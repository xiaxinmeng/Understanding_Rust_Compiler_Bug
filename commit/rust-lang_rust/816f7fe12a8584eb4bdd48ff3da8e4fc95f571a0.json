{"sha": "816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "node_id": "C_kwDOAAsO6NoAKDgxNmY3ZmUxMmE4NTg0ZWI0YmRkNDhmZjNkYThlNGZjOTVmNTcxYTA", "commit": {"author": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-07-20T13:02:08Z"}, "committer": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-07-20T13:02:08Z"}, "message": "Run cargo fix --edition-idioms", "tree": {"sha": "a855b8bf05bb903a03de17a6842d32c89abcea1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a855b8bf05bb903a03de17a6842d32c89abcea1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "html_url": "https://github.com/rust-lang/rust/commit/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/comments", "author": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23d25a3094ec89fca610cd2e0d3434e36a4f11ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/23d25a3094ec89fca610cd2e0d3434e36a4f11ab", "html_url": "https://github.com/rust-lang/rust/commit/23d25a3094ec89fca610cd2e0d3434e36a4f11ab"}], "stats": {"total": 1776, "additions": 888, "deletions": 888}, "files": [{"sha": "b57f2345767d0fa45ee6ebde1607d5a8343cbded", "filename": "crates/base-db/src/change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fbase-db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fbase-db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Fchange.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -17,7 +17,7 @@ pub struct Change {\n }\n \n impl fmt::Debug for Change {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut d = fmt.debug_struct(\"Change\");\n         if let Some(roots) = &self.roots {\n             d.field(\"roots\", roots);"}, {"sha": "9b5a10acfbeaf90711e17c66c21b24105557a665", "filename": "crates/base-db/src/input.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Finput.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -104,7 +104,7 @@ impl CrateName {\n }\n \n impl fmt::Display for CrateName {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.0.fmt(f)\n     }\n }\n@@ -187,7 +187,7 @@ impl From<CrateName> for CrateDisplayName {\n }\n \n impl fmt::Display for CrateDisplayName {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.crate_name.fmt(f)\n     }\n }"}, {"sha": "2d0a95b09d9a1a5b7d0bcb5116ad0572f4a1930f", "filename": "crates/base-db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fbase-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fbase-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Flib.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -57,7 +57,7 @@ pub const DEFAULT_LRU_CAP: usize = 128;\n pub trait FileLoader {\n     /// Text of the file.\n     fn file_text(&self, file_id: FileId) -> Arc<String>;\n-    fn resolve_path(&self, path: AnchoredPath) -> Option<FileId>;\n+    fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId>;\n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>>;\n }\n \n@@ -116,7 +116,7 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n     fn file_text(&self, file_id: FileId) -> Arc<String> {\n         SourceDatabaseExt::file_text(self.0, file_id)\n     }\n-    fn resolve_path(&self, path: AnchoredPath) -> Option<FileId> {\n+    fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         // FIXME: this *somehow* should be platform agnostic...\n         let source_root = self.0.file_source_root(path.anchor);\n         let source_root = self.0.source_root(source_root);"}, {"sha": "fd9e31ed3b4f52472a47659ca7f159329e87c223", "filename": "crates/cfg/src/cfg_expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -85,7 +85,7 @@ impl CfgExpr {\n     }\n }\n \n-fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n+fn next_cfg_expr(it: &mut SliceIter<'_, tt::TokenTree>) -> Option<CfgExpr> {\n     let name = match it.next() {\n         None => return None,\n         Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) => ident.text.clone(),"}, {"sha": "2397cf5015848038b2b2401d8b600b89534aaeaa", "filename": "crates/hir-def/src/generics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -195,7 +195,7 @@ impl GenericParams {\n         }\n     }\n \n-    pub(crate) fn fill(&mut self, lower_ctx: &LowerCtx, node: &dyn HasGenericParams) {\n+    pub(crate) fn fill(&mut self, lower_ctx: &LowerCtx<'_>, node: &dyn HasGenericParams) {\n         if let Some(params) = node.generic_param_list() {\n             self.fill_params(lower_ctx, params)\n         }\n@@ -206,7 +206,7 @@ impl GenericParams {\n \n     pub(crate) fn fill_bounds(\n         &mut self,\n-        lower_ctx: &LowerCtx,\n+        lower_ctx: &LowerCtx<'_>,\n         node: &dyn ast::HasTypeBounds,\n         target: Either<TypeRef, LifetimeRef>,\n     ) {\n@@ -217,7 +217,7 @@ impl GenericParams {\n         }\n     }\n \n-    fn fill_params(&mut self, lower_ctx: &LowerCtx, params: ast::GenericParamList) {\n+    fn fill_params(&mut self, lower_ctx: &LowerCtx<'_>, params: ast::GenericParamList) {\n         for type_or_const_param in params.type_or_const_params() {\n             match type_or_const_param {\n                 ast::TypeOrConstParam::Type(type_param) => {\n@@ -259,7 +259,7 @@ impl GenericParams {\n         }\n     }\n \n-    fn fill_where_predicates(&mut self, lower_ctx: &LowerCtx, where_clause: ast::WhereClause) {\n+    fn fill_where_predicates(&mut self, lower_ctx: &LowerCtx<'_>, where_clause: ast::WhereClause) {\n         for pred in where_clause.predicates() {\n             let target = if let Some(type_ref) = pred.ty() {\n                 Either::Left(TypeRef::from_ast(lower_ctx, type_ref))\n@@ -293,7 +293,7 @@ impl GenericParams {\n \n     fn add_where_predicate_from_bound(\n         &mut self,\n-        lower_ctx: &LowerCtx,\n+        lower_ctx: &LowerCtx<'_>,\n         bound: ast::TypeBound,\n         hrtb_lifetimes: Option<&Box<[Name]>>,\n         target: Either<TypeRef, LifetimeRef>,"}, {"sha": "5f40d26a2ed7e859262cff5bc5e2810625abf81d", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -1509,7 +1509,7 @@ impl ModCollector<'_, '_> {\n             let module = self.def_collector.def_map.module_id(self.module_id);\n             let def_map = &mut self.def_collector.def_map;\n             let update_def =\n-                |def_collector: &mut DefCollector, id, name: &Name, vis, has_constructor| {\n+                |def_collector: &mut DefCollector<'_>, id, name: &Name, vis, has_constructor| {\n                     def_collector.def_map.modules[self.module_id].scope.declare(id);\n                     def_collector.update(\n                         self.module_id,"}, {"sha": "7af7e5574dd1094735134cce1a01a2eac7fdf25a", "filename": "crates/hir-def/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -88,7 +88,7 @@ pub enum GenericArg {\n impl Path {\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// It correctly handles `$crate` based path from macro call.\n-    pub fn from_src(path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n+    pub fn from_src(path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path> {\n         lower::lower_path(path, ctx)\n     }\n \n@@ -188,7 +188,7 @@ impl<'a> PathSegments<'a> {\n }\n \n impl GenericArgs {\n-    pub(crate) fn from_ast(lower_ctx: &LowerCtx, node: ast::GenericArgList) -> Option<GenericArgs> {\n+    pub(crate) fn from_ast(lower_ctx: &LowerCtx<'_>, node: ast::GenericArgList) -> Option<GenericArgs> {\n         lower::lower_generic_args(lower_ctx, node)\n     }\n "}, {"sha": "0428f1a398b1a7e9d97daadf9f7ce5dc0fd5cc6e", "filename": "crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -15,7 +15,7 @@ use crate::{\n \n /// Converts an `ast::Path` to `Path`. Works with use trees.\n /// It correctly handles `$crate` based path from macro call.\n-pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n+pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path> {\n     let mut kind = PathKind::Plain;\n     let mut type_anchor = None;\n     let mut segments = Vec::new();\n@@ -149,7 +149,7 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n }\n \n pub(super) fn lower_generic_args(\n-    lower_ctx: &LowerCtx,\n+    lower_ctx: &LowerCtx<'_>,\n     node: ast::GenericArgList,\n ) -> Option<GenericArgs> {\n     let mut args = Vec::new();\n@@ -196,7 +196,7 @@ pub(super) fn lower_generic_args(\n /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n /// -> Z` (which desugars to `Fn<(X, Y), Output=Z>`).\n fn lower_generic_args_from_fn_path(\n-    ctx: &LowerCtx,\n+    ctx: &LowerCtx<'_>,\n     params: Option<ast::ParamList>,\n     ret_type: Option<ast::RetType>,\n ) -> Option<GenericArgs> {"}, {"sha": "9cdc18d6b66fdfb07ba53e85dcb00a65cc4aede7", "filename": "crates/hir-def/src/test_db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftest_db.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -73,7 +73,7 @@ impl FileLoader for TestDB {\n     fn file_text(&self, file_id: FileId) -> Arc<String> {\n         FileLoaderDelegate(self).file_text(file_id)\n     }\n-    fn resolve_path(&self, path: AnchoredPath) -> Option<FileId> {\n+    fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         FileLoaderDelegate(self).resolve_path(path)\n     }\n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {"}, {"sha": "97aeed819af0f5f1cde2ba0a7afff14262f91bbc", "filename": "crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -86,7 +86,7 @@ pub struct TraitRef {\n \n impl TraitRef {\n     /// Converts an `ast::PathType` to a `hir::TraitRef`.\n-    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::Type) -> Option<Self> {\n+    pub(crate) fn from_ast(ctx: &LowerCtx<'_>, node: ast::Type) -> Option<Self> {\n         // FIXME: Use `Path::from_src`\n         match node {\n             ast::Type::PathType(path) => {\n@@ -159,7 +159,7 @@ pub enum TraitBoundModifier {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub fn from_ast(ctx: &LowerCtx, node: ast::Type) -> Self {\n+    pub fn from_ast(ctx: &LowerCtx<'_>, node: ast::Type) -> Self {\n         match node {\n             ast::Type::ParenType(inner) => TypeRef::from_ast_opt(ctx, inner.ty()),\n             ast::Type::TupleType(inner) => {\n@@ -245,7 +245,7 @@ impl TypeRef {\n         }\n     }\n \n-    pub(crate) fn from_ast_opt(ctx: &LowerCtx, node: Option<ast::Type>) -> Self {\n+    pub(crate) fn from_ast_opt(ctx: &LowerCtx<'_>, node: Option<ast::Type>) -> Self {\n         match node {\n             Some(node) => TypeRef::from_ast(ctx, node),\n             None => TypeRef::Error,\n@@ -320,7 +320,7 @@ impl TypeRef {\n }\n \n pub(crate) fn type_bounds_from_ast(\n-    lower_ctx: &LowerCtx,\n+    lower_ctx: &LowerCtx<'_>,\n     type_bounds_opt: Option<ast::TypeBoundList>,\n ) -> Vec<Interned<TypeBound>> {\n     if let Some(type_bounds) = type_bounds_opt {\n@@ -331,7 +331,7 @@ pub(crate) fn type_bounds_from_ast(\n }\n \n impl TypeBound {\n-    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::TypeBound) -> Self {\n+    pub(crate) fn from_ast(ctx: &LowerCtx<'_>, node: ast::TypeBound) -> Self {\n         let lower_path_type = |path_type: ast::PathType| ctx.lower_path(path_type.path()?);\n \n         match node.kind() {"}, {"sha": "fea09521e87cb6f96aeac38730a65df3739d7e5b", "filename": "crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -102,7 +102,7 @@ impl ModPath {\n         }\n     }\n \n-    pub fn escaped(&self) -> EscapedModPath {\n+    pub fn escaped(&self) -> EscapedModPath<'_> {\n         EscapedModPath(self)\n     }\n "}, {"sha": "85b0a7735fe94e9fc4255b89c414b36f2865eabc", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -21,7 +21,7 @@ enum Repr {\n }\n \n impl fmt::Display for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match &self.0 {\n             Repr::Text(text) => fmt::Display::fmt(&text, f),\n             Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n@@ -35,7 +35,7 @@ fn is_raw_identifier(name: &str) -> bool {\n }\n \n impl<'a> fmt::Display for EscapedName<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match &self.0 .0 {\n             Repr::Text(text) => {\n                 if is_raw_identifier(text) {\n@@ -142,7 +142,7 @@ impl Name {\n         }\n     }\n \n-    pub fn escaped(&self) -> EscapedName {\n+    pub fn escaped(&self) -> EscapedName<'_> {\n         EscapedName(self)\n     }\n }"}, {"sha": "837049cea35c82479ad6621d6590c8e6e27be252", "filename": "crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -70,7 +70,7 @@ impl Iterator for Autoderef<'_, '_> {\n     }\n }\n \n-pub(crate) fn autoderef_step(table: &mut InferenceTable, ty: Ty) -> Option<(AutoderefKind, Ty)> {\n+pub(crate) fn autoderef_step(table: &mut InferenceTable<'_>, ty: Ty) -> Option<(AutoderefKind, Ty)> {\n     if let Some(derefed) = builtin_deref(&ty) {\n         Some((AutoderefKind::Builtin, table.resolve_ty_shallow(derefed)))\n     } else {\n@@ -94,7 +94,7 @@ pub fn autoderef<'a>(\n     v.into_iter()\n }\n \n-pub(crate) fn deref(table: &mut InferenceTable, ty: Ty) -> Option<Ty> {\n+pub(crate) fn deref(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n     let _p = profile::span(\"deref\");\n     autoderef_step(table, ty).map(|(_, ty)| ty)\n }\n@@ -107,7 +107,7 @@ fn builtin_deref(ty: &Ty) -> Option<&Ty> {\n     }\n }\n \n-fn deref_by_trait(table: &mut InferenceTable, ty: Ty) -> Option<Ty> {\n+fn deref_by_trait(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n     let _p = profile::span(\"deref_by_trait\");\n     if table.resolve_ty_shallow(&ty).inference_var(Interner).is_some() {\n         // don't try to deref unknown variables"}, {"sha": "94d7806cb6e8f261d6a3d686ceb18f4a5b0d5b07", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -111,7 +111,7 @@ impl<D> TyBuilder<D> {\n         this\n     }\n \n-    pub(crate) fn fill_with_inference_vars(self, table: &mut InferenceTable) -> Self {\n+    pub(crate) fn fill_with_inference_vars(self, table: &mut InferenceTable<'_>) -> Self {\n         self.fill(|x| match x {\n             ParamKind::Type => GenericArgData::Ty(table.new_type_var()).intern(Interner),\n             ParamKind::Const(ty) => {"}, {"sha": "d51ad72bd27b12bd8fb6f8da8d7f0a9ae461a834", "filename": "crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -292,7 +292,7 @@ impl<'a> PatCtxt<'a> {\n }\n \n impl HirDisplay for Pat {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match &*self.kind {\n             PatKind::Wild => write!(f, \"_\"),\n             PatKind::Binding { name, subpattern } => {\n@@ -394,11 +394,11 @@ impl HirDisplay for Pat {\n \n struct WriteWith<F>(F)\n where\n-    F: Fn(&mut HirFormatter) -> Result<(), HirDisplayError>;\n+    F: Fn(&mut HirFormatter<'_>) -> Result<(), HirDisplayError>;\n \n impl<F> HirDisplay for WriteWith<F>\n where\n-    F: Fn(&mut HirFormatter) -> Result<(), HirDisplayError>,\n+    F: Fn(&mut HirFormatter<'_>) -> Result<(), HirDisplayError>,\n {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         (self.0)(f)"}, {"sha": "bbbe539c13fbe2c94b1bb05c5c5ed3e9928398da", "filename": "crates/hir-ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -144,7 +144,7 @@ impl IntRange {\n         }\n     }\n \n-    fn to_pat(&self, _cx: &MatchCheckCtx, ty: Ty) -> Pat {\n+    fn to_pat(&self, _cx: &MatchCheckCtx<'_, '_>, ty: Ty) -> Pat {\n         match ty.kind(Interner) {\n             TyKind::Scalar(Scalar::Bool) => {\n                 let kind = match self.boundaries() {"}, {"sha": "6cd3e2b382d78f6ec22d2a270471f2b14429eacb", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -45,7 +45,7 @@ pub struct HirFormatter<'a> {\n }\n \n pub trait HirDisplay {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError>;\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError>;\n \n     /// Returns a `Display`able type that is human-readable.\n     fn into_displayable<'a>(\n@@ -162,7 +162,7 @@ impl<'a> HirFormatter<'a> {\n     }\n \n     /// This allows using the `write!` macro directly with a `HirFormatter`.\n-    pub fn write_fmt(&mut self, args: fmt::Arguments) -> Result<(), HirDisplayError> {\n+    pub fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> Result<(), HirDisplayError> {\n         // We write to a buffer first to track output size\n         self.buf.clear();\n         fmt::write(&mut self.buf, args)?;\n@@ -247,7 +247,7 @@ impl<'a, T> fmt::Display for HirDisplayWrapper<'a, T>\n where\n     T: HirDisplay,\n {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.t.hir_fmt(&mut HirFormatter {\n             db: self.db,\n             fmt: f,\n@@ -270,19 +270,19 @@ where\n const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n \n impl<T: HirDisplay> HirDisplay for &'_ T {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(*self, f)\n     }\n }\n \n impl<T: HirDisplay + Internable> HirDisplay for Interned<T> {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(self.as_ref(), f)\n     }\n }\n \n impl HirDisplay for ProjectionTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -302,7 +302,7 @@ impl HirDisplay for ProjectionTy {\n }\n \n impl HirDisplay for OpaqueTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -312,7 +312,7 @@ impl HirDisplay for OpaqueTy {\n }\n \n impl HirDisplay for GenericArg {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self.interned() {\n             crate::GenericArgData::Ty(ty) => ty.hir_fmt(f),\n             crate::GenericArgData::Lifetime(lt) => lt.hir_fmt(f),\n@@ -322,7 +322,7 @@ impl HirDisplay for GenericArg {\n }\n \n impl HirDisplay for Const {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         let data = self.interned();\n         match data.value {\n             ConstValue::BoundVar(idx) => idx.hir_fmt(f),\n@@ -339,13 +339,13 @@ impl HirDisplay for Const {\n }\n \n impl HirDisplay for BoundVar {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write!(f, \"?{}.{}\", self.debruijn.depth(), self.index)\n     }\n }\n \n impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -790,7 +790,7 @@ impl HirDisplay for Ty {\n }\n \n impl HirDisplay for CallableSig {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write!(f, \"fn(\")?;\n         f.write_joined(self.params(), \", \")?;\n         if self.is_varargs {\n@@ -839,7 +839,7 @@ pub fn write_bounds_like_dyn_trait_with_prefix(\n     prefix: &str,\n     predicates: &[QuantifiedWhereClause],\n     default_sized: SizedByDefault,\n-    f: &mut HirFormatter,\n+    f: &mut HirFormatter<'_>,\n ) -> Result<(), HirDisplayError> {\n     write!(f, \"{}\", prefix)?;\n     if !predicates.is_empty()\n@@ -855,7 +855,7 @@ pub fn write_bounds_like_dyn_trait_with_prefix(\n fn write_bounds_like_dyn_trait(\n     predicates: &[QuantifiedWhereClause],\n     default_sized: SizedByDefault,\n-    f: &mut HirFormatter,\n+    f: &mut HirFormatter<'_>,\n ) -> Result<(), HirDisplayError> {\n     // Note: This code is written to produce nice results (i.e.\n     // corresponding to surface Rust) for types that can occur in\n@@ -952,7 +952,7 @@ fn write_bounds_like_dyn_trait(\n     Ok(())\n }\n \n-fn fmt_trait_ref(tr: &TraitRef, f: &mut HirFormatter, use_as: bool) -> Result<(), HirDisplayError> {\n+fn fmt_trait_ref(tr: &TraitRef, f: &mut HirFormatter<'_>, use_as: bool) -> Result<(), HirDisplayError> {\n     if f.should_truncate() {\n         return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n     }\n@@ -973,13 +973,13 @@ fn fmt_trait_ref(tr: &TraitRef, f: &mut HirFormatter, use_as: bool) -> Result<()\n }\n \n impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         fmt_trait_ref(self, f, false)\n     }\n }\n \n impl HirDisplay for WhereClause {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -1007,21 +1007,21 @@ impl HirDisplay for WhereClause {\n }\n \n impl HirDisplay for LifetimeOutlives {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         self.a.hir_fmt(f)?;\n         write!(f, \": \")?;\n         self.b.hir_fmt(f)\n     }\n }\n \n impl HirDisplay for Lifetime {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         self.interned().hir_fmt(f)\n     }\n }\n \n impl HirDisplay for LifetimeData {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self {\n             LifetimeData::BoundVar(idx) => idx.hir_fmt(f),\n             LifetimeData::InferenceVar(_) => write!(f, \"_\"),\n@@ -1040,7 +1040,7 @@ impl HirDisplay for LifetimeData {\n }\n \n impl HirDisplay for DomainGoal {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self {\n             DomainGoal::Holds(wc) => {\n                 write!(f, \"Holds(\")?;\n@@ -1056,7 +1056,7 @@ impl HirDisplay for DomainGoal {\n pub fn write_visibility(\n     module_id: ModuleId,\n     vis: Visibility,\n-    f: &mut HirFormatter,\n+    f: &mut HirFormatter<'_>,\n ) -> Result<(), HirDisplayError> {\n     match vis {\n         Visibility::Public => write!(f, \"pub \"),\n@@ -1078,7 +1078,7 @@ pub fn write_visibility(\n }\n \n impl HirDisplay for TypeRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self {\n             TypeRef::Never => write!(f, \"!\")?,\n             TypeRef::Placeholder => write!(f, \"_\")?,\n@@ -1177,7 +1177,7 @@ impl HirDisplay for TypeRef {\n }\n \n impl HirDisplay for TypeBound {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self {\n             TypeBound::Path(path, modifier) => {\n                 match modifier {\n@@ -1197,7 +1197,7 @@ impl HirDisplay for TypeBound {\n }\n \n impl HirDisplay for Path {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match (self.type_anchor(), self.kind()) {\n             (Some(anchor), _) => {\n                 write!(f, \"<\")?;\n@@ -1301,7 +1301,7 @@ impl HirDisplay for Path {\n }\n \n impl HirDisplay for hir_def::path::GenericArg {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self {\n             hir_def::path::GenericArg::Type(ty) => ty.hir_fmt(f),\n             hir_def::path::GenericArg::Const(c) => write!(f, \"{}\", c),"}, {"sha": "0a64b929a129605dcda5649ce06fc0c16ad738a5", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -130,7 +130,7 @@ trait PatLike: Into<ExprOrPatId> + Copy {\n     type BindingMode: Copy;\n \n     fn infer(\n-        this: &mut InferenceContext,\n+        this: &mut InferenceContext<'_>,\n         id: Self,\n         expected_ty: &Ty,\n         default_bm: Self::BindingMode,\n@@ -140,7 +140,7 @@ trait PatLike: Into<ExprOrPatId> + Copy {\n impl PatLike for ExprId {\n     type BindingMode = ();\n \n-    fn infer(this: &mut InferenceContext, id: Self, expected_ty: &Ty, _: Self::BindingMode) -> Ty {\n+    fn infer(this: &mut InferenceContext<'_>, id: Self, expected_ty: &Ty, _: Self::BindingMode) -> Ty {\n         this.infer_assignee_expr(id, expected_ty)\n     }\n }\n@@ -149,7 +149,7 @@ impl PatLike for PatId {\n     type BindingMode = BindingMode;\n \n     fn infer(\n-        this: &mut InferenceContext,\n+        this: &mut InferenceContext<'_>,\n         id: Self,\n         expected_ty: &Ty,\n         default_bm: Self::BindingMode,\n@@ -971,7 +971,7 @@ impl Expectation {\n     /// which still is useful, because it informs integer literals and the like.\n     /// See the test case `test/ui/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n-    fn rvalue_hint(table: &mut unify::InferenceTable, ty: Ty) -> Self {\n+    fn rvalue_hint(table: &mut unify::InferenceTable<'_>, ty: Ty) -> Self {\n         // FIXME: do struct_tail_without_normalization\n         match table.resolve_ty_shallow(&ty).kind(Interner) {\n             TyKind::Slice(_) | TyKind::Str | TyKind::Dyn(_) => Expectation::RValueLikeUnsized(ty),\n@@ -984,7 +984,7 @@ impl Expectation {\n         Expectation::None\n     }\n \n-    fn resolve(&self, table: &mut unify::InferenceTable) -> Expectation {\n+    fn resolve(&self, table: &mut unify::InferenceTable<'_>) -> Expectation {\n         match self {\n             Expectation::None => Expectation::None,\n             Expectation::HasType(t) => Expectation::HasType(table.resolve_ty_shallow(t)),\n@@ -994,7 +994,7 @@ impl Expectation {\n         }\n     }\n \n-    fn to_option(&self, table: &mut unify::InferenceTable) -> Option<Ty> {\n+    fn to_option(&self, table: &mut unify::InferenceTable<'_>) -> Option<Ty> {\n         match self.resolve(table) {\n             Expectation::None => None,\n             Expectation::HasType(t) |\n@@ -1003,7 +1003,7 @@ impl Expectation {\n         }\n     }\n \n-    fn only_has_type(&self, table: &mut unify::InferenceTable) -> Option<Ty> {\n+    fn only_has_type(&self, table: &mut unify::InferenceTable<'_>) -> Option<Ty> {\n         match self {\n             Expectation::HasType(t) => Some(table.resolve_ty_shallow(t)),\n             // Expectation::Castable(_) |\n@@ -1028,7 +1028,7 @@ impl Expectation {\n     /// an expected type. Otherwise, we might write parts of the type\n     /// when checking the 'then' block which are incompatible with the\n     /// 'else' branch.\n-    fn adjust_for_branches(&self, table: &mut unify::InferenceTable) -> Expectation {\n+    fn adjust_for_branches(&self, table: &mut unify::InferenceTable<'_>) -> Expectation {\n         match self {\n             Expectation::HasType(ety) => {\n                 let ety = table.resolve_ty_shallow(ety);"}, {"sha": "e77b55670b5e1b6c3881129d3497e82d06c39c37", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -43,7 +43,7 @@ where\n impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n     pub(super) fn apply_solution(\n         &self,\n-        ctx: &mut InferenceTable,\n+        ctx: &mut InferenceTable<'_>,\n         solution: Canonical<Substitution>,\n     ) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n@@ -391,7 +391,7 @@ impl<'a> InferenceTable<'a> {\n         self.pending_obligations = snapshot.pending_obligations;\n     }\n \n-    pub(crate) fn run_in_snapshot<T>(&mut self, f: impl FnOnce(&mut InferenceTable) -> T) -> T {\n+    pub(crate) fn run_in_snapshot<T>(&mut self, f: impl FnOnce(&mut InferenceTable<'_>) -> T) -> T {\n         let snapshot = self.snapshot();\n         let result = f(self);\n         self.rollback_to(snapshot);"}, {"sha": "ca76e08fddb915ee1b10597a6149ab3295177c77", "filename": "crates/hir-ty/src/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finterner.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -168,7 +168,7 @@ impl chalk_ir::interner::Interner for Interner {\n     }\n \n     fn debug_separator_trait_ref(\n-        separator_trait_ref: &chalk_ir::SeparatorTraitRef<Interner>,\n+        separator_trait_ref: &chalk_ir::SeparatorTraitRef<'_, Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n         Some(write!(fmt, \"{:?}\", separator_trait_ref.debug(Interner)))"}, {"sha": "a9420514a2bc277cf88bcd6c60b335ac4045533f", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -106,7 +106,7 @@ impl<'a> TyLoweringContext<'a> {\n     pub fn with_debruijn<T>(\n         &self,\n         debruijn: DebruijnIndex,\n-        f: impl FnOnce(&TyLoweringContext) -> T,\n+        f: impl FnOnce(&TyLoweringContext<'_>) -> T,\n     ) -> T {\n         let opaque_ty_data_vec = self.opaque_type_data.take();\n         let expander = self.expander.take();\n@@ -130,7 +130,7 @@ impl<'a> TyLoweringContext<'a> {\n     pub fn with_shifted_in<T>(\n         &self,\n         debruijn: DebruijnIndex,\n-        f: impl FnOnce(&TyLoweringContext) -> T,\n+        f: impl FnOnce(&TyLoweringContext<'_>) -> T,\n     ) -> T {\n         self.with_debruijn(self.in_binders.shifted_in_from(debruijn), f)\n     }"}, {"sha": "b5810ad0544395dc300c040ed7b9d899fc76d901", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -492,7 +492,7 @@ pub struct ReceiverAdjustments {\n }\n \n impl ReceiverAdjustments {\n-    pub(crate) fn apply(&self, table: &mut InferenceTable, ty: Ty) -> (Ty, Vec<Adjustment>) {\n+    pub(crate) fn apply(&self, table: &mut InferenceTable<'_>, ty: Ty) -> (Ty, Vec<Adjustment>) {\n         let mut ty = ty;\n         let mut adjust = Vec::new();\n         for _ in 0..self.autoderefs {\n@@ -597,7 +597,7 @@ pub fn lookup_impl_method(\n \n fn find_matching_impl(\n     mut impls: impl Iterator<Item = ImplId>,\n-    table: &mut InferenceTable,\n+    table: &mut InferenceTable<'_>,\n     self_ty: &Ty,\n ) -> Option<Arc<ImplData>> {\n     let db = table.db;\n@@ -856,7 +856,7 @@ fn iterate_method_candidates_for_self_ty(\n \n fn iterate_trait_method_candidates(\n     self_ty: &Ty,\n-    table: &mut InferenceTable,\n+    table: &mut InferenceTable<'_>,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Ty>,\n@@ -922,7 +922,7 @@ fn iterate_trait_method_candidates(\n \n fn iterate_inherent_methods(\n     self_ty: &Ty,\n-    table: &mut InferenceTable,\n+    table: &mut InferenceTable<'_>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Ty>,\n     receiver_adjustments: Option<ReceiverAdjustments>,\n@@ -975,7 +975,7 @@ fn iterate_inherent_methods(\n     fn impls_for_self_ty(\n         impls: &InherentImpls,\n         self_ty: &Ty,\n-        table: &mut InferenceTable,\n+        table: &mut InferenceTable<'_>,\n         name: Option<&Name>,\n         receiver_ty: Option<&Ty>,\n         receiver_adjustments: Option<ReceiverAdjustments>,\n@@ -1017,7 +1017,7 @@ pub fn resolve_indexing_op(\n }\n \n fn is_valid_candidate(\n-    table: &mut InferenceTable,\n+    table: &mut InferenceTable<'_>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Ty>,\n     item: AssocItemId,\n@@ -1161,7 +1161,7 @@ fn generic_implements_goal(\n }\n \n fn autoderef_method_receiver(\n-    table: &mut InferenceTable,\n+    table: &mut InferenceTable<'_>,\n     ty: Ty,\n ) -> (Vec<Canonical<Ty>>, Vec<ReceiverAdjustments>) {\n     let (mut deref_chain, mut adjustments): (Vec<_>, Vec<_>) = (Vec::new(), Vec::new());"}, {"sha": "dc7252f7072d86a052eb2c2d365938bcf867bb28", "filename": "crates/hir-ty/src/test_db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftest_db.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -77,7 +77,7 @@ impl FileLoader for TestDB {\n     fn file_text(&self, file_id: FileId) -> Arc<String> {\n         FileLoaderDelegate(self).file_text(file_id)\n     }\n-    fn resolve_path(&self, path: AnchoredPath) -> Option<FileId> {\n+    fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         FileLoaderDelegate(self).resolve_path(path)\n     }\n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {"}, {"sha": "547850b021c3cef706d1181ce8f9a16ea93d9822", "filename": "crates/hir-ty/src/tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftls.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -104,7 +104,7 @@ mod unsafe_tls {\n     use crate::db::HirDatabase;\n     use scoped_tls::scoped_thread_local;\n \n-    scoped_thread_local!(static PROGRAM: DebugContext);\n+    scoped_thread_local!(static PROGRAM: DebugContext<'_>);\n \n     pub(crate) fn with_current_program<R>(\n         op: impl for<'a> FnOnce(Option<&'a DebugContext<'a>>) -> R,\n@@ -127,7 +127,7 @@ mod unsafe_tls {\n         // `with_current_program`, which hides the lifetime through the `for`\n         // type.\n         let static_p: &DebugContext<'static> =\n-            unsafe { std::mem::transmute::<&DebugContext, &DebugContext<'static>>(&ctx) };\n+            unsafe { std::mem::transmute::<&DebugContext<'_>, &DebugContext<'static>>(&ctx) };\n         PROGRAM.set(static_p, op)\n     }\n }"}, {"sha": "83319755da73aa5fbce84053edf06cbbcd9a7e8f", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -130,7 +130,7 @@ pub fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[Trai\n /// `all_super_traits` is that we keep track of type parameters; for example if\n /// we have `Self: Trait<u32, i32>` and `Trait<T, U>: OtherTrait<U>` we'll get\n /// `Self: OtherTrait<i32>`.\n-pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) -> SuperTraits {\n+pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) -> SuperTraits<'_> {\n     SuperTraits { db, seen: iter::once(trait_ref.trait_id).collect(), stack: vec![trait_ref] }\n }\n "}, {"sha": "dda9d4a9d527b3799a72ce6a2d314006b8c81d68", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -23,7 +23,7 @@ use crate::{\n };\n \n impl HirDisplay for Function {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         let data = f.db.function_data(self.id);\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         if data.has_default_kw() {\n@@ -48,7 +48,7 @@ impl HirDisplay for Function {\n \n         f.write_char('(')?;\n \n-        let write_self_param = |ty: &TypeRef, f: &mut HirFormatter| match ty {\n+        let write_self_param = |ty: &TypeRef, f: &mut HirFormatter<'_>| match ty {\n             TypeRef::Path(p) if p.is_self_type() => f.write_str(\"self\"),\n             TypeRef::Reference(inner, lifetime, mut_) if matches!(&**inner,TypeRef::Path(p) if p.is_self_type()) =>\n             {\n@@ -129,7 +129,7 @@ impl HirDisplay for Function {\n }\n \n impl HirDisplay for Adt {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self {\n             Adt::Struct(it) => it.hir_fmt(f),\n             Adt::Union(it) => it.hir_fmt(f),\n@@ -139,7 +139,7 @@ impl HirDisplay for Adt {\n }\n \n impl HirDisplay for Struct {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         f.write_str(\"struct \")?;\n         write!(f, \"{}\", self.name(f.db))?;\n@@ -151,7 +151,7 @@ impl HirDisplay for Struct {\n }\n \n impl HirDisplay for Enum {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         f.write_str(\"enum \")?;\n         write!(f, \"{}\", self.name(f.db))?;\n@@ -163,7 +163,7 @@ impl HirDisplay for Enum {\n }\n \n impl HirDisplay for Union {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         f.write_str(\"union \")?;\n         write!(f, \"{}\", self.name(f.db))?;\n@@ -175,15 +175,15 @@ impl HirDisplay for Union {\n }\n \n impl HirDisplay for Field {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.parent.module(f.db).id, self.visibility(f.db), f)?;\n         write!(f, \"{}: \", self.name(f.db))?;\n         self.ty(f.db).hir_fmt(f)\n     }\n }\n \n impl HirDisplay for Variant {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write!(f, \"{}\", self.name(f.db))?;\n         let data = self.variant_data(f.db);\n         match &*data {\n@@ -224,13 +224,13 @@ impl HirDisplay for Variant {\n }\n \n impl HirDisplay for Type {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         self.ty.hir_fmt(f)\n     }\n }\n \n impl HirDisplay for GenericParam {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self {\n             GenericParam::TypeParam(it) => it.hir_fmt(f),\n             GenericParam::ConstParam(it) => it.hir_fmt(f),\n@@ -240,7 +240,7 @@ impl HirDisplay for GenericParam {\n }\n \n impl HirDisplay for TypeOrConstParam {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self.split(f.db) {\n             either::Either::Left(x) => x.hir_fmt(f),\n             either::Either::Right(x) => x.hir_fmt(f),\n@@ -249,7 +249,7 @@ impl HirDisplay for TypeOrConstParam {\n }\n \n impl HirDisplay for TypeParam {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write!(f, \"{}\", self.name(f.db))?;\n         if f.omit_verbose_types() {\n             return Ok(());\n@@ -277,19 +277,19 @@ impl HirDisplay for TypeParam {\n }\n \n impl HirDisplay for LifetimeParam {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write!(f, \"{}\", self.name(f.db))\n     }\n }\n \n impl HirDisplay for ConstParam {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write!(f, \"const {}: \", self.name(f.db))?;\n         self.ty(f.db).hir_fmt(f)\n     }\n }\n \n-fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+fn write_generic_params(def: GenericDefId, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n     let params = f.db.generic_params(def);\n     if params.lifetimes.is_empty()\n         && params.type_or_consts.iter().all(|x| x.1.const_param().is_none())\n@@ -304,7 +304,7 @@ fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), H\n     f.write_char('<')?;\n \n     let mut first = true;\n-    let mut delim = |f: &mut HirFormatter| {\n+    let mut delim = |f: &mut HirFormatter<'_>| {\n         if first {\n             first = false;\n             Ok(())\n@@ -343,7 +343,7 @@ fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), H\n     Ok(())\n }\n \n-fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+fn write_where_clause(def: GenericDefId, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n     let params = f.db.generic_params(def);\n \n     // unnamed type targets are displayed inline with the argument itself, e.g. `f: impl Y`.\n@@ -365,7 +365,7 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), Hir\n         return Ok(());\n     }\n \n-    let write_target = |target: &WherePredicateTypeTarget, f: &mut HirFormatter| match target {\n+    let write_target = |target: &WherePredicateTypeTarget, f: &mut HirFormatter<'_>| match target {\n         WherePredicateTypeTarget::TypeRef(ty) => ty.hir_fmt(f),\n         WherePredicateTypeTarget::TypeOrConstParam(id) => {\n             match &params.type_or_consts[*id].name() {\n@@ -382,7 +382,7 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), Hir\n             if pred_idx == 0 { None } else { Some(&params.where_predicates[pred_idx - 1]) };\n \n         let new_predicate =\n-            |f: &mut HirFormatter| f.write_str(if pred_idx == 0 { \"\\n    \" } else { \",\\n    \" });\n+            |f: &mut HirFormatter<'_>| f.write_str(if pred_idx == 0 { \"\\n    \" } else { \",\\n    \" });\n \n         match pred {\n             WherePredicate::TypeBound { target, .. } if is_unnamed_type_target(target) => {}\n@@ -438,7 +438,7 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), Hir\n }\n \n impl HirDisplay for Const {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         let data = f.db.const_data(self.id);\n         f.write_str(\"const \")?;\n@@ -452,7 +452,7 @@ impl HirDisplay for Const {\n }\n \n impl HirDisplay for Static {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         let data = f.db.static_data(self.id);\n         f.write_str(\"static \")?;\n@@ -466,7 +466,7 @@ impl HirDisplay for Static {\n }\n \n impl HirDisplay for Trait {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         let data = f.db.trait_data(self.id);\n         if data.is_unsafe {\n@@ -484,7 +484,7 @@ impl HirDisplay for Trait {\n }\n \n impl HirDisplay for TypeAlias {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         let data = f.db.type_alias_data(self.id);\n         write!(f, \"type {}\", data.name)?;\n@@ -501,7 +501,7 @@ impl HirDisplay for TypeAlias {\n }\n \n impl HirDisplay for Module {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         // FIXME: Module doesn't have visibility saved in data.\n         match self.name(f.db) {\n             Some(name) => write!(f, \"mod {}\", name),\n@@ -515,7 +515,7 @@ impl HirDisplay for Module {\n }\n \n impl HirDisplay for Macro {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self.id {\n             hir_def::MacroId::Macro2Id(_) => f.write_str(\"macro\"),\n             hir_def::MacroId::MacroRulesId(_) => f.write_str(\"macro_rules!\"),"}, {"sha": "9ffbb3964cf1134e5c89193a7bb9f2238ef5da4b", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -3028,7 +3028,7 @@ impl Type {\n     pub fn iterate_method_candidates<T>(\n         &self,\n         db: &dyn HirDatabase,\n-        scope: &SemanticsScope,\n+        scope: &SemanticsScope<'_>,\n         // FIXME this can be retrieved from `scope`, except autoimport uses this\n         // to specify a different set, so the method needs to be split\n         traits_in_scope: &FxHashSet<TraitId>,\n@@ -3061,7 +3061,7 @@ impl Type {\n     fn iterate_method_candidates_dyn(\n         &self,\n         db: &dyn HirDatabase,\n-        scope: &SemanticsScope,\n+        scope: &SemanticsScope<'_>,\n         traits_in_scope: &FxHashSet<TraitId>,\n         with_local_impls: Option<Module>,\n         name: Option<&Name>,\n@@ -3091,7 +3091,7 @@ impl Type {\n     pub fn iterate_path_candidates<T>(\n         &self,\n         db: &dyn HirDatabase,\n-        scope: &SemanticsScope,\n+        scope: &SemanticsScope<'_>,\n         traits_in_scope: &FxHashSet<TraitId>,\n         with_local_impls: Option<Module>,\n         name: Option<&Name>,\n@@ -3119,7 +3119,7 @@ impl Type {\n     fn iterate_path_candidates_dyn(\n         &self,\n         db: &dyn HirDatabase,\n-        scope: &SemanticsScope,\n+        scope: &SemanticsScope<'_>,\n         traits_in_scope: &FxHashSet<TraitId>,\n         with_local_impls: Option<Module>,\n         name: Option<&Name>,"}, {"sha": "edcb2fc6a7246be99cbd10a1e4a44e28d1364cd8", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -124,7 +124,7 @@ impl<DB> fmt::Debug for Semantics<'_, DB> {\n }\n \n impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n-    pub fn new(db: &DB) -> Semantics<DB> {\n+    pub fn new(db: &DB) -> Semantics<'_, DB> {\n         let impl_ = SemanticsImpl::new(db);\n         Semantics { db, imp: impl_ }\n     }\n@@ -1056,7 +1056,7 @@ impl<'db> SemanticsImpl<'db> {\n             .unwrap_or_default()\n     }\n \n-    fn with_ctx<F: FnOnce(&mut SourceToDefCtx) -> T, T>(&self, f: F) -> T {\n+    fn with_ctx<F: FnOnce(&mut SourceToDefCtx<'_, '_>) -> T, T>(&self, f: F) -> T {\n         let mut cache = self.s2d_cache.borrow_mut();\n         let mut ctx = SourceToDefCtx { db: self.db, cache: &mut *cache };\n         f(&mut ctx)\n@@ -1280,7 +1280,7 @@ impl<'db> SemanticsImpl<'db> {\n }\n \n fn macro_call_to_macro_id(\n-    ctx: &mut SourceToDefCtx,\n+    ctx: &mut SourceToDefCtx<'_, '_>,\n     db: &dyn AstDatabase,\n     macro_call_id: MacroCallId,\n ) -> Option<MacroId> {\n@@ -1302,14 +1302,14 @@ fn macro_call_to_macro_id(\n pub trait ToDef: AstNode + Clone {\n     type Def;\n \n-    fn to_def(sema: &SemanticsImpl, src: InFile<Self>) -> Option<Self::Def>;\n+    fn to_def(sema: &SemanticsImpl<'_>, src: InFile<Self>) -> Option<Self::Def>;\n }\n \n macro_rules! to_def_impls {\n     ($(($def:path, $ast:path, $meth:ident)),* ,) => {$(\n         impl ToDef for $ast {\n             type Def = $def;\n-            fn to_def(sema: &SemanticsImpl, src: InFile<Self>) -> Option<Self::Def> {\n+            fn to_def(sema: &SemanticsImpl<'_>, src: InFile<Self>) -> Option<Self::Def> {\n                 sema.with_ctx(|ctx| ctx.$meth(src)).map(<$def>::from)\n             }\n         }"}, {"sha": "616a406c72758aa4b0ca77dca33f74b5601aa308", "filename": "crates/hir/src/symbols.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fhir%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsymbols.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -32,7 +32,7 @@ pub struct DeclarationLocation {\n }\n \n impl DeclarationLocation {\n-    pub fn syntax<DB: HirDatabase>(&self, sema: &Semantics<DB>) -> Option<SyntaxNode> {\n+    pub fn syntax<DB: HirDatabase>(&self, sema: &Semantics<'_, DB>) -> Option<SyntaxNode> {\n         let root = sema.parse_or_expand(self.hir_file_id)?;\n         Some(self.ptr.to_node(&root))\n     }"}, {"sha": "f9b42661425745a6df4323230a3c55e5a5f9a908", "filename": "crates/ide-assists/src/assist_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fassist_context.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -144,7 +144,7 @@ pub(crate) struct Assists {\n }\n \n impl Assists {\n-    pub(crate) fn new(ctx: &AssistContext, resolve: AssistResolveStrategy) -> Assists {\n+    pub(crate) fn new(ctx: &AssistContext<'_>, resolve: AssistResolveStrategy) -> Assists {\n         Assists {\n             resolve,\n             file: ctx.frange.file_id,"}, {"sha": "bfa9759ec84bea47b1abbe4e9687e93103af8bbc", "filename": "crates/ide-assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -19,7 +19,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     let x: i32 = 92;\n // }\n // ```\n-pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (ascribed_ty, expr, pat) = if let Some(let_stmt) = ctx.find_node_at_offset::<LetStmt>() {\n         let cursor_in_range = {\n             let eq_range = let_stmt.eq_token()?.text_range();"}, {"sha": "001f1e8bb158545ada906c8d188d601ca737644c", "filename": "crates/ide-assists/src/handlers/add_label_to_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_label_to_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_label_to_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_label_to_loop.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -27,7 +27,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     }\n // }\n // ```\n-pub(crate) fn add_label_to_loop(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn add_label_to_loop(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let loop_kw = ctx.find_token_syntax_at_offset(T![loop])?;\n     let loop_expr = loop_kw.parent().and_then(ast::LoopExpr::cast)?;\n     if loop_expr.label().is_some() {"}, {"sha": "12213c8455c77436dc4d5a96095de440a5c6c51b", "filename": "crates/ide-assists/src/handlers/add_lifetime_to_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_lifetime_to_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_lifetime_to_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_lifetime_to_type.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -19,7 +19,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     y: u32,\n // }\n // ```\n-pub(crate) fn add_lifetime_to_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn add_lifetime_to_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let ref_type_focused = ctx.find_node_at_offset::<ast::RefType>()?;\n     if ref_type_focused.lifetime().is_some() {\n         return None;"}, {"sha": "9d252e411fe4f1424b5d70624e77d6bf764e4c75", "filename": "crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -44,7 +44,7 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     add_missing_impl_members_inner(\n         acc,\n         ctx,\n@@ -85,7 +85,7 @@ pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -\n //     $0fn bar(&self) {}\n // }\n // ```\n-pub(crate) fn add_missing_default_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn add_missing_default_members(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     add_missing_impl_members_inner(\n         acc,\n         ctx,\n@@ -97,7 +97,7 @@ pub(crate) fn add_missing_default_members(acc: &mut Assists, ctx: &AssistContext\n \n fn add_missing_impl_members_inner(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     mode: DefaultMethods,\n     assist_id: &'static str,\n     label: &'static str,\n@@ -164,7 +164,7 @@ fn add_missing_impl_members_inner(\n }\n \n fn try_gen_trait_body(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     func: &ast::Fn,\n     trait_: &hir::Trait,\n     impl_def: &ast::Impl,"}, {"sha": "b16f6fe03ae8e12716352b22dc7c514a189e0eea", "filename": "crates/ide-assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -36,7 +36,7 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let match_expr = ctx.find_node_at_offset_with_descend::<ast::MatchExpr>()?;\n     let match_arm_list = match_expr.match_arm_list()?;\n     let target_range = ctx.sema.original_range(match_expr.syntax()).range;\n@@ -221,7 +221,7 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n }\n \n fn cursor_at_trivial_match_arm_list(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     match_expr: &MatchExpr,\n     match_arm_list: &MatchArmList,\n ) -> Option<()> {\n@@ -321,15 +321,15 @@ impl ExtendedEnum {\n     }\n }\n \n-fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<ExtendedEnum> {\n+fn resolve_enum_def(sema: &Semantics<'_, RootDatabase>, expr: &ast::Expr) -> Option<ExtendedEnum> {\n     sema.type_of_expr(expr)?.adjusted().autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n         Some(Adt::Enum(e)) => Some(ExtendedEnum::Enum(e)),\n         _ => ty.is_bool().then(|| ExtendedEnum::Bool),\n     })\n }\n \n fn resolve_tuple_of_enum_def(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     expr: &ast::Expr,\n ) -> Option<Vec<ExtendedEnum>> {\n     sema.type_of_expr(expr)?"}, {"sha": "f858d7a15c24276fb591c28996e1ea7f3b2f2bbe", "filename": "crates/ide-assists/src/handlers/add_return_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -15,7 +15,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n // fn foo() -> i32 { 42i32 }\n // ```\n-pub(crate) fn add_return_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn add_return_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (fn_type, tail_expr, builder_edit_pos) = extract_tail(ctx)?;\n     let module = ctx.sema.scope(tail_expr.syntax())?.module();\n     let ty = ctx.sema.type_of_expr(&peel_blocks(tail_expr.clone()))?.original();\n@@ -132,7 +132,7 @@ fn peel_blocks(mut expr: ast::Expr) -> ast::Expr {\n     expr\n }\n \n-fn extract_tail(ctx: &AssistContext) -> Option<(FnType, ast::Expr, InsertOrReplace)> {\n+fn extract_tail(ctx: &AssistContext<'_>) -> Option<(FnType, ast::Expr, InsertOrReplace)> {\n     let (fn_type, tail_expr, return_type_range, action) =\n         if let Some(closure) = ctx.find_node_at_offset::<ast::ClosureExpr>() {\n             let rpipe = closure.param_list()?.syntax().last_token()?;"}, {"sha": "c0bf238db7317a78756dd3fb97a4f04b573e4637", "filename": "crates/ide-assists/src/handlers/add_turbo_fish.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -24,7 +24,7 @@ use crate::{\n //     let x = make::<${0:_}>();\n // }\n // ```\n-pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let ident = ctx.find_token_syntax_at_offset(SyntaxKind::IDENT).or_else(|| {\n         let arg_list = ctx.find_node_at_offset::<ast::ArgList>()?;\n         if arg_list.args().next().is_some() {"}, {"sha": "2853d1d1be3cd57b5935f61bc4899cd2d68d30b3", "filename": "crates/ide-assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -22,7 +22,7 @@ use crate::{utils::invert_boolean_expression, AssistContext, AssistId, AssistKin\n //     if !(x == 4 && y >= 3.14) {}\n // }\n // ```\n-pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n     let op = expr.op_kind()?;\n     let op_range = expr.op_token()?.text_range();"}, {"sha": "c086d9f1cdd08479373486522ad8d227c20bc821", "filename": "crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -87,7 +87,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n // }\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n-pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n     let mut proposed_imports =\n         import_assets.search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind);\n@@ -142,7 +142,7 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     Some(())\n }\n \n-pub(super) fn find_importable_node(ctx: &AssistContext) -> Option<(ImportAssets, SyntaxElement)> {\n+pub(super) fn find_importable_node(ctx: &AssistContext<'_>) -> Option<(ImportAssets, SyntaxElement)> {\n     if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n         ImportAssets::for_exact_path(&path_under_caret, &ctx.sema)\n             .zip(Some(path_under_caret.syntax().clone().into()))\n@@ -177,7 +177,7 @@ fn group_label(import_candidate: &ImportCandidate) -> GroupLabel {\n /// Determine how relevant a given import is in the current context. Higher scores are more\n /// relevant.\n fn relevance_score(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     import: &LocatedImport,\n     current_module: Option<&Module>,\n ) -> i32 {"}, {"sha": "2b1d8f6f0132aa332778b642b0612850637150ac", "filename": "crates/ide-assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -20,14 +20,14 @@ use crate::{utils::vis_offset, AssistContext, AssistId, AssistKind, Assists};\n // ```\n // pub(crate) fn frobnicate() {}\n // ```\n-pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     if let Some(vis) = ctx.find_node_at_offset::<ast::Visibility>() {\n         return change_vis(acc, vis);\n     }\n     add_vis(acc, ctx)\n }\n \n-fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+fn add_vis(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let item_keyword = ctx.token_at_offset().find(|leaf| {\n         matches!(\n             leaf.kind(),"}, {"sha": "db96ad33047fb3791657260f1304f64a2d9de16b", "filename": "crates/ide-assists/src/handlers/convert_bool_then.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -37,7 +37,7 @@ use crate::{\n //     cond.then(|| val)\n // }\n // ```\n-pub(crate) fn convert_if_to_bool_then(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn convert_if_to_bool_then(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     // FIXME applies to match as well\n     let expr = ctx.find_node_at_offset::<ast::IfExpr>()?;\n     if !expr.if_token()?.text_range().contains_inclusive(ctx.offset()) {\n@@ -149,7 +149,7 @@ pub(crate) fn convert_if_to_bool_then(acc: &mut Assists, ctx: &AssistContext) ->\n //     }\n // }\n // ```\n-pub(crate) fn convert_bool_then_to_if(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn convert_bool_then_to_if(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let name_ref = ctx.find_node_at_offset::<ast::NameRef>()?;\n     let mcall = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n     let receiver = mcall.receiver()?;\n@@ -219,7 +219,7 @@ pub(crate) fn convert_bool_then_to_if(acc: &mut Assists, ctx: &AssistContext) ->\n }\n \n fn option_variants(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     expr: &SyntaxNode,\n ) -> Option<(hir::Variant, hir::Variant)> {\n     let fam = FamousDefs(sema, sema.scope(expr)?.krate());\n@@ -237,7 +237,7 @@ fn option_variants(\n /// Traverses the expression checking if it contains `return` or `?` expressions or if any tail is not a `Some(expr)` expression.\n /// If any of these conditions are met it is impossible to rewrite this as a `bool::then` call.\n fn is_invalid_body(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     some_variant: hir::Variant,\n     expr: &ast::Expr,\n ) -> bool {\n@@ -272,7 +272,7 @@ fn is_invalid_body(\n }\n \n fn block_is_none_variant(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     block: &ast::BlockExpr,\n     none_variant: hir::Variant,\n ) -> bool {"}, {"sha": "f171dd81a811e7183d70e673e37806fbe813ce87", "filename": "crates/ide-assists/src/handlers/convert_comment_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -21,7 +21,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //   comment\n //   */\n // ```\n-pub(crate) fn convert_comment_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn convert_comment_block(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let comment = ctx.find_token_at_offset::<ast::Comment>()?;\n     // Only allow comments which are alone on their line\n     if let Some(prev) = comment.syntax().prev_token() {"}, {"sha": "9060696cdc8e9c76fd26cd5c7eda993d0ebb15d6", "filename": "crates/ide-assists/src/handlers/convert_integer_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -13,7 +13,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n // ```\n // const _: i32 = 0b1010;\n // ```\n-pub(crate) fn convert_integer_literal(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn convert_integer_literal(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let literal = ctx.find_node_at_offset::<ast::Literal>()?;\n     let literal = match literal.kind() {\n         ast::LiteralKind::IntNumber(it) => it,"}, {"sha": "30f6dd41a1d6d53398855c686adfb3df50d87616", "filename": "crates/ide-assists/src/handlers/convert_into_to_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -31,7 +31,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     }\n // }\n // ```\n-pub(crate) fn convert_into_to_from(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn convert_into_to_from(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let impl_ = ctx.find_node_at_offset::<ast::Impl>()?;\n     let src_type = impl_.self_ty()?;\n     let ast_trait = impl_.trait_()?;"}, {"sha": "e42a52c4db14063075790710bb01c4b4890b014b", "filename": "crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -32,7 +32,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     }\n // }\n // ```\n-pub(crate) fn convert_iter_for_each_to_for(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn convert_iter_for_each_to_for(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let method = ctx.find_node_at_offset::<ast::MethodCallExpr>()?;\n \n     let closure = match method.arg_list()?.args().next()? {\n@@ -91,7 +91,7 @@ pub(crate) fn convert_iter_for_each_to_for(acc: &mut Assists, ctx: &AssistContex\n //     });\n // }\n // ```\n-pub(crate) fn convert_for_loop_with_for_each(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn convert_for_loop_with_for_each(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let for_loop = ctx.find_node_at_offset::<ast::ForExpr>()?;\n     let iterable = for_loop.iterable()?;\n     let pat = for_loop.pat()?;\n@@ -136,7 +136,7 @@ pub(crate) fn convert_for_loop_with_for_each(acc: &mut Assists, ctx: &AssistCont\n /// returning an Iterator called iter or iter_mut (depending on the type of reference) then return\n /// the expression behind the reference and the method name\n fn is_ref_and_impls_iter_method(\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n+    sema: &hir::Semantics<'_, ide_db::RootDatabase>,\n     iterable: &ast::Expr,\n ) -> Option<(ast::Expr, hir::Name)> {\n     let ref_expr = match iterable {\n@@ -173,7 +173,7 @@ fn is_ref_and_impls_iter_method(\n }\n \n /// Whether iterable implements core::Iterator\n-fn impls_core_iter(sema: &hir::Semantics<ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {\n+fn impls_core_iter(sema: &hir::Semantics<'_, ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {\n     (|| {\n         let it_typ = sema.type_of_expr(iterable)?.adjusted();\n \n@@ -188,7 +188,7 @@ fn impls_core_iter(sema: &hir::Semantics<ide_db::RootDatabase>, iterable: &ast::\n }\n \n fn validate_method_call_expr(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     expr: ast::MethodCallExpr,\n ) -> Option<(ast::Expr, ast::Expr)> {\n     let name_ref = expr.name_ref()?;"}, {"sha": "00095de257d5ab19922c22df209b76b763281a8c", "filename": "crates/ide-assists/src/handlers/convert_let_else_to_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -9,7 +9,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n fn binders_in_pat(\n     acc: &mut Vec<(Name, bool)>,\n     pat: &Pat,\n-    sem: &Semantics<RootDatabase>,\n+    sem: &Semantics<'_, RootDatabase>,\n ) -> Option<()> {\n     use Pat::*;\n     match pat {\n@@ -115,7 +115,7 @@ fn binders_to_str(binders: &[(Name, bool)], addmut: bool) -> String {\n //     };\n // }\n // ```\n-pub(crate) fn convert_let_else_to_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn convert_let_else_to_match(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     // should focus on else token to trigger\n     let else_token = ctx.find_token_syntax_at_offset(T![else])?;\n     let let_stmt = LetStmt::cast(else_token.parent()?.parent()?)?;"}, {"sha": "cb75619ced9c31f46bf0c2a92adfc3902870e67f", "filename": "crates/ide-assists/src/handlers/convert_to_guarded_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -40,7 +40,7 @@ use crate::{\n //     bar();\n // }\n // ```\n-pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     if if_expr.else_branch().is_some() {\n         return None;"}, {"sha": "4ab8e93a2909f1c3e7020da6d95c753845bb0a35", "filename": "crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -48,7 +48,7 @@ use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind,\n // ```\n pub(crate) fn convert_tuple_struct_to_named_struct(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n ) -> Option<()> {\n     let strukt = ctx\n         .find_node_at_offset::<ast::Struct>()\n@@ -79,7 +79,7 @@ pub(crate) fn convert_tuple_struct_to_named_struct(\n }\n \n fn edit_struct_def(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     edit: &mut AssistBuilder,\n     strukt: &Either<ast::Struct, ast::Variant>,\n     tuple_fields: ast::TupleFieldList,\n@@ -121,7 +121,7 @@ fn edit_struct_def(\n }\n \n fn edit_struct_references(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     edit: &mut AssistBuilder,\n     strukt: Either<hir::Struct, hir::Variant>,\n     names: &[ast::Name],\n@@ -202,7 +202,7 @@ fn edit_struct_references(\n }\n \n fn edit_field_references(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     edit: &mut AssistBuilder,\n     fields: impl Iterator<Item = ast::TupleField>,\n     names: &[ast::Name],"}, {"sha": "c34b684112aaf53471101ce45371089aefb51e79", "filename": "crates/ide-assists/src/handlers/convert_while_to_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_while_to_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_while_to_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_while_to_loop.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -38,7 +38,7 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn convert_while_to_loop(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn convert_while_to_loop(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let while_kw = ctx.find_token_syntax_at_offset(T![while])?;\n     let while_expr = while_kw.parent().and_then(ast::WhileExpr::cast)?;\n     let while_body = while_expr.loop_body()?;"}, {"sha": "c1f57532bb29623ea75f2083edc55622b0534e18", "filename": "crates/ide-assists/src/handlers/destructure_tuple_binding.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -27,7 +27,7 @@ use crate::assist_context::{AssistBuilder, AssistContext, Assists};\n //     let v = _0;\n // }\n // ```\n-pub(crate) fn destructure_tuple_binding(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn destructure_tuple_binding(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     destructure_tuple_binding_impl(acc, ctx, false)\n }\n \n@@ -51,7 +51,7 @@ pub(crate) fn destructure_tuple_binding(acc: &mut Assists, ctx: &AssistContext)\n // ```\n pub(crate) fn destructure_tuple_binding_impl(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     with_sub_pattern: bool,\n ) -> Option<()> {\n     let ident_pat = ctx.find_node_at_offset::<ast::IdentPat>()?;\n@@ -82,7 +82,7 @@ pub(crate) fn destructure_tuple_binding_impl(\n     Some(())\n }\n \n-fn collect_data(ident_pat: IdentPat, ctx: &AssistContext) -> Option<TupleData> {\n+fn collect_data(ident_pat: IdentPat, ctx: &AssistContext<'_>) -> Option<TupleData> {\n     if ident_pat.at_token().is_some() {\n         // Cannot destructure pattern with sub-pattern:\n         // Only IdentPat can have sub-pattern,\n@@ -126,7 +126,7 @@ fn collect_data(ident_pat: IdentPat, ctx: &AssistContext) -> Option<TupleData> {\n }\n \n fn generate_name(\n-    _ctx: &AssistContext,\n+    _ctx: &AssistContext<'_>,\n     index: usize,\n     _tuple_name: &str,\n     _ident_pat: &IdentPat,\n@@ -150,7 +150,7 @@ struct TupleData {\n     usages: Option<UsageSearchResult>,\n }\n fn edit_tuple_assignment(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     builder: &mut AssistBuilder,\n     data: &TupleData,\n     in_sub_pattern: bool,\n@@ -196,7 +196,7 @@ fn edit_tuple_assignment(\n fn edit_tuple_usages(\n     data: &TupleData,\n     builder: &mut AssistBuilder,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     in_sub_pattern: bool,\n ) {\n     if let Some(usages) = data.usages.as_ref() {\n@@ -210,7 +210,7 @@ fn edit_tuple_usages(\n     }\n }\n fn edit_tuple_usage(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     builder: &mut AssistBuilder,\n     usage: &FileReference,\n     data: &TupleData,\n@@ -238,7 +238,7 @@ fn edit_tuple_usage(\n }\n \n fn edit_tuple_field_usage(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     builder: &mut AssistBuilder,\n     data: &TupleData,\n     index: TupleIndex,\n@@ -321,7 +321,7 @@ impl RefData {\n         }\n     }\n }\n-fn handle_ref_field_usage(ctx: &AssistContext, field_expr: &FieldExpr) -> RefData {\n+fn handle_ref_field_usage(ctx: &AssistContext<'_>, field_expr: &FieldExpr) -> RefData {\n     let s = field_expr.syntax();\n     let mut ref_data =\n         RefData { range: s.text_range(), needs_deref: true, needs_parentheses: true };\n@@ -368,8 +368,8 @@ fn handle_ref_field_usage(ctx: &AssistContext, field_expr: &FieldExpr) -> RefDat\n             // other combinations (`&value` -> `value`, `&&value` -> `&value`, `&value` -> `&&value`) might or might not be able to auto-ref/deref,\n             // but there might be trait implementations an added `&` might resolve to\n             // -> ONLY handle auto-ref from `value` to `&value`\n-            fn is_auto_ref(ctx: &AssistContext, call_expr: &MethodCallExpr) -> bool {\n-                fn impl_(ctx: &AssistContext, call_expr: &MethodCallExpr) -> Option<bool> {\n+            fn is_auto_ref(ctx: &AssistContext<'_>, call_expr: &MethodCallExpr) -> bool {\n+                fn impl_(ctx: &AssistContext<'_>, call_expr: &MethodCallExpr) -> Option<bool> {\n                     let rec = call_expr.receiver()?;\n                     let rec_ty = ctx.sema.type_of_expr(&rec)?.original();\n                     // input must be actual value\n@@ -426,7 +426,7 @@ mod tests {\n     // Tests for direct tuple destructure:\n     // `let $0t = (1,2);` -> `let (_0, _1) = (1,2);`\n \n-    fn assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    fn assist(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n         destructure_tuple_binding_impl(acc, ctx, false)\n     }\n \n@@ -1191,10 +1191,10 @@ fn main {\n         use super::*;\n         use crate::tests::check_assist_by_label;\n \n-        fn assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+        fn assist(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n             destructure_tuple_binding_impl(acc, ctx, true)\n         }\n-        fn in_place_assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+        fn in_place_assist(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n             destructure_tuple_binding_impl(acc, ctx, false)\n         }\n \n@@ -1256,7 +1256,7 @@ fn main() {\n \n         #[test]\n         fn trigger_both_destructure_tuple_assists() {\n-            fn assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+            fn assist(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n                 destructure_tuple_binding_impl(acc, ctx, true)\n             }\n             let text = r#\""}, {"sha": "943c1d90e63659830d017e9ab4b102a594de62f1", "filename": "crates/ide-assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -40,7 +40,7 @@ use crate::{\n //\n // fn qux(bar: Bar, baz: Baz) {}\n // ```\n-pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let star = ctx.find_token_syntax_at_offset(T![*])?;\n     let use_tree = star.parent().and_then(ast::UseTree::cast)?;\n     let (parent, mod_path) = find_parent_and_path(&star)?;\n@@ -112,7 +112,7 @@ fn find_parent_and_path(\n     }\n }\n \n-fn def_is_referenced_in(def: Definition, ctx: &AssistContext) -> bool {\n+fn def_is_referenced_in(def: Definition, ctx: &AssistContext<'_>) -> bool {\n     let search_scope = SearchScope::single_file(ctx.file_id());\n     def.usages(&ctx.sema).in_scope(search_scope).at_least_one()\n }\n@@ -139,7 +139,7 @@ impl Ref {\n struct Refs(Vec<Ref>);\n \n impl Refs {\n-    fn used_refs(&self, ctx: &AssistContext) -> Refs {\n+    fn used_refs(&self, ctx: &AssistContext<'_>) -> Refs {\n         Refs(\n             self.0\n                 .clone()\n@@ -168,7 +168,7 @@ impl Refs {\n     }\n }\n \n-fn find_refs_in_mod(ctx: &AssistContext, module: Module, visible_from: Module) -> Option<Refs> {\n+fn find_refs_in_mod(ctx: &AssistContext<'_>, module: Module, visible_from: Module) -> Option<Refs> {\n     if !is_mod_visible_from(ctx, module, visible_from) {\n         return None;\n     }\n@@ -178,7 +178,7 @@ fn find_refs_in_mod(ctx: &AssistContext, module: Module, visible_from: Module) -\n     Some(Refs(refs))\n }\n \n-fn is_mod_visible_from(ctx: &AssistContext, module: Module, from: Module) -> bool {\n+fn is_mod_visible_from(ctx: &AssistContext<'_>, module: Module, from: Module) -> bool {\n     match module.parent(ctx.db()) {\n         Some(parent) => {\n             module.visibility(ctx.db()).is_visible_from(ctx.db(), from.into())\n@@ -202,7 +202,7 @@ fn is_mod_visible_from(ctx: &AssistContext, module: Module, from: Module) -> boo\n // use foo::*$0;\n // use baz::Baz;\n // \u2191 ---------------\n-fn find_imported_defs(ctx: &AssistContext, star: SyntaxToken) -> Option<Vec<Definition>> {\n+fn find_imported_defs(ctx: &AssistContext<'_>, star: SyntaxToken) -> Option<Vec<Definition>> {\n     let parent_use_item_syntax = star.parent_ancestors().find_map(|n| {\n         if ast::Use::can_cast(n.kind()) {\n             Some(n)\n@@ -239,7 +239,7 @@ fn find_imported_defs(ctx: &AssistContext, star: SyntaxToken) -> Option<Vec<Defi\n }\n \n fn find_names_to_import(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     refs_in_target: Refs,\n     imported_defs: Vec<Definition>,\n ) -> Vec<Name> {"}, {"sha": "af39387cddf12ffc9744d4eb865aca97c533b2f9", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -60,7 +60,7 @@ use crate::{\n //     let k = m + n;\n // }\n // ```\n-pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let range = ctx.selection_trimmed();\n     if range.is_empty() {\n         return None;\n@@ -170,7 +170,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     )\n }\n \n-fn make_function_name(semantics_scope: &hir::SemanticsScope) -> ast::NameRef {\n+fn make_function_name(semantics_scope: &hir::SemanticsScope<'_>) -> ast::NameRef {\n     let mut names_in_scope = vec![];\n     semantics_scope.process_all_names(&mut |name, _| names_in_scope.push(name.to_string()));\n \n@@ -366,7 +366,7 @@ struct OutlivedLocal {\n struct LocalUsages(ide_db::search::UsageSearchResult);\n \n impl LocalUsages {\n-    fn find_local_usages(ctx: &AssistContext, var: Local) -> Self {\n+    fn find_local_usages(ctx: &AssistContext<'_>, var: Local) -> Self {\n         Self(\n             Definition::Local(var)\n                 .usages(&ctx.sema)\n@@ -381,7 +381,7 @@ impl LocalUsages {\n }\n \n impl Function {\n-    fn return_type(&self, ctx: &AssistContext) -> FunType {\n+    fn return_type(&self, ctx: &AssistContext<'_>) -> FunType {\n         match &self.ret_ty {\n             RetType::Expr(ty) if ty.is_unit() => FunType::Unit,\n             RetType::Expr(ty) => FunType::Single(ty.clone()),\n@@ -396,7 +396,7 @@ impl Function {\n         }\n     }\n \n-    fn self_param_adt(&self, ctx: &AssistContext) -> Option<ast::Adt> {\n+    fn self_param_adt(&self, ctx: &AssistContext<'_>) -> Option<ast::Adt> {\n         let self_param = self.self_param.as_ref()?;\n         let def = ctx.sema.to_def(self_param)?;\n         let adt = def.ty(ctx.db()).strip_references().as_adt()?;\n@@ -421,7 +421,7 @@ impl Param {\n         }\n     }\n \n-    fn to_arg(&self, ctx: &AssistContext) -> ast::Expr {\n+    fn to_arg(&self, ctx: &AssistContext<'_>) -> ast::Expr {\n         let var = path_expr_from_local(ctx, self.var);\n         match self.kind() {\n             ParamKind::Value | ParamKind::MutValue => var,\n@@ -430,7 +430,7 @@ impl Param {\n         }\n     }\n \n-    fn to_param(&self, ctx: &AssistContext, module: hir::Module) -> ast::Param {\n+    fn to_param(&self, ctx: &AssistContext<'_>, module: hir::Module) -> ast::Param {\n         let var = self.var.name(ctx.db()).to_string();\n         let var_name = make::name(&var);\n         let pat = match self.kind() {\n@@ -452,7 +452,7 @@ impl Param {\n }\n \n impl TryKind {\n-    fn of_ty(ty: hir::Type, ctx: &AssistContext) -> Option<TryKind> {\n+    fn of_ty(ty: hir::Type, ctx: &AssistContext<'_>) -> Option<TryKind> {\n         if ty.is_unknown() {\n             // We favour Result for `expr?`\n             return Some(TryKind::Result { ty });\n@@ -485,7 +485,7 @@ impl FlowKind {\n         }\n     }\n \n-    fn expr_ty(&self, ctx: &AssistContext) -> Option<hir::Type> {\n+    fn expr_ty(&self, ctx: &AssistContext<'_>) -> Option<hir::Type> {\n         match self {\n             FlowKind::Return(Some(expr)) | FlowKind::Break(_, Some(expr)) => {\n                 ctx.sema.type_of_expr(expr).map(TypeInfo::adjusted)\n@@ -691,7 +691,7 @@ impl FunctionBody {\n     /// whether it contains an await expression.\n     fn analyze(\n         &self,\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n     ) -> (FxIndexSet<Local>, Option<ast::SelfParam>) {\n         let mut self_param = None;\n         let mut res = FxIndexSet::default();\n@@ -741,7 +741,7 @@ impl FunctionBody {\n         (res, self_param)\n     }\n \n-    fn analyze_container(&self, sema: &Semantics<RootDatabase>) -> Option<ContainerInfo> {\n+    fn analyze_container(&self, sema: &Semantics<'_, RootDatabase>) -> Option<ContainerInfo> {\n         let mut ancestors = self.parent()?.ancestors();\n         let infer_expr_opt = |expr| sema.type_of_expr(&expr?).map(TypeInfo::adjusted);\n         let mut parent_loop = None;\n@@ -837,7 +837,7 @@ impl FunctionBody {\n         })\n     }\n \n-    fn return_ty(&self, ctx: &AssistContext) -> Option<RetType> {\n+    fn return_ty(&self, ctx: &AssistContext<'_>) -> Option<RetType> {\n         match self.tail_expr() {\n             Some(expr) => ctx.sema.type_of_expr(&expr).map(TypeInfo::original).map(RetType::Expr),\n             None => Some(RetType::Stmt),\n@@ -847,7 +847,7 @@ impl FunctionBody {\n     /// Local variables defined inside `body` that are accessed outside of it\n     fn ret_values<'a>(\n         &self,\n-        ctx: &'a AssistContext,\n+        ctx: &'a AssistContext<'_>,\n         parent: &SyntaxNode,\n     ) -> impl Iterator<Item = OutlivedLocal> + 'a {\n         let parent = parent.clone();\n@@ -860,7 +860,7 @@ impl FunctionBody {\n     /// Analyses the function body for external control flow.\n     fn external_control_flow(\n         &self,\n-        ctx: &AssistContext,\n+        ctx: &AssistContext<'_>,\n         container_info: &ContainerInfo,\n     ) -> Option<ControlFlow> {\n         let mut ret_expr = None;\n@@ -950,7 +950,7 @@ impl FunctionBody {\n     /// Computes additional info that affects param type and mutability\n     fn extracted_function_params(\n         &self,\n-        ctx: &AssistContext,\n+        ctx: &AssistContext<'_>,\n         container_info: &ContainerInfo,\n         locals: impl Iterator<Item = Local>,\n     ) -> Vec<Param> {\n@@ -1042,7 +1042,7 @@ fn generic_parents(parent: &SyntaxNode) -> Vec<GenericParent> {\n }\n \n /// checks if relevant var is used with `&mut` access inside body\n-fn has_exclusive_usages(ctx: &AssistContext, usages: &LocalUsages, body: &FunctionBody) -> bool {\n+fn has_exclusive_usages(ctx: &AssistContext<'_>, usages: &LocalUsages, body: &FunctionBody) -> bool {\n     usages\n         .iter()\n         .filter(|reference| body.contains_range(reference.range))\n@@ -1053,7 +1053,7 @@ fn has_exclusive_usages(ctx: &AssistContext, usages: &LocalUsages, body: &Functi\n fn reference_is_exclusive(\n     reference: &FileReference,\n     node: &dyn HasTokenAtOffset,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n ) -> bool {\n     // we directly modify variable with set: `n = 0`, `n += 1`\n     if reference.category == Some(ReferenceCategory::Write) {\n@@ -1070,7 +1070,7 @@ fn reference_is_exclusive(\n }\n \n /// checks if this expr requires `&mut` access, recurses on field access\n-fn expr_require_exclusive_access(ctx: &AssistContext, expr: &ast::Expr) -> Option<bool> {\n+fn expr_require_exclusive_access(ctx: &AssistContext<'_>, expr: &ast::Expr) -> Option<bool> {\n     if let ast::Expr::MacroExpr(_) = expr {\n         // FIXME: expand macro and check output for mutable usages of the variable?\n         return None;\n@@ -1172,7 +1172,7 @@ fn path_element_of_reference(\n \n /// list local variables defined inside `body`\n fn locals_defined_in_body(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     body: &FunctionBody,\n ) -> FxIndexSet<Local> {\n     // FIXME: this doesn't work well with macros\n@@ -1190,7 +1190,7 @@ fn locals_defined_in_body(\n \n /// Returns usage details if local variable is used after(outside of) body\n fn local_outlives_body(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     body_range: TextRange,\n     local: Local,\n     parent: &SyntaxNode,\n@@ -1215,7 +1215,7 @@ fn local_outlives_body(\n \n /// checks if the relevant local was defined before(outside of) body\n fn is_defined_outside_of_body(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     body: &FunctionBody,\n     src: &hir::InFile<Either<ast::IdentPat, ast::SelfParam>>,\n ) -> bool {\n@@ -1260,7 +1260,7 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n     last_ancestor\n }\n \n-fn make_call(ctx: &AssistContext, fun: &Function, indent: IndentLevel) -> String {\n+fn make_call(ctx: &AssistContext<'_>, fun: &Function, indent: IndentLevel) -> String {\n     let ret_ty = fun.return_type(ctx);\n \n     let args = make::arg_list(fun.params.iter().map(|param| param.to_arg(ctx)));\n@@ -1429,13 +1429,13 @@ impl FlowHandler {\n     }\n }\n \n-fn path_expr_from_local(ctx: &AssistContext, var: Local) -> ast::Expr {\n+fn path_expr_from_local(ctx: &AssistContext<'_>, var: Local) -> ast::Expr {\n     let name = var.name(ctx.db()).to_string();\n     make::expr_path(make::ext::ident_path(&name))\n }\n \n fn format_function(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     module: hir::Module,\n     fun: &Function,\n     old_indent: IndentLevel,\n@@ -1490,7 +1490,7 @@ fn format_function(\n }\n \n fn make_generic_params_and_where_clause(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     fun: &Function,\n ) -> (Option<ast::GenericParamList>, Option<ast::WhereClause>) {\n     let used_type_params = fun.type_params(ctx);\n@@ -1502,7 +1502,7 @@ fn make_generic_params_and_where_clause(\n }\n \n fn make_generic_param_list(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     fun: &Function,\n     used_type_params: &[TypeParam],\n ) -> Option<ast::GenericParamList> {\n@@ -1525,7 +1525,7 @@ fn make_generic_param_list(\n }\n \n fn param_is_required(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     param: &ast::GenericParam,\n     used_type_params: &[TypeParam],\n ) -> bool {\n@@ -1539,7 +1539,7 @@ fn param_is_required(\n }\n \n fn make_where_clause(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     fun: &Function,\n     used_type_params: &[TypeParam],\n ) -> Option<ast::WhereClause> {\n@@ -1562,7 +1562,7 @@ fn make_where_clause(\n }\n \n fn pred_is_required(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     pred: &ast::WherePred,\n     used_type_params: &[TypeParam],\n ) -> bool {\n@@ -1572,7 +1572,7 @@ fn pred_is_required(\n     }\n }\n \n-fn resolved_type_param(ctx: &AssistContext, pred: &ast::WherePred) -> Option<TypeParam> {\n+fn resolved_type_param(ctx: &AssistContext<'_>, pred: &ast::WherePred) -> Option<TypeParam> {\n     let path = match pred.ty()? {\n         ast::Type::PathType(path_type) => path_type.path(),\n         _ => None,\n@@ -1586,7 +1586,7 @@ fn resolved_type_param(ctx: &AssistContext, pred: &ast::WherePred) -> Option<Typ\n \n impl Function {\n     /// Collect all the `TypeParam`s used in the `body` and `params`.\n-    fn type_params(&self, ctx: &AssistContext) -> Vec<TypeParam> {\n+    fn type_params(&self, ctx: &AssistContext<'_>) -> Vec<TypeParam> {\n         let type_params_in_descendant_paths =\n             self.body.descendant_paths().filter_map(|it| match ctx.sema.resolve_path(&it) {\n                 Some(PathResolution::TypeParam(type_param)) => Some(type_param),\n@@ -1596,13 +1596,13 @@ impl Function {\n         type_params_in_descendant_paths.chain(type_params_in_params).collect()\n     }\n \n-    fn make_param_list(&self, ctx: &AssistContext, module: hir::Module) -> ast::ParamList {\n+    fn make_param_list(&self, ctx: &AssistContext<'_>, module: hir::Module) -> ast::ParamList {\n         let self_param = self.self_param.clone();\n         let params = self.params.iter().map(|param| param.to_param(ctx, module));\n         make::param_list(self_param, params)\n     }\n \n-    fn make_ret_ty(&self, ctx: &AssistContext, module: hir::Module) -> Option<ast::RetType> {\n+    fn make_ret_ty(&self, ctx: &AssistContext<'_>, module: hir::Module) -> Option<ast::RetType> {\n         let fun_ty = self.return_type(ctx);\n         let handler = if self.mods.is_in_tail {\n             FlowHandler::None\n@@ -1649,7 +1649,7 @@ impl Function {\n }\n \n impl FunType {\n-    fn make_ty(&self, ctx: &AssistContext, module: hir::Module) -> ast::Type {\n+    fn make_ty(&self, ctx: &AssistContext<'_>, module: hir::Module) -> ast::Type {\n         match self {\n             FunType::Unit => make::ty_unit(),\n             FunType::Single(ty) => make_ty(ty, ctx, module),\n@@ -1672,7 +1672,7 @@ impl FunType {\n }\n \n fn make_body(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     old_indent: IndentLevel,\n     new_indent: IndentLevel,\n     fun: &Function,\n@@ -1821,17 +1821,17 @@ fn with_tail_expr(block: ast::BlockExpr, tail_expr: ast::Expr) -> ast::BlockExpr\n     make::block_expr(stmts, Some(tail_expr))\n }\n \n-fn format_type(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> String {\n+fn format_type(ty: &hir::Type, ctx: &AssistContext<'_>, module: hir::Module) -> String {\n     ty.display_source_code(ctx.db(), module.into()).ok().unwrap_or_else(|| \"_\".to_string())\n }\n \n-fn make_ty(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> ast::Type {\n+fn make_ty(ty: &hir::Type, ctx: &AssistContext<'_>, module: hir::Module) -> ast::Type {\n     let ty_str = format_type(ty, ctx, module);\n     make::ty(&ty_str)\n }\n \n fn rewrite_body_segment(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     params: &[Param],\n     handler: &FlowHandler,\n     syntax: &SyntaxNode,\n@@ -1842,7 +1842,7 @@ fn rewrite_body_segment(\n }\n \n /// change all usages to account for added `&`/`&mut` for some params\n-fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode) -> SyntaxNode {\n+fn fix_param_usages(ctx: &AssistContext<'_>, params: &[Param], syntax: &SyntaxNode) -> SyntaxNode {\n     let mut usages_for_param: Vec<(&Param, Vec<ast::Expr>)> = Vec::new();\n \n     let tm = TreeMutator::new(syntax);"}, {"sha": "b3c4d306ac1c58d64fc3b1e4281dfc826ff4d467", "filename": "crates/ide-assists/src/handlers/extract_module.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -53,7 +53,7 @@ use super::remove_unused_param::range_to_remove;\n //     name + 2\n // }\n // ```\n-pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     if ctx.has_empty_selection() {\n         return None;\n     }\n@@ -234,7 +234,7 @@ fn extract_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Modul\n impl Module {\n     fn get_usages_and_record_fields(\n         &self,\n-        ctx: &AssistContext,\n+        ctx: &AssistContext<'_>,\n     ) -> (HashMap<FileId, Vec<(TextRange, String)>>, Vec<SyntaxNode>) {\n         let mut adt_fields = Vec::new();\n         let mut refs: HashMap<FileId, Vec<(TextRange, String)>> = HashMap::new();\n@@ -318,7 +318,7 @@ impl Module {\n \n     fn expand_and_group_usages_file_wise(\n         &self,\n-        ctx: &AssistContext,\n+        ctx: &AssistContext<'_>,\n         node_def: Definition,\n         refs_in_files: &mut HashMap<FileId, Vec<(TextRange, String)>>,\n     ) {\n@@ -396,7 +396,7 @@ impl Module {\n     fn resolve_imports(\n         &mut self,\n         curr_parent_module: Option<ast::Module>,\n-        ctx: &AssistContext,\n+        ctx: &AssistContext<'_>,\n     ) -> Vec<TextRange> {\n         let mut import_paths_to_be_removed: Vec<TextRange> = vec![];\n         let mut node_set: HashSet<String> = HashSet::new();\n@@ -471,7 +471,7 @@ impl Module {\n         def: Definition,\n         node_syntax: &SyntaxNode,\n         curr_parent_module: &Option<ast::Module>,\n-        ctx: &AssistContext,\n+        ctx: &AssistContext<'_>,\n     ) -> Option<TextRange> {\n         //We only need to find in the current file\n         let selection_range = ctx.selection_trimmed();\n@@ -684,7 +684,7 @@ fn check_intersection_and_push(\n \n fn does_source_exists_outside_sel_in_same_mod(\n     def: Definition,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     curr_parent_module: &Option<ast::Module>,\n     selection_range: TextRange,\n     curr_file_id: FileId,\n@@ -904,7 +904,7 @@ fn add_change_vis(vis: Option<ast::Visibility>, node_or_token_opt: Option<syntax\n fn compare_hir_and_ast_module(\n     ast_module: &ast::Module,\n     hir_module: hir::Module,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n ) -> Option<()> {\n     let hir_mod_name = hir_module.name(ctx.db())?;\n     let ast_mod_name = ast_module.name()?;"}, {"sha": "a93648f2d315aee65ca326a5fd8b8b5f3b13e2e0", "filename": "crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -37,7 +37,7 @@ use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind,\n // ```\n pub(crate) fn extract_struct_from_enum_variant(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n ) -> Option<()> {\n     let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n     let field_list = extract_field_list_if_applicable(&variant)?;\n@@ -373,7 +373,7 @@ fn apply_references(\n }\n \n fn process_references(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     builder: &mut AssistBuilder,\n     visited_modules: &mut FxHashSet<Module>,\n     enum_module_def: &ModuleDef,\n@@ -407,7 +407,7 @@ fn process_references(\n }\n \n fn reference_to_node(\n-    sema: &hir::Semantics<RootDatabase>,\n+    sema: &hir::Semantics<'_, RootDatabase>,\n     reference: FileReference,\n ) -> Option<(ast::PathSegment, SyntaxNode, hir::Module)> {\n     let segment ="}, {"sha": "af584cdb4384aa96b508775bfaec88932b14b456", "filename": "crates/ide-assists/src/handlers/extract_type_alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -25,7 +25,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     field: Type,\n // }\n // ```\n-pub(crate) fn extract_type_alias(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn extract_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     if ctx.has_empty_selection() {\n         return None;\n     }"}, {"sha": "3596b6f82381b5ff1d6127ed162ca27b58aa972e", "filename": "crates/ide-assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -27,7 +27,7 @@ use crate::{utils::suggest_name, AssistContext, AssistId, AssistKind, Assists};\n //     var_name * 4;\n // }\n // ```\n-pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     if ctx.has_empty_selection() {\n         return None;\n     }\n@@ -164,7 +164,7 @@ fn valid_target_expr(node: SyntaxNode) -> Option<ast::Expr> {\n     }\n }\n \n-fn get_receiver_type(ctx: &AssistContext, expression: &ast::Expr) -> Option<hir::Type> {\n+fn get_receiver_type(ctx: &AssistContext<'_>, expression: &ast::Expr) -> Option<hir::Type> {\n     let receiver = get_receiver(expression.clone())?;\n     Some(ctx.sema.type_of_expr(&receiver)?.original())\n }"}, {"sha": "b33846f546653e9095520861ea3d4fa819803a91", "filename": "crates/ide-assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -30,12 +30,12 @@ use crate::{utils::vis_offset, AssistContext, AssistId, AssistKind, Assists};\n //     m::frobnicate() {}\n // }\n // ```\n-pub(crate) fn fix_visibility(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn fix_visibility(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     add_vis_to_referenced_module_def(acc, ctx)\n         .or_else(|| add_vis_to_referenced_record_field(acc, ctx))\n }\n \n-fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let path: ast::Path = ctx.find_node_at_offset()?;\n     let path_res = ctx.sema.resolve_path(&path)?;\n     let def = match path_res {\n@@ -82,7 +82,7 @@ fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> O\n     })\n }\n \n-fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let record_field: ast::RecordExprField = ctx.find_node_at_offset()?;\n     let (record_field_def, _, _) = ctx.sema.resolve_record_field(&record_field)?;\n "}, {"sha": "2ea6f58fa0f1e25cd18b540dfa6ca66d5b090207", "filename": "crates/ide-assists/src/handlers/flip_binexpr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -17,7 +17,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     let _ = 2 + 90;\n // }\n // ```\n-pub(crate) fn flip_binexpr(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn flip_binexpr(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<BinExpr>()?;\n     let lhs = expr.lhs()?.syntax().clone();\n     let rhs = expr.rhs()?.syntax().clone();"}, {"sha": "f40f2713ad1319a5affc21f27100263ef49dbabb", "filename": "crates/ide-assists/src/handlers/flip_comma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_comma.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -17,7 +17,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     ((3, 4), (1, 2));\n // }\n // ```\n-pub(crate) fn flip_comma(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn flip_comma(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let comma = ctx.find_token_syntax_at_offset(T![,])?;\n     let prev = non_trivia_sibling(comma.clone().into(), Direction::Prev)?;\n     let next = non_trivia_sibling(comma.clone().into(), Direction::Next)?;"}, {"sha": "e3ae4970b6a7a172e7c9050277cab3fc9b9f4523", "filename": "crates/ide-assists/src/handlers/flip_trait_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -17,7 +17,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n // fn foo<T: Copy + Clone>() { }\n // ```\n-pub(crate) fn flip_trait_bound(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn flip_trait_bound(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     // We want to replicate the behavior of `flip_binexpr` by only suggesting\n     // the assist when the cursor is on a `+`\n     let plus = ctx.find_token_syntax_at_offset(T![+])?;"}, {"sha": "eaa6de73eb35d4bc0ec6ffafb1ba464e29d4507b", "filename": "crates/ide-assists/src/handlers/generate_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -31,7 +31,7 @@ use syntax::{\n // }\n // ```\n \n-pub(crate) fn generate_constant(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_constant(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let constant_token = ctx.find_node_at_offset::<ast::NameRef>()?;\n     if constant_token.to_string().chars().any(|it| !(it.is_uppercase() || it == '_')) {\n         cov_mark::hit!(not_constant_name);\n@@ -113,7 +113,7 @@ fn get_text_for_generate_constant(\n }\n \n fn target_data_for_generate_constant(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     current_module: Module,\n     constant_module: Module,\n ) -> Option<(TextSize, IndentLevel, Option<FileId>, String)> {"}, {"sha": "5e9995a9866445ec96dca5a9991440551119f169", "filename": "crates/ide-assists/src/handlers/generate_default_from_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -30,7 +30,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n pub(crate) fn generate_default_from_enum_variant(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n ) -> Option<()> {\n     let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n     let variant_name = variant.name()?;"}, {"sha": "cbd33de19eda0c047675d36cb966e4133d14158a", "filename": "crates/ide-assists/src/handlers/generate_default_from_new.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -40,7 +40,7 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn generate_default_from_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_default_from_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let fn_node = ctx.find_node_at_offset::<ast::Fn>()?;\n     let fn_name = fn_node.name()?;\n \n@@ -122,7 +122,7 @@ fn generate_trait_impl_text_from_impl(impl_: &ast::Impl, trait_text: &str, code:\n     buf\n }\n \n-fn is_default_implemented(ctx: &AssistContext, impl_: &Impl) -> bool {\n+fn is_default_implemented(ctx: &AssistContext<'_>, impl_: &Impl) -> bool {\n     let db = ctx.sema.db;\n     let impl_ = ctx.sema.to_def(impl_);\n     let impl_def = match impl_ {"}, {"sha": "85b193663a05bc5e2798d7408d53a08500c43b93", "filename": "crates/ide-assists/src/handlers/generate_delegate_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -42,7 +42,7 @@ use syntax::ast::edit::AstNodeEdit;\n //     }\n // }\n // ```\n-pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n     let strukt_name = strukt.name()?;\n     let current_module = ctx.sema.scope(strukt.syntax())?.module();"}, {"sha": "b9637ee8d7c60bece754d922ccc73e504ee857ce", "filename": "crates/ide-assists/src/handlers/generate_deref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -39,11 +39,11 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn generate_deref(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     generate_record_deref(acc, ctx).or_else(|| generate_tuple_deref(acc, ctx))\n }\n \n-fn generate_record_deref(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+fn generate_record_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n     let field = ctx.find_node_at_offset::<ast::RecordField>()?;\n \n@@ -80,7 +80,7 @@ fn generate_record_deref(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     )\n }\n \n-fn generate_tuple_deref(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+fn generate_tuple_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n     let field = ctx.find_node_at_offset::<ast::TupleField>()?;\n     let field_list = ctx.find_node_at_offset::<ast::TupleFieldList>()?;"}, {"sha": "339245b94eca4250bb73ff1d664b8433905364ff", "filename": "crates/ide-assists/src/handlers/generate_derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -24,7 +24,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     y: u32,\n // }\n // ```\n-pub(crate) fn generate_derive(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_derive(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let cap = ctx.config.snippet_cap?;\n     let nominal = ctx.find_node_at_offset::<ast::Adt>()?;\n     let node_start = derive_insertion_offset(&nominal)?;"}, {"sha": "c91141f8eb50f27fd41ccf8634587c62c2b55747", "filename": "crates/ide-assists/src/handlers/generate_documentation_template.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -42,7 +42,7 @@ use crate::assist_context::{AssistContext, Assists};\n // ```\n pub(crate) fn generate_documentation_template(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n ) -> Option<()> {\n     let name = ctx.find_node_at_offset::<ast::Name>()?;\n     let ast_func = name.syntax().parent().and_then(ast::Fn::cast)?;\n@@ -94,7 +94,7 @@ pub(crate) fn generate_documentation_template(\n // /// ```\n // pub fn add(a: i32, b: i32) -> i32 { a + b }\n // ```\n-pub(crate) fn generate_doc_example(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_doc_example(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let tok: ast::Comment = ctx.find_token_at_offset()?;\n     let node = tok.syntax().parent()?;\n     let last_doc_token =\n@@ -126,7 +126,7 @@ pub(crate) fn generate_doc_example(acc: &mut Assists, ctx: &AssistContext) -> Op\n     )\n }\n \n-fn make_example_for_fn(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n+fn make_example_for_fn(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<String> {\n     if !is_public(ast_func, ctx)? {\n         // Doctests for private items can't actually name the item, so they're pretty useless.\n         return None;\n@@ -176,7 +176,7 @@ fn make_example_for_fn(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String\n     Some(example)\n }\n \n-fn introduction_builder(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n+fn introduction_builder(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<String> {\n     let hir_func = ctx.sema.to_def(ast_func)?;\n     let container = hir_func.as_assoc_item(ctx.db())?.container(ctx.db());\n     if let hir::AssocItemContainer::Impl(imp) = container {\n@@ -270,7 +270,7 @@ fn safety_builder(ast_func: &ast::Fn) -> Option<Vec<String>> {\n }\n \n /// Checks if the function is public / exported\n-fn is_public(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<bool> {\n+fn is_public(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<bool> {\n     let hir_func = ctx.sema.to_def(ast_func)?;\n     Some(\n         hir_func.visibility(ctx.db()) == Visibility::Public\n@@ -279,7 +279,7 @@ fn is_public(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<bool> {\n }\n \n /// Checks that all parent modules of the function are public / exported\n-fn all_parent_mods_public(hir_func: &hir::Function, ctx: &AssistContext) -> bool {\n+fn all_parent_mods_public(hir_func: &hir::Function, ctx: &AssistContext<'_>) -> bool {\n     let mut module = hir_func.module(ctx.db());\n     loop {\n         if let Some(parent) = module.parent(ctx.db()) {\n@@ -294,7 +294,7 @@ fn all_parent_mods_public(hir_func: &hir::Function, ctx: &AssistContext) -> bool\n }\n \n /// Returns the name of the current crate\n-fn crate_name(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n+fn crate_name(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<String> {\n     let krate = ctx.sema.scope(ast_func.syntax())?.krate();\n     Some(krate.display_name(ctx.db())?.to_string())\n }\n@@ -351,7 +351,7 @@ fn self_partial_type(ast_func: &ast::Fn) -> Option<String> {\n }\n \n /// Helper function to determine if the function is in a trait implementation\n-fn is_in_trait_impl(ast_func: &ast::Fn, ctx: &AssistContext) -> bool {\n+fn is_in_trait_impl(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> bool {\n     ctx.sema\n         .to_def(ast_func)\n         .and_then(|hir_func| hir_func.as_assoc_item(ctx.db()))\n@@ -360,7 +360,7 @@ fn is_in_trait_impl(ast_func: &ast::Fn, ctx: &AssistContext) -> bool {\n }\n \n /// Helper function to determine if the function definition is in a trait definition\n-fn is_in_trait_def(ast_func: &ast::Fn, ctx: &AssistContext) -> bool {\n+fn is_in_trait_def(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> bool {\n     ctx.sema\n         .to_def(ast_func)\n         .and_then(|hir_func| hir_func.as_assoc_item(ctx.db()))\n@@ -462,7 +462,7 @@ fn string_vec_from(string_array: &[&str]) -> Vec<String> {\n }\n \n /// Helper function to build the path of the module in the which is the node\n-fn build_path(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n+fn build_path(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<String> {\n     let crate_name = crate_name(ast_func, ctx)?;\n     let leaf = self_partial_type(ast_func)\n         .or_else(|| ast_func.name().map(|n| n.to_string()))\n@@ -480,7 +480,7 @@ fn return_type(ast_func: &ast::Fn) -> Option<ast::Type> {\n }\n \n /// Helper function to determine if the function returns some data\n-fn returns_a_value(ast_func: &ast::Fn, ctx: &AssistContext) -> bool {\n+fn returns_a_value(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> bool {\n     ctx.sema\n         .to_def(ast_func)\n         .map(|hir_func| hir_func.ret_type(ctx.db()))"}, {"sha": "52d27d8a7d63350b385cf74c5806e23bb612c9c0", "filename": "crates/ide-assists/src/handlers/generate_enum_is_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -37,7 +37,7 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n     let variant_name = variant.name()?;\n     let parent_enum = ast::Adt::Enum(variant.parent_enum());"}, {"sha": "e7646421c7aa94a5b77ba3219e143cbfa81fb568", "filename": "crates/ide-assists/src/handlers/generate_enum_projection_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -36,7 +36,7 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn generate_enum_try_into_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_enum_try_into_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     generate_enum_projection_method(\n         acc,\n         ctx,\n@@ -80,7 +80,7 @@ pub(crate) fn generate_enum_try_into_method(acc: &mut Assists, ctx: &AssistConte\n //     }\n // }\n // ```\n-pub(crate) fn generate_enum_as_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_enum_as_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     generate_enum_projection_method(\n         acc,\n         ctx,\n@@ -108,7 +108,7 @@ struct ProjectionProps {\n \n fn generate_enum_projection_method(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     assist_id: &'static str,\n     assist_description: &str,\n     props: ProjectionProps,"}, {"sha": "4461fbd5ac82709eeb7a6f0b6ff904c88c250028", "filename": "crates/ide-assists/src/handlers/generate_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -31,7 +31,7 @@ use crate::assist_context::{AssistContext, Assists};\n //     let country = Countries::Lesotho;\n // }\n // ```\n-pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let path = path_expr.path()?;\n \n@@ -58,7 +58,7 @@ pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext) -> O\n \n fn add_variant_to_accumulator(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     target: syntax::TextRange,\n     adt: hir::Enum,\n     name_ref: &ast::NameRef,"}, {"sha": "157ad3b74e1285c577ec72e45a0efec1b7bd87b8", "filename": "crates/ide-assists/src/handlers/generate_from_impl_for_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -20,7 +20,7 @@ use crate::{utils::generate_trait_impl_text, AssistContext, AssistId, AssistKind\n //     }\n // }\n // ```\n-pub(crate) fn generate_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n     let variant_name = variant.name()?;\n     let enum_ = ast::Adt::Enum(variant.parent_enum());"}, {"sha": "d564a0540898e77ac694f3dd0bc9d4ff61c003e3", "filename": "crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -46,11 +46,11 @@ use crate::{\n // }\n //\n // ```\n-pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     gen_fn(acc, ctx).or_else(|| gen_method(acc, ctx))\n }\n \n-fn gen_fn(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+fn gen_fn(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let path = path_expr.path()?;\n@@ -113,7 +113,7 @@ fn gen_fn(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     )\n }\n \n-fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+fn gen_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n     if ctx.sema.resolve_method_call(&call).is_some() {\n         return None;\n@@ -149,7 +149,7 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n \n fn add_func_to_accumulator(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     text_range: TextRange,\n     function_builder: FunctionBuilder,\n     insert_offset: TextSize,\n@@ -172,7 +172,7 @@ fn add_func_to_accumulator(\n }\n \n fn get_adt_source(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     adt: &hir::Adt,\n     fn_name: &str,\n ) -> Option<(Option<ast::Impl>, FileId)> {\n@@ -229,7 +229,7 @@ impl FunctionBuilder {\n     /// Prepares a generated function that matches `call`.\n     /// The function is generated in `target_module` or next to `call`\n     fn from_call(\n-        ctx: &AssistContext,\n+        ctx: &AssistContext<'_>,\n         call: &ast::CallExpr,\n         fn_name: &str,\n         target_module: Option<hir::Module>,\n@@ -261,7 +261,7 @@ impl FunctionBuilder {\n     }\n \n     fn from_method_call(\n-        ctx: &AssistContext,\n+        ctx: &AssistContext<'_>,\n         call: &ast::MethodCallExpr,\n         name: &ast::NameRef,\n         target_module: Module,\n@@ -344,7 +344,7 @@ impl FunctionBuilder {\n /// * If we could infer the return type, don't focus it (and thus focus the function body) so the\n /// user can change the `todo!` function body.\n fn make_return_type(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     call: &ast::Expr,\n     target_module: Module,\n ) -> (Option<ast::RetType>, bool) {\n@@ -367,7 +367,7 @@ fn make_return_type(\n }\n \n fn get_fn_target(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     target_module: &Option<Module>,\n     call: CallExpr,\n ) -> Option<(GeneratedFunctionTarget, FileId, TextSize)> {\n@@ -385,7 +385,7 @@ fn get_fn_target(\n }\n \n fn get_method_target(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     target_module: &Module,\n     impl_: &Option<ast::Impl>,\n ) -> Option<(GeneratedFunctionTarget, TextSize)> {\n@@ -423,7 +423,7 @@ impl GeneratedFunctionTarget {\n \n /// Computes the type variables and arguments required for the generated function\n fn fn_args(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     target_module: hir::Module,\n     call: ast::CallableExpr,\n ) -> Option<(Option<ast::GenericParamList>, ast::ParamList)> {\n@@ -482,7 +482,7 @@ fn deduplicate_arg_names(arg_names: &mut Vec<String>) {\n     }\n }\n \n-fn fn_arg_name(sema: &Semantics<RootDatabase>, arg_expr: &ast::Expr) -> String {\n+fn fn_arg_name(sema: &Semantics<'_, RootDatabase>, arg_expr: &ast::Expr) -> String {\n     let name = (|| match arg_expr {\n         ast::Expr::CastExpr(cast_expr) => Some(fn_arg_name(sema, &cast_expr.expr()?)),\n         expr => {\n@@ -510,9 +510,9 @@ fn fn_arg_name(sema: &Semantics<RootDatabase>, arg_expr: &ast::Expr) -> String {\n     }\n }\n \n-fn fn_arg_type(ctx: &AssistContext, target_module: hir::Module, fn_arg: &ast::Expr) -> String {\n+fn fn_arg_type(ctx: &AssistContext<'_>, target_module: hir::Module, fn_arg: &ast::Expr) -> String {\n     fn maybe_displayed_type(\n-        ctx: &AssistContext,\n+        ctx: &AssistContext<'_>,\n         target_module: hir::Module,\n         fn_arg: &ast::Expr,\n     ) -> Option<String> {\n@@ -593,7 +593,7 @@ fn next_space_for_fn_in_impl(impl_: &ast::Impl) -> Option<GeneratedFunctionTarge\n     }\n }\n \n-fn module_is_descendant(module: &hir::Module, ans: &hir::Module, ctx: &AssistContext) -> bool {\n+fn module_is_descendant(module: &hir::Module, ans: &hir::Module, ctx: &AssistContext<'_>) -> bool {\n     if module == ans {\n         return true;\n     }"}, {"sha": "76fcef0cad9512a7b823be4cb3bce514923f29f8", "filename": "crates/ide-assists/src/handlers/generate_getter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -43,7 +43,7 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn generate_getter(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_getter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     generate_getter_impl(acc, ctx, false)\n }\n \n@@ -68,13 +68,13 @@ pub(crate) fn generate_getter(acc: &mut Assists, ctx: &AssistContext) -> Option<\n //     }\n // }\n // ```\n-pub(crate) fn generate_getter_mut(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_getter_mut(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     generate_getter_impl(acc, ctx, true)\n }\n \n pub(crate) fn generate_getter_impl(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     mutable: bool,\n ) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;"}, {"sha": "68287a20bf8068ac45677908396ee9bf06c366fb", "filename": "crates/ide-assists/src/handlers/generate_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -21,7 +21,7 @@ use crate::{utils::generate_impl_text, AssistContext, AssistId, AssistKind, Assi\n //     $0\n // }\n // ```\n-pub(crate) fn generate_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let nominal = ctx.find_node_at_offset::<ast::Adt>()?;\n     let name = nominal.name()?;\n     let target = nominal.syntax().text_range();"}, {"sha": "9ce525ca375c8ed3a1b6d3b8afce1d4658e0d730", "filename": "crates/ide-assists/src/handlers/generate_is_empty_from_len.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -39,7 +39,7 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn generate_is_empty_from_len(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_is_empty_from_len(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let fn_node = ctx.find_node_at_offset::<ast::Fn>()?;\n     let fn_name = fn_node.name()?;\n \n@@ -86,7 +86,7 @@ pub(crate) fn generate_is_empty_from_len(acc: &mut Assists, ctx: &AssistContext)\n }\n \n fn get_impl_method(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     impl_: &ast::Impl,\n     fn_name: &Name,\n ) -> Option<hir::Function> {"}, {"sha": "f27538259544c06e13cadf319500589c8f129202", "filename": "crates/ide-assists/src/handlers/generate_new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -29,7 +29,7 @@ use crate::{\n //     fn $0new(data: T) -> Self { Self { data } }\n // }\n // ```\n-pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n \n     // We want to only apply this to non-union structs with named fields"}, {"sha": "2a7ad6ce3681145f0f8940124e5c2a8709d882a7", "filename": "crates/ide-assists/src/handlers/generate_setter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -27,7 +27,7 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn generate_setter(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_setter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n     let field = ctx.find_node_at_offset::<ast::RecordField>()?;\n "}, {"sha": "658a1aadf53ecf9e0549f27af1671d3d0b9bd127", "filename": "crates/ide-assists/src/handlers/inline_call.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -59,7 +59,7 @@ use crate::{\n //     };\n // }\n // ```\n-pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let def_file = ctx.file_id();\n     let name = ctx.find_node_at_offset::<ast::Name>()?;\n     let ast_func = name.syntax().parent().and_then(ast::Fn::cast)?;\n@@ -174,7 +174,7 @@ pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext) -> Opt\n //         };\n // }\n // ```\n-pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let name_ref: ast::NameRef = ctx.find_node_at_offset()?;\n     let call_info = CallInfo::from_name_ref(name_ref.clone())?;\n     let (function, label) = match &call_info.node {\n@@ -294,7 +294,7 @@ fn get_fn_params(\n }\n \n fn inline(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     function_def_file_id: FileId,\n     function: hir::Function,\n     fn_body: &ast::BlockExpr,"}, {"sha": "7259d67819416e502dcceb64452b5f3b2bedc6a6", "filename": "crates/ide-assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -32,7 +32,7 @@ use crate::{\n //     (1 + 2) * 4;\n // }\n // ```\n-pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let file_id = ctx.file_id();\n     let range = ctx.selection_trimmed();\n     let InlineData { let_stmt, delete_let, references, target } =\n@@ -149,7 +149,7 @@ struct InlineData {\n }\n \n fn inline_let(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     let_stmt: ast::LetStmt,\n     range: TextRange,\n     file_id: FileId,\n@@ -184,7 +184,7 @@ fn inline_let(\n }\n \n fn inline_usage(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     path_expr: ast::PathExpr,\n     range: TextRange,\n     file_id: FileId,"}, {"sha": "054663a06a1154b2868c00590dcc1a325b67e1e2", "filename": "crates/ide-assists/src/handlers/inline_type_alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -35,7 +35,7 @@ use crate::{\n //     let a: Vec<u32>;\n // }\n // ```\n-pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     enum Replacement {\n         Generic { lifetime_map: LifetimeMap, const_and_type_map: ConstAndTypeMap },\n         Plain,\n@@ -252,7 +252,7 @@ fn create_replacement(\n     updated_concrete_type.to_string()\n }\n \n-fn get_type_alias(ctx: &AssistContext, path: &ast::PathType) -> Option<ast::TypeAlias> {\n+fn get_type_alias(ctx: &AssistContext<'_>, path: &ast::PathType) -> Option<ast::TypeAlias> {\n     let resolved_path = ctx.sema.resolve_path(&path.path()?)?;\n \n     // We need the generics in the correct order to be able to map any provided"}, {"sha": "062c816aef0dad95e11d81f48bb230d039b0bcef", "filename": "crates/ide-assists/src/handlers/introduce_named_generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_generic.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -16,7 +16,7 @@ use crate::{utils::suggest_name, AssistContext, AssistId, AssistKind, Assists};\n // ```\n // fn foo<B: Bar>(bar: B) {}\n // ```\n-pub(crate) fn introduce_named_generic(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn introduce_named_generic(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let impl_trait_type = ctx.find_node_at_offset::<ast::ImplTraitType>()?;\n     let param = impl_trait_type.syntax().parent().and_then(ast::Param::cast)?;\n     let fn_ = param.syntax().ancestors().find_map(ast::Fn::cast)?;"}, {"sha": "ce91dd23703b6dd89633392ab440a3ed9920142b", "filename": "crates/ide-assists/src/handlers/introduce_named_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -33,7 +33,7 @@ static ASSIST_LABEL: &str = \"Introduce named lifetime\";\n //     }\n // }\n // ```\n-pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     // FIXME: How can we handle renaming any one of multiple anonymous lifetimes?\n     // FIXME: should also add support for the case fun(f: &Foo) -> &$0Foo\n     let lifetime ="}, {"sha": "547158e29778e4bdd273c9e0ad0499b636aecab5", "filename": "crates/ide-assists/src/handlers/invert_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -26,7 +26,7 @@ use crate::{\n //     if y { B } else { A }\n // }\n // ```\n-pub(crate) fn invert_if(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn invert_if(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let if_keyword = ctx.find_token_syntax_at_offset(T![if])?;\n     let expr = ast::IfExpr::cast(if_keyword.parent()?)?;\n     let if_range = if_keyword.text_range();"}, {"sha": "7e102ceba891ae2f9d3d2f5132b8a2fff678a9d9", "filename": "crates/ide-assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -22,7 +22,7 @@ use Edit::*;\n // ```\n // use std::{fmt::Formatter, io};\n // ```\n-pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (target, edits) = if ctx.has_empty_selection() {\n         // Merge a neighbor\n         let tree: ast::UseTree = ctx.find_node_at_offset()?;"}, {"sha": "c24015b1c5175a410d45dab0974e913b78346de1", "filename": "crates/ide-assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -32,7 +32,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists, TextRange};\n //     }\n // }\n // ```\n-pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let current_arm = ctx.find_node_at_offset::<ast::MatchArm>()?;\n     // Don't try to handle arms with guards for now - can add support for this later\n     if current_arm.guard().is_some() {\n@@ -97,7 +97,7 @@ fn contains_placeholder(a: &ast::MatchArm) -> bool {\n fn are_same_types(\n     current_arm_types: &HashMap<String, Option<TypeInfo>>,\n     arm: &ast::MatchArm,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n ) -> bool {\n     let arm_types = get_arm_types(ctx, arm);\n     for (other_arm_type_name, other_arm_type) in arm_types {\n@@ -112,14 +112,14 @@ fn are_same_types(\n }\n \n fn get_arm_types(\n-    context: &AssistContext,\n+    context: &AssistContext<'_>,\n     arm: &ast::MatchArm,\n ) -> HashMap<String, Option<TypeInfo>> {\n     let mut mapping: HashMap<String, Option<TypeInfo>> = HashMap::new();\n \n     fn recurse(\n         map: &mut HashMap<String, Option<TypeInfo>>,\n-        ctx: &AssistContext,\n+        ctx: &AssistContext<'_>,\n         pat: &Option<ast::Pat>,\n     ) {\n         if let Some(local_pat) = pat {"}, {"sha": "7fa1a0d2cafb910fd58bc5735d93a2003855881c", "filename": "crates/ide-assists/src/handlers/move_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -20,7 +20,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     f(x)\n // }\n // ```\n-pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let type_param_list = ctx.find_node_at_offset::<ast::GenericParamList>()?;\n \n     let mut type_params = type_param_list.type_or_const_params();"}, {"sha": "a6c85a2b18b34b535c9e98e3ea01fbfc4b4f2dc6", "filename": "crates/ide-assists/src/handlers/move_from_mod_rs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -23,7 +23,7 @@ use crate::{\n // ```\n // fn t() {}\n // ```\n-pub(crate) fn move_from_mod_rs(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn move_from_mod_rs(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let source_file = ctx.find_node_at_offset::<ast::SourceFile>()?;\n     let module = ctx.sema.to_module_def(ctx.file_id())?;\n     // Enable this assist if the user select all \"meaningful\" content in the source file"}, {"sha": "778a31f99dd26cb5898270d6e812932940dea331", "filename": "crates/ide-assists/src/handlers/move_guard.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -32,7 +32,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     }\n // }\n // ```\n-pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let match_arm = ctx.find_node_at_offset::<MatchArm>()?;\n     let guard = match_arm.guard()?;\n     if ctx.offset() > guard.syntax().text_range().end() {\n@@ -91,7 +91,7 @@ pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) ->\n //     }\n // }\n // ```\n-pub(crate) fn move_arm_cond_to_match_guard(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn move_arm_cond_to_match_guard(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let match_arm: MatchArm = ctx.find_node_at_offset::<MatchArm>()?;\n     let match_pat = match_arm.pat()?;\n     let arm_body = match_arm.expr()?;"}, {"sha": "7468318a594afbea619df9e475aebdb414030484", "filename": "crates/ide-assists/src/handlers/move_module_to_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -24,7 +24,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n // mod foo;\n // ```\n-pub(crate) fn move_module_to_file(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn move_module_to_file(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let module_ast = ctx.find_node_at_offset::<ast::Module>()?;\n     let module_items = module_ast.item_list()?;\n "}, {"sha": "a909ce8b26791af34208f0aa32b20017978e697b", "filename": "crates/ide-assists/src/handlers/move_to_mod_rs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -23,7 +23,7 @@ use crate::{\n // ```\n // fn t() {}\n // ```\n-pub(crate) fn move_to_mod_rs(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn move_to_mod_rs(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let source_file = ctx.find_node_at_offset::<ast::SourceFile>()?;\n     let module = ctx.sema.to_module_def(ctx.file_id())?;\n     // Enable this assist if the user select all \"meaningful\" content in the source file"}, {"sha": "424db7437a743b4bce4fa639dc500048718f87d7", "filename": "crates/ide-assists/src/handlers/number_representation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fnumber_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fnumber_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fnumber_representation.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -15,7 +15,7 @@ const MIN_NUMBER_OF_DIGITS_TO_FORMAT: usize = 5;\n // ```\n // const _: i32 = 1_012_345;\n // ```\n-pub(crate) fn reformat_number_literal(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn reformat_number_literal(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let literal = ctx.find_node_at_offset::<ast::Literal>()?;\n     let literal = match literal.kind() {\n         ast::LiteralKind::IntNumber(it) => it,"}, {"sha": "cbbea6c1e6373793e5c6392db508b5778c76e6b9", "filename": "crates/ide-assists/src/handlers/promote_local_to_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -44,7 +44,7 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn promote_local_to_const(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn promote_local_to_const(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let pat = ctx.find_node_at_offset::<ast::IdentPat>()?;\n     let name = pat.name()?;\n     if !pat.is_simple_ident() {\n@@ -95,7 +95,7 @@ pub(crate) fn promote_local_to_const(acc: &mut Assists, ctx: &AssistContext) ->\n     )\n }\n \n-fn is_body_const(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> bool {\n+fn is_body_const(sema: &Semantics<'_, RootDatabase>, expr: &ast::Expr) -> bool {\n     let mut is_const = true;\n     preorder_expr(expr, &mut |ev| {\n         let expr = match ev {"}, {"sha": "4cfe6c99b23c290e15b847a1cabb3cd1fe54922b", "filename": "crates/ide-assists/src/handlers/pull_assignment_up.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -35,7 +35,7 @@ use crate::{\n //     };\n // }\n // ```\n-pub(crate) fn pull_assignment_up(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn pull_assignment_up(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let assign_expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n \n     let op_kind = assign_expr.op_kind()?;\n@@ -151,7 +151,7 @@ impl<'a> AssignmentsCollector<'a> {\n }\n \n fn is_equivalent(\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n+    sema: &hir::Semantics<'_, ide_db::RootDatabase>,\n     expr0: &ast::Expr,\n     expr1: &ast::Expr,\n ) -> bool {"}, {"sha": "121f8b4a136839dfcf1a7f040cb9a7e317d3fb0d", "filename": "crates/ide-assists/src/handlers/qualify_method_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -32,7 +32,7 @@ use crate::{\n //     Foo::foo(&foo);\n // }\n // ```\n-pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let name: ast::NameRef = ctx.find_node_at_offset()?;\n     let call = name.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n "}, {"sha": "0c2e9da38639fbcf8844cace2d83bf71599724fa", "filename": "crates/ide-assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -35,7 +35,7 @@ use crate::{\n // }\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n-pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n     let mut proposed_imports = import_assets.search_for_relative_paths(&ctx.sema);\n     if proposed_imports.is_empty() {"}, {"sha": "dbe8cb7bf031faadb71ed8ebae13819624980f55", "filename": "crates/ide-assists/src/handlers/raw_string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -19,7 +19,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     r#\"Hello, World!\"#;\n // }\n // ```\n-pub(crate) fn make_raw_string(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn make_raw_string(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let token = ctx.find_token_at_offset::<ast::String>()?;\n     if token.is_raw() {\n         return None;\n@@ -61,7 +61,7 @@ pub(crate) fn make_raw_string(acc: &mut Assists, ctx: &AssistContext) -> Option<\n //     \"Hello, \\\"World!\\\"\";\n // }\n // ```\n-pub(crate) fn make_usual_string(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn make_usual_string(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let token = ctx.find_token_at_offset::<ast::String>()?;\n     if !token.is_raw() {\n         return None;\n@@ -103,7 +103,7 @@ pub(crate) fn make_usual_string(acc: &mut Assists, ctx: &AssistContext) -> Optio\n //     r##\"Hello, World!\"##;\n // }\n // ```\n-pub(crate) fn add_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn add_hash(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let token = ctx.find_token_at_offset::<ast::String>()?;\n     if !token.is_raw() {\n         return None;\n@@ -131,7 +131,7 @@ pub(crate) fn add_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n //     r\"Hello, World!\";\n // }\n // ```\n-pub(crate) fn remove_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn remove_hash(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let token = ctx.find_token_at_offset::<ast::String>()?;\n     if !token.is_raw() {\n         return None;"}, {"sha": "afaa7c933c73951093dea8d12d0c12557c03cc76", "filename": "crates/ide-assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -21,7 +21,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     92;\n // }\n // ```\n-pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let macro_call = ctx.find_node_at_offset::<ast::MacroCall>()?;\n     let tt = macro_call.token_tree()?;\n     let r_delim = NodeOrToken::Token(tt.right_delimiter_token()?);"}, {"sha": "0b299e8349ac1aaa5d76e22948d8da0243d9b604", "filename": "crates/ide-assists/src/handlers/remove_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_mut.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -17,7 +17,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     fn feed(&self, amount: u32) {}\n // }\n // ```\n-pub(crate) fn remove_mut(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn remove_mut(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let mut_token = ctx.find_token_syntax_at_offset(T![mut])?;\n     let delete_from = mut_token.text_range().start();\n     let delete_to = match mut_token.next_token() {"}, {"sha": "59ea94ea1ff6b64fc6cb8d16a4837d4d100fcd09", "filename": "crates/ide-assists/src/handlers/remove_unused_param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -30,7 +30,7 @@ use crate::{\n //     frobnicate();\n // }\n // ```\n-pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let param: ast::Param = ctx.find_node_at_offset()?;\n     let ident_pat = match param.pat()? {\n         ast::Pat::IdentPat(it) => it,\n@@ -87,7 +87,7 @@ pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext) -> Opt\n }\n \n fn process_usages(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     builder: &mut AssistBuilder,\n     file_id: FileId,\n     references: Vec<FileReference>,"}, {"sha": "62e396d1dc0b983040af7a4e1a7315a75e6c132c", "filename": "crates/ide-assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -19,7 +19,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // struct Foo {foo: i32, bar: i32};\n // const test: Foo = Foo {foo: 1, bar: 0}\n // ```\n-pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let record = ctx\n         .find_node_at_offset::<ast::RecordExpr>()\n         .map(Either::Left)\n@@ -86,7 +86,7 @@ fn replace<T: AstNode + PartialEq>(\n     });\n }\n \n-fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashMap<String, usize>> {\n+fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext<'_>) -> Option<FxHashMap<String, usize>> {\n     let strukt = match ctx.sema.resolve_path(path) {\n         Some(hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Struct(it)))) => it,\n         _ => return None,"}, {"sha": "970bbaa0e7b13e249f3a4d8917d75e32f4ace3ba", "filename": "crates/ide-assists/src/handlers/reorder_impl_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -42,7 +42,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     fn c() {}\n // }\n // ```\n-pub(crate) fn reorder_impl_items(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn reorder_impl_items(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let impl_ast = ctx.find_node_at_offset::<ast::Impl>()?;\n     let items = impl_ast.assoc_item_list()?;\n     let assoc_items = items.assoc_items().collect::<Vec<_>>();\n@@ -93,7 +93,7 @@ pub(crate) fn reorder_impl_items(acc: &mut Assists, ctx: &AssistContext) -> Opti\n     )\n }\n \n-fn compute_item_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashMap<String, usize>> {\n+fn compute_item_ranks(path: &ast::Path, ctx: &AssistContext<'_>) -> Option<FxHashMap<String, usize>> {\n     let td = trait_definition(path, &ctx.sema)?;\n \n     Some(\n@@ -106,7 +106,7 @@ fn compute_item_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashMap\n     )\n }\n \n-fn trait_definition(path: &ast::Path, sema: &Semantics<RootDatabase>) -> Option<hir::Trait> {\n+fn trait_definition(path: &ast::Path, sema: &Semantics<'_, RootDatabase>) -> Option<hir::Trait> {\n     match sema.resolve_path(path)? {\n         PathResolution::Def(hir::ModuleDef::Trait(trait_)) => Some(trait_),\n         _ => None,"}, {"sha": "bd50208da5ffdecb81e57cb206d1ce67217529e3", "filename": "crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -42,7 +42,7 @@ use crate::{\n // ```\n pub(crate) fn replace_derive_with_manual_impl(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n ) -> Option<()> {\n     let attr = ctx.find_node_at_offset_with_descend::<ast::Attr>()?;\n     let path = attr.path()?;\n@@ -113,7 +113,7 @@ pub(crate) fn replace_derive_with_manual_impl(\n \n fn add_assist(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     attr: &ast::Attr,\n     old_derives: &[ast::Path],\n     old_tree: &ast::TokenTree,\n@@ -170,7 +170,7 @@ fn add_assist(\n }\n \n fn impl_def_from_trait(\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n+    sema: &hir::Semantics<'_, ide_db::RootDatabase>,\n     adt: &ast::Adt,\n     annotated_name: &ast::Name,\n     trait_: Option<hir::Trait>,"}, {"sha": "484c27387da94ee7fb71aa5eaf7b9cfae0be80a5", "filename": "crates/ide-assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -47,7 +47,7 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     let available_range = TextRange::new(\n         if_expr.syntax().text_range().start(),\n@@ -140,7 +140,7 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n }\n \n fn make_else_arm(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     else_block: Option<ast::BlockExpr>,\n     conditionals: &[(Either<ast::Pat, ast::Expr>, ast::BlockExpr)],\n ) -> ast::MatchArm {\n@@ -197,7 +197,7 @@ fn make_else_arm(\n //     }\n // }\n // ```\n-pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let match_expr: ast::MatchExpr = ctx.find_node_at_offset()?;\n \n     let mut arms = match_expr.match_arm_list()?.arms();\n@@ -248,7 +248,7 @@ pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext)\n \n /// Pick the pattern for the if let condition and return the expressions for the `then` body and `else` body in that order.\n fn pick_pattern_and_expr_order(\n-    sema: &hir::Semantics<RootDatabase>,\n+    sema: &hir::Semantics<'_, RootDatabase>,\n     pat: ast::Pat,\n     pat2: ast::Pat,\n     expr: ast::Expr,\n@@ -281,7 +281,7 @@ fn is_empty_expr(expr: &ast::Expr) -> bool {\n     }\n }\n \n-fn binds_name(sema: &hir::Semantics<RootDatabase>, pat: &ast::Pat) -> bool {\n+fn binds_name(sema: &hir::Semantics<'_, RootDatabase>, pat: &ast::Pat) -> bool {\n     let binds_name_v = |pat| binds_name(sema, &pat);\n     match pat {\n         ast::Pat::IdentPat(pat) => !matches!(\n@@ -303,7 +303,7 @@ fn binds_name(sema: &hir::Semantics<RootDatabase>, pat: &ast::Pat) -> bool {\n     }\n }\n \n-fn is_sad_pat(sema: &hir::Semantics<RootDatabase>, pat: &ast::Pat) -> bool {\n+fn is_sad_pat(sema: &hir::Semantics<'_, RootDatabase>, pat: &ast::Pat) -> bool {\n     sema.type_of_pat(pat)\n         .and_then(|ty| TryEnum::from_ty(sema, &ty.adjusted()))\n         .map_or(false, |it| does_pat_match_variant(pat, &it.sad_pattern()))"}, {"sha": "c2be4593b97d0c410814a9ae63dd67b587dafb1e", "filename": "crates/ide-assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -36,7 +36,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //\n // fn compute() -> Option<i32> { None }\n // ```\n-pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let let_kw = ctx.find_token_syntax_at_offset(T![let])?;\n     let let_stmt = let_kw.parent().and_then(ast::LetStmt::cast)?;\n     let init = let_stmt.initializer()?;"}, {"sha": "2419fa11c155428b66899b88589c8c22833bb2f6", "filename": "crates/ide-assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -27,7 +27,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n pub(crate) fn replace_qualified_name_with_use(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n ) -> Option<()> {\n     let path: ast::Path = ctx.find_node_at_offset()?;\n     // We don't want to mess with use statements"}, {"sha": "decb5fb62a772654e34763f992cf5683ee4d5fff", "filename": "crates/ide-assists/src/handlers/replace_string_with_char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_string_with_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_string_with_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_string_with_char.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -23,7 +23,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     find('{');\n // }\n // ```\n-pub(crate) fn replace_string_with_char(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn replace_string_with_char(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let token = ctx.find_token_syntax_at_offset(STRING).and_then(ast::String::cast)?;\n     let value = token.value()?;\n     let target = token.syntax().text_range();\n@@ -63,7 +63,7 @@ pub(crate) fn replace_string_with_char(acc: &mut Assists, ctx: &AssistContext) -\n //     find(\"{\");\n // }\n // ```\n-pub(crate) fn replace_char_with_string(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn replace_char_with_string(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let token = ctx.find_token_syntax_at_offset(CHAR)?;\n     let target = token.text_range();\n "}, {"sha": "b825998cb7a5ed61dd634b28c9635b472b25dc5e", "filename": "crates/ide-assists/src/handlers/replace_try_expr_with_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -34,7 +34,7 @@ use crate::assist_context::{AssistContext, Assists};\n //     };\n // }\n // ```\n-pub(crate) fn replace_try_expr_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn replace_try_expr_with_match(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let qm_kw = ctx.find_token_syntax_at_offset(T![?])?;\n     let qm_kw_parent = qm_kw.parent().and_then(ast::TryExpr::cast)?;\n "}, {"sha": "6112e09455a47c19c108ea4388346aef778534f7", "filename": "crates/ide-assists/src/handlers/replace_turbofish_with_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -28,7 +28,7 @@ use crate::{\n // ```\n pub(crate) fn replace_turbofish_with_explicit_type(\n     acc: &mut Assists,\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n ) -> Option<()> {\n     let let_stmt = ctx.find_node_at_offset::<LetStmt>()?;\n "}, {"sha": "a93704b39474b8ec520fc6fbd84192debea396b6", "filename": "crates/ide-assists/src/handlers/sort_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -81,7 +81,7 @@ use crate::{utils::get_methods, AssistContext, AssistId, AssistKind, Assists};\n //   Cat { name: String, weight: f64 },\n // }\n // ```\n-pub(crate) fn sort_items(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn sort_items(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     if ctx.has_empty_selection() {\n         cov_mark::hit!(not_applicable_if_no_selection);\n         return None;"}, {"sha": "775ededecbcc8b9587c6f84e3414c51c88616674", "filename": "crates/ide-assists/src/handlers/split_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -13,7 +13,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n // use std::{collections::HashMap};\n // ```\n-pub(crate) fn split_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn split_import(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let colon_colon = ctx.find_token_syntax_at_offset(T![::])?;\n     let path = ast::Path::cast(colon_colon.parent()?)?.qualifier()?;\n "}, {"sha": "b7d57f02be566f07a9e9d39f36ba37c68f36263d", "filename": "crates/ide-assists/src/handlers/toggle_ignore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ftoggle_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ftoggle_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ftoggle_ignore.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -23,7 +23,7 @@ use crate::{utils::test_related_attribute, AssistContext, AssistId, AssistKind,\n //     assert_eq!(2 + 2, 5);\n // }\n // ```\n-pub(crate) fn toggle_ignore(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn toggle_ignore(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let attr: ast::Attr = ctx.find_node_at_offset()?;\n     let func = attr.syntax().parent().and_then(ast::Fn::cast)?;\n     let attr = test_related_attribute(&func)?;"}, {"sha": "3ce028e9306597b87fa117b36cdbfc428c8a2f4a", "filename": "crates/ide-assists/src/handlers/unmerge_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_use.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -21,7 +21,7 @@ use crate::{\n // use std::fmt::{Debug};\n // use std::fmt::Display;\n // ```\n-pub(crate) fn unmerge_use(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn unmerge_use(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let tree: ast::UseTree = ctx.find_node_at_offset::<ast::UseTree>()?.clone_for_update();\n \n     let tree_list = tree.syntax().parent().and_then(ast::UseTreeList::cast)?;"}, {"sha": "d5cd2d551349d7c225be5e262ce399e2354deafb", "filename": "crates/ide-assists/src/handlers/unnecessary_async.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -26,7 +26,7 @@ use crate::{AssistContext, Assists};\n // pub fn foo() {}\n // pub async fn bar() { foo() }\n // ```\n-pub(crate) fn unnecessary_async(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn unnecessary_async(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let function: ast::Fn = ctx.find_node_at_offset()?;\n \n     // Do nothing if the cursor is not on the prototype. This is so that the check does not pollute\n@@ -89,7 +89,7 @@ pub(crate) fn unnecessary_async(acc: &mut Assists, ctx: &AssistContext) -> Optio\n }\n \n fn find_all_references(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     def: &Definition,\n ) -> impl Iterator<Item = (FileId, FileReference)> {\n     def.usages(&ctx.sema).all().into_iter().flat_map(|(file_id, references)| {\n@@ -99,7 +99,7 @@ fn find_all_references(\n \n /// Finds the await expression for the given `NameRef`.\n /// If no await expression is found, returns None.\n-fn find_await_expression(ctx: &AssistContext, nameref: &NameRef) -> Option<ast::AwaitExpr> {\n+fn find_await_expression(ctx: &AssistContext<'_>, nameref: &NameRef) -> Option<ast::AwaitExpr> {\n     // From the nameref, walk up the tree to the await expression.\n     let await_expr = if let Some(path) = full_path_of_name_ref(&nameref) {\n         // Function calls."}, {"sha": "7969a491822d19165cdc4e5567f6a040a82ef226", "filename": "crates/ide-assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -25,7 +25,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     println!(\"foo\");\n // }\n // ```\n-pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let assist_id = AssistId(\"unwrap_block\", AssistKind::RefactorRewrite);\n     let assist_label = \"Unwrap block\";\n "}, {"sha": "9ef4ae047ef0e9d7a45ec0ae57a887aa1337406a", "filename": "crates/ide-assists/src/handlers/unwrap_result_return_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -22,7 +22,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n // fn foo() -> i32 { 42i32 }\n // ```\n-pub(crate) fn unwrap_result_return_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn unwrap_result_return_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let ret_type = ctx.find_node_at_offset::<ast::RetType>()?;\n     let parent = ret_type.syntax().parent()?;\n     let body = match_ast! {"}, {"sha": "83446387db1cf65332b559105fb75a7a8c7326e3", "filename": "crates/ide-assists/src/handlers/wrap_return_type_in_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -23,7 +23,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n // fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n // ```\n-pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let ret_type = ctx.find_node_at_offset::<ast::RetType>()?;\n     let parent = ret_type.syntax().parent()?;\n     let body = match_ast! {"}, {"sha": "fe87aa15fcf23ffa542f5ac3071ba67585f0668e", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -104,7 +104,7 @@ pub fn assists(\n mod handlers {\n     use crate::{AssistContext, Assists};\n \n-    pub(crate) type Handler = fn(&mut Assists, &AssistContext) -> Option<()>;\n+    pub(crate) type Handler = fn(&mut Assists, &AssistContext<'_>) -> Option<()>;\n \n     mod add_explicit_type;\n     mod add_label_to_loop;"}, {"sha": "249a56b4ae3c1d789b7c4b634fb26b003080fb0b", "filename": "crates/ide-assists/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -113,7 +113,7 @@ enum ExpectedResult<'a> {\n }\n \n #[track_caller]\n-fn check(handler: Handler, before: &str, expected: ExpectedResult, assist_label: Option<&str>) {\n+fn check(handler: Handler, before: &str, expected: ExpectedResult<'_>, assist_label: Option<&str>) {\n     let (mut db, file_with_caret_id, range_or_offset) = RootDatabase::with_range_or_offset(before);\n     db.set_enable_proc_attr_macros(true);\n     let text_without_caret = db.file_text(file_with_caret_id).to_string();"}, {"sha": "3e61d0741d3fe1267030541948bf1849103a0b17", "filename": "crates/ide-assists/src/utils.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -90,7 +90,7 @@ pub enum DefaultMethods {\n }\n \n pub fn filter_assoc_items(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     items: &[hir::AssocItem],\n     default_methods: DefaultMethods,\n ) -> Vec<ast::AssocItem> {\n@@ -127,11 +127,11 @@ pub fn filter_assoc_items(\n }\n \n pub fn add_trait_assoc_items_to_impl(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     items: Vec<ast::AssocItem>,\n     trait_: hir::Trait,\n     impl_: ast::Impl,\n-    target_scope: hir::SemanticsScope,\n+    target_scope: hir::SemanticsScope<'_>,\n ) -> (ast::Impl, ast::AssocItem) {\n     let source_scope = sema.scope_for_def(trait_);\n \n@@ -183,7 +183,7 @@ impl<'a> Cursor<'a> {\n     }\n }\n \n-pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor) -> String {\n+pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor<'_>) -> String {\n     assert!(cursor.node().ancestors().any(|it| it == *node));\n     let range = cursor.node().text_range() - node.text_range().start();\n     let range: ops::Range<usize> = range.into();\n@@ -334,7 +334,7 @@ fn calc_depth(pat: &ast::Pat, depth: usize) -> usize {\n // viable (e.g. we process proc macros, etc)\n // FIXME: this partially overlaps with `find_impl_block_*`\n pub(crate) fn find_struct_impl(\n-    ctx: &AssistContext,\n+    ctx: &AssistContext<'_>,\n     adt: &ast::Adt,\n     name: &str,\n ) -> Option<Option<ast::Impl>> {\n@@ -576,7 +576,7 @@ impl ReferenceConversion {\n pub(crate) fn convert_reference_type(\n     ty: hir::Type,\n     db: &RootDatabase,\n-    famous_defs: &FamousDefs,\n+    famous_defs: &FamousDefs<'_, '_>,\n ) -> Option<ReferenceConversion> {\n     handle_copy(&ty, db)\n         .or_else(|| handle_as_ref_str(&ty, db, famous_defs))\n@@ -594,7 +594,7 @@ fn handle_copy(ty: &hir::Type, db: &dyn HirDatabase) -> Option<ReferenceConversi\n fn handle_as_ref_str(\n     ty: &hir::Type,\n     db: &dyn HirDatabase,\n-    famous_defs: &FamousDefs,\n+    famous_defs: &FamousDefs<'_, '_>,\n ) -> Option<ReferenceConversionType> {\n     let str_type = hir::BuiltinType::str().ty(db);\n \n@@ -605,7 +605,7 @@ fn handle_as_ref_str(\n fn handle_as_ref_slice(\n     ty: &hir::Type,\n     db: &dyn HirDatabase,\n-    famous_defs: &FamousDefs,\n+    famous_defs: &FamousDefs<'_, '_>,\n ) -> Option<ReferenceConversionType> {\n     let type_argument = ty.type_arguments().next()?;\n     let slice_type = hir::Type::new_slice(type_argument);\n@@ -617,7 +617,7 @@ fn handle_as_ref_slice(\n fn handle_dereferenced(\n     ty: &hir::Type,\n     db: &dyn HirDatabase,\n-    famous_defs: &FamousDefs,\n+    famous_defs: &FamousDefs<'_, '_>,\n ) -> Option<ReferenceConversionType> {\n     let type_argument = ty.type_arguments().next()?;\n \n@@ -628,7 +628,7 @@ fn handle_dereferenced(\n fn handle_option_as_ref(\n     ty: &hir::Type,\n     db: &dyn HirDatabase,\n-    famous_defs: &FamousDefs,\n+    famous_defs: &FamousDefs<'_, '_>,\n ) -> Option<ReferenceConversionType> {\n     if ty.as_adt() == famous_defs.core_option_Option()?.ty(db).as_adt() {\n         Some(ReferenceConversionType::Option)\n@@ -640,7 +640,7 @@ fn handle_option_as_ref(\n fn handle_result_as_ref(\n     ty: &hir::Type,\n     db: &dyn HirDatabase,\n-    famous_defs: &FamousDefs,\n+    famous_defs: &FamousDefs<'_, '_>,\n ) -> Option<ReferenceConversionType> {\n     if ty.as_adt() == famous_defs.core_result_Result()?.ty(db).as_adt() {\n         Some(ReferenceConversionType::Result)"}, {"sha": "b1cabbb99d25d1b508f3d00711648459d38e3348", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -85,20 +85,20 @@ impl Completions {\n         items.into_iter().for_each(|item| self.add(item.into()))\n     }\n \n-    pub(crate) fn add_keyword(&mut self, ctx: &CompletionContext, keyword: &'static str) {\n+    pub(crate) fn add_keyword(&mut self, ctx: &CompletionContext<'_>, keyword: &'static str) {\n         let item = CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), keyword);\n         item.add_to(self);\n     }\n \n-    pub(crate) fn add_nameref_keywords_with_colon(&mut self, ctx: &CompletionContext) {\n+    pub(crate) fn add_nameref_keywords_with_colon(&mut self, ctx: &CompletionContext<'_>) {\n         [\"self::\", \"crate::\"].into_iter().for_each(|kw| self.add_keyword(ctx, kw));\n \n         if ctx.depth_from_crate_root > 0 {\n             self.add_keyword(ctx, \"super::\");\n         }\n     }\n \n-    pub(crate) fn add_nameref_keywords(&mut self, ctx: &CompletionContext) {\n+    pub(crate) fn add_nameref_keywords(&mut self, ctx: &CompletionContext<'_>) {\n         [\"self\", \"crate\"].into_iter().for_each(|kw| self.add_keyword(ctx, kw));\n \n         if ctx.depth_from_crate_root > 0 {\n@@ -108,7 +108,7 @@ impl Completions {\n \n     pub(crate) fn add_super_keyword(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         super_chain_len: Option<usize>,\n     ) {\n         if let Some(len) = super_chain_len {\n@@ -120,7 +120,7 @@ impl Completions {\n \n     pub(crate) fn add_keyword_snippet_expr(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         incomplete_let: bool,\n         kw: &str,\n         snippet: &str,\n@@ -144,7 +144,7 @@ impl Completions {\n         item.add_to(self);\n     }\n \n-    pub(crate) fn add_keyword_snippet(&mut self, ctx: &CompletionContext, kw: &str, snippet: &str) {\n+    pub(crate) fn add_keyword_snippet(&mut self, ctx: &CompletionContext<'_>, kw: &str, snippet: &str) {\n         let mut item = CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), kw);\n \n         match ctx.config.snippet_cap {\n@@ -156,7 +156,7 @@ impl Completions {\n \n     pub(crate) fn add_crate_roots(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         path_ctx: &PathCompletionCtx,\n     ) {\n         ctx.process_all_names(&mut |name, res| match res {\n@@ -169,7 +169,7 @@ impl Completions {\n \n     pub(crate) fn add_path_resolution(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         path_ctx: &PathCompletionCtx,\n         local_name: hir::Name,\n         resolution: hir::ScopeDef,\n@@ -192,7 +192,7 @@ impl Completions {\n \n     pub(crate) fn add_pattern_resolution(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         pattern_ctx: &PatternContext,\n         local_name: hir::Name,\n         resolution: hir::ScopeDef,\n@@ -215,7 +215,7 @@ impl Completions {\n \n     pub(crate) fn add_enum_variants(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         path_ctx: &PathCompletionCtx,\n         e: hir::Enum,\n     ) {\n@@ -226,7 +226,7 @@ impl Completions {\n \n     pub(crate) fn add_module(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         path_ctx: &PathCompletionCtx,\n         module: hir::Module,\n         local_name: hir::Name,\n@@ -241,7 +241,7 @@ impl Completions {\n \n     pub(crate) fn add_macro(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         path_ctx: &PathCompletionCtx,\n         mac: hir::Macro,\n         local_name: hir::Name,\n@@ -264,7 +264,7 @@ impl Completions {\n \n     pub(crate) fn add_function(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         path_ctx: &PathCompletionCtx,\n         func: hir::Function,\n         local_name: Option<hir::Name>,\n@@ -287,7 +287,7 @@ impl Completions {\n \n     pub(crate) fn add_method(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         dot_access: &DotAccess,\n         func: hir::Function,\n         receiver: Option<hir::Name>,\n@@ -312,7 +312,7 @@ impl Completions {\n \n     pub(crate) fn add_method_with_import(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         dot_access: &DotAccess,\n         func: hir::Function,\n         import: LocatedImport,\n@@ -336,7 +336,7 @@ impl Completions {\n         );\n     }\n \n-    pub(crate) fn add_const(&mut self, ctx: &CompletionContext, konst: hir::Const) {\n+    pub(crate) fn add_const(&mut self, ctx: &CompletionContext<'_>, konst: hir::Const) {\n         let is_private_editable = match ctx.is_visible(&konst) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -348,7 +348,7 @@ impl Completions {\n         ));\n     }\n \n-    pub(crate) fn add_type_alias(&mut self, ctx: &CompletionContext, type_alias: hir::TypeAlias) {\n+    pub(crate) fn add_type_alias(&mut self, ctx: &CompletionContext<'_>, type_alias: hir::TypeAlias) {\n         let is_private_editable = match ctx.is_visible(&type_alias) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -362,15 +362,15 @@ impl Completions {\n \n     pub(crate) fn add_type_alias_with_eq(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         type_alias: hir::TypeAlias,\n     ) {\n         self.add_opt(render_type_alias_with_eq(RenderContext::new(ctx), type_alias));\n     }\n \n     pub(crate) fn add_qualified_enum_variant(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         path_ctx: &PathCompletionCtx,\n         variant: hir::Variant,\n         path: hir::ModPath,\n@@ -384,7 +384,7 @@ impl Completions {\n \n     pub(crate) fn add_enum_variant(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         path_ctx: &PathCompletionCtx,\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n@@ -404,7 +404,7 @@ impl Completions {\n \n     pub(crate) fn add_field(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         dot_access: &DotAccess,\n         receiver: Option<hir::Name>,\n         field: hir::Field,\n@@ -427,7 +427,7 @@ impl Completions {\n \n     pub(crate) fn add_struct_literal(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         path_ctx: &PathCompletionCtx,\n         strukt: hir::Struct,\n         path: Option<hir::ModPath>,\n@@ -442,7 +442,7 @@ impl Completions {\n \n     pub(crate) fn add_union_literal(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         un: hir::Union,\n         path: Option<hir::ModPath>,\n         local_name: Option<hir::Name>,\n@@ -453,7 +453,7 @@ impl Completions {\n \n     pub(crate) fn add_tuple_field(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         receiver: Option<hir::Name>,\n         field: usize,\n         ty: &hir::Type,\n@@ -462,18 +462,18 @@ impl Completions {\n         self.add(item);\n     }\n \n-    pub(crate) fn add_lifetime(&mut self, ctx: &CompletionContext, name: hir::Name) {\n+    pub(crate) fn add_lifetime(&mut self, ctx: &CompletionContext<'_>, name: hir::Name) {\n         CompletionItem::new(SymbolKind::LifetimeParam, ctx.source_range(), name.to_smol_str())\n             .add_to(self)\n     }\n \n-    pub(crate) fn add_label(&mut self, ctx: &CompletionContext, name: hir::Name) {\n+    pub(crate) fn add_label(&mut self, ctx: &CompletionContext<'_>, name: hir::Name) {\n         CompletionItem::new(SymbolKind::Label, ctx.source_range(), name.to_smol_str()).add_to(self)\n     }\n \n     pub(crate) fn add_variant_pat(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         pattern_ctx: &PatternContext,\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n@@ -489,7 +489,7 @@ impl Completions {\n \n     pub(crate) fn add_qualified_variant_pat(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         pattern_ctx: &PatternContext,\n         variant: hir::Variant,\n         path: hir::ModPath,\n@@ -500,7 +500,7 @@ impl Completions {\n \n     pub(crate) fn add_struct_pat(\n         &mut self,\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         pattern_ctx: &PatternContext,\n         strukt: hir::Struct,\n         local_name: Option<hir::Name>,\n@@ -513,10 +513,10 @@ impl Completions {\n /// Skips variants that are visible with single segment paths.\n fn enum_variants_with_paths(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     enum_: hir::Enum,\n     impl_: &Option<ast::Impl>,\n-    cb: impl Fn(&mut Completions, &CompletionContext, hir::Variant, hir::ModPath),\n+    cb: impl Fn(&mut Completions, &CompletionContext<'_>, hir::Variant, hir::ModPath),\n ) {\n     let variants = enum_.variants(ctx.db);\n \n@@ -545,7 +545,7 @@ fn enum_variants_with_paths(\n \n pub(super) fn complete_name(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     NameContext { name, kind }: &NameContext,\n ) {\n     match kind {\n@@ -586,7 +586,7 @@ pub(super) fn complete_name(\n \n pub(super) fn complete_name_ref(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     NameRefContext { nameref, kind }: &NameRefContext,\n ) {\n     match kind {\n@@ -661,7 +661,7 @@ pub(super) fn complete_name_ref(\n     }\n }\n \n-fn complete_patterns(acc: &mut Completions, ctx: &CompletionContext, pattern_ctx: &PatternContext) {\n+fn complete_patterns(acc: &mut Completions, ctx: &CompletionContext<'_>, pattern_ctx: &PatternContext) {\n     flyimport::import_on_the_fly_pat(acc, ctx, pattern_ctx);\n     fn_param::complete_fn_param(acc, ctx, pattern_ctx);\n     pattern::complete_pattern(acc, ctx, pattern_ctx);"}, {"sha": "1d8a8c5f20db35828438e90abaa8bd1b6dbbed27", "filename": "crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -32,7 +32,7 @@ pub(crate) use self::derive::complete_derive_path;\n /// Complete inputs to known builtin attributes as well as derive attributes\n pub(crate) fn complete_known_attribute_input(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     &colon_prefix: &bool,\n     fake_attribute_under_caret: &ast::Attr,\n ) -> Option<()> {\n@@ -73,7 +73,7 @@ pub(crate) fn complete_known_attribute_input(\n \n pub(crate) fn complete_attribute_path(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n     &AttrCtx { kind, annotated_item_kind }: &AttrCtx,\n ) {"}, {"sha": "311060143b06a19c8d08ea437f6791827b41e09b", "filename": "crates/ide-completion/src/completions/attribute/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -8,7 +8,7 @@ use syntax::SyntaxKind;\n \n use crate::{completions::Completions, context::CompletionContext, CompletionItem};\n \n-pub(crate) fn complete_cfg(acc: &mut Completions, ctx: &CompletionContext) {\n+pub(crate) fn complete_cfg(acc: &mut Completions, ctx: &CompletionContext<'_>) {\n     let add_completion = |item: &str| {\n         let mut completion = CompletionItem::new(SymbolKind::BuiltinAttr, ctx.source_range(), item);\n         completion.insert_text(format!(r#\"\"{}\"\"#, item));"}, {"sha": "14538fef6072c8b8a481b182321ab6cb5a6d1b5c", "filename": "crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -12,7 +12,7 @@ use crate::{\n \n pub(crate) fn complete_derive_path(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n     existing_derives: &ExistingDerives,\n ) {"}, {"sha": "967f6ddd9a83b3b2196fa29e0979549954304bed", "filename": "crates/ide-completion/src/completions/attribute/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -6,7 +6,7 @@ use crate::{context::CompletionContext, item::CompletionItem, Completions};\n \n pub(super) fn complete_lint(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     is_qualified: bool,\n     existing_lints: &[ast::Path],\n     lints_completions: &[Lint],"}, {"sha": "cdd629824a9937c2dd742db24d708b138e4fe8ae", "filename": "crates/ide-completion/src/completions/attribute/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -5,7 +5,7 @@ use syntax::ast;\n \n use crate::{context::CompletionContext, item::CompletionItem, Completions};\n \n-pub(super) fn complete_repr(acc: &mut Completions, ctx: &CompletionContext, input: ast::TokenTree) {\n+pub(super) fn complete_repr(acc: &mut Completions, ctx: &CompletionContext<'_>, input: ast::TokenTree) {\n     if let Some(existing_reprs) = super::parse_comma_sep_expr(input) {\n         for &ReprCompletion { label, snippet, lookup, collides } in REPR_COMPLETIONS {\n             let repr_already_annotated = existing_reprs"}, {"sha": "4f80031541d6a527f7802337bdb8f43a3f852882", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -8,7 +8,7 @@ use crate::{\n };\n \n /// Complete dot accesses, i.e. fields or methods.\n-pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext, dot_access: &DotAccess) {\n+pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext<'_>, dot_access: &DotAccess) {\n     let receiver_ty = match dot_access {\n         DotAccess { receiver_ty: Some(receiver_ty), .. } => &receiver_ty.original,\n         _ => return,\n@@ -38,7 +38,7 @@ pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext, dot_a\n \n pub(crate) fn complete_undotted_self(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx: &PathCompletionCtx,\n     expr_ctx: &ExprCtx,\n ) {\n@@ -96,7 +96,7 @@ pub(crate) fn complete_undotted_self(\n \n fn complete_fields(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     receiver: &hir::Type,\n     mut named_field: impl FnMut(&mut Completions, hir::Field, hir::Type),\n     mut tuple_index: impl FnMut(&mut Completions, usize, hir::Type),\n@@ -113,7 +113,7 @@ fn complete_fields(\n }\n \n fn complete_methods(\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     receiver: &hir::Type,\n     mut f: impl FnMut(hir::Function),\n ) {"}, {"sha": "d4544dd1d127200ab80e690fa0713898f098656d", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -9,7 +9,7 @@ use crate::{\n \n pub(crate) fn complete_expr_path(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n     &ExprCtx {\n         in_block_expr,"}, {"sha": "4e89ef6960821e8a79cd854fc32bd0352458cc14", "filename": "crates/ide-completion/src/completions/extern_abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -42,7 +42,7 @@ const SUPPORTED_CALLING_CONVENTIONS: &[&str] = &[\n \n pub(crate) fn complete_extern_abi(\n     acc: &mut Completions,\n-    _ctx: &CompletionContext,\n+    _ctx: &CompletionContext<'_>,\n     expanded: &ast::String,\n ) -> Option<()> {\n     if !expanded.syntax().parent().map_or(false, |it| ast::Abi::can_cast(it.kind())) {"}, {"sha": "0e84d0a53e3b158b6edc7403604266cf1fd254a0", "filename": "crates/ide-completion/src/completions/field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -7,7 +7,7 @@ use crate::{\n \n pub(crate) fn complete_field_list_tuple_variant(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx: &PathCompletionCtx,\n ) {\n     if ctx.qualifier_ctx.vis_node.is_some() {\n@@ -30,7 +30,7 @@ pub(crate) fn complete_field_list_tuple_variant(\n     }\n }\n \n-pub(crate) fn complete_field_list_record_variant(acc: &mut Completions, ctx: &CompletionContext) {\n+pub(crate) fn complete_field_list_record_variant(acc: &mut Completions, ctx: &CompletionContext<'_>) {\n     if ctx.qualifier_ctx.vis_node.is_none() {\n         let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n         add_keyword(\"pub(crate)\", \"pub(crate)\");"}, {"sha": "f04cc15d7fabd844eff4d5e8900a89e5c03f5999", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -113,7 +113,7 @@ use super::Completions;\n // capability enabled.\n pub(crate) fn import_on_the_fly_path(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx: &PathCompletionCtx,\n ) -> Option<()> {\n     if !ctx.config.enable_imports_on_the_fly {\n@@ -152,7 +152,7 @@ pub(crate) fn import_on_the_fly_path(\n \n pub(crate) fn import_on_the_fly_pat(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     pattern_ctx: &PatternContext,\n ) -> Option<()> {\n     if !ctx.config.enable_imports_on_the_fly {\n@@ -177,7 +177,7 @@ pub(crate) fn import_on_the_fly_pat(\n \n pub(crate) fn import_on_the_fly_dot(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     dot_access: &DotAccess,\n ) -> Option<()> {\n     if !ctx.config.enable_imports_on_the_fly {\n@@ -205,7 +205,7 @@ pub(crate) fn import_on_the_fly_dot(\n \n fn import_on_the_fly(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { kind, .. }: &PathCompletionCtx,\n     import_assets: ImportAssets,\n     position: SyntaxNode,\n@@ -285,7 +285,7 @@ fn import_on_the_fly(\n \n fn import_on_the_fly_pat_(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     pattern_ctx: &PatternContext,\n     import_assets: ImportAssets,\n     position: SyntaxNode,\n@@ -329,7 +329,7 @@ fn import_on_the_fly_pat_(\n \n fn import_on_the_fly_method(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     dot_access: &DotAccess,\n     import_assets: ImportAssets,\n     position: SyntaxNode,\n@@ -362,7 +362,7 @@ fn import_on_the_fly_method(\n     Some(())\n }\n \n-fn import_name(ctx: &CompletionContext) -> String {\n+fn import_name(ctx: &CompletionContext<'_>) -> String {\n     let token_kind = ctx.token.kind();\n     if matches!(token_kind, T![.] | T![::]) {\n         String::new()\n@@ -372,7 +372,7 @@ fn import_name(ctx: &CompletionContext) -> String {\n }\n \n fn import_assets_for_path(\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     potential_import_name: &str,\n     qualifier: Option<ast::Path>,\n ) -> Option<ImportAssets> {"}, {"sha": "f0ecc595af33eaf22838510b6ff35fcc44ec9b48", "filename": "crates/ide-completion/src/completions/fn_param.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -21,7 +21,7 @@ use crate::{\n /// Also complete parameters for closure or local functions from the surrounding defined locals.\n pub(crate) fn complete_fn_param(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     pattern_ctx: &PatternContext,\n ) -> Option<()> {\n     let (ParamContext { param_list, kind, .. }, impl_) = match pattern_ctx {\n@@ -59,7 +59,7 @@ pub(crate) fn complete_fn_param(\n }\n \n fn fill_fn_params(\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     function: &ast::Fn,\n     param_list: &ast::ParamList,\n     impl_: &Option<ast::Impl>,\n@@ -113,7 +113,7 @@ fn fill_fn_params(\n }\n \n fn params_from_stmt_list_scope(\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     stmt_list: ast::StmtList,\n     mut cb: impl FnMut(hir::Name, String),\n ) {\n@@ -170,7 +170,7 @@ fn should_add_self_completions(\n     }\n }\n \n-fn comma_wrapper(ctx: &CompletionContext) -> Option<(impl Fn(&str) -> String, TextRange)> {\n+fn comma_wrapper(ctx: &CompletionContext<'_>) -> Option<(impl Fn(&str) -> String, TextRange)> {\n     let param = ctx.token.parent_ancestors().find(|node| node.kind() == SyntaxKind::PARAM)?;\n \n     let next_token_kind = {"}, {"sha": "038bdb4279e07f404246f8c3f51c9df5616af02d", "filename": "crates/ide-completion/src/completions/format_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -9,7 +9,7 @@ use crate::{context::CompletionContext, CompletionItem, CompletionItemKind, Comp\n /// Complete identifiers in format strings.\n pub(crate) fn format_string(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     original: &ast::String,\n     expanded: &ast::String,\n ) {"}, {"sha": "4e4c9fba6cc57250498a877f159967ca9051e538", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -9,7 +9,7 @@ pub(crate) mod trait_impl;\n \n pub(crate) fn complete_item_list_in_expr(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx: &PathCompletionCtx,\n     expr_ctx: &ExprCtx,\n ) {\n@@ -24,7 +24,7 @@ pub(crate) fn complete_item_list_in_expr(\n \n pub(crate) fn complete_item_list(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n     kind: &ItemListKind,\n ) {\n@@ -70,7 +70,7 @@ pub(crate) fn complete_item_list(\n     }\n }\n \n-fn add_keywords(acc: &mut Completions, ctx: &CompletionContext, kind: Option<&ItemListKind>) {\n+fn add_keywords(acc: &mut Completions, ctx: &CompletionContext<'_>, kind: Option<&ItemListKind>) {\n     let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n \n     let in_item_list = matches!(kind, Some(ItemListKind::SourceFile | ItemListKind::Module) | None);"}, {"sha": "e9256803cc4f7e46d92c6e51c2d6157a63e1af38", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -57,31 +57,31 @@ enum ImplCompletionKind {\n \n pub(crate) fn complete_trait_impl_const(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     name: &Option<ast::Name>,\n ) -> Option<()> {\n     complete_trait_impl_name(acc, ctx, name, ImplCompletionKind::Const)\n }\n \n pub(crate) fn complete_trait_impl_type_alias(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     name: &Option<ast::Name>,\n ) -> Option<()> {\n     complete_trait_impl_name(acc, ctx, name, ImplCompletionKind::TypeAlias)\n }\n \n pub(crate) fn complete_trait_impl_fn(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     name: &Option<ast::Name>,\n ) -> Option<()> {\n     complete_trait_impl_name(acc, ctx, name, ImplCompletionKind::Fn)\n }\n \n fn complete_trait_impl_name(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     name: &Option<ast::Name>,\n     kind: ImplCompletionKind,\n ) -> Option<()> {\n@@ -104,7 +104,7 @@ fn complete_trait_impl_name(\n \n pub(crate) fn complete_trait_impl_item_by_name(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx: &PathCompletionCtx,\n     name_ref: &Option<ast::NameRef>,\n     impl_: &Option<ast::Impl>,\n@@ -128,7 +128,7 @@ pub(crate) fn complete_trait_impl_item_by_name(\n \n fn complete_trait_impl(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     kind: ImplCompletionKind,\n     replacement_range: TextRange,\n     impl_def: &ast::Impl,\n@@ -154,7 +154,7 @@ fn complete_trait_impl(\n \n fn add_function_impl(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     replacement_range: TextRange,\n     func: hir::Function,\n     impl_def: hir::Impl,\n@@ -204,7 +204,7 @@ fn add_function_impl(\n \n /// Transform a relevant associated item to inline generics from the impl, remove attrs and docs, etc.\n fn get_transformed_assoc_item(\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     assoc_item: ast::AssocItem,\n     impl_def: hir::Impl,\n ) -> Option<ast::AssocItem> {\n@@ -228,7 +228,7 @@ fn get_transformed_assoc_item(\n \n fn add_type_alias_impl(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     replacement_range: TextRange,\n     type_alias: hir::TypeAlias,\n ) {\n@@ -252,7 +252,7 @@ fn add_type_alias_impl(\n \n fn add_const_impl(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     replacement_range: TextRange,\n     const_: hir::Const,\n     impl_def: hir::Impl,\n@@ -340,7 +340,7 @@ fn function_declaration(node: &ast::Fn, needs_whitespace: bool) -> String {\n     syntax.trim_end().to_owned()\n }\n \n-fn replacement_range(ctx: &CompletionContext, item: &SyntaxNode) -> TextRange {\n+fn replacement_range(ctx: &CompletionContext<'_>, item: &SyntaxNode) -> TextRange {\n     let first_child = item\n         .children_with_tokens()\n         .find(|child| {"}, {"sha": "0089958ff1d03b96578886e9b4f19bddc8aa968d", "filename": "crates/ide-completion/src/completions/keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -6,7 +6,7 @@ use crate::{CompletionContext, Completions};\n \n pub(crate) fn complete_for_and_where(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     keyword_item: &ast::Item,\n ) {\n     let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);"}, {"sha": "3b79def639df420aa7295ed1970c09e98541015d", "filename": "crates/ide-completion/src/completions/lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -18,7 +18,7 @@ use crate::{\n /// Completes lifetimes.\n pub(crate) fn complete_lifetime(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     lifetime_ctx: &LifetimeContext,\n ) {\n     let (lp, lifetime) = match lifetime_ctx {\n@@ -54,7 +54,7 @@ pub(crate) fn complete_lifetime(\n /// Completes labels.\n pub(crate) fn complete_label(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     lifetime_ctx: &LifetimeContext,\n ) {\n     if !matches!(lifetime_ctx, LifetimeContext { kind: LifetimeKind::LabelRef, .. }) {"}, {"sha": "9c975b92953377b2e476edb8065a77a35652f57f", "filename": "crates/ide-completion/src/completions/mod_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -14,7 +14,7 @@ use crate::{context::CompletionContext, CompletionItem, Completions};\n /// Complete mod declaration, i.e. `mod $0;`\n pub(crate) fn complete_mod(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     mod_under_caret: &ast::Module,\n ) -> Option<()> {\n     if mod_under_caret.item_list().is_some() {"}, {"sha": "17dfe432b3529e453e81a8fbaebf174c99d63046", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -11,7 +11,7 @@ use crate::{\n /// Completes constants and paths in unqualified patterns.\n pub(crate) fn complete_pattern(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     pattern_ctx: &PatternContext,\n ) {\n     match pattern_ctx.parent_pat.as_ref() {\n@@ -107,7 +107,7 @@ pub(crate) fn complete_pattern(\n \n pub(crate) fn complete_pattern_path(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n ) {\n     match qualified {"}, {"sha": "9a891cea2d458491979475f1753b1f3f67b69645", "filename": "crates/ide-completion/src/completions/postfix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -20,7 +20,7 @@ use crate::{\n \n pub(crate) fn complete_postfix(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     dot_access: &DotAccess,\n ) {\n     if !ctx.config.enable_postfix_completions {\n@@ -221,7 +221,7 @@ fn include_references(initial_element: &ast::Expr) -> ast::Expr {\n }\n \n fn build_postfix_snippet_builder<'ctx>(\n-    ctx: &'ctx CompletionContext,\n+    ctx: &'ctx CompletionContext<'_>,\n     cap: SnippetCap,\n     receiver: &'ctx ast::Expr,\n ) -> Option<impl Fn(&str, &str, &str) -> Builder + 'ctx> {\n@@ -236,7 +236,7 @@ fn build_postfix_snippet_builder<'ctx>(\n     // Wrapping impl Fn in an option ruins lifetime inference for the parameters in a way that\n     // can't be annotated for the closure, hence fix it by constructing it without the Option first\n     fn build<'ctx>(\n-        ctx: &'ctx CompletionContext,\n+        ctx: &'ctx CompletionContext<'_>,\n         cap: SnippetCap,\n         delete_range: TextRange,\n     ) -> impl Fn(&str, &str, &str) -> Builder + 'ctx {\n@@ -262,7 +262,7 @@ fn build_postfix_snippet_builder<'ctx>(\n \n fn add_custom_postfix_completions(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     postfix_snippet: impl Fn(&str, &str, &str) -> Builder,\n     receiver_text: &str,\n ) -> Option<()> {"}, {"sha": "6b94347e0ad05cb7e3b7d451184cfcdc1d04dfdc", "filename": "crates/ide-completion/src/completions/postfix/format_like.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -38,7 +38,7 @@ static KINDS: &[(&str, &str)] = &[\n \n pub(crate) fn add_format_like_completions(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     dot_receiver: &ast::Expr,\n     cap: SnippetCap,\n     receiver_text: &ast::String,"}, {"sha": "1c9042390d3b2fc0703ce730cbbe659ff7703e7f", "filename": "crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -10,7 +10,7 @@ use crate::{\n \n pub(crate) fn complete_record_pattern_fields(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     pattern_ctx: &PatternContext,\n ) {\n     if let PatternContext { record_pat: Some(record_pat), .. } = pattern_ctx {\n@@ -20,7 +20,7 @@ pub(crate) fn complete_record_pattern_fields(\n \n pub(crate) fn complete_record_expr_fields(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     record_expr: &ast::RecordExpr,\n     &dot_prefix: &bool,\n ) {\n@@ -59,7 +59,7 @@ pub(crate) fn complete_record_expr_fields(\n // FIXME: This should probably be part of complete_path_expr\n pub(crate) fn complete_record_expr_func_update(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx: &PathCompletionCtx,\n     expr_ctx: &ExprCtx,\n ) {\n@@ -81,7 +81,7 @@ pub(crate) fn complete_record_expr_func_update(\n \n fn add_default_update(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     ty: Option<hir::TypeInfo>,\n     missing_fields: &[(hir::Field, hir::Type)],\n ) {\n@@ -105,7 +105,7 @@ fn add_default_update(\n \n fn complete_fields(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     missing_fields: Vec<(hir::Field, hir::Type)>,\n ) {\n     for (field, ty) in missing_fields {"}, {"sha": "66adb4286373a85deb59413905e85aa48df811bb", "filename": "crates/ide-completion/src/completions/snippet.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -11,7 +11,7 @@ use crate::{\n \n pub(crate) fn complete_expr_snippet(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx: &PathCompletionCtx,\n     &ExprCtx { in_block_expr, .. }: &ExprCtx,\n ) {\n@@ -51,7 +51,7 @@ macro_rules! $1 {\n \n pub(crate) fn complete_item_snippet(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx: &PathCompletionCtx,\n     kind: &ItemListKind,\n ) {\n@@ -118,15 +118,15 @@ macro_rules! $1 {\n     }\n }\n \n-fn snippet(ctx: &CompletionContext, cap: SnippetCap, label: &str, snippet: &str) -> Builder {\n+fn snippet(ctx: &CompletionContext<'_>, cap: SnippetCap, label: &str, snippet: &str) -> Builder {\n     let mut item = CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), label);\n     item.insert_snippet(cap, snippet);\n     item\n }\n \n fn add_custom_completions(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     cap: SnippetCap,\n     scope: SnippetScope,\n ) -> Option<()> {"}, {"sha": "87a998dfcce6bfab229e85d6302330a2e7b891bc", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -11,7 +11,7 @@ use crate::{\n \n pub(crate) fn complete_type_path(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n     location: &TypeLocation,\n ) {\n@@ -208,7 +208,7 @@ pub(crate) fn complete_type_path(\n \n pub(crate) fn complete_ascribed_type(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx: &PathCompletionCtx,\n     ascription: &TypeAscriptionTarget,\n ) -> Option<()> {"}, {"sha": "bb2ecc9fdde76b384464d22b9c5df5b1056b0a10", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -12,7 +12,7 @@ use crate::{\n \n pub(crate) fn complete_use_path(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { qualified, use_tree_parent, .. }: &PathCompletionCtx,\n     name_ref: &Option<ast::NameRef>,\n ) {"}, {"sha": "ca8303906a800a82f425cdd716a9f442c8f8ef16", "filename": "crates/ide-completion/src/completions/vis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -7,7 +7,7 @@ use crate::{\n \n pub(crate) fn complete_vis_path(\n     acc: &mut Completions,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n     &has_in_token: &bool,\n ) {"}, {"sha": "6a2079b12666e47266f5ef0f9c9ac2bc53235d7b", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -388,7 +388,7 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n-    pub(crate) fn famous_defs(&self) -> FamousDefs {\n+    pub(crate) fn famous_defs(&self) -> FamousDefs<'_, '_> {\n         FamousDefs(&self.sema, self.krate)\n     }\n "}, {"sha": "0c8b569b66a32e9d412e4d329a158c9dbbbf5491", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -410,7 +410,7 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn classify_lifetime(\n-        _sema: &Semantics<RootDatabase>,\n+        _sema: &Semantics<'_, RootDatabase>,\n         original_file: &SyntaxNode,\n         lifetime: ast::Lifetime,\n     ) -> Option<LifetimeContext> {\n@@ -437,7 +437,7 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn classify_name(\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         original_file: &SyntaxNode,\n         name: ast::Name,\n     ) -> Option<NameContext> {\n@@ -477,7 +477,7 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn classify_name_ref(\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         original_file: &SyntaxNode,\n         name_ref: ast::NameRef,\n         parent: SyntaxNode,\n@@ -987,7 +987,7 @@ impl<'a> CompletionContext<'a> {\n }\n \n fn pattern_context_for(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     original_file: &SyntaxNode,\n     pat: ast::Pat,\n ) -> PatternContext {\n@@ -1047,7 +1047,7 @@ fn pattern_context_for(\n }\n \n fn fetch_immediate_impl(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     original_file: &SyntaxNode,\n     node: &SyntaxNode,\n ) -> Option<ast::Impl> {\n@@ -1085,15 +1085,15 @@ fn find_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n /// for the offset introduced by the fake ident.\n /// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n fn find_node_in_file_compensated<N: AstNode>(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     in_file: &SyntaxNode,\n     node: &N,\n ) -> Option<N> {\n     ancestors_in_file_compensated(sema, in_file, node.syntax())?.find_map(N::cast)\n }\n \n fn ancestors_in_file_compensated<'sema>(\n-    sema: &'sema Semantics<RootDatabase>,\n+    sema: &'sema Semantics<'_, RootDatabase>,\n     in_file: &SyntaxNode,\n     node: &SyntaxNode,\n ) -> Option<impl Iterator<Item = SyntaxNode> + 'sema> {\n@@ -1117,7 +1117,7 @@ fn ancestors_in_file_compensated<'sema>(\n /// for the offset introduced by the fake ident..\n /// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n fn find_opt_node_in_file_compensated<N: AstNode>(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     syntax: &SyntaxNode,\n     node: Option<N>,\n ) -> Option<N> {"}, {"sha": "27482ea489be75ffb87d250f08b50852f6d16887", "filename": "crates/ide-completion/src/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fitem.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -76,7 +76,7 @@ pub struct CompletionItem {\n \n // We use custom debug for CompletionItem to make snapshot tests more readable.\n impl fmt::Debug for CompletionItem {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut s = f.debug_struct(\"CompletionItem\");\n         s.field(\"label\", &self.label()).field(\"source_range\", &self.source_range());\n         if self.text_edit().len() == 1 {\n@@ -433,7 +433,7 @@ pub(crate) struct Builder {\n \n impl Builder {\n     pub(crate) fn from_resolution(\n-        ctx: &CompletionContext,\n+        ctx: &CompletionContext<'_>,\n         path_ctx: &PathCompletionCtx,\n         local_name: hir::Name,\n         resolution: hir::ScopeDef,"}, {"sha": "f3de4a94ca3af4c6342eadd7dda4be14bc2c3ee4", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -158,7 +158,7 @@ pub(crate) fn render_tuple_field(\n     item.build()\n }\n \n-pub(crate) fn render_type_inference(ty_string: String, ctx: &CompletionContext) -> CompletionItem {\n+pub(crate) fn render_type_inference(ty_string: String, ctx: &CompletionContext<'_>) -> CompletionItem {\n     let mut builder =\n         CompletionItem::new(CompletionItemKind::InferredType, ctx.source_range(), ty_string);\n     builder.set_relevance(CompletionRelevance { is_definite: true, ..Default::default() });\n@@ -206,7 +206,7 @@ pub(crate) fn render_resolution_with_import_pat(\n \n fn scope_def_to_name(\n     resolution: ScopeDef,\n-    ctx: &RenderContext,\n+    ctx: &RenderContext<'_>,\n     import_edit: &LocatedImport,\n ) -> Option<hir::Name> {\n     Some(match resolution {\n@@ -400,7 +400,7 @@ fn scope_def_is_deprecated(ctx: &RenderContext<'_>, resolution: ScopeDef) -> boo\n }\n \n fn compute_type_match(\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     completion_ty: &hir::Type,\n ) -> Option<CompletionRelevanceTypeMatch> {\n     let expected_type = ctx.expected_type.as_ref()?;\n@@ -420,12 +420,12 @@ fn compute_type_match(\n     }\n }\n \n-fn compute_exact_name_match(ctx: &CompletionContext, completion_name: &str) -> bool {\n+fn compute_exact_name_match(ctx: &CompletionContext<'_>, completion_name: &str) -> bool {\n     ctx.expected_name.as_ref().map_or(false, |name| name.text() == completion_name)\n }\n \n fn compute_ref_match(\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     completion_ty: &hir::Type,\n ) -> Option<hir::Mutability> {\n     let expected_type = ctx.expected_type.as_ref()?;"}, {"sha": "241de0a1834a0c1759fd4cd280df61ce94475fe3", "filename": "crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -44,7 +44,7 @@ fn render(\n     ctx @ RenderContext { completion, .. }: RenderContext<'_>,\n     local_name: Option<hir::Name>,\n     func: hir::Function,\n-    func_kind: FuncKind,\n+    func_kind: FuncKind<'_>,\n ) -> Builder {\n     let db = completion.db;\n \n@@ -150,7 +150,7 @@ fn render(\n \n pub(super) fn add_call_parens<'b>(\n     builder: &'b mut Builder,\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     cap: SnippetCap,\n     name: SmolStr,\n     escaped_name: SmolStr,\n@@ -211,7 +211,7 @@ pub(super) fn add_call_parens<'b>(\n     builder.label(SmolStr::from_iter([&name, label_suffix])).insert_snippet(cap, snippet)\n }\n \n-fn ref_of_param(ctx: &CompletionContext, arg: &str, ty: &hir::Type) -> &'static str {\n+fn ref_of_param(ctx: &CompletionContext<'_>, arg: &str, ty: &hir::Type) -> &'static str {\n     if let Some(derefed_ty) = ty.remove_ref() {\n         for (name, local) in ctx.locals.iter() {\n             if name.as_text().as_deref() == Some(arg) {\n@@ -278,7 +278,7 @@ fn params_display(db: &dyn HirDatabase, func: hir::Function) -> String {\n fn params(\n     ctx: &CompletionContext<'_>,\n     func: hir::Function,\n-    func_kind: &FuncKind,\n+    func_kind: &FuncKind<'_>,\n     has_dot_receiver: bool,\n ) -> Option<(Option<hir::SelfParam>, Vec<hir::Param>)> {\n     if ctx.config.callable.is_none() {"}, {"sha": "91a253f8fc8c13266ee655a309f4fc7bc0de83d1", "filename": "crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -138,7 +138,7 @@ enum Variant {\n }\n \n impl Variant {\n-    fn fields(self, ctx: &CompletionContext) -> Option<Vec<hir::Field>> {\n+    fn fields(self, ctx: &CompletionContext<'_>) -> Option<Vec<hir::Field>> {\n         let fields = match self {\n             Variant::Struct(it) => it.fields(ctx.db),\n             Variant::EnumVariant(it) => it.fields(ctx.db),"}, {"sha": "9c9540a9bd96321c894b4d6b449102eb0e1a8e3c", "filename": "crates/ide-completion/src/render/union_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -13,7 +13,7 @@ use crate::{\n };\n \n pub(crate) fn render_union_literal(\n-    ctx: RenderContext,\n+    ctx: RenderContext<'_>,\n     un: hir::Union,\n     path: Option<hir::ModPath>,\n     local_name: Option<Name>,"}, {"sha": "003a0c11ed2f8ab188f9c5f4dbacbcc430514f90", "filename": "crates/ide-completion/src/render/variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -68,7 +68,7 @@ pub(crate) fn render_tuple_lit(\n /// fields, plus a boolean for whether the list is comprehensive (contains no\n /// private fields and its item is not marked `#[non_exhaustive]`).\n pub(crate) fn visible_fields(\n-    ctx: &CompletionContext,\n+    ctx: &CompletionContext<'_>,\n     fields: &[hir::Field],\n     item: impl HasAttrs + HasCrate + Copy,\n ) -> Option<(Vec<hir::Field>, bool)> {"}, {"sha": "dc1039fa623e85ad924f8c01e3d0d277a472d9d9", "filename": "crates/ide-completion/src/snippet.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-completion%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fsnippet.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -154,7 +154,7 @@ impl Snippet {\n     }\n \n     /// Returns [`None`] if the required items do not resolve.\n-    pub(crate) fn imports(&self, ctx: &CompletionContext) -> Option<Vec<LocatedImport>> {\n+    pub(crate) fn imports(&self, ctx: &CompletionContext<'_>) -> Option<Vec<LocatedImport>> {\n         import_edits(ctx, &self.requires)\n     }\n \n@@ -167,7 +167,7 @@ impl Snippet {\n     }\n }\n \n-fn import_edits(ctx: &CompletionContext, requires: &[GreenNode]) -> Option<Vec<LocatedImport>> {\n+fn import_edits(ctx: &CompletionContext<'_>, requires: &[GreenNode]) -> Option<Vec<LocatedImport>> {\n     let resolve = |import: &GreenNode| {\n         let path = ast::Path::cast(SyntaxNode::new_root(import.clone()))?;\n         let item = match ctx.scope.speculative_resolve(&path)? {"}, {"sha": "7303ef8b7bb588d4b525e889d68519bdc6ec3565", "filename": "crates/ide-db/src/active_parameter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Factive_parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Factive_parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Factive_parameter.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -17,7 +17,7 @@ pub struct ActiveParameter {\n \n impl ActiveParameter {\n     /// Returns information about the call argument this token is part of.\n-    pub fn at_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Self> {\n+    pub fn at_token(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken) -> Option<Self> {\n         let (signature, active_parameter) = callable_for_token(sema, token)?;\n \n         let idx = active_parameter?;\n@@ -40,7 +40,7 @@ impl ActiveParameter {\n \n /// Returns a [`hir::Callable`] this token is a part of and its argument index of said callable.\n pub fn callable_for_token(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     token: SyntaxToken,\n ) -> Option<(hir::Callable, Option<usize>)> {\n     // Find the calling expression and its NameRef\n@@ -54,7 +54,7 @@ pub fn callable_for_token(\n }\n \n pub fn callable_for_node(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     calling_node: &ast::CallableExpr,\n     token: &SyntaxToken,\n ) -> Option<(hir::Callable, Option<usize>)> {"}, {"sha": "26f63a2bd1fcbaf98ebf0814ebaaa111170cc725", "filename": "crates/ide-db/src/defs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fdefs.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -130,7 +130,7 @@ pub enum IdentClass {\n }\n \n impl IdentClass {\n-    pub fn classify_node(sema: &Semantics<RootDatabase>, node: &SyntaxNode) -> Option<IdentClass> {\n+    pub fn classify_node(sema: &Semantics<'_, RootDatabase>, node: &SyntaxNode) -> Option<IdentClass> {\n         match_ast! {\n             match node {\n                 ast::Name(name) => NameClass::classify(sema, &name).map(IdentClass::NameClass),\n@@ -146,15 +146,15 @@ impl IdentClass {\n     }\n \n     pub fn classify_token(\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         token: &SyntaxToken,\n     ) -> Option<IdentClass> {\n         let parent = token.parent()?;\n         Self::classify_node(sema, &parent)\n     }\n \n     pub fn classify_lifetime(\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         lifetime: &ast::Lifetime,\n     ) -> Option<IdentClass> {\n         NameRefClass::classify_lifetime(sema, lifetime)\n@@ -218,7 +218,7 @@ impl NameClass {\n         Some(res)\n     }\n \n-    pub fn classify(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<NameClass> {\n+    pub fn classify(sema: &Semantics<'_, RootDatabase>, name: &ast::Name) -> Option<NameClass> {\n         let _p = profile::span(\"classify_name\");\n \n         let parent = name.syntax().parent()?;\n@@ -238,7 +238,7 @@ impl NameClass {\n         };\n         return Some(NameClass::Definition(definition));\n \n-        fn classify_item(sema: &Semantics<RootDatabase>, item: ast::Item) -> Option<Definition> {\n+        fn classify_item(sema: &Semantics<'_, RootDatabase>, item: ast::Item) -> Option<Definition> {\n             let definition = match item {\n                 ast::Item::MacroRules(it) => {\n                     Definition::Macro(sema.to_def(&ast::Macro::MacroRules(it))?)\n@@ -266,7 +266,7 @@ impl NameClass {\n         }\n \n         fn classify_ident_pat(\n-            sema: &Semantics<RootDatabase>,\n+            sema: &Semantics<'_, RootDatabase>,\n             ident_pat: ast::IdentPat,\n         ) -> Option<NameClass> {\n             if let Some(def) = sema.resolve_bind_pat_to_const(&ident_pat) {\n@@ -289,7 +289,7 @@ impl NameClass {\n         }\n \n         fn classify_rename(\n-            sema: &Semantics<RootDatabase>,\n+            sema: &Semantics<'_, RootDatabase>,\n             rename: ast::Rename,\n         ) -> Option<Definition> {\n             if let Some(use_tree) = rename.syntax().parent().and_then(ast::UseTree::cast) {\n@@ -305,7 +305,7 @@ impl NameClass {\n     }\n \n     pub fn classify_lifetime(\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         lifetime: &ast::Lifetime,\n     ) -> Option<NameClass> {\n         let _p = profile::span(\"classify_lifetime\").detail(|| lifetime.to_string());\n@@ -338,7 +338,7 @@ impl NameRefClass {\n     // Note: we don't have unit-tests for this rather important function.\n     // It is primarily exercised via goto definition tests in `ide`.\n     pub fn classify(\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         name_ref: &ast::NameRef,\n     ) -> Option<NameRefClass> {\n         let _p = profile::span(\"classify_name_ref\").detail(|| name_ref.to_string());\n@@ -418,7 +418,7 @@ impl NameRefClass {\n     }\n \n     pub fn classify_lifetime(\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         lifetime: &ast::Lifetime,\n     ) -> Option<NameRefClass> {\n         let _p = profile::span(\"classify_lifetime_ref\").detail(|| lifetime.to_string());"}, {"sha": "6e56efe344d72650048e96a702a4950141d6651f", "filename": "crates/ide-db/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fhelpers.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -56,7 +56,7 @@ pub fn mod_path_to_ast(path: &hir::ModPath) -> ast::Path {\n \n /// Iterates all `ModuleDef`s and `Impl` blocks of the given file.\n pub fn visit_file_defs(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     file_id: FileId,\n     cb: &mut dyn FnMut(Definition),\n ) {"}, {"sha": "8378e323ed6e5a36d85788495ddeee25ecc4d4be", "filename": "crates/ide-db/src/imports/import_assets.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -99,7 +99,7 @@ pub struct ImportAssets {\n impl ImportAssets {\n     pub fn for_method_call(\n         method_call: &ast::MethodCallExpr,\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n     ) -> Option<Self> {\n         let candidate_node = method_call.syntax().clone();\n         Some(Self {\n@@ -111,7 +111,7 @@ impl ImportAssets {\n \n     pub fn for_exact_path(\n         fully_qualified_path: &ast::Path,\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n     ) -> Option<Self> {\n         let candidate_node = fully_qualified_path.syntax().clone();\n         if let Some(use_tree) = candidate_node.ancestors().find_map(ast::UseTree::cast) {\n@@ -129,7 +129,7 @@ impl ImportAssets {\n         })\n     }\n \n-    pub fn for_ident_pat(sema: &Semantics<RootDatabase>, pat: &ast::IdentPat) -> Option<Self> {\n+    pub fn for_ident_pat(sema: &Semantics<'_, RootDatabase>, pat: &ast::IdentPat) -> Option<Self> {\n         if !pat.is_simple_ident() {\n             return None;\n         }\n@@ -146,7 +146,7 @@ impl ImportAssets {\n         module_with_candidate: Module,\n         qualifier: Option<ast::Path>,\n         fuzzy_name: String,\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         candidate_node: SyntaxNode,\n     ) -> Option<Self> {\n         Some(Self {\n@@ -210,15 +210,15 @@ impl ImportAssets {\n \n     pub fn search_for_imports(\n         &self,\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         prefix_kind: PrefixKind,\n     ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_imports\");\n         self.search_for(sema, Some(prefix_kind))\n     }\n \n     /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n-    pub fn search_for_relative_paths(&self, sema: &Semantics<RootDatabase>) -> Vec<LocatedImport> {\n+    pub fn search_for_relative_paths(&self, sema: &Semantics<'_, RootDatabase>) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_relative_paths\");\n         self.search_for(sema, None)\n     }\n@@ -237,7 +237,7 @@ impl ImportAssets {\n \n     fn search_for(\n         &self,\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         prefixed: Option<PrefixKind>,\n     ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for\");\n@@ -276,7 +276,7 @@ impl ImportAssets {\n         .collect()\n     }\n \n-    fn scope_definitions(&self, sema: &Semantics<RootDatabase>) -> FxHashSet<ScopeDef> {\n+    fn scope_definitions(&self, sema: &Semantics<'_, RootDatabase>) -> FxHashSet<ScopeDef> {\n         let _p = profile::span(\"import_assets::scope_definitions\");\n         let mut scope_definitions = FxHashSet::default();\n         if let Some(scope) = sema.scope(&self.candidate_node) {\n@@ -289,7 +289,7 @@ impl ImportAssets {\n }\n \n fn path_applicable_imports(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     current_crate: Crate,\n     path_candidate: &PathImportCandidate,\n     mod_path: impl Fn(ItemInNs) -> Option<ModPath> + Copy,\n@@ -456,9 +456,9 @@ fn module_with_segment_name(\n }\n \n fn trait_applicable_items(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     current_crate: Crate,\n-    scope: &SemanticsScope,\n+    scope: &SemanticsScope<'_>,\n     trait_candidate: &TraitImportCandidate,\n     trait_assoc_item: bool,\n     mod_path: impl Fn(ItemInNs) -> Option<ModPath>,\n@@ -571,7 +571,7 @@ fn get_mod_path(\n \n impl ImportCandidate {\n     fn for_method_call(\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         method_call: &ast::MethodCallExpr,\n     ) -> Option<Self> {\n         match sema.resolve_method_call(method_call) {\n@@ -585,7 +585,7 @@ impl ImportCandidate {\n         }\n     }\n \n-    fn for_regular_path(sema: &Semantics<RootDatabase>, path: &ast::Path) -> Option<Self> {\n+    fn for_regular_path(sema: &Semantics<'_, RootDatabase>, path: &ast::Path) -> Option<Self> {\n         if sema.resolve_path(path).is_some() {\n             return None;\n         }\n@@ -596,7 +596,7 @@ impl ImportCandidate {\n         )\n     }\n \n-    fn for_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<Self> {\n+    fn for_name(sema: &Semantics<'_, RootDatabase>, name: &ast::Name) -> Option<Self> {\n         if sema\n             .scope(name.syntax())?\n             .speculative_resolve(&ast::make::ext::ident_path(&name.text()))\n@@ -613,14 +613,14 @@ impl ImportCandidate {\n     fn for_fuzzy_path(\n         qualifier: Option<ast::Path>,\n         fuzzy_name: String,\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n     ) -> Option<Self> {\n         path_import_candidate(sema, qualifier, NameToImport::Fuzzy(fuzzy_name))\n     }\n }\n \n fn path_import_candidate(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     qualifier: Option<ast::Path>,\n     name: NameToImport,\n ) -> Option<ImportCandidate> {"}, {"sha": "26648b4d7638c8f0ca0560d80778ea3e6a5141e1", "filename": "crates/ide-db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Flib.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -115,7 +115,7 @@ impl FileLoader for RootDatabase {\n     fn file_text(&self, file_id: FileId) -> Arc<String> {\n         FileLoaderDelegate(self).file_text(file_id)\n     }\n-    fn resolve_path(&self, path: AnchoredPath) -> Option<FileId> {\n+    fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         FileLoaderDelegate(self).resolve_path(path)\n     }\n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {"}, {"sha": "d78b8758d65126afba8d59dc717e15c2b843e977", "filename": "crates/ide-db/src/path_transform.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fpath_transform.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -255,7 +255,7 @@ fn get_type_args_from_arg_list(generic_arg_list: ast::GenericArgList) -> Option<\n }\n \n fn find_trait_for_assoc_item(\n-    scope: &SemanticsScope,\n+    scope: &SemanticsScope<'_>,\n     type_param: hir::TypeParam,\n     assoc_item: ast::NameRef,\n ) -> Option<hir::Trait> {"}, {"sha": "435a99aa0f0f618ea2e4487d78f11c763e354284", "filename": "crates/ide-db/src/rename.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Frename.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -66,7 +66,7 @@ macro_rules! _bail {\n pub use _bail as bail;\n \n impl Definition {\n-    pub fn rename(&self, sema: &Semantics<RootDatabase>, new_name: &str) -> Result<SourceChange> {\n+    pub fn rename(&self, sema: &Semantics<'_, RootDatabase>, new_name: &str) -> Result<SourceChange> {\n         match *self {\n             Definition::Module(module) => rename_mod(sema, module, new_name),\n             Definition::BuiltinType(_) => {\n@@ -80,7 +80,7 @@ impl Definition {\n     /// Textual range of the identifier which will change when renaming this\n     /// `Definition`. Note that some definitions, like buitin types, can't be\n     /// renamed.\n-    pub fn range_for_rename(self, sema: &Semantics<RootDatabase>) -> Option<FileRange> {\n+    pub fn range_for_rename(self, sema: &Semantics<'_, RootDatabase>) -> Option<FileRange> {\n         let res = match self {\n             Definition::Macro(mac) => {\n                 let src = mac.source(sema.db)?;\n@@ -155,7 +155,7 @@ impl Definition {\n         };\n         return res;\n \n-        fn name_range<D>(def: D, sema: &Semantics<RootDatabase>) -> Option<FileRange>\n+        fn name_range<D>(def: D, sema: &Semantics<'_, RootDatabase>) -> Option<FileRange>\n         where\n             D: HasSource,\n             D::Ast: ast::HasName,\n@@ -168,7 +168,7 @@ impl Definition {\n }\n \n fn rename_mod(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     module: hir::Module,\n     new_name: &str,\n ) -> Result<SourceChange> {\n@@ -248,7 +248,7 @@ fn rename_mod(\n }\n \n fn rename_reference(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     def: Definition,\n     new_name: &str,\n ) -> Result<SourceChange> {\n@@ -448,7 +448,7 @@ fn source_edit_from_name_ref(\n }\n \n fn source_edit_from_def(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     def: Definition,\n     new_name: &str,\n ) -> Result<(FileId, TextEdit)> {"}, {"sha": "c75364084e36a26c87ea7626489760116411b164", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -305,7 +305,7 @@ impl Definition {\n         }\n     }\n \n-    pub fn usages<'a>(self, sema: &'a Semantics<RootDatabase>) -> FindUsages<'a> {\n+    pub fn usages<'a>(self, sema: &'a Semantics<'_, RootDatabase>) -> FindUsages<'a> {\n         FindUsages {\n             local_repr: match self {\n                 Definition::Local(local) => Some(local.representative(sema.db)),\n@@ -424,7 +424,7 @@ impl<'a> FindUsages<'a> {\n         }\n \n         fn scope_files<'a>(\n-            sema: &'a Semantics<RootDatabase>,\n+            sema: &'a Semantics<'_, RootDatabase>,\n             scope: &'a SearchScope,\n         ) -> impl Iterator<Item = (Arc<String>, FileId, TextRange)> + 'a {\n             scope.entries.iter().map(|(&file_id, &search_range)| {\n@@ -740,7 +740,7 @@ impl<'a> FindUsages<'a> {\n     }\n }\n \n-fn def_to_ty(sema: &Semantics<RootDatabase>, def: &Definition) -> Option<hir::Type> {\n+fn def_to_ty(sema: &Semantics<'_, RootDatabase>, def: &Definition) -> Option<hir::Type> {\n     match def {\n         Definition::Adt(adt) => Some(adt.ty(sema.db)),\n         Definition::TypeAlias(it) => Some(it.ty(sema.db)),"}, {"sha": "bfb00312771051f6c2dffd871017e3f65369333c", "filename": "crates/ide-db/src/symbol_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsymbol_index.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -224,7 +224,7 @@ pub struct SymbolIndex {\n }\n \n impl fmt::Debug for SymbolIndex {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"SymbolIndex\").field(\"n_symbols\", &self.symbols.len()).finish()\n     }\n }"}, {"sha": "84bde4d44dbb34dda5249336ec315966d1f0c881", "filename": "crates/ide-db/src/syntax_helpers/node_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -399,7 +399,7 @@ impl TreeWithDepthIterator {\n     }\n }\n \n-impl<'a> Iterator for TreeWithDepthIterator {\n+impl Iterator for TreeWithDepthIterator {\n     type Item = (ast::Expr, u32);\n \n     fn next(&mut self) -> Option<Self::Item> {"}, {"sha": "5042f6d815a1ea35357f314e6442276a4318ec58", "filename": "crates/ide-db/src/tests/sourcegen_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Ftests%2Fsourcegen_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Ftests%2Fsourcegen_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Ftests%2Fsourcegen_lints.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -264,7 +264,7 @@ fn push_lint_completion(buf: &mut String, label: &str, description: &str) {\n     );\n }\n \n-fn push_lint_group<'a>(buf: &mut String, label: &str, description: &str, children: &[String]) {\n+fn push_lint_group(buf: &mut String, label: &str, description: &str, children: &[String]) {\n     buf.push_str(\n         r###\"    LintGroup {\n         lint:"}, {"sha": "6a7ea7c19f22801f2ea1dde50c2e7928af792cca", "filename": "crates/ide-db/src/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Ftraits.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -7,7 +7,7 @@ use syntax::{ast, AstNode};\n \n /// Given the `impl` block, attempts to find the trait this `impl` corresponds to.\n pub fn resolve_target_trait(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     impl_def: &ast::Impl,\n ) -> Option<hir::Trait> {\n     let ast_path =\n@@ -22,7 +22,7 @@ pub fn resolve_target_trait(\n /// Given the `impl` block, returns the list of associated items (e.g. functions or types) that are\n /// missing in this `impl` block.\n pub fn get_missing_assoc_items(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     impl_def: &ast::Impl,\n ) -> Vec<hir::AssocItem> {\n     let imp = match sema.to_def(impl_def) {"}, {"sha": "46f47f258bdb89b873b48a12782e71048dc65d52", "filename": "crates/ide-db/src/ty_filter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fty_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-db%2Fsrc%2Fty_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fty_filter.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -20,7 +20,7 @@ impl TryEnum {\n     const ALL: [TryEnum; 2] = [TryEnum::Option, TryEnum::Result];\n \n     /// Returns `Some(..)` if the provided type is an enum that implements `std::ops::Try`.\n-    pub fn from_ty(sema: &Semantics<RootDatabase>, ty: &hir::Type) -> Option<TryEnum> {\n+    pub fn from_ty(sema: &Semantics<'_, RootDatabase>, ty: &hir::Type) -> Option<TryEnum> {\n         let enum_ = match ty.as_adt() {\n             Some(hir::Adt::Enum(it)) => it,\n             _ => return None,"}, {"sha": "e032c578f0282947032ffd60e8578b8c84ea935e", "filename": "crates/ide-diagnostics/src/handlers/no_such_field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -30,7 +30,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::NoSuchField) -> Option<Vec<Assis\n }\n \n fn missing_record_expr_field_fixes(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     usage_file_id: FileId,\n     record_expr_field: &ast::RecordExprField,\n ) -> Option<Vec<Assist>> {"}, {"sha": "80bd055c78be8a4247187b67672f659a8fb8444d", "filename": "crates/ide-diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -18,7 +18,7 @@ use crate::{fix, Assist, Diagnostic, DiagnosticsContext, Severity};\n //\n // This diagnostic is shown for files that are not included in any crate, or files that are part of\n // crates rust-analyzer failed to discover. The file will not have IDE features available.\n-pub(crate) fn unlinked_file(ctx: &DiagnosticsContext, acc: &mut Vec<Diagnostic>, file_id: FileId) {\n+pub(crate) fn unlinked_file(ctx: &DiagnosticsContext<'_>, acc: &mut Vec<Diagnostic>, file_id: FileId) {\n     // Limit diagnostic to the first few characters in the file. This matches how VS Code\n     // renders it with the full span, but on other editors, and is less invasive.\n     let range = ctx.sema.db.parse(file_id).syntax_node().text_range();\n@@ -32,7 +32,7 @@ pub(crate) fn unlinked_file(ctx: &DiagnosticsContext, acc: &mut Vec<Diagnostic>,\n     );\n }\n \n-fn fixes(ctx: &DiagnosticsContext, file_id: FileId) -> Option<Vec<Assist>> {\n+fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n     // If there's an existing module that could add `mod` or `pub mod` items to include the unlinked file,\n     // suggest that as a fix.\n "}, {"sha": "2c9c25b96cf7911483fa450d46de5f5bdf788a25", "filename": "crates/ide-ssr/src/from_comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-ssr%2Fsrc%2Ffrom_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-ssr%2Fsrc%2Ffrom_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Ffrom_comment.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -15,7 +15,7 @@ use crate::MatchFinder;\n /// Attempts to build an SSR MatchFinder from a comment at the given file\n /// range. If successful, returns the MatchFinder and a TextRange covering\n /// comment.\n-pub fn ssr_from_comment(db: &RootDatabase, frange: FileRange) -> Option<(MatchFinder, TextRange)> {\n+pub fn ssr_from_comment(db: &RootDatabase, frange: FileRange) -> Option<(MatchFinder<'_>, TextRange)> {\n     let comment = {\n         let file = db.parse(frange.file_id);\n         file.tree().syntax().token_at_offset(frange.range.start()).find_map(ast::Comment::cast)"}, {"sha": "e3a837ddcdb054247fbdc9de581effc1281d2692", "filename": "crates/ide-ssr/src/matching.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Fmatching.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -89,7 +89,7 @@ pub(crate) fn get_match(\n     rule: &ResolvedRule,\n     code: &SyntaxNode,\n     restrict_range: &Option<FileRange>,\n-    sema: &Semantics<ide_db::RootDatabase>,\n+    sema: &Semantics<'_, ide_db::RootDatabase>,\n ) -> Result<Match, MatchFailed> {\n     record_match_fails_reasons_scope(debug_active, || {\n         Matcher::try_match(rule, code, restrict_range, sema)\n@@ -165,7 +165,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n \n     fn attempt_match_node(\n         &self,\n-        phase: &mut Phase,\n+        phase: &mut Phase<'_>,\n         pattern: &SyntaxNode,\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n@@ -218,7 +218,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n \n     fn attempt_match_node_children(\n         &self,\n-        phase: &mut Phase,\n+        phase: &mut Phase<'_>,\n         pattern: &SyntaxNode,\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n@@ -231,7 +231,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n \n     fn attempt_match_sequences(\n         &self,\n-        phase: &mut Phase,\n+        phase: &mut Phase<'_>,\n         pattern_it: PatternIterator,\n         mut code_it: SyntaxElementChildren,\n     ) -> Result<(), MatchFailed> {\n@@ -260,7 +260,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n \n     fn attempt_match_token(\n         &self,\n-        phase: &mut Phase,\n+        phase: &mut Phase<'_>,\n         pattern: &mut Peekable<PatternIterator>,\n         code: &syntax::SyntaxToken,\n     ) -> Result<(), MatchFailed> {\n@@ -332,7 +332,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n     /// differently.\n     fn attempt_match_path(\n         &self,\n-        phase: &mut Phase,\n+        phase: &mut Phase<'_>,\n         pattern: &SyntaxNode,\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n@@ -372,7 +372,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n \n     fn attempt_match_opt<T: AstNode>(\n         &self,\n-        phase: &mut Phase,\n+        phase: &mut Phase<'_>,\n         pattern: Option<T>,\n         code: Option<T>,\n     ) -> Result<(), MatchFailed> {\n@@ -390,7 +390,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n     /// them.\n     fn attempt_match_record_field_list(\n         &self,\n-        phase: &mut Phase,\n+        phase: &mut Phase<'_>,\n         pattern: &SyntaxNode,\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n@@ -440,7 +440,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n     /// expanded the macro.\n     fn attempt_match_token_tree(\n         &self,\n-        phase: &mut Phase,\n+        phase: &mut Phase<'_>,\n         pattern: &SyntaxNode,\n         code: &syntax::SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n@@ -521,7 +521,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n \n     fn attempt_match_ufcs_to_method_call(\n         &self,\n-        phase: &mut Phase,\n+        phase: &mut Phase<'_>,\n         pattern_ufcs: &UfcsCallInfo,\n         code: &ast::MethodCallExpr,\n     ) -> Result<(), MatchFailed> {\n@@ -581,7 +581,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n \n     fn attempt_match_ufcs_to_ufcs(\n         &self,\n-        phase: &mut Phase,\n+        phase: &mut Phase<'_>,\n         pattern_ufcs: &UfcsCallInfo,\n         code: &ast::CallExpr,\n     ) -> Result<(), MatchFailed> {\n@@ -640,7 +640,7 @@ impl Match {\n     fn render_template_paths(\n         &mut self,\n         template: &ResolvedPattern,\n-        sema: &Semantics<ide_db::RootDatabase>,\n+        sema: &Semantics<'_, ide_db::RootDatabase>,\n     ) -> Result<(), MatchFailed> {\n         let module = sema\n             .scope(&self.matched_node)"}, {"sha": "c6a765070efb3f55d75729bd42471fe14694f9fb", "filename": "crates/ide-ssr/src/nester.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-ssr%2Fsrc%2Fnester.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-ssr%2Fsrc%2Fnester.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Fnester.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -14,7 +14,7 @@ use crate::{Match, SsrMatches};\n \n pub(crate) fn nest_and_remove_collisions(\n     mut matches: Vec<Match>,\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n+    sema: &hir::Semantics<'_, ide_db::RootDatabase>,\n ) -> SsrMatches {\n     // We sort the matches by depth then by rule index. Sorting by depth means that by the time we\n     // see a match, any parent matches or conflicting matches will have already been seen. Sorting\n@@ -37,7 +37,7 @@ impl MatchCollector {\n     /// Attempts to add `m` to matches. If it conflicts with an existing match, it is discarded. If\n     /// it is entirely within the a placeholder of an existing match, then it is added as a child\n     /// match of the existing match.\n-    fn add_match(&mut self, m: Match, sema: &hir::Semantics<ide_db::RootDatabase>) {\n+    fn add_match(&mut self, m: Match, sema: &hir::Semantics<'_, ide_db::RootDatabase>) {\n         let matched_node = m.matched_node.clone();\n         if let Some(existing) = self.matches_by_node.get_mut(&matched_node) {\n             try_add_sub_match(m, existing, sema);\n@@ -54,7 +54,7 @@ impl MatchCollector {\n }\n \n /// Attempts to add `m` as a sub-match of `existing`.\n-fn try_add_sub_match(m: Match, existing: &mut Match, sema: &hir::Semantics<ide_db::RootDatabase>) {\n+fn try_add_sub_match(m: Match, existing: &mut Match, sema: &hir::Semantics<'_, ide_db::RootDatabase>) {\n     for p in existing.placeholder_values.values_mut() {\n         // Note, no need to check if p.range.file is equal to m.range.file, since we\n         // already know we're within `existing`."}, {"sha": "4731f14f4e6234a580d12cf5b7a9e211262a7a94", "filename": "crates/ide-ssr/src/resolving.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Fresolving.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -42,7 +42,7 @@ pub(crate) struct UfcsCallInfo {\n impl ResolvedRule {\n     pub(crate) fn new(\n         rule: parsing::ParsedRule,\n-        resolution_scope: &ResolutionScope,\n+        resolution_scope: &ResolutionScope<'_>,\n         index: usize,\n     ) -> Result<ResolvedRule, SsrError> {\n         let resolver ="}, {"sha": "1ecb7aa9aa701092821267741bd04bc679899bcb", "filename": "crates/ide-ssr/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide-ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Ftests.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -113,7 +113,7 @@ fn assert_ssr_transforms(rules: &[&str], input: &str, expected: Expect) {\n     expected.assert_eq(&actual);\n }\n \n-fn print_match_debug_info(match_finder: &MatchFinder, file_id: FileId, snippet: &str) {\n+fn print_match_debug_info(match_finder: &MatchFinder<'_>, file_id: FileId, snippet: &str) {\n     let debug_info = match_finder.debug_where_text_equal(file_id, snippet);\n     println!(\n         \"Match debug info: {} nodes had text exactly equal to '{}'\","}, {"sha": "fed327f52be52953145156e2ce4f364bec6f254a", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -75,7 +75,7 @@ pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: Defin\n pub(crate) fn remove_links(markdown: &str) -> String {\n     let mut drop_link = false;\n \n-    let mut cb = |_: BrokenLink| {\n+    let mut cb = |_: BrokenLink<'_>| {\n         let empty = InlineStr::try_from(\"\").unwrap();\n         Some((CowStr::Inlined(empty), CowStr::Inlined(empty)))\n     };\n@@ -196,7 +196,7 @@ pub(crate) fn resolve_doc_path_for_def(\n }\n \n pub(crate) fn doc_attributes(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     node: &SyntaxNode,\n ) -> Option<(hir::AttrsWithOwner, Definition)> {\n     match_ast! {\n@@ -241,7 +241,7 @@ pub(crate) fn token_as_doc_comment(doc_token: &SyntaxToken) -> Option<DocComment\n impl DocCommentToken {\n     pub(crate) fn get_definition_with_descend_at<T>(\n         self,\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         offset: TextSize,\n         // Definition, CommentOwner, range of intra doc link in original file\n         mut cb: impl FnMut(Definition, SyntaxNode, TextRange) -> Option<T>,\n@@ -360,7 +360,7 @@ fn map_links<'e>(\n ) -> impl Iterator<Item = Event<'e>> {\n     let mut in_link = false;\n     // holds the origin link target on start event and the rewritten one on end event\n-    let mut end_link_target: Option<CowStr> = None;\n+    let mut end_link_target: Option<CowStr<'_>> = None;\n     // normally link's type is determined by the type of link tag in the end event,\n     // however in some cases we want to change the link type, for example,\n     // `Shortcut` type parsed from Start/End tags doesn't make sense for url links"}, {"sha": "c6bfb6b9d09756635cbd41e05cf1c6c2154117c2", "filename": "crates/ide/src/doc_links/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -52,7 +52,7 @@ fn check_doc_links(ra_fixture: &str) {\n }\n \n fn def_under_cursor(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     position: &FilePosition,\n ) -> (Definition, hir::Documentation) {\n     let (docs, def) = sema\n@@ -70,7 +70,7 @@ fn def_under_cursor(\n }\n \n fn node_to_def(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     node: &SyntaxNode,\n ) -> Option<Option<(Option<hir::Documentation>, Definition)>> {\n     Some(match_ast! {"}, {"sha": "136d3dec808721bec72e178a6709783fd9ea4bf4", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -100,23 +100,23 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n }\n \n fn expand_macro_recur(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     macro_call: &ast::MacroCall,\n ) -> Option<SyntaxNode> {\n     let expanded = sema.expand(macro_call)?.clone_for_update();\n     expand(sema, expanded, ast::MacroCall::cast, expand_macro_recur)\n }\n \n-fn expand_attr_macro_recur(sema: &Semantics<RootDatabase>, item: &ast::Item) -> Option<SyntaxNode> {\n+fn expand_attr_macro_recur(sema: &Semantics<'_, RootDatabase>, item: &ast::Item) -> Option<SyntaxNode> {\n     let expanded = sema.expand_attr_macro(item)?.clone_for_update();\n     expand(sema, expanded, ast::Item::cast, expand_attr_macro_recur)\n }\n \n fn expand<T: AstNode>(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     expanded: SyntaxNode,\n     f: impl FnMut(SyntaxNode) -> Option<T>,\n-    exp: impl Fn(&Semantics<RootDatabase>, &T) -> Option<SyntaxNode>,\n+    exp: impl Fn(&Semantics<'_, RootDatabase>, &T) -> Option<SyntaxNode>,\n ) -> Option<SyntaxNode> {\n     let children = expanded.descendants().filter_map(f);\n     let mut replacements = Vec::new();"}, {"sha": "45f1fd74841c695dc0572fa6a79b40aec1a0abd3", "filename": "crates/ide/src/extend_selection.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fextend_selection.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -33,7 +33,7 @@ pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRang\n }\n \n fn try_extend_selection(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     root: &SyntaxNode,\n     frange: FileRange,\n ) -> Option<TextRange> {\n@@ -120,7 +120,7 @@ fn try_extend_selection(\n }\n \n fn extend_tokens_from_range(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     macro_call: ast::MacroCall,\n     original_range: TextRange,\n ) -> Option<TextRange> {"}, {"sha": "d9c97751c95c319ef136b0852a8b7cfebdd6f460", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -79,7 +79,7 @@ pub(crate) fn goto_definition(\n }\n \n fn try_lookup_include_path(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     tt: ast::TokenTree,\n     token: SyntaxToken,\n     file_id: FileId,\n@@ -112,7 +112,7 @@ fn try_lookup_include_path(\n /// impl A for S { type a = i32; } // <-- on this associate type, will get the location of a in the trait\n /// ```\n fn try_filter_trait_item_definition(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     def: &Definition,\n ) -> Option<Vec<NavigationTarget>> {\n     let db = sema.db;"}, {"sha": "b29ee44e5b93bf9503aab62560c013377281399e", "filename": "crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -86,19 +86,19 @@ pub(crate) fn goto_implementation(\n     Some(RangeInfo { range, info: navs })\n }\n \n-fn impls_for_ty(sema: &Semantics<RootDatabase>, ty: hir::Type) -> Vec<NavigationTarget> {\n+fn impls_for_ty(sema: &Semantics<'_, RootDatabase>, ty: hir::Type) -> Vec<NavigationTarget> {\n     Impl::all_for_type(sema.db, ty).into_iter().filter_map(|imp| imp.try_to_nav(sema.db)).collect()\n }\n \n-fn impls_for_trait(sema: &Semantics<RootDatabase>, trait_: hir::Trait) -> Vec<NavigationTarget> {\n+fn impls_for_trait(sema: &Semantics<'_, RootDatabase>, trait_: hir::Trait) -> Vec<NavigationTarget> {\n     Impl::all_for_trait(sema.db, trait_)\n         .into_iter()\n         .filter_map(|imp| imp.try_to_nav(sema.db))\n         .collect()\n }\n \n fn impls_for_trait_item(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     trait_: hir::Trait,\n     fun_name: hir::Name,\n ) -> Vec<NavigationTarget> {"}, {"sha": "f2d7029eab19556b42059cef7e3abb8bf3633302", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -44,7 +44,7 @@ pub struct HighlightRelatedConfig {\n //\n // Note: `?` and `->` do not currently trigger this behavior in the VSCode editor.\n pub(crate) fn highlight_related(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: HighlightRelatedConfig,\n     FilePosition { offset, file_id }: FilePosition,\n ) -> Option<Vec<HighlightedRange>> {\n@@ -76,7 +76,7 @@ pub(crate) fn highlight_related(\n }\n \n fn highlight_references(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     node: &SyntaxNode,\n     token: SyntaxToken,\n     file_id: FileId,\n@@ -136,11 +136,11 @@ fn highlight_references(\n }\n \n fn highlight_exit_points(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     token: SyntaxToken,\n ) -> Option<Vec<HighlightedRange>> {\n     fn hl(\n-        sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<'_, RootDatabase>,\n         body: Option<ast::Expr>,\n     ) -> Option<Vec<HighlightedRange>> {\n         let mut highlights = Vec::new();\n@@ -330,7 +330,7 @@ fn cover_range(r0: Option<TextRange>, r1: Option<TextRange>) -> Option<TextRange\n     }\n }\n \n-fn find_defs(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> FxHashSet<Definition> {\n+fn find_defs(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken) -> FxHashSet<Definition> {\n     sema.descend_into_macros(token)\n         .into_iter()\n         .filter_map(|token| IdentClass::classify_token(sema, &token).map(IdentClass::definitions))"}, {"sha": "d8867cf783ad8ed9fc3b07907724b33d91fc2d04", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -163,7 +163,7 @@ pub(crate) fn hover(\n }\n \n pub(crate) fn hover_for_definition(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     file_id: FileId,\n     definition: Definition,\n     node: &SyntaxNode,\n@@ -189,7 +189,7 @@ pub(crate) fn hover_for_definition(\n fn hover_ranged(\n     file: &SyntaxNode,\n     range: syntax::TextRange,\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n     // FIXME: make this work in attributes\n@@ -222,7 +222,7 @@ fn hover_ranged(\n }\n \n fn hover_type_fallback(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n     token: &SyntaxToken,\n     original_token: &SyntaxToken,\n@@ -281,7 +281,7 @@ fn show_fn_references_action(db: &RootDatabase, def: Definition) -> Option<Hover\n }\n \n fn runnable_action(\n-    sema: &hir::Semantics<RootDatabase>,\n+    sema: &hir::Semantics<'_, RootDatabase>,\n     def: Definition,\n     file_id: FileId,\n ) -> Option<HoverAction> {"}, {"sha": "925aaa61cdd04f4b9777b326a8c1e70acaddc366", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -26,7 +26,7 @@ use crate::{\n };\n \n pub(super) fn type_info(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n     expr_or_pat: &Either<ast::Expr, ast::Pat>,\n ) -> Option<HoverResult> {\n@@ -71,7 +71,7 @@ pub(super) fn type_info(\n }\n \n pub(super) fn try_expr(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n     try_expr: &ast::TryExpr,\n ) -> Option<HoverResult> {\n@@ -162,7 +162,7 @@ pub(super) fn try_expr(\n }\n \n pub(super) fn deref_expr(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n     deref_expr: &ast::PrefixExpr,\n ) -> Option<HoverResult> {\n@@ -226,7 +226,7 @@ pub(super) fn deref_expr(\n }\n \n pub(super) fn keyword(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n     token: &SyntaxToken,\n ) -> Option<HoverResult> {\n@@ -335,7 +335,7 @@ pub(super) fn path(db: &RootDatabase, module: hir::Module, item_name: Option<Str\n pub(super) fn definition(\n     db: &RootDatabase,\n     def: Definition,\n-    famous_defs: Option<&FamousDefs>,\n+    famous_defs: Option<&FamousDefs<'_, '_>>,\n     config: &HoverConfig,\n ) -> Option<Markup> {\n     let mod_path = definition_mod_path(db, &def);\n@@ -460,15 +460,15 @@ fn markup(docs: Option<String>, desc: String, mod_path: Option<String>) -> Optio\n     Some(buf.into())\n }\n \n-fn builtin(famous_defs: &FamousDefs, builtin: hir::BuiltinType) -> Option<Markup> {\n+fn builtin(famous_defs: &FamousDefs<'_, '_>, builtin: hir::BuiltinType) -> Option<Markup> {\n     // std exposes prim_{} modules with docstrings on the root to document the builtins\n     let primitive_mod = format!(\"prim_{}\", builtin.name());\n     let doc_owner = find_std_module(famous_defs, &primitive_mod)?;\n     let docs = doc_owner.attrs(famous_defs.0.db).docs()?;\n     markup(Some(docs.into()), builtin.name().to_string(), None)\n }\n \n-fn find_std_module(famous_defs: &FamousDefs, name: &str) -> Option<hir::Module> {\n+fn find_std_module(famous_defs: &FamousDefs<'_, '_>, name: &str) -> Option<hir::Module> {\n     let db = famous_defs.0.db;\n     let std_crate = famous_defs.std()?;\n     let std_root_module = std_crate.root_module(db);\n@@ -513,7 +513,7 @@ impl KeywordHint {\n }\n \n fn keyword_hints(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     token: &SyntaxToken,\n     parent: syntax::SyntaxNode,\n ) -> KeywordHint {"}, {"sha": "5aae669aa4d6d1db97ddf26acdf823c215e6f2dc", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -138,7 +138,7 @@ pub(crate) fn inlay_hints(\n \n fn hints(\n     hints: &mut Vec<InlayHint>,\n-    famous_defs @ FamousDefs(sema, _): &FamousDefs,\n+    famous_defs @ FamousDefs(sema, _): &FamousDefs<'_, '_>,\n     config: &InlayHintsConfig,\n     file_id: FileId,\n     node: SyntaxNode,\n@@ -185,7 +185,7 @@ fn hints(\n \n fn closing_brace_hints(\n     acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &InlayHintsConfig,\n     file_id: FileId,\n     node: SyntaxNode,\n@@ -502,8 +502,8 @@ fn fn_lifetime_fn_hints(\n \n fn closure_ret_hints(\n     acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<RootDatabase>,\n-    famous_defs: &FamousDefs,\n+    sema: &Semantics<'_, RootDatabase>,\n+    famous_defs: &FamousDefs<'_, '_>,\n     config: &InlayHintsConfig,\n     file_id: FileId,\n     closure: ast::ClosureExpr,\n@@ -543,7 +543,7 @@ fn closure_ret_hints(\n \n fn reborrow_hints(\n     acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &InlayHintsConfig,\n     expr: &ast::Expr,\n ) -> Option<()> {\n@@ -570,8 +570,8 @@ fn reborrow_hints(\n \n fn chaining_hints(\n     acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<RootDatabase>,\n-    famous_defs: &FamousDefs,\n+    sema: &Semantics<'_, RootDatabase>,\n+    famous_defs: &FamousDefs<'_, '_>,\n     config: &InlayHintsConfig,\n     file_id: FileId,\n     expr: &ast::Expr,\n@@ -632,7 +632,7 @@ fn chaining_hints(\n \n fn param_name_hints(\n     acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &InlayHintsConfig,\n     expr: ast::Expr,\n ) -> Option<()> {\n@@ -685,7 +685,7 @@ fn param_name_hints(\n \n fn binding_mode_hints(\n     acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &InlayHintsConfig,\n     pat: &ast::Pat,\n ) -> Option<()> {\n@@ -732,7 +732,7 @@ fn binding_mode_hints(\n \n fn bind_pat_hints(\n     acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &InlayHintsConfig,\n     file_id: FileId,\n     pat: &ast::IdentPat,\n@@ -783,7 +783,7 @@ fn bind_pat_hints(\n }\n \n fn is_named_constructor(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     pat: &ast::IdentPat,\n     ty_name: &str,\n ) -> Option<()> {\n@@ -837,8 +837,8 @@ fn is_named_constructor(\n \n /// Checks if the type is an Iterator from std::iter and replaces its hint with an `impl Iterator<Item = Ty>`.\n fn hint_iterator(\n-    sema: &Semantics<RootDatabase>,\n-    famous_defs: &FamousDefs,\n+    sema: &Semantics<'_, RootDatabase>,\n+    famous_defs: &FamousDefs<'_, '_>,\n     config: &InlayHintsConfig,\n     ty: &hir::Type,\n ) -> Option<String> {\n@@ -899,7 +899,7 @@ fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &hir\n }\n \n fn should_not_display_type_hint(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     config: &InlayHintsConfig,\n     bind_pat: &ast::IdentPat,\n     pat_ty: &hir::Type,\n@@ -959,7 +959,7 @@ fn closure_has_block_body(closure: &ast::ClosureExpr) -> bool {\n }\n \n fn should_hide_param_name_hint(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     callable: &hir::Callable,\n     param_name: &str,\n     argument: &ast::Expr,\n@@ -1048,7 +1048,7 @@ fn is_param_name_suffix_of_fn_name(\n }\n \n fn is_adt_constructor_similar_to_param_name(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     argument: &ast::Expr,\n     param_name: &str,\n ) -> bool {\n@@ -1116,7 +1116,7 @@ fn is_obvious_param(param_name: &str) -> bool {\n }\n \n fn get_callable(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     expr: &ast::Expr,\n ) -> Option<(hir::Callable, ast::ArgList)> {\n     match expr {"}, {"sha": "1a6beec1881b00faf061a2e3b52b54429cda90ec", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -50,7 +50,7 @@ pub struct Declaration {\n //\n // image::https://user-images.githubusercontent.com/48062697/113020670-b7c34f00-917a-11eb-8003-370ac5f2b3cb.gif[]\n pub(crate) fn find_all_refs(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     position: FilePosition,\n     search_scope: Option<SearchScope>,\n ) -> Option<Vec<ReferenceSearchResult>> {\n@@ -112,7 +112,7 @@ pub(crate) fn find_all_refs(\n }\n \n pub(crate) fn find_defs<'a>(\n-    sema: &'a Semantics<RootDatabase>,\n+    sema: &'a Semantics<'_, RootDatabase>,\n     syntax: &SyntaxNode,\n     offset: TextSize,\n ) -> Option<impl Iterator<Item = Definition> + 'a> {\n@@ -178,7 +178,7 @@ pub(crate) fn decl_mutability(def: &Definition, syntax: &SyntaxNode, range: Text\n fn retain_adt_literal_usages(\n     usages: &mut UsageSearchResult,\n     def: Definition,\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n ) {\n     let refs = usages.references.values_mut();\n     match def {\n@@ -242,7 +242,7 @@ fn name_for_constructor_search(syntax: &SyntaxNode, position: FilePosition) -> O\n }\n \n fn is_enum_lit_name_ref(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     enum_: hir::Enum,\n     name_ref: &ast::NameRef,\n ) -> bool {"}, {"sha": "9f64ddea2088add194bffc3bc7637af7d6239cd0", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -120,7 +120,7 @@ pub(crate) fn will_rename_file(\n }\n \n fn find_definitions(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n ) -> RenameResult<impl Iterator<Item = (ast::NameLike, Definition)>> {\n@@ -201,7 +201,7 @@ fn find_definitions(\n     }\n }\n \n-fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameResult<SourceChange> {\n+fn rename_to_self(sema: &Semantics<'_, RootDatabase>, local: hir::Local) -> RenameResult<SourceChange> {\n     if never!(local.is_self(sema.db)) {\n         bail!(\"rename_to_self invoked on self\");\n     }\n@@ -269,7 +269,7 @@ fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameRe\n }\n \n fn rename_self_to_param(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     local: hir::Local,\n     self_param: hir::SelfParam,\n     new_name: &str,"}, {"sha": "b2869d44ac8821922c21d49ea84cb6b01bc54f59", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -35,7 +35,7 @@ pub enum TestId {\n }\n \n impl fmt::Display for TestId {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             TestId::Name(name) => name.fmt(f),\n             TestId::Path(path) => path.fmt(f),\n@@ -219,7 +219,7 @@ pub(crate) fn related_tests(\n }\n \n fn find_related_tests(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n     search_scope: Option<SearchScope>,\n@@ -259,7 +259,7 @@ fn find_related_tests(\n }\n \n fn find_related_tests_in_module(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     syntax: &SyntaxNode,\n     fn_def: &ast::Fn,\n     parent_module: &hir::Module,\n@@ -282,7 +282,7 @@ fn find_related_tests_in_module(\n     find_related_tests(sema, syntax, fn_pos, Some(mod_scope), tests)\n }\n \n-fn as_test_runnable(sema: &Semantics<RootDatabase>, fn_def: &ast::Fn) -> Option<Runnable> {\n+fn as_test_runnable(sema: &Semantics<'_, RootDatabase>, fn_def: &ast::Fn) -> Option<Runnable> {\n     if test_related_attribute(fn_def).is_some() {\n         let function = sema.to_def(fn_def)?;\n         runnable_fn(sema, function)\n@@ -291,7 +291,7 @@ fn as_test_runnable(sema: &Semantics<RootDatabase>, fn_def: &ast::Fn) -> Option<\n     }\n }\n \n-fn parent_test_module(sema: &Semantics<RootDatabase>, fn_def: &ast::Fn) -> Option<hir::Module> {\n+fn parent_test_module(sema: &Semantics<'_, RootDatabase>, fn_def: &ast::Fn) -> Option<hir::Module> {\n     fn_def.syntax().ancestors().find_map(|node| {\n         let module = ast::Module::cast(node)?;\n         let module = sema.to_def(&module)?;\n@@ -304,7 +304,7 @@ fn parent_test_module(sema: &Semantics<RootDatabase>, fn_def: &ast::Fn) -> Optio\n     })\n }\n \n-pub(crate) fn runnable_fn(sema: &Semantics<RootDatabase>, def: hir::Function) -> Option<Runnable> {\n+pub(crate) fn runnable_fn(sema: &Semantics<'_, RootDatabase>, def: hir::Function) -> Option<Runnable> {\n     let func = def.source(sema.db)?;\n     let name = def.name(sema.db).to_smol_str();\n \n@@ -340,7 +340,7 @@ pub(crate) fn runnable_fn(sema: &Semantics<RootDatabase>, def: hir::Function) ->\n     Some(Runnable { use_name_in_title: false, nav, kind, cfg })\n }\n \n-pub(crate) fn runnable_mod(sema: &Semantics<RootDatabase>, def: hir::Module) -> Option<Runnable> {\n+pub(crate) fn runnable_mod(sema: &Semantics<'_, RootDatabase>, def: hir::Module) -> Option<Runnable> {\n     if !has_test_function_or_multiple_test_submodules(sema, &def) {\n         return None;\n     }\n@@ -353,7 +353,7 @@ pub(crate) fn runnable_mod(sema: &Semantics<RootDatabase>, def: hir::Module) ->\n     Some(Runnable { use_name_in_title: false, nav, kind: RunnableKind::TestMod { path }, cfg })\n }\n \n-pub(crate) fn runnable_impl(sema: &Semantics<RootDatabase>, def: &hir::Impl) -> Option<Runnable> {\n+pub(crate) fn runnable_impl(sema: &Semantics<'_, RootDatabase>, def: &hir::Impl) -> Option<Runnable> {\n     let attrs = def.attrs(sema.db);\n     if !has_runnable_doc_test(&attrs) {\n         return None;\n@@ -375,7 +375,7 @@ pub(crate) fn runnable_impl(sema: &Semantics<RootDatabase>, def: &hir::Impl) ->\n \n /// Creates a test mod runnable for outline modules at the top of their definition.\n fn runnable_mod_outline_definition(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     def: hir::Module,\n ) -> Option<Runnable> {\n     if !has_test_function_or_multiple_test_submodules(sema, &def) {\n@@ -509,7 +509,7 @@ fn has_runnable_doc_test(attrs: &hir::Attrs) -> bool {\n // We could create runnables for modules with number_of_test_submodules > 0,\n // but that bloats the runnables for no real benefit, since all tests can be run by the submodule already\n fn has_test_function_or_multiple_test_submodules(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     module: &hir::Module,\n ) -> bool {\n     let mut number_of_test_submodules = 0;"}, {"sha": "ba287d13aec1d2a341aac010a745431a7e83b687", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -94,7 +94,7 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n }\n \n fn signature_help_for_call(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n     // Find the calling expression and its NameRef\n@@ -198,7 +198,7 @@ fn signature_help_for_call(\n }\n \n fn signature_help_for_generics(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n     let parent = token.parent()?;"}, {"sha": "d74b640415c76e83e4b8a9c0a10877453bfddf4a", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -173,7 +173,7 @@ impl StaticIndex<'_> {\n         self.files.push(result);\n     }\n \n-    pub fn compute(analysis: &Analysis) -> StaticIndex {\n+    pub fn compute(analysis: &Analysis) -> StaticIndex<'_> {\n         let db = &*analysis.db;\n         let work = all_modules(db).into_iter().filter(|module| {\n             let file_id = module.definition_source(db).file_id.original_file(db);\n@@ -202,7 +202,7 @@ impl StaticIndex<'_> {\n     }\n }\n \n-fn get_definition(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Definition> {\n+fn get_definition(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken) -> Option<Definition> {\n     for token in sema.descend_into_macros(token) {\n         let def = IdentClass::classify_token(sema, &token).map(IdentClass::definitions);\n         if let Some(&[x]) = def.as_deref() {"}, {"sha": "3191870eb5e8f888f85f4c66170e57d02d2a6b2e", "filename": "crates/ide/src/status.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatus.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -75,7 +75,7 @@ struct FilesStats {\n }\n \n impl fmt::Display for FilesStats {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"{} of files\", self.size)\n     }\n }\n@@ -101,7 +101,7 @@ pub(crate) struct SyntaxTreeStats {\n }\n \n impl fmt::Display for SyntaxTreeStats {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"{} trees, {} preserved\", self.total, self.retained)\n     }\n }\n@@ -143,7 +143,7 @@ struct LibrarySymbolsStats {\n }\n \n impl fmt::Display for LibrarySymbolsStats {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"{} of index symbols ({})\", self.size, self.total)\n     }\n }"}, {"sha": "9fb6a302632e352b87854ada49a9807df245dbc1", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -196,7 +196,7 @@ pub(crate) fn highlight(\n \n fn traverse(\n     hl: &mut Highlights,\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     file_id: FileId,\n     root: &SyntaxNode,\n     krate: hir::Crate,"}, {"sha": "42adca49585e71c0e1a3c7d0b32bf1ef65e935b2", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     Highlight, HlMod, HlTag,\n };\n \n-pub(super) fn token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Highlight> {\n+pub(super) fn token(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken) -> Option<Highlight> {\n     if let Some(comment) = ast::Comment::cast(token.clone()) {\n         let h = HlTag::Comment;\n         return Some(match comment.kind().doc {\n@@ -46,7 +46,7 @@ pub(super) fn token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Optio\n }\n \n pub(super) fn name_like(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     krate: hir::Crate,\n     bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n     syntactic_name_ref_highlighting: bool,\n@@ -79,7 +79,7 @@ pub(super) fn name_like(\n     Some((highlight, binding_hash))\n }\n \n-fn punctuation(sema: &Semantics<RootDatabase>, token: SyntaxToken, kind: SyntaxKind) -> Highlight {\n+fn punctuation(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken, kind: SyntaxKind) -> Highlight {\n     let parent = token.parent();\n     let parent_kind = parent.as_ref().map_or(EOF, SyntaxNode::kind);\n     match (kind, parent_kind) {\n@@ -151,7 +151,7 @@ fn punctuation(sema: &Semantics<RootDatabase>, token: SyntaxToken, kind: SyntaxK\n }\n \n fn keyword(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     token: SyntaxToken,\n     kind: SyntaxKind,\n ) -> Option<Highlight> {\n@@ -190,7 +190,7 @@ fn keyword(\n }\n \n fn highlight_name_ref(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     krate: hir::Crate,\n     bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n     binding_hash: &mut Option<u64>,\n@@ -274,7 +274,7 @@ fn highlight_name_ref(\n }\n \n fn highlight_name(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n     binding_hash: &mut Option<u64>,\n     krate: hir::Crate,\n@@ -321,7 +321,7 @@ fn calc_binding_hash(name: &hir::Name, shadow_count: u32) -> u64 {\n     hash((name, shadow_count))\n }\n \n-fn highlight_def(sema: &Semantics<RootDatabase>, krate: hir::Crate, def: Definition) -> Highlight {\n+fn highlight_def(sema: &Semantics<'_, RootDatabase>, krate: hir::Crate, def: Definition) -> Highlight {\n     let db = sema.db;\n     let mut h = match def {\n         Definition::Macro(m) => Highlight::new(HlTag::Symbol(m.kind(sema.db).into())),\n@@ -486,7 +486,7 @@ fn highlight_def(sema: &Semantics<RootDatabase>, krate: hir::Crate, def: Definit\n }\n \n fn highlight_method_call_by_name_ref(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     krate: hir::Crate,\n     name_ref: &ast::NameRef,\n ) -> Option<Highlight> {\n@@ -495,7 +495,7 @@ fn highlight_method_call_by_name_ref(\n }\n \n fn highlight_method_call(\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     krate: hir::Crate,\n     method_call: &ast::MethodCallExpr,\n ) -> Option<Highlight> {\n@@ -584,7 +584,7 @@ fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n \n fn highlight_name_ref_by_syntax(\n     name: ast::NameRef,\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     krate: hir::Crate,\n ) -> Highlight {\n     let default = HlTag::UnresolvedReference;"}, {"sha": "94d573a30b0412f5895bb63a0574ad83a334086c", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -20,7 +20,7 @@ use crate::{\n \n pub(super) fn ra_fixture(\n     hl: &mut Highlights,\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     literal: &ast::String,\n     expanded: &ast::String,\n ) -> Option<()> {\n@@ -84,7 +84,7 @@ const RUSTDOC_FENCES: [&str; 2] = [\"```\", \"~~~\"];\n /// Injection of syntax highlighting of doctests.\n pub(super) fn doc_comment(\n     hl: &mut Highlights,\n-    sema: &Semantics<RootDatabase>,\n+    sema: &Semantics<'_, RootDatabase>,\n     InFile { file_id: src_file_id, value: node }: InFile<&SyntaxNode>,\n ) {\n     let (attributes, def) = match doc_attributes(sema, node) {"}, {"sha": "5020e9abaf31502ea80fdecc6971d9ee1b712ea9", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -522,7 +522,7 @@ fn match_loop_inner<'t>(\n \n fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n     let mut src = TtIter::new(src);\n-    let mut stack: SmallVec<[TtIter; 1]> = SmallVec::new();\n+    let mut stack: SmallVec<[TtIter<'_>; 1]> = SmallVec::new();\n     let mut res = Match::default();\n     let mut error_recover_item = None;\n \n@@ -656,7 +656,7 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n     }\n }\n \n-fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter) -> Result<(), ExpandError> {\n+fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter<'_>) -> Result<(), ExpandError> {\n     let rhs = src\n         .expect_leaf()\n         .map_err(|()| ExpandError::binding_error(format!(\"expected leaf: `{lhs}`\")))?;\n@@ -677,7 +677,7 @@ fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter) -> Result<(), ExpandError> {\n     }\n }\n \n-fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragment>> {\n+fn match_meta_var(kind: &str, input: &mut TtIter<'_>) -> ExpandResult<Option<Fragment>> {\n     let fragment = match kind {\n         \"path\" => parser::PrefixEntryPoint::Path,\n         \"ty\" => parser::PrefixEntryPoint::Ty,"}, {"sha": "7bcc84740f1869935c23fa710574c0f083da9f40", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -75,7 +75,7 @@ struct ExpandCtx<'a> {\n }\n \n fn expand_subtree(\n-    ctx: &mut ExpandCtx,\n+    ctx: &mut ExpandCtx<'_>,\n     template: &MetaTemplate,\n     delimiter: Option<Delimiter>,\n     arena: &mut Vec<tt::TokenTree>,\n@@ -127,7 +127,7 @@ fn expand_subtree(\n     ExpandResult { value: tt::Subtree { delimiter, token_trees: tts }, err }\n }\n \n-fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr, id: tt::TokenId) -> ExpandResult<Fragment> {\n+fn expand_var(ctx: &mut ExpandCtx<'_>, v: &SmolStr, id: tt::TokenId) -> ExpandResult<Fragment> {\n     // We already handle $crate case in mbe parser\n     debug_assert!(v != \"crate\");\n \n@@ -163,7 +163,7 @@ fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr, id: tt::TokenId) -> ExpandResult\n }\n \n fn expand_repeat(\n-    ctx: &mut ExpandCtx,\n+    ctx: &mut ExpandCtx<'_>,\n     template: &MetaTemplate,\n     kind: RepeatKind,\n     separator: &Option<Separator>,"}, {"sha": "79da84f4a022638c96a08d0b57842735a217545a", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -268,7 +268,7 @@ impl DeclarativeMacro {\n }\n \n impl Rule {\n-    fn parse(src: &mut TtIter, expect_arrow: bool) -> Result<Self, ParseError> {\n+    fn parse(src: &mut TtIter<'_>, expect_arrow: bool) -> Result<Self, ParseError> {\n         let lhs = src.expect_subtree().map_err(|()| ParseError::expected(\"expected subtree\"))?;\n         if expect_arrow {\n             src.expect_char('=').map_err(|()| ParseError::expected(\"expected `=`\"))?;"}, {"sha": "acb4be5846de1936a3ca2de080e17949321149bf", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -194,7 +194,7 @@ fn is_boolean_literal(lit: &tt::Literal) -> bool {\n     matches!(lit.text.as_str(), \"true\" | \"false\")\n }\n \n-fn parse_repeat(src: &mut TtIter) -> Result<(Option<Separator>, RepeatKind), ParseError> {\n+fn parse_repeat(src: &mut TtIter<'_>) -> Result<(Option<Separator>, RepeatKind), ParseError> {\n     let mut separator = Separator::Puncts(SmallVec::new());\n     for tt in src {\n         let tt = match tt {\n@@ -231,7 +231,7 @@ fn parse_repeat(src: &mut TtIter) -> Result<(Option<Separator>, RepeatKind), Par\n     Err(ParseError::InvalidRepeat)\n }\n \n-fn parse_metavar_expr(src: &mut TtIter) -> Result<Op, ()> {\n+fn parse_metavar_expr(src: &mut TtIter<'_>) -> Result<Op, ()> {\n     let func = src.expect_ident()?;\n     let args = src.expect_subtree()?;\n "}, {"sha": "783c3ca4a89f7dd8025e172292ba11c9100564b1", "filename": "crates/mbe/src/to_parser_input.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -4,7 +4,7 @@\n use syntax::{SyntaxKind, SyntaxKind::*, T};\n use tt::buffer::TokenBuffer;\n \n-pub(crate) fn to_parser_input(buffer: &TokenBuffer) -> parser::Input {\n+pub(crate) fn to_parser_input(buffer: &TokenBuffer<'_>) -> parser::Input {\n     let mut res = parser::Input::default();\n \n     let mut current = buffer.begin();"}, {"sha": "b7468329610a7e247985e32622b6eeb84d994e87", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -50,51 +50,51 @@ pub(crate) mod entry {\n     pub(crate) mod prefix {\n         use super::*;\n \n-        pub(crate) fn vis(p: &mut Parser) {\n+        pub(crate) fn vis(p: &mut Parser<'_>) {\n             let _ = opt_visibility(p, false);\n         }\n \n-        pub(crate) fn block(p: &mut Parser) {\n+        pub(crate) fn block(p: &mut Parser<'_>) {\n             expressions::block_expr(p);\n         }\n \n-        pub(crate) fn stmt(p: &mut Parser) {\n+        pub(crate) fn stmt(p: &mut Parser<'_>) {\n             expressions::stmt(p, expressions::Semicolon::Forbidden);\n         }\n \n-        pub(crate) fn pat(p: &mut Parser) {\n+        pub(crate) fn pat(p: &mut Parser<'_>) {\n             patterns::pattern_single(p);\n         }\n \n-        pub(crate) fn ty(p: &mut Parser) {\n+        pub(crate) fn ty(p: &mut Parser<'_>) {\n             types::type_(p);\n         }\n-        pub(crate) fn expr(p: &mut Parser) {\n+        pub(crate) fn expr(p: &mut Parser<'_>) {\n             let _ = expressions::expr(p);\n         }\n-        pub(crate) fn path(p: &mut Parser) {\n+        pub(crate) fn path(p: &mut Parser<'_>) {\n             let _ = paths::type_path(p);\n         }\n-        pub(crate) fn item(p: &mut Parser) {\n+        pub(crate) fn item(p: &mut Parser<'_>) {\n             items::item_or_macro(p, true);\n         }\n         // Parse a meta item , which excluded [], e.g : #[ MetaItem ]\n-        pub(crate) fn meta_item(p: &mut Parser) {\n+        pub(crate) fn meta_item(p: &mut Parser<'_>) {\n             attributes::meta(p);\n         }\n     }\n \n     pub(crate) mod top {\n         use super::*;\n \n-        pub(crate) fn source_file(p: &mut Parser) {\n+        pub(crate) fn source_file(p: &mut Parser<'_>) {\n             let m = p.start();\n             p.eat(SHEBANG);\n             items::mod_contents(p, false);\n             m.complete(p, SOURCE_FILE);\n         }\n \n-        pub(crate) fn macro_stmts(p: &mut Parser) {\n+        pub(crate) fn macro_stmts(p: &mut Parser<'_>) {\n             let m = p.start();\n \n             while !p.at(EOF) {\n@@ -104,13 +104,13 @@ pub(crate) mod entry {\n             m.complete(p, MACRO_STMTS);\n         }\n \n-        pub(crate) fn macro_items(p: &mut Parser) {\n+        pub(crate) fn macro_items(p: &mut Parser<'_>) {\n             let m = p.start();\n             items::mod_contents(p, false);\n             m.complete(p, MACRO_ITEMS);\n         }\n \n-        pub(crate) fn pattern(p: &mut Parser) {\n+        pub(crate) fn pattern(p: &mut Parser<'_>) {\n             let m = p.start();\n             patterns::pattern_top(p);\n             if p.at(EOF) {\n@@ -123,7 +123,7 @@ pub(crate) mod entry {\n             m.complete(p, ERROR);\n         }\n \n-        pub(crate) fn type_(p: &mut Parser) {\n+        pub(crate) fn type_(p: &mut Parser<'_>) {\n             let m = p.start();\n             types::type_(p);\n             if p.at(EOF) {\n@@ -136,7 +136,7 @@ pub(crate) mod entry {\n             m.complete(p, ERROR);\n         }\n \n-        pub(crate) fn expr(p: &mut Parser) {\n+        pub(crate) fn expr(p: &mut Parser<'_>) {\n             let m = p.start();\n             expressions::expr(p);\n             if p.at(EOF) {\n@@ -149,7 +149,7 @@ pub(crate) mod entry {\n             m.complete(p, ERROR);\n         }\n \n-        pub(crate) fn meta_item(p: &mut Parser) {\n+        pub(crate) fn meta_item(p: &mut Parser<'_>) {\n             let m = p.start();\n             attributes::meta(p);\n             if p.at(EOF) {\n@@ -168,7 +168,7 @@ pub(crate) fn reparser(\n     node: SyntaxKind,\n     first_child: Option<SyntaxKind>,\n     parent: Option<SyntaxKind>,\n-) -> Option<fn(&mut Parser)> {\n+) -> Option<fn(&mut Parser<'_>)> {\n     let res = match node {\n         BLOCK_EXPR => expressions::block_expr,\n         RECORD_FIELD_LIST => items::record_field_list,\n@@ -200,7 +200,7 @@ impl BlockLike {\n     }\n }\n \n-fn opt_visibility(p: &mut Parser, in_tuple_field: bool) -> bool {\n+fn opt_visibility(p: &mut Parser<'_>, in_tuple_field: bool) -> bool {\n     match p.current() {\n         T![pub] => {\n             let m = p.start();\n@@ -262,7 +262,7 @@ fn opt_visibility(p: &mut Parser, in_tuple_field: bool) -> bool {\n     }\n }\n \n-fn opt_rename(p: &mut Parser) {\n+fn opt_rename(p: &mut Parser<'_>) {\n     if p.at(T![as]) {\n         let m = p.start();\n         p.bump(T![as]);\n@@ -273,15 +273,15 @@ fn opt_rename(p: &mut Parser) {\n     }\n }\n \n-fn abi(p: &mut Parser) {\n+fn abi(p: &mut Parser<'_>) {\n     assert!(p.at(T![extern]));\n     let abi = p.start();\n     p.bump(T![extern]);\n     p.eat(STRING);\n     abi.complete(p, ABI);\n }\n \n-fn opt_ret_type(p: &mut Parser) -> bool {\n+fn opt_ret_type(p: &mut Parser<'_>) -> bool {\n     if p.at(T![->]) {\n         let m = p.start();\n         p.bump(T![->]);\n@@ -293,7 +293,7 @@ fn opt_ret_type(p: &mut Parser) -> bool {\n     }\n }\n \n-fn name_r(p: &mut Parser, recovery: TokenSet) {\n+fn name_r(p: &mut Parser<'_>, recovery: TokenSet) {\n     if p.at(IDENT) {\n         let m = p.start();\n         p.bump(IDENT);\n@@ -303,11 +303,11 @@ fn name_r(p: &mut Parser, recovery: TokenSet) {\n     }\n }\n \n-fn name(p: &mut Parser) {\n+fn name(p: &mut Parser<'_>) {\n     name_r(p, TokenSet::EMPTY);\n }\n \n-fn name_ref(p: &mut Parser) {\n+fn name_ref(p: &mut Parser<'_>) {\n     if p.at(IDENT) {\n         let m = p.start();\n         p.bump(IDENT);\n@@ -317,21 +317,21 @@ fn name_ref(p: &mut Parser) {\n     }\n }\n \n-fn name_ref_or_index(p: &mut Parser) {\n+fn name_ref_or_index(p: &mut Parser<'_>) {\n     assert!(p.at(IDENT) || p.at(INT_NUMBER));\n     let m = p.start();\n     p.bump_any();\n     m.complete(p, NAME_REF);\n }\n \n-fn lifetime(p: &mut Parser) {\n+fn lifetime(p: &mut Parser<'_>) {\n     assert!(p.at(LIFETIME_IDENT));\n     let m = p.start();\n     p.bump(LIFETIME_IDENT);\n     m.complete(p, LIFETIME);\n }\n \n-fn error_block(p: &mut Parser, message: &str) {\n+fn error_block(p: &mut Parser<'_>, message: &str) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.error(message);"}, {"sha": "0cf6a16f86a573bf785e07df7509e4af237db9e6", "filename": "crates/parser/src/grammar/attributes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -1,18 +1,18 @@\n use super::*;\n \n-pub(super) fn inner_attrs(p: &mut Parser) {\n+pub(super) fn inner_attrs(p: &mut Parser<'_>) {\n     while p.at(T![#]) && p.nth(1) == T![!] {\n         attr(p, true);\n     }\n }\n \n-pub(super) fn outer_attrs(p: &mut Parser) {\n+pub(super) fn outer_attrs(p: &mut Parser<'_>) {\n     while p.at(T![#]) {\n         attr(p, false);\n     }\n }\n \n-fn attr(p: &mut Parser, inner: bool) {\n+fn attr(p: &mut Parser<'_>, inner: bool) {\n     assert!(p.at(T![#]));\n \n     let attr = p.start();\n@@ -34,7 +34,7 @@ fn attr(p: &mut Parser, inner: bool) {\n     attr.complete(p, ATTR);\n }\n \n-pub(super) fn meta(p: &mut Parser) {\n+pub(super) fn meta(p: &mut Parser<'_>) {\n     let meta = p.start();\n     paths::use_path(p);\n "}, {"sha": "8887f3330bd477c73f50213f85b335b68bbf8d9d", "filename": "crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -14,17 +14,17 @@ pub(super) enum Semicolon {\n \n const EXPR_FIRST: TokenSet = LHS_FIRST;\n \n-pub(super) fn expr(p: &mut Parser) -> bool {\n+pub(super) fn expr(p: &mut Parser<'_>) -> bool {\n     let r = Restrictions { forbid_structs: false, prefer_stmt: false };\n     expr_bp(p, None, r, 1).is_some()\n }\n \n-pub(super) fn expr_stmt(p: &mut Parser, m: Option<Marker>) -> Option<(CompletedMarker, BlockLike)> {\n+pub(super) fn expr_stmt(p: &mut Parser<'_>, m: Option<Marker>) -> Option<(CompletedMarker, BlockLike)> {\n     let r = Restrictions { forbid_structs: false, prefer_stmt: true };\n     expr_bp(p, m, r, 1)\n }\n \n-fn expr_no_struct(p: &mut Parser) {\n+fn expr_no_struct(p: &mut Parser<'_>) {\n     let r = Restrictions { forbid_structs: true, prefer_stmt: false };\n     expr_bp(p, None, r, 1);\n }\n@@ -33,12 +33,12 @@ fn expr_no_struct(p: &mut Parser) {\n /// It needs to be parsed with lower precedence than `&&`, so that\n /// `if let true = true && false` is parsed as `if (let true = true) && (true)`\n /// and not `if let true = (true && true)`.\n-fn expr_let(p: &mut Parser) {\n+fn expr_let(p: &mut Parser<'_>) {\n     let r = Restrictions { forbid_structs: true, prefer_stmt: false };\n     expr_bp(p, None, r, 5);\n }\n \n-pub(super) fn stmt(p: &mut Parser, semicolon: Semicolon) {\n+pub(super) fn stmt(p: &mut Parser<'_>, semicolon: Semicolon) {\n     if p.eat(T![;]) {\n         return;\n     }\n@@ -101,7 +101,7 @@ pub(super) fn stmt(p: &mut Parser, semicolon: Semicolon) {\n \n     // test let_stmt\n     // fn f() { let x: i32 = 92; }\n-    fn let_stmt(p: &mut Parser, m: Marker, with_semi: Semicolon) {\n+    fn let_stmt(p: &mut Parser<'_>, m: Marker, with_semi: Semicolon) {\n         p.bump(T![let]);\n         patterns::pattern(p);\n         if p.at(T![:]) {\n@@ -138,7 +138,7 @@ pub(super) fn stmt(p: &mut Parser, semicolon: Semicolon) {\n     }\n }\n \n-pub(super) fn expr_block_contents(p: &mut Parser) {\n+pub(super) fn expr_block_contents(p: &mut Parser<'_>) {\n     attributes::inner_attrs(p);\n \n     while !p.at(EOF) && !p.at(T!['}']) {\n@@ -170,7 +170,7 @@ struct Restrictions {\n ///\n /// See <https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html>\n #[rustfmt::skip]\n-fn current_op(p: &Parser) -> (u8, SyntaxKind) {\n+fn current_op(p: &Parser<'_>) -> (u8, SyntaxKind) {\n     const NOT_AN_OP: (u8, SyntaxKind) = (0, T![@]);\n     match p.current() {\n         T![|] if p.at(T![||])  => (3,  T![||]),\n@@ -214,7 +214,7 @@ fn current_op(p: &Parser) -> (u8, SyntaxKind) {\n \n // Parses expression with binding power of at least bp.\n fn expr_bp(\n-    p: &mut Parser,\n+    p: &mut Parser<'_>,\n     m: Option<Marker>,\n     mut r: Restrictions,\n     bp: u8,\n@@ -287,7 +287,7 @@ fn expr_bp(\n const LHS_FIRST: TokenSet =\n     atom::ATOM_EXPR_FIRST.union(TokenSet::new(&[T![&], T![*], T![!], T![.], T![-]]));\n \n-fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)> {\n+fn lhs(p: &mut Parser<'_>, r: Restrictions) -> Option<(CompletedMarker, BlockLike)> {\n     let m;\n     let kind = match p.current() {\n         // test ref_expr\n@@ -356,7 +356,7 @@ fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)>\n }\n \n fn postfix_expr(\n-    p: &mut Parser,\n+    p: &mut Parser<'_>,\n     mut lhs: CompletedMarker,\n     // Calls are disallowed if the type is a block and we prefer statements because the call cannot be disambiguated from a tuple\n     // E.g. `while true {break}();` is parsed as\n@@ -392,7 +392,7 @@ fn postfix_expr(\n     return (lhs, block_like);\n \n     fn postfix_dot_expr(\n-        p: &mut Parser,\n+        p: &mut Parser<'_>,\n         lhs: CompletedMarker,\n     ) -> Result<CompletedMarker, CompletedMarker> {\n         assert!(p.at(T![.]));\n@@ -428,7 +428,7 @@ fn postfix_expr(\n //     let _ = f(<Foo>::func());\n //     f(<Foo as Trait>::func());\n // }\n-fn call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n+fn call_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T!['(']));\n     let m = lhs.precede(p);\n     arg_list(p);\n@@ -439,7 +439,7 @@ fn call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n // fn foo() {\n //     x[1][2];\n // }\n-fn index_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n+fn index_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T!['[']));\n     let m = lhs.precede(p);\n     p.bump(T!['[']);\n@@ -453,7 +453,7 @@ fn index_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     x.foo();\n //     y.bar::<T>(1, 2,);\n // }\n-fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n+fn method_call_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![.]) && p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth_at(2, T![::])));\n     let m = lhs.precede(p);\n     p.bump_any();\n@@ -471,7 +471,7 @@ fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     x.0.bar;\n //     x.0();\n // }\n-fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n+fn field_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![.]));\n     let m = lhs.precede(p);\n     p.bump(T![.]);\n@@ -490,7 +490,7 @@ fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n // fn foo() {\n //     x?;\n // }\n-fn try_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n+fn try_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![?]));\n     let m = lhs.precede(p);\n     p.bump(T![?]);\n@@ -504,7 +504,7 @@ fn try_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     79 as i16 - 1;\n //     0x36 as u8 <= 0x37;\n // }\n-fn cast_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n+fn cast_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![as]));\n     let m = lhs.precede(p);\n     p.bump(T![as]);\n@@ -514,7 +514,7 @@ fn cast_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     m.complete(p, CAST_EXPR)\n }\n \n-fn arg_list(p: &mut Parser) {\n+fn arg_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n     p.bump(T!['(']);\n@@ -541,7 +541,7 @@ fn arg_list(p: &mut Parser) {\n //     let _ = ::a::<b>;\n //     let _ = format!();\n // }\n-fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n+fn path_expr(p: &mut Parser<'_>, r: Restrictions) -> (CompletedMarker, BlockLike) {\n     assert!(paths::is_path_start(p));\n     let m = p.start();\n     paths::expr_path(p);\n@@ -565,7 +565,7 @@ fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n //     S { x, y: 32, ..Default::default() };\n //     TupleStruct { 0: 1 };\n // }\n-pub(crate) fn record_expr_field_list(p: &mut Parser) {\n+pub(crate) fn record_expr_field_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);"}, {"sha": "30aadb1f9d65569c1baf21b9d0d29d67cbf860e0", "filename": "crates/parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -24,7 +24,7 @@ pub(crate) const LITERAL_FIRST: TokenSet = TokenSet::new(&[\n     BYTE_STRING,\n ]);\n \n-pub(crate) fn literal(p: &mut Parser) -> Option<CompletedMarker> {\n+pub(crate) fn literal(p: &mut Parser<'_>) -> Option<CompletedMarker> {\n     if !p.at_ts(LITERAL_FIRST) {\n         return None;\n     }\n@@ -60,7 +60,7 @@ pub(super) const ATOM_EXPR_FIRST: TokenSet =\n \n const EXPR_RECOVERY_SET: TokenSet = TokenSet::new(&[T![let]]);\n \n-pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)> {\n+pub(super) fn atom_expr(p: &mut Parser<'_>, r: Restrictions) -> Option<(CompletedMarker, BlockLike)> {\n     if let Some(m) = literal(p) {\n         return Some((m, BlockLike::NotBlock));\n     }\n@@ -169,7 +169,7 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n //     (1);\n //     (1,);\n // }\n-fn tuple_expr(p: &mut Parser) -> CompletedMarker {\n+fn tuple_expr(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n     p.expect(T!['(']);\n@@ -201,7 +201,7 @@ fn tuple_expr(p: &mut Parser) -> CompletedMarker {\n //     [1, 2,];\n //     [1; 2];\n // }\n-fn array_expr(p: &mut Parser) -> CompletedMarker {\n+fn array_expr(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T!['[']));\n     let m = p.start();\n \n@@ -248,7 +248,7 @@ fn array_expr(p: &mut Parser) -> CompletedMarker {\n //     for<'a> || {};\n //     for<'a> move || {};\n // }\n-fn closure_expr(p: &mut Parser) -> CompletedMarker {\n+fn closure_expr(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(match p.current() {\n         T![static] | T![async] | T![move] | T![|] => true,\n         T![for] => p.nth(1) == T![<],\n@@ -290,7 +290,7 @@ fn closure_expr(p: &mut Parser) -> CompletedMarker {\n //     if S {};\n //     if { true } { } else { };\n // }\n-fn if_expr(p: &mut Parser) -> CompletedMarker {\n+fn if_expr(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T![if]));\n     let m = p.start();\n     p.bump(T![if]);\n@@ -313,7 +313,7 @@ fn if_expr(p: &mut Parser) -> CompletedMarker {\n //     'b: while true {}\n //     'c: for x in () {}\n // }\n-fn label(p: &mut Parser) {\n+fn label(p: &mut Parser<'_>) {\n     assert!(p.at(LIFETIME_IDENT) && p.nth(1) == T![:]);\n     let m = p.start();\n     lifetime(p);\n@@ -325,7 +325,7 @@ fn label(p: &mut Parser) {\n // fn foo() {\n //     loop {};\n // }\n-fn loop_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n+fn loop_expr(p: &mut Parser<'_>, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![loop]));\n     let m = m.unwrap_or_else(|| p.start());\n     p.bump(T![loop]);\n@@ -339,7 +339,7 @@ fn loop_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n //     while let Some(x) = it.next() {};\n //     while { true } {};\n // }\n-fn while_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n+fn while_expr(p: &mut Parser<'_>, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![while]));\n     let m = m.unwrap_or_else(|| p.start());\n     p.bump(T![while]);\n@@ -352,7 +352,7 @@ fn while_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n // fn foo() {\n //     for x in [] {};\n // }\n-fn for_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n+fn for_expr(p: &mut Parser<'_>, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![for]));\n     let m = m.unwrap_or_else(|| p.start());\n     p.bump(T![for]);\n@@ -368,7 +368,7 @@ fn for_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n //     if let Some(_) = None && true {}\n //     while 1 == 5 && (let None = None) {}\n // }\n-fn let_expr(p: &mut Parser) -> CompletedMarker {\n+fn let_expr(p: &mut Parser<'_>) -> CompletedMarker {\n     let m = p.start();\n     p.bump(T![let]);\n     patterns::pattern_top(p);\n@@ -384,7 +384,7 @@ fn let_expr(p: &mut Parser) -> CompletedMarker {\n //     match { } { _ => () };\n //     match { S {} } {};\n // }\n-fn match_expr(p: &mut Parser) -> CompletedMarker {\n+fn match_expr(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T![match]));\n     let m = p.start();\n     p.bump(T![match]);\n@@ -397,7 +397,7 @@ fn match_expr(p: &mut Parser) -> CompletedMarker {\n     m.complete(p, MATCH_EXPR)\n }\n \n-pub(crate) fn match_arm_list(p: &mut Parser) {\n+pub(crate) fn match_arm_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.eat(T!['{']);\n@@ -434,7 +434,7 @@ pub(crate) fn match_arm_list(p: &mut Parser) {\n //         | X => (),\n //     };\n // }\n-fn match_arm(p: &mut Parser) {\n+fn match_arm(p: &mut Parser<'_>) {\n     let m = p.start();\n     // test match_arms_outer_attributes\n     // fn foo() {\n@@ -482,7 +482,7 @@ fn match_arm(p: &mut Parser) {\n //         _ if let foo = bar => (),\n //     }\n // }\n-fn match_guard(p: &mut Parser) -> CompletedMarker {\n+fn match_guard(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T![if]));\n     let m = p.start();\n     p.bump(T![if]);\n@@ -495,7 +495,7 @@ fn match_guard(p: &mut Parser) -> CompletedMarker {\n // fn b() { let _ = 1; }\n // fn c() { 1; 2; }\n // fn d() { 1; 2 }\n-pub(crate) fn block_expr(p: &mut Parser) {\n+pub(crate) fn block_expr(p: &mut Parser<'_>) {\n     if !p.at(T!['{']) {\n         p.error(\"expected a block\");\n         return;\n@@ -505,7 +505,7 @@ pub(crate) fn block_expr(p: &mut Parser) {\n     m.complete(p, BLOCK_EXPR);\n }\n \n-fn stmt_list(p: &mut Parser) -> CompletedMarker {\n+fn stmt_list(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -519,7 +519,7 @@ fn stmt_list(p: &mut Parser) -> CompletedMarker {\n //     return;\n //     return 92;\n // }\n-fn return_expr(p: &mut Parser) -> CompletedMarker {\n+fn return_expr(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T![return]));\n     let m = p.start();\n     p.bump(T![return]);\n@@ -533,7 +533,7 @@ fn return_expr(p: &mut Parser) -> CompletedMarker {\n //     yield;\n //     yield 1;\n // }\n-fn yield_expr(p: &mut Parser) -> CompletedMarker {\n+fn yield_expr(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T![yield]));\n     let m = p.start();\n     p.bump(T![yield]);\n@@ -550,7 +550,7 @@ fn yield_expr(p: &mut Parser) -> CompletedMarker {\n //         continue 'l;\n //     }\n // }\n-fn continue_expr(p: &mut Parser) -> CompletedMarker {\n+fn continue_expr(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T![continue]));\n     let m = p.start();\n     p.bump(T![continue]);\n@@ -569,7 +569,7 @@ fn continue_expr(p: &mut Parser) -> CompletedMarker {\n //         break 'l 92;\n //     }\n // }\n-fn break_expr(p: &mut Parser, r: Restrictions) -> CompletedMarker {\n+fn break_expr(p: &mut Parser<'_>, r: Restrictions) -> CompletedMarker {\n     assert!(p.at(T![break]));\n     let m = p.start();\n     p.bump(T![break]);\n@@ -593,7 +593,7 @@ fn break_expr(p: &mut Parser, r: Restrictions) -> CompletedMarker {\n // fn foo() {\n //     let _ = try {};\n // }\n-fn try_block_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n+fn try_block_expr(p: &mut Parser<'_>, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![try]));\n     let m = m.unwrap_or_else(|| p.start());\n     // Special-case `try!` as macro.\n@@ -629,7 +629,7 @@ fn try_block_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n //     let y = (box 1i32, box 2i32);\n //     let z = Foo(box 1i32, box 2i32);\n // }\n-fn box_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n+fn box_expr(p: &mut Parser<'_>, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![box]));\n     let m = m.unwrap_or_else(|| p.start());\n     p.bump(T![box]);"}, {"sha": "c438943a0026274537d5dee684b3e38f4843f46f", "filename": "crates/parser/src/grammar/generic_args.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -1,6 +1,6 @@\n use super::*;\n \n-pub(super) fn opt_generic_arg_list(p: &mut Parser, colon_colon_required: bool) {\n+pub(super) fn opt_generic_arg_list(p: &mut Parser<'_>, colon_colon_required: bool) {\n     let m;\n     if p.at(T![::]) && p.nth(2) == T![<] {\n         m = p.start();\n@@ -25,7 +25,7 @@ pub(super) fn opt_generic_arg_list(p: &mut Parser, colon_colon_required: bool) {\n \n // test generic_arg\n // type T = S<i32>;\n-fn generic_arg(p: &mut Parser) {\n+fn generic_arg(p: &mut Parser<'_>) {\n     match p.current() {\n         LIFETIME_IDENT => lifetime_arg(p),\n         T!['{'] | T![true] | T![false] | T![-] => const_arg(p),\n@@ -74,13 +74,13 @@ fn generic_arg(p: &mut Parser) {\n \n // test lifetime_arg\n // type T = S<'static>;\n-fn lifetime_arg(p: &mut Parser) {\n+fn lifetime_arg(p: &mut Parser<'_>) {\n     let m = p.start();\n     lifetime(p);\n     m.complete(p, LIFETIME_ARG);\n }\n \n-pub(super) fn const_arg_expr(p: &mut Parser) {\n+pub(super) fn const_arg_expr(p: &mut Parser<'_>) {\n     // The tests in here are really for `const_arg`, which wraps the content\n     // CONST_ARG.\n     match p.current() {\n@@ -118,13 +118,13 @@ pub(super) fn const_arg_expr(p: &mut Parser) {\n \n // test const_arg\n // type T = S<92>;\n-pub(super) fn const_arg(p: &mut Parser) {\n+pub(super) fn const_arg(p: &mut Parser<'_>) {\n     let m = p.start();\n     const_arg_expr(p);\n     m.complete(p, CONST_ARG);\n }\n \n-fn type_arg(p: &mut Parser) {\n+fn type_arg(p: &mut Parser<'_>) {\n     let m = p.start();\n     types::type_(p);\n     m.complete(p, TYPE_ARG);"}, {"sha": "6db28ef13239c5f27bad56c73842b509ac44a93f", "filename": "crates/parser/src/grammar/generic_params.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -1,14 +1,14 @@\n use super::*;\n \n-pub(super) fn opt_generic_param_list(p: &mut Parser) {\n+pub(super) fn opt_generic_param_list(p: &mut Parser<'_>) {\n     if p.at(T![<]) {\n         generic_param_list(p);\n     }\n }\n \n // test generic_param_list\n // fn f<T: Clone>() {}\n-fn generic_param_list(p: &mut Parser) {\n+fn generic_param_list(p: &mut Parser<'_>) {\n     assert!(p.at(T![<]));\n     let m = p.start();\n     p.bump(T![<]);\n@@ -23,7 +23,7 @@ fn generic_param_list(p: &mut Parser) {\n     m.complete(p, GENERIC_PARAM_LIST);\n }\n \n-fn generic_param(p: &mut Parser) {\n+fn generic_param(p: &mut Parser<'_>) {\n     let m = p.start();\n     // test generic_param_attribute\n     // fn foo<#[lt_attr] 'a, #[t_attr] T>() {}\n@@ -41,7 +41,7 @@ fn generic_param(p: &mut Parser) {\n \n // test lifetime_param\n // fn f<'a: 'b>() {}\n-fn lifetime_param(p: &mut Parser, m: Marker) {\n+fn lifetime_param(p: &mut Parser<'_>, m: Marker) {\n     assert!(p.at(LIFETIME_IDENT));\n     lifetime(p);\n     if p.at(T![:]) {\n@@ -52,7 +52,7 @@ fn lifetime_param(p: &mut Parser, m: Marker) {\n \n // test type_param\n // fn f<T: Clone>() {}\n-fn type_param(p: &mut Parser, m: Marker) {\n+fn type_param(p: &mut Parser<'_>, m: Marker) {\n     assert!(p.at(IDENT));\n     name(p);\n     if p.at(T![:]) {\n@@ -69,7 +69,7 @@ fn type_param(p: &mut Parser, m: Marker) {\n \n // test const_param\n // struct S<const N: u32>;\n-fn const_param(p: &mut Parser, m: Marker) {\n+fn const_param(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![const]);\n     name(p);\n     if p.at(T![:]) {\n@@ -94,7 +94,7 @@ fn const_param(p: &mut Parser, m: Marker) {\n     m.complete(p, CONST_PARAM);\n }\n \n-fn lifetime_bounds(p: &mut Parser) {\n+fn lifetime_bounds(p: &mut Parser<'_>) {\n     assert!(p.at(T![:]));\n     p.bump(T![:]);\n     while p.at(LIFETIME_IDENT) {\n@@ -107,18 +107,18 @@ fn lifetime_bounds(p: &mut Parser) {\n \n // test type_param_bounds\n // struct S<T: 'a + ?Sized + (Copy) + ~const Drop>;\n-pub(super) fn bounds(p: &mut Parser) {\n+pub(super) fn bounds(p: &mut Parser<'_>) {\n     assert!(p.at(T![:]));\n     p.bump(T![:]);\n     bounds_without_colon(p);\n }\n \n-pub(super) fn bounds_without_colon(p: &mut Parser) {\n+pub(super) fn bounds_without_colon(p: &mut Parser<'_>) {\n     let m = p.start();\n     bounds_without_colon_m(p, m);\n }\n \n-pub(super) fn bounds_without_colon_m(p: &mut Parser, marker: Marker) -> CompletedMarker {\n+pub(super) fn bounds_without_colon_m(p: &mut Parser<'_>, marker: Marker) -> CompletedMarker {\n     while type_bound(p) {\n         if !p.eat(T![+]) {\n             break;\n@@ -127,7 +127,7 @@ pub(super) fn bounds_without_colon_m(p: &mut Parser, marker: Marker) -> Complete\n     marker.complete(p, TYPE_BOUND_LIST)\n }\n \n-fn type_bound(p: &mut Parser) -> bool {\n+fn type_bound(p: &mut Parser<'_>) -> bool {\n     let m = p.start();\n     let has_paren = p.eat(T!['(']);\n     match p.current() {\n@@ -172,7 +172,7 @@ fn type_bound(p: &mut Parser) -> bool {\n //    Iterator::Item: 'a,\n //    <T as Iterator>::Item: 'a\n // {}\n-pub(super) fn opt_where_clause(p: &mut Parser) {\n+pub(super) fn opt_where_clause(p: &mut Parser<'_>) {\n     if !p.at(T![where]) {\n         return;\n     }\n@@ -196,7 +196,7 @@ pub(super) fn opt_where_clause(p: &mut Parser) {\n \n     m.complete(p, WHERE_CLAUSE);\n \n-    fn is_where_predicate(p: &mut Parser) -> bool {\n+    fn is_where_predicate(p: &mut Parser<'_>) -> bool {\n         match p.current() {\n             LIFETIME_IDENT => true,\n             T![impl] => false,\n@@ -205,7 +205,7 @@ pub(super) fn opt_where_clause(p: &mut Parser) {\n     }\n }\n \n-fn where_predicate(p: &mut Parser) {\n+fn where_predicate(p: &mut Parser<'_>) {\n     let m = p.start();\n     match p.current() {\n         LIFETIME_IDENT => {"}, {"sha": "5e0951bf8b50a8de204f4b6e6d78e56f18975ecc", "filename": "crates/parser/src/grammar/items.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -17,7 +17,7 @@ use super::*;\n // foo::bar!();\n // super::baz! {}\n // struct S;\n-pub(super) fn mod_contents(p: &mut Parser, stop_on_r_curly: bool) {\n+pub(super) fn mod_contents(p: &mut Parser<'_>, stop_on_r_curly: bool) {\n     attributes::inner_attrs(p);\n     while !p.at(EOF) && !(p.at(T!['}']) && stop_on_r_curly) {\n         item_or_macro(p, stop_on_r_curly);\n@@ -41,7 +41,7 @@ pub(super) const ITEM_RECOVERY_SET: TokenSet = TokenSet::new(&[\n     T![;],\n ]);\n \n-pub(super) fn item_or_macro(p: &mut Parser, stop_on_r_curly: bool) {\n+pub(super) fn item_or_macro(p: &mut Parser<'_>, stop_on_r_curly: bool) {\n     let m = p.start();\n     attributes::outer_attrs(p);\n \n@@ -84,7 +84,7 @@ pub(super) fn item_or_macro(p: &mut Parser, stop_on_r_curly: bool) {\n }\n \n /// Try to parse an item, completing `m` in case of success.\n-pub(super) fn opt_item(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n+pub(super) fn opt_item(p: &mut Parser<'_>, m: Marker) -> Result<(), Marker> {\n     // test_err pub_expr\n     // fn foo() { pub 92; }\n     let has_visibility = opt_visibility(p, false);\n@@ -214,7 +214,7 @@ pub(super) fn opt_item(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n     Ok(())\n }\n \n-fn opt_item_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n+fn opt_item_without_modifiers(p: &mut Parser<'_>, m: Marker) -> Result<(), Marker> {\n     let la = p.nth(1);\n     match p.current() {\n         T![extern] if la == T![crate] => extern_crate(p, m),\n@@ -239,7 +239,7 @@ fn opt_item_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n \n // test extern_crate\n // extern crate foo;\n-fn extern_crate(p: &mut Parser, m: Marker) {\n+fn extern_crate(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![extern]);\n     p.bump(T![crate]);\n \n@@ -262,7 +262,7 @@ fn extern_crate(p: &mut Parser, m: Marker) {\n \n // test mod_item\n // mod a;\n-pub(crate) fn mod_item(p: &mut Parser, m: Marker) {\n+pub(crate) fn mod_item(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![mod]);\n     name(p);\n     if p.at(T!['{']) {\n@@ -277,7 +277,7 @@ pub(crate) fn mod_item(p: &mut Parser, m: Marker) {\n \n // test type_alias\n // type Foo = Bar;\n-fn type_alias(p: &mut Parser, m: Marker) {\n+fn type_alias(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![type]);\n \n     name(p);\n@@ -305,7 +305,7 @@ fn type_alias(p: &mut Parser, m: Marker) {\n     m.complete(p, TYPE_ALIAS);\n }\n \n-pub(crate) fn item_list(p: &mut Parser) {\n+pub(crate) fn item_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -314,7 +314,7 @@ pub(crate) fn item_list(p: &mut Parser) {\n     m.complete(p, ITEM_LIST);\n }\n \n-pub(crate) fn extern_item_list(p: &mut Parser) {\n+pub(crate) fn extern_item_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -323,7 +323,7 @@ pub(crate) fn extern_item_list(p: &mut Parser) {\n     m.complete(p, EXTERN_ITEM_LIST);\n }\n \n-fn macro_rules(p: &mut Parser, m: Marker) {\n+fn macro_rules(p: &mut Parser<'_>, m: Marker) {\n     assert!(p.at_contextual_kw(T![macro_rules]));\n     p.bump_remap(T![macro_rules]);\n     p.expect(T![!]);\n@@ -358,7 +358,7 @@ fn macro_rules(p: &mut Parser, m: Marker) {\n \n // test macro_def\n // macro m($i:ident) {}\n-fn macro_def(p: &mut Parser, m: Marker) {\n+fn macro_def(p: &mut Parser<'_>, m: Marker) {\n     p.expect(T![macro]);\n     name_r(p, ITEM_RECOVERY_SET);\n     if p.at(T!['{']) {\n@@ -382,7 +382,7 @@ fn macro_def(p: &mut Parser, m: Marker) {\n \n // test fn\n // fn foo() {}\n-fn fn_(p: &mut Parser, m: Marker) {\n+fn fn_(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![fn]);\n \n     name_r(p, ITEM_RECOVERY_SET);\n@@ -414,13 +414,13 @@ fn fn_(p: &mut Parser, m: Marker) {\n     m.complete(p, FN);\n }\n \n-fn macro_call(p: &mut Parser) -> BlockLike {\n+fn macro_call(p: &mut Parser<'_>) -> BlockLike {\n     assert!(paths::is_use_path_start(p));\n     paths::use_path(p);\n     macro_call_after_excl(p)\n }\n \n-pub(super) fn macro_call_after_excl(p: &mut Parser) -> BlockLike {\n+pub(super) fn macro_call_after_excl(p: &mut Parser<'_>) -> BlockLike {\n     p.expect(T![!]);\n \n     match p.current() {\n@@ -439,7 +439,7 @@ pub(super) fn macro_call_after_excl(p: &mut Parser) -> BlockLike {\n     }\n }\n \n-pub(crate) fn token_tree(p: &mut Parser) {\n+pub(crate) fn token_tree(p: &mut Parser<'_>) {\n     let closing_paren_kind = match p.current() {\n         T!['{'] => T!['}'],\n         T!['('] => T![')'],"}, {"sha": "e7d30516b9510e4c508d255a3548af7415e651df", "filename": "crates/parser/src/grammar/items/adt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -2,20 +2,20 @@ use super::*;\n \n // test struct_item\n // struct S {}\n-pub(super) fn strukt(p: &mut Parser, m: Marker) {\n+pub(super) fn strukt(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![struct]);\n     struct_or_union(p, m, true);\n }\n \n // test union_item\n // struct U { i: i32, f: f32 }\n-pub(super) fn union(p: &mut Parser, m: Marker) {\n+pub(super) fn union(p: &mut Parser<'_>, m: Marker) {\n     assert!(p.at_contextual_kw(T![union]));\n     p.bump_remap(T![union]);\n     struct_or_union(p, m, false);\n }\n \n-fn struct_or_union(p: &mut Parser, m: Marker, is_struct: bool) {\n+fn struct_or_union(p: &mut Parser<'_>, m: Marker, is_struct: bool) {\n     name_r(p, ITEM_RECOVERY_SET);\n     generic_params::opt_generic_param_list(p);\n     match p.current() {\n@@ -50,7 +50,7 @@ fn struct_or_union(p: &mut Parser, m: Marker, is_struct: bool) {\n     m.complete(p, if is_struct { STRUCT } else { UNION });\n }\n \n-pub(super) fn enum_(p: &mut Parser, m: Marker) {\n+pub(super) fn enum_(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![enum]);\n     name_r(p, ITEM_RECOVERY_SET);\n     generic_params::opt_generic_param_list(p);\n@@ -63,7 +63,7 @@ pub(super) fn enum_(p: &mut Parser, m: Marker) {\n     m.complete(p, ENUM);\n }\n \n-pub(crate) fn variant_list(p: &mut Parser) {\n+pub(crate) fn variant_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -80,7 +80,7 @@ pub(crate) fn variant_list(p: &mut Parser) {\n     p.expect(T!['}']);\n     m.complete(p, VARIANT_LIST);\n \n-    fn variant(p: &mut Parser) {\n+    fn variant(p: &mut Parser<'_>) {\n         let m = p.start();\n         attributes::outer_attrs(p);\n         if p.at(IDENT) {\n@@ -106,7 +106,7 @@ pub(crate) fn variant_list(p: &mut Parser) {\n \n // test record_field_list\n // struct S { a: i32, b: f32 }\n-pub(crate) fn record_field_list(p: &mut Parser) {\n+pub(crate) fn record_field_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -123,7 +123,7 @@ pub(crate) fn record_field_list(p: &mut Parser) {\n     p.expect(T!['}']);\n     m.complete(p, RECORD_FIELD_LIST);\n \n-    fn record_field(p: &mut Parser) {\n+    fn record_field(p: &mut Parser<'_>) {\n         let m = p.start();\n         // test record_field_attrs\n         // struct S { #[attr] f: f32 }\n@@ -141,7 +141,7 @@ pub(crate) fn record_field_list(p: &mut Parser) {\n     }\n }\n \n-fn tuple_field_list(p: &mut Parser) {\n+fn tuple_field_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n     p.bump(T!['(']);"}, {"sha": "9549ec9b4005e69e5c0bbe26b25f8faf9a7b8f7f", "filename": "crates/parser/src/grammar/items/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -2,17 +2,17 @@ use super::*;\n \n // test const_item\n // const C: u32 = 92;\n-pub(super) fn konst(p: &mut Parser, m: Marker) {\n+pub(super) fn konst(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![const]);\n     const_or_static(p, m, true);\n }\n \n-pub(super) fn static_(p: &mut Parser, m: Marker) {\n+pub(super) fn static_(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![static]);\n     const_or_static(p, m, false);\n }\n \n-fn const_or_static(p: &mut Parser, m: Marker, is_const: bool) {\n+fn const_or_static(p: &mut Parser<'_>, m: Marker, is_const: bool) {\n     p.eat(T![mut]);\n \n     if is_const && p.eat(T![_]) {"}, {"sha": "c982e2d564c90839a3b3c56c507df73a2aced425", "filename": "crates/parser/src/grammar/items/traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n // test trait_item\n // trait T { fn new() -> Self; }\n-pub(super) fn trait_(p: &mut Parser, m: Marker) {\n+pub(super) fn trait_(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![trait]);\n     name_r(p, ITEM_RECOVERY_SET);\n \n@@ -44,7 +44,7 @@ pub(super) fn trait_(p: &mut Parser, m: Marker) {\n \n // test impl_item\n // impl S {}\n-pub(super) fn impl_(p: &mut Parser, m: Marker) {\n+pub(super) fn impl_(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![impl]);\n     if p.at(T![<]) && not_a_qualified_path(p) {\n         generic_params::opt_generic_param_list(p);\n@@ -80,7 +80,7 @@ pub(super) fn impl_(p: &mut Parser, m: Marker) {\n //     fn foo() {}\n //     fn bar(&self) {}\n // }\n-pub(crate) fn assoc_item_list(p: &mut Parser) {\n+pub(crate) fn assoc_item_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['{']));\n \n     let m = p.start();\n@@ -102,7 +102,7 @@ pub(crate) fn assoc_item_list(p: &mut Parser) {\n \n // test impl_type_params\n // impl<const N: u32> Bar<N> {}\n-fn not_a_qualified_path(p: &Parser) -> bool {\n+fn not_a_qualified_path(p: &Parser<'_>) -> bool {\n     // There's an ambiguity between generic parameters and qualified paths in impls.\n     // If we see `<` it may start both, so we have to inspect some following tokens.\n     // The following combinations can only start generics,\n@@ -131,7 +131,7 @@ fn not_a_qualified_path(p: &Parser) -> bool {\n // impl Trait1 for T {}\n // impl impl NotType {}\n // impl Trait2 for impl NotType {}\n-pub(crate) fn impl_type(p: &mut Parser) {\n+pub(crate) fn impl_type(p: &mut Parser<'_>) {\n     if p.at(T![impl]) {\n         p.error(\"expected trait or type\");\n         return;"}, {"sha": "69880b7946b6955e7c664c8e0cd4621341ecfbb0", "filename": "crates/parser/src/grammar/items/use_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n // test use_item\n // use std::collections;\n-pub(super) fn use_(p: &mut Parser, m: Marker) {\n+pub(super) fn use_(p: &mut Parser<'_>, m: Marker) {\n     p.bump(T![use]);\n     use_tree(p, true);\n     p.expect(T![;]);\n@@ -11,7 +11,7 @@ pub(super) fn use_(p: &mut Parser, m: Marker) {\n \n // test use_tree\n // use outer::tree::{inner::tree};\n-fn use_tree(p: &mut Parser, top_level: bool) {\n+fn use_tree(p: &mut Parser<'_>, top_level: bool) {\n     let m = p.start();\n     match p.current() {\n         // test use_tree_star\n@@ -78,7 +78,7 @@ fn use_tree(p: &mut Parser, top_level: bool) {\n \n // test use_tree_list\n // use {a, b, c};\n-pub(crate) fn use_tree_list(p: &mut Parser) {\n+pub(crate) fn use_tree_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);"}, {"sha": "20e8e95f0662cfead85aef0e0e753610620d38e8", "filename": "crates/parser/src/grammar/params.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -5,21 +5,21 @@ use super::*;\n // fn b(x: i32) {}\n // fn c(x: i32, ) {}\n // fn d(x: i32, y: ()) {}\n-pub(super) fn param_list_fn_def(p: &mut Parser) {\n+pub(super) fn param_list_fn_def(p: &mut Parser<'_>) {\n     list_(p, Flavor::FnDef);\n }\n \n // test param_list_opt_patterns\n // fn foo<F: FnMut(&mut Foo<'a>)>(){}\n-pub(super) fn param_list_fn_trait(p: &mut Parser) {\n+pub(super) fn param_list_fn_trait(p: &mut Parser<'_>) {\n     list_(p, Flavor::FnTrait);\n }\n \n-pub(super) fn param_list_fn_ptr(p: &mut Parser) {\n+pub(super) fn param_list_fn_ptr(p: &mut Parser<'_>) {\n     list_(p, Flavor::FnPointer);\n }\n \n-pub(super) fn param_list_closure(p: &mut Parser) {\n+pub(super) fn param_list_closure(p: &mut Parser<'_>) {\n     list_(p, Flavor::Closure);\n }\n \n@@ -31,7 +31,7 @@ enum Flavor {\n     Closure,\n }\n \n-fn list_(p: &mut Parser, flavor: Flavor) {\n+fn list_(p: &mut Parser<'_>, flavor: Flavor) {\n     use Flavor::*;\n \n     let (bra, ket) = match flavor {\n@@ -87,7 +87,7 @@ fn list_(p: &mut Parser, flavor: Flavor) {\n \n const PARAM_FIRST: TokenSet = patterns::PATTERN_FIRST.union(types::TYPE_FIRST);\n \n-fn param(p: &mut Parser, m: Marker, flavor: Flavor) {\n+fn param(p: &mut Parser<'_>, m: Marker, flavor: Flavor) {\n     match flavor {\n         // test param_list_vararg\n         // extern \"C\" { fn printf(format: *const i8, ..., _: u8) -> i32; }\n@@ -146,7 +146,7 @@ fn param(p: &mut Parser, m: Marker, flavor: Flavor) {\n     m.complete(p, PARAM);\n }\n \n-fn variadic_param(p: &mut Parser) -> bool {\n+fn variadic_param(p: &mut Parser<'_>) -> bool {\n     if p.at(T![:]) && p.nth_at(1, T![...]) {\n         p.bump(T![:]);\n         p.bump(T![...]);\n@@ -164,7 +164,7 @@ fn variadic_param(p: &mut Parser) -> bool {\n //     fn d(&'a mut self, x: i32) {}\n //     fn e(mut self) {}\n // }\n-fn opt_self_param(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n+fn opt_self_param(p: &mut Parser<'_>, m: Marker) -> Result<(), Marker> {\n     if p.at(T![self]) || p.at(T![mut]) && p.nth(1) == T![self] {\n         p.eat(T![mut]);\n         self_as_name(p);\n@@ -202,7 +202,7 @@ fn opt_self_param(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n     Ok(())\n }\n \n-fn self_as_name(p: &mut Parser) {\n+fn self_as_name(p: &mut Parser<'_>) {\n     let m = p.start();\n     p.bump(T![self]);\n     m.complete(p, NAME);"}, {"sha": "22c7f003f41e5fcad5f4fe05b0ad3df1a118e454", "filename": "crates/parser/src/grammar/paths.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -3,31 +3,31 @@ use super::*;\n pub(super) const PATH_FIRST: TokenSet =\n     TokenSet::new(&[IDENT, T![self], T![super], T![crate], T![Self], T![:], T![<]]);\n \n-pub(super) fn is_path_start(p: &Parser) -> bool {\n+pub(super) fn is_path_start(p: &Parser<'_>) -> bool {\n     is_use_path_start(p) || p.at(T![<]) || p.at(T![Self])\n }\n \n-pub(super) fn is_use_path_start(p: &Parser) -> bool {\n+pub(super) fn is_use_path_start(p: &Parser<'_>) -> bool {\n     match p.current() {\n         IDENT | T![self] | T![super] | T![crate] => true,\n         T![:] if p.at(T![::]) => true,\n         _ => false,\n     }\n }\n \n-pub(super) fn use_path(p: &mut Parser) {\n+pub(super) fn use_path(p: &mut Parser<'_>) {\n     path(p, Mode::Use);\n }\n \n-pub(crate) fn type_path(p: &mut Parser) {\n+pub(crate) fn type_path(p: &mut Parser<'_>) {\n     path(p, Mode::Type);\n }\n \n-pub(super) fn expr_path(p: &mut Parser) {\n+pub(super) fn expr_path(p: &mut Parser<'_>) {\n     path(p, Mode::Expr);\n }\n \n-pub(crate) fn type_path_for_qualifier(p: &mut Parser, qual: CompletedMarker) -> CompletedMarker {\n+pub(crate) fn type_path_for_qualifier(p: &mut Parser<'_>, qual: CompletedMarker) -> CompletedMarker {\n     path_for_qualifier(p, Mode::Type, qual)\n }\n \n@@ -38,14 +38,14 @@ enum Mode {\n     Expr,\n }\n \n-fn path(p: &mut Parser, mode: Mode) {\n+fn path(p: &mut Parser<'_>, mode: Mode) {\n     let path = p.start();\n     path_segment(p, mode, true);\n     let qual = path.complete(p, PATH);\n     path_for_qualifier(p, mode, qual);\n }\n \n-fn path_for_qualifier(p: &mut Parser, mode: Mode, mut qual: CompletedMarker) -> CompletedMarker {\n+fn path_for_qualifier(p: &mut Parser<'_>, mode: Mode, mut qual: CompletedMarker) -> CompletedMarker {\n     loop {\n         let use_tree = matches!(p.nth(2), T![*] | T!['{']);\n         if p.at(T![::]) && !use_tree {\n@@ -60,7 +60,7 @@ fn path_for_qualifier(p: &mut Parser, mode: Mode, mut qual: CompletedMarker) ->\n     }\n }\n \n-fn path_segment(p: &mut Parser, mode: Mode, first: bool) {\n+fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) {\n     let m = p.start();\n     // test qual_paths\n     // type X = <A as B>::Output;\n@@ -107,7 +107,7 @@ fn path_segment(p: &mut Parser, mode: Mode, first: bool) {\n     m.complete(p, PATH_SEGMENT);\n }\n \n-fn opt_path_type_args(p: &mut Parser, mode: Mode) {\n+fn opt_path_type_args(p: &mut Parser<'_>, mode: Mode) {\n     match mode {\n         Mode::Use => {}\n         Mode::Type => {"}, {"sha": "4cbf1030614977af5e9cb5b39a93d92c528af94d", "filename": "crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -13,22 +13,22 @@ pub(super) const PATTERN_FIRST: TokenSet =\n         T![.],\n     ]));\n \n-pub(crate) fn pattern(p: &mut Parser) {\n+pub(crate) fn pattern(p: &mut Parser<'_>) {\n     pattern_r(p, PAT_RECOVERY_SET);\n }\n \n /// Parses a pattern list separated by pipes `|`.\n-pub(super) fn pattern_top(p: &mut Parser) {\n+pub(super) fn pattern_top(p: &mut Parser<'_>) {\n     pattern_top_r(p, PAT_RECOVERY_SET);\n }\n \n-pub(crate) fn pattern_single(p: &mut Parser) {\n+pub(crate) fn pattern_single(p: &mut Parser<'_>) {\n     pattern_single_r(p, PAT_RECOVERY_SET);\n }\n \n /// Parses a pattern list separated by pipes `|`\n /// using the given `recovery_set`.\n-pub(super) fn pattern_top_r(p: &mut Parser, recovery_set: TokenSet) {\n+pub(super) fn pattern_top_r(p: &mut Parser<'_>, recovery_set: TokenSet) {\n     p.eat(T![|]);\n     pattern_r(p, recovery_set);\n }\n@@ -45,7 +45,7 @@ pub(super) fn pattern_top_r(p: &mut Parser, recovery_set: TokenSet) {\n //         [_ | _,] => (),\n //     }\n // }\n-fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n+fn pattern_r(p: &mut Parser<'_>, recovery_set: TokenSet) {\n     let m = p.start();\n     pattern_single_r(p, recovery_set);\n \n@@ -59,7 +59,7 @@ fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n     m.complete(p, OR_PAT);\n }\n \n-fn pattern_single_r(p: &mut Parser, recovery_set: TokenSet) {\n+fn pattern_single_r(p: &mut Parser<'_>, recovery_set: TokenSet) {\n     if let Some(lhs) = atom_pat(p, recovery_set) {\n         // test range_pat\n         // fn main() {\n@@ -106,7 +106,7 @@ fn pattern_single_r(p: &mut Parser, recovery_set: TokenSet) {\n const PAT_RECOVERY_SET: TokenSet =\n     TokenSet::new(&[T![let], T![if], T![while], T![loop], T![match], T![')'], T![,], T![=]]);\n \n-fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n+fn atom_pat(p: &mut Parser<'_>, recovery_set: TokenSet) -> Option<CompletedMarker> {\n     let m = match p.current() {\n         T![box] => box_pat(p),\n         T![ref] | T![mut] => ident_pat(p, true),\n@@ -139,7 +139,7 @@ fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n     Some(m)\n }\n \n-fn is_literal_pat_start(p: &Parser) -> bool {\n+fn is_literal_pat_start(p: &Parser<'_>) -> bool {\n     p.at(T![-]) && (p.nth(1) == INT_NUMBER || p.nth(1) == FLOAT_NUMBER)\n         || p.at_ts(expressions::LITERAL_FIRST)\n }\n@@ -153,7 +153,7 @@ fn is_literal_pat_start(p: &Parser) -> bool {\n //         \"hello\" => (),\n //     }\n // }\n-fn literal_pat(p: &mut Parser) -> CompletedMarker {\n+fn literal_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(is_literal_pat_start(p));\n     let m = p.start();\n     if p.at(T![-]) {\n@@ -170,7 +170,7 @@ fn literal_pat(p: &mut Parser) -> CompletedMarker {\n //     let Bar { .. } = ();\n //     let Bar(..) = ();\n // }\n-fn path_or_macro_pat(p: &mut Parser) -> CompletedMarker {\n+fn path_or_macro_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(paths::is_path_start(p));\n     let m = p.start();\n     paths::expr_path(p);\n@@ -203,7 +203,7 @@ fn path_or_macro_pat(p: &mut Parser) -> CompletedMarker {\n //     let S(_,) = ();\n //     let S(_, .. , x) = ();\n // }\n-fn tuple_pat_fields(p: &mut Parser) {\n+fn tuple_pat_fields(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n     p.bump(T!['(']);\n     pat_list(p, T![')']);\n@@ -216,7 +216,7 @@ fn tuple_pat_fields(p: &mut Parser) {\n //     let S { x: 1 } = ();\n //     let S { #[cfg(any())] x: 1 } = ();\n // }\n-fn record_pat_field(p: &mut Parser) {\n+fn record_pat_field(p: &mut Parser<'_>) {\n     match p.current() {\n         IDENT | INT_NUMBER if p.nth(1) == T![:] => {\n             name_ref_or_index(p);\n@@ -244,7 +244,7 @@ fn record_pat_field(p: &mut Parser) {\n //     let S { h: _, } = ();\n //     let S { #[cfg(any())] .. } = ();\n // }\n-fn record_pat_field_list(p: &mut Parser) {\n+fn record_pat_field_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -277,7 +277,7 @@ fn record_pat_field_list(p: &mut Parser) {\n \n // test placeholder_pat\n // fn main() { let _ = (); }\n-fn wildcard_pat(p: &mut Parser) -> CompletedMarker {\n+fn wildcard_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T![_]));\n     let m = p.start();\n     p.bump(T![_]);\n@@ -310,7 +310,7 @@ fn wildcard_pat(p: &mut Parser) -> CompletedMarker {\n //     let [head, .., mid, tail @ ..] = ();\n //     let [head, .., mid, .., cons] = ();\n // }\n-fn rest_pat(p: &mut Parser) -> CompletedMarker {\n+fn rest_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T![..]));\n     let m = p.start();\n     p.bump(T![..]);\n@@ -322,7 +322,7 @@ fn rest_pat(p: &mut Parser) -> CompletedMarker {\n //     let &a = ();\n //     let &mut b = ();\n // }\n-fn ref_pat(p: &mut Parser) -> CompletedMarker {\n+fn ref_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T![&]));\n     let m = p.start();\n     p.bump(T![&]);\n@@ -338,7 +338,7 @@ fn ref_pat(p: &mut Parser) -> CompletedMarker {\n //     let (..) = ();\n //     let () = ();\n // }\n-fn tuple_pat(p: &mut Parser) -> CompletedMarker {\n+fn tuple_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n     p.bump(T!['(']);\n@@ -368,7 +368,7 @@ fn tuple_pat(p: &mut Parser) -> CompletedMarker {\n // fn main() {\n //     let [a, b, ..] = [];\n // }\n-fn slice_pat(p: &mut Parser) -> CompletedMarker {\n+fn slice_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T!['[']));\n     let m = p.start();\n     p.bump(T!['[']);\n@@ -377,7 +377,7 @@ fn slice_pat(p: &mut Parser) -> CompletedMarker {\n     m.complete(p, SLICE_PAT)\n }\n \n-fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n+fn pat_list(p: &mut Parser<'_>, ket: SyntaxKind) {\n     while !p.at(EOF) && !p.at(ket) {\n         if !p.at_ts(PATTERN_FIRST) {\n             p.error(\"expected a pattern\");\n@@ -400,7 +400,7 @@ fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n //     let e @ _ = ();\n //     let ref mut f @ g @ _ = ();\n // }\n-fn ident_pat(p: &mut Parser, with_at: bool) -> CompletedMarker {\n+fn ident_pat(p: &mut Parser<'_>, with_at: bool) -> CompletedMarker {\n     assert!(matches!(p.current(), T![ref] | T![mut] | IDENT));\n     let m = p.start();\n     p.eat(T![ref]);\n@@ -418,7 +418,7 @@ fn ident_pat(p: &mut Parser, with_at: bool) -> CompletedMarker {\n //     let box Outer { box i, j: box Inner(box &x) } = ();\n //     let box ref mut i = ();\n // }\n-fn box_pat(p: &mut Parser) -> CompletedMarker {\n+fn box_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T![box]));\n     let m = p.start();\n     p.bump(T![box]);\n@@ -431,7 +431,7 @@ fn box_pat(p: &mut Parser) -> CompletedMarker {\n //     let const { 15 } = ();\n //     let const { foo(); bar() } = ();\n // }\n-fn const_block_pat(p: &mut Parser) -> CompletedMarker {\n+fn const_block_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T![const]));\n     let m = p.start();\n     p.bump(T![const]);"}, {"sha": "5c6e18fee8bffdde54ce186ac0004d428ed5a697", "filename": "crates/parser/src/grammar/types.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -25,15 +25,15 @@ const TYPE_RECOVERY_SET: TokenSet = TokenSet::new(&[\n     T![pub],\n ]);\n \n-pub(crate) fn type_(p: &mut Parser) {\n+pub(crate) fn type_(p: &mut Parser<'_>) {\n     type_with_bounds_cond(p, true);\n }\n \n-pub(super) fn type_no_bounds(p: &mut Parser) {\n+pub(super) fn type_no_bounds(p: &mut Parser<'_>) {\n     type_with_bounds_cond(p, false);\n }\n \n-fn type_with_bounds_cond(p: &mut Parser, allow_bounds: bool) {\n+fn type_with_bounds_cond(p: &mut Parser<'_>, allow_bounds: bool) {\n     match p.current() {\n         T!['('] => paren_or_tuple_type(p),\n         T![!] => never_type(p),\n@@ -54,7 +54,7 @@ fn type_with_bounds_cond(p: &mut Parser, allow_bounds: bool) {\n     }\n }\n \n-pub(super) fn ascription(p: &mut Parser) {\n+pub(super) fn ascription(p: &mut Parser<'_>) {\n     assert!(p.at(T![:]));\n     p.bump(T![:]);\n     if p.at(T![=]) {\n@@ -66,7 +66,7 @@ pub(super) fn ascription(p: &mut Parser) {\n     type_(p);\n }\n \n-fn paren_or_tuple_type(p: &mut Parser) {\n+fn paren_or_tuple_type(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n     p.bump(T!['(']);\n@@ -101,14 +101,14 @@ fn paren_or_tuple_type(p: &mut Parser) {\n \n // test never_type\n // type Never = !;\n-fn never_type(p: &mut Parser) {\n+fn never_type(p: &mut Parser<'_>) {\n     assert!(p.at(T![!]));\n     let m = p.start();\n     p.bump(T![!]);\n     m.complete(p, NEVER_TYPE);\n }\n \n-fn ptr_type(p: &mut Parser) {\n+fn ptr_type(p: &mut Parser<'_>) {\n     assert!(p.at(T![*]));\n     let m = p.start();\n     p.bump(T![*]);\n@@ -132,7 +132,7 @@ fn ptr_type(p: &mut Parser) {\n     m.complete(p, PTR_TYPE);\n }\n \n-fn array_or_slice_type(p: &mut Parser) {\n+fn array_or_slice_type(p: &mut Parser<'_>) {\n     assert!(p.at(T!['[']));\n     let m = p.start();\n     p.bump(T!['[']);\n@@ -168,7 +168,7 @@ fn array_or_slice_type(p: &mut Parser) {\n // type A = &();\n // type B = &'static ();\n // type C = &mut ();\n-fn ref_type(p: &mut Parser) {\n+fn ref_type(p: &mut Parser<'_>) {\n     assert!(p.at(T![&]));\n     let m = p.start();\n     p.bump(T![&]);\n@@ -182,7 +182,7 @@ fn ref_type(p: &mut Parser) {\n \n // test placeholder_type\n // type Placeholder = _;\n-fn infer_type(p: &mut Parser) {\n+fn infer_type(p: &mut Parser<'_>) {\n     assert!(p.at(T![_]));\n     let m = p.start();\n     p.bump(T![_]);\n@@ -194,7 +194,7 @@ fn infer_type(p: &mut Parser) {\n // type B = unsafe fn();\n // type C = unsafe extern \"C\" fn();\n // type D = extern \"C\" fn ( u8 , ... ) -> u8;\n-fn fn_ptr_type(p: &mut Parser) {\n+fn fn_ptr_type(p: &mut Parser<'_>) {\n     let m = p.start();\n     p.eat(T![unsafe]);\n     if p.at(T![extern]) {\n@@ -218,7 +218,7 @@ fn fn_ptr_type(p: &mut Parser) {\n     m.complete(p, FN_PTR_TYPE);\n }\n \n-pub(super) fn for_binder(p: &mut Parser) {\n+pub(super) fn for_binder(p: &mut Parser<'_>) {\n     assert!(p.at(T![for]));\n     p.bump(T![for]);\n     if p.at(T![<]) {\n@@ -232,7 +232,7 @@ pub(super) fn for_binder(p: &mut Parser) {\n // type A = for<'a> fn() -> ();\n // type B = for<'a> unsafe extern \"C\" fn(&'a ()) -> ();\n // type Obj = for<'a> PartialEq<&'a i32>;\n-pub(super) fn for_type(p: &mut Parser, allow_bounds: bool) {\n+pub(super) fn for_type(p: &mut Parser<'_>, allow_bounds: bool) {\n     assert!(p.at(T![for]));\n     let m = p.start();\n     for_binder(p);\n@@ -256,7 +256,7 @@ pub(super) fn for_type(p: &mut Parser, allow_bounds: bool) {\n \n // test impl_trait_type\n // type A = impl Iterator<Item=Foo<'a>> + 'a;\n-fn impl_trait_type(p: &mut Parser) {\n+fn impl_trait_type(p: &mut Parser<'_>) {\n     assert!(p.at(T![impl]));\n     let m = p.start();\n     p.bump(T![impl]);\n@@ -266,7 +266,7 @@ fn impl_trait_type(p: &mut Parser) {\n \n // test dyn_trait_type\n // type A = dyn Iterator<Item=Foo<'a>> + 'a;\n-fn dyn_trait_type(p: &mut Parser) {\n+fn dyn_trait_type(p: &mut Parser<'_>) {\n     assert!(p.at(T![dyn]));\n     let m = p.start();\n     p.bump(T![dyn]);\n@@ -279,14 +279,14 @@ fn dyn_trait_type(p: &mut Parser) {\n // type B = ::Foo;\n // type C = self::Foo;\n // type D = super::Foo;\n-pub(super) fn path_type(p: &mut Parser) {\n+pub(super) fn path_type(p: &mut Parser<'_>) {\n     path_type_(p, true);\n }\n \n // test macro_call_type\n // type A = foo!();\n // type B = crate::foo!();\n-fn path_or_macro_type_(p: &mut Parser, allow_bounds: bool) {\n+fn path_or_macro_type_(p: &mut Parser<'_>, allow_bounds: bool) {\n     assert!(paths::is_path_start(p));\n     let r = p.start();\n     let m = p.start();\n@@ -309,7 +309,7 @@ fn path_or_macro_type_(p: &mut Parser, allow_bounds: bool) {\n     }\n }\n \n-pub(super) fn path_type_(p: &mut Parser, allow_bounds: bool) {\n+pub(super) fn path_type_(p: &mut Parser<'_>, allow_bounds: bool) {\n     assert!(paths::is_path_start(p));\n     let m = p.start();\n     paths::type_path(p);\n@@ -325,7 +325,7 @@ pub(super) fn path_type_(p: &mut Parser, allow_bounds: bool) {\n \n /// This turns a parsed PATH_TYPE or FOR_TYPE optionally into a DYN_TRAIT_TYPE\n /// with a TYPE_BOUND_LIST\n-fn opt_type_bounds_as_dyn_trait_type(p: &mut Parser, type_marker: CompletedMarker) {\n+fn opt_type_bounds_as_dyn_trait_type(p: &mut Parser<'_>, type_marker: CompletedMarker) {\n     assert!(matches!(\n         type_marker.kind(),\n         SyntaxKind::PATH_TYPE | SyntaxKind::FOR_TYPE | SyntaxKind::MACRO_TYPE"}, {"sha": "87be47927735aeb3dfe8f1bc9d0c16812cb447f5", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -79,7 +79,7 @@ pub enum TopEntryPoint {\n \n impl TopEntryPoint {\n     pub fn parse(&self, input: &Input) -> Output {\n-        let entry_point: fn(&'_ mut parser::Parser) = match self {\n+        let entry_point: fn(&'_ mut parser::Parser<'_>) = match self {\n             TopEntryPoint::SourceFile => grammar::entry::top::source_file,\n             TopEntryPoint::MacroStmts => grammar::entry::top::macro_stmts,\n             TopEntryPoint::MacroItems => grammar::entry::top::macro_items,\n@@ -136,7 +136,7 @@ pub enum PrefixEntryPoint {\n \n impl PrefixEntryPoint {\n     pub fn parse(&self, input: &Input) -> Output {\n-        let entry_point: fn(&'_ mut parser::Parser) = match self {\n+        let entry_point: fn(&'_ mut parser::Parser<'_>) = match self {\n             PrefixEntryPoint::Vis => grammar::entry::prefix::vis,\n             PrefixEntryPoint::Block => grammar::entry::prefix::block,\n             PrefixEntryPoint::Stmt => grammar::entry::prefix::stmt,\n@@ -155,7 +155,7 @@ impl PrefixEntryPoint {\n }\n \n /// A parsing function for a specific braced-block.\n-pub struct Reparser(fn(&mut parser::Parser));\n+pub struct Reparser(fn(&mut parser::Parser<'_>));\n \n impl Reparser {\n     /// If the node is a braced block, return the corresponding `Reparser`."}, {"sha": "48d8350e07ee817282ba1f354f3b567563092cd7", "filename": "crates/parser/src/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fparser.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -259,7 +259,7 @@ impl Marker {\n     /// Finishes the syntax tree node and assigns `kind` to it,\n     /// and mark the create a `CompletedMarker` for possible future\n     /// operation like `.precede()` to deal with forward_parent.\n-    pub(crate) fn complete(mut self, p: &mut Parser, kind: SyntaxKind) -> CompletedMarker {\n+    pub(crate) fn complete(mut self, p: &mut Parser<'_>, kind: SyntaxKind) -> CompletedMarker {\n         self.bomb.defuse();\n         let idx = self.pos as usize;\n         match &mut p.events[idx] {\n@@ -274,7 +274,7 @@ impl Marker {\n \n     /// Abandons the syntax tree node. All its children\n     /// are attached to its parent instead.\n-    pub(crate) fn abandon(mut self, p: &mut Parser) {\n+    pub(crate) fn abandon(mut self, p: &mut Parser<'_>) {\n         self.bomb.defuse();\n         let idx = self.pos as usize;\n         if idx == p.events.len() - 1 {\n@@ -309,7 +309,7 @@ impl CompletedMarker {\n     /// Append a new `START` events as `[START, FINISH, NEWSTART]`,\n     /// then mark `NEWSTART` as `START`'s parent with saving its relative\n     /// distance to `NEWSTART` into forward_parent(=2 in this case);\n-    pub(crate) fn precede(self, p: &mut Parser) -> Marker {\n+    pub(crate) fn precede(self, p: &mut Parser<'_>) -> Marker {\n         let new_pos = p.start();\n         let idx = self.pos as usize;\n         match &mut p.events[idx] {\n@@ -322,7 +322,7 @@ impl CompletedMarker {\n     }\n \n     /// Extends this completed marker *to the left* up to `m`.\n-    pub(crate) fn extend_to(self, p: &mut Parser, mut m: Marker) -> CompletedMarker {\n+    pub(crate) fn extend_to(self, p: &mut Parser<'_>, mut m: Marker) -> CompletedMarker {\n         m.bomb.defuse();\n         let idx = m.pos as usize;\n         match &mut p.events[idx] {"}, {"sha": "4b805faddcba9fd4b67f0370dbae10ff8cba85bb", "filename": "crates/parser/src/shortcuts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fshortcuts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fparser%2Fsrc%2Fshortcuts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fshortcuts.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -54,7 +54,7 @@ impl<'a> LexedStr<'a> {\n     pub fn intersperse_trivia(\n         &self,\n         output: &crate::Output,\n-        sink: &mut dyn FnMut(StrStep),\n+        sink: &mut dyn FnMut(StrStep<'_>),\n     ) -> bool {\n         let mut builder = Builder { lexed: self, pos: 0, state: State::PendingEnter, sink };\n "}, {"sha": "41e2e45703d9ae7546e7cb8c960731ece1e3659b", "filename": "crates/proc-macro-srv/src/abis/abi_1_58/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fmod.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -25,7 +25,7 @@ impl From<proc_macro::bridge::PanicMessage> for PanicMessage {\n \n impl Abi {\n     pub unsafe fn from_lib(lib: &Library, symbol_name: String) -> Result<Abi, libloading::Error> {\n-        let macros: libloading::Symbol<&&[proc_macro::bridge::client::ProcMacro]> =\n+        let macros: libloading::Symbol<'_, &&[proc_macro::bridge::client::ProcMacro]> =\n             lib.get(symbol_name.as_bytes())?;\n         Ok(Self { exported_macros: macros.to_vec() })\n     }"}, {"sha": "c253b10994dd61ff736a5c3543c6ecc8a537057f", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -27,7 +27,7 @@ impl From<proc_macro::bridge::PanicMessage> for PanicMessage {\n \n impl Abi {\n     pub unsafe fn from_lib(lib: &Library, symbol_name: String) -> Result<Abi, libloading::Error> {\n-        let macros: libloading::Symbol<&&[proc_macro::bridge::client::ProcMacro]> =\n+        let macros: libloading::Symbol<'_, &&[proc_macro::bridge::client::ProcMacro]> =\n             lib.get(symbol_name.as_bytes())?;\n         Ok(Self { exported_macros: macros.to_vec() })\n     }"}, {"sha": "0ba4bbbef086ec7475cc9fa777a0df7e5c0e9d8a", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fmod.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -27,7 +27,7 @@ impl From<proc_macro::bridge::PanicMessage> for PanicMessage {\n \n impl Abi {\n     pub unsafe fn from_lib(lib: &Library, symbol_name: String) -> Result<Abi, libloading::Error> {\n-        let macros: libloading::Symbol<&&[proc_macro::bridge::client::ProcMacro]> =\n+        let macros: libloading::Symbol<'_, &&[proc_macro::bridge::client::ProcMacro]> =\n             lib.get(symbol_name.as_bytes())?;\n         Ok(Self { exported_macros: macros.to_vec() })\n     }"}, {"sha": "ee882b4cb4c68fa9174cf9bdd56e4c346670b482", "filename": "crates/profile/src/memory_usage.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fprofile%2Fsrc%2Fmemory_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fprofile%2Fsrc%2Fmemory_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fprofile%2Fsrc%2Fmemory_usage.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -11,7 +11,7 @@ pub struct MemoryUsage {\n }\n \n impl fmt::Display for MemoryUsage {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.allocated.fmt(f)\n     }\n }\n@@ -97,7 +97,7 @@ impl Bytes {\n }\n \n impl fmt::Display for Bytes {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let bytes = self.0;\n         let mut value = bytes;\n         let mut suffix = \"b\";"}, {"sha": "0b69f75bc0db0ef87829b7594d28b5e39d6bb242", "filename": "crates/rust-analyzer/src/bin/logger.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -109,7 +109,7 @@ where\n     fn format_event(\n         &self,\n         ctx: &FmtContext<'_, S, N>,\n-        mut writer: Writer,\n+        mut writer: Writer<'_>,\n         event: &Event<'_>,\n     ) -> fmt::Result {\n         // Write level and target"}, {"sha": "4fa88c3c6da11bb1076b9976309c2cb1bd69721f", "filename": "crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -26,7 +26,7 @@ pub(crate) struct Project<'a> {\n }\n \n impl<'a> Project<'a> {\n-    pub(crate) fn with_fixture(fixture: &str) -> Project {\n+    pub(crate) fn with_fixture(fixture: &str) -> Project<'_> {\n         Project {\n             fixture,\n             tmp_dir: None,"}, {"sha": "b143df1f83f2ae3a2aa26dad048cd1fedc5c0492", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -432,7 +432,7 @@ impl NameLike {\n             _ => None,\n         }\n     }\n-    pub fn text(&self) -> TokenText {\n+    pub fn text(&self) -> TokenText<'_> {\n         match self {\n             NameLike::NameRef(name_ref) => name_ref.text(),\n             NameLike::Name(name) => name.text(),"}, {"sha": "dc6130bd6415ca00342e6b53c62e4d9c9b7eed73", "filename": "crates/syntax/src/syntax_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fsyntax%2Fsrc%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fsyntax%2Fsrc%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fsyntax_error.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -38,7 +38,7 @@ impl SyntaxError {\n }\n \n impl fmt::Display for SyntaxError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.0.fmt(f)\n     }\n }"}, {"sha": "cf5be1c30fba2ef47bc3c5891747735c73a76460", "filename": "crates/syntax/src/tests/ast_src.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fsyntax%2Fsrc%2Ftests%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fsyntax%2Fsrc%2Ftests%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftests%2Fast_src.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -9,7 +9,7 @@ pub(crate) struct KindsSrc<'a> {\n     pub(crate) nodes: &'a [&'a str],\n }\n \n-pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n+pub(crate) const KINDS_SRC: KindsSrc<'_> = KindsSrc {\n     punct: &[\n         (\";\", \"SEMICOLON\"),\n         (\",\", \"COMMA\"),"}, {"sha": "913b24d42bcfd042a1ef29505ca7131847229bfd", "filename": "crates/syntax/src/token_text.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fsyntax%2Fsrc%2Ftoken_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Fsyntax%2Fsrc%2Ftoken_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftoken_text.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -42,7 +42,7 @@ impl AsRef<str> for TokenText<'_> {\n }\n \n impl From<TokenText<'_>> for String {\n-    fn from(token_text: TokenText) -> Self {\n+    fn from(token_text: TokenText<'_>) -> Self {\n         token_text.as_str().into()\n     }\n }\n@@ -53,7 +53,7 @@ impl PartialEq<&'_ str> for TokenText<'_> {\n     }\n }\n impl PartialEq<TokenText<'_>> for &'_ str {\n-    fn eq(&self, other: &TokenText) -> bool {\n+    fn eq(&self, other: &TokenText<'_>) -> bool {\n         other == self\n     }\n }\n@@ -63,12 +63,12 @@ impl PartialEq<String> for TokenText<'_> {\n     }\n }\n impl PartialEq<TokenText<'_>> for String {\n-    fn eq(&self, other: &TokenText) -> bool {\n+    fn eq(&self, other: &TokenText<'_>) -> bool {\n         other == self\n     }\n }\n impl PartialEq for TokenText<'_> {\n-    fn eq(&self, other: &TokenText) -> bool {\n+    fn eq(&self, other: &TokenText<'_>) -> bool {\n         self.as_str() == other.as_str()\n     }\n }"}, {"sha": "dedfbd7afef42990fdfba34ddba9a470292ca841", "filename": "crates/test-utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Ftest-utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Ftest-utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Flib.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -407,7 +407,7 @@ pub fn project_root() -> PathBuf {\n     PathBuf::from(dir).parent().unwrap().parent().unwrap().to_owned()\n }\n \n-pub fn format_diff(chunks: Vec<dissimilar::Chunk>) -> String {\n+pub fn format_diff(chunks: Vec<dissimilar::Chunk<'_>>) -> String {\n     let mut buf = String::new();\n     for chunk in chunks {\n         let formatted = match chunk {"}, {"sha": "69226bd4c4805ccf4e4225171999d85e8a32ea4d", "filename": "crates/tt/src/buffer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Ftt%2Fsrc%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Ftt%2Fsrc%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftt%2Fsrc%2Fbuffer.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -109,7 +109,7 @@ impl<'t> TokenBuffer<'t> {\n         Cursor::create(self, EntryPtr(EntryId(0), 0))\n     }\n \n-    fn entry(&self, ptr: &EntryPtr) -> Option<&Entry> {\n+    fn entry(&self, ptr: &EntryPtr) -> Option<&Entry<'_>> {\n         let id = ptr.0;\n         self.buffers[id.0].get(ptr.1)\n     }\n@@ -141,7 +141,7 @@ pub struct Cursor<'a> {\n }\n \n impl<'a> PartialEq for Cursor<'a> {\n-    fn eq(&self, other: &Cursor) -> bool {\n+    fn eq(&self, other: &Cursor<'_>) -> bool {\n         self.ptr == other.ptr && std::ptr::eq(self.buffer, other.buffer)\n     }\n }\n@@ -198,7 +198,7 @@ impl<'a> Cursor<'a> {\n         }\n     }\n \n-    fn create(buffer: &'a TokenBuffer, ptr: EntryPtr) -> Cursor<'a> {\n+    fn create(buffer: &'a TokenBuffer<'_>, ptr: EntryPtr) -> Cursor<'a> {\n         Cursor { buffer, ptr }\n     }\n "}, {"sha": "a54861de9587bd13c5e6cf8072c90a41c73184d2", "filename": "crates/tt/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Ftt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/crates%2Ftt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftt%2Fsrc%2Flib.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -156,7 +156,7 @@ impl fmt::Debug for Subtree {\n }\n \n impl fmt::Display for TokenTree {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             TokenTree::Leaf(it) => fmt::Display::fmt(it, f),\n             TokenTree::Subtree(it) => fmt::Display::fmt(it, f),\n@@ -165,7 +165,7 @@ impl fmt::Display for TokenTree {\n }\n \n impl fmt::Display for Subtree {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let (l, r) = match self.delimiter_kind() {\n             Some(DelimiterKind::Parenthesis) => (\"(\", \")\"),\n             Some(DelimiterKind::Brace) => (\"{\", \"}\"),\n@@ -193,7 +193,7 @@ impl fmt::Display for Subtree {\n }\n \n impl fmt::Display for Leaf {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Leaf::Ident(it) => fmt::Display::fmt(it, f),\n             Leaf::Literal(it) => fmt::Display::fmt(it, f),\n@@ -203,19 +203,19 @@ impl fmt::Display for Leaf {\n }\n \n impl fmt::Display for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&self.text, f)\n     }\n }\n \n impl fmt::Display for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&self.text, f)\n     }\n }\n \n impl fmt::Display for Punct {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&self.char, f)\n     }\n }"}, {"sha": "dadee43b1085cbd9bf28d4b66d2be8c967513b2d", "filename": "lib/la-arena/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/lib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0/lib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Flib.rs?ref=816f7fe12a8584eb4bdd48ff3da8e4fc95f571a0", "patch": "@@ -31,13 +31,13 @@ impl From<u32> for RawIdx {\n }\n \n impl fmt::Debug for RawIdx {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.0.fmt(f)\n     }\n }\n \n impl fmt::Display for RawIdx {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.0.fmt(f)\n     }\n }\n@@ -192,7 +192,7 @@ pub struct Arena<T> {\n }\n \n impl<T: fmt::Debug> fmt::Debug for Arena<T> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Arena\").field(\"len\", &self.len()).field(\"data\", &self.data).finish()\n     }\n }"}]}