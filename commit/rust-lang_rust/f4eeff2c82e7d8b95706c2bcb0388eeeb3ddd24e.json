{"sha": "f4eeff2c82e7d8b95706c2bcb0388eeeb3ddd24e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZWVmZjJjODJlN2Q4Yjk1NzA2YzJiY2IwMzg4ZWVlYjNkZGQyNGU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-16T13:32:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-16T13:32:07Z"}, "message": "Merge #2861\n\n2861: Micro-optimize type hints to avoid allocations r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "dfb27036b4cbb872b62b764d4c60c3aee60b1b6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfb27036b4cbb872b62b764d4c60c3aee60b1b6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4eeff2c82e7d8b95706c2bcb0388eeeb3ddd24e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeIGXXCRBK7hj4Ov3rIwAAdHIIAFX0YTQXvWf6UhG66oSiE7wa\nKH37KXhvEXNSwF4YcWxKn+ZSkdeJdJkdfTPspNE/HOPKp92lUfbGwSvUY+lPbsmF\nQqMTh2U4uSb+rhh26tO2uz0Pd0aNTD0pJWYwvypsyzACRQCVl/huwYPBO422n/1Z\n3RRFDhRmZzHTkctdbbK8+Zqsw3W3I3SgGmqgz6w5dM6BKZzl6pcH7psTuzpuxR2g\nbIk/+5DOm5i4SzKXqFsm6h5rlZYhV5NHxtRRFLLEfkBZWmCZP+KgJKd2Ladp+JTt\nDIkVSlh7rx4y4DRXJUow+ZaEFOOH1JqlX88ePH4fv5Rs25AEm9IDzCJrTaVLJbU=\n=NPoj\n-----END PGP SIGNATURE-----\n", "payload": "tree dfb27036b4cbb872b62b764d4c60c3aee60b1b6f\nparent 04b8bda51582b06c5af8bf2fbacd58f264c9f6f0\nparent 272f6dfd9eceb171b23200601201f3df95aa66c9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1579181527 +0000\ncommitter GitHub <noreply@github.com> 1579181527 +0000\n\nMerge #2861\n\n2861: Micro-optimize type hints to avoid allocations r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4eeff2c82e7d8b95706c2bcb0388eeeb3ddd24e", "html_url": "https://github.com/rust-lang/rust/commit/f4eeff2c82e7d8b95706c2bcb0388eeeb3ddd24e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4eeff2c82e7d8b95706c2bcb0388eeeb3ddd24e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04b8bda51582b06c5af8bf2fbacd58f264c9f6f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/04b8bda51582b06c5af8bf2fbacd58f264c9f6f0", "html_url": "https://github.com/rust-lang/rust/commit/04b8bda51582b06c5af8bf2fbacd58f264c9f6f0"}, {"sha": "272f6dfd9eceb171b23200601201f3df95aa66c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/272f6dfd9eceb171b23200601201f3df95aa66c9", "html_url": "https://github.com/rust-lang/rust/commit/272f6dfd9eceb171b23200601201f3df95aa66c9"}], "stats": {"total": 77, "additions": 38, "deletions": 39}, "files": [{"sha": "1b631c7cd88a13d1b0e18024bae85c92af302bd6", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f4eeff2c82e7d8b95706c2bcb0388eeeb3ddd24e/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eeff2c82e7d8b95706c2bcb0388eeeb3ddd24e/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=f4eeff2c82e7d8b95706c2bcb0388eeeb3ddd24e", "patch": "@@ -30,19 +30,20 @@ pub(crate) fn inlay_hints(\n     max_inlay_hint_length: Option<usize>,\n ) -> Vec<InlayHint> {\n     let mut sb = SourceBinder::new(db);\n-    file.syntax()\n-        .descendants()\n-        .flat_map(|node| get_inlay_hints(&mut sb, file_id, &node, max_inlay_hint_length))\n-        .flatten()\n-        .collect()\n+    let mut res = Vec::new();\n+    for node in file.syntax().descendants() {\n+        get_inlay_hints(&mut res, &mut sb, file_id, &node, max_inlay_hint_length);\n+    }\n+    res\n }\n \n fn get_inlay_hints(\n+    acc: &mut Vec<InlayHint>,\n     sb: &mut SourceBinder<RootDatabase>,\n     file_id: FileId,\n     node: &SyntaxNode,\n     max_inlay_hint_length: Option<usize>,\n-) -> Option<Vec<InlayHint>> {\n+) -> Option<()> {\n     let _p = profile(\"get_inlay_hints\");\n     let db = sb.db;\n     let analyzer = Lazy::new(move || sb.analyze(hir::InFile::new(file_id.into(), node), None));\n@@ -53,62 +54,58 @@ fn get_inlay_hints(\n                     return None;\n                 }\n                 let pat = it.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, false, max_inlay_hint_length))\n+                get_pat_type_hints(acc, db, &analyzer, pat, false, max_inlay_hint_length);\n             },\n             ast::LambdaExpr(it) => {\n                 it.param_list().map(|param_list| {\n                     param_list\n                         .params()\n                         .filter(|closure_param| closure_param.ascribed_type().is_none())\n                         .filter_map(|closure_param| closure_param.pat())\n-                        .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, false, max_inlay_hint_length))\n-                        .flatten()\n-                        .collect()\n-                })\n+                        .for_each(|root_pat| get_pat_type_hints(acc, db, &analyzer, root_pat, false, max_inlay_hint_length))\n+                });\n             },\n             ast::ForExpr(it) => {\n                 let pat = it.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, false, max_inlay_hint_length))\n+                get_pat_type_hints(acc, db, &analyzer, pat, false, max_inlay_hint_length);\n             },\n             ast::IfExpr(it) => {\n                 let pat = it.condition()?.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, true, max_inlay_hint_length))\n+                get_pat_type_hints(acc, db, &analyzer, pat, true, max_inlay_hint_length);\n             },\n             ast::WhileExpr(it) => {\n                 let pat = it.condition()?.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, true, max_inlay_hint_length))\n+                get_pat_type_hints(acc, db, &analyzer, pat, true, max_inlay_hint_length);\n             },\n             ast::MatchArmList(it) => {\n-                Some(\n-                    it\n-                        .arms()\n-                        .map(|match_arm| match_arm.pats())\n-                        .flatten()\n-                        .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, true, max_inlay_hint_length))\n-                        .flatten()\n-                        .collect(),\n-                )\n+                it.arms()\n+                    .map(|match_arm| match_arm.pats())\n+                    .flatten()\n+                    .for_each(|root_pat| get_pat_type_hints(acc, db, &analyzer, root_pat, true, max_inlay_hint_length));\n             },\n             ast::CallExpr(it) => {\n-                get_param_name_hints(db, &analyzer, ast::Expr::from(it))\n+                get_param_name_hints(acc, db, &analyzer, ast::Expr::from(it));\n             },\n             ast::MethodCallExpr(it) => {\n-                get_param_name_hints(db, &analyzer, ast::Expr::from(it))\n+                get_param_name_hints(acc, db, &analyzer, ast::Expr::from(it));\n             },\n-            _ => None,\n+            _ => (),\n         }\n-    }\n+    };\n+    Some(())\n }\n+\n fn get_param_name_hints(\n+    acc: &mut Vec<InlayHint>,\n     db: &RootDatabase,\n     analyzer: &SourceAnalyzer,\n     expr: ast::Expr,\n-) -> Option<Vec<InlayHint>> {\n+) -> Option<()> {\n     let args = match &expr {\n-        ast::Expr::CallExpr(expr) => Some(expr.arg_list()?.args()),\n-        ast::Expr::MethodCallExpr(expr) => Some(expr.arg_list()?.args()),\n-        _ => None,\n-    }?;\n+        ast::Expr::CallExpr(expr) => expr.arg_list()?.args(),\n+        ast::Expr::MethodCallExpr(expr) => expr.arg_list()?.args(),\n+        _ => return None,\n+    };\n \n     let mut parameters = get_fn_signature(db, analyzer, &expr)?.parameter_names.into_iter();\n \n@@ -129,10 +126,10 @@ fn get_param_name_hints(\n             range,\n             kind: InlayKind::ParameterHint,\n             label: param_name.into(),\n-        })\n-        .collect();\n+        });\n \n-    Some(hints)\n+    acc.extend(hints);\n+    Some(())\n }\n \n fn get_fn_signature(\n@@ -164,15 +161,16 @@ fn get_fn_signature(\n }\n \n fn get_pat_type_hints(\n+    acc: &mut Vec<InlayHint>,\n     db: &RootDatabase,\n     analyzer: &SourceAnalyzer,\n     root_pat: ast::Pat,\n     skip_root_pat_hint: bool,\n     max_inlay_hint_length: Option<usize>,\n-) -> Vec<InlayHint> {\n+) {\n     let original_pat = &root_pat.clone();\n \n-    get_leaf_pats(root_pat)\n+    let hints = get_leaf_pats(root_pat)\n         .into_iter()\n         .filter(|pat| !skip_root_pat_hint || pat != original_pat)\n         .filter_map(|pat| {\n@@ -186,8 +184,9 @@ fn get_pat_type_hints(\n             range,\n             kind: InlayKind::TypeHint,\n             label: pat_type.display_truncated(db, max_inlay_hint_length).to_string().into(),\n-        })\n-        .collect()\n+        });\n+\n+    acc.extend(hints);\n }\n \n fn get_leaf_pats(root_pat: ast::Pat) -> Vec<ast::Pat> {"}]}