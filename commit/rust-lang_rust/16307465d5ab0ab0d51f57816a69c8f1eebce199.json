{"sha": "16307465d5ab0ab0d51f57816a69c8f1eebce199", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MzA3NDY1ZDVhYjBhYjBkNTFmNTc4MTZhNjljOGYxZWViY2UxOTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-01T17:16:39Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-17T14:34:54Z"}, "message": "rustc_trans: always keep track of the Align in LvalueRef.", "tree": {"sha": "6030177a97b3046b83459003620325e947e46ff0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6030177a97b3046b83459003620325e947e46ff0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16307465d5ab0ab0d51f57816a69c8f1eebce199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16307465d5ab0ab0d51f57816a69c8f1eebce199", "html_url": "https://github.com/rust-lang/rust/commit/16307465d5ab0ab0d51f57816a69c8f1eebce199", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16307465d5ab0ab0d51f57816a69c8f1eebce199/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c6f242ca8a4eca33e8257906cc549b6b1418be2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c6f242ca8a4eca33e8257906cc549b6b1418be2", "html_url": "https://github.com/rust-lang/rust/commit/7c6f242ca8a4eca33e8257906cc549b6b1418be2"}], "stats": {"total": 210, "additions": 86, "deletions": 124}, "files": [{"sha": "4190a5bb66357986f0a36f8357cc8dc208bc145c", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=16307465d5ab0ab0d51f57816a69c8f1eebce199", "patch": "@@ -30,7 +30,7 @@ use cabi_sparc64;\n use cabi_nvptx;\n use cabi_nvptx64;\n use cabi_hexagon;\n-use mir::place::{Alignment, PlaceRef};\n+use mir::place::PlaceRef;\n use mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n@@ -561,7 +561,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         }\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n-            OperandValue::Ref(val, Alignment::AbiAligned).store(bcx, dst)\n+            OperandValue::Ref(val, self.layout.align).store(bcx, dst)\n         } else if let PassMode::Cast(cast) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}."}, {"sha": "09d7c7d677aa4faeaf35c5b56dfc1d2843d3a4a4", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=16307465d5ab0ab0d51f57816a69c8f1eebce199", "patch": "@@ -316,7 +316,7 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n                 if src_f.layout.ty == dst_f.layout.ty {\n                     memcpy_ty(bcx, dst_f.llval, src_f.llval, src_f.layout,\n-                        (src_f.alignment | dst_f.alignment).non_abi());\n+                        Some(src_f.align.min(dst_f.align)));\n                 } else {\n                     coerce_unsized_into(bcx, src_f, dst_f);\n                 }"}, {"sha": "a402fa136928968079b9fd3868dc3a5832442f08", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=16307465d5ab0ab0d51f57816a69c8f1eebce199", "patch": "@@ -14,7 +14,7 @@ use intrinsics::{self, Intrinsic};\n use llvm;\n use llvm::{ValueRef};\n use abi::{Abi, FnType, PassMode};\n-use mir::place::{PlaceRef, Alignment};\n+use mir::place::PlaceRef;\n use mir::operand::{OperandRef, OperandValue};\n use base::*;\n use common::*;\n@@ -106,7 +106,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let name = &*tcx.item_name(def_id);\n \n     let llret_ty = ccx.layout_of(ret_ty).llvm_type(ccx);\n-    let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, Alignment::AbiAligned);\n+    let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, fn_ty.ret.layout.align);\n \n     let simple = get_simple_intrinsic(ccx, name);\n     let llval = match name {\n@@ -254,7 +254,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 bcx.volatile_store(b, dst.project_field(bcx, 1).llval);\n             } else {\n                 let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                    bcx.load(ptr, align.non_abi())\n+                    bcx.load(ptr, Some(align))\n                 } else {\n                     if dst.layout.is_zst() {\n                         return;\n@@ -330,9 +330,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             let overflow = bcx.zext(bcx.extract_value(pair, 1), Type::bool(ccx));\n \n                             let dest = result.project_field(bcx, 0);\n-                            bcx.store(val, dest.llval, dest.alignment.non_abi());\n+                            bcx.store(val, dest.llval, dest.non_abi_align());\n                             let dest = result.project_field(bcx, 1);\n-                            bcx.store(overflow, dest.llval, dest.alignment.non_abi());\n+                            bcx.store(overflow, dest.llval, dest.non_abi_align());\n \n                             return;\n                         },\n@@ -473,9 +473,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         let success = bcx.zext(bcx.extract_value(pair, 1), Type::bool(bcx.ccx));\n \n                         let dest = result.project_field(bcx, 0);\n-                        bcx.store(val, dest.llval, dest.alignment.non_abi());\n+                        bcx.store(val, dest.llval, dest.non_abi_align());\n                         let dest = result.project_field(bcx, 1);\n-                        bcx.store(success, dest.llval, dest.alignment.non_abi());\n+                        bcx.store(success, dest.llval, dest.non_abi_align());\n                         return;\n                     } else {\n                         return invalid_monomorphization(ty);\n@@ -544,7 +544,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let tp_ty = substs.type_at(0);\n             let dst = args[0].deref(bcx.ccx);\n             let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                bcx.load(ptr, align.non_abi())\n+                bcx.load(ptr, Some(align))\n             } else {\n                 from_immediate(bcx, args[1].immediate())\n             };\n@@ -677,7 +677,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     for i in 0..elems.len() {\n                         let dest = result.project_field(bcx, i);\n                         let val = bcx.extract_value(val, i as u64);\n-                        bcx.store(val, dest.llval, dest.alignment.non_abi());\n+                        bcx.store(val, dest.llval, dest.non_abi_align());\n                     }\n                     return;\n                 }"}, {"sha": "1d90994c150b9559ae78e93c0dde0fd2adfbcf8d", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=16307465d5ab0ab0d51f57816a69c8f1eebce199", "patch": "@@ -31,7 +31,7 @@ use syntax_pos::Pos;\n \n use super::{MirContext, LocalRef};\n use super::constant::Const;\n-use super::place::{Alignment, PlaceRef};\n+use super::place::PlaceRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n@@ -216,7 +216,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     PassMode::Direct(_) | PassMode::Pair(..) => {\n                         let op = self.trans_consume(&bcx, &mir::Place::Local(mir::RETURN_PLACE));\n                         if let Ref(llval, align) = op.val {\n-                            bcx.load(llval, align.non_abi())\n+                            bcx.load(llval, Some(align))\n                         } else {\n                             op.immediate_or_packed_pair(&bcx)\n                         }\n@@ -228,7 +228,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             LocalRef::Operand(None) => bug!(\"use of return before def\"),\n                             LocalRef::Place(tr_place) => {\n                                 OperandRef {\n-                                    val: Ref(tr_place.llval, tr_place.alignment),\n+                                    val: Ref(tr_place.llval, tr_place.align),\n                                     layout: tr_place.layout\n                                 }\n                             }\n@@ -240,7 +240,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 scratch.llval\n                             }\n                             Ref(llval, align) => {\n-                                assert_eq!(align, Alignment::AbiAligned,\n+                                assert_eq!(align.abi(), op.layout.align.abi(),\n                                            \"return place is unaligned!\");\n                                 llval\n                             }\n@@ -579,7 +579,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         (&mir::Operand::Constant(_), Ref(..)) => {\n                             let tmp = PlaceRef::alloca(&bcx, op.layout, \"const\");\n                             op.val.store(&bcx, tmp);\n-                            op.val = Ref(tmp.llval, tmp.alignment);\n+                            op.val = Ref(tmp.llval, tmp.align);\n                         }\n                         _ => {}\n                     }\n@@ -639,38 +639,40 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     PassMode::Indirect(_) | PassMode::Cast(_) => {\n                         let scratch = PlaceRef::alloca(bcx, arg.layout, \"arg\");\n                         op.val.store(bcx, scratch);\n-                        (scratch.llval, Alignment::AbiAligned, true)\n+                        (scratch.llval, scratch.align, true)\n                     }\n                     _ => {\n-                        (op.immediate_or_packed_pair(bcx), Alignment::AbiAligned, false)\n+                        (op.immediate_or_packed_pair(bcx), arg.layout.align, false)\n                     }\n                 }\n             }\n-            Ref(llval, align @ Alignment::Packed(_)) if arg.is_indirect() => {\n-                // `foo(packed.large_field)`. We can't pass the (unaligned) field directly. I\n-                // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n-                // have scary latent bugs around.\n-\n-                let scratch = PlaceRef::alloca(bcx, arg.layout, \"arg\");\n-                base::memcpy_ty(bcx, scratch.llval, llval, op.layout, align.non_abi());\n-                (scratch.llval, Alignment::AbiAligned, true)\n+            Ref(llval, align) => {\n+                if arg.is_indirect() && align.abi() < arg.layout.align.abi() {\n+                    // `foo(packed.large_field)`. We can't pass the (unaligned) field directly. I\n+                    // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n+                    // have scary latent bugs around.\n+\n+                    let scratch = PlaceRef::alloca(bcx, arg.layout, \"arg\");\n+                    base::memcpy_ty(bcx, scratch.llval, llval, op.layout, Some(align));\n+                    (scratch.llval, scratch.align, true)\n+                } else {\n+                    (llval, align, true)\n+                }\n             }\n-            Ref(llval, align) => (llval, align, true)\n         };\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n                 llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n-                                 (align | Alignment::Packed(arg.layout.align))\n-                                    .non_abi());\n+                                 Some(align.min(arg.layout.align)));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n                 // used for this call is passing it by-value. In that case,\n                 // the load would just produce `OperandValue::Ref` instead\n                 // of the `OperandValue::Immediate` we need for the call.\n-                llval = bcx.load(llval, align.non_abi());\n+                llval = bcx.load(llval, Some(align));\n                 if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n                     if scalar.is_bool() {\n                         bcx.range_metadata(llval, 0..2);\n@@ -820,21 +822,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             self.trans_place(bcx, dest)\n         };\n         if fn_ret.is_indirect() {\n-            match dest.alignment {\n-                Alignment::AbiAligned => {\n-                    llargs.push(dest.llval);\n-                    ReturnDest::Nothing\n-                },\n-                Alignment::Packed(_) => {\n-                    // Currently, MIR code generation does not create calls\n-                    // that store directly to fields of packed structs (in\n-                    // fact, the calls it creates write only to temps),\n-                    //\n-                    // If someone changes that, please update this code path\n-                    // to create a temporary.\n-                    span_bug!(self.mir.span, \"can't directly store to unaligned value\");\n-                }\n+            if dest.align.abi() < dest.layout.align.abi() {\n+                // Currently, MIR code generation does not create calls\n+                // that store directly to fields of packed structs (in\n+                // fact, the calls it creates write only to temps),\n+                //\n+                // If someone changes that, please update this code path\n+                // to create a temporary.\n+                span_bug!(self.mir.span, \"can't directly store to unaligned value\");\n             }\n+            llargs.push(dest.llval);\n+            ReturnDest::Nothing\n         } else {\n             ReturnDest::Store(dest)\n         }\n@@ -874,8 +872,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let llty = src.layout.llvm_type(bcx.ccx);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         let align = src.layout.align.min(dst.layout.align);\n-        src.val.store(bcx,\n-            PlaceRef::new_sized(cast_ptr, src.layout, Alignment::Packed(align)));\n+        src.val.store(bcx, PlaceRef::new_sized(cast_ptr, src.layout, align));\n     }\n \n "}, {"sha": "69105b0cd8678ef66a840770725cddf7a1cb61db", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=16307465d5ab0ab0d51f57816a69c8f1eebce199", "patch": "@@ -42,7 +42,6 @@ use syntax::ast;\n use std::fmt;\n use std::ptr;\n \n-use super::place::Alignment;\n use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n \n@@ -182,12 +181,12 @@ impl<'a, 'tcx> Const<'tcx> {\n             let align = ccx.align_of(self.ty);\n             let ptr = consts::addr_of(ccx, self.llval, align, \"const\");\n             OperandValue::Ref(consts::ptrcast(ptr, layout.llvm_type(ccx).ptr_to()),\n-                              Alignment::AbiAligned)\n+                              layout.align)\n         };\n \n         OperandRef {\n             val,\n-            layout: ccx.layout_of(self.ty)\n+            layout\n         }\n     }\n }"}, {"sha": "2c109e80aeeadbce16fc57afe9fea506fbb89ef0", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=16307465d5ab0ab0d51f57816a69c8f1eebce199", "patch": "@@ -35,7 +35,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n pub use self::constant::trans_static_initializer;\n \n use self::analyze::CleanupKind;\n-use self::place::{Alignment, PlaceRef};\n+use self::place::PlaceRef;\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n@@ -279,9 +279,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 if local == mir::RETURN_PLACE && mircx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return place) -> place\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n-                    LocalRef::Place(PlaceRef::new_sized(llretptr,\n-                                                          layout,\n-                                                          Alignment::AbiAligned))\n+                    LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align))\n                 } else if memory_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> place\", local);\n                     LocalRef::Place(PlaceRef::alloca(&bcx, layout, &format!(\"{:?}\", local)))\n@@ -474,7 +472,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             bcx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n-            PlaceRef::new_sized(llarg, arg.layout, Alignment::AbiAligned)\n+            PlaceRef::new_sized(llarg, arg.layout, arg.layout.align)\n         } else {\n             let tmp = PlaceRef::alloca(bcx, arg.layout, &name);\n             arg.store_fn_arg(bcx, &mut llarg_idx, tmp);"}, {"sha": "74622cdf582f6c8e193862ebff42f020a92aa469", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=16307465d5ab0ab0d51f57816a69c8f1eebce199", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::ValueRef;\n use rustc::ty;\n-use rustc::ty::layout::{self, LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -25,7 +25,7 @@ use std::fmt;\n use std::ptr;\n \n use super::{MirContext, LocalRef};\n-use super::place::{Alignment, PlaceRef};\n+use super::place::PlaceRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -34,7 +34,7 @@ use super::place::{Alignment, PlaceRef};\n pub enum OperandValue {\n     /// A reference to the actual operand. The data is guaranteed\n     /// to be valid for the operand's lifetime.\n-    Ref(ValueRef, Alignment),\n+    Ref(ValueRef, Align),\n     /// A single LLVM value.\n     Immediate(ValueRef),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n@@ -107,11 +107,12 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n             OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n             OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n         };\n+        let layout = ccx.layout_of(projected_ty);\n         PlaceRef {\n             llval: llptr,\n             llextra,\n-            layout: ccx.layout_of(projected_ty),\n-            alignment: Alignment::AbiAligned,\n+            layout,\n+            align: layout.align,\n         }\n     }\n \n@@ -222,9 +223,9 @@ impl<'a, 'tcx> OperandValue {\n         match self {\n             OperandValue::Ref(r, source_align) =>\n                 base::memcpy_ty(bcx, dest.llval, r, dest.layout,\n-                                (source_align | dest.alignment).non_abi()),\n+                                Some(source_align.min(dest.align))),\n             OperandValue::Immediate(s) => {\n-                bcx.store(base::from_immediate(bcx, s), dest.llval, dest.alignment.non_abi());\n+                bcx.store(base::from_immediate(bcx, s), dest.llval, dest.non_abi_align());\n             }\n             OperandValue::Pair(a, b) => {\n                 for (i, &x) in [a, b].iter().enumerate() {\n@@ -233,7 +234,7 @@ impl<'a, 'tcx> OperandValue {\n                     if common::val_ty(x) == Type::i1(bcx.ccx) {\n                         llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n                     }\n-                    bcx.store(base::from_immediate(bcx, x), llptr, dest.alignment.non_abi());\n+                    bcx.store(base::from_immediate(bcx, x), llptr, dest.non_abi_align());\n                 }\n             }\n         }"}, {"sha": "c217f2e89945565aafeee29a9ea983bba3d0e38e", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 26, "deletions": 59, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=16307465d5ab0ab0d51f57816a69c8f1eebce199", "patch": "@@ -24,50 +24,10 @@ use value::Value;\n use glue;\n \n use std::ptr;\n-use std::ops;\n \n use super::{MirContext, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Alignment {\n-    Packed(Align),\n-    AbiAligned,\n-}\n-\n-impl ops::BitOr for Alignment {\n-    type Output = Self;\n-\n-    fn bitor(self, rhs: Self) -> Self {\n-        match (self, rhs) {\n-            (Alignment::Packed(a), Alignment::Packed(b)) => {\n-                Alignment::Packed(a.min(b))\n-            }\n-            (Alignment::Packed(x), _) | (_, Alignment::Packed(x)) => {\n-                Alignment::Packed(x)\n-            }\n-            (Alignment::AbiAligned, Alignment::AbiAligned) => {\n-                Alignment::AbiAligned\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> From<TyLayout<'a>> for Alignment {\n-    fn from(layout: TyLayout) -> Self {\n-        Alignment::Packed(layout.align)\n-    }\n-}\n-\n-impl Alignment {\n-    pub fn non_abi(self) -> Option<Align> {\n-        match self {\n-            Alignment::Packed(x) => Some(x),\n-            Alignment::AbiAligned => None,\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct PlaceRef<'tcx> {\n     /// Pointer to the contents of the place\n@@ -79,28 +39,28 @@ pub struct PlaceRef<'tcx> {\n     /// Monomorphized type of this place, including variant information\n     pub layout: TyLayout<'tcx>,\n \n-    /// Whether this place is known to be aligned according to its layout\n-    pub alignment: Alignment,\n+    /// What alignment we know for this place\n+    pub align: Align,\n }\n \n impl<'a, 'tcx> PlaceRef<'tcx> {\n     pub fn new_sized(llval: ValueRef,\n                      layout: TyLayout<'tcx>,\n-                     alignment: Alignment)\n+                     align: Align)\n                      -> PlaceRef<'tcx> {\n         PlaceRef {\n             llval,\n             llextra: ptr::null_mut(),\n             layout,\n-            alignment\n+            align\n         }\n     }\n \n     pub fn alloca(bcx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n                   -> PlaceRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         let tmp = bcx.alloca(layout.llvm_type(bcx.ccx), name, layout.align);\n-        Self::new_sized(tmp, layout, Alignment::AbiAligned)\n+        Self::new_sized(tmp, layout, layout.align)\n     }\n \n     pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n@@ -121,6 +81,14 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         !self.llextra.is_null()\n     }\n \n+    pub fn non_abi_align(self) -> Option<Align> {\n+        if self.align.abi() >= self.layout.align.abi() {\n+            None\n+        } else {\n+            Some(self.align)\n+        }\n+    }\n+\n     pub fn load(&self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         debug!(\"PlaceRef::load: {:?}\", self);\n \n@@ -167,7 +135,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             let llval = if !const_llval.is_null() {\n                 const_llval\n             } else {\n-                let load = bcx.load(self.llval, self.alignment.non_abi());\n+                let load = bcx.load(self.llval, self.non_abi_align());\n                 if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n                     scalar_load_metadata(load, scalar);\n                 }\n@@ -181,7 +149,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 if scalar.is_bool() {\n                     llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n                 }\n-                let load = bcx.load(llptr, self.alignment.non_abi());\n+                let load = bcx.load(llptr, self.non_abi_align());\n                 scalar_load_metadata(load, scalar);\n                 if scalar.is_bool() {\n                     bcx.trunc(load, Type::i1(bcx.ccx))\n@@ -191,7 +159,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             };\n             OperandValue::Pair(load(0, a), load(1, b))\n         } else {\n-            OperandValue::Ref(self.llval, self.alignment)\n+            OperandValue::Ref(self.llval, self.align)\n         };\n \n         OperandRef { val, layout: self.layout }\n@@ -202,7 +170,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         let ccx = bcx.ccx;\n         let field = self.layout.field(ccx, ix);\n         let offset = self.layout.fields.offset(ix);\n-        let alignment = self.alignment | Alignment::from(self.layout);\n+        let align = self.align.min(self.layout.align).min(field.align);\n \n         let simple = || {\n             // Unions and newtypes only use an offset of 0.\n@@ -224,7 +192,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                     ptr::null_mut()\n                 },\n                 layout: field,\n-                alignment,\n+                align,\n             }\n         };\n \n@@ -271,17 +239,17 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         let unaligned_offset = C_usize(ccx, offset.bytes());\n \n         // Get the alignment of the field\n-        let (_, align) = glue::size_and_align_of_dst(bcx, field.ty, meta);\n+        let (_, unsized_align) = glue::size_and_align_of_dst(bcx, field.ty, meta);\n \n         // Bump the unaligned offset up to the appropriate alignment using the\n         // following expression:\n         //\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bcx.sub(align, C_usize(ccx, 1u64));\n+        let align_sub_1 = bcx.sub(unsized_align, C_usize(ccx, 1u64));\n         let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n-        bcx.neg(align));\n+        bcx.neg(unsized_align));\n \n         debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n@@ -297,7 +265,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             llval: bcx.pointercast(byte_ptr, ll_fty.ptr_to()),\n             llextra: self.llextra,\n             layout: field,\n-            alignment,\n+            align,\n         }\n     }\n \n@@ -370,7 +338,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                     .discriminant_for_variant(bcx.tcx(), variant_index)\n                     .to_u128_unchecked() as u64;\n                 bcx.store(C_int(ptr.layout.llvm_type(bcx.ccx), to as i64),\n-                    ptr.llval, ptr.alignment.non_abi());\n+                    ptr.llval, ptr.non_abi_align());\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n@@ -414,7 +382,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             llval: bcx.inbounds_gep(self.llval, &[C_usize(bcx.ccx, 0), llindex]),\n             llextra: ptr::null_mut(),\n             layout: self.layout.field(bcx.ccx, 0),\n-            alignment: self.alignment\n+            align: self.align\n         }\n     }\n \n@@ -463,9 +431,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let result = match *place {\n             mir::Place::Local(_) => bug!(), // handled above\n             mir::Place::Static(box mir::Static { def_id, ty }) => {\n-                PlaceRef::new_sized(consts::get_static(ccx, def_id),\n-                                     ccx.layout_of(self.monomorphize(&ty)),\n-                                     Alignment::AbiAligned)\n+                let layout = ccx.layout_of(self.monomorphize(&ty));\n+                PlaceRef::new_sized(consts::get_static(ccx, def_id), layout, layout.align)\n             },\n             mir::Place::Projection(box mir::Projection {\n                 ref base,"}, {"sha": "577715797ade9d181f8c6259b506528b4fc5fe97", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16307465d5ab0ab0d51f57816a69c8f1eebce199/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=16307465d5ab0ab0d51f57816a69c8f1eebce199", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let start = dest.project_index(&bcx, C_usize(bcx.ccx, 0)).llval;\n \n                 if let OperandValue::Immediate(v) = tr_elem.val {\n-                    let align = dest.alignment.non_abi()\n+                    let align = dest.non_abi_align()\n                         .unwrap_or(tr_elem.layout.align);\n                     let align = C_i32(bcx.ccx, align.abi() as i32);\n                     let size = C_usize(bcx.ccx, dest.layout.size.bytes());\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n \n                 tr_elem.val.store(&body_bcx,\n-                    PlaceRef::new_sized(current, tr_elem.layout, dest.alignment));\n+                    PlaceRef::new_sized(current, tr_elem.layout, dest.align));\n \n                 let next = body_bcx.inbounds_gep(current, &[C_usize(bcx.ccx, 1)]);\n                 body_bcx.br(header_bcx.llbb());"}]}