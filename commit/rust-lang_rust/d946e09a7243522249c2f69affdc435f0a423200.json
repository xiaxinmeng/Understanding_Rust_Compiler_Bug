{"sha": "d946e09a7243522249c2f69affdc435f0a423200", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NDZlMDlhNzI0MzUyMjI0OWMyZjY5YWZmZGM0MzVmMGE0MjMyMDA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-28T13:57:38Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-29T08:36:40Z"}, "message": "Move closure construction over to DPS style\n\nIssue #667", "tree": {"sha": "637735cd70b1739845f3fa505cebc5bff74fb5c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/637735cd70b1739845f3fa505cebc5bff74fb5c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d946e09a7243522249c2f69affdc435f0a423200", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d946e09a7243522249c2f69affdc435f0a423200", "html_url": "https://github.com/rust-lang/rust/commit/d946e09a7243522249c2f69affdc435f0a423200", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d946e09a7243522249c2f69affdc435f0a423200/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "508c48ce10bc7d7e5d4ff7c1f1053f113867b9bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/508c48ce10bc7d7e5d4ff7c1f1053f113867b9bc", "html_url": "https://github.com/rust-lang/rust/commit/508c48ce10bc7d7e5d4ff7c1f1053f113867b9bc"}], "stats": {"total": 311, "additions": 163, "deletions": 148}, "files": [{"sha": "166affa0e593d585084b6d599e30e1e30acd64cc", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 157, "deletions": 143, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/d946e09a7243522249c2f69affdc435f0a423200/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d946e09a7243522249c2f69affdc435f0a423200/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d946e09a7243522249c2f69affdc435f0a423200", "patch": "@@ -2102,7 +2102,6 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n \n fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n                     src: lval_result, t: ty::t) -> @block_ctxt {\n-\n     // Lvals in memory are not temporaries. Copy them.\n     if src.is_mem {\n         ret copy_val(cx, action, dst, load_if_immediate(cx, src.val, t),\n@@ -2217,6 +2216,41 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n     }\n }\n \n+fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n+                 id: ast::node_id, dest: dest) -> @block_ctxt {\n+    if dest == ignore { ret bcx; }\n+    let ccx = bcx_ccx(bcx);\n+    let fty = node_id_type(ccx, id);\n+    check returns_non_ty_var(ccx, fty);\n+    let llfnty = type_of_fn_from_ty(ccx, sp, fty, 0u);\n+    let sub_cx = extend_path(bcx.fcx.lcx, ccx.names.next(\"anon\"));\n+    let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n+    let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n+\n+    let copying = f.proto == ast::proto_closure;\n+    let env;\n+    alt f.proto {\n+      ast::proto_block. | ast::proto_closure. {\n+        let upvars = get_freevars(ccx.tcx, id);\n+        let env_r = build_closure(bcx, upvars, copying);\n+        env = env_r.ptr;\n+        trans_closure(sub_cx, sp, f, llfn, none, [], id, {|fcx|\n+            load_environment(bcx, fcx, env_r.ptrty, upvars, copying);\n+        });\n+      }\n+      _ {\n+        env = C_null(T_opaque_closure_ptr(*bcx_ccx(bcx)));\n+        trans_closure(sub_cx, sp, f, llfn, none, [], id, {|_fcx|});\n+      }\n+    };\n+    let addr = alt dest {\n+      save_in(a) { a }\n+      overwrite(a, ty) { bcx = drop_ty(bcx, a, ty); a }\n+    };\n+    fill_fn_pair(bcx, addr, llfn, env);\n+    ret bcx;\n+}\n+\n fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n                  _lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n     // Determine the operation we need.\n@@ -2590,20 +2624,33 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n \n // Iterator translation\n \n+tag environment_value {\n+    env_expr(@ast::expr);\n+    env_direct(ValueRef, ty::t);\n+}\n+\n // Given a block context and a list of tydescs and values to bind\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n-                     bound_tys: [ty::t], bound_vals: [lval_result],\n+                     bound_values: [environment_value],\n                      copying: bool) ->\n    {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n+    let tcx = bcx_tcx(bcx);\n     // Synthesize a closure type.\n \n     // First, synthesize a tuple type containing the types of all the\n     // bound expressions.\n     // bindings_ty = [bound_ty1, bound_ty2, ...]\n-    let bindings_ty: ty::t = ty::mk_tup(bcx_tcx(bcx), bound_tys);\n+    let bound_tys = [];\n+    for bv in bound_values {\n+        bound_tys += [alt bv {\n+          env_direct(_, t) { t }\n+          env_expr(e) { ty::expr_ty(tcx, e) }\n+        }];\n+    }\n+    let bindings_ty: ty::t = ty::mk_tup(tcx, bound_tys);\n \n     // NB: keep this in sync with T_closure_ptr; we're making\n     // a ty::t structure that has the same \"shape\" as the LLVM type\n@@ -2612,7 +2659,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     // Make a vector that contains ty_param_count copies of tydesc_ty.\n     // (We'll need room for that many tydescs in the closure.)\n     let ty_param_count = std::vec::len(lltydescs);\n-    let tydesc_ty: ty::t = ty::mk_type(bcx_tcx(bcx));\n+    let tydesc_ty: ty::t = ty::mk_type(tcx);\n     let captured_tys: [ty::t] = std::vec::init_elt(tydesc_ty, ty_param_count);\n \n     // Get all the types we've got (some of which we synthesized\n@@ -2622,26 +2669,28 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     // closure_tys = [tydesc_ty, [bound_ty1, bound_ty2, ...], [tydesc_ty,\n     // tydesc_ty, ...]]\n     let closure_tys: [ty::t] =\n-        [tydesc_ty, bindings_ty, ty::mk_tup(bcx_tcx(bcx), captured_tys)];\n+        [tydesc_ty, bindings_ty, ty::mk_tup(tcx, captured_tys)];\n \n     // Finally, synthesize a type for that whole vector.\n-    let closure_ty: ty::t = ty::mk_tup(bcx_tcx(bcx), closure_tys);\n+    let closure_ty: ty::t = ty::mk_tup(tcx, closure_tys);\n \n+    let temp_cleanups = [];\n     // Allocate a box that can hold something closure-sized.\n-    let r =\n-        if copying {\n-            trans_malloc_boxed(bcx, closure_ty)\n-        } else {\n-            // We need to dummy up a box on the stack\n-            let ty =\n-                ty::mk_tup(bcx_tcx(bcx),\n-                           [ty::mk_int(bcx_tcx(bcx)), closure_ty]);\n-            let r = alloc_ty(bcx, ty);\n-            let body = GEPi(bcx, r.val, [0, abi::box_rc_field_body]);\n-            {bcx: r.bcx, box: r.val, body: body}\n-        };\n-    bcx = r.bcx;\n-    let closure = r.body;\n+    let (closure, box) = if copying {\n+        let r = trans_malloc_boxed(bcx, closure_ty);\n+        add_clean_free(bcx, r.box, false);\n+        temp_cleanups += [r.box];\n+        bcx = r.bcx;\n+        (r.body, r.box)\n+    } else {\n+        // We need to dummy up a box on the stack\n+        let ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n+        let r = alloc_ty(bcx, ty);\n+        bcx = r.bcx;\n+        // Prevent glue from trying to free this.\n+        Store(bcx, C_int(2), GEPi(bcx, r.val, [0, abi::box_rc_field_refcnt]));\n+        (GEPi(bcx, r.val, [0, abi::box_rc_field_body]), r.val)\n+    };\n \n     // Store bindings tydesc.\n     if copying {\n@@ -2656,24 +2705,32 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     }\n \n     // Copy expr values into boxed bindings.\n-    let i = 0u;\n     // Silly check\n     check type_is_tup_like(bcx, closure_ty);\n-    let bindings =\n-        GEP_tup_like(bcx, closure_ty, closure,\n-                     [0, abi::closure_elt_bindings]);\n+    let bindings = GEP_tup_like(bcx, closure_ty, closure,\n+                                [0, abi::closure_elt_bindings]);\n     bcx = bindings.bcx;\n-    for lv: lval_result in bound_vals {\n-        // Also a silly check\n-        check type_is_tup_like(bcx, bindings_ty);\n+    let i = 0u;\n+    for bv in bound_values {\n         let bound =\n-            GEP_tup_like(bcx, bindings_ty, bindings.val, [0, i as int]);\n+            GEP_tup_like_1(bcx, bindings_ty, bindings.val, [0, i as int]);\n         bcx = bound.bcx;\n-        if copying {\n-            bcx = move_val_if_temp(bcx, INIT, bound.val, lv, bound_tys[i]);\n-        } else { Store(bcx, lv.val, bound.val); }\n+        alt bv {\n+          env_expr(e) {\n+            bcx = trans_expr_save_in(bcx, e, bound.val, INIT);\n+            add_clean_temp_mem(bcx, bound.val, bound_tys[i]);\n+            temp_cleanups += [bound.val];\n+          }\n+          env_direct(val, ty) {\n+            if copying {\n+                bcx = copy_val(bcx, INIT, bound.val,\n+                               load_if_immediate(bcx, val, ty), ty);\n+            } else { Store(bcx, val, bound.val); }\n+          }\n+        }\n         i += 1u;\n     }\n+    for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n \n     // If necessary, copy tydescs describing type parameters into the\n     // appropriate slot in the closure.\n@@ -2690,31 +2747,29 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         i += 1u;\n     }\n \n-    ret {ptr: r.box, ptrty: closure_ty, bcx: bcx};\n+    ret {ptr: box, ptrty: closure_ty, bcx: bcx};\n }\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for build_environment.\n fn build_closure(cx: @block_ctxt, upvars: @[ast::def], copying: bool) ->\n    {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n-    let closure_vals: [lval_result] = [];\n-    let closure_tys: [ty::t] = [];\n     // If we need to, package up the iterator body to call\n-    if !copying && !option::is_none(cx.fcx.lliterbody) {\n-        closure_vals += [lval_mem(cx, option::get(cx.fcx.lliterbody))];\n-        closure_tys += [option::get(cx.fcx.iterbodyty)];\n-    }\n+    let env_vals = alt cx.fcx.lliterbody {\n+      some(body) when !copying {\n+        [env_direct(body, option::get(cx.fcx.iterbodyty))]\n+      }\n+      _ { [] }\n+    };\n     // Package up the upvars\n     for def in *upvars {\n-        closure_vals += [trans_local_var(cx, def)];\n+        let val = trans_local_var(cx, def).val;\n         let nid = ast_util::def_id_of_def(def).node;\n         let ty = ty::node_id_to_monotype(bcx_tcx(cx), nid);\n         if !copying { ty = ty::mk_mut_ptr(bcx_tcx(cx), ty); }\n-        closure_tys += [ty];\n+        env_vals += [env_direct(val, ty)];\n     }\n-\n-    ret build_environment(cx, copy cx.fcx.lltydescs, closure_tys,\n-                          closure_vals, copying);\n+    ret build_environment(cx, copy cx.fcx.lltydescs, env_vals, copying);\n }\n \n // Return a pointer to the stored typarams in a closure.\n@@ -3300,8 +3355,11 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n       some(gi) {\n         let n_args = std::vec::len(ty::ty_fn_args(bcx_tcx(c.bcx), ty));\n         let args = std::vec::init_elt(none::<@ast::expr>, n_args);\n-        let {bcx, val} = trans_bind_1(c.bcx, ty, c, args, ty);\n-        ret lval_val(bcx, val);\n+        let space = alloc_ty(c.bcx, ty);\n+        let bcx = trans_bind_1(space.bcx, ty, c, args, ty,\n+                               save_in(space.val));\n+        add_clean_temp(bcx, space.val, ty);\n+        ret lval_val(bcx, space.val);\n       }\n       none. {\n         let (is_mem, val) = maybe_add_env(c.bcx, c);\n@@ -3578,19 +3636,25 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n }\n \n fn trans_bind(cx: @block_ctxt, f: @ast::expr, args: [option::t<@ast::expr>],\n-              id: ast::node_id) -> result {\n+              id: ast::node_id, dest: dest) -> @block_ctxt {\n     let f_res = trans_callee(cx, f);\n     ret trans_bind_1(cx, ty::expr_ty(bcx_tcx(cx), f), f_res, args,\n-                     ty::node_id_to_type(bcx_tcx(cx), id));\n+                     ty::node_id_to_type(bcx_tcx(cx), id), dest);\n }\n \n fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n                 f_res: lval_maybe_callee,\n-                args: [option::t<@ast::expr>], pair_ty: ty::t) -> result {\n+                args: [option::t<@ast::expr>], pair_ty: ty::t,\n+                dest: dest) -> @block_ctxt {\n     let bound: [@ast::expr] = [];\n     for argopt: option::t<@ast::expr> in args {\n         alt argopt { none. { } some(e) { bound += [e]; } }\n     }\n+    let bcx = f_res.bcx;\n+    if dest == ignore {\n+        for ex in bound { bcx = trans_expr_dps(bcx, ex, ignore); }\n+        ret bcx;\n+    }\n \n     // Figure out which tydescs we need to pass, if any.\n     let outgoing_fty_real; // the type with typarams still in it\n@@ -3608,12 +3672,18 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     if std::vec::len(bound) == 0u && ty_param_count == 0u {\n         // Trivial 'binding': just return the closure\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n-        ret rslt(lv.bcx, lv.val);\n+        bcx = lv.bcx;\n+        // FIXME[DPS] factor this out\n+        let addr = alt dest {\n+          save_in(a) { a }\n+          overwrite(a, ty) { bcx = drop_ty(bcx, a, ty); a }\n+        };\n+        bcx = memmove_ty(bcx, addr, lv.val, pair_ty);\n+        ret bcx;\n     }\n-    let bcx = f_res.bcx;\n-    let (is_mem, closure) = alt f_res.env {\n-      null_env. { (true, none) }\n-      _ { let (mem, cl) = maybe_add_env(cx, f_res); (mem, some(cl)) }\n+    let closure = alt f_res.env {\n+      null_env. { none }\n+      _ { let (_, cl) = maybe_add_env(cx, f_res); some(cl) }\n     };\n \n     // FIXME: should follow from a precondition on trans_bind_1\n@@ -3622,47 +3692,36 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n \n     // Arrange for the bound function to live in the first binding spot\n     // if the function is not statically known.\n-    let (bound_tys, bound_vals, target_res) = alt closure {\n+    let (env_vals, target_res) = alt closure {\n       some(cl) {\n         // Cast the function we are binding to be the type that the\n         // closure will expect it to have. The type the closure knows\n         // about has the type parameters substituted with the real types.\n         let sp = cx.sp;\n         let llclosurety = T_ptr(type_of(ccx, sp, outgoing_fty));\n         let src_loc = PointerCast(bcx, cl, llclosurety);\n-        let bound_f = {bcx: bcx, val: src_loc, is_mem: is_mem};\n-        ([outgoing_fty], [bound_f], none)\n+        ([env_direct(src_loc, pair_ty)], none)\n       }\n-      none. { ([], [], some(f_res.val)) }\n+      none. { ([], some(f_res.val)) }\n     };\n \n-    // Translate the bound expressions.\n-    for e: @ast::expr in bound {\n-        let lv = trans_lval(bcx, e);\n-        bcx = lv.bcx;\n-        bound_vals += [lv];\n-        bound_tys += [ty::expr_ty(bcx_tcx(cx), e)];\n-    }\n-    if bcx.unreachable {\n-        ret rslt(bcx, llvm::LLVMGetUndef(\n-            T_ptr(type_of_or_i8(bcx, outgoing_fty))));\n-    }\n-\n     // Actually construct the closure\n-    let closure =\n-        build_environment(bcx, lltydescs, bound_tys, bound_vals, true);\n+    let closure = build_environment\n+        (bcx, lltydescs, env_vals + vec::map(env_expr, bound), true);\n     bcx = closure.bcx;\n \n     // Make thunk\n     let llthunk =\n         trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real, args,\n                          closure.ptrty, ty_param_count, target_res);\n \n-    // Construct the function pair\n-    let pair_v =\n-        create_real_fn_pair(bcx, llthunk.ty, llthunk.val, closure.ptr);\n-    add_clean_temp(cx, pair_v, pair_ty);\n-    ret rslt(bcx, pair_v);\n+    // Fill the function pair\n+    let addr = alt dest {\n+      save_in(a) { a }\n+      overwrite(a, ty) { bcx = drop_ty(bcx, a, ty); a }\n+    };\n+    fill_fn_pair(bcx, addr, llthunk.val, closure.ptr);\n+    ret bcx;\n }\n \n fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n@@ -4129,30 +4188,6 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n     // Fixme Fill in cx.sp\n     alt e.node {\n-      ast::expr_fn(f) {\n-        let ccx = bcx_ccx(cx);\n-        let fty = node_id_type(ccx, e.id);\n-        check returns_non_ty_var(ccx, fty);\n-        let llfnty: TypeRef =\n-            type_of_fn_from_ty(ccx, e.span, fty, 0u);\n-        let sub_cx = extend_path(cx.fcx.lcx, ccx.names.next(\"anon\"));\n-        let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n-        let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n-\n-        let fn_res =\n-            trans_closure(some(cx), some(llfnty), sub_cx, e.span, f, llfn,\n-                          none, [], e.id);\n-        let fn_pair =\n-            alt fn_res {\n-              some(fn_pair) { fn_pair }\n-              none. {\n-                {fn_pair: create_real_fn_pair(cx, llfnty, llfn,\n-                                              null_env_ptr(cx)),\n-                 bcx: cx}\n-              }\n-            };\n-        ret rslt(fn_pair.bcx, fn_pair.fn_pair);\n-      }\n       ast::expr_copy(a) {\n         let e_ty = ty::expr_ty(bcx_tcx(cx), a);\n         let lv = trans_lval(cx, a);\n@@ -4168,7 +4203,6 @@ fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n         add_clean_temp(bcx, r.val, e_ty);\n         ret r;\n       }\n-      ast::expr_bind(f, args) { ret trans_bind(cx, f, args, e.id); }\n       ast::expr_cast(val, _) { ret trans_cast(cx, val, e.id); }\n       ast::expr_anon_obj(anon_obj) {\n         ret trans_anon_obj(cx, e.span, anon_obj, e.id);\n@@ -4247,7 +4281,10 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n         }\n         ret trans_unary(bcx, op, x, e.id, dest);\n       }\n+      ast::expr_fn(f) { ret trans_expr_fn(bcx, f, e.span, e.id, dest); }\n+      ast::expr_bind(f, args) { ret trans_bind(bcx, f, args, e.id, dest); }\n \n+      // These return nothing\n       ast::expr_break. {\n         assert dest == ignore;\n         ret trans_break(e.span, bcx);\n@@ -5207,11 +5244,9 @@ fn finish_fn(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-fn trans_closure(bcx_maybe: option::t<@block_ctxt>,\n-                 llfnty: option::t<TypeRef>, cx: @local_ctxt, sp: span,\n-                 f: ast::_fn, llfndecl: ValueRef, ty_self: option::t<ty::t>,\n-                 ty_params: [ast::ty_param], id: ast::node_id) ->\n-   option::t<{fn_pair: ValueRef, bcx: @block_ctxt}> {\n+fn trans_closure(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n+                 ty_self: option::t<ty::t>, ty_params: [ast::ty_param],\n+                 id: ast::node_id, maybe_load_env: block(@fn_ctxt)) {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n@@ -5233,28 +5268,7 @@ fn trans_closure(bcx_maybe: option::t<@block_ctxt>,\n     let arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n     bcx = copy_args_to_allocas(fcx, bcx, f.decl.inputs, arg_tys, false);\n \n-    // Figure out if we need to build a closure and act accordingly\n-    let res =\n-        alt f.proto {\n-          ast::proto_block. | ast::proto_closure. {\n-            let bcx = option::get(bcx_maybe);\n-            let upvars = get_freevars(cx.ccx.tcx, id);\n-\n-            let copying = f.proto == ast::proto_closure;\n-            let env = build_closure(bcx, upvars, copying);\n-            load_environment(bcx, fcx, env.ptrty, upvars, copying);\n-\n-            let closure =\n-                create_real_fn_pair(env.bcx, option::get(llfnty), llfndecl,\n-                                    env.ptr);\n-            if copying {\n-                add_clean_temp(bcx, closure, node_id_type(cx.ccx, id));\n-            }\n-            some({fn_pair: closure, bcx: env.bcx})\n-          }\n-          _ { none }\n-        };\n-\n+    maybe_load_env(fcx);\n \n     // This call to trans_block is the place where we bridge between\n     // translation calls that don't have a return value (trans_crate,\n@@ -5273,22 +5287,17 @@ fn trans_closure(bcx_maybe: option::t<@block_ctxt>,\n         bcx = trans_block_dps(bcx, f.body, save_in(fcx.llretptr));\n     }\n \n-    if !bcx.unreachable {\n-        // FIXME: until LLVM has a unit type, we are moving around\n-        // C_nil values rather than their void type.\n-        build_return(bcx);\n-    }\n-\n+    // FIXME: until LLVM has a unit type, we are moving around\n+    // C_nil values rather than their void type.\n+    if !bcx.unreachable { build_return(bcx); }\n     // Insert the mandatory first few basic blocks before lltop.\n     finish_fn(fcx, lltop);\n-\n-    ret res;\n }\n \n fn trans_fn_inner(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n                   ty_self: option::t<ty::t>, ty_params: [ast::ty_param],\n                   id: ast::node_id) {\n-    trans_closure(none, none, cx, sp, f, llfndecl, ty_self, ty_params, id);\n+    trans_closure(cx, sp, f, llfndecl, ty_self, ty_params, id, {|_fcx|});\n }\n \n \n@@ -5635,15 +5644,20 @@ fn create_real_fn_pair(cx: @block_ctxt, llfnty: TypeRef, llfn: ValueRef,\n     let lcx = cx.fcx.lcx;\n \n     let pair = alloca(cx, T_fn_pair(*lcx.ccx, llfnty));\n-    let code_cell = GEP(cx, pair, [C_int(0), C_int(abi::fn_field_code)]);\n-    Store(cx, llfn, code_cell);\n-    let env_cell = GEP(cx, pair, [C_int(0), C_int(abi::fn_field_box)]);\n-    let llenvblobptr =\n-        PointerCast(cx, llenvptr, T_opaque_closure_ptr(*lcx.ccx));\n-    Store(cx, llenvblobptr, env_cell);\n+    fill_fn_pair(cx, pair, llfn, llenvptr);\n     ret pair;\n }\n \n+fn fill_fn_pair(bcx: @block_ctxt, pair: ValueRef, llfn: ValueRef,\n+                llenvptr: ValueRef) {\n+    let code_cell = GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_code)]);\n+    Store(bcx, llfn, code_cell);\n+    let env_cell = GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_box)]);\n+    let llenvblobptr =\n+        PointerCast(bcx, llenvptr, T_opaque_closure_ptr(*bcx_ccx(bcx)));\n+    Store(bcx, llenvblobptr, env_cell);\n+}\n+\n // Returns the number of type parameters that the given native function has.\n fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n     let count;"}, {"sha": "cf5b3a8504e1a37c3710804881b4859e8af89998", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d946e09a7243522249c2f69affdc435f0a423200/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d946e09a7243522249c2f69affdc435f0a423200/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=d946e09a7243522249c2f69affdc435f0a423200", "patch": "@@ -6,7 +6,6 @@ import trans::{\n     trans_shared_malloc,\n     type_of_inner,\n     size_of,\n-    move_val_if_temp,\n     node_id_type,\n     trans_lval,\n     INIT,"}, {"sha": "2439505242b49a18d726ac8357c6fad52bb57dc8", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d946e09a7243522249c2f69affdc435f0a423200/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d946e09a7243522249c2f69affdc435f0a423200/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=d946e09a7243522249c2f69affdc435f0a423200", "patch": "@@ -6,7 +6,7 @@ import back::abi;\n import trans::{call_memmove, trans_shared_malloc, llsize_of, type_of_or_i8,\n                INIT, copy_val, load_if_immediate, alloca, size_of,\n                llderivedtydescs_block_ctxt, lazily_emit_tydesc_glue,\n-               get_tydesc, load_inbounds, move_val_if_temp, trans_lval,\n+               get_tydesc, load_inbounds, trans_lval,\n                node_id_type, new_sub_block_ctxt, tps_normal, do_spill_noroot,\n                GEPi, alloc_ty, dest};\n import trans_build::*;\n@@ -121,12 +121,10 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n     let dataptr = get_dataptr_simple(bcx, vptr, llunitty);\n     let i = 0u, temp_cleanups = [vptr];\n     for e in args {\n-        let lv = trans_lval(bcx, e);\n-        bcx = lv.bcx;\n         let lleltptr = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n             InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(i), llunitsz)])\n         } else { InBoundsGEP(bcx, dataptr, [C_uint(i)]) };\n-        bcx = move_val_if_temp(bcx, INIT, lleltptr, lv, unit_ty);\n+        bcx = trans::trans_expr_save_in(bcx, e, lleltptr, INIT);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n         temp_cleanups += [lleltptr];\n         i += 1u;"}, {"sha": "e327c7a6cf0b55b57000fdcb0fd98e16c9f720d8", "filename": "src/test/run-pass/first-class-method.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d946e09a7243522249c2f69affdc435f0a423200/src%2Ftest%2Frun-pass%2Ffirst-class-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d946e09a7243522249c2f69affdc435f0a423200/src%2Ftest%2Frun-pass%2Ffirst-class-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffirst-class-method.rs?ref=d946e09a7243522249c2f69affdc435f0a423200", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n // Test case for issue #758.\n obj foo() { fn f() { } }\n "}, {"sha": "a9d93917c4be5bb67840f7c2b39a173701de6d94", "filename": "src/test/run-pass/standalone-method.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d946e09a7243522249c2f69affdc435f0a423200/src%2Ftest%2Frun-pass%2Fstandalone-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d946e09a7243522249c2f69affdc435f0a423200/src%2Ftest%2Frun-pass%2Fstandalone-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstandalone-method.rs?ref=d946e09a7243522249c2f69affdc435f0a423200", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n // Test case for issue #435.\n obj foo(x: int) {\n     fn add5(n: int) -> int { ret n + x; }"}]}