{"sha": "bfb832e7c886a720e0aa847ffd8500621a3152d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYjgzMmU3Yzg4NmE3MjBlMGFhODQ3ZmZkODUwMDYyMWEzMTUyZDU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-17T08:43:17Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-27T22:27:18Z"}, "message": "Add `SingleImports` and use it in place of `outstanding_references`\nand `pub_outstanding_references`.", "tree": {"sha": "d5065ddfa925d350aa0e8e840bfd71c3a403851f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5065ddfa925d350aa0e8e840bfd71c3a403851f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfb832e7c886a720e0aa847ffd8500621a3152d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfb832e7c886a720e0aa847ffd8500621a3152d5", "html_url": "https://github.com/rust-lang/rust/commit/bfb832e7c886a720e0aa847ffd8500621a3152d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfb832e7c886a720e0aa847ffd8500621a3152d5/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ff21f138a1a807205180caf7921256e6dc16790", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ff21f138a1a807205180caf7921256e6dc16790", "html_url": "https://github.com/rust-lang/rust/commit/5ff21f138a1a807205180caf7921256e6dc16790"}], "stats": {"total": 218, "additions": 114, "deletions": 104}, "files": [{"sha": "10a8647906e35a7011e8cda59ee6b534bc3fda03", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 35, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bfb832e7c886a720e0aa847ffd8500621a3152d5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfb832e7c886a720e0aa847ffd8500621a3152d5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=bfb832e7c886a720e0aa847ffd8500621a3152d5", "patch": "@@ -14,8 +14,7 @@\n //! any imports resolved.\n \n use DefModifiers;\n-use resolve_imports::ImportDirective;\n-use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n+use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBinding, NameBindingKind};\n@@ -28,7 +27,7 @@ use rustc::middle::def::*;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty::VariantKind;\n \n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::Name;\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::special_idents;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -152,8 +151,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                         }\n \n                         let subclass = ImportDirectiveSubclass::single(binding, source_name);\n-                        self.build_import_directive(parent,\n-                                                    module_path,\n+                        self.unresolved_imports += 1;\n+                        parent.add_import_directive(module_path,\n                                                     subclass,\n                                                     view_path.span,\n                                                     item.id,\n@@ -203,8 +202,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                 }\n                             };\n                             let subclass = ImportDirectiveSubclass::single(rename, name);\n-                            self.build_import_directive(parent,\n-                                                        module_path,\n+                            self.unresolved_imports += 1;\n+                            parent.add_import_directive(module_path,\n                                                         subclass,\n                                                         source_item.span,\n                                                         source_item.node.id(),\n@@ -213,8 +212,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                         }\n                     }\n                     ViewPathGlob(_) => {\n-                        self.build_import_directive(parent,\n-                                                    module_path,\n+                        self.unresolved_imports += 1;\n+                        parent.add_import_directive(module_path,\n                                                     GlobImport,\n                                                     view_path.span,\n                                                     item.id,\n@@ -521,32 +520,6 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         }\n     }\n \n-    /// Creates and adds an import directive to the given module.\n-    fn build_import_directive(&mut self,\n-                              module_: Module<'b>,\n-                              module_path: Vec<Name>,\n-                              subclass: ImportDirectiveSubclass,\n-                              span: Span,\n-                              id: NodeId,\n-                              is_public: bool,\n-                              is_prelude: bool) {\n-        // Bump the reference count on the name. Or, if this is a glob, set\n-        // the appropriate flag.\n-\n-        match subclass {\n-            SingleImport { target, .. } => {\n-                module_.increment_outstanding_references_for(target, ValueNS, is_public);\n-                module_.increment_outstanding_references_for(target, TypeNS, is_public);\n-            }\n-            GlobImport => {}\n-        }\n-\n-        let directive =\n-            ImportDirective::new(module_path, subclass, span, id, is_public, is_prelude);\n-        module_.add_import_directive(directive);\n-        self.unresolved_imports += 1;\n-    }\n-\n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n     pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {"}, {"sha": "a13ecc26ad807f7cee28b779558cf4570cc34655", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 106, "deletions": 69, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/bfb832e7c886a720e0aa847ffd8500621a3152d5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfb832e7c886a720e0aa847ffd8500621a3152d5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=bfb832e7c886a720e0aa847ffd8500621a3152d5", "patch": "@@ -68,24 +68,6 @@ pub struct ImportDirective<'a> {\n }\n \n impl<'a> ImportDirective<'a> {\n-    pub fn new(module_path: Vec<Name>,\n-               subclass: ImportDirectiveSubclass,\n-               span: Span,\n-               id: NodeId,\n-               is_public: bool,\n-               is_prelude: bool)\n-               -> Self {\n-        ImportDirective {\n-            module_path: module_path,\n-            target_module: Cell::new(None),\n-            subclass: subclass,\n-            span: span,\n-            id: id,\n-            is_public: is_public,\n-            is_prelude: is_prelude,\n-        }\n-    }\n-\n     // Given the binding to which this directive resolves in a particular namespace,\n     // this returns the binding for the name this directive defines in that namespace.\n     fn import(&self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n@@ -111,17 +93,52 @@ impl<'a> ImportDirective<'a> {\n }\n \n #[derive(Clone, Default)]\n-/// Records information about the resolution of a name in a module.\n+/// Records information about the resolution of a name in a namespace of a module.\n pub struct NameResolution<'a> {\n-    /// The number of unresolved single imports of any visibility that could define the name.\n-    outstanding_references: u32,\n-    /// The number of unresolved `pub` single imports that could define the name.\n-    pub_outstanding_references: u32,\n+    /// The single imports that define the name in the namespace.\n+    single_imports: SingleImports<'a>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n     duplicate_globs: Vec<&'a NameBinding<'a>>,\n }\n \n+#[derive(Clone, Debug)]\n+enum SingleImports<'a> {\n+    /// No single imports can define the name in the namespace.\n+    None,\n+    /// Only the given single import can define the name in the namespace.\n+    MaybeOne(&'a ImportDirective<'a>),\n+    /// At least one single import will define the name in the namespace.\n+    AtLeastOne,\n+}\n+\n+impl<'a> Default for SingleImports<'a> {\n+    fn default() -> Self {\n+        SingleImports::None\n+    }\n+}\n+\n+impl<'a> SingleImports<'a> {\n+    fn add_directive(&mut self, directive: &'a ImportDirective<'a>) {\n+        match *self {\n+            SingleImports::None => *self = SingleImports::MaybeOne(directive),\n+            // If two single imports can define the name in the namespace, we can assume that at\n+            // least one of them will define it since otherwise both would have to define only one\n+            // namespace, leading to a duplicate error.\n+            SingleImports::MaybeOne(_) => *self = SingleImports::AtLeastOne,\n+            SingleImports::AtLeastOne => {}\n+        };\n+    }\n+\n+    fn directive_failed(&mut self) {\n+        match *self {\n+            SingleImports::None => unreachable!(),\n+            SingleImports::MaybeOne(_) => *self = SingleImports::None,\n+            SingleImports::AtLeastOne => {}\n+        }\n+    }\n+}\n+\n impl<'a> NameResolution<'a> {\n     fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n         if let Some(old_binding) = self.binding {\n@@ -140,40 +157,43 @@ impl<'a> NameResolution<'a> {\n         Ok(())\n     }\n \n+    // Returns the binding for the name if it is known or None if it not known.\n+    fn binding(&self) -> Option<&'a NameBinding<'a>> {\n+        self.binding.and_then(|binding| match self.single_imports {\n+            SingleImports::None => Some(binding),\n+            _ if !binding.defined_with(DefModifiers::GLOB_IMPORTED) => Some(binding),\n+            _ => None, // The binding could be shadowed by a single import, so it is not known.\n+        })\n+    }\n+\n     // Returns Some(the resolution of the name), or None if the resolution depends\n     // on whether more globs can define the name.\n     fn try_result(&self, allow_private_imports: bool)\n                   -> Option<ResolveResult<&'a NameBinding<'a>>> {\n         match self.binding {\n             Some(binding) if !binding.defined_with(DefModifiers::GLOB_IMPORTED) =>\n-                Some(Success(binding)),\n-            // If (1) we don't allow private imports, (2) no public single import can define the\n-            // name, and (3) no public glob has defined the name, the resolution depends on globs.\n-            _ if !allow_private_imports && self.pub_outstanding_references == 0 &&\n-                 !self.binding.map(NameBinding::is_public).unwrap_or(false) => None,\n-            _ if self.outstanding_references > 0 => Some(Indeterminate),\n-            Some(binding) => Some(Success(binding)),\n-            None => None,\n-        }\n-    }\n-\n-    fn increment_outstanding_references(&mut self, is_public: bool) {\n-        self.outstanding_references += 1;\n-        if is_public {\n-            self.pub_outstanding_references += 1;\n-        }\n-    }\n-\n-    fn decrement_outstanding_references(&mut self, is_public: bool) {\n-        let decrement_references = |count: &mut _| {\n-            assert!(*count > 0);\n-            *count -= 1;\n+                return Some(Success(binding)),\n+            _ => {} // Items and single imports are not shadowable\n         };\n \n-        decrement_references(&mut self.outstanding_references);\n-        if is_public {\n-            decrement_references(&mut self.pub_outstanding_references);\n+        // Check if a single import can still define the name.\n+        match self.single_imports {\n+            SingleImports::None => {},\n+            SingleImports::AtLeastOne => return Some(Indeterminate),\n+            SingleImports::MaybeOne(directive) => {\n+                // If (1) we don't allow private imports, (2) no public single import can define\n+                // the name, and (3) no public glob has defined the name, the resolution depends\n+                // on whether more globs can define the name.\n+                if !allow_private_imports && !directive.is_public &&\n+                   !self.binding.map(NameBinding::is_public).unwrap_or(false) {\n+                    return None;\n+                }\n+\n+                return Indeterminate;\n+            }\n         }\n+\n+        self.binding.map(Success)\n     }\n \n     fn report_conflicts<F: FnMut(&NameBinding, &NameBinding)>(&self, mut report: F) {\n@@ -245,35 +265,51 @@ impl<'a> ::ModuleS<'a> {\n         })\n     }\n \n-    pub fn add_import_directive(&self, directive: ImportDirective<'a>) {\n-        let directive = self.arenas.alloc_import_directive(directive);\n+    pub fn add_import_directive(&self,\n+                                module_path: Vec<Name>,\n+                                subclass: ImportDirectiveSubclass,\n+                                span: Span,\n+                                id: NodeId,\n+                                is_public: bool,\n+                                is_prelude: bool) {\n+        let directive = self.arenas.alloc_import_directive(ImportDirective {\n+            module_path: module_path,\n+            target_module: Cell::new(None),\n+            subclass: subclass,\n+            span: span,\n+            id: id,\n+            is_public: is_public,\n+            is_prelude: is_prelude,\n+        });\n+\n         self.unresolved_imports.borrow_mut().push(directive);\n-        if let GlobImport = directive.subclass {\n+        match directive.subclass {\n+            SingleImport { target, .. } => {\n+                let mut resolutions = self.resolutions.borrow_mut();\n+                for &ns in &[ValueNS, TypeNS] {\n+                    resolutions.entry((target, ns)).or_insert_with(Default::default)\n+                               .single_imports.add_directive(directive);\n+                }\n+            }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n-            if !directive.is_prelude {\n-                self.globs.borrow_mut().push(directive);\n-            }\n+            GlobImport if directive.is_prelude => {}\n+            GlobImport => self.globs.borrow_mut().push(directive),\n         }\n     }\n \n-    pub fn increment_outstanding_references_for(&self, name: Name, ns: Namespace, is_public: bool) {\n-        self.resolutions.borrow_mut().entry((name, ns)).or_insert_with(Default::default)\n-            .increment_outstanding_references(is_public);\n-    }\n-\n     // Use `update` to mutate the resolution for the name.\n     // If the resolution becomes a success, define it in the module's glob importers.\n     fn update_resolution<T, F>(&self, name: Name, ns: Namespace, update: F) -> T\n         where F: FnOnce(&mut NameResolution<'a>) -> T\n     {\n         let mut resolutions = self.resolutions.borrow_mut();\n         let resolution = resolutions.entry((name, ns)).or_insert_with(Default::default);\n-        let was_success = resolution.try_result(false).and_then(ResolveResult::success).is_some();\n+        let was_known = resolution.binding().is_some();\n \n         let t = update(resolution);\n-        if !was_success {\n-            if let Some(Success(binding)) = resolution.try_result(false) {\n+        if !was_known {\n+            if let Some(binding) = resolution.binding() {\n                 self.define_in_glob_importers(name, ns, binding);\n             }\n         }\n@@ -454,12 +490,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 // (as opposed to being indeterminate) when it can only be defined by the directive.\n                 if !determined {\n                     module_.resolutions.borrow_mut().get_mut(&(target, ns)).unwrap()\n-                           .decrement_outstanding_references(directive.is_public);\n+                           .single_imports.directive_failed();\n                 }\n                 let result =\n                     self.resolver.resolve_name_in_module(target_module, source, ns, false, true);\n                 if !determined {\n-                    module_.increment_outstanding_references_for(target, ns, directive.is_public)\n+                    module_.resolutions.borrow_mut().get_mut(&(target, ns)).unwrap()\n+                           .single_imports.add_directive(directive);\n                 }\n                 result\n             };\n@@ -491,11 +528,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     let binding = &directive.import(binding, None);\n                     self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n                 }\n+            } else {\n+                module_.update_resolution(target, ns, |resolution| {\n+                    resolution.single_imports.directive_failed();\n+                });\n             }\n-\n-            module_.update_resolution(target, ns, |resolution| {\n-                resolution.decrement_outstanding_references(directive.is_public);\n-            })\n         }\n \n         match (&value_result, &type_result) {\n@@ -605,7 +642,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         target_module.glob_importers.borrow_mut().push((module_, directive));\n \n         for (&(name, ns), resolution) in target_module.resolutions.borrow().iter() {\n-            if let Some(Success(binding)) = resolution.try_result(false) {\n+            if let Some(binding) = resolution.binding() {\n                 if binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) {\n                     let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n                 }"}]}