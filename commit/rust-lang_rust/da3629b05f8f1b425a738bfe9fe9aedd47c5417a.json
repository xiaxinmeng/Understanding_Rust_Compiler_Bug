{"sha": "da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMzYyOWIwNWY4ZjFiNDI1YTczOGJmZTlmZTlhZWRkNDdjNTQxN2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-29T19:30:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-29T19:30:53Z"}, "message": "Auto merge of #67112 - Centril:expr-polish, r=estebank\n\nRefactor expression parsing thoroughly\n\nBased on https://github.com/rust-lang/rust/pull/66994 together with which this has refactored basically the entirety of `expr.rs`.\n\nr? @estebank", "tree": {"sha": "047f021d39e5bc5a58f3c290866159d036f668f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/047f021d39e5bc5a58f3c290866159d036f668f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "html_url": "https://github.com/rust-lang/rust/commit/da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25434f898b499876203a3b95c1b38bad5ed2cc5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/25434f898b499876203a3b95c1b38bad5ed2cc5d", "html_url": "https://github.com/rust-lang/rust/commit/25434f898b499876203a3b95c1b38bad5ed2cc5d"}, {"sha": "7a246acf0a0413131765a3e78dc665e68f6f243d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a246acf0a0413131765a3e78dc665e68f6f243d", "html_url": "https://github.com/rust-lang/rust/commit/7a246acf0a0413131765a3e78dc665e68f6f243d"}], "stats": {"total": 1122, "additions": 585, "deletions": 537}, "files": [{"sha": "4b7f1e9a4d8338a8ccfd3f874c6ed320e0458fa8", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -2,6 +2,7 @@ use super::{Parser, PathStyle, TokenType};\n use rustc_errors::PResult;\n use syntax::ast;\n use syntax::attr;\n+use syntax::print::pprust;\n use syntax::token::{self, Nonterminal};\n use syntax::util::comments;\n use syntax_pos::{Span, Symbol};\n@@ -154,7 +155,7 @@ impl<'a> Parser<'a> {\n                 (attr_sp, item, style)\n             }\n             _ => {\n-                let token_str = self.this_token_to_string();\n+                let token_str = pprust::token_to_string(&self.token);\n                 return Err(self.fatal(&format!(\"expected `#`, found `{}`\", token_str)));\n             }\n         };\n@@ -329,7 +330,7 @@ impl<'a> Parser<'a> {\n             Err(ref mut err) => err.cancel(),\n         }\n \n-        let found = self.this_token_to_string();\n+        let found = pprust::token_to_string(&self.token);\n         let msg = format!(\"expected unsuffixed literal or identifier, found `{}`\", found);\n         Err(self.diagnostic().struct_span_err(self.token.span, &msg))\n     }"}, {"sha": "578f816be58c8f58ad79fcabc2b19b5df64e01fe", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -200,7 +200,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n         let mut err = self.struct_span_err(\n             self.token.span,\n-            &format!(\"expected identifier, found {}\", self.this_token_descr()),\n+            &format!(\"expected identifier, found {}\", super::token_descr(&self.token)),\n         );\n         let valid_follow = &[\n             TokenKind::Eq,\n@@ -225,7 +225,7 @@ impl<'a> Parser<'a> {\n                 );\n             }\n         }\n-        if let Some(token_descr) = self.token_descr() {\n+        if let Some(token_descr) = super::token_descr_opt(&self.token) {\n             err.span_label(self.token.span, format!(\"expected identifier, found {}\", token_descr));\n         } else {\n             err.span_label(self.token.span, \"expected identifier\");\n@@ -272,7 +272,7 @@ impl<'a> Parser<'a> {\n         expected.sort_by_cached_key(|x| x.to_string());\n         expected.dedup();\n         let expect = tokens_to_string(&expected[..]);\n-        let actual = self.this_token_descr();\n+        let actual = super::token_descr(&self.token);\n         let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {\n             let short_expect = if expected.len() > 6 {\n                 format!(\"{} possible tokens\", expected.len())\n@@ -815,7 +815,7 @@ impl<'a> Parser<'a> {\n         t: &TokenKind,\n     ) -> PResult<'a, bool /* recovered */> {\n         let token_str = pprust::token_kind_to_string(t);\n-        let this_token_str = self.this_token_descr();\n+        let this_token_str = super::token_descr(&self.token);\n         let (prev_sp, sp) = match (&self.token.kind, self.subparser_name) {\n             // Point at the end of the macro call when reaching end of macro arguments.\n             (token::Eof, Some(_)) => {\n@@ -862,7 +862,7 @@ impl<'a> Parser<'a> {\n             return Ok(());\n         }\n         let sm = self.sess.source_map();\n-        let msg = format!(\"expected `;`, found `{}`\", self.this_token_descr());\n+        let msg = format!(\"expected `;`, found `{}`\", super::token_descr(&self.token));\n         let appl = Applicability::MachineApplicable;\n         if self.token.span == DUMMY_SP || self.prev_span == DUMMY_SP {\n             // Likely inside a macro, can't provide meaninful suggestions.\n@@ -1270,7 +1270,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn expected_semi_or_open_brace<T>(&mut self) -> PResult<'a, T> {\n-        let token_str = self.this_token_descr();\n+        let token_str = super::token_descr(&self.token);\n         let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\", token_str));\n         err.span_label(self.token.span, \"expected `;` or `{`\");\n         Err(err)\n@@ -1447,7 +1447,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => (\n                 self.token.span,\n-                format!(\"expected expression, found {}\", self.this_token_descr(),),\n+                format!(\"expected expression, found {}\", super::token_descr(&self.token),),\n             ),\n         };\n         let mut err = self.struct_span_err(span, &msg);"}, {"sha": "b51a4465b159e47fc1a1f04a7586788a591b8598", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 453, "deletions": 437, "changes": 890, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -210,30 +210,12 @@ impl<'a> Parser<'a> {\n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n                 continue;\n             } else if op == AssocOp::Colon {\n-                let maybe_path = self.could_ascription_be_path(&lhs.kind);\n-                self.last_type_ascription = Some((self.prev_span, maybe_path));\n-\n-                lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n-                self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n+                lhs = self.parse_assoc_op_ascribe(lhs, lhs_span)?;\n                 continue;\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n                 // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n                 // generalise it to the Fixity::None code.\n-                //\n-                // We have 2 alternatives here: `x..y`/`x..=y` and `x..`/`x..=` The other\n-                // two variants are handled with `parse_prefix_range_expr` call above.\n-                let rhs = if self.is_at_start_of_range_notation_rhs() {\n-                    Some(self.parse_assoc_expr_with(prec + 1, LhsExpr::NotYetParsed)?)\n-                } else {\n-                    None\n-                };\n-                let (lhs_span, rhs_span) =\n-                    (lhs.span, if let Some(ref x) = rhs { x.span } else { cur_op_span });\n-                let limits =\n-                    if op == AssocOp::DotDot { RangeLimits::HalfOpen } else { RangeLimits::Closed };\n-\n-                let r = self.mk_range(Some(lhs), rhs, limits)?;\n-                lhs = self.mk_expr(lhs_span.to(rhs_span), r, AttrVec::new());\n+                lhs = self.parse_range_expr(prec, lhs, op, cur_op_span)?;\n                 break;\n             }\n \n@@ -395,6 +377,27 @@ impl<'a> Parser<'a> {\n             && !classify::expr_requires_semi_to_be_stmt(e)\n     }\n \n+    /// Parses `x..y`, `x..=y`, and `x..`/`x..=`.\n+    /// The other two variants are handled in `parse_prefix_range_expr` below.\n+    fn parse_range_expr(\n+        &mut self,\n+        prec: usize,\n+        lhs: P<Expr>,\n+        op: AssocOp,\n+        cur_op_span: Span,\n+    ) -> PResult<'a, P<Expr>> {\n+        let rhs = if self.is_at_start_of_range_notation_rhs() {\n+            Some(self.parse_assoc_expr_with(prec + 1, LhsExpr::NotYetParsed)?)\n+        } else {\n+            None\n+        };\n+        let rhs_span = rhs.as_ref().map_or(cur_op_span, |x| x.span);\n+        let span = lhs.span.to(rhs_span);\n+        let limits =\n+            if op == AssocOp::DotDot { RangeLimits::HalfOpen } else { RangeLimits::Closed };\n+        Ok(self.mk_expr(span, self.mk_range(Some(lhs), rhs, limits)?, AttrVec::new()))\n+    }\n+\n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n         if self.token.can_begin_expr() {\n             // Parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n@@ -408,10 +411,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses prefix-forms of range notation: `..expr`, `..`, `..=expr`.\n-    fn parse_prefix_range_expr(\n-        &mut self,\n-        already_parsed_attrs: Option<AttrVec>,\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_prefix_range_expr(&mut self, attrs: Option<AttrVec>) -> PResult<'a, P<Expr>> {\n         // Check for deprecated `...` syntax.\n         if self.token == token::DotDotDot {\n             self.err_dotdotdot_syntax(self.token.span);\n@@ -422,118 +422,107 @@ impl<'a> Parser<'a> {\n             \"parse_prefix_range_expr: token {:?} is not DotDot/DotDotEq\",\n             self.token\n         );\n-        let tok = self.token.clone();\n-        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n+\n+        let limits = match self.token.kind {\n+            token::DotDot => RangeLimits::HalfOpen,\n+            _ => RangeLimits::Closed,\n+        };\n+        let op = AssocOp::from_token(&self.token);\n+        let attrs = self.parse_or_use_outer_attributes(attrs)?;\n         let lo = self.token.span;\n-        let mut hi = self.token.span;\n         self.bump();\n-        let opt_end = if self.is_at_start_of_range_notation_rhs() {\n+        let (span, opt_end) = if self.is_at_start_of_range_notation_rhs() {\n             // RHS must be parsed with more associativity than the dots.\n-            let next_prec = AssocOp::from_token(&tok).unwrap().precedence() + 1;\n-            Some(self.parse_assoc_expr_with(next_prec, LhsExpr::NotYetParsed).map(|x| {\n-                hi = x.span;\n-                x\n-            })?)\n+            self.parse_assoc_expr_with(op.unwrap().precedence() + 1, LhsExpr::NotYetParsed)\n+                .map(|x| (lo.to(x.span), Some(x)))?\n         } else {\n-            None\n+            (lo, None)\n         };\n-        let limits = if tok == token::DotDot { RangeLimits::HalfOpen } else { RangeLimits::Closed };\n-\n-        let r = self.mk_range(None, opt_end, limits)?;\n-        Ok(self.mk_expr(lo.to(hi), r, attrs))\n+        Ok(self.mk_expr(span, self.mk_range(None, opt_end, limits)?, attrs))\n     }\n \n     /// Parses a prefix-unary-operator expr.\n-    fn parse_prefix_expr(&mut self, already_parsed_attrs: Option<AttrVec>) -> PResult<'a, P<Expr>> {\n-        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n+    fn parse_prefix_expr(&mut self, attrs: Option<AttrVec>) -> PResult<'a, P<Expr>> {\n+        let attrs = self.parse_or_use_outer_attributes(attrs)?;\n         let lo = self.token.span;\n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n         let (hi, ex) = match self.token.kind {\n-            token::Not => {\n-                self.bump();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), self.mk_unary(UnOp::Not, e))\n-            }\n-            // Suggest `!` for bitwise negation when encountering a `~`\n-            token::Tilde => {\n-                self.bump();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                let span_of_tilde = lo;\n-                self.struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\")\n-                    .span_suggestion_short(\n-                        span_of_tilde,\n-                        \"use `!` to perform bitwise not\",\n-                        \"!\".to_owned(),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n-                (lo.to(span), self.mk_unary(UnOp::Not, e))\n-            }\n-            token::BinOp(token::Minus) => {\n-                self.bump();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), self.mk_unary(UnOp::Neg, e))\n-            }\n-            token::BinOp(token::Star) => {\n-                self.bump();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), self.mk_unary(UnOp::Deref, e))\n-            }\n-            token::BinOp(token::And) | token::AndAnd => self.parse_address_of(lo)?,\n-            token::Ident(..) if self.token.is_keyword(kw::Box) => {\n-                self.bump();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                let span = lo.to(span);\n-                self.sess.gated_spans.gate(sym::box_syntax, span);\n-                (span, ExprKind::Box(e))\n-            }\n-            token::Ident(..) if self.token.is_ident_named(sym::not) => {\n-                // `not` is just an ordinary identifier in Rust-the-language,\n-                // but as `rustc`-the-compiler, we can issue clever diagnostics\n-                // for confused users who really want to say `!`\n-                let token_cannot_continue_expr = |t: &Token| match t.kind {\n-                    // These tokens can start an expression after `!`, but\n-                    // can't continue an expression after an ident\n-                    token::Ident(name, is_raw) => token::ident_can_begin_expr(name, t.span, is_raw),\n-                    token::Literal(..) | token::Pound => true,\n-                    _ => t.is_whole_expr(),\n-                };\n-                let cannot_continue_expr = self.look_ahead(1, token_cannot_continue_expr);\n-                if cannot_continue_expr {\n-                    self.bump();\n-                    // Emit the error ...\n-                    self.struct_span_err(\n-                        self.token.span,\n-                        &format!(\"unexpected {} after identifier\", self.this_token_descr()),\n-                    )\n-                    .span_suggestion_short(\n-                        // Span the `not` plus trailing whitespace to avoid\n-                        // trailing whitespace after the `!` in our suggestion\n-                        self.sess.source_map().span_until_non_whitespace(lo.to(self.token.span)),\n-                        \"use `!` to perform logical negation\",\n-                        \"!\".to_owned(),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n-                    // \u2014and recover! (just as if we were in the block\n-                    // for the `token::Not` arm)\n-                    let e = self.parse_prefix_expr(None);\n-                    let (span, e) = self.interpolated_or_expr_span(e)?;\n-                    (lo.to(span), self.mk_unary(UnOp::Not, e))\n-                } else {\n-                    return self.parse_dot_or_call_expr(Some(attrs));\n-                }\n-            }\n-            _ => {\n-                return self.parse_dot_or_call_expr(Some(attrs));\n-            }\n+            token::Not => self.parse_unary_expr(lo, UnOp::Not), // `!expr`\n+            token::Tilde => self.recover_tilde_expr(lo),        // `~expr`\n+            token::BinOp(token::Minus) => self.parse_unary_expr(lo, UnOp::Neg), // `-expr`\n+            token::BinOp(token::Star) => self.parse_unary_expr(lo, UnOp::Deref), // `*expr`\n+            token::BinOp(token::And) | token::AndAnd => self.parse_borrow_expr(lo),\n+            token::Ident(..) if self.token.is_keyword(kw::Box) => self.parse_box_expr(lo),\n+            token::Ident(..) if self.is_mistaken_not_ident_negation() => self.recover_not_expr(lo),\n+            _ => return self.parse_dot_or_call_expr(Some(attrs)),\n+        }?;\n+        Ok(self.mk_expr(lo.to(hi), ex, attrs))\n+    }\n+\n+    fn parse_prefix_expr_common(&mut self, lo: Span) -> PResult<'a, (Span, P<Expr>)> {\n+        self.bump();\n+        let expr = self.parse_prefix_expr(None);\n+        let (span, expr) = self.interpolated_or_expr_span(expr)?;\n+        Ok((lo.to(span), expr))\n+    }\n+\n+    fn parse_unary_expr(&mut self, lo: Span, op: UnOp) -> PResult<'a, (Span, ExprKind)> {\n+        let (span, expr) = self.parse_prefix_expr_common(lo)?;\n+        Ok((span, self.mk_unary(op, expr)))\n+    }\n+\n+    // Recover on `!` suggesting for bitwise negation instead.\n+    fn recover_tilde_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n+        self.struct_span_err(lo, \"`~` cannot be used as a unary operator\")\n+            .span_suggestion_short(\n+                lo,\n+                \"use `!` to perform bitwise not\",\n+                \"!\".to_owned(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+\n+        self.parse_unary_expr(lo, UnOp::Not)\n+    }\n+\n+    /// Parse `box expr`.\n+    fn parse_box_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n+        let (span, expr) = self.parse_prefix_expr_common(lo)?;\n+        self.sess.gated_spans.gate(sym::box_syntax, span);\n+        Ok((span, ExprKind::Box(expr)))\n+    }\n+\n+    fn is_mistaken_not_ident_negation(&self) -> bool {\n+        let token_cannot_continue_expr = |t: &Token| match t.kind {\n+            // These tokens can start an expression after `!`, but\n+            // can't continue an expression after an ident\n+            token::Ident(name, is_raw) => token::ident_can_begin_expr(name, t.span, is_raw),\n+            token::Literal(..) | token::Pound => true,\n+            _ => t.is_whole_expr(),\n         };\n-        return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n+        self.token.is_ident_named(sym::not) && self.look_ahead(1, token_cannot_continue_expr)\n+    }\n+\n+    /// Recover on `not expr` in favor of `!expr`.\n+    fn recover_not_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n+        // Emit the error...\n+        let not_token = self.look_ahead(1, |t| t.clone());\n+        self.struct_span_err(\n+            not_token.span,\n+            &format!(\"unexpected {} after identifier\", super::token_descr(&not_token)),\n+        )\n+        .span_suggestion_short(\n+            // Span the `not` plus trailing whitespace to avoid\n+            // trailing whitespace after the `!` in our suggestion\n+            self.sess.source_map().span_until_non_whitespace(lo.to(not_token.span)),\n+            \"use `!` to perform logical negation\",\n+            \"!\".to_owned(),\n+            Applicability::MachineApplicable,\n+        )\n+        .emit();\n+\n+        // ...and recover!\n+        self.parse_unary_expr(lo, UnOp::Not)\n     }\n \n     /// Returns the span of expr, if it was not interpolated or the span of the interpolated token.\n@@ -598,14 +587,7 @@ impl<'a> Parser<'a> {\n                             op_noun,\n                         );\n                         let span_after_type = parser_snapshot_after_type.token.span;\n-                        let expr = mk_expr(\n-                            self,\n-                            P(Ty {\n-                                span: path.span,\n-                                kind: TyKind::Path(None, path),\n-                                id: DUMMY_NODE_ID,\n-                            }),\n-                        );\n+                        let expr = mk_expr(self, self.mk_ty(path.span, TyKind::Path(None, path)));\n \n                         let expr_str = self\n                             .span_to_snippet(expr.span)\n@@ -638,33 +620,44 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn parse_assoc_op_ascribe(&mut self, lhs: P<Expr>, lhs_span: Span) -> PResult<'a, P<Expr>> {\n+        let maybe_path = self.could_ascription_be_path(&lhs.kind);\n+        self.last_type_ascription = Some((self.prev_span, maybe_path));\n+        let lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n+        self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n+        Ok(lhs)\n+    }\n+\n     /// Parse `& mut? <expr>` or `& raw [ const | mut ] <expr>`.\n-    fn parse_address_of(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n+    fn parse_borrow_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.expect_and()?;\n-        let (k, m) = if self.check_keyword(kw::Raw) && self.look_ahead(1, Token::is_mutability) {\n+        let (borrow_kind, mutbl) = self.parse_borrow_modifiers(lo);\n+        let expr = self.parse_prefix_expr(None);\n+        let (span, expr) = self.interpolated_or_expr_span(expr)?;\n+        Ok((lo.to(span), ExprKind::AddrOf(borrow_kind, mutbl, expr)))\n+    }\n+\n+    /// Parse `mut?` or `raw [ const | mut ]`.\n+    fn parse_borrow_modifiers(&mut self, lo: Span) -> (ast::BorrowKind, ast::Mutability) {\n+        if self.check_keyword(kw::Raw) && self.look_ahead(1, Token::is_mutability) {\n+            // `raw [ const | mut ]`.\n             let found_raw = self.eat_keyword(kw::Raw);\n             assert!(found_raw);\n             let mutability = self.parse_const_or_mut().unwrap();\n             self.sess.gated_spans.gate(sym::raw_ref_op, lo.to(self.prev_span));\n             (ast::BorrowKind::Raw, mutability)\n         } else {\n+            // `mut?`\n             (ast::BorrowKind::Ref, self.parse_mutability())\n-        };\n-        let e = self.parse_prefix_expr(None);\n-        let (span, e) = self.interpolated_or_expr_span(e)?;\n-        Ok((lo.to(span), ExprKind::AddrOf(k, m, e)))\n+        }\n     }\n \n     /// Parses `a.b` or `a(13)` or `a[4]` or just `a`.\n-    fn parse_dot_or_call_expr(\n-        &mut self,\n-        already_parsed_attrs: Option<AttrVec>,\n-    ) -> PResult<'a, P<Expr>> {\n-        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n-\n-        let b = self.parse_bottom_expr();\n-        let (span, b) = self.interpolated_or_expr_span(b)?;\n-        self.parse_dot_or_call_expr_with(b, span, attrs)\n+    fn parse_dot_or_call_expr(&mut self, attrs: Option<AttrVec>) -> PResult<'a, P<Expr>> {\n+        let attrs = self.parse_or_use_outer_attributes(attrs)?;\n+        let base = self.parse_bottom_expr();\n+        let (span, base) = self.interpolated_or_expr_span(base)?;\n+        self.parse_dot_or_call_expr_with(base, span, attrs)\n     }\n \n     pub(super) fn parse_dot_or_call_expr_with(\n@@ -694,95 +687,120 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        let mut e = e0;\n-        let mut hi;\n+    fn parse_dot_or_call_expr_with_(&mut self, mut e: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         loop {\n-            // expr?\n-            while self.eat(&token::Question) {\n-                let hi = self.prev_span;\n-                e = self.mk_expr(lo.to(hi), ExprKind::Try(e), AttrVec::new());\n+            if self.eat(&token::Question) {\n+                // `expr?`\n+                e = self.mk_expr(lo.to(self.prev_span), ExprKind::Try(e), AttrVec::new());\n+                continue;\n             }\n-\n-            // expr.f\n             if self.eat(&token::Dot) {\n-                match self.token.kind {\n-                    token::Ident(..) => {\n-                        e = self.parse_dot_suffix(e, lo)?;\n-                    }\n-                    token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n-                        let span = self.token.span;\n-                        self.bump();\n-                        let field = ExprKind::Field(e, Ident::new(symbol, span));\n-                        e = self.mk_expr(lo.to(span), field, AttrVec::new());\n-\n-                        self.expect_no_suffix(span, \"a tuple index\", suffix);\n-                    }\n-                    token::Literal(token::Lit { kind: token::Float, symbol, .. }) => {\n-                        self.bump();\n-                        let fstr = symbol.as_str();\n-                        let msg = format!(\"unexpected token: `{}`\", symbol);\n-                        let mut err = self.diagnostic().struct_span_err(self.prev_span, &msg);\n-                        err.span_label(self.prev_span, \"unexpected token\");\n-                        if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n-                            let float = match fstr.parse::<f64>().ok() {\n-                                Some(f) => f,\n-                                None => continue,\n-                            };\n-                            let sugg = pprust::to_string(|s| {\n-                                s.popen();\n-                                s.print_expr(&e);\n-                                s.s.word(\".\");\n-                                s.print_usize(float.trunc() as usize);\n-                                s.pclose();\n-                                s.s.word(\".\");\n-                                s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n-                            });\n-                            err.span_suggestion(\n-                                lo.to(self.prev_span),\n-                                \"try parenthesizing the first index\",\n-                                sugg,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                        return Err(err);\n-                    }\n-                    _ => {\n-                        // FIXME Could factor this out into non_fatal_unexpected or something.\n-                        let actual = self.this_token_to_string();\n-                        self.span_err(self.token.span, &format!(\"unexpected token: `{}`\", actual));\n-                    }\n-                }\n+                // expr.f\n+                e = self.parse_dot_suffix_expr(lo, e)?;\n                 continue;\n             }\n             if self.expr_is_complete(&e) {\n-                break;\n+                return Ok(e);\n             }\n-            match self.token.kind {\n-                // expr(...)\n-                token::OpenDelim(token::Paren) => {\n-                    let seq = self.parse_paren_expr_seq().map(|es| {\n-                        let nd = self.mk_call(e, es);\n-                        let hi = self.prev_span;\n-                        self.mk_expr(lo.to(hi), nd, AttrVec::new())\n-                    });\n-                    e = self.recover_seq_parse_error(token::Paren, lo, seq);\n-                }\n-\n-                // expr[...]\n-                // Could be either an index expression or a slicing expression.\n-                token::OpenDelim(token::Bracket) => {\n-                    self.bump();\n-                    let ix = self.parse_expr()?;\n-                    hi = self.token.span;\n-                    self.expect(&token::CloseDelim(token::Bracket))?;\n-                    let index = self.mk_index(e, ix);\n-                    e = self.mk_expr(lo.to(hi), index, AttrVec::new())\n-                }\n+            e = match self.token.kind {\n+                token::OpenDelim(token::Paren) => self.parse_fn_call_expr(lo, e),\n+                token::OpenDelim(token::Bracket) => self.parse_index_expr(lo, e)?,\n                 _ => return Ok(e),\n             }\n         }\n-        return Ok(e);\n+    }\n+\n+    fn parse_dot_suffix_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n+        match self.token.kind {\n+            token::Ident(..) => self.parse_dot_suffix(base, lo),\n+            token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n+                Ok(self.parse_tuple_field_access_expr(lo, base, symbol, suffix))\n+            }\n+            token::Literal(token::Lit { kind: token::Float, symbol, .. }) => {\n+                self.recover_field_access_by_float_lit(lo, base, symbol)\n+            }\n+            _ => {\n+                self.error_unexpected_after_dot();\n+                Ok(base)\n+            }\n+        }\n+    }\n+\n+    fn error_unexpected_after_dot(&self) {\n+        // FIXME Could factor this out into non_fatal_unexpected or something.\n+        let actual = pprust::token_to_string(&self.token);\n+        self.struct_span_err(self.token.span, &format!(\"unexpected token: `{}`\", actual)).emit();\n+    }\n+\n+    fn recover_field_access_by_float_lit(\n+        &mut self,\n+        lo: Span,\n+        base: P<Expr>,\n+        sym: Symbol,\n+    ) -> PResult<'a, P<Expr>> {\n+        self.bump();\n+\n+        let fstr = sym.as_str();\n+        let msg = format!(\"unexpected token: `{}`\", sym);\n+\n+        let mut err = self.struct_span_err(self.prev_span, &msg);\n+        err.span_label(self.prev_span, \"unexpected token\");\n+\n+        if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n+            let float = match fstr.parse::<f64>() {\n+                Ok(f) => f,\n+                Err(_) => {\n+                    err.emit();\n+                    return Ok(base);\n+                }\n+            };\n+            let sugg = pprust::to_string(|s| {\n+                s.popen();\n+                s.print_expr(&base);\n+                s.s.word(\".\");\n+                s.print_usize(float.trunc() as usize);\n+                s.pclose();\n+                s.s.word(\".\");\n+                s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n+            });\n+            err.span_suggestion(\n+                lo.to(self.prev_span),\n+                \"try parenthesizing the first index\",\n+                sugg,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        Err(err)\n+    }\n+\n+    fn parse_tuple_field_access_expr(\n+        &mut self,\n+        lo: Span,\n+        base: P<Expr>,\n+        field: Symbol,\n+        suffix: Option<Symbol>,\n+    ) -> P<Expr> {\n+        let span = self.token.span;\n+        self.bump();\n+        let field = ExprKind::Field(base, Ident::new(field, span));\n+        self.expect_no_suffix(span, \"a tuple index\", suffix);\n+        self.mk_expr(lo.to(span), field, AttrVec::new())\n+    }\n+\n+    /// Parse a function call expression, `expr(...)`.\n+    fn parse_fn_call_expr(&mut self, lo: Span, fun: P<Expr>) -> P<Expr> {\n+        let seq = self.parse_paren_expr_seq().map(|args| {\n+            self.mk_expr(lo.to(self.prev_span), self.mk_call(fun, args), AttrVec::new())\n+        });\n+        self.recover_seq_parse_error(token::Paren, lo, seq)\n+    }\n+\n+    /// Parse an indexing expression `expr[...]`.\n+    fn parse_index_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n+        self.bump(); // `[`\n+        let index = self.parse_expr()?;\n+        self.expect(&token::CloseDelim(token::Bracket))?;\n+        Ok(self.mk_expr(lo.to(self.prev_span), self.mk_index(base, index), AttrVec::new()))\n     }\n \n     /// Assuming we have just parsed `.`, continue parsing into an expression.\n@@ -794,25 +812,22 @@ impl<'a> Parser<'a> {\n         let segment = self.parse_path_segment(PathStyle::Expr)?;\n         self.check_trailing_angle_brackets(&segment, token::OpenDelim(token::Paren));\n \n-        Ok(match self.token.kind {\n-            token::OpenDelim(token::Paren) => {\n-                // Method call `expr.f()`\n-                let mut args = self.parse_paren_expr_seq()?;\n-                args.insert(0, self_arg);\n+        if self.check(&token::OpenDelim(token::Paren)) {\n+            // Method call `expr.f()`\n+            let mut args = self.parse_paren_expr_seq()?;\n+            args.insert(0, self_arg);\n \n-                let span = lo.to(self.prev_span);\n-                self.mk_expr(span, ExprKind::MethodCall(segment, args), AttrVec::new())\n+            let span = lo.to(self.prev_span);\n+            Ok(self.mk_expr(span, ExprKind::MethodCall(segment, args), AttrVec::new()))\n+        } else {\n+            // Field access `expr.f`\n+            if let Some(args) = segment.args {\n+                self.span_err(args.span(), \"field expressions may not have generic arguments\");\n             }\n-            _ => {\n-                // Field access `expr.f`\n-                if let Some(args) = segment.args {\n-                    self.span_err(args.span(), \"field expressions may not have generic arguments\");\n-                }\n \n-                let span = lo.to(self.prev_span);\n-                self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), AttrVec::new())\n-            }\n-        })\n+            let span = lo.to(self.prev_span);\n+            Ok(self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), AttrVec::new()))\n+        }\n     }\n \n     /// At the bottom (top?) of the precedence hierarchy,\n@@ -1117,7 +1132,7 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n         self.parse_opt_lit().ok_or_else(|| {\n-            let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n+            let msg = format!(\"unexpected token: {}\", super::token_descr(&self.token));\n             self.span_fatal(self.token.span, &msg)\n         })\n     }\n@@ -1143,14 +1158,7 @@ impl<'a> Parser<'a> {\n             });\n             if let Some(token) = &recovered {\n                 self.bump();\n-                self.struct_span_err(token.span, \"float literals must have an integer part\")\n-                    .span_suggestion(\n-                        token.span,\n-                        \"must have an integer part\",\n-                        pprust::token_to_string(token),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.error_float_lits_must_have_int_part(&token);\n             }\n         }\n \n@@ -1179,6 +1187,17 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn error_float_lits_must_have_int_part(&self, token: &Token) {\n+        self.struct_span_err(token.span, \"float literals must have an integer part\")\n+            .span_suggestion(\n+                token.span,\n+                \"must have an integer part\",\n+                pprust::token_to_string(token),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+    }\n+\n     fn report_lit_error(&self, err: LitError, lit: token::Lit, span: Span) {\n         // Checks if `s` looks like i32 or u1234 etc.\n         fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n@@ -1282,17 +1301,13 @@ impl<'a> Parser<'a> {\n     pub fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);\n \n-        let minus_lo = self.token.span;\n-        let minus_present = self.eat(&token::BinOp(token::Minus));\n         let lo = self.token.span;\n-        let literal = self.parse_lit()?;\n-        let hi = self.prev_span;\n-        let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), AttrVec::new());\n+        let minus_present = self.eat(&token::BinOp(token::Minus));\n+        let lit = self.parse_lit()?;\n+        let expr = self.mk_expr(lit.span, ExprKind::Lit(lit), AttrVec::new());\n \n         if minus_present {\n-            let minus_hi = self.prev_span;\n-            let unary = self.mk_unary(UnOp::Neg, expr);\n-            Ok(self.mk_expr(minus_lo.to(minus_hi), unary, AttrVec::new()))\n+            Ok(self.mk_expr(lo.to(self.prev_span), self.mk_unary(UnOp::Neg, expr), AttrVec::new()))\n         } else {\n             Ok(expr)\n         }\n@@ -1362,44 +1377,41 @@ impl<'a> Parser<'a> {\n \n     /// Parses the `|arg, arg|` header of a closure.\n     fn parse_fn_block_decl(&mut self) -> PResult<'a, P<FnDecl>> {\n-        let inputs_captures = {\n-            if self.eat(&token::OrOr) {\n-                Vec::new()\n-            } else {\n-                self.expect(&token::BinOp(token::Or))?;\n-                let args = self\n-                    .parse_seq_to_before_tokens(\n-                        &[&token::BinOp(token::Or), &token::OrOr],\n-                        SeqSep::trailing_allowed(token::Comma),\n-                        TokenExpectType::NoExpect,\n-                        |p| p.parse_fn_block_param(),\n-                    )?\n-                    .0;\n-                self.expect_or()?;\n-                args\n-            }\n+        let inputs = if self.eat(&token::OrOr) {\n+            Vec::new()\n+        } else {\n+            self.expect(&token::BinOp(token::Or))?;\n+            let args = self\n+                .parse_seq_to_before_tokens(\n+                    &[&token::BinOp(token::Or), &token::OrOr],\n+                    SeqSep::trailing_allowed(token::Comma),\n+                    TokenExpectType::NoExpect,\n+                    |p| p.parse_fn_block_param(),\n+                )?\n+                .0;\n+            self.expect_or()?;\n+            args\n         };\n         let output = self.parse_ret_ty(true, true)?;\n \n-        Ok(P(FnDecl { inputs: inputs_captures, output }))\n+        Ok(P(FnDecl { inputs, output }))\n     }\n \n     /// Parses a parameter in a closure header (e.g., `|arg, arg|`).\n     fn parse_fn_block_param(&mut self) -> PResult<'a, Param> {\n         let lo = self.token.span;\n         let attrs = self.parse_outer_attributes()?;\n         let pat = self.parse_pat(PARAM_EXPECTED)?;\n-        let t = if self.eat(&token::Colon) {\n+        let ty = if self.eat(&token::Colon) {\n             self.parse_ty()?\n         } else {\n-            P(Ty { id: DUMMY_NODE_ID, kind: TyKind::Infer, span: self.prev_span })\n+            self.mk_ty(self.prev_span, TyKind::Infer)\n         };\n-        let span = lo.to(self.token.span);\n         Ok(Param {\n             attrs: attrs.into(),\n-            ty: t,\n+            ty,\n             pat,\n-            span,\n+            span: lo.to(self.token.span),\n             id: DUMMY_NODE_ID,\n             is_placeholder: false,\n         })\n@@ -1414,28 +1426,29 @@ impl<'a> Parser<'a> {\n         // verify that the last statement is either an implicit return (no `;`) or an explicit\n         // return. This won't catch blocks with an explicit `return`, but that would be caught by\n         // the dead code lint.\n-        if self.eat_keyword(kw::Else) || !cond.returns() {\n-            let sp = self.sess.source_map().next_point(lo);\n-            let mut err =\n-                self.diagnostic().struct_span_err(sp, \"missing condition for `if` expression\");\n-            err.span_label(sp, \"expected if condition here\");\n-            return Err(err);\n-        }\n-        let not_block = self.token != token::OpenDelim(token::Brace);\n-        let thn = self.parse_block().map_err(|mut err| {\n-            if not_block {\n-                err.span_label(lo, \"this `if` statement has a condition, but no block\");\n-            }\n-            err\n-        })?;\n-        let mut els: Option<P<Expr>> = None;\n-        let mut hi = thn.span;\n-        if self.eat_keyword(kw::Else) {\n-            let elexpr = self.parse_else_expr()?;\n-            hi = elexpr.span;\n-            els = Some(elexpr);\n-        }\n-        Ok(self.mk_expr(lo.to(hi), ExprKind::If(cond, thn, els), attrs))\n+        let thn = if self.eat_keyword(kw::Else) || !cond.returns() {\n+            self.error_missing_if_cond(lo, cond.span)\n+        } else {\n+            let not_block = self.token != token::OpenDelim(token::Brace);\n+            self.parse_block().map_err(|mut err| {\n+                if not_block {\n+                    err.span_label(lo, \"this `if` expression has a condition, but no block\");\n+                }\n+                err\n+            })?\n+        };\n+        let els = if self.eat_keyword(kw::Else) { Some(self.parse_else_expr()?) } else { None };\n+        Ok(self.mk_expr(lo.to(self.prev_span), ExprKind::If(cond, thn, els), attrs))\n+    }\n+\n+    fn error_missing_if_cond(&self, lo: Span, span: Span) -> P<ast::Block> {\n+        let sp = self.sess.source_map().next_point(lo);\n+        self.struct_span_err(sp, \"missing condition for `if` expression\")\n+            .span_label(sp, \"expected if condition here\")\n+            .emit();\n+        let expr = self.mk_expr_err(span);\n+        let stmt = self.mk_stmt(span, ast::StmtKind::Expr(expr));\n+        self.mk_block(vec![stmt], BlockCheckMode::Default, span)\n     }\n \n     /// Parses the condition of a `if` or `while` expression.\n@@ -1467,22 +1480,20 @@ impl<'a> Parser<'a> {\n     /// Parses an `else { ... }` expression (`else` token already eaten).\n     fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n         if self.eat_keyword(kw::If) {\n-            return self.parse_if_expr(AttrVec::new());\n+            self.parse_if_expr(AttrVec::new())\n         } else {\n             let blk = self.parse_block()?;\n-            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()));\n+            Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()))\n         }\n     }\n \n-    /// Parses a `for ... in` expression (`for` token already eaten).\n+    /// Parses `for <src_pat> in <src_expr> <src_loop_block>` (`for` token already eaten).\n     fn parse_for_expr(\n         &mut self,\n         opt_label: Option<Label>,\n-        span_lo: Span,\n+        lo: Span,\n         mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n-        // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n-\n         // Record whether we are about to parse `for (`.\n         // This is used below for recovery in case of `for ( $stuff ) $block`\n         // in which case we will suggest `for $stuff $block`.\n@@ -1493,72 +1504,71 @@ impl<'a> Parser<'a> {\n \n         let pat = self.parse_top_pat(GateOr::Yes)?;\n         if !self.eat_keyword(kw::In) {\n-            let in_span = self.prev_span.between(self.token.span);\n-            self.struct_span_err(in_span, \"missing `in` in `for` loop\")\n-                .span_suggestion_short(\n-                    in_span,\n-                    \"try adding `in` here\",\n-                    \" in \".into(),\n-                    // has been misleading, at least in the past (closed Issue #48492)\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.error_missing_in_for_loop();\n         }\n-        let in_span = self.prev_span;\n-        self.check_for_for_in_in_typo(in_span);\n+        self.check_for_for_in_in_typo(self.prev_span);\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n \n         let pat = self.recover_parens_around_for_head(pat, &expr, begin_paren);\n \n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n \n-        let hi = self.prev_span;\n-        Ok(self.mk_expr(span_lo.to(hi), ExprKind::ForLoop(pat, expr, loop_block, opt_label), attrs))\n+        let kind = ExprKind::ForLoop(pat, expr, loop_block, opt_label);\n+        Ok(self.mk_expr(lo.to(self.prev_span), kind, attrs))\n+    }\n+\n+    fn error_missing_in_for_loop(&self) {\n+        let in_span = self.prev_span.between(self.token.span);\n+        self.struct_span_err(in_span, \"missing `in` in `for` loop\")\n+            .span_suggestion_short(\n+                in_span,\n+                \"try adding `in` here\",\n+                \" in \".into(),\n+                // Has been misleading, at least in the past (closed Issue #48492).\n+                Applicability::MaybeIncorrect,\n+            )\n+            .emit();\n     }\n \n     /// Parses a `while` or `while let` expression (`while` token already eaten).\n     fn parse_while_expr(\n         &mut self,\n         opt_label: Option<Label>,\n-        span_lo: Span,\n+        lo: Span,\n         mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         let cond = self.parse_cond_expr()?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        let span = span_lo.to(body.span);\n-        Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_label), attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_span), ExprKind::While(cond, body, opt_label), attrs))\n     }\n \n     /// Parses `loop { ... }` (`loop` token already eaten).\n     fn parse_loop_expr(\n         &mut self,\n         opt_label: Option<Label>,\n-        span_lo: Span,\n+        lo: Span,\n         mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        let span = span_lo.to(body.span);\n-        Ok(self.mk_expr(span, ExprKind::Loop(body, opt_label), attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_span), ExprKind::Loop(body, opt_label), attrs))\n     }\n \n     fn eat_label(&mut self) -> Option<Label> {\n-        if let Some(ident) = self.token.lifetime() {\n+        self.token.lifetime().map(|ident| {\n             let span = self.token.span;\n             self.bump();\n-            Some(Label { ident: Ident::new(ident.name, span) })\n-        } else {\n-            None\n-        }\n+            Label { ident: Ident::new(ident.name, span) }\n+        })\n     }\n \n     /// Parses a `match ... { ... }` expression (`match` token already eaten).\n     fn parse_match_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_span;\n         let lo = self.prev_span;\n-        let discriminant = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+        let scrutinee = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n             if self.token == token::Semi {\n                 e.span_suggestion_short(\n@@ -1584,13 +1594,13 @@ impl<'a> Parser<'a> {\n                     if self.token == token::CloseDelim(token::Brace) {\n                         self.bump();\n                     }\n-                    return Ok(self.mk_expr(span, ExprKind::Match(discriminant, arms), attrs));\n+                    return Ok(self.mk_expr(span, ExprKind::Match(scrutinee, arms), attrs));\n                 }\n             }\n         }\n         let hi = self.token.span;\n         self.bump();\n-        return Ok(self.mk_expr(lo.to(hi), ExprKind::Match(discriminant, arms), attrs));\n+        return Ok(self.mk_expr(lo.to(hi), ExprKind::Match(scrutinee, arms), attrs));\n     }\n \n     pub(super) fn parse_arm(&mut self) -> PResult<'a, Arm> {\n@@ -1699,16 +1709,13 @@ impl<'a> Parser<'a> {\n \n     /// Parses an `async move? {...}` expression.\n     fn parse_async_block(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let span_lo = self.token.span;\n+        let lo = self.token.span;\n         self.expect_keyword(kw::Async)?;\n         let capture_clause = self.parse_capture_clause();\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        Ok(self.mk_expr(\n-            span_lo.to(body.span),\n-            ExprKind::Async(capture_clause, DUMMY_NODE_ID, body),\n-            attrs,\n-        ))\n+        let kind = ExprKind::Async(capture_clause, DUMMY_NODE_ID, body);\n+        Ok(self.mk_expr(lo.to(self.prev_span), kind, attrs))\n     }\n \n     fn is_async_block(&self) -> bool {\n@@ -1723,48 +1730,49 @@ impl<'a> Parser<'a> {\n             ))\n     }\n \n+    fn is_certainly_not_a_block(&self) -> bool {\n+        self.look_ahead(1, |t| t.is_ident())\n+            && (\n+                // `{ ident, ` cannot start a block.\n+                self.look_ahead(2, |t| t == &token::Comma)\n+                    || self.look_ahead(2, |t| t == &token::Colon)\n+                        && (\n+                            // `{ ident: token, ` cannot start a block.\n+                            self.look_ahead(4, |t| t == &token::Comma) ||\n+                // `{ ident: ` cannot start a block unless it's a type ascription `ident: Type`.\n+                self.look_ahead(3, |t| !t.can_begin_type())\n+                        )\n+            )\n+    }\n+\n     fn maybe_parse_struct_expr(\n         &mut self,\n         lo: Span,\n         path: &ast::Path,\n         attrs: &AttrVec,\n     ) -> Option<PResult<'a, P<Expr>>> {\n         let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n-        let certainly_not_a_block = || {\n-            self.look_ahead(1, |t| t.is_ident())\n-                && (\n-                    // `{ ident, ` cannot start a block.\n-                    self.look_ahead(2, |t| t == &token::Comma)\n-                        || self.look_ahead(2, |t| t == &token::Colon)\n-                            && (\n-                                // `{ ident: token, ` cannot start a block.\n-                                self.look_ahead(4, |t| t == &token::Comma) ||\n-                // `{ ident: ` cannot start a block unless it's a type ascription `ident: Type`.\n-                self.look_ahead(3, |t| !t.can_begin_type())\n-                            )\n-                )\n-        };\n-\n-        if struct_allowed || certainly_not_a_block() {\n+        if struct_allowed || self.is_certainly_not_a_block() {\n             // This is a struct literal, but we don't can't accept them here.\n             let expr = self.parse_struct_expr(lo, path.clone(), attrs.clone());\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n-                self.struct_span_err(expr.span, \"struct literals are not allowed here\")\n-                    .multipart_suggestion(\n-                        \"surround the struct literal with parentheses\",\n-                        vec![\n-                            (lo.shrink_to_lo(), \"(\".to_string()),\n-                            (expr.span.shrink_to_hi(), \")\".to_string()),\n-                        ],\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.error_struct_lit_not_allowed_here(lo, expr.span);\n             }\n             return Some(expr);\n         }\n         None\n     }\n \n+    fn error_struct_lit_not_allowed_here(&self, lo: Span, sp: Span) {\n+        self.struct_span_err(sp, \"struct literals are not allowed here\")\n+            .multipart_suggestion(\n+                \"surround the struct literal with parentheses\",\n+                vec![(lo.shrink_to_lo(), \"(\".to_string()), (sp.shrink_to_hi(), \")\".to_string())],\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+    }\n+\n     pub(super) fn parse_struct_expr(\n         &mut self,\n         lo: Span,\n@@ -1782,50 +1790,19 @@ impl<'a> Parser<'a> {\n             if self.eat(&token::DotDot) {\n                 let exp_span = self.prev_span;\n                 match self.parse_expr() {\n-                    Ok(e) => {\n-                        base = Some(e);\n-                    }\n+                    Ok(e) => base = Some(e),\n                     Err(mut e) => {\n                         e.emit();\n                         self.recover_stmt();\n                     }\n                 }\n-                if self.token == token::Comma {\n-                    self.struct_span_err(\n-                        exp_span.to(self.prev_span),\n-                        \"cannot use a comma after the base struct\",\n-                    )\n-                    .span_suggestion_short(\n-                        self.token.span,\n-                        \"remove this comma\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .note(\"the base struct must always be the last field\")\n-                    .emit();\n-                    self.recover_stmt();\n-                }\n+                self.recover_struct_comma_after_dotdot(exp_span);\n                 break;\n             }\n \n-            let mut recovery_field = None;\n-            if let token::Ident(name, _) = self.token.kind {\n-                if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n-                    // Use in case of error after field-looking code: `S { foo: () with a }`.\n-                    recovery_field = Some(ast::Field {\n-                        ident: Ident::new(name, self.token.span),\n-                        span: self.token.span,\n-                        expr: self.mk_expr(self.token.span, ExprKind::Err, AttrVec::new()),\n-                        is_shorthand: false,\n-                        attrs: AttrVec::new(),\n-                        id: DUMMY_NODE_ID,\n-                        is_placeholder: false,\n-                    });\n-                }\n-            }\n-            let mut parsed_field = None;\n-            match self.parse_field() {\n-                Ok(f) => parsed_field = Some(f),\n+            let recovery_field = self.find_struct_error_after_field_looking_code();\n+            let parsed_field = match self.parse_field() {\n+                Ok(f) => Some(f),\n                 Err(mut e) => {\n                     e.span_label(struct_sp, \"while parsing this struct\");\n                     e.emit();\n@@ -1839,8 +1816,9 @@ impl<'a> Parser<'a> {\n                             break;\n                         }\n                     }\n+                    None\n                 }\n-            }\n+            };\n \n             match self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)]) {\n                 Ok(_) => {\n@@ -1863,53 +1841,91 @@ impl<'a> Parser<'a> {\n \n         let span = lo.to(self.token.span);\n         self.expect(&token::CloseDelim(token::Brace))?;\n-        return Ok(self.mk_expr(span, ExprKind::Struct(pth, fields, base), attrs));\n+        Ok(self.mk_expr(span, ExprKind::Struct(pth, fields, base), attrs))\n+    }\n+\n+    /// Use in case of error after field-looking code: `S { foo: () with a }`.\n+    fn find_struct_error_after_field_looking_code(&self) -> Option<Field> {\n+        if let token::Ident(name, _) = self.token.kind {\n+            if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n+                let span = self.token.span;\n+                return Some(ast::Field {\n+                    ident: Ident::new(name, span),\n+                    span,\n+                    expr: self.mk_expr_err(span),\n+                    is_shorthand: false,\n+                    attrs: AttrVec::new(),\n+                    id: DUMMY_NODE_ID,\n+                    is_placeholder: false,\n+                });\n+            }\n+        }\n+        None\n+    }\n+\n+    fn recover_struct_comma_after_dotdot(&mut self, span: Span) {\n+        if self.token != token::Comma {\n+            return;\n+        }\n+        self.struct_span_err(span.to(self.prev_span), \"cannot use a comma after the base struct\")\n+            .span_suggestion_short(\n+                self.token.span,\n+                \"remove this comma\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+            .note(\"the base struct must always be the last field\")\n+            .emit();\n+        self.recover_stmt();\n     }\n \n     /// Parses `ident (COLON expr)?`.\n     fn parse_field(&mut self) -> PResult<'a, Field> {\n-        let attrs = self.parse_outer_attributes()?;\n+        let attrs = self.parse_outer_attributes()?.into();\n         let lo = self.token.span;\n \n         // Check if a colon exists one ahead. This means we're parsing a fieldname.\n-        let (fieldname, expr, is_shorthand) =\n-            if self.look_ahead(1, |t| t == &token::Colon || t == &token::Eq) {\n-                let fieldname = self.parse_field_name()?;\n-\n-                // Check for an equals token. This means the source incorrectly attempts to\n-                // initialize a field with an eq rather than a colon.\n-                if self.token == token::Eq {\n-                    self.diagnostic()\n-                        .struct_span_err(self.token.span, \"expected `:`, found `=`\")\n-                        .span_suggestion(\n-                            fieldname.span.shrink_to_hi().to(self.token.span),\n-                            \"replace equals symbol with a colon\",\n-                            \":\".to_string(),\n-                            Applicability::MachineApplicable,\n-                        )\n-                        .emit();\n-                }\n-                self.bump(); // `:`\n-                (fieldname, self.parse_expr()?, false)\n-            } else {\n-                let fieldname = self.parse_ident_common(false)?;\n-\n-                // Mimic `x: x` for the `x` field shorthand.\n-                let path = ast::Path::from_ident(fieldname);\n-                let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), AttrVec::new());\n-                (fieldname, expr, true)\n-            };\n+        let is_shorthand = !self.look_ahead(1, |t| t == &token::Colon || t == &token::Eq);\n+        let (ident, expr) = if is_shorthand {\n+            // Mimic `x: x` for the `x` field shorthand.\n+            let ident = self.parse_ident_common(false)?;\n+            let path = ast::Path::from_ident(ident);\n+            (ident, self.mk_expr(ident.span, ExprKind::Path(None, path), AttrVec::new()))\n+        } else {\n+            let ident = self.parse_field_name()?;\n+            self.error_on_eq_field_init(ident);\n+            self.bump(); // `:`\n+            (ident, self.parse_expr()?)\n+        };\n         Ok(ast::Field {\n-            ident: fieldname,\n+            ident,\n             span: lo.to(expr.span),\n             expr,\n             is_shorthand,\n-            attrs: attrs.into(),\n+            attrs,\n             id: DUMMY_NODE_ID,\n             is_placeholder: false,\n         })\n     }\n \n+    /// Check for `=`. This means the source incorrectly attempts to\n+    /// initialize a field with an eq rather than a colon.\n+    fn error_on_eq_field_init(&self, field_name: Ident) {\n+        if self.token != token::Eq {\n+            return;\n+        }\n+\n+        self.diagnostic()\n+            .struct_span_err(self.token.span, \"expected `:`, found `=`\")\n+            .span_suggestion(\n+                field_name.span.shrink_to_hi().to(self.token.span),\n+                \"replace equals symbol with a colon\",\n+                \":\".to_string(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+    }\n+\n     fn err_dotdotdot_syntax(&self, span: Span) {\n         self.struct_span_err(span, \"unexpected token: `...`\")\n             .span_suggestion("}, {"sha": "343c6667d47d595d294a4a30467d1a42ffc08ac8", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -1348,7 +1348,7 @@ impl<'a> Parser<'a> {\n             self.expect_semi()?;\n             body\n         } else {\n-            let token_str = self.this_token_descr();\n+            let token_str = super::token_descr(&self.token);\n             let mut err = self.fatal(&format!(\n                 \"expected `where`, `{{`, `(`, or `;` after struct name, found {}\",\n                 token_str\n@@ -1374,7 +1374,7 @@ impl<'a> Parser<'a> {\n             let (fields, recovered) = self.parse_record_struct_body()?;\n             VariantData::Struct(fields, recovered)\n         } else {\n-            let token_str = self.this_token_descr();\n+            let token_str = super::token_descr(&self.token);\n             let mut err = self\n                 .fatal(&format!(\"expected `where` or `{{` after union name, found {}\", token_str));\n             err.span_label(self.token.span, \"expected `where` or `{` after union name\");\n@@ -1411,7 +1411,7 @@ impl<'a> Parser<'a> {\n             }\n             self.eat(&token::CloseDelim(token::Brace));\n         } else {\n-            let token_str = self.this_token_descr();\n+            let token_str = super::token_descr(&self.token);\n             let mut err = self.fatal(&format!(\n                 \"expected `where`, or `{{` after struct name, found {}\",\n                 token_str\n@@ -1498,7 +1498,7 @@ impl<'a> Parser<'a> {\n                 let sp = self.sess.source_map().next_point(self.prev_span);\n                 let mut err = self.struct_span_err(\n                     sp,\n-                    &format!(\"expected `,`, or `}}`, found {}\", self.this_token_descr()),\n+                    &format!(\"expected `,`, or `}}`, found {}\", super::token_descr(&self.token)),\n                 );\n                 if self.token.is_ident() {\n                     // This is likely another field; emit the diagnostic and keep going"}, {"sha": "103bbe5dd763e20aab519bf7a5e7d6cc7cacc8fe", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -354,6 +354,24 @@ pub enum FollowedByType {\n     No,\n }\n \n+fn token_descr_opt(token: &Token) -> Option<&'static str> {\n+    Some(match token.kind {\n+        _ if token.is_special_ident() => \"reserved identifier\",\n+        _ if token.is_used_keyword() => \"keyword\",\n+        _ if token.is_unused_keyword() => \"reserved keyword\",\n+        token::DocComment(..) => \"doc comment\",\n+        _ => return None,\n+    })\n+}\n+\n+pub(super) fn token_descr(token: &Token) -> String {\n+    let token_str = pprust::token_to_string(token);\n+    match token_descr_opt(token) {\n+        Some(prefix) => format!(\"{} `{}`\", prefix, token_str),\n+        _ => format!(\"`{}`\", token_str),\n+    }\n+}\n+\n impl<'a> Parser<'a> {\n     pub fn new(\n         sess: &'a ParseSess,\n@@ -422,29 +440,6 @@ impl<'a> Parser<'a> {\n         next\n     }\n \n-    /// Converts the current token to a string using `self`'s reader.\n-    pub fn this_token_to_string(&self) -> String {\n-        pprust::token_to_string(&self.token)\n-    }\n-\n-    fn token_descr(&self) -> Option<&'static str> {\n-        Some(match &self.token.kind {\n-            _ if self.token.is_special_ident() => \"reserved identifier\",\n-            _ if self.token.is_used_keyword() => \"keyword\",\n-            _ if self.token.is_unused_keyword() => \"reserved keyword\",\n-            token::DocComment(..) => \"doc comment\",\n-            _ => return None,\n-        })\n-    }\n-\n-    pub(super) fn this_token_descr(&self) -> String {\n-        if let Some(prefix) = self.token_descr() {\n-            format!(\"{} `{}`\", prefix, self.this_token_to_string())\n-        } else {\n-            format!(\"`{}`\", self.this_token_to_string())\n-        }\n-    }\n-\n     crate fn unexpected<T>(&mut self) -> PResult<'a, T> {\n         match self.expect_one_of(&[], &[]) {\n             Err(e) => Err(e),"}, {"sha": "3f54e0b6de031f7922368433a62760b50a415a32", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -79,7 +79,7 @@ impl<'a> Parser<'a> {\n         }\n \n         if !self.eat(term) {\n-            let token_str = self.this_token_descr();\n+            let token_str = super::token_descr(&self.token);\n             if !self.maybe_consume_incorrect_semicolon(&items) {\n                 let mut err = self.fatal(&format!(\"expected item, found {}\", token_str));\n                 err.span_label(self.token.span, \"expected item\");"}, {"sha": "d2288b27a0c40a775c6d229177ef58668fba6116", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -671,7 +671,7 @@ impl<'a> Parser<'a> {\n         err.cancel();\n \n         let expected = expected.unwrap_or(\"pattern\");\n-        let msg = format!(\"expected {}, found {}\", expected, self.this_token_descr());\n+        let msg = format!(\"expected {}, found {}\", expected, super::token_descr(&self.token));\n \n         let mut err = self.fatal(&msg);\n         err.span_label(self.token.span, format!(\"expected {}\", expected));\n@@ -876,7 +876,7 @@ impl<'a> Parser<'a> {\n                     etc_span = Some(etc_sp);\n                     break;\n                 }\n-                let token_str = self.this_token_descr();\n+                let token_str = super::token_descr(&self.token);\n                 let mut err = self.fatal(&format!(\"expected `}}`, found {}\", token_str));\n \n                 err.span_label(self.token.span, \"expected `}`\");"}, {"sha": "8270da6c0234f8f17fe4ce9a07452a7b4adf954b", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -323,7 +323,7 @@ impl<'a> Parser<'a> {\n \n     fn error_block_no_opening_brace<T>(&mut self) -> PResult<'a, T> {\n         let sp = self.token.span;\n-        let tok = self.this_token_descr();\n+        let tok = super::token_descr(&self.token);\n         let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n         let do_not_suggest_help = self.token.is_keyword(kw::In) || self.token == token::Colon;\n \n@@ -411,7 +411,7 @@ impl<'a> Parser<'a> {\n                 continue;\n             };\n         }\n-        Ok(P(ast::Block { stmts, id: DUMMY_NODE_ID, rules: s, span: lo.to(self.prev_span) }))\n+        Ok(self.mk_block(stmts, s, lo.to(self.prev_span)))\n     }\n \n     /// Parses a statement, including the trailing semicolon.\n@@ -463,15 +463,19 @@ impl<'a> Parser<'a> {\n     fn warn_missing_semicolon(&self) {\n         self.diagnostic()\n             .struct_span_warn(self.token.span, {\n-                &format!(\"expected `;`, found {}\", self.this_token_descr())\n+                &format!(\"expected `;`, found {}\", super::token_descr(&self.token))\n             })\n             .note({\n                 \"this was erroneously allowed and will become a hard error in a future release\"\n             })\n             .emit();\n     }\n \n-    fn mk_stmt(&self, span: Span, kind: StmtKind) -> Stmt {\n+    pub(super) fn mk_block(&self, stmts: Vec<Stmt>, rules: BlockCheckMode, span: Span) -> P<Block> {\n+        P(Block { stmts, id: DUMMY_NODE_ID, rules, span })\n+    }\n+\n+    pub(super) fn mk_stmt(&self, span: Span, kind: StmtKind) -> Stmt {\n         Stmt { id: DUMMY_NODE_ID, kind, span }\n     }\n }"}, {"sha": "049c077c3cea338abd50624d701bec86f8cebe76", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -135,7 +135,7 @@ impl<'a> Parser<'a> {\n                 TyKind::Err\n             }\n         } else {\n-            let msg = format!(\"expected type, found {}\", self.this_token_descr());\n+            let msg = format!(\"expected type, found {}\", super::token_descr(&self.token));\n             let mut err = self.struct_span_err(self.token.span, &msg);\n             err.span_label(self.token.span, \"expected type\");\n             self.maybe_annotate_with_ascription(&mut err, true);"}, {"sha": "4df51ff41f3f6441b8614eee2bff7d8821de8853", "filename": "src/libsyntax_expand/expand.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibsyntax_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibsyntax_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fexpand.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -904,10 +904,8 @@ pub fn ensure_complete_parse<'a>(\n     span: Span,\n ) {\n     if this.token != token::Eof {\n-        let msg = format!(\n-            \"macro expansion ignores token `{}` and any following\",\n-            this.this_token_to_string()\n-        );\n+        let token = pprust::token_to_string(&this.token);\n+        let msg = format!(\"macro expansion ignores token `{}` and any following\", token);\n         // Avoid emitting backtrace info twice.\n         let def_site_span = this.token.span.with_ctxt(SyntaxContext::root());\n         let mut err = this.struct_span_err(def_site_span, &msg);"}, {"sha": "fccc36e2ea8093a36601c87ed29fe7edaf763ef7", "filename": "src/libsyntax_ext/source_util.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibsyntax_ext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Flibsyntax_ext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fsource_util.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -133,15 +133,17 @@ pub fn expand_include<'cx>(\n             while self.p.token != token::Eof {\n                 match panictry!(self.p.parse_item()) {\n                     Some(item) => ret.push(item),\n-                    None => self\n-                        .p\n-                        .sess\n-                        .span_diagnostic\n-                        .span_fatal(\n-                            self.p.token.span,\n-                            &format!(\"expected item, found `{}`\", self.p.this_token_to_string()),\n-                        )\n-                        .raise(),\n+                    None => {\n+                        let token = pprust::token_to_string(&self.p.token);\n+                        self.p\n+                            .sess\n+                            .span_diagnostic\n+                            .span_fatal(\n+                                self.p.token.span,\n+                                &format!(\"expected item, found `{}`\", token),\n+                            )\n+                            .raise();\n+                    }\n                 }\n             }\n             Some(ret)"}, {"sha": "8025886a9eb46f2f2d7f8c17bd44a9b3c132207b", "filename": "src/test/ui/did_you_mean/issue-46836-identifier-not-instead-of-negation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-46836-identifier-not-instead-of-negation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-46836-identifier-not-instead-of-negation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-46836-identifier-not-instead-of-negation.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -26,7 +26,7 @@ error: expected `{`, found `;`\n   --> $DIR/issue-46836-identifier-not-instead-of-negation.rs:20:31\n    |\n LL |     if not  // lack of braces is [sic]\n-   |     -- this `if` statement has a condition, but no block\n+   |     -- this `if` expression has a condition, but no block\n LL |         println!(\"Then when?\");\n    |                               ^\n    |                               |"}, {"sha": "570a64e999cd018daea5b2f83eec08b488c28941", "filename": "src/test/ui/if/if-let.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fif%2Fif-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fif%2Fif-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-let.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -2,7 +2,7 @@ warning: irrefutable if-let pattern\n   --> $DIR/if-let.rs:6:13\n    |\n LL |               if let $p = $e $b\n-   |               ^^\n+   |               ^^^^^^^^^^^^^^^^^\n ...\n LL | /     foo!(a, 1, {\n LL | |         println!(\"irrefutable pattern\");\n@@ -15,7 +15,7 @@ warning: irrefutable if-let pattern\n   --> $DIR/if-let.rs:6:13\n    |\n LL |               if let $p = $e $b\n-   |               ^^\n+   |               ^^^^^^^^^^^^^^^^^\n ...\n LL | /     bar!(a, 1, {\n LL | |         println!(\"irrefutable pattern\");"}, {"sha": "8a4c59f32613d46de81544441f3251730cda3811", "filename": "src/test/ui/if/if-without-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fif%2Fif-without-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fif%2Fif-without-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-without-block.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     let n = 1;\n     if 5 == {\n-    //~^ NOTE this `if` statement has a condition, but no block\n+    //~^ NOTE this `if` expression has a condition, but no block\n         println!(\"five\");\n     }\n }"}, {"sha": "34df8e3d7794637656d5f27d1fc2aba52f618387", "filename": "src/test/ui/if/if-without-block.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fif%2Fif-without-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fif%2Fif-without-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-without-block.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -2,7 +2,7 @@ error: expected `{`, found `}`\n   --> $DIR/if-without-block.rs:7:1\n    |\n LL |     if 5 == {\n-   |     -- this `if` statement has a condition, but no block\n+   |     -- this `if` expression has a condition, but no block\n ...\n LL | }\n    | ^ expected `{`"}, {"sha": "a2fd9264b15308c1871a45fb63887879243750e6", "filename": "src/test/ui/issues/issue-13483.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-13483.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-13483.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13483.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -1,13 +1,15 @@\n fn main() {\n     if true {\n     } else if { //~ ERROR missing condition\n+    //~^ ERROR mismatched types\n     } else {\n     }\n }\n \n fn foo() {\n     if true {\n     } else if { //~ ERROR missing condition\n+    //~^ ERROR mismatched types\n     }\n     bar();\n }"}, {"sha": "5fd05b18ce06e6bfcda8df32b14beefb6b95f320", "filename": "src/test/ui/issues/issue-13483.stderr", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-13483.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-13483.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13483.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -5,10 +5,29 @@ LL |     } else if {\n    |              ^ expected if condition here\n \n error: missing condition for `if` expression\n-  --> $DIR/issue-13483.rs:10:14\n+  --> $DIR/issue-13483.rs:11:14\n    |\n LL |     } else if {\n    |              ^ expected if condition here\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13483.rs:3:15\n+   |\n+LL |       } else if {\n+   |  _______________^\n+LL | |\n+LL | |     } else {\n+   | |_____^ expected `bool`, found `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13483.rs:11:15\n+   |\n+LL |       } else if {\n+   |  _______________^\n+LL | |\n+LL | |     }\n+   | |_____^ expected `bool`, found `()`\n+\n+error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "11b145d6e0dc977e6da5e087e5759e62f40ac90b", "filename": "src/test/ui/issues/issue-39848.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -4,7 +4,7 @@ error: expected `{`, found `foo`\n LL |         if $tgt.has_$field() {}\n    |         --                -- help: try placing this code inside a block: `{ () }`\n    |         |\n-   |         this `if` statement has a condition, but no block\n+   |         this `if` expression has a condition, but no block\n ...\n LL |     get_opt!(bar, foo);\n    |                   ^^^ expected `{`"}, {"sha": "d800890bca38d18295bfd6cef55ff27f4c1029c6", "filename": "src/test/ui/issues/issue-51602.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-51602.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-51602.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51602.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -4,7 +4,7 @@ error: expected `{`, found keyword `in`\n LL |     if i in 1..10 {\n    |     --   ^^ expected `{`\n    |     |\n-   |     this `if` statement has a condition, but no block\n+   |     this `if` expression has a condition, but no block\n \n error: aborting due to previous error\n "}, {"sha": "8b95d9c6ae48b4b3d2431f3edf13402928a1d6bc", "filename": "src/test/ui/issues/issue-61858.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-61858.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-61858.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61858.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -4,7 +4,7 @@ error: expected `{`, found `)`\n LL |     (if foobar)\n    |      --       ^ expected `{`\n    |      |\n-   |      this `if` statement has a condition, but no block\n+   |      this `if` expression has a condition, but no block\n \n error: aborting due to previous error\n "}, {"sha": "d59546e23839ac2d2fe9a8f955a27214970d1666", "filename": "src/test/ui/issues/issue-62554.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-62554.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fissues%2Fissue-62554.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-62554.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -17,7 +17,7 @@ error: expected `{`, found `macro_rules`\n LL | fn foo(u: u8) { if u8 macro_rules! u8 { (u6) => { fn uuuuuuuuuuu() { use s loo mod u8 {\n    |                 --    ^^^^^^^^^^^ expected `{`\n    |                 |\n-   |                 this `if` statement has a condition, but no block\n+   |                 this `if` expression has a condition, but no block\n    |\n help: try placing this code inside a block\n    |"}, {"sha": "46b53c65b48179d4585a741580db4a48971ffb66", "filename": "src/test/ui/label/label_break_value_illegal_uses.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -12,7 +12,7 @@ LL |     if true 'b: {}\n    |     |       |\n    |     |       expected `{`\n    |     |       help: try placing this code inside a block: `{ 'b: {} }`\n-   |     this `if` statement has a condition, but no block\n+   |     this `if` expression has a condition, but no block\n \n error: expected `{`, found `'b`\n   --> $DIR/label_break_value_illegal_uses.rs:14:21"}, {"sha": "0f635817bf4624b7e5866245256bf956d89082f0", "filename": "src/test/ui/missing/missing-block-hint.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fmissing%2Fmissing-block-hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fmissing%2Fmissing-block-hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-block-hint.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -4,13 +4,13 @@ error: expected `{`, found `=>`\n LL |         if (foo) => {}\n    |         --       ^^ expected `{`\n    |         |\n-   |         this `if` statement has a condition, but no block\n+   |         this `if` expression has a condition, but no block\n \n error: expected `{`, found `bar`\n   --> $DIR/missing-block-hint.rs:7:13\n    |\n LL |         if (foo)\n-   |         -- this `if` statement has a condition, but no block\n+   |         -- this `if` expression has a condition, but no block\n LL |             bar;\n    |             ^^^-\n    |             |"}, {"sha": "e5ac59ae463010b1a6aff3c0cfc0886194055d4e", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad-2.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25434f898b499876203a3b95c1b38bad5ed2cc5d/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25434f898b499876203a3b95c1b38bad5ed2cc5d/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.rs?ref=25434f898b499876203a3b95c1b38bad5ed2cc5d", "patch": "@@ -1,2 +0,0 @@\n-#[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n-//~^ ERROR unexpected token: `#`"}, {"sha": "ca1043250ba78521178b2ec789374d7b173cfed1", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad-2.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25434f898b499876203a3b95c1b38bad5ed2cc5d/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25434f898b499876203a3b95c1b38bad5ed2cc5d/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.stderr?ref=25434f898b499876203a3b95c1b38bad5ed2cc5d", "patch": "@@ -1,8 +0,0 @@\n-error: unexpected token: `#`\n-  --> $DIR/attr-stmt-expr-attr-bad-2.rs:1:34\n-   |\n-LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n-   |                                  ^\n-\n-error: aborting due to previous error\n-"}, {"sha": "7dc71af52f4d97b234d57ca37719be438d87298a", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad-3.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25434f898b499876203a3b95c1b38bad5ed2cc5d/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25434f898b499876203a3b95c1b38bad5ed2cc5d/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.rs?ref=25434f898b499876203a3b95c1b38bad5ed2cc5d", "patch": "@@ -1,2 +0,0 @@\n-#[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n-//~^ ERROR unexpected token: `#`"}, {"sha": "ab9366d042a2c1acae5ed5e2778c0b931126760e", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad-3.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25434f898b499876203a3b95c1b38bad5ed2cc5d/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25434f898b499876203a3b95c1b38bad5ed2cc5d/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.stderr?ref=25434f898b499876203a3b95c1b38bad5ed2cc5d", "patch": "@@ -1,8 +0,0 @@\n-error: unexpected token: `#`\n-  --> $DIR/attr-stmt-expr-attr-bad-3.rs:1:34\n-   |\n-LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n-   |                                  ^\n-\n-error: aborting due to previous error\n-"}, {"sha": "6e1d72cd2f6e2033473ed6308eb240efbe5982a1", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -101,6 +101,13 @@ fn main() {}\n //~^ ERROR `X..=` range patterns are not supported\n //~| ERROR expected one of `=>`, `if`, or `|`, found `#`\n \n+#[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n+//~^ ERROR unexpected token: `#`\n+//~| ERROR expected one of `.`\n+#[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n+//~^ ERROR unexpected token: `#`\n+//~| ERROR expected one of `.`\n+\n // make sure we don't catch this bug again...\n #[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n //~^ ERROR expected statement after outer attribute"}, {"sha": "371d3f575a418b3682a8a713c889ff1d34f85c07", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -149,7 +149,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n    |                                --   ^       --- help: try placing this code inside a block: `{ {}; }`\n    |                                |    |\n    |                                |    expected `{`\n-   |                                this `if` statement has a condition, but no block\n+   |                                this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:43:38\n@@ -202,7 +202,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n    |                                             --   ^       --- help: try placing this code inside a block: `{ {}; }`\n    |                                             |    |\n    |                                             |    expected `{`\n-   |                                             this `if` statement has a condition, but no block\n+   |                                             this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:56:51\n@@ -225,7 +225,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n    |                                --           ^       --- help: try placing this code inside a block: `{ {}; }`\n    |                                |            |\n    |                                |            expected `{`\n-   |                                this `if` statement has a condition, but no block\n+   |                                this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:62:46\n@@ -278,7 +278,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}\n    |                                                     --           ^       --- help: try placing this code inside a block: `{ {}; }`\n    |                                                     |            |\n    |                                                     |            expected `{`\n-   |                                                     this `if` statement has a condition, but no block\n+   |                                                     this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:75:67\n@@ -380,11 +380,35 @@ error: expected one of `=>`, `if`, or `|`, found `#`\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n+error: unexpected token: `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:104:34\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n+   |                                  ^\n+\n+error: expected one of `.`, `;`, `?`, or an operator, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:104:34\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n+   |                                  ^ expected one of `.`, `;`, `?`, or an operator\n+\n+error: unexpected token: `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:107:34\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n+   |                                  ^\n+\n+error: expected one of `.`, `;`, `?`, or an operator, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:107:34\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n+   |                                  ^ expected one of `.`, `;`, `?`, or an operator\n+\n error: expected statement after outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:105:44\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:112:44\n    |\n LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n    |                                            ^\n \n-error: aborting due to 52 previous errors\n+error: aborting due to 56 previous errors\n "}, {"sha": "a720dd68bd0377baed1c590fe0e5632f6309b1c6", "filename": "src/test/ui/parser/doc-comment-in-if-statement.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -4,7 +4,7 @@ error: expected `{`, found doc comment `/*!*/`\n LL |     if true /*!*/ {}\n    |     --      ^^^^^ expected `{`\n    |     |\n-   |     this `if` statement has a condition, but no block\n+   |     this `if` expression has a condition, but no block\n \n error: aborting due to previous error\n "}, {"sha": "09f0d641de060ea5254b1905a845009b89d7e641", "filename": "src/test/ui/while-let.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fwhile-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3629b05f8f1b425a738bfe9fe9aedd47c5417a/src%2Ftest%2Fui%2Fwhile-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhile-let.stderr?ref=da3629b05f8f1b425a738bfe9fe9aedd47c5417a", "patch": "@@ -2,7 +2,7 @@ warning: irrefutable while-let pattern\n   --> $DIR/while-let.rs:7:13\n    |\n LL |               while let $p = $e $b\n-   |               ^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^\n ...\n LL | /     foo!(_a, 1, {\n LL | |         println!(\"irrefutable pattern\");\n@@ -15,7 +15,7 @@ warning: irrefutable while-let pattern\n   --> $DIR/while-let.rs:7:13\n    |\n LL |               while let $p = $e $b\n-   |               ^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^\n ...\n LL | /     bar!(_a, 1, {\n LL | |         println!(\"irrefutable pattern\");"}]}