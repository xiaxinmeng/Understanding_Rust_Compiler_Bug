{"sha": "127139aecd5c3a1227ee58c77fc083506125f7cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNzEzOWFlY2Q1YzNhMTIyN2VlNThjNzdmYzA4MzUwNjEyNWY3Y2Q=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-24T20:14:05Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-24T20:14:05Z"}, "message": "Parse crate directive tree in one pass, then evaluate it in a second.", "tree": {"sha": "a293dd6ff789de49d81098cf5d162180c86b6617", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a293dd6ff789de49d81098cf5d162180c86b6617"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/127139aecd5c3a1227ee58c77fc083506125f7cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/127139aecd5c3a1227ee58c77fc083506125f7cd", "html_url": "https://github.com/rust-lang/rust/commit/127139aecd5c3a1227ee58c77fc083506125f7cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/127139aecd5c3a1227ee58c77fc083506125f7cd/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ebd75a54757b06718fc87a72c20389a9e7f29d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ebd75a54757b06718fc87a72c20389a9e7f29d0", "html_url": "https://github.com/rust-lang/rust/commit/4ebd75a54757b06718fc87a72c20389a9e7f29d0"}], "stats": {"total": 129, "additions": 96, "deletions": 33}, "files": [{"sha": "088ef4ed9205f64d92420158ae159c5eb763f58c", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/127139aecd5c3a1227ee58c77fc083506125f7cd/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/127139aecd5c3a1227ee58c77fc083506125f7cd/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=127139aecd5c3a1227ee58c77fc083506125f7cd", "patch": "@@ -46,8 +46,9 @@ type crate_ = rec(_mod module);\n \n tag crate_directive_ {\n     cdir_expr(@expr);\n+    cdir_const(@item);\n     cdir_src_mod(ident, option.t[filename]);\n-    cdir_dir_mod(ident, option.t[filename], vec[crate_directive]);\n+    cdir_dir_mod(ident, option.t[filename], vec[@crate_directive]);\n     cdir_view_item(@view_item);\n     cdir_meta(@meta_item);\n     cdir_syntax(path);"}, {"sha": "944e14240bab8fcb46244843db165b88f4e28f16", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 94, "deletions": 32, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/127139aecd5c3a1227ee58c77fc083506125f7cd/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/127139aecd5c3a1227ee58c77fc083506125f7cd/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=127139aecd5c3a1227ee58c77fc083506125f7cd", "patch": "@@ -8,6 +8,7 @@ import std.map.hashmap;\n \n import driver.session;\n import util.common;\n+import util.common.filename;\n import util.common.append;\n import util.common.span;\n import util.common.new_str_hash;\n@@ -2110,9 +2111,81 @@ impure fn parse_crate_from_source_file(parser p) -> @ast.crate {\n //\n // Each directive imperatively extends its environment with 0 or more items.\n \n-impure fn parse_crate_directive(str prefix, parser p,\n-                                &mutable vec[@ast.item] items,\n-                                hashmap[ast.ident,ast.mod_index_entry] index)\n+impure fn eval_crate_directives(parser p,\n+                                vec[@ast.crate_directive] cdirs,\n+                                str prefix) -> ast._mod {\n+    let vec[@ast.item] items = vec();\n+    auto index = new_str_hash[ast.mod_index_entry]();\n+    auto view_items = parse_view(p, index);\n+\n+    for (@ast.crate_directive sub_cdir in cdirs) {\n+        eval_crate_directive(p, sub_cdir, prefix,\n+                             view_items, items, index);\n+    }\n+\n+    ret rec(view_items=view_items, items=items, index=index);\n+}\n+\n+impure fn eval_crate_directive(parser p,\n+                               @ast.crate_directive cdir,\n+                               str prefix,\n+                               &mutable vec[@ast.view_item] view_items,\n+                               &mutable vec[@ast.item] items,\n+                               hashmap[ast.ident,ast.mod_index_entry] index) {\n+    alt (cdir.node) {\n+        case (ast.cdir_expr(?e)) {}\n+        case (ast.cdir_const(?i)) {}\n+\n+        case (ast.cdir_src_mod(?id, ?file_opt)) {\n+\n+            auto file_path = id + \".rs\";\n+            alt (file_opt) {\n+                case (some[filename](?f)) {\n+                    file_path = f;\n+                }\n+                case (none[filename]) {}\n+            }\n+\n+            auto full_path = prefix + std.os.path_sep() + file_path;\n+\n+            auto p0 = new_parser(p.get_session(), 0, full_path);\n+            auto m0 = parse_mod_items(p0, token.EOF);\n+            auto im = ast.item_mod(id, m0, p.next_def_id());\n+            auto i = @spanned(cdir.span, cdir.span, im);\n+            ast.index_item(index, i);\n+            append[@ast.item](items, i);\n+        }\n+\n+        case (ast.cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n+\n+            auto path = id;\n+            alt (dir_opt) {\n+                case (some[filename](?d)) {\n+                    path = d;\n+                }\n+                case (none[filename]) {}\n+            }\n+\n+            auto full_path = prefix + std.os.path_sep() + path;\n+            auto m0 = eval_crate_directives(p, cdirs, path);\n+            auto im = ast.item_mod(id, m0, p.next_def_id());\n+            auto i = @spanned(cdir.span, cdir.span, im);\n+            ast.index_item(index, i);\n+            append[@ast.item](items, i);\n+        }\n+\n+        case (ast.cdir_view_item(?vi)) {\n+            append[@ast.view_item](view_items, vi);\n+            ast.index_view_item(index, vi);\n+        }\n+\n+        case (ast.cdir_meta(?mi)) {}\n+        case (ast.cdir_syntax(?pth)) {}\n+        case (ast.cdir_auth(?pth, ?eff)) {}\n+    }\n+}\n+\n+impure fn parse_crate_directive(parser p) -> ast.crate_directive\n {\n     auto lo = p.get_span();\n     auto hi = lo;\n@@ -2124,28 +2197,27 @@ impure fn parse_crate_directive(str prefix, parser p,\n             auto n = parse_path(p, GREEDY);\n             expect(p, token.EQ);\n             auto e = parse_effect(p);\n+            hi = p.get_span();\n             expect(p, token.SEMI);\n+            ret spanned(lo, hi, ast.cdir_auth(n, e));\n         }\n         case (token.CONST) {\n             auto c = parse_item_const(p);\n-            ast.index_item(index, c);\n-            append[@ast.item](items, c);\n+            ret spanned(c.span, c.span, ast.cdir_const(c));\n          }\n         case (token.MOD) {\n             p.bump();\n             auto id = parse_ident(p);\n-            auto file_path = id;\n+            auto file_opt = none[filename];\n             alt (p.peek()) {\n                 case (token.EQ) {\n                     p.bump();\n                     // FIXME: turn this into parse+eval expr\n-                    file_path = parse_str_lit(p);\n+                    file_opt = some[filename](parse_str_lit(p));\n                 }\n                 case (_) {}\n             }\n \n-            // dir-qualify file path.\n-            auto full_path = prefix + std.os.path_sep() + file_path;\n \n             alt (p.peek()) {\n \n@@ -2154,29 +2226,18 @@ impure fn parse_crate_directive(str prefix, parser p,\n                 case (token.SEMI) {\n                     hi = p.get_span();\n                     p.bump();\n-                    if (!_str.ends_with(full_path, \".rs\")) {\n-                        full_path += \".rs\";\n-                    }\n-                    auto p0 = new_parser(p.get_session(), 0, full_path);\n-                    auto m0 = parse_mod_items(p0, token.EOF);\n-                    auto im = ast.item_mod(id, m0, p.next_def_id());\n-                    auto i = @spanned(lo, hi, im);\n-                    ast.index_item(index, i);\n-                    append[@ast.item](items, i);\n+                    ret spanned(lo, hi, ast.cdir_src_mod(id, file_opt));\n                 }\n \n                 // mod x = \"foo_dir\" { ...directives... }\n \n                 case (token.LBRACE) {\n                     p.bump();\n-                    auto m0 = parse_crate_directives(full_path, p,\n-                                                     token.RBRACE);\n+                    auto cdirs = parse_crate_directives(p, token.RBRACE);\n                     hi = p.get_span();\n                     expect(p, token.RBRACE);\n-                    auto im = ast.item_mod(id, m0, p.next_def_id());\n-                    auto i = @spanned(lo, hi, im);\n-                    ast.index_item(index, i);\n-                    append[@ast.item](items, i);\n+                    ret spanned(lo, hi,\n+                                ast.cdir_dir_mod(id, file_opt, cdirs));\n                 }\n \n                 case (?t) {\n@@ -2185,27 +2246,28 @@ impure fn parse_crate_directive(str prefix, parser p,\n             }\n         }\n     }\n+    fail;\n }\n \n-impure fn parse_crate_directives(str prefix, parser p,\n-                                 token.token term) -> ast._mod {\n-    auto index = new_str_hash[ast.mod_index_entry]();\n-    auto view_items = parse_view(p, index);\n+impure fn parse_crate_directives(parser p, token.token term)\n+    -> vec[@ast.crate_directive] {\n \n-    let vec[@ast.item] items = vec();\n+    let vec[@ast.crate_directive] cdirs = vec();\n \n     while (p.peek() != term) {\n-        parse_crate_directive(prefix, p, items, index);\n+        auto cdir = @parse_crate_directive(p);\n+        append[@ast.crate_directive](cdirs, cdir);\n     }\n \n-    ret rec(view_items=view_items, items=items, index=index);\n+    ret cdirs;\n }\n \n impure fn parse_crate_from_crate_file(parser p) -> @ast.crate {\n     auto lo = p.get_span();\n     auto hi = lo;\n     auto prefix = std.path.dirname(lo.filename);\n-    auto m = parse_crate_directives(prefix, p, token.EOF);\n+    auto cdirs = parse_crate_directives(p, token.EOF);\n+    auto m = eval_crate_directives(p, cdirs, prefix);\n     hi = p.get_span();\n     expect(p, token.EOF);\n     ret @spanned(lo, hi, rec(module=m));"}]}