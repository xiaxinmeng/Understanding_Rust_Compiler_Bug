{"sha": "bfac337daab9b86971bcb3db61382ac44f94621c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYWMzMzdkYWFiOWI4Njk3MWJjYjNkYjYxMzgyYWM0NGY5NDYyMWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-17T17:15:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-17T17:15:54Z"}, "message": "Auto merge of #23330 - alexcrichton:thread-sleep, r=aturon\n\nThis function is the current replacement for `std::old_io::timer` which will\r\nsoon be deprecated. This function is unstable and has its own feature gate as it\r\ndoes not yet have an RFC nor has it existed for very long.", "tree": {"sha": "34bc72817ddffae38dde0fa30b8f35a0bc92e1d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34bc72817ddffae38dde0fa30b8f35a0bc92e1d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfac337daab9b86971bcb3db61382ac44f94621c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfac337daab9b86971bcb3db61382ac44f94621c", "html_url": "https://github.com/rust-lang/rust/commit/bfac337daab9b86971bcb3db61382ac44f94621c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfac337daab9b86971bcb3db61382ac44f94621c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "html_url": "https://github.com/rust-lang/rust/commit/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9"}, {"sha": "04cf5344111c357ad80335b88709281bb4bfaa0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/04cf5344111c357ad80335b88709281bb4bfaa0a", "html_url": "https://github.com/rust-lang/rust/commit/04cf5344111c357ad80335b88709281bb4bfaa0a"}], "stats": {"total": 418, "additions": 197, "deletions": 221}, "files": [{"sha": "f45daea18a21f3f2bc65e763f6cb6fdf648c54d2", "filename": "src/libstd/sys/common/thread.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bfac337daab9b86971bcb3db61382ac44f94621c/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfac337daab9b86971bcb3db61382ac44f94621c/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs?ref=bfac337daab9b86971bcb3db61382ac44f94621c", "patch": "@@ -8,28 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n+use prelude::v1::*;\n \n-use boxed::Box;\n-use mem;\n use usize;\n use libc;\n use thunk::Thunk;\n use sys_common::stack;\n-use sys::{thread, stack_overflow};\n+use sys::stack_overflow;\n \n // This is the starting point of rust os threads. The first thing we do\n // is make sure that we don't trigger __morestack (also why this has a\n // no_stack_check annotation), and then we extract the main function\n // and invoke it.\n #[no_stack_check]\n-pub fn start_thread(main: *mut libc::c_void) -> thread::rust_thread_return {\n+pub fn start_thread(main: *mut libc::c_void) {\n     unsafe {\n         stack::record_os_managed_stack_bounds(0, usize::MAX);\n-        let handler = stack_overflow::Handler::new();\n-        let f: Box<Thunk> = Box::from_raw(main as *mut Thunk);\n-        f.invoke(());\n-        drop(handler);\n-        mem::transmute(0 as thread::rust_thread_return)\n+        let _handler = stack_overflow::Handler::new();\n+        Box::from_raw(main as *mut Thunk).invoke(());\n     }\n }"}, {"sha": "045082949812bf605035c5c9c1d08faa383b1e45", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 137, "deletions": 181, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/bfac337daab9b86971bcb3db61382ac44f94621c/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfac337daab9b86971bcb3db61382ac44f94621c/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=bfac337daab9b86971bcb3db61382ac44f94621c", "patch": "@@ -12,71 +12,53 @@\n \n use core::prelude::*;\n \n-use io;\n-use boxed;\n-use boxed::Box;\n use cmp;\n+use ffi::CString;\n+use io;\n+use libc::consts::os::posix01::PTHREAD_STACK_MIN;\n+use libc;\n use mem;\n use ptr;\n-use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n-use libc;\n+use sys::os;\n use thunk::Thunk;\n-use ffi::CString;\n+use time::Duration;\n \n use sys_common::stack::RED_ZONE;\n use sys_common::thread::*;\n \n pub type rust_thread = libc::pthread_t;\n-pub type rust_thread_return = *mut u8;\n-pub type StartFn = extern \"C\" fn(*mut libc::c_void) -> rust_thread_return;\n-\n-#[no_stack_check]\n-pub extern fn thread_start(main: *mut libc::c_void) -> rust_thread_return {\n-    return start_thread(main);\n-}\n \n #[cfg(all(not(target_os = \"linux\"),\n           not(target_os = \"macos\"),\n           not(target_os = \"bitrig\"),\n           not(target_os = \"openbsd\")))]\n pub mod guard {\n-    pub unsafe fn current() -> uint {\n-        0\n-    }\n-\n-    pub unsafe fn main() -> uint {\n-        0\n-    }\n-\n-    pub unsafe fn init() {\n-    }\n+    pub unsafe fn current() -> usize { 0 }\n+    pub unsafe fn main() -> usize { 0 }\n+    pub unsafe fn init() {}\n }\n \n \n #[cfg(any(target_os = \"linux\",\n           target_os = \"macos\",\n           target_os = \"bitrig\",\n           target_os = \"openbsd\"))]\n+#[allow(unused_imports)]\n pub mod guard {\n-    use super::*;\n-    #[cfg(any(target_os = \"linux\",\n-              target_os = \"android\",\n-              target_os = \"bitrig\",\n-              target_os = \"openbsd\"))]\n-    use mem;\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    use ptr;\n-    use libc;\n-    use libc::funcs::posix88::mman::{mmap};\n+    use libc::{self, pthread_t};\n+    use libc::funcs::posix88::mman::mmap;\n     use libc::consts::os::posix88::{PROT_NONE,\n                                     MAP_PRIVATE,\n                                     MAP_ANON,\n                                     MAP_FAILED,\n                                     MAP_FIXED};\n+    use mem;\n+    use ptr;\n+    use super::{pthread_self, pthread_attr_destroy};\n+    use sys::os;\n \n     // These are initialized in init() and only read from after\n-    static mut PAGE_SIZE: uint = 0;\n-    static mut GUARD_PAGE: uint = 0;\n+    static mut GUARD_PAGE: usize = 0;\n \n     #[cfg(any(target_os = \"macos\",\n               target_os = \"bitrig\",\n@@ -88,28 +70,16 @@ pub mod guard {\n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     unsafe fn get_stack_start() -> *mut libc::c_void {\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n-        if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n-            panic!(\"failed to get thread attributes\");\n-        }\n+        assert_eq!(pthread_getattr_np(pthread_self(), &mut attr), 0);\n         let mut stackaddr = ptr::null_mut();\n         let mut stacksize = 0;\n-        if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n-            panic!(\"failed to get stack information\");\n-        }\n-        if pthread_attr_destroy(&mut attr) != 0 {\n-            panic!(\"failed to destroy thread attributes\");\n-        }\n+        assert_eq!(pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize), 0);\n+        assert_eq!(pthread_attr_destroy(&mut attr), 0);\n         stackaddr\n     }\n \n     pub unsafe fn init() {\n-        let psize = libc::sysconf(libc::consts::os::sysconf::_SC_PAGESIZE);\n-        if psize == -1 {\n-            panic!(\"failed to get page size\");\n-        }\n-\n-        PAGE_SIZE = psize as uint;\n-\n+        let psize = os::page_size();\n         let mut stackaddr = get_stack_start();\n \n         // Ensure stackaddr is page aligned! A parent process might\n@@ -118,17 +88,17 @@ pub mod guard {\n         // stackaddr < stackaddr + stacksize, so if stackaddr is not\n         // page-aligned, calculate the fix such that stackaddr <\n         // new_page_aligned_stackaddr < stackaddr + stacksize\n-        let remainder = (stackaddr as usize) % (PAGE_SIZE as usize);\n+        let remainder = (stackaddr as usize) % psize;\n         if remainder != 0 {\n-            stackaddr = ((stackaddr as usize) + (PAGE_SIZE as usize) - remainder)\n+            stackaddr = ((stackaddr as usize) + psize - remainder)\n                 as *mut libc::c_void;\n         }\n \n         // Rellocate the last page of the stack.\n         // This ensures SIGBUS will be raised on\n         // stack overflow.\n         let result = mmap(stackaddr,\n-                          PAGE_SIZE as libc::size_t,\n+                          psize as libc::size_t,\n                           PROT_NONE,\n                           MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n                           -1,\n@@ -138,139 +108,134 @@ pub mod guard {\n             panic!(\"failed to allocate a guard page\");\n         }\n \n-        let offset = if cfg!(target_os = \"linux\") {\n-            2\n-        } else {\n-            1\n-        };\n+        let offset = if cfg!(target_os = \"linux\") {2} else {1};\n \n-        GUARD_PAGE = stackaddr as uint + offset * PAGE_SIZE;\n+        GUARD_PAGE = stackaddr as usize + offset * psize;\n     }\n \n-    pub unsafe fn main() -> uint {\n+    pub unsafe fn main() -> usize {\n         GUARD_PAGE\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    pub unsafe fn current() -> uint {\n+    pub unsafe fn current() -> usize {\n+        extern {\n+            fn pthread_get_stackaddr_np(thread: pthread_t) -> *mut libc::c_void;\n+            fn pthread_get_stacksize_np(thread: pthread_t) -> libc::size_t;\n+        }\n         (pthread_get_stackaddr_np(pthread_self()) as libc::size_t -\n-         pthread_get_stacksize_np(pthread_self())) as uint\n+         pthread_get_stacksize_np(pthread_self())) as usize\n     }\n \n-    #[cfg(target_os = \"openbsd\")]\n-    pub unsafe fn current() -> uint {\n-        let mut current_stack: stack_t = mem::zeroed();\n-        if pthread_stackseg_np(pthread_self(), &mut current_stack) != 0 {\n-            panic!(\"failed to get current stack: pthread_stackseg_np\")\n+    #[cfg(any(target_os = \"openbsd\", target_os = \"bitrig\"))]\n+    pub unsafe fn current() -> usize {\n+        #[repr(C)]\n+        pub struct stack_t {\n+            ss_sp: *mut libc::c_void,\n+            ss_size: libc::size_t,\n+            ss_flags: libc::c_int,\n+        }\n+        extern {\n+            fn pthread_stackseg_np(thread: pthread_t,\n+                                   sinfo: *mut stack_t) -> libc::c_uint;\n         }\n \n+        let mut current_stack: stack_t = mem::zeroed();\n+        assert_eq!(pthread_stackseg_np(pthread_self(), &mut current_stack), 0);\n+\n+        let extra = if cfg!(target_os = \"bitrig\") {3} else {1} * os::page_size();\n         if pthread_main_np() == 1 {\n             // main thread\n-            current_stack.ss_sp as uint - current_stack.ss_size as uint + PAGE_SIZE as uint\n-\n+            current_stack.ss_sp as usize - current_stack.ss_size as usize + extra\n         } else {\n             // new thread\n-            current_stack.ss_sp as uint - current_stack.ss_size as uint\n+            current_stack.ss_sp as usize - current_stack.ss_size as usize\n         }\n     }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    pub unsafe fn current() -> uint {\n+    pub unsafe fn current() -> usize {\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n-        if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n-            panic!(\"failed to get thread attributes\");\n-        }\n+        assert_eq!(pthread_getattr_np(pthread_self(), &mut attr), 0);\n         let mut guardsize = 0;\n-        if pthread_attr_getguardsize(&attr, &mut guardsize) != 0 {\n-            panic!(\"failed to get stack guard page\");\n-        }\n+        assert_eq!(pthread_attr_getguardsize(&attr, &mut guardsize), 0);\n         if guardsize == 0 {\n             panic!(\"there is no guard page\");\n         }\n         let mut stackaddr = ptr::null_mut();\n-        let mut stacksize = 0;\n-        if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n-            panic!(\"failed to get stack information\");\n-        }\n-        if pthread_attr_destroy(&mut attr) != 0 {\n-            panic!(\"failed to destroy thread attributes\");\n-        }\n+        let mut size = 0;\n+        assert_eq!(pthread_attr_getstack(&attr, &mut stackaddr, &mut size), 0);\n+        assert_eq!(pthread_attr_destroy(&mut attr), 0);\n \n-        stackaddr as uint + guardsize as uint\n+        stackaddr as usize + guardsize as usize\n     }\n \n-    #[cfg(target_os = \"bitrig\")]\n-    pub unsafe fn current() -> uint {\n-      let mut current_stack: stack_t = mem::zeroed();\n-      if pthread_stackseg_np(pthread_self(), &mut current_stack) != 0 {\n-        panic!(\"failed to get current stack: pthread_stackseg_np\")\n-      }\n-\n-      if pthread_main_np() == 1 {\n-        // main thread\n-        current_stack.ss_sp as uint - current_stack.ss_size as uint + 3 * PAGE_SIZE as uint\n-      } else {\n-        // new thread\n-        current_stack.ss_sp as uint - current_stack.ss_size as uint\n-      }\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    extern {\n+        fn pthread_getattr_np(native: libc::pthread_t,\n+                              attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+        fn pthread_attr_getguardsize(attr: *const libc::pthread_attr_t,\n+                                     guardsize: *mut libc::size_t) -> libc::c_int;\n+        fn pthread_attr_getstack(attr: *const libc::pthread_attr_t,\n+                                 stackaddr: *mut *mut libc::c_void,\n+                                 stacksize: *mut libc::size_t) -> libc::c_int;\n     }\n }\n \n-pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n+pub unsafe fn create(stack: usize, p: Thunk) -> io::Result<rust_thread> {\n+    let p = box p;\n     let mut native: libc::pthread_t = mem::zeroed();\n     let mut attr: libc::pthread_attr_t = mem::zeroed();\n     assert_eq!(pthread_attr_init(&mut attr), 0);\n-    assert_eq!(pthread_attr_setdetachstate(&mut attr,\n-                                           PTHREAD_CREATE_JOINABLE), 0);\n \n     // Reserve room for the red zone, the runtime's stack of last resort.\n-    let stack_size = cmp::max(stack, RED_ZONE + min_stack_size(&attr) as uint);\n+    let stack_size = cmp::max(stack, RED_ZONE + min_stack_size(&attr) as usize);\n     match pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t) {\n-        0 => {\n-        },\n-        libc::EINVAL => {\n+        0 => {}\n+        n => {\n+            assert_eq!(n, libc::EINVAL);\n             // EINVAL means |stack_size| is either too small or not a\n             // multiple of the system page size.  Because it's definitely\n             // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n             // Round up to the nearest page and try again.\n-            let page_size = libc::sysconf(libc::_SC_PAGESIZE) as uint;\n+            let page_size = os::page_size();\n             let stack_size = (stack_size + page_size - 1) &\n-                             (-(page_size as int - 1) as uint - 1);\n-            assert_eq!(pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t), 0);\n-        },\n-        errno => {\n-            // This cannot really happen.\n-            panic!(\"pthread_attr_setstacksize() error: {}\", errno);\n-        },\n+                             (-(page_size as isize - 1) as usize - 1);\n+            assert_eq!(pthread_attr_setstacksize(&mut attr,\n+                                                 stack_size as libc::size_t), 0);\n+        }\n     };\n \n-    // must box since sizeof(p)=2*uint\n-    let raw_p = boxed::into_raw(box p);\n-    let arg = raw_p as *mut libc::c_void;\n-    let ret = pthread_create(&mut native, &attr, thread_start, arg);\n+    let ret = pthread_create(&mut native, &attr, thread_start,\n+                             &*p as *const _ as *mut _);\n     assert_eq!(pthread_attr_destroy(&mut attr), 0);\n \n-    if ret != 0 {\n-        // be sure to not leak the closure\n-        let _p: Box<Thunk> = Box::from_raw(raw_p);\n+    return if ret != 0 {\n         Err(io::Error::from_os_error(ret))\n     } else {\n+        mem::forget(p); // ownership passed to pthread_create\n         Ok(native)\n+    };\n+\n+    #[no_stack_check]\n+    extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n+        start_thread(main);\n+        0 as *mut _\n     }\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub unsafe fn set_name(name: &str) {\n     // pthread_setname_np() since glibc 2.12\n     // availability autodetected via weak linkage\n-    let cname = CString::new(name).unwrap();\n-    type F = unsafe extern \"C\" fn(libc::pthread_t, *const libc::c_char)\n-                                  -> libc::c_int;\n+    type F = unsafe extern fn(libc::pthread_t, *const libc::c_char)\n+                              -> libc::c_int;\n     extern {\n         #[linkage = \"extern_weak\"]\n         static pthread_setname_np: *const ();\n     }\n     if !pthread_setname_np.is_null() {\n+        let cname = CString::new(name).unwrap();\n         mem::transmute::<*const (), F>(pthread_setname_np)(pthread_self(),\n                                                            cname.as_ptr());\n     }\n@@ -281,14 +246,18 @@ pub unsafe fn set_name(name: &str) {\n           target_os = \"bitrig\",\n           target_os = \"openbsd\"))]\n pub unsafe fn set_name(name: &str) {\n-    // pthread_set_name_np() since almost forever on all BSDs\n+    extern {\n+        fn pthread_set_name_np(tid: libc::pthread_t, name: *const libc::c_char);\n+    }\n     let cname = CString::new(name).unwrap();\n     pthread_set_name_np(pthread_self(), cname.as_ptr());\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n pub unsafe fn set_name(name: &str) {\n-    // pthread_setname_np() since OS X 10.6 and iOS 3.2\n+    extern {\n+        fn pthread_setname_np(name: *const libc::c_char) -> libc::c_int;\n+    }\n     let cname = CString::new(name).unwrap();\n     pthread_setname_np(cname.as_ptr());\n }\n@@ -301,7 +270,42 @@ pub unsafe fn detach(native: rust_thread) {\n     assert_eq!(pthread_detach(native), 0);\n }\n \n-pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }\n+pub unsafe fn yield_now() {\n+    assert_eq!(sched_yield(), 0);\n+}\n+\n+pub fn sleep(dur: Duration) {\n+    unsafe {\n+        if dur < Duration::zero() {\n+            return yield_now()\n+        }\n+        let seconds = dur.num_seconds();\n+        let ns = dur - Duration::seconds(seconds);\n+        let mut ts = libc::timespec {\n+            tv_sec: seconds as libc::time_t,\n+            tv_nsec: ns.num_nanoseconds().unwrap() as libc::c_long,\n+        };\n+        // If we're awoken with a signal then the return value will be -1 and\n+        // nanosleep will fill in `ts` with the remaining time.\n+        while dosleep(&mut ts) == -1 {\n+            assert_eq!(os::errno(), libc::EINTR);\n+        }\n+    }\n+\n+    #[cfg(target_os = \"linux\")]\n+    unsafe fn dosleep(ts: *mut libc::timespec) -> libc::c_int {\n+        extern {\n+            fn clock_nanosleep(clock_id: libc::c_int, flags: libc::c_int,\n+                               request: *const libc::timespec,\n+                               remain: *mut libc::timespec) -> libc::c_int;\n+        }\n+        clock_nanosleep(libc::CLOCK_MONOTONIC, 0, ts, ts)\n+    }\n+    #[cfg(not(target_os = \"linux\"))]\n+    unsafe fn dosleep(ts: *mut libc::timespec) -> libc::c_int {\n+        libc::nanosleep(ts, ts)\n+    }\n+}\n \n // glibc >= 2.15 has a __pthread_get_minstack() function that returns\n // PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n@@ -334,67 +338,19 @@ fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t {\n     PTHREAD_STACK_MIN\n }\n \n-#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-extern {\n-    pub fn pthread_self() -> libc::pthread_t;\n-    pub fn pthread_getattr_np(native: libc::pthread_t,\n-                              attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-    pub fn pthread_attr_getguardsize(attr: *const libc::pthread_attr_t,\n-                                     guardsize: *mut libc::size_t) -> libc::c_int;\n-    pub fn pthread_attr_getstack(attr: *const libc::pthread_attr_t,\n-                                 stackaddr: *mut *mut libc::c_void,\n-                                 stacksize: *mut libc::size_t) -> libc::c_int;\n-}\n-\n-#[cfg(any(target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"openbsd\"))]\n extern {\n-    pub fn pthread_self() -> libc::pthread_t;\n-    fn pthread_set_name_np(tid: libc::pthread_t, name: *const libc::c_char);\n-}\n+    #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n+    fn pthread_main_np() -> libc::c_uint;\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-extern {\n-    pub fn pthread_self() -> libc::pthread_t;\n-    pub fn pthread_get_stackaddr_np(thread: libc::pthread_t) -> *mut libc::c_void;\n-    pub fn pthread_get_stacksize_np(thread: libc::pthread_t) -> libc::size_t;\n-    fn pthread_setname_np(name: *const libc::c_char) -> libc::c_int;\n-}\n-\n-#[cfg(target_os = \"bitrig\")]\n-extern {\n-    pub fn pthread_self() -> libc::pthread_t;\n-    pub fn pthread_stackseg_np(thread: libc::pthread_t,\n-                              sinfo: *mut stack_t) -> libc::c_uint;\n-    pub fn pthread_main_np() -> libc::c_uint;\n-    fn pthread_set_name_np(tid: libc::pthread_t, name: *const libc::c_char);\n-}\n-\n-#[cfg(target_os = \"openbsd\")]\n-extern {\n-        pub fn pthread_stackseg_np(thread: libc::pthread_t,\n-                                   sinfo: *mut stack_t) -> libc::c_uint;\n-        pub fn pthread_main_np() -> libc::c_uint;\n-}\n-\n-#[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-#[repr(C)]\n-pub struct stack_t {\n-    pub ss_sp: *mut libc::c_void,\n-    pub ss_size: libc::size_t,\n-    pub ss_flags: libc::c_int,\n-}\n-\n-extern {\n+    fn pthread_self() -> libc::pthread_t;\n     fn pthread_create(native: *mut libc::pthread_t,\n                       attr: *const libc::pthread_attr_t,\n-                      f: StartFn,\n+                      f: extern fn(*mut libc::c_void) -> *mut libc::c_void,\n                       value: *mut libc::c_void) -> libc::c_int;\n     fn pthread_join(native: libc::pthread_t,\n                     value: *mut *mut libc::c_void) -> libc::c_int;\n     fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-    pub fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+    fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n     fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n                                  stack_size: libc::size_t) -> libc::c_int;\n     fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,"}, {"sha": "d1d4ad90081bf536ddc3b8ca40351b126ad1b6f3", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/bfac337daab9b86971bcb3db61382ac44f94621c/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfac337daab9b86971bcb3db61382ac44f94621c/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=bfac337daab9b86971bcb3db61382ac44f94621c", "patch": "@@ -10,43 +10,28 @@\n \n use prelude::v1::*;\n \n-use boxed;\n use cmp;\n use io;\n-use ptr;\n-use libc;\n+use libc::{self, c_void};\n use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n                                    LPVOID, DWORD, LPDWORD, HANDLE};\n-use thunk::Thunk;\n+use mem;\n+use ptr;\n use sys_common::stack::RED_ZONE;\n use sys_common::thread::*;\n+use thunk::Thunk;\n+use time::Duration;\n \n pub type rust_thread = HANDLE;\n-pub type rust_thread_return = DWORD;\n-\n-pub type StartFn = extern \"system\" fn(*mut libc::c_void) -> rust_thread_return;\n-\n-#[no_stack_check]\n-pub extern \"system\" fn thread_start(main: *mut libc::c_void) -> rust_thread_return {\n-    return start_thread(main);\n-}\n \n pub mod guard {\n-    pub unsafe fn main() -> uint {\n-        0\n-    }\n-\n-    pub unsafe fn current() -> uint {\n-        0\n-    }\n-\n-    pub unsafe fn init() {\n-    }\n+    pub unsafe fn main() -> uint { 0 }\n+    pub unsafe fn current() -> uint { 0 }\n+    pub unsafe fn init() {}\n }\n \n-pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n-    let raw_p = boxed::into_raw(box p);\n-    let arg = raw_p as *mut libc::c_void;\n+pub unsafe fn create(stack: usize, p: Thunk) -> io::Result<rust_thread> {\n+    let p = box p;\n     // FIXME On UNIX, we guard against stack sizes that are too small but\n     // that's because pthreads enforces that stacks are at least\n     // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n@@ -58,14 +43,20 @@ pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n     // 20 kB red zone, that makes for a 64 kB minimum stack.\n     let stack_size = (cmp::max(stack, RED_ZONE) + 0xfffe) & (-0xfffe - 1);\n     let ret = CreateThread(ptr::null_mut(), stack_size as libc::size_t,\n-                           thread_start, arg, 0, ptr::null_mut());\n+                           thread_start, &*p as *const _ as *mut _,\n+                           0, ptr::null_mut());\n \n-    if ret as uint == 0 {\n-        // be sure to not leak the closure\n-        let _p: Box<Thunk> = Box::from_raw(raw_p);\n+    return if ret as usize == 0 {\n         Err(io::Error::last_os_error())\n     } else {\n+        mem::forget(p); // ownership passed to CreateThread\n         Ok(ret)\n+    };\n+\n+    #[no_stack_check]\n+    extern \"system\" fn thread_start(main: *mut libc::c_void) -> DWORD {\n+        start_thread(main);\n+        0\n     }\n }\n \n@@ -92,14 +83,29 @@ pub unsafe fn yield_now() {\n     SwitchToThread();\n }\n \n+pub fn sleep(dur: Duration) {\n+    unsafe {\n+        if dur < Duration::zero() {\n+            return yield_now()\n+        }\n+        let ms = dur.num_milliseconds();\n+        // if we have a fractional number of milliseconds then add an extra\n+        // millisecond to sleep for\n+        let extra = dur - Duration::milliseconds(ms);\n+        let ms = ms + if extra.is_zero() {0} else {1};\n+        Sleep(ms as DWORD);\n+    }\n+}\n+\n #[allow(non_snake_case)]\n extern \"system\" {\n     fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n                     dwStackSize: SIZE_T,\n-                    lpStartAddress: StartFn,\n+                    lpStartAddress: extern \"system\" fn(*mut c_void) -> DWORD,\n                     lpParameter: LPVOID,\n                     dwCreationFlags: DWORD,\n                     lpThreadId: LPDWORD) -> HANDLE;\n     fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n     fn SwitchToThread() -> BOOL;\n+    fn Sleep(dwMilliseconds: DWORD);\n }"}, {"sha": "d2742d4b45a59658e3c9bd711b8027b9d5e182ba", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bfac337daab9b86971bcb3db61382ac44f94621c/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfac337daab9b86971bcb3db61382ac44f94621c/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=bfac337daab9b86971bcb3db61382ac44f94621c", "patch": "@@ -379,6 +379,19 @@ pub fn panicking() -> bool {\n     unwind::panicking()\n }\n \n+/// Put the current thread to sleep for the specified amount of time.\n+///\n+/// The thread may sleep longer than the duration specified due to scheduling\n+/// specifics or platform-dependent functionality. Note that on unix platforms\n+/// this function will not return early due to a signal being received or a\n+/// spurious wakeup.\n+#[unstable(feature = \"thread_sleep\",\n+           reason = \"recently added, needs an RFC, and `Duration` itself is \\\n+                     unstable\")]\n+pub fn sleep(dur: Duration) {\n+    imp::sleep(dur)\n+}\n+\n /// Block unless or until the current thread's token is made available (may wake spuriously).\n ///\n /// See the module doc for more detail.\n@@ -935,6 +948,12 @@ mod test {\n         }\n     }\n \n+    #[test]\n+    fn sleep_smoke() {\n+        thread::sleep(Duration::milliseconds(2));\n+        thread::sleep(Duration::milliseconds(-2));\n+    }\n+\n     // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due\n     // to the test harness apparently interfering with stderr configuration.\n }"}]}