{"sha": "64b27e995e793d78ac873057393991c0dda9a178", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YjI3ZTk5NWU3OTNkNzhhYzg3MzA1NzM5Mzk5MWMwZGRhOWExNzg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-19T17:00:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-19T17:00:12Z"}, "message": "rollup merge of #17259 : eddyb/def-no-gc", "tree": {"sha": "67b295e588ac24acd7f14885ec4f24a73898d6d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67b295e588ac24acd7f14885ec4f24a73898d6d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64b27e995e793d78ac873057393991c0dda9a178", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64b27e995e793d78ac873057393991c0dda9a178", "html_url": "https://github.com/rust-lang/rust/commit/64b27e995e793d78ac873057393991c0dda9a178", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64b27e995e793d78ac873057393991c0dda9a178/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e5cb75766f35bf5b0bef21dfc12cc9bff0a072f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e5cb75766f35bf5b0bef21dfc12cc9bff0a072f", "html_url": "https://github.com/rust-lang/rust/commit/0e5cb75766f35bf5b0bef21dfc12cc9bff0a072f"}, {"sha": "74b8868b5f74f35b375c2a0eb0995f1a6101a7fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/74b8868b5f74f35b375c2a0eb0995f1a6101a7fa", "html_url": "https://github.com/rust-lang/rust/commit/74b8868b5f74f35b375c2a0eb0995f1a6101a7fa"}], "stats": {"total": 1042, "additions": 374, "deletions": 668}, "files": [{"sha": "4ff9133c8a534e9748c2beabee67dec375118f63", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -17,7 +17,7 @@ use lint;\n use llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n use metadata::creader;\n-use middle::{trans, freevars, stability, kind, ty, typeck, reachable};\n+use middle::{trans, stability, kind, ty, typeck, reachable};\n use middle::dependency_format;\n use middle;\n use plugin::load::Plugins;\n@@ -378,11 +378,13 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                           middle::lang_items::collect_language_items(krate, &sess));\n \n     let middle::resolve::CrateMap {\n-        def_map: def_map,\n-        exp_map2: exp_map2,\n-        trait_map: trait_map,\n-        external_exports: external_exports,\n-        last_private_map: last_private_map\n+        def_map,\n+        freevars,\n+        capture_mode_map,\n+        exp_map2,\n+        trait_map,\n+        external_exports,\n+        last_private_map\n     } =\n         time(time_passes, \"resolution\", (), |_|\n              middle::resolve::resolve_crate(&sess, &lang_items, krate));\n@@ -401,10 +403,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n             plugin::build::find_plugin_registrar(\n                 sess.diagnostic(), krate)));\n \n-    let (freevars, capture_modes) =\n-        time(time_passes, \"freevar finding\", (), |_|\n-             freevars::annotate_freevars(&def_map, krate));\n-\n     let region_map = time(time_passes, \"region resolution\", (), |_|\n                           middle::region::resolve_crate(&sess, krate));\n \n@@ -423,7 +421,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                             named_region_map,\n                             ast_map,\n                             freevars,\n-                            capture_modes,\n+                            capture_mode_map,\n                             region_map,\n                             lang_items,\n                             stability_index);"}, {"sha": "2994954c3d72726c64a5e6788caecb0a34babf6f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -29,7 +29,7 @@ This API is completely unstable and subject to change.\n       html_root_url = \"http://doc.rust-lang.org/master/\")]\n \n #![allow(deprecated)]\n-#![feature(macro_rules, globs, struct_variant, managed_boxes, quote)]\n+#![feature(macro_rules, globs, struct_variant, quote)]\n #![feature(default_type_params, phase, unsafe_destructor)]\n \n #![allow(unknown_features)] // NOTE: Remove after next snapshot\n@@ -93,7 +93,6 @@ pub mod middle {\n     pub mod effect;\n     pub mod entry;\n     pub mod expr_use_visitor;\n-    pub mod freevars;\n     pub mod graph;\n     pub mod intrinsicck;\n     pub mod kind;"}, {"sha": "3456e449a49f4b7e9e911e9c769e0fcd3ba743a0", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -954,8 +954,7 @@ impl LintPass for NonSnakeCase {\n         match &p.node {\n             &ast::PatIdent(_, ref path1, _) => {\n                 match cx.tcx.def_map.borrow().find(&p.id) {\n-                    Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n-                            Some(&def::DefArg(_, _)) => {\n+                    Some(&def::DefLocal(_)) => {\n                         self.check_snake_case(cx, \"variable\", path1.node, p.span);\n                     }\n                     _ => {}"}, {"sha": "feef7ffe847def1f9bedfc37deac0de1a09458d1", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -18,13 +18,12 @@ use driver::session::Session;\n use metadata::decoder;\n use middle::def;\n use metadata::encoder as e;\n-use middle::freevars::{CaptureMode, freevar_entry};\n-use middle::freevars;\n use middle::region;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n use metadata::tydecode::{RegionParameter};\n use metadata::tyencode;\n+use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n@@ -42,7 +41,6 @@ use syntax;\n use libc;\n use std::io::Seek;\n use std::mem;\n-use std::gc::GC;\n use std::rc::Rc;\n \n use rbml::io::SeekableMemWriter;\n@@ -462,8 +460,7 @@ impl tr for def::Def {\n           def::DefMod(did) => { def::DefMod(did.tr(dcx)) }\n           def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n           def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n-          def::DefArg(nid, b) => { def::DefArg(dcx.tr_id(nid), b) }\n-          def::DefLocal(nid, b) => { def::DefLocal(dcx.tr_id(nid), b) }\n+          def::DefLocal(nid) => { def::DefLocal(dcx.tr_id(nid)) }\n           def::DefVariant(e_did, v_did, is_s) => {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)\n           },\n@@ -472,11 +469,9 @@ impl tr for def::Def {\n           def::DefAssociatedTy(did) => def::DefAssociatedTy(did.tr(dcx)),\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n           def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(dcx), v),\n-          def::DefBinding(nid, bm) => def::DefBinding(dcx.tr_id(nid), bm),\n           def::DefUse(did) => def::DefUse(did.tr(dcx)),\n-          def::DefUpvar(nid1, def, nid2, nid3) => {\n+          def::DefUpvar(nid1, nid2, nid3) => {\n             def::DefUpvar(dcx.tr_id(nid1),\n-                           box(GC) (*def).tr(dcx),\n                            dcx.tr_id(nid2),\n                            dcx.tr_id(nid3))\n           }\n@@ -541,36 +536,36 @@ impl tr for ty::TraitStore {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &freevar_entry) {\n+fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &ty::Freevar) {\n     (*fv).encode(rbml_w).unwrap();\n }\n \n-fn encode_capture_mode(rbml_w: &mut Encoder, cm: CaptureMode) {\n+fn encode_capture_mode(rbml_w: &mut Encoder, cm: ast::CaptureClause) {\n     cm.encode(rbml_w).unwrap();\n }\n \n trait rbml_decoder_helper {\n     fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n-                          -> freevar_entry;\n-    fn read_capture_mode(&mut self) -> CaptureMode;\n+                          -> ty::Freevar;\n+    fn read_capture_mode(&mut self) -> ast::CaptureClause;\n }\n \n impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n     fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n-                          -> freevar_entry {\n-        let fv: freevar_entry = Decodable::decode(self).unwrap();\n+                          -> ty::Freevar {\n+        let fv: ty::Freevar = Decodable::decode(self).unwrap();\n         fv.tr(dcx)\n     }\n \n-    fn read_capture_mode(&mut self) -> CaptureMode {\n-        let cm: CaptureMode = Decodable::decode(self).unwrap();\n+    fn read_capture_mode(&mut self) -> ast::CaptureClause {\n+        let cm: ast::CaptureClause = Decodable::decode(self).unwrap();\n         cm\n     }\n }\n \n-impl tr for freevar_entry {\n-    fn tr(&self, dcx: &DecodeContext) -> freevar_entry {\n-        freevar_entry {\n+impl tr for ty::Freevar {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::Freevar {\n+        ty::Freevar {\n             def: self.def.tr(dcx),\n             span: self.span.tr(dcx),\n         }\n@@ -1292,8 +1287,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         });\n \n         for freevar in fv.iter() {\n-            match freevars::get_capture_mode(tcx, id) {\n-                freevars::CaptureByRef => {\n+            match tcx.capture_mode(id) {\n+                ast::CaptureByRef => {\n                     rbml_w.tag(c::tag_table_upvar_borrow_map, |rbml_w| {\n                         rbml_w.id(id);\n                         rbml_w.tag(c::tag_table_val, |rbml_w| {"}, {"sha": "95009bc2dbfc084ce661f3a809afa6b070032207", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -514,9 +514,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         true\n     }\n \n-    pub fn is_local_variable_or_arg(&self, cmt: mc::cmt) -> bool {\n+    fn is_local_variable_or_arg(&self, cmt: mc::cmt) -> bool {\n         match cmt.cat {\n-          mc::cat_local(_) | mc::cat_arg(_) => true,\n+          mc::cat_local(_) => true,\n           _ => false\n         }\n     }\n@@ -775,7 +775,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 debug!(\"mark_variable_as_used_mut(cmt={})\", cmt.repr(this.tcx()));\n                 match cmt.cat.clone() {\n                     mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id, .. }) |\n-                    mc::cat_local(id) | mc::cat_arg(id) => {\n+                    mc::cat_local(id) => {\n                         this.tcx().used_mut_nodes.borrow_mut().insert(id);\n                         return;\n                     }"}, {"sha": "25439fce68c9f1936412018c10bad0b27a4d7965", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -147,8 +147,7 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n         }\n \n         mc::cat_rvalue(..) |\n-        mc::cat_local(..) |\n-        mc::cat_arg(..) => {\n+        mc::cat_local(..) => {\n             None\n         }\n "}, {"sha": "c07123325253b37bd4bbb7d6b1da67698a3afd90", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -69,7 +69,6 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             mc::cat_rvalue(..) |\n             mc::cat_copied_upvar(..) |                  // L-Local\n             mc::cat_local(..) |                         // L-Local\n-            mc::cat_arg(..) |                           // L-Local\n             mc::cat_upvar(..) |\n             mc::cat_deref(_, _, mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n             mc::cat_deref(_, _, mc::Implicit(..)) |\n@@ -174,8 +173,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             mc::cat_static_item => {\n                 ty::ReStatic\n             }\n-            mc::cat_local(local_id) |\n-            mc::cat_arg(local_id) => {\n+            mc::cat_local(local_id) => {\n                 ty::ReScope(self.bccx.tcx.region_maps.var_scope(local_id))\n             }\n             mc::cat_deref(_, _, mc::UnsafePtr(..)) => {"}, {"sha": "e0018919b9823f57b4946d183991e3d64defe5f5", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -66,8 +66,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 Safe\n             }\n \n-            mc::cat_local(local_id) |\n-            mc::cat_arg(local_id) => {\n+            mc::cat_local(local_id) => {\n                 // R-Variable, locally declared\n                 let lp = Rc::new(LpVar(local_id));\n                 SafeIf(lp.clone(), vec![lp])"}, {"sha": "38b5c5f330270a12cd5237c3b94fec872bcfbd14", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -321,8 +321,7 @@ pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n             None\n         }\n \n-        mc::cat_local(id) |\n-        mc::cat_arg(id) => {\n+        mc::cat_local(id) => {\n             Some(Rc::new(LpVar(id)))\n         }\n "}, {"sha": "1863a19b56d02ad462992580a00b7b1c49a423b4", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -12,8 +12,6 @@ use middle::subst::ParamSpace;\n use syntax::ast;\n use syntax::ast_util::local_def;\n \n-use std::gc::Gc;\n-\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Def {\n     DefFn(ast::DefId, ast::FnStyle),\n@@ -22,20 +20,18 @@ pub enum Def {\n     DefMod(ast::DefId),\n     DefForeignMod(ast::DefId),\n     DefStatic(ast::DefId, bool /* is_mutbl */),\n-    DefArg(ast::NodeId, ast::BindingMode),\n-    DefLocal(ast::NodeId, ast::BindingMode),\n+    DefLocal(ast::NodeId),\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n     DefTy(ast::DefId, bool /* is_enum */),\n     DefAssociatedTy(ast::DefId),\n     DefTrait(ast::DefId),\n     DefPrimTy(ast::PrimTy),\n     DefTyParam(ParamSpace, ast::DefId, uint),\n-    DefBinding(ast::NodeId, ast::BindingMode),\n     DefUse(ast::DefId),\n-    DefUpvar(ast::NodeId,  // id of closed over var\n-             Gc<Def>,     // closed over def\n+    DefUpvar(ast::NodeId,  // id of closed over local\n              ast::NodeId,  // expr node that creates the closure\n-             ast::NodeId), // id for the block/body of the closure expr\n+             ast::NodeId), // block node for the closest enclosing proc\n+                           // or unboxed closure, DUMMY_NODE_ID otherwise\n \n     /// Note that if it's a tuple struct's definition, the node id of the ast::DefId\n     /// may either refer to the item definition's id or the StructDef.ctor_id.\n@@ -68,11 +64,9 @@ impl Def {\n             DefMethod(id, _) => {\n                 id\n             }\n-            DefArg(id, _) |\n-            DefLocal(id, _) |\n+            DefLocal(id) |\n             DefSelfTy(id) |\n-            DefUpvar(id, _, _, _) |\n-            DefBinding(id, _) |\n+            DefUpvar(id, _, _) |\n             DefRegion(id) |\n             DefTyParamBinder(id) |\n             DefLabel(id) => {"}, {"sha": "0a61911dfc9085e4bb230cf3af9bfc95c9138153", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -16,7 +16,7 @@\n \n use middle::mem_categorization as mc;\n use middle::def;\n-use middle::freevars;\n+use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::ty;\n use middle::typeck::{MethodCall, MethodObject, MethodOrigin, MethodParam};\n@@ -911,12 +911,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n \n         let tcx = self.typer.tcx();\n-        freevars::with_freevars(tcx, closure_expr.id, |freevars| {\n-            match freevars::get_capture_mode(self.tcx(), closure_expr.id) {\n-                freevars::CaptureByRef => {\n+        ty::with_freevars(tcx, closure_expr.id, |freevars| {\n+            match self.tcx().capture_mode(closure_expr.id) {\n+                ast::CaptureByRef => {\n                     self.walk_by_ref_captures(closure_expr, freevars);\n                 }\n-                freevars::CaptureByValue => {\n+                ast::CaptureByValue => {\n                     self.walk_by_value_captures(closure_expr, freevars);\n                 }\n             }\n@@ -925,7 +925,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n \n     fn walk_by_ref_captures(&mut self,\n                             closure_expr: &ast::Expr,\n-                            freevars: &[freevars::freevar_entry]) {\n+                            freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n             let id_var = freevar.def.def_id().node;\n             let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n@@ -950,7 +950,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n \n     fn walk_by_value_captures(&mut self,\n                               closure_expr: &ast::Expr,\n-                              freevars: &[freevars::freevar_entry]) {\n+                              freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n             let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                closure_expr.span,"}, {"sha": "5b7c72208ea7d181976aa2d0a0913c425352dbdf", "filename": "src/librustc/middle/freevars.rs", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cb75766f35bf5b0bef21dfc12cc9bff0a072f/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cb75766f35bf5b0bef21dfc12cc9bff0a072f/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=0e5cb75766f35bf5b0bef21dfc12cc9bff0a072f", "patch": "@@ -1,190 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// A pass that annotates for each loops and functions with the free\n-// variables that they contain.\n-\n-#![allow(non_camel_case_types)]\n-\n-use middle::def;\n-use middle::mem_categorization::Typer;\n-use middle::resolve;\n-use middle::ty;\n-use util::nodemap::{NodeMap, NodeSet};\n-\n-use syntax::ast;\n-use syntax::codemap::Span;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n-\n-#[deriving(Clone, Decodable, Encodable, Show)]\n-pub enum CaptureMode {\n-    /// Copy/move the value from this llvm ValueRef into the environment.\n-    CaptureByValue,\n-\n-    /// Access by reference (used for stack closures).\n-    CaptureByRef\n-}\n-\n-// A vector of defs representing the free variables referred to in a function.\n-// (The def_upvar will already have been stripped).\n-#[deriving(Encodable, Decodable)]\n-pub struct freevar_entry {\n-    pub def: def::Def, //< The variable being accessed free.\n-    pub span: Span     //< First span where it is accessed (there can be multiple)\n-}\n-\n-pub type freevar_map = NodeMap<Vec<freevar_entry>>;\n-\n-pub type CaptureModeMap = NodeMap<CaptureMode>;\n-\n-struct CollectFreevarsVisitor<'a> {\n-    seen: NodeSet,\n-    refs: Vec<freevar_entry>,\n-    def_map: &'a resolve::DefMap,\n-    capture_mode_map: &'a mut CaptureModeMap,\n-    depth: uint\n-}\n-\n-impl<'a, 'v> Visitor<'v> for CollectFreevarsVisitor<'a> {\n-    fn visit_item(&mut self, _: &ast::Item) {\n-        // ignore_item\n-    }\n-\n-    fn visit_expr(&mut self, expr: &ast::Expr) {\n-        match expr.node {\n-            ast::ExprProc(..) => {\n-                self.capture_mode_map.insert(expr.id, CaptureByValue);\n-                self.depth += 1;\n-                visit::walk_expr(self, expr);\n-                self.depth -= 1;\n-            }\n-            ast::ExprFnBlock(_, _, _) => {\n-                // NOTE(stage0): After snapshot, change to:\n-                //\n-                //let capture_mode = match capture_clause {\n-                //    ast::CaptureByValue => CaptureByValue,\n-                //    ast::CaptureByRef => CaptureByRef,\n-                //};\n-                let capture_mode = CaptureByRef;\n-                self.capture_mode_map.insert(expr.id, capture_mode);\n-                self.depth += 1;\n-                visit::walk_expr(self, expr);\n-                self.depth -= 1;\n-            }\n-            ast::ExprUnboxedFn(capture_clause, _, _, _) => {\n-                let capture_mode = match capture_clause {\n-                    ast::CaptureByValue => CaptureByValue,\n-                    ast::CaptureByRef => CaptureByRef,\n-                };\n-                self.capture_mode_map.insert(expr.id, capture_mode);\n-                self.depth += 1;\n-                visit::walk_expr(self, expr);\n-                self.depth -= 1;\n-            }\n-            ast::ExprPath(..) => {\n-                let mut def = *self.def_map.borrow().find(&expr.id)\n-                                                    .expect(\"path not found\");\n-                let mut i = 0;\n-                while i < self.depth {\n-                    match def {\n-                        def::DefUpvar(_, inner, _, _) => { def = *inner; }\n-                        _ => break\n-                    }\n-                    i += 1;\n-                }\n-                if i == self.depth { // Made it to end of loop\n-                    let dnum = def.def_id().node;\n-                    if !self.seen.contains(&dnum) {\n-                        self.refs.push(freevar_entry {\n-                            def: def,\n-                            span: expr.span,\n-                        });\n-                        self.seen.insert(dnum);\n-                    }\n-                }\n-            }\n-            _ => visit::walk_expr(self, expr)\n-        }\n-    }\n-}\n-\n-// Searches through part of the AST for all references to locals or\n-// upvars in this frame and returns the list of definition IDs thus found.\n-// Since we want to be able to collect upvars in some arbitrary piece\n-// of the AST, we take a walker function that we invoke with a visitor\n-// in order to start the search.\n-fn collect_freevars(def_map: &resolve::DefMap,\n-                    blk: &ast::Block,\n-                    capture_mode_map: &mut CaptureModeMap)\n-                    -> Vec<freevar_entry> {\n-    let mut v = CollectFreevarsVisitor {\n-        seen: NodeSet::new(),\n-        refs: Vec::new(),\n-        def_map: def_map,\n-        capture_mode_map: &mut *capture_mode_map,\n-        depth: 1\n-    };\n-\n-    v.visit_block(blk);\n-\n-    v.refs\n-}\n-\n-struct AnnotateFreevarsVisitor<'a> {\n-    def_map: &'a resolve::DefMap,\n-    freevars: freevar_map,\n-    capture_mode_map: CaptureModeMap,\n-}\n-\n-impl<'a, 'v> Visitor<'v> for AnnotateFreevarsVisitor<'a> {\n-    fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n-                blk: &'v ast::Block, s: Span, nid: ast::NodeId) {\n-        let vars = collect_freevars(self.def_map,\n-                                    blk,\n-                                    &mut self.capture_mode_map);\n-        self.freevars.insert(nid, vars);\n-        visit::walk_fn(self, fk, fd, blk, s);\n-    }\n-}\n-\n-// Build a map from every function and for-each body to a set of the\n-// freevars contained in it. The implementation is not particularly\n-// efficient as it fully recomputes the free variables at every\n-// node of interest rather than building up the free variables in\n-// one pass. This could be improved upon if it turns out to matter.\n-pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate)\n-                         -> (freevar_map, CaptureModeMap) {\n-    let mut visitor = AnnotateFreevarsVisitor {\n-        def_map: def_map,\n-        freevars: NodeMap::new(),\n-        capture_mode_map: NodeMap::new(),\n-    };\n-    visit::walk_crate(&mut visitor, krate);\n-\n-    let AnnotateFreevarsVisitor {\n-        freevars,\n-        capture_mode_map,\n-        ..\n-    } = visitor;\n-    (freevars, capture_mode_map)\n-}\n-\n-pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[freevar_entry]| -> T) -> T {\n-    match tcx.freevars.borrow().find(&fid) {\n-        None => fail!(\"with_freevars: {} has no freevars\", fid),\n-        Some(d) => f(d.as_slice())\n-    }\n-}\n-\n-pub fn get_capture_mode<'tcx, T:Typer<'tcx>>(tcx: &T, closure_expr_id: ast::NodeId)\n-                                             -> CaptureMode {\n-    tcx.capture_mode(closure_expr_id)\n-}"}, {"sha": "ad275e6e84cdea9335235040fe7c775fe856f243", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::freevars::freevar_entry;\n-use middle::freevars;\n use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty;\n@@ -146,10 +144,10 @@ fn check_item(cx: &mut Context, item: &Item) {\n fn with_appropriate_checker(cx: &Context,\n                             id: NodeId,\n                             fn_span: Span,\n-                            b: |checker: |&Context, &freevar_entry||) {\n+                            b: |checker: |&Context, &ty::Freevar||) {\n     fn check_for_uniq(cx: &Context,\n                       fn_span: Span,\n-                      fv: &freevar_entry,\n+                      fv: &ty::Freevar,\n                       bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n@@ -162,7 +160,7 @@ fn with_appropriate_checker(cx: &Context,\n     fn check_for_block(cx: &Context,\n                        fn_span: Span,\n                        fn_id: NodeId,\n-                       fv: &freevar_entry,\n+                       fv: &ty::Freevar,\n                        bounds: ty::BuiltinBounds) {\n         let id = fv.def.def_id().node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n@@ -177,7 +175,7 @@ fn with_appropriate_checker(cx: &Context,\n                              bounds, Some(var_t));\n     }\n \n-    fn check_for_bare(cx: &Context, fv: &freevar_entry) {\n+    fn check_for_bare(cx: &Context, fv: &ty::Freevar) {\n         span_err!(cx.tcx.sess, fv.span, E0143,\n                   \"can't capture dynamic environment in a fn item; \\\n                    use the || {} closure form instead\", \"{ ... }\");\n@@ -227,7 +225,7 @@ fn check_fn(\n \n     // <Check kinds on free variables:\n     with_appropriate_checker(cx, fn_id, sp, |chk| {\n-        freevars::with_freevars(cx.tcx, fn_id, |freevars| {\n+        ty::with_freevars(cx.tcx, fn_id, |freevars| {\n             for fv in freevars.iter() {\n                 chk(cx, fv);\n             }"}, {"sha": "74c889c614acb1e67a8a46e4d67090c802ab46fb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 12, "deletions": 32, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -103,7 +103,6 @@\n  */\n \n use middle::def::*;\n-use middle::freevars;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::ty;\n@@ -437,24 +436,15 @@ fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     visit::walk_arm(ir, arm);\n }\n \n-fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n-    match def {\n-        DefBinding(nid, _) |\n-        DefArg(nid, _) |\n-        DefLocal(nid, _) => Some(nid),\n-\n-      _ => None\n-    }\n-}\n-\n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) => {\n         let def = ir.tcx.def_map.borrow().get_copy(&expr.id);\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n-        if moved_variable_node_id_from_def(def).is_some() {\n-            ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        match def {\n+            DefLocal(..) => ir.add_live_node_for_node(expr.id, ExprNode(expr.span)),\n+            _ => {}\n         }\n         visit::walk_expr(ir, expr);\n       }\n@@ -468,15 +458,15 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        freevars::with_freevars(ir.tcx, expr.id, |freevars| {\n+        ty::with_freevars(ir.tcx, expr.id, |freevars| {\n             for fv in freevars.iter() {\n-                match moved_variable_node_id_from_def(fv.def) {\n-                    Some(rv) => {\n+                match fv.def {\n+                    DefLocal(rv) => {\n                         let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                         call_caps.push(CaptureInfo {ln: fv_ln,\n                                                     var_nid: rv});\n                     }\n-                    None => {}\n+                    _ => {}\n                 }\n             }\n         });\n@@ -1296,9 +1286,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                    -> LiveNode {\n-        let def = self.ir.tcx.def_map.borrow().get_copy(&expr.id);\n-        match moved_variable_node_id_from_def(def) {\n-          Some(nid) => {\n+        match self.ir.tcx.def_map.borrow().get_copy(&expr.id) {\n+          DefLocal(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n                 self.init_from_succ(ln, succ);\n@@ -1307,7 +1296,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n             ln\n           }\n-          None => succ\n+          _ => succ\n         }\n     }\n \n@@ -1537,7 +1526,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           ExprPath(_) => {\n             match self.ir.tcx.def_map.borrow().get_copy(&expr.id) {\n-              DefLocal(nid, _) => {\n+              DefLocal(nid) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually\n                 // mutable, then check for a reassignment to flag the mutability\n@@ -1546,16 +1535,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let var = self.variable(nid, expr.span);\n                 self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n               }\n-              def => {\n-                match moved_variable_node_id_from_def(def) {\n-                  Some(nid) => {\n-                    let ln = self.live_node(expr.id, expr.span);\n-                    let var = self.variable(nid, expr.span);\n-                    self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n-                  }\n-                  None => {}\n-                }\n-              }\n+              _ => {}\n             }\n           }\n "}, {"sha": "653b24f02558a51467f3c2877de5290afbddcdde", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 29, "deletions": 55, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -63,14 +63,14 @@\n #![allow(non_camel_case_types)]\n \n use middle::def;\n-use middle::freevars;\n use middle::ty;\n use middle::typeck;\n use util::nodemap::{DefIdMap, NodeMap};\n use util::ppaux::{ty_to_string, Repr};\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n use syntax::parse::token;\n@@ -85,7 +85,6 @@ pub enum categorization {\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into proc env\n     cat_upvar(ty::UpvarId, ty::UpvarBorrow), // by ref upvar from stack closure\n     cat_local(ast::NodeId),            // local variable\n-    cat_arg(ast::NodeId),              // formal argument\n     cat_deref(cmt, uint, PointerKind), // deref of a ptr\n     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n     cat_downcast(cmt),                 // selects a particular enum variant (*1)\n@@ -273,7 +272,7 @@ pub trait Typer<'tcx> {\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode;\n+                    -> ast::CaptureClause;\n     fn unboxed_closures<'a>(&'a self)\n                         -> &'a RefCell<DefIdMap<ty::UnboxedClosure>>;\n }\n@@ -312,28 +311,19 @@ impl MutabilityCategory {\n         }\n     }\n \n-    fn from_def(def: &def::Def) -> MutabilityCategory {\n-        match *def {\n-            def::DefFn(..) | def::DefStaticMethod(..) | def::DefSelfTy(..) |\n-            def::DefMod(..) | def::DefForeignMod(..) | def::DefVariant(..) |\n-            def::DefTy(..) | def::DefTrait(..) | def::DefPrimTy(..) |\n-            def::DefTyParam(..) | def::DefUse(..) | def::DefStruct(..) |\n-            def::DefTyParamBinder(..) | def::DefRegion(..) | def::DefLabel(..) |\n-            def::DefMethod(..) | def::DefAssociatedTy(..) => {\n-                fail!(\"no MutabilityCategory for def: {}\", *def)\n-            }\n-\n-            def::DefStatic(_, false) => McImmutable,\n-            def::DefStatic(_, true) => McDeclared,\n-\n-            def::DefArg(_, binding_mode) |\n-            def::DefBinding(_, binding_mode) |\n-            def::DefLocal(_, binding_mode)  => match binding_mode {\n-                ast::BindByValue(ast::MutMutable) => McDeclared,\n-                _ => McImmutable\n+    fn from_local(tcx: &ty::ctxt, id: ast::NodeId) -> MutabilityCategory {\n+        match tcx.map.get(id) {\n+            ast_map::NodeLocal(p) | ast_map::NodeArg(p) => match p.node {\n+                ast::PatIdent(bind_mode, _, _) => {\n+                    if bind_mode == ast::BindByValue(ast::MutMutable) {\n+                        McDeclared\n+                    } else {\n+                        McImmutable\n+                    }\n+                }\n+                _ => tcx.sess.span_bug(p.span, \"expected identifier pattern\")\n             },\n-\n-            def::DefUpvar(_, def, _, _) => MutabilityCategory::from_def(&*def)\n+            _ => tcx.sess.span_bug(tcx.map.span(id), \"expected identifier pattern\")\n         }\n     }\n \n@@ -546,30 +536,17 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               }))\n           }\n \n-          def::DefStatic(_, _) => {\n+          def::DefStatic(_, mutbl) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n-                  mutbl: MutabilityCategory::from_def(&def),\n+                  mutbl: if mutbl { McDeclared } else { McImmutable},\n                   ty:expr_ty\n               }))\n           }\n \n-          def::DefArg(vid, _) => {\n-            // Idea: make this could be rewritten to model by-ref\n-            // stuff as `&const` and `&mut`?\n-\n-            Ok(Rc::new(cmt_ {\n-                id: id,\n-                span: span,\n-                cat: cat_arg(vid),\n-                mutbl: MutabilityCategory::from_def(&def),\n-                ty:expr_ty\n-            }))\n-          }\n-\n-          def::DefUpvar(var_id, _, fn_node_id, _) => {\n+          def::DefUpvar(var_id, fn_node_id, _) => {\n               let ty = if_ok!(self.node_ty(fn_node_id));\n               match ty::get(ty).sty {\n                   ty::ty_closure(ref closure_ty) => {\n@@ -597,7 +574,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                   onceness: closure_ty.onceness,\n                                   capturing_proc: fn_node_id,\n                               }),\n-                              mutbl: MutabilityCategory::from_def(&def),\n+                              mutbl: MutabilityCategory::from_local(self.tcx(), var_id),\n                               ty:expr_ty\n                           }))\n                       }\n@@ -620,7 +597,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                               onceness: onceness,\n                               capturing_proc: fn_node_id,\n                           }),\n-                          mutbl: MutabilityCategory::from_def(&def),\n+                          mutbl: MutabilityCategory::from_local(self.tcx(), var_id),\n                           ty: expr_ty\n                       }))\n                   }\n@@ -634,14 +611,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               }\n           }\n \n-          def::DefLocal(vid, _) |\n-          def::DefBinding(vid, _) => {\n-            // by-value/by-ref bindings are local variables\n+          def::DefLocal(vid) => {\n             Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_local(vid),\n-                mutbl: MutabilityCategory::from_def(&def),\n+                mutbl: MutabilityCategory::from_local(self.tcx(), vid),\n                 ty: expr_ty\n             }))\n           }\n@@ -1196,11 +1171,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           cat_rvalue(..) => {\n               \"non-lvalue\".to_string()\n           }\n-          cat_local(_) => {\n-              \"local variable\".to_string()\n-          }\n-          cat_arg(..) => {\n-              \"argument\".to_string()\n+          cat_local(vid) => {\n+              match self.tcx().map.find(vid) {\n+                  Some(ast_map::NodeArg(_)) => {\n+                      \"argument\".to_string()\n+                  }\n+                  _ => \"local variable\".to_string()\n+              }\n           }\n           cat_deref(ref base, _, pk) => {\n               match base.cat {\n@@ -1267,7 +1244,6 @@ impl cmt_ {\n             cat_static_item |\n             cat_copied_upvar(..) |\n             cat_local(..) |\n-            cat_arg(..) |\n             cat_deref(_, _, UnsafePtr(..)) |\n             cat_deref(_, _, GcPtr(..)) |\n             cat_deref(_, _, BorrowedPtr(..)) |\n@@ -1311,7 +1287,6 @@ impl cmt_ {\n             cat_rvalue(..) |\n             cat_local(..) |\n             cat_upvar(..) |\n-            cat_arg(_) |\n             cat_deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n                 None\n             }\n@@ -1363,8 +1338,7 @@ impl Repr for categorization {\n             cat_rvalue(..) |\n             cat_copied_upvar(..) |\n             cat_local(..) |\n-            cat_upvar(..) |\n-            cat_arg(..) => {\n+            cat_upvar(..) => {\n                 format!(\"{:?}\", *self)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {"}, {"sha": "cbf2e7634a12d25b7b776e0651b9131d5f6ea37b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 161, "deletions": 146, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -19,7 +19,8 @@ use middle::lang_items::LanguageItems;\n use middle::pat_util::pat_bindings;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use middle::ty::{ExplicitSelfCategory, StaticExplicitSelfCategory};\n-use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n+use middle::ty::{CaptureModeMap, Freevar, FreevarMap};\n+use util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DeclItem, DefId, Expr, ExprAgain, ExprBreak, ExprField};\n@@ -59,7 +60,6 @@ use syntax::visit::Visitor;\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n-use std::gc::GC;\n use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::uint;\n@@ -270,16 +270,16 @@ enum TypeParameters<'a> {\n         RibKind)\n }\n \n-// The rib kind controls the translation of argument or local definitions\n-// (`def_arg` or `def_local`) to upvars (`def_upvar`).\n+// The rib kind controls the translation of local\n+// definitions (`DefLocal`) to upvars (`DefUpvar`).\n \n enum RibKind {\n     // No translation needs to be applied.\n     NormalRibKind,\n \n-    // We passed through a function scope at the given node ID. Translate\n-    // upvars as appropriate.\n-    FunctionRibKind(NodeId /* func id */, NodeId /* body id */),\n+    // We passed through a closure scope at the given node ID.\n+    // Translate upvars as appropriate.\n+    ClosureRibKind(NodeId /* func id */, NodeId /* body id if proc or unboxed */),\n \n     // We passed through an impl or trait and are now in one of its\n     // methods. Allow references to ty params that impl or trait\n@@ -891,6 +891,9 @@ struct Resolver<'a> {\n     primitive_type_table: PrimitiveTypeTable,\n \n     def_map: DefMap,\n+    freevars: RefCell<FreevarMap>,\n+    freevars_seen: RefCell<NodeMap<NodeSet>>,\n+    capture_mode_map: RefCell<CaptureModeMap>,\n     export_map2: ExportMap2,\n     trait_map: TraitMap,\n     external_exports: ExternalExports,\n@@ -996,6 +999,9 @@ impl<'a> Resolver<'a> {\n             primitive_type_table: PrimitiveTypeTable::new(),\n \n             def_map: RefCell::new(NodeMap::new()),\n+            freevars: RefCell::new(NodeMap::new()),\n+            freevars_seen: RefCell::new(NodeMap::new()),\n+            capture_mode_map: RefCell::new(NodeMap::new()),\n             export_map2: RefCell::new(NodeMap::new()),\n             trait_map: NodeMap::new(),\n             used_imports: HashSet::new(),\n@@ -1895,8 +1901,7 @@ impl<'a> Resolver<'a> {\n                       ignoring {:?}\", def);\n               // Ignored; handled elsewhere.\n           }\n-          DefArg(..) | DefLocal(..) | DefPrimTy(..) |\n-          DefTyParam(..) | DefBinding(..) |\n+          DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n           DefUse(..) | DefUpvar(..) | DefRegion(..) |\n           DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n             fail!(\"didn't expect `{:?}`\", def);\n@@ -3828,155 +3833,164 @@ impl<'a> Resolver<'a> {\n         self.current_module = orig_module;\n     }\n \n-    /// Wraps the given definition in the appropriate number of `def_upvar`\n+    /// Wraps the given definition in the appropriate number of `DefUpvar`\n     /// wrappers.\n     fn upvarify(&self,\n                 ribs: &[Rib],\n-                rib_index: uint,\n                 def_like: DefLike,\n                 span: Span)\n                 -> Option<DefLike> {\n-        let mut def;\n-        let is_ty_param;\n-\n         match def_like {\n-            DlDef(d @ DefLocal(..)) | DlDef(d @ DefUpvar(..)) |\n-            DlDef(d @ DefArg(..)) | DlDef(d @ DefBinding(..)) => {\n-                def = d;\n-                is_ty_param = false;\n-            }\n-            DlDef(d @ DefTyParam(..)) |\n-            DlDef(d @ DefSelfTy(..)) => {\n-                def = d;\n-                is_ty_param = true;\n-            }\n-            _ => {\n-                return Some(def_like);\n-            }\n-        }\n+            DlDef(d @ DefUpvar(..)) => {\n+                self.session.span_bug(span,\n+                    format!(\"unexpected {} in bindings\", d).as_slice())\n+            }\n+            DlDef(d @ DefLocal(_)) => {\n+                let node_id = d.def_id().node;\n+                let mut def = d;\n+                let mut last_proc_body_id = ast::DUMMY_NODE_ID;\n+                for rib in ribs.iter() {\n+                    match rib.kind {\n+                        NormalRibKind => {\n+                            // Nothing to do. Continue.\n+                        }\n+                        ClosureRibKind(function_id, maybe_proc_body) => {\n+                            let prev_def = def;\n+                            if maybe_proc_body != ast::DUMMY_NODE_ID {\n+                                last_proc_body_id = maybe_proc_body;\n+                            }\n+                            def = DefUpvar(node_id, function_id, last_proc_body_id);\n \n-        let mut rib_index = rib_index + 1;\n-        while rib_index < ribs.len() {\n-            match ribs[rib_index].kind {\n-                NormalRibKind => {\n-                    // Nothing to do. Continue.\n-                }\n-                FunctionRibKind(function_id, body_id) => {\n-                    if !is_ty_param {\n-                        def = DefUpvar(def.def_id().node,\n-                                       box(GC) def,\n-                                       function_id,\n-                                       body_id);\n-                    }\n-                }\n-                MethodRibKind(item_id, _) => {\n-                  // If the def is a ty param, and came from the parent\n-                  // item, it's ok\n-                  match def {\n-                    DefTyParam(_, did, _) if {\n-                        self.def_map.borrow().find(&did.node).map(|x| *x)\n-                            == Some(DefTyParamBinder(item_id))\n-                    } => {\n-                      // ok\n-                    }\n+                            let mut seen = self.freevars_seen.borrow_mut();\n+                            let seen = seen.find_or_insert(function_id, NodeSet::new());\n+                            if seen.contains(&node_id) {\n+                                continue;\n+                            }\n+                            self.freevars.borrow_mut().find_or_insert(function_id, vec![])\n+                                         .push(Freevar { def: prev_def, span: span });\n+                            seen.insert(node_id);\n+                        }\n+                        MethodRibKind(item_id, _) => {\n+                            // If the def is a ty param, and came from the parent\n+                            // item, it's ok\n+                            match def {\n+                                DefTyParam(_, did, _) if {\n+                                    self.def_map.borrow().find_copy(&did.node)\n+                                        == Some(DefTyParamBinder(item_id))\n+                                } => {} // ok\n+                                DefSelfTy(did) if did == item_id => {} // ok\n+                                _ => {\n+                                    // This was an attempt to access an upvar inside a\n+                                    // named function item. This is not allowed, so we\n+                                    // report an error.\n \n-                    DefSelfTy(did) if {\n-                        did == item_id\n-                    } => {\n-                      // ok\n-                    }\n+                                    self.resolve_error(\n+                                        span,\n+                                        \"can't capture dynamic environment in a fn item; \\\n+                                        use the || { ... } closure form instead\");\n \n-                    _ => {\n-                    if !is_ty_param {\n-                        // This was an attempt to access an upvar inside a\n-                        // named function item. This is not allowed, so we\n-                        // report an error.\n+                                    return None;\n+                                }\n+                            }\n+                        }\n+                        ItemRibKind => {\n+                            // This was an attempt to access an upvar inside a\n+                            // named function item. This is not allowed, so we\n+                            // report an error.\n \n-                        self.resolve_error(\n-                            span,\n-                            \"can't capture dynamic environment in a fn item; \\\n-                            use the || { ... } closure form instead\");\n-                    } else {\n-                        // This was an attempt to use a type parameter outside\n-                        // its scope.\n+                            self.resolve_error(\n+                                span,\n+                                \"can't capture dynamic environment in a fn item; \\\n+                                use the || { ... } closure form instead\");\n \n-                        self.resolve_error(span,\n-                                              \"can't use type parameters from \\\n-                                              outer function; try using a local \\\n-                                              type parameter instead\");\n-                    }\n+                            return None;\n+                        }\n+                        ConstantItemRibKind => {\n+                            // Still doesn't deal with upvars\n+                            self.resolve_error(span,\n+                                               \"attempt to use a non-constant \\\n+                                                value in a constant\");\n \n-                    return None;\n+                        }\n                     }\n-                  }\n                 }\n-                ItemRibKind => {\n-                    if !is_ty_param {\n-                        // This was an attempt to access an upvar inside a\n-                        // named function item. This is not allowed, so we\n-                        // report an error.\n+                Some(DlDef(def))\n+            }\n+            DlDef(def @ DefTyParam(..)) |\n+            DlDef(def @ DefSelfTy(..)) => {\n+                for rib in ribs.iter() {\n+                    match rib.kind {\n+                        NormalRibKind | ClosureRibKind(..) => {\n+                            // Nothing to do. Continue.\n+                        }\n+                        MethodRibKind(item_id, _) => {\n+                            // If the def is a ty param, and came from the parent\n+                            // item, it's ok\n+                            match def {\n+                                DefTyParam(_, did, _) if {\n+                                    self.def_map.borrow().find_copy(&did.node)\n+                                        == Some(DefTyParamBinder(item_id))\n+                                } => {} // ok\n+                                DefSelfTy(did) if did == item_id => {} // ok\n \n-                        self.resolve_error(\n-                            span,\n-                            \"can't capture dynamic environment in a fn item; \\\n-                            use the || { ... } closure form instead\");\n-                    } else {\n-                        // This was an attempt to use a type parameter outside\n-                        // its scope.\n+                                _ => {\n+                                    // This was an attempt to use a type parameter outside\n+                                    // its scope.\n \n-                        self.resolve_error(span,\n-                                              \"can't use type parameters from \\\n-                                              outer function; try using a local \\\n-                                              type parameter instead\");\n-                    }\n+                                    self.resolve_error(span,\n+                                                        \"can't use type parameters from \\\n+                                                        outer function; try using a local \\\n+                                                        type parameter instead\");\n \n-                    return None;\n-                }\n-                ConstantItemRibKind => {\n-                    if is_ty_param {\n-                        // see #9186\n-                        self.resolve_error(span,\n-                                              \"cannot use an outer type \\\n-                                               parameter in this context\");\n-                    } else {\n-                        // Still doesn't deal with upvars\n-                        self.resolve_error(span,\n-                                              \"attempt to use a non-constant \\\n-                                               value in a constant\");\n-                    }\n+                                    return None;\n+                                }\n+                            }\n+                        }\n+                        ItemRibKind => {\n+                            // This was an attempt to use a type parameter outside\n+                            // its scope.\n \n+                            self.resolve_error(span,\n+                                               \"can't use type parameters from \\\n+                                                outer function; try using a local \\\n+                                                type parameter instead\");\n+\n+                            return None;\n+                        }\n+                        ConstantItemRibKind => {\n+                            // see #9186\n+                            self.resolve_error(span,\n+                                               \"cannot use an outer type \\\n+                                                parameter in this context\");\n+\n+                        }\n+                    }\n                 }\n+                Some(DlDef(def))\n             }\n-\n-            rib_index += 1;\n+            _ => Some(def_like)\n         }\n-\n-        return Some(DlDef(def));\n     }\n \n     fn search_ribs(&self,\n                    ribs: &[Rib],\n                    name: Name,\n                    span: Span)\n                    -> Option<DefLike> {\n-        // FIXME #4950: This should not use a while loop.\n         // FIXME #4950: Try caching?\n \n-        let mut i = ribs.len();\n-        while i != 0 {\n-            i -= 1;\n-            let binding_opt = ribs[i].bindings.borrow().find_copy(&name);\n-            match binding_opt {\n+        for (i, rib) in ribs.iter().enumerate().rev() {\n+            match rib.bindings.borrow().find_copy(&name) {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs, i, def_like, span);\n+                    return self.upvarify(ribs.slice_from(i + 1), def_like, span);\n                 }\n                 None => {\n                     // Continue.\n                 }\n             }\n         }\n \n-        return None;\n+        None\n     }\n \n     fn resolve_crate(&mut self, krate: &ast::Crate) {\n@@ -4970,22 +4984,7 @@ impl<'a> Resolver<'a> {\n                             debug!(\"(resolving pattern) binding `{}`\",\n                                    token::get_name(renamed));\n \n-                            let def = match mode {\n-                                RefutableMode => {\n-                                    // For pattern arms, we must use\n-                                    // `def_binding` definitions.\n-\n-                                    DefBinding(pattern.id, binding_mode)\n-                                }\n-                                LocalIrrefutableMode => {\n-                                    // But for locals, we use `def_local`.\n-                                    DefLocal(pattern.id, binding_mode)\n-                                }\n-                                ArgumentIrrefutableMode => {\n-                                    // And for function arguments, `def_arg`.\n-                                    DefArg(pattern.id, binding_mode)\n-                                }\n-                            };\n+                            let def = DefLocal(pattern.id);\n \n                             // Record the definition so that later passes\n                             // will be able to distinguish variants from\n@@ -5803,10 +5802,24 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprFnBlock(_, ref fn_decl, ref block) |\n-            ExprProc(ref fn_decl, ref block) |\n-            ExprUnboxedFn(_, _, ref fn_decl, ref block) => {\n-                self.resolve_function(FunctionRibKind(expr.id, block.id),\n+            ExprFnBlock(_, ref fn_decl, ref block) => {\n+                // NOTE(stage0): After snapshot, change to:\n+                //\n+                //self.capture_mode_map.borrow_mut().insert(expr.id, capture_clause);\n+                self.capture_mode_map.borrow_mut().insert(expr.id, ast::CaptureByRef);\n+                self.resolve_function(ClosureRibKind(expr.id, ast::DUMMY_NODE_ID),\n+                                      Some(&**fn_decl), NoTypeParameters,\n+                                      &**block);\n+            }\n+            ExprProc(ref fn_decl, ref block) => {\n+                self.capture_mode_map.borrow_mut().insert(expr.id, ast::CaptureByValue);\n+                self.resolve_function(ClosureRibKind(expr.id, block.id),\n+                                      Some(&**fn_decl), NoTypeParameters,\n+                                      &**block);\n+            }\n+            ExprUnboxedFn(capture_clause, _, ref fn_decl, ref block) => {\n+                self.capture_mode_map.borrow_mut().insert(expr.id, capture_clause);\n+                self.resolve_function(ClosureRibKind(expr.id, block.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n             }\n@@ -6237,6 +6250,8 @@ impl<'a> Resolver<'a> {\n \n pub struct CrateMap {\n     pub def_map: DefMap,\n+    pub freevars: RefCell<FreevarMap>,\n+    pub capture_mode_map: RefCell<CaptureModeMap>,\n     pub exp_map2: ExportMap2,\n     pub trait_map: TraitMap,\n     pub external_exports: ExternalExports,\n@@ -6250,13 +6265,13 @@ pub fn resolve_crate(session: &Session,\n                   -> CrateMap {\n     let mut resolver = Resolver::new(session, krate.span);\n     resolver.resolve(krate);\n-    let Resolver { def_map, export_map2, trait_map, last_private,\n-                   external_exports, .. } = resolver;\n     CrateMap {\n-        def_map: def_map,\n-        exp_map2: export_map2,\n-        trait_map: trait_map,\n-        external_exports: external_exports,\n-        last_private_map: last_private,\n+        def_map: resolver.def_map,\n+        freevars: resolver.freevars,\n+        capture_mode_map: resolver.capture_mode_map,\n+        exp_map2: resolver.export_map2,\n+        trait_map: resolver.trait_map,\n+        external_exports: resolver.external_exports,\n+        last_private_map: resolver.last_private,\n     }\n }"}, {"sha": "a2debe61e5f60f2240918dbabc229a166ca25d9d", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -230,11 +230,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefAssociatedTy(..) |\n             def::DefTrait(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n-            def::DefBinding(_, _) |\n-            def::DefArg(_, _) |\n-            def::DefLocal(_, _) |\n+            def::DefLocal(_) |\n             def::DefVariant(_, _, _) |\n-            def::DefUpvar(_, _, _, _) => Some(recorder::VarRef),\n+            def::DefUpvar(..) => Some(recorder::VarRef),\n \n             def::DefFn(_, _) => Some(recorder::FnRef),\n \n@@ -739,20 +737,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def = def_map.get(&ex.id);\n         let sub_span = self.span.span_for_last_ident(ex.span);\n         match *def {\n-            def::DefLocal(id, _) |\n-            def::DefArg(id, _) |\n-            def::DefUpvar(id, _, _, _) |\n-            def::DefBinding(id, _) => self.fmt.ref_str(recorder::VarRef,\n-                                                       ex.span,\n-                                                       sub_span,\n-                                                       ast_util::local_def(id),\n-                                                       self.cur_scope),\n-            def::DefStatic(def_id,_) |\n-            def::DefVariant(_, def_id, _) => self.fmt.ref_str(recorder::VarRef,\n-                                                              ex.span,\n-                                                              sub_span,\n-                                                              def_id,\n-                                                              self.cur_scope),\n+            def::DefUpvar(..) |\n+            def::DefLocal(..) |\n+            def::DefStatic(..) |\n+            def::DefVariant(..) => self.fmt.ref_str(recorder::VarRef,\n+                                                    ex.span,\n+                                                    sub_span,\n+                                                    def.def_id(),\n+                                                    self.cur_scope),\n             def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n                                                        ex.span,\n                                                        sub_span,\n@@ -813,8 +805,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefStaticMethod(_, _, _) => {\n                 self.write_sub_path_trait_truncated(path);\n             },\n-            def::DefLocal(_, _) |\n-            def::DefArg(_, _) |\n+            def::DefLocal(_) |\n             def::DefStatic(_,_) |\n             def::DefStruct(_) |\n             def::DefFn(_, _) => self.write_sub_paths_truncated(path),\n@@ -1382,12 +1373,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             }\n             let def = def_map.get(&id);\n             match *def {\n-                def::DefBinding(id, _)  => self.fmt.variable_str(p.span,\n-                                                                 sub_span,\n-                                                                 id,\n-                                                                 path_to_string(p).as_slice(),\n-                                                                 value.as_slice(),\n-                                                                 \"\"),\n+                def::DefLocal(id)  => self.fmt.variable_str(p.span,\n+                                                            sub_span,\n+                                                            id,\n+                                                            path_to_string(p).as_slice(),\n+                                                            value.as_slice(),\n+                                                            \"\"),\n                 def::DefVariant(_,id,_) => self.fmt.ref_str(ref_kind,\n                                                             p.span,\n                                                             sub_span,"}, {"sha": "68d0bb2d8b49805220a6e796172a7d989c31eed6", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 22, "deletions": 44, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -1226,8 +1226,7 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool {\n     match discr.node {\n         ast::ExprPath(..) => match bcx.def(discr.id) {\n-            def::DefArg(vid, _) | def::DefBinding(vid, _) |\n-            def::DefLocal(vid, _) | def::DefUpvar(vid, _, _, _) => {\n+            def::DefLocal(vid) | def::DefUpvar(vid, _, _) => {\n                 let mut rc = ReassignmentChecker {\n                     node: vid,\n                     reassigned: false\n@@ -1259,7 +1258,7 @@ impl euv::Delegate for ReassignmentChecker {\n     fn mutate(&mut self, _: ast::NodeId, _: Span, cmt: mc::cmt, _: euv::MutateMode) {\n         match cmt.cat {\n             mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: vid, .. }) |\n-            mc::cat_arg(vid) | mc::cat_local(vid) => self.reassigned = self.node == vid,\n+            mc::cat_local(vid) => self.reassigned = self.node == vid,\n             _ => {}\n         }\n     }\n@@ -1391,13 +1390,6 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     return bcx;\n }\n \n-enum IrrefutablePatternBindingMode {\n-    // Stores the association between node ID and LLVM value in `lllocals`.\n-    BindLocal,\n-    // Stores the association between node ID and LLVM value in `llargs`.\n-    BindArgument\n-}\n-\n pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                local: &ast::Local)\n                                -> Block<'blk, 'tcx> {\n@@ -1419,7 +1411,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         pat_bindings(&tcx.def_map, pat, |_, p_id, _, path1| {\n             let scope = cleanup::var_scope(tcx, p_id);\n             bcx = mk_binding_alloca(\n-                bcx, p_id, &path1.node, BindLocal, scope, (),\n+                bcx, p_id, &path1.node, scope, (),\n                 |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n         });\n         bcx\n@@ -1441,7 +1433,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(ident) => {\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n-                        bcx, pat.id, ident, BindLocal, var_scope, (),\n+                        bcx, pat.id, ident, var_scope, (),\n                         |(), bcx, v, _| expr::trans_into(bcx, &**init_expr,\n                                                          expr::SaveIn(v)));\n                 }\n@@ -1459,7 +1451,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     add_comment(bcx, \"creating zeroable ref llval\");\n                 }\n                 let var_scope = cleanup::var_scope(tcx, local.id);\n-                bind_irrefutable_pat(bcx, pat, init_datum.val, BindLocal, var_scope)\n+                bind_irrefutable_pat(bcx, pat, init_datum.val, var_scope)\n             }\n         }\n         None => {\n@@ -1475,7 +1467,7 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              -> Block<'blk, 'tcx> {\n     /*!\n      * Generates code for argument patterns like `fn foo(<pat>: T)`.\n-     * Creates entries in the `llargs` map for each of the bindings\n+     * Creates entries in the `lllocals` map for each of the bindings\n      * in `pat`.\n      *\n      * # Arguments\n@@ -1499,12 +1491,12 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 // already put it in a temporary alloca and gave it up, unless\n                 // we emit extra-debug-info, which requires local allocas :(.\n                 let arg_val = arg.add_clean(bcx.fcx, arg_scope);\n-                bcx.fcx.llargs.borrow_mut()\n+                bcx.fcx.lllocals.borrow_mut()\n                    .insert(pat.id, Datum::new(arg_val, arg_ty, Lvalue));\n                 bcx\n             } else {\n                 mk_binding_alloca(\n-                    bcx, pat.id, ident, BindArgument, arg_scope, arg,\n+                    bcx, pat.id, ident, arg_scope, arg,\n                     |arg, bcx, llval, _| arg.store_to(bcx, llval))\n             }\n         }\n@@ -1514,8 +1506,7 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             // pattern.\n             let arg = unpack_datum!(\n                 bcx, arg.to_lvalue_datum_in_scope(bcx, \"__arg\", arg_scope));\n-            bind_irrefutable_pat(bcx, pat, arg.val,\n-                                 BindArgument, arg_scope)\n+            bind_irrefutable_pat(bcx, pat, arg.val, arg_scope)\n         }\n     }\n }\n@@ -1541,13 +1532,12 @@ pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     // General path. Copy out the values that are used in the pattern.\n-    bind_irrefutable_pat(bcx, pat, llvalue, BindLocal, body_scope)\n+    bind_irrefutable_pat(bcx, pat, llvalue, body_scope)\n }\n \n fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n                                     p_id: ast::NodeId,\n                                     ident: &ast::Ident,\n-                                    binding_mode: IrrefutablePatternBindingMode,\n                                     cleanup_scope: cleanup::ScopeId,\n                                     arg: A,\n                                     populate: |A, Block<'blk, 'tcx>, ValueRef, ty::t|\n@@ -1567,18 +1557,13 @@ fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n     // Now that memory is initialized and has cleanup scheduled,\n     // create the datum and insert into the local variable map.\n     let datum = Datum::new(llval, var_ty, Lvalue);\n-    let mut llmap = match binding_mode {\n-        BindLocal => bcx.fcx.lllocals.borrow_mut(),\n-        BindArgument => bcx.fcx.llargs.borrow_mut()\n-    };\n-    llmap.insert(p_id, datum);\n+    bcx.fcx.lllocals.borrow_mut().insert(p_id, datum);\n     bcx\n }\n \n fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     pat: &ast::Pat,\n                                     val: ValueRef,\n-                                    binding_mode: IrrefutablePatternBindingMode,\n                                     cleanup_scope: cleanup::ScopeId)\n                                     -> Block<'blk, 'tcx> {\n     /*!\n@@ -1594,13 +1579,11 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n      * - bcx: starting basic block context\n      * - pat: the irrefutable pattern being matched.\n      * - val: the value being matched -- must be an lvalue (by ref, with cleanup)\n-     * - binding_mode: is this for an argument or a local variable?\n      */\n \n-    debug!(\"bind_irrefutable_pat(bcx={}, pat={}, binding_mode={:?})\",\n+    debug!(\"bind_irrefutable_pat(bcx={}, pat={})\",\n            bcx.to_str(),\n-           pat.repr(bcx.tcx()),\n-           binding_mode);\n+           pat.repr(bcx.tcx()));\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, format!(\"bind_irrefutable_pat(pat={})\",\n@@ -1620,7 +1603,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // binding will live and place it into the appropriate\n                 // map.\n                 bcx = mk_binding_alloca(\n-                    bcx, pat.id, &path1.node, binding_mode, cleanup_scope, (),\n+                    bcx, pat.id, &path1.node, cleanup_scope, (),\n                     |(), bcx, llval, ty| {\n                         match pat_binding_mode {\n                             ast::BindByValue(_) => {\n@@ -1641,8 +1624,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n \n             for inner_pat in inner.iter() {\n-                bcx = bind_irrefutable_pat(bcx, &**inner_pat, val,\n-                                           binding_mode, cleanup_scope);\n+                bcx = bind_irrefutable_pat(bcx, &**inner_pat, val, cleanup_scope);\n             }\n         }\n         ast::PatEnum(_, ref sub_pats) => {\n@@ -1660,8 +1642,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     for sub_pat in sub_pats.iter() {\n                         for (i, &argval) in args.vals.iter().enumerate() {\n                             bcx = bind_irrefutable_pat(bcx, &**sub_pat.get(i),\n-                                                       argval, binding_mode,\n-                                                       cleanup_scope);\n+                                                       argval, cleanup_scope);\n                         }\n                     }\n                 }\n@@ -1678,8 +1659,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 let fldptr = adt::trans_field_ptr(bcx, &*repr,\n                                                                   val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx, &**elem,\n-                                                           fldptr, binding_mode,\n-                                                           cleanup_scope);\n+                                                           fldptr, cleanup_scope);\n                             }\n                         }\n                     }\n@@ -1698,26 +1678,24 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let ix = ty::field_idx_strict(tcx, f.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n                                                       discr, ix);\n-                    bcx = bind_irrefutable_pat(bcx, &*f.pat, fldptr,\n-                                               binding_mode, cleanup_scope);\n+                    bcx = bind_irrefutable_pat(bcx, &*f.pat, fldptr, cleanup_scope);\n                 }\n             })\n         }\n         ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for (i, elem) in elems.iter().enumerate() {\n                 let fldptr = adt::trans_field_ptr(bcx, &*repr, val, 0, i);\n-                bcx = bind_irrefutable_pat(bcx, &**elem, fldptr,\n-                                           binding_mode, cleanup_scope);\n+                bcx = bind_irrefutable_pat(bcx, &**elem, fldptr, cleanup_scope);\n             }\n         }\n         ast::PatBox(ref inner) => {\n             let llbox = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, &**inner, llbox, binding_mode, cleanup_scope);\n+            bcx = bind_irrefutable_pat(bcx, &**inner, llbox, cleanup_scope);\n         }\n         ast::PatRegion(ref inner) => {\n             let loaded_val = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, &**inner, loaded_val, binding_mode, cleanup_scope);\n+            bcx = bind_irrefutable_pat(bcx, &**inner, loaded_val, cleanup_scope);\n         }\n         ast::PatVec(ref before, ref slice, ref after) => {\n             let pat_ty = node_id_type(bcx, pat.id);\n@@ -1737,7 +1715,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 .chain(after.iter())\n                 .zip(extracted.vals.into_iter())\n                 .fold(bcx, |bcx, (inner, elem)|\n-                    bind_irrefutable_pat(bcx, &**inner, elem, binding_mode, cleanup_scope)\n+                    bind_irrefutable_pat(bcx, &**inner, elem, cleanup_scope)\n                 );\n         }\n         ast::PatMac(..) => {"}, {"sha": "72e0401e7ab772b2a7e1f07a2845c2de1591733c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -1460,7 +1460,6 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           needs_ret_allocas: nested_returns,\n           personality: Cell::new(None),\n           caller_expects_out_pointer: uses_outptr,\n-          llargs: RefCell::new(NodeMap::new()),\n           lllocals: RefCell::new(NodeMap::new()),\n           llupvars: RefCell::new(NodeMap::new()),\n           id: id,"}, {"sha": "bcf7a08de354f4de42610a8df7426887fa6fadbc", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -196,9 +196,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefStatic(..) |\n-            def::DefArg(..) |\n             def::DefLocal(..) |\n-            def::DefBinding(..) |\n             def::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)\n             }"}, {"sha": "fa8c6b8b4482f63ad514c2930dbc87ed79a04305", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -14,7 +14,7 @@ use back::link::mangle_internal_name_by_path_and_seq;\n use driver::config::FullDebugInfo;\n use llvm::ValueRef;\n use middle::def;\n-use middle::freevars;\n+use middle::mem_categorization::Typer;\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -100,7 +100,7 @@ use syntax::ast_util;\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n pub struct EnvValue {\n-    action: freevars::CaptureMode,\n+    action: ast::CaptureClause,\n     datum: Datum<Lvalue>\n }\n \n@@ -120,8 +120,8 @@ pub fn mk_closure_tys(tcx: &ty::ctxt,\n     // converted to ptrs.\n     let bound_tys = bound_values.iter().map(|bv| {\n         match bv.action {\n-            freevars::CaptureByValue => bv.datum.ty,\n-            freevars::CaptureByRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n+            ast::CaptureByValue => bv.datum.ty,\n+            ast::CaptureByRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n         }\n     }).collect();\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n@@ -208,10 +208,10 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let bound_data = GEPi(bcx, llbox, [0u, abi::box_field_body, i]);\n \n         match bv.action {\n-            freevars::CaptureByValue => {\n+            ast::CaptureByValue => {\n                 bcx = bv.datum.store_to(bcx, bound_data);\n             }\n-            freevars::CaptureByRef => {\n+            ast::CaptureByRef => {\n                 Store(bcx, bv.datum.to_llref(), bound_data);\n             }\n         }\n@@ -223,8 +223,8 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n-                             freevar_mode: freevars::CaptureMode,\n-                             freevars: &Vec<freevars::freevar_entry>,\n+                             freevar_mode: ast::CaptureClause,\n+                             freevars: &Vec<ty::Freevar>,\n                              store: ty::TraitStore)\n                              -> ClosureResult<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::build_closure\");\n@@ -247,7 +247,7 @@ fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n // with the upvars and type descriptors.\n fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 cdata_ty: ty::t,\n-                                freevars: &Vec<freevars::freevar_entry>,\n+                                freevars: &Vec<ty::Freevar>,\n                                 store: ty::TraitStore)\n                                 -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n@@ -301,7 +301,7 @@ fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn load_unboxed_closure_environment<'blk, 'tcx>(\n                                     bcx: Block<'blk, 'tcx>,\n                                     arg_scope_id: ScopeId,\n-                                    freevars: &Vec<freevars::freevar_entry>,\n+                                    freevars: &Vec<ty::Freevar>,\n                                     closure_id: ast::DefId)\n                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n@@ -386,11 +386,9 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n \n-    let freevar_mode = freevars::get_capture_mode(tcx, id);\n-    let freevars: Vec<freevars::freevar_entry> =\n-        freevars::with_freevars(tcx,\n-                                id,\n-                                |fv| fv.iter().map(|&fv| fv).collect());\n+    let freevar_mode = tcx.capture_mode(id);\n+    let freevars: Vec<ty::Freevar> =\n+        ty::with_freevars(tcx, id, |fv| fv.iter().map(|&fv| fv).collect());\n \n     let ClosureResult {\n         llbox,\n@@ -476,10 +474,8 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                                         .clone();\n     let function_type = ty::mk_closure(bcx.tcx(), function_type);\n \n-    let freevars: Vec<freevars::freevar_entry> =\n-        freevars::with_freevars(bcx.tcx(),\n-                                id,\n-                                |fv| fv.iter().map(|&fv| fv).collect());\n+    let freevars: Vec<ty::Freevar> =\n+        ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n     let freevars_ptr = &freevars;\n \n     trans_closure(bcx.ccx(),"}, {"sha": "a5a9d6851762a7bcc0e567294a1fd2bb5205a8db", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -17,7 +17,6 @@ use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef};\n use llvm::{True, False, Bool};\n use middle::def;\n-use middle::freevars;\n use middle::lang_items::LangItem;\n use middle::mem_categorization as mc;\n use middle::subst;\n@@ -267,10 +266,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // points to, but if this value is false, that slot will be a local alloca.\n     pub caller_expects_out_pointer: bool,\n \n-    // Maps arguments to allocas created for them in llallocas.\n-    pub llargs: RefCell<NodeMap<LvalueDatum>>,\n-\n-    // Maps the def_ids for local variables to the allocas created for\n+    // Maps the DefId's for local variables to the allocas created for\n     // them in llallocas.\n     pub lllocals: RefCell<NodeMap<LvalueDatum>>,\n \n@@ -528,7 +524,7 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n     }\n }"}, {"sha": "4201e606e9b609fe7e00aac21dde06e501d9ff11", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -999,11 +999,11 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n-        let llarg = match bcx.fcx.llargs.borrow().find_copy(&node_id) {\n+        let llarg = match bcx.fcx.lllocals.borrow().find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n-                    format!(\"no entry in llargs table for {:?}\",\n+                    format!(\"no entry in lllocals table for {:?}\",\n                             node_id).as_slice());\n             }\n         };"}, {"sha": "fd063d79b0bb3fbb32f47681e14e3ea539ec32b9", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -71,7 +71,6 @@ use middle::typeck;\n use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::Repr;\n-use util::nodemap::NodeMap;\n use middle::trans::machine::{llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n \n@@ -1176,8 +1175,8 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let _icx = push_ctxt(\"trans_local_var\");\n \n-    return match def {\n-        def::DefUpvar(nid, _, _, _) => {\n+    match def {\n+        def::DefUpvar(nid, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             match bcx.fcx.llupvars.borrow().find(&nid) {\n@@ -1189,34 +1188,24 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        def::DefArg(nid, _) => {\n-            take_local(bcx, &*bcx.fcx.llargs.borrow(), nid)\n-        }\n-        def::DefLocal(nid, _) | def::DefBinding(nid, _) => {\n-            take_local(bcx, &*bcx.fcx.lllocals.borrow(), nid)\n+        def::DefLocal(nid) => {\n+            let datum = match bcx.fcx.lllocals.borrow().find(&nid) {\n+                Some(&v) => v,\n+                None => {\n+                    bcx.sess().bug(format!(\n+                        \"trans_local_var: no datum for local/arg {:?} found\",\n+                        nid).as_slice());\n+                }\n+            };\n+            debug!(\"take_local(nid={:?}, v={}, ty={})\",\n+                   nid, bcx.val_to_string(datum.val), bcx.ty_to_string(datum.ty));\n+            datum\n         }\n         _ => {\n             bcx.sess().unimpl(format!(\n                 \"unsupported def type in trans_local_var: {:?}\",\n                 def).as_slice());\n         }\n-    };\n-\n-    fn take_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              table: &NodeMap<Datum<Lvalue>>,\n-                              nid: ast::NodeId)\n-                              -> Datum<Lvalue> {\n-        let datum = match table.find(&nid) {\n-            Some(&v) => v,\n-            None => {\n-                bcx.sess().bug(format!(\n-                    \"trans_local_var: no datum for local/arg {:?} found\",\n-                    nid).as_slice());\n-            }\n-        };\n-        debug!(\"take_local(nid={:?}, v={}, ty={})\",\n-               nid, bcx.val_to_string(datum.val), bcx.ty_to_string(datum.ty));\n-        datum\n     }\n }\n "}, {"sha": "7e767b96b6d9ce5220ed92d64e27aafbc254d10f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -17,8 +17,6 @@ use metadata::csearch;\n use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n-use middle::freevars::CaptureModeMap;\n-use middle::freevars;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n use middle::lang_items::{FnOnceTraitLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n@@ -480,7 +478,7 @@ pub struct ctxt<'tcx> {\n \n     pub map: ast_map::Map<'tcx>,\n     pub intrinsic_defs: RefCell<DefIdMap<t>>,\n-    pub freevars: RefCell<freevars::freevar_map>,\n+    pub freevars: RefCell<FreevarMap>,\n     pub tcache: type_cache,\n     pub rcache: creader_cache,\n     pub short_names_cache: RefCell<HashMap<t, String>>,\n@@ -1463,8 +1461,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      dm: resolve::DefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n-                     freevars: freevars::freevar_map,\n-                     capture_modes: freevars::CaptureModeMap,\n+                     freevars: RefCell<FreevarMap>,\n+                     capture_modes: RefCell<CaptureModeMap>,\n                      region_maps: middle::region::RegionMaps,\n                      lang_items: middle::lang_items::LanguageItems,\n                      stability: stability::Index) -> ctxt<'tcx> {\n@@ -1485,7 +1483,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         object_cast_map: RefCell::new(NodeMap::new()),\n         map: map,\n         intrinsic_defs: RefCell::new(DefIdMap::new()),\n-        freevars: RefCell::new(freevars),\n+        freevars: freevars,\n         tcache: RefCell::new(DefIdMap::new()),\n         rcache: RefCell::new(HashMap::new()),\n         short_names_cache: RefCell::new(HashMap::new()),\n@@ -1522,7 +1520,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         node_lint_levels: RefCell::new(HashMap::new()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n-        capture_modes: RefCell::new(capture_modes),\n+        capture_modes: capture_modes,\n         associated_types: RefCell::new(DefIdMap::new()),\n         trait_associated_types: RefCell::new(DefIdMap::new()),\n     }\n@@ -3684,9 +3682,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 // DefArg's, particularly those of immediate type, ought to\n                 // considered rvalues.\n                 def::DefStatic(..) |\n-                def::DefBinding(..) |\n                 def::DefUpvar(..) |\n-                def::DefArg(..) |\n                 def::DefLocal(..) => LvalueExpr,\n \n                 def => {\n@@ -4759,7 +4755,7 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId)\n                               -> Vec<UnboxedClosureUpvar> {\n     if closure_id.krate == ast::LOCAL_CRATE {\n         match tcx.freevars.borrow().find(&closure_id.node) {\n-            None => tcx.sess.bug(\"no freevars for unboxed closure?!\"),\n+            None => vec![],\n             Some(ref freevars) => {\n                 freevars.iter().map(|freevar| {\n                     let freevar_def_id = freevar.def.def_id();\n@@ -5617,7 +5613,7 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.capture_modes.borrow().get_copy(&closure_expr_id)\n     }\n \n@@ -5688,3 +5684,24 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n         }\n     })\n }\n+\n+/// A free variable referred to in a function.\n+#[deriving(Encodable, Decodable)]\n+pub struct Freevar {\n+    /// The variable being accessed free.\n+    pub def: def::Def,\n+\n+    // First span where it is accessed (there can be multiple).\n+    pub span: Span\n+}\n+\n+pub type FreevarMap = NodeMap<Vec<Freevar>>;\n+\n+pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n+\n+pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[Freevar]| -> T) -> T {\n+    match tcx.freevars.borrow().find(&fid) {\n+        None => f(&[]),\n+        Some(d) => f(d.as_slice())\n+    }\n+}"}, {"sha": "9676e1515530e707a110b60c6f233128cff6a605", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -79,7 +79,6 @@ type parameter).\n \n use middle::const_eval;\n use middle::def;\n-use middle::freevars;\n use middle::lang_items::IteratorItem;\n use middle::mem_categorization::McResult;\n use middle::mem_categorization;\n@@ -318,7 +317,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         self.ccx.tcx.upvar_borrow(upvar_id)\n     }\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.ccx.tcx.capture_mode(closure_expr_id)\n     }\n     fn unboxed_closures<'a>(&'a self)\n@@ -5027,8 +5026,7 @@ pub fn polytype_for_def(fcx: &FnCtxt,\n                         defn: def::Def)\n                         -> Polytype {\n     match defn {\n-      def::DefArg(nid, _) | def::DefLocal(nid, _) |\n-      def::DefBinding(nid, _) => {\n+      def::DefLocal(nid) | def::DefUpvar(nid, _, _) => {\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);\n       }\n@@ -5037,9 +5035,6 @@ pub fn polytype_for_def(fcx: &FnCtxt,\n       def::DefStruct(id) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n-      def::DefUpvar(_, inner, _, _) => {\n-        return polytype_for_def(fcx, sp, *inner);\n-      }\n       def::DefTrait(_) |\n       def::DefTy(..) |\n       def::DefAssociatedTy(..) |\n@@ -5183,10 +5178,8 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         // elsewhere. (I hope)\n         def::DefMod(..) |\n         def::DefForeignMod(..) |\n-        def::DefArg(..) |\n         def::DefLocal(..) |\n         def::DefMethod(..) |\n-        def::DefBinding(..) |\n         def::DefUse(..) |\n         def::DefRegion(..) |\n         def::DefLabel(..) |"}, {"sha": "2effff4767b02a6bdb4080e0031e155a029c7b8c", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -119,8 +119,6 @@ and report an error, and it just seems like more mess in the end.)\n */\n \n use middle::def;\n-use middle::def::{DefArg, DefBinding, DefLocal, DefUpvar};\n-use middle::freevars;\n use middle::mem_categorization as mc;\n use middle::ty::{ReScope};\n use middle::ty;\n@@ -243,14 +241,14 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n \n     let tcx = fcx.tcx();\n     match def {\n-        DefLocal(node_id, _) | DefArg(node_id, _) |\n-        DefBinding(node_id, _) => {\n+        def::DefLocal(node_id) => {\n             tcx.region_maps.var_region(node_id)\n         }\n-        DefUpvar(_, subdef, closure_id, body_id) => {\n-            match ty::ty_closure_store(fcx.node_ty(closure_id)) {\n-                ty::RegionTraitStore(..) => region_of_def(fcx, *subdef),\n-                ty::UniqTraitStore => ReScope(body_id)\n+        def::DefUpvar(node_id, _, body_id) => {\n+            if body_id == ast::DUMMY_NODE_ID {\n+                tcx.region_maps.var_region(node_id)\n+            } else {\n+                ReScope(body_id)\n             }\n         }\n         _ => {\n@@ -479,7 +477,7 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> freevars::CaptureMode {\n+                    -> ast::CaptureClause {\n         self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n     }\n \n@@ -852,7 +850,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                                          ..}) => {\n             // For closure, ensure that the variables outlive region\n             // bound, since they are captured by reference.\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 if freevars.is_empty() {\n                     // No free variables means that the environment\n                     // will be NULL at runtime and hence the closure\n@@ -875,13 +873,13 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                                          ..}) => {\n             // For proc, ensure that the *types* of the variables\n             // outlive region bound, since they are captured by value.\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 ensure_free_variable_types_outlive_closure_bound(\n                     rcx, bounds.region_bound, expr, freevars);\n             });\n         }\n         ty::ty_unboxed_closure(_, region) => {\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 // No free variables means that there is no environment and\n                 // hence the closure has static lifetime. Otherwise, the\n                 // closure must not outlive the variables it closes over\n@@ -907,7 +905,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 store: ty::RegionTraitStore(..),\n                 ..\n             }) => {\n-            freevars::with_freevars(tcx, expr.id, |freevars| {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n                 propagate_upupvar_borrow_kind(rcx, expr, freevars);\n             })\n         }\n@@ -918,7 +916,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         rcx: &mut Rcx,\n         region_bound: ty::Region,\n         expr: &ast::Expr,\n-        freevars: &[freevars::freevar_entry])\n+        freevars: &[ty::Freevar])\n     {\n         /*!\n          * Make sure that the type of all free variables referenced\n@@ -951,7 +949,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         rcx: &mut Rcx,\n         region_bound: ty::Region,\n         expr: &ast::Expr,\n-        freevars: &[freevars::freevar_entry])\n+        freevars: &[ty::Freevar])\n     {\n         /*!\n          * Make sure that all free variables referenced inside the\n@@ -1001,7 +999,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n     fn propagate_upupvar_borrow_kind(rcx: &mut Rcx,\n                                      expr: &ast::Expr,\n-                                     freevars: &[freevars::freevar_entry]) {\n+                                     freevars: &[ty::Freevar]) {\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"propagate_upupvar_borrow_kind({})\", expr.repr(tcx));\n         for freevar in freevars.iter() {\n@@ -1031,7 +1029,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             // determining the final borrow_kind) and propagate that as\n             // a constraint on the outer closure.\n             match freevar.def {\n-                def::DefUpvar(var_id, _, outer_closure_id, _) => {\n+                def::DefUpvar(var_id, outer_closure_id, _) => {\n                     // thing being captured is itself an upvar:\n                     let outer_upvar_id = ty::UpvarId {\n                         var_id: var_id,\n@@ -1475,7 +1473,6 @@ fn link_region(rcx: &Rcx,\n             mc::cat_static_item |\n             mc::cat_copied_upvar(..) |\n             mc::cat_local(..) |\n-            mc::cat_arg(..) |\n             mc::cat_upvar(..) |\n             mc::cat_rvalue(..) => {\n                 // These are all \"base cases\" with independent lifetimes\n@@ -1701,7 +1698,6 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n             mc::cat_rvalue(_) |\n             mc::cat_copied_upvar(_) |\n             mc::cat_local(_) |\n-            mc::cat_arg(_) |\n             mc::cat_upvar(..) => {\n                 return;\n             }\n@@ -1753,7 +1749,6 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n             mc::cat_rvalue(_) |\n             mc::cat_copied_upvar(_) |\n             mc::cat_local(_) |\n-            mc::cat_arg(_) |\n             mc::cat_upvar(..) => {\n                 return;\n             }"}, {"sha": "29cd2e77e8b1f05a2bb1d8e3f6aa963c0df8389e", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b27e995e793d78ac873057393991c0dda9a178/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=64b27e995e793d78ac873057393991c0dda9a178", "patch": "@@ -22,7 +22,6 @@ use driver::diagnostic;\n use driver::diagnostic::Emitter;\n use driver::driver;\n use driver::session;\n-use middle::freevars;\n use middle::lang_items;\n use middle::region;\n use middle::resolve;\n@@ -125,10 +124,8 @@ fn test_env(_test_name: &str,\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(krate, &sess);\n-    let resolve::CrateMap { def_map: def_map, .. } =\n+    let resolve::CrateMap { def_map, freevars, capture_mode_map, .. } =\n         resolve::resolve_crate(&sess, &lang_items, krate);\n-    let (freevars_map, captures_map) = freevars::annotate_freevars(&def_map,\n-                                                                   krate);\n     let named_region_map = resolve_lifetime::krate(&sess, krate);\n     let region_map = region::resolve_crate(&sess, krate);\n     let stability_index = stability::Index::build(krate);\n@@ -138,8 +135,8 @@ fn test_env(_test_name: &str,\n                           def_map,\n                           named_region_map,\n                           ast_map,\n-                          freevars_map,\n-                          captures_map,\n+                          freevars,\n+                          capture_mode_map,\n                           region_map,\n                           lang_items,\n                           stability_index);"}]}