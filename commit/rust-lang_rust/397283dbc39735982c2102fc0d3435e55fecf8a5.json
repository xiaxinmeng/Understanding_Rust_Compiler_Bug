{"sha": "397283dbc39735982c2102fc0d3435e55fecf8a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NzI4M2RiYzM5NzM1OTgyYzIxMDJmYzBkMzQzNWU1NWZlY2Y4YTU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-29T19:35:20Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-10T07:58:17Z"}, "message": "rename extra -> meta in place", "tree": {"sha": "f42f7a60036bebb68c73af0e46911c4d2aa484ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f42f7a60036bebb68c73af0e46911c4d2aa484ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/397283dbc39735982c2102fc0d3435e55fecf8a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/397283dbc39735982c2102fc0d3435e55fecf8a5", "html_url": "https://github.com/rust-lang/rust/commit/397283dbc39735982c2102fc0d3435e55fecf8a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/397283dbc39735982c2102fc0d3435e55fecf8a5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50c00a93016ee8987dc75d201fd8c9ed5e763441", "url": "https://api.github.com/repos/rust-lang/rust/commits/50c00a93016ee8987dc75d201fd8c9ed5e763441", "html_url": "https://github.com/rust-lang/rust/commit/50c00a93016ee8987dc75d201fd8c9ed5e763441"}], "stats": {"total": 68, "additions": 34, "deletions": 34}, "files": [{"sha": "65b323d8433112d706cd4636714047bc385d9f76", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/397283dbc39735982c2102fc0d3435e55fecf8a5/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397283dbc39735982c2102fc0d3435e55fecf8a5/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=397283dbc39735982c2102fc0d3435e55fecf8a5", "patch": "@@ -119,9 +119,9 @@ pub fn op_to_const<'tcx>(\n         }\n     };\n     let val = match normalized_op {\n-        Err(MemPlace { ptr, align, extra }) => {\n+        Err(MemPlace { ptr, align, meta }) => {\n             // extract alloc-offset pair\n-            assert!(extra.is_none());\n+            assert!(meta.is_none());\n             let ptr = ptr.to_ptr()?;\n             let alloc = ecx.memory.get(ptr.alloc_id)?;\n             assert!(alloc.align.abi() >= align.abi());"}, {"sha": "f6944b2a9ae8555b73b0cbf6573697663137f044", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/397283dbc39735982c2102fc0d3435e55fecf8a5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397283dbc39735982c2102fc0d3435e55fecf8a5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=397283dbc39735982c2102fc0d3435e55fecf8a5", "patch": "@@ -330,7 +330,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     }\n \n     /// Return the actual dynamic size and alignment of the place at the given type.\n-    /// Only the \"extra\" (metadata) part of the place matters.\n+    /// Only the `meta` part of the place matters.\n     pub(super) fn size_and_align_of(\n         &self,\n         metadata: Option<Scalar<M::PointerTag>>,\n@@ -416,7 +416,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        self.size_and_align_of(mplace.extra, mplace.layout)\n+        self.size_and_align_of(mplace.meta, mplace.layout)\n     }\n \n     pub fn push_stack_frame("}, {"sha": "88a3e52d7f9abfe2e8834e9aabfd09b19d10acaf", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/397283dbc39735982c2102fc0d3435e55fecf8a5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397283dbc39735982c2102fc0d3435e55fecf8a5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=397283dbc39735982c2102fc0d3435e55fecf8a5", "patch": "@@ -34,7 +34,7 @@ pub struct MemPlace<Tag=(), Id=AllocId> {\n     /// Metadata for unsized places.  Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g. `extern type`).\n-    pub extra: Option<Scalar<Tag, Id>>,\n+    pub meta: Option<Scalar<Tag, Id>>,\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -97,7 +97,7 @@ impl MemPlace {\n         MemPlace {\n             ptr: self.ptr.with_default_tag(),\n             align: self.align,\n-            extra: self.extra.map(Scalar::with_default_tag),\n+            meta: self.meta.map(Scalar::with_default_tag),\n         }\n     }\n }\n@@ -109,7 +109,7 @@ impl<Tag> MemPlace<Tag> {\n         MemPlace {\n             ptr: self.ptr.erase_tag(),\n             align: self.align,\n-            extra: self.extra.map(Scalar::erase_tag),\n+            meta: self.meta.map(Scalar::erase_tag),\n         }\n     }\n \n@@ -118,7 +118,7 @@ impl<Tag> MemPlace<Tag> {\n         MemPlace {\n             ptr,\n             align,\n-            extra: None,\n+            meta: None,\n         }\n     }\n \n@@ -129,11 +129,11 @@ impl<Tag> MemPlace<Tag> {\n \n     #[inline(always)]\n     pub fn to_scalar_ptr_align(self) -> (Scalar<Tag>, Align) {\n-        assert!(self.extra.is_none());\n+        assert!(self.meta.is_none());\n         (self.ptr, self.align)\n     }\n \n-    /// Extract the ptr part of the mplace\n+    /// metact the ptr part of the mplace\n     #[inline(always)]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n         // At this point, we forget about the alignment information --\n@@ -147,9 +147,9 @@ impl<Tag> MemPlace<Tag> {\n     pub fn to_ref(self) -> Value<Tag> {\n         // We ignore the alignment of the place here -- special handling for packed structs ends\n         // at the `&` operator.\n-        match self.extra {\n+        match self.meta {\n             None => Value::Scalar(self.ptr.into()),\n-            Some(extra) => Value::ScalarPair(self.ptr.into(), extra.into()),\n+            Some(meta) => Value::ScalarPair(self.ptr.into(), meta.into()),\n         }\n     }\n }\n@@ -175,10 +175,10 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     #[inline]\n     pub(super) fn len(self, cx: impl HasDataLayout) -> EvalResult<'tcx, u64> {\n         if self.layout.is_unsized() {\n-            // We need to consult `extra` metadata\n+            // We need to consult `meta` metadata\n             match self.layout.ty.sty {\n                 ty::Slice(..) | ty::Str =>\n-                    return self.mplace.extra.unwrap().to_usize(cx),\n+                    return self.mplace.meta.unwrap().to_usize(cx),\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n@@ -194,7 +194,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     #[inline]\n     pub(super) fn vtable(self) -> EvalResult<'tcx, Pointer<Tag>> {\n         match self.layout.ty.sty {\n-            ty::Dynamic(..) => self.mplace.extra.unwrap().to_ptr(),\n+            ty::Dynamic(..) => self.mplace.meta.unwrap().to_ptr(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n         }\n     }\n@@ -283,9 +283,9 @@ impl\n         let align = layout.align;\n         let mplace = match *val {\n             Value::Scalar(ptr) =>\n-                MemPlace { ptr: ptr.not_undef()?, align, extra: None },\n-            Value::ScalarPair(ptr, extra) =>\n-                MemPlace { ptr: ptr.not_undef()?, align, extra: Some(extra.not_undef()?) },\n+                MemPlace { ptr: ptr.not_undef()?, align, meta: None },\n+            Value::ScalarPair(ptr, meta) =>\n+                MemPlace { ptr: ptr.not_undef()?, align, meta: Some(meta.not_undef()?) },\n         };\n         Ok(MPlaceTy { mplace, layout })\n     }\n@@ -321,13 +321,13 @@ impl\n         let field_layout = base.layout.field(self, usize::try_from(field).unwrap_or(0))?;\n \n         // Offset may need adjustment for unsized fields\n-        let (extra, offset) = if field_layout.is_unsized() {\n+        let (meta, offset) = if field_layout.is_unsized() {\n             // re-use parent metadata to determine dynamic field layout\n-            let (_, align) = self.size_and_align_of(base.extra, field_layout)?;\n-            (base.extra, offset.abi_align(align))\n+            let (_, align) = self.size_and_align_of(base.meta, field_layout)?;\n+            (base.meta, offset.abi_align(align))\n \n         } else {\n-            // base.extra could be present; we might be accessing a sized field of an unsized\n+            // base.meta could be present; we might be accessing a sized field of an unsized\n             // struct.\n             (None, offset)\n         };\n@@ -338,7 +338,7 @@ impl\n             // codegen -- mostly to see if we can get away with that\n             .restrict_for_offset(offset); // must be last thing that happens\n \n-        Ok(MPlaceTy { mplace: MemPlace { ptr, align, extra }, layout: field_layout })\n+        Ok(MPlaceTy { mplace: MemPlace { ptr, align, meta }, layout: field_layout })\n     }\n \n     // Iterates over all fields of an array. Much more efficient than doing the\n@@ -359,7 +359,7 @@ impl\n         Ok((0..len).map(move |i| {\n             let ptr = base.ptr.ptr_offset(i * stride, dl)?;\n             Ok(MPlaceTy {\n-                mplace: MemPlace { ptr, align: base.align, extra: None },\n+                mplace: MemPlace { ptr, align: base.align, meta: None },\n                 layout\n             })\n         }))\n@@ -383,9 +383,9 @@ impl\n         };\n         let ptr = base.ptr.ptr_offset(from_offset, self)?;\n \n-        // Compute extra and new layout\n+        // Compute meta and new layout\n         let inner_len = len - to - from;\n-        let (extra, ty) = match base.layout.ty.sty {\n+        let (meta, ty) = match base.layout.ty.sty {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n             ty::Array(inner, _) =>\n@@ -400,7 +400,7 @@ impl\n         let layout = self.layout_of(ty)?;\n \n         Ok(MPlaceTy {\n-            mplace: MemPlace { ptr, align: base.align, extra },\n+            mplace: MemPlace { ptr, align: base.align, meta },\n             layout\n         })\n     }\n@@ -411,7 +411,7 @@ impl\n         variant: usize,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n-        assert!(base.extra.is_none());\n+        assert!(base.meta.is_none());\n         Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n     }\n \n@@ -838,7 +838,7 @@ impl\n         }\n \n         let mplace = MPlaceTy {\n-            mplace: MemPlace { extra: None, ..*mplace },\n+            mplace: MemPlace { meta: None, ..*mplace },\n             layout\n         };\n         Ok((instance, mplace))"}, {"sha": "5c1606aec14ca1b69830bb71b29648d7e2250ac5", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/397283dbc39735982c2102fc0d3435e55fecf8a5/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397283dbc39735982c2102fc0d3435e55fecf8a5/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=397283dbc39735982c2102fc0d3435e55fecf8a5", "patch": "@@ -209,11 +209,11 @@ impl_snapshot_for!(enum ScalarMaybeUndef {\n impl_stable_hash_for!(struct ::interpret::MemPlace {\n     ptr,\n     align,\n-    extra,\n+    meta,\n });\n impl_snapshot_for!(struct MemPlace {\n     ptr,\n-    extra,\n+    meta,\n     align -> *align, // just copy alignment verbatim\n });\n "}, {"sha": "9dc035a3e20b81d115f4680e87ac6a59ae15bb09", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/397283dbc39735982c2102fc0d3435e55fecf8a5/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397283dbc39735982c2102fc0d3435e55fecf8a5/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=397283dbc39735982c2102fc0d3435e55fecf8a5", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     let tail = self.tcx.struct_tail(place.layout.ty);\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n-                            let vtable = try_validation!(place.extra.unwrap().to_ptr(),\n+                            let vtable = try_validation!(place.meta.unwrap().to_ptr(),\n                                 \"non-pointer vtable in fat pointer\", path);\n                             try_validation!(self.read_drop_type_from_vtable(vtable),\n                                 \"invalid drop fn in vtable\", path);\n@@ -195,7 +195,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             // FIXME: More checks for the vtable.\n                         }\n                         ty::Slice(..) | ty::Str => {\n-                            try_validation!(place.extra.unwrap().to_usize(self),\n+                            try_validation!(place.meta.unwrap().to_usize(self),\n                                 \"non-integer slice length in fat pointer\", path);\n                         }\n                         ty::Foreign(..) => {\n@@ -208,7 +208,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // for safe ptrs, also check the ptr values itself\n                 if !ty.is_unsafe_ptr() {\n                     // Make sure this is non-NULL and aligned\n-                    let (size, align) = self.size_and_align_of(place.extra, place.layout)?;\n+                    let (size, align) = self.size_and_align_of(place.meta, place.layout)?;\n                     match self.memory.check_align(place.ptr, align) {\n                         Ok(_) => {},\n                         Err(err) => match err.kind {"}]}