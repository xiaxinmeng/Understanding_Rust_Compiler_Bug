{"sha": "1f254dd8555633292c1d7a64c1ddef220be9caa5", "node_id": "C_kwDOAAsO6NoAKDFmMjU0ZGQ4NTU1NjMzMjkyYzFkN2E2NGMxZGRlZjIyMGJlOWNhYTU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-05T14:57:28Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-05T14:57:28Z"}, "message": "feat: Enable flyimport completions for attributes", "tree": {"sha": "b410d2475385e60e3e0de15bc22c8c54399c703b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b410d2475385e60e3e0de15bc22c8c54399c703b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f254dd8555633292c1d7a64c1ddef220be9caa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f254dd8555633292c1d7a64c1ddef220be9caa5", "html_url": "https://github.com/rust-lang/rust/commit/1f254dd8555633292c1d7a64c1ddef220be9caa5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f254dd8555633292c1d7a64c1ddef220be9caa5/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b4ca77572c4cfa71f51fef052ef0aa3cc8d6d19", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b4ca77572c4cfa71f51fef052ef0aa3cc8d6d19", "html_url": "https://github.com/rust-lang/rust/commit/9b4ca77572c4cfa71f51fef052ef0aa3cc8d6d19"}], "stats": {"total": 251, "additions": 217, "deletions": 34}, "files": [{"sha": "fe8a8018dbec007653226bbfdd36feb1adebe612", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=1f254dd8555633292c1d7a64c1ddef220be9caa5", "patch": "@@ -1716,6 +1716,10 @@ impl MacroDef {\n             MacroKind::Attr | MacroKind::Derive => false,\n         }\n     }\n+\n+    pub fn is_attr(&self) -> bool {\n+        matches!(self.kind(), MacroKind::Attr)\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]"}, {"sha": "446a808de84384656c572ba51d9b3fc48a777a0c", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=1f254dd8555633292c1d7a64c1ddef220be9caa5", "patch": "@@ -1,13 +1,14 @@\n //! See [`import_on_the_fly`].\n+use hir::ItemInNs;\n use ide_db::helpers::{\n-    import_assets::{ImportAssets, ImportCandidate},\n+    import_assets::{ImportAssets, ImportCandidate, LocatedImport},\n     insert_use::ImportScope,\n };\n use itertools::Itertools;\n use syntax::{AstNode, SyntaxNode, T};\n \n use crate::{\n-    context::CompletionContext,\n+    context::{CompletionContext, PathKind},\n     render::{render_resolution_with_import, RenderContext},\n     ImportEdit,\n };\n@@ -135,10 +136,35 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         &ctx.sema,\n     )?;\n \n+    let ns_filter = |import: &LocatedImport| {\n+        let kind = match ctx.path_kind() {\n+            Some(kind) => kind,\n+            None => {\n+                return match import.original_item {\n+                    ItemInNs::Macros(mac) => mac.is_fn_like(),\n+                    _ => true,\n+                }\n+            }\n+        };\n+        match (kind, import.original_item) {\n+            (PathKind::Expr, ItemInNs::Types(_) | ItemInNs::Values(_)) => true,\n+\n+            (PathKind::Type, ItemInNs::Types(_)) => true,\n+            (PathKind::Type, ItemInNs::Values(_)) => false,\n+\n+            (PathKind::Expr | PathKind::Type, ItemInNs::Macros(mac)) => mac.is_fn_like(),\n+\n+            (PathKind::Attr, ItemInNs::Types(hir::ModuleDef::Module(_))) => true,\n+            (PathKind::Attr, ItemInNs::Macros(mac)) => mac.is_attr(),\n+            (PathKind::Attr, _) => false,\n+        }\n+    };\n+\n     acc.add_all(\n         import_assets\n             .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n             .into_iter()\n+            .filter(ns_filter)\n             .filter(|import| {\n                 !ctx.is_item_hidden(&import.item_to_import)\n                     && !ctx.is_item_hidden(&import.original_item)"}, {"sha": "4abf7374b3b2a66140a990f6dbac9761cfe88fef", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=1f254dd8555633292c1d7a64c1ddef220be9caa5", "patch": "@@ -2,6 +2,7 @@\n \n use std::iter;\n \n+use hir::ScopeDef;\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n \n@@ -31,35 +32,50 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n         Some(ImmediateLocation::ItemList | ImmediateLocation::Trait | ImmediateLocation::Impl) => {\n             if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n                 for (name, def) in module.scope(ctx.db, context_module) {\n-                    if let hir::ScopeDef::MacroDef(macro_def) = def {\n+                    if let ScopeDef::MacroDef(macro_def) = def {\n                         if macro_def.is_fn_like() {\n                             acc.add_macro(ctx, Some(name.clone()), macro_def);\n                         }\n                     }\n-                    if let hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = def {\n+                    if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = def {\n                         acc.add_resolution(ctx, name, &def);\n                     }\n                 }\n             }\n             return;\n         }\n         Some(ImmediateLocation::Visibility(_)) => {\n-            if let hir::PathResolution::Def(hir::ModuleDef::Module(resolved)) = resolution {\n+            if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n                 if let Some(current_module) = ctx.scope.module() {\n                     if let Some(next) = current_module\n                         .path_to_root(ctx.db)\n                         .into_iter()\n-                        .take_while(|&it| it != resolved)\n+                        .take_while(|&it| it != module)\n                         .next()\n                     {\n                         if let Some(name) = next.name(ctx.db) {\n-                            acc.add_resolution(ctx, name, &hir::ScopeDef::ModuleDef(next.into()));\n+                            acc.add_resolution(ctx, name, &ScopeDef::ModuleDef(next.into()));\n                         }\n                     }\n                 }\n             }\n             return;\n         }\n+        Some(ImmediateLocation::Attribute(_)) => {\n+            if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n+                for (name, def) in module.scope(ctx.db, context_module) {\n+                    let add_resolution = match def {\n+                        ScopeDef::MacroDef(mac) => mac.is_attr(),\n+                        ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => true,\n+                        _ => false,\n+                    };\n+                    if add_resolution {\n+                        acc.add_resolution(ctx, name, &def);\n+                    }\n+                }\n+            }\n+            return;\n+        }\n         _ => (),\n     }\n \n@@ -91,7 +107,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             let module_scope = module.scope(ctx.db, context_module);\n             for (name, def) in module_scope {\n                 if ctx.in_use_tree() {\n-                    if let hir::ScopeDef::Unknown = def {\n+                    if let ScopeDef::Unknown = def {\n                         if let Some(ast::NameLike::NameRef(name_ref)) = ctx.name_syntax.as_ref() {\n                             if name_ref.syntax().text() == name.to_smol_str().as_str() {\n                                 // for `use self::foo$0`, don't suggest `foo` as a completion\n@@ -104,16 +120,16 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n                 let add_resolution = match def {\n                     // Don't suggest attribute macros and derives.\n-                    hir::ScopeDef::MacroDef(mac) => mac.is_fn_like(),\n+                    ScopeDef::MacroDef(mac) => mac.is_fn_like(),\n                     // no values in type places\n-                    hir::ScopeDef::ModuleDef(\n+                    ScopeDef::ModuleDef(\n                         hir::ModuleDef::Function(_)\n                         | hir::ModuleDef::Variant(_)\n                         | hir::ModuleDef::Static(_),\n                     )\n-                    | hir::ScopeDef::Local(_) => !ctx.expects_type(),\n+                    | ScopeDef::Local(_) => !ctx.expects_type(),\n                     // unless its a constant in a generic arg list position\n-                    hir::ScopeDef::ModuleDef(hir::ModuleDef::Const(_)) => {\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Const(_)) => {\n                         !ctx.expects_type() || ctx.expects_generic_arg()\n                     }\n                     _ => true,"}, {"sha": "414c1d961bbf3991d640c47118f6e6dd535e315f", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=1f254dd8555633292c1d7a64c1ddef220be9caa5", "patch": "@@ -56,6 +56,19 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n             });\n             return;\n         }\n+        Some(ImmediateLocation::Attribute(_)) => {\n+            ctx.process_all_names(&mut |name, res| {\n+                let add_resolution = match res {\n+                    ScopeDef::MacroDef(mac) => mac.is_attr(),\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => true,\n+                    _ => false,\n+                };\n+                if add_resolution {\n+                    acc.add_resolution(ctx, name, &res);\n+                }\n+            });\n+            return;\n+        }\n         _ => (),\n     }\n "}, {"sha": "b3ce1f8e9c4bca8ec94143ec897d642b5051996f", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=1f254dd8555633292c1d7a64c1ddef220be9caa5", "patch": "@@ -30,10 +30,11 @@ pub(crate) enum PatternRefutability {\n     Irrefutable,\n }\n \n-#[derive(Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub(super) enum PathKind {\n     Expr,\n     Type,\n+    Attr,\n }\n \n #[derive(Debug)]\n@@ -232,17 +233,15 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     pub(crate) fn is_path_disallowed(&self) -> bool {\n-        self.attribute_under_caret.is_some()\n-            || self.previous_token_is(T![unsafe])\n+        self.previous_token_is(T![unsafe])\n             || matches!(\n                 self.prev_sibling,\n                 Some(ImmediatePrevSibling::Attribute | ImmediatePrevSibling::Visibility)\n             )\n             || matches!(\n                 self.completion_location,\n                 Some(\n-                    ImmediateLocation::Attribute(_)\n-                        | ImmediateLocation::ModDeclaration(_)\n+                    ImmediateLocation::ModDeclaration(_)\n                         | ImmediateLocation::RecordPat(_)\n                         | ImmediateLocation::RecordExpr(_)\n                         | ImmediateLocation::Rename\n@@ -274,6 +273,10 @@ impl<'a> CompletionContext<'a> {\n         self.path_context.as_ref().and_then(|it| it.qualifier.as_ref())\n     }\n \n+    pub(crate) fn path_kind(&self) -> Option<PathKind> {\n+        self.path_context.as_ref().and_then(|it| it.kind)\n+    }\n+\n     /// Checks if an item is visible and not `doc(hidden)` at the completion site.\n     pub(crate) fn is_visible<I>(&self, item: &I) -> bool\n     where\n@@ -785,6 +788,7 @@ impl<'a> CompletionContext<'a> {\n                 match parent {\n                     ast::PathType(_it) => Some(PathKind::Type),\n                     ast::PathExpr(_it) => Some(PathKind::Expr),\n+                    ast::Meta(_it) => Some(PathKind::Attr),\n                     _ => None,\n                 }\n             };"}, {"sha": "22fb1f4825193cb23f0558cc81f268d29d136b35", "filename": "crates/ide_completion/src/render/macro_.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs?ref=1f254dd8555633292c1d7a64c1ddef220be9caa5", "patch": "@@ -1,8 +1,12 @@\n //! Renderer for macro invocations.\n \n+use either::Either;\n use hir::HasSource;\n use ide_db::SymbolKind;\n-use syntax::{display::macro_label, SmolStr};\n+use syntax::{\n+    display::{fn_as_proc_macro_label, macro_label},\n+    SmolStr,\n+};\n \n use crate::{\n     context::CallKind,\n@@ -35,7 +39,8 @@ impl<'a> MacroRender<'a> {\n         let name = name.to_smol_str();\n         let docs = ctx.docs(macro_);\n         let docs_str = docs.as_ref().map_or(\"\", |s| s.as_str());\n-        let (bra, ket) = guess_macro_braces(&name, docs_str);\n+        let (bra, ket) =\n+            if macro_.is_fn_like() { guess_macro_braces(&name, docs_str) } else { (\"\", \"\") };\n \n         MacroRender { ctx, name, macro_, docs, bra, ket }\n     }\n@@ -47,15 +52,23 @@ impl<'a> MacroRender<'a> {\n         } else {\n             Some(self.ctx.source_range())\n         }?;\n-        let mut item = CompletionItem::new(SymbolKind::Macro, source_range, self.label());\n+        let kind = match self.macro_.kind() {\n+            hir::MacroKind::Derive => SymbolKind::Derive,\n+            hir::MacroKind::Attr => SymbolKind::Attribute,\n+            hir::MacroKind::BuiltIn | hir::MacroKind::Declarative | hir::MacroKind::ProcMacro => {\n+                SymbolKind::Macro\n+            }\n+        };\n+        let mut item = CompletionItem::new(kind, source_range, self.label());\n         item.set_deprecated(self.ctx.is_deprecated(self.macro_)).set_detail(self.detail());\n \n         if let Some(import_to_add) = import_to_add {\n             item.add_import(import_to_add);\n         }\n \n-        let needs_bang = !(self.ctx.completion.in_use_tree()\n-            || matches!(self.ctx.completion.path_call_kind(), Some(CallKind::Mac)));\n+        let needs_bang = self.macro_.is_fn_like()\n+            && !(self.ctx.completion.in_use_tree()\n+                || matches!(self.ctx.completion.path_call_kind(), Some(CallKind::Mac)));\n         let has_parens = self.ctx.completion.path_call_kind().is_some();\n \n         match self.ctx.snippet_cap() {\n@@ -84,10 +97,10 @@ impl<'a> MacroRender<'a> {\n     }\n \n     fn label(&self) -> SmolStr {\n-        if self.needs_bang() && self.ctx.snippet_cap().is_some() {\n-            SmolStr::from_iter([&*self.name, \"!\", self.bra, \"\u2026\", self.ket])\n-        } else if self.macro_.kind() == hir::MacroKind::Derive {\n+        if !self.macro_.is_fn_like() {\n             self.name.clone()\n+        } else if self.needs_bang() && self.ctx.snippet_cap().is_some() {\n+            SmolStr::from_iter([&*self.name, \"!\", self.bra, \"\u2026\", self.ket])\n         } else {\n             self.banged_name()\n         }\n@@ -98,8 +111,11 @@ impl<'a> MacroRender<'a> {\n     }\n \n     fn detail(&self) -> Option<String> {\n-        let ast_node = self.macro_.source(self.ctx.db())?.value.left()?;\n-        Some(macro_label(&ast_node))\n+        let detail = match self.macro_.source(self.ctx.db())?.value {\n+            Either::Left(node) => macro_label(&node),\n+            Either::Right(node) => fn_as_proc_macro_label(&node),\n+        };\n+        Some(detail)\n     }\n }\n "}, {"sha": "c3dce61e7d4ea6a648faeae3b9df3fcd4b4589ac", "filename": "crates/ide_completion/src/tests/attribute.rs", "status": "modified", "additions": 83, "deletions": 7, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs?ref=1f254dd8555633292c1d7a64c1ddef220be9caa5", "patch": "@@ -9,12 +9,12 @@ fn check(ra_fixture: &str, expect: Expect) {\n }\n \n #[test]\n-fn doesnt_complete_items() {\n+fn proc_macros() {\n     check(\n         r#\"\n-struct Foo;\n+//- proc_macros: identity\n #[$0]\n-use self as this;\n+struct Foo;\n \"#,\n         expect![[r#\"\n             at allow(\u2026)\n@@ -29,19 +29,29 @@ use self as this;\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n+            at derive(\u2026)\n+            at repr(\u2026)\n+            at non_exhaustive\n+            kw self\n+            kw super\n+            kw crate\n+            md proc_macros\n         \"#]],\n     )\n }\n \n #[test]\n-fn doesnt_complete_qualified() {\n+fn proc_macros_qualified() {\n     check(\n         r#\"\n+//- proc_macros: identity\n+#[proc_macros::$0]\n struct Foo;\n-#[foo::$0]\n-use self as this;\n \"#,\n-        expect![[r#\"\"#]],\n+        expect![[r#\"\n+            at input_replace pub macro input_replace\n+            at identity      pub macro identity\n+        \"#]],\n     )\n }\n \n@@ -61,6 +71,9 @@ fn with_existing_attr() {\n             at deny(\u2026)\n             at forbid(\u2026)\n             at warn(\u2026)\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     )\n }\n@@ -90,6 +103,9 @@ fn attr_on_source_file() {\n             at recursion_limit = \"\u2026\"\n             at type_length_limit = \u2026\n             at windows_subsystem = \"\u2026\"\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -113,6 +129,9 @@ fn attr_on_module() {\n             at no_mangle\n             at macro_use\n             at path = \"\u2026\"\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n     check(\n@@ -131,6 +150,9 @@ fn attr_on_module() {\n             at must_use\n             at no_mangle\n             at no_implicit_prelude\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -154,6 +176,9 @@ fn attr_on_macro_rules() {\n             at no_mangle\n             at macro_export\n             at macro_use\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -175,6 +200,9 @@ fn attr_on_macro_def() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -197,6 +225,9 @@ fn attr_on_extern_crate() {\n             at must_use\n             at no_mangle\n             at macro_use\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -218,6 +249,9 @@ fn attr_on_use() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -239,6 +273,9 @@ fn attr_on_type_alias() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -263,6 +300,9 @@ fn attr_on_struct() {\n             at derive(\u2026)\n             at repr(\u2026)\n             at non_exhaustive\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -287,6 +327,9 @@ fn attr_on_enum() {\n             at derive(\u2026)\n             at repr(\u2026)\n             at non_exhaustive\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -308,6 +351,9 @@ fn attr_on_const() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -334,6 +380,9 @@ fn attr_on_static() {\n             at link_section = \"\u2026\"\n             at global_allocator\n             at used\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -356,6 +405,9 @@ fn attr_on_trait() {\n             at must_use\n             at no_mangle\n             at must_use\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -378,6 +430,9 @@ fn attr_on_impl() {\n             at must_use\n             at no_mangle\n             at automatically_derived\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n     check(\n@@ -395,6 +450,9 @@ fn attr_on_impl() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -417,6 +475,9 @@ fn attr_on_extern_block() {\n             at must_use\n             at no_mangle\n             at link\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n     check(\n@@ -435,6 +496,9 @@ fn attr_on_extern_block() {\n             at must_use\n             at no_mangle\n             at link\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -451,6 +515,9 @@ fn attr_on_variant() {\n             at forbid(\u2026)\n             at warn(\u2026)\n             at non_exhaustive\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -487,6 +554,9 @@ fn attr_on_fn() {\n             at target_feature = \"\u2026\"\n             at test\n             at track_caller\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -503,6 +573,9 @@ fn attr_on_expr() {\n             at deny(\u2026)\n             at forbid(\u2026)\n             at warn(\u2026)\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }\n@@ -548,6 +621,9 @@ fn attr_in_source_file_end() {\n             at track_caller\n             at used\n             at warn(\u2026)\n+            kw self\n+            kw super\n+            kw crate\n         \"#]],\n     );\n }"}, {"sha": "ff46dda5e239e9a0ebd56a8069bb21f198067038", "filename": "crates/ide_completion/src/tests/flyimport.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f254dd8555633292c1d7a64c1ddef220be9caa5/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=1f254dd8555633292c1d7a64c1ddef220be9caa5", "patch": "@@ -1043,3 +1043,31 @@ enum Foo {\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn flyimport_attribute() {\n+    check(\n+        r#\"\n+//- proc_macros:identity\n+#[ide$0]\n+struct Foo;\n+\"#,\n+        expect![[r#\"\n+            at identity (use proc_macros::identity) pub macro identity\n+        \"#]],\n+    );\n+    check_edit(\n+        \"identity\",\n+        r#\"\n+//- proc_macros:identity\n+#[ide$0]\n+struct Foo;\n+\"#,\n+        r#\"\n+use proc_macros::identity;\n+\n+#[identity]\n+struct Foo;\n+\"#,\n+    );\n+}"}]}