{"sha": "5d395176809c8f8a8399a8bec31bb2f6cdbf975a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMzk1MTc2ODA5YzhmOGE4Mzk5YThiZWMzMWJiMmY2Y2RiZjk3NWE=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-03-20T08:02:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-20T08:02:01Z"}, "message": "Rollup merge of #69618 - hniksic:mem-forget-doc-fix, r=RalfJung\n\nClarify the relationship between `forget()` and `ManuallyDrop`.\n\nAs discussed on reddit, this commit addresses two issues with the\ndocumentation of `mem::forget()`:\n\n* The documentation of `mem::forget()` can confuse the reader because of the\n  discrepancy between usage examples that show correct usage and the\n  accompanying text which speaks of the possibility of double-free.  The\n  text that says \"if the panic occurs before `mem::forget` was called\"\n  refers to a variant of the second example that was never shown, modified\n  to use `mem::forget` instead of `ManuallyDrop`.  Ideally the documentation\n  should show both variants, so it's clear what it's talking about.\n\n  Also, the double free could be fixed just by placing `mem::forget(v)`\n  before the construction of `s`.  Since the lifetimes of `s` and `v`\n  wouldn't overlap, there would be no point where panic could cause a double\n  free.  This could be mentioned, and contrasted against the more robust fix\n  of using `ManuallyDrop`.\n\n* This sentence seems unjustified: \"For some types, operations such as\n  passing ownership (to a funcion like `mem::forget`) requires them to\n  actually be fully owned right now [...]\".  Unlike C++, Rust has no move\n  constructors, its moves are (possibly elided) bitwise copies.  Even if you\n  pass an invalid object to `mem::forget`, no harm should come to pass\n  because `mem::forget` consumes the object and exists solely to prevent\n  drop, so there no one left to observe the invalid state state.", "tree": {"sha": "4b9df3ffc79987c76b7361ba158faf79a3101a51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b9df3ffc79987c76b7361ba158faf79a3101a51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d395176809c8f8a8399a8bec31bb2f6cdbf975a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJedHh5CRBK7hj4Ov3rIwAAdHIIABkPMUBiLDmZL30RcwNkpdyU\ngCiTgApYmRq1AfUqDszaQM7L/wt384jspLQeaMsxawiK+UPwRyXEgSERkLNs9gxt\nA7U1a49orJ9iSbX3iXABX8+cvZUa44Kl2H1b6wF2De38IRh+gdbyCIXdutp84K7I\n6k7dxbnQV03eGuKV0iBlg+OF7quGlSxXiC8dsddOBpGhzekC809rJDeokUeipSaT\ncNznpUWVwNTuUODNOm5WFJr/iAHzyqXKkeoKnedI51TijZqw1efaVJ/yy7xsdYG2\nAagb+NDuKv7J/8EqUZeyt8dA8BIQRW+1Px+szBrL1PhhMhqab0TmMNBDbp9YglA=\n=Z1o3\n-----END PGP SIGNATURE-----\n", "payload": "tree 4b9df3ffc79987c76b7361ba158faf79a3101a51\nparent f4c675c476c18b1a11041193f2f59d695b126bc8\nparent 2bebe8d87111b544b8f5600fe93cc96391d5c91e\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1584691321 +0900\ncommitter GitHub <noreply@github.com> 1584691321 +0900\n\nRollup merge of #69618 - hniksic:mem-forget-doc-fix, r=RalfJung\n\nClarify the relationship between `forget()` and `ManuallyDrop`.\n\nAs discussed on reddit, this commit addresses two issues with the\ndocumentation of `mem::forget()`:\n\n* The documentation of `mem::forget()` can confuse the reader because of the\n  discrepancy between usage examples that show correct usage and the\n  accompanying text which speaks of the possibility of double-free.  The\n  text that says \"if the panic occurs before `mem::forget` was called\"\n  refers to a variant of the second example that was never shown, modified\n  to use `mem::forget` instead of `ManuallyDrop`.  Ideally the documentation\n  should show both variants, so it's clear what it's talking about.\n\n  Also, the double free could be fixed just by placing `mem::forget(v)`\n  before the construction of `s`.  Since the lifetimes of `s` and `v`\n  wouldn't overlap, there would be no point where panic could cause a double\n  free.  This could be mentioned, and contrasted against the more robust fix\n  of using `ManuallyDrop`.\n\n* This sentence seems unjustified: \"For some types, operations such as\n  passing ownership (to a funcion like `mem::forget`) requires them to\n  actually be fully owned right now [...]\".  Unlike C++, Rust has no move\n  constructors, its moves are (possibly elided) bitwise copies.  Even if you\n  pass an invalid object to `mem::forget`, no harm should come to pass\n  because `mem::forget` consumes the object and exists solely to prevent\n  drop, so there no one left to observe the invalid state state.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d395176809c8f8a8399a8bec31bb2f6cdbf975a", "html_url": "https://github.com/rust-lang/rust/commit/5d395176809c8f8a8399a8bec31bb2f6cdbf975a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d395176809c8f8a8399a8bec31bb2f6cdbf975a/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4c675c476c18b1a11041193f2f59d695b126bc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4c675c476c18b1a11041193f2f59d695b126bc8", "html_url": "https://github.com/rust-lang/rust/commit/f4c675c476c18b1a11041193f2f59d695b126bc8"}, {"sha": "2bebe8d87111b544b8f5600fe93cc96391d5c91e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bebe8d87111b544b8f5600fe93cc96391d5c91e", "html_url": "https://github.com/rust-lang/rust/commit/2bebe8d87111b544b8f5600fe93cc96391d5c91e"}], "stats": {"total": 65, "additions": 49, "deletions": 16}, "files": [{"sha": "dac9ee6a5d91e62342468065861a925c72cd8780", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5d395176809c8f8a8399a8bec31bb2f6cdbf975a/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d395176809c8f8a8399a8bec31bb2f6cdbf975a/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=5d395176809c8f8a8399a8bec31bb2f6cdbf975a", "patch": "@@ -58,7 +58,9 @@ pub use crate::intrinsics::transmute;\n ///\n /// # Examples\n ///\n-/// Leak an I/O object, never closing the file:\n+/// The canonical safe use of `mem::forget` is to circumvent a value's destructor\n+/// implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim\n+/// the space taken by the variable but never close the underlying system resource:\n ///\n /// ```no_run\n /// use std::mem;\n@@ -68,9 +70,40 @@ pub use crate::intrinsics::transmute;\n /// mem::forget(file);\n /// ```\n ///\n-/// The practical use cases for `forget` are rather specialized and mainly come\n-/// up in unsafe or FFI code. However, [`ManuallyDrop`] is usually preferred\n-/// for such cases, e.g.:\n+/// This is useful when the ownership of the underlying resource was previously\n+/// transferred to code outside of Rust, for example by transmitting the raw\n+/// file descriptor to C code.\n+///\n+/// # Relationship with `ManuallyDrop`\n+///\n+/// While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone.\n+/// [`ManuallyDrop`] should be used instead. Consider, for example, this code:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let mut v = vec![65, 122];\n+/// // Build a `String` using the contents of `v`\n+/// let s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\n+/// // leak `v` because its memory is now managed by `s`\n+/// mem::forget(v);  // ERROR - v is invalid and must not be passed to a function\n+/// assert_eq!(s, \"Az\");\n+/// // `s` is implicitly dropped and its memory deallocated.\n+/// ```\n+///\n+/// There are two issues with the above example:\n+///\n+/// * If more code were added between the construction of `String` and the invocation of\n+///   `mem::forget()`, a panic within it would cause a double free because the same memory\n+///   is handled by both `v` and `s`.\n+/// * After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`,\n+///   the `v` value is invalid. Even when a value is just moved to `mem::forget` (which won't\n+///   inspect it), some types have strict requirements on their values that\n+///   make them invalid when dangling or no longer owned. Using invalid values in any\n+///   way, including passing them to or returning them from functions, constitutes\n+///   undefined behavior and may break the assumptions made by the compiler.\n+///\n+/// Switching to `ManuallyDrop` avoids both issues:\n ///\n /// ```\n /// use std::mem::ManuallyDrop;\n@@ -80,24 +113,24 @@ pub use crate::intrinsics::transmute;\n /// // does not get dropped!\n /// let mut v = ManuallyDrop::new(v);\n /// // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n-/// let ptr = v.as_mut_ptr();\n-/// let cap = v.capacity();\n+/// let (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\n /// // Finally, build a `String`.\n-/// let s = unsafe { String::from_raw_parts(ptr, 2, cap) };\n+/// let s = unsafe { String::from_raw_parts(ptr, len, cap) };\n /// assert_eq!(s, \"Az\");\n /// // `s` is implicitly dropped and its memory deallocated.\n /// ```\n ///\n-/// Using `ManuallyDrop` here has two advantages:\n+/// `ManuallyDrop` robustly prevents double-free because we disable `v`'s destructor\n+/// before doing anything else. `mem::forget()` doesn't allow this because it consumes its\n+/// argument, forcing us to call it only after extracting anything we need from `v`. Even\n+/// if a panic were introduced between construction of `ManuallyDrop` and building the\n+/// string (which cannot happen in the code as shown), it would result in a leak and not a\n+/// double free. In other words, `ManuallyDrop` errs on the side of leaking instead of\n+/// erring on the side of (double-)dropping.\n ///\n-/// * We do not \"touch\" `v` after disassembling it. For some types, operations\n-///   such as passing ownership (to a function like `mem::forget`) requires them to actually\n-///   be fully owned right now; that is a promise we do not want to make here as we are\n-///   in the process of transferring ownership to the new `String` we are building.\n-/// * In case of an unexpected panic, `ManuallyDrop` is not dropped, but if the panic\n-///   occurs before `mem::forget` was called we might end up dropping invalid data,\n-///   or double-dropping. In other words, `ManuallyDrop` errs on the side of leaking\n-///   instead of erring on the side of dropping.\n+/// Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the\n+/// ownership to `s` - the final step of interacting with `v` to dispoe of it without\n+/// running its destructor is entirely avoided.\n ///\n /// [drop]: fn.drop.html\n /// [uninit]: fn.uninitialized.html"}]}