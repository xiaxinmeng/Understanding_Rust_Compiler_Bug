{"sha": "4f4f22b11cad95d54dbc59d6613c4df767e7de64", "node_id": "C_kwDOAAsO6NoAKDRmNGYyMmIxMWNhZDk1ZDU0ZGJjNTlkNjYxM2M0ZGY3NjdlN2RlNjQ", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2022-12-01T07:12:04Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2023-05-05T23:04:59Z"}, "message": "Incorporate review feedback from 103926.", "tree": {"sha": "b2ad474842a70d8379f1b65124885651125dd8c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2ad474842a70d8379f1b65124885651125dd8c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f4f22b11cad95d54dbc59d6613c4df767e7de64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4f22b11cad95d54dbc59d6613c4df767e7de64", "html_url": "https://github.com/rust-lang/rust/commit/4f4f22b11cad95d54dbc59d6613c4df767e7de64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f4f22b11cad95d54dbc59d6613c4df767e7de64/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3800535b1c9213fa99d897d317bfcf0ba7bf426", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3800535b1c9213fa99d897d317bfcf0ba7bf426", "html_url": "https://github.com/rust-lang/rust/commit/a3800535b1c9213fa99d897d317bfcf0ba7bf426"}], "stats": {"total": 71, "additions": 33, "deletions": 38}, "files": [{"sha": "356a3b5cb06dabb513dd1873a22d39fc3b145a4a", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f22b11cad95d54dbc59d6613c4df767e7de64/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f22b11cad95d54dbc59d6613c4df767e7de64/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=4f4f22b11cad95d54dbc59d6613c4df767e7de64", "patch": "@@ -729,64 +729,59 @@ pub trait LayoutCalculator {\n             align = align.max(AbiAndPrefAlign::new(repr_align));\n         }\n \n-        let optimize = !repr.inhibit_union_abi_opt();\n+        let mut optimize = !repr.inhibit_union_abi_opt();\n         let mut size = Size::ZERO;\n-        let mut abi = None;\n-        let mut biggest_zst_align = align;\n-        let mut biggest_non_zst_align = align;\n+        let mut common_non_zst_abi_and_align: Option<(Abi, AbiAndPrefAlign)> = None;\n         let only_variant = &variants[FIRST_VARIANT];\n         for field in only_variant {\n-            assert!(!field.0.is_unsized());\n+            assert!(field.0.is_sized());\n \n-            if optimize {\n-                // If all non-ZST fields have the same ABI, forward this ABI\n-                if field.0.is_zst() {\n-                    biggest_zst_align = biggest_zst_align.max(field.align());\n-                } else {\n-                    biggest_non_zst_align = biggest_non_zst_align.max(field.align());\n-                    // Discard valid range information and allow undef\n-                    let field_abi = match field.abi() {\n-                        Abi::Scalar(x) => Abi::Scalar(x.to_union()),\n-                        Abi::ScalarPair(x, y) => Abi::ScalarPair(x.to_union(), y.to_union()),\n-                        Abi::Vector { element: x, count } => {\n-                            Abi::Vector { element: x.to_union(), count }\n-                        }\n-                        Abi::Uninhabited | Abi::Aggregate { .. } => Abi::Aggregate { sized: true },\n-                    };\n+            if !field.0.is_zst() && optimize {\n+                // Discard valid range information and allow undef\n+                let field_abi = field.abi().to_union();\n \n-                    if let Some(abi) = &mut abi {\n-                        if *abi != field_abi {\n-                            // different fields have different ABI: reset to Aggregate\n-                            *abi = Abi::Aggregate { sized: true };\n-                        }\n+                if let Some((abi, align)) = &mut common_non_zst_abi_and_align {\n+                    if *abi != field_abi {\n+                        // Different fields have different ABI: disable opt\n+                        optimize = false;\n                     } else {\n-                        abi = Some(field_abi);\n+                        // Fields with the same non-Aggregate ABI should also\n+                        // have the same alignment\n+                        if !matches!(abi, Abi::Aggregate { .. }) {\n+                            assert_eq!(\n+                                align.abi,\n+                                field.align().abi,\n+                                \"non-Aggregate field with matching ABI but differing alignment\"\n+                            );\n+                        }\n                     }\n+                } else {\n+                    common_non_zst_abi_and_align = Some((field_abi, field.align()));\n                 }\n             }\n \n             align = align.max(field.align());\n             size = cmp::max(size, field.size());\n         }\n \n-        let abi = match abi {\n-            None => Abi::Aggregate { sized: true },\n-            Some(non_zst_abi) => {\n-                if biggest_zst_align.abi > biggest_non_zst_align.abi {\n-                    // If a zst has a bigger alignment than the non-zst fields,\n-                    // we cannot use scalar layout, because scalar(pair)s can't be\n-                    // more aligned than their primitive.\n+        if let Some(pack) = repr.pack {\n+            align = align.min(AbiAndPrefAlign::new(pack));\n+        }\n+\n+        // If all non-ZST fields have the same ABI, we may forward that ABI\n+        // for the union as a whole, unless otherwise inhibited.\n+        let abi = match (optimize, common_non_zst_abi_and_align) {\n+            (false, _) | (_, None) => Abi::Aggregate { sized: true },\n+            (true, Some((abi, _))) => {\n+                if abi.inherent_align(dl).map(|a| a.abi) != Some(align.abi) {\n+                    // Mismatched alignment: disable opt\n                     Abi::Aggregate { sized: true }\n                 } else {\n-                    non_zst_abi\n+                    abi\n                 }\n             }\n         };\n \n-        if let Some(pack) = repr.pack {\n-            align = align.min(AbiAndPrefAlign::new(pack));\n-        }\n-\n         Some(LayoutS {\n             variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Union(NonZeroUsize::new(only_variant.len())?),"}]}