{"sha": "29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YzU4YzQ3M2YwODZhZjFjNTVmNGEzM2VmOWU2Y2JhYTE5ZmZkYjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-18T23:01:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-18T23:01:40Z"}, "message": "Remove the fmt! syntax extension\n\nIt lived a good life, but its time has come. The groundwork is set for the\nofficial transition after the next snapshot (removal of XXX2 macros)", "tree": {"sha": "02e16be2e3a182021a911c7c154d80e9f0ed2800", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02e16be2e3a182021a911c7c154d80e9f0ed2800"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1", "html_url": "https://github.com/rust-lang/rust/commit/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d773a024a2976f2759235551a52101cd08b37cce", "url": "https://api.github.com/repos/rust-lang/rust/commits/d773a024a2976f2759235551a52101cd08b37cce", "html_url": "https://github.com/rust-lang/rust/commit/d773a024a2976f2759235551a52101cd08b37cce"}], "stats": {"total": 1559, "additions": 26, "deletions": 1533}, "files": [{"sha": "8d35e01e4d035a1fbd181e574eac2c5a6111a95a", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1", "patch": "@@ -88,7 +88,7 @@ ifneq ($(wildcard $(NON_BUILD_TARGET_TRIPLES)),)\n CFG_INFO := $(info cfg: non-build target triples $(NON_BUILD_TARGET_TRIPLES))\n endif\n \n-CFG_RUSTC_FLAGS := $(RUSTFLAGS) --cfg nofmt\n+CFG_RUSTC_FLAGS := $(RUSTFLAGS)\n CFG_GCCISH_CFLAGS :=\n CFG_GCCISH_LINK_FLAGS :=\n "}, {"sha": "0131f2c603cdac5c72392bb50e0a5010a5ecfab3", "filename": "src/libstd/unstable/extfmt.rs", "status": "removed", "additions": 0, "deletions": 703, "changes": 703, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,703 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Support for fmt! expressions.\n-//!\n-//! The syntax is close to that of Posix format strings:\n-//!\n-//! ~~~~~~\n-//! Format := '%' Parameter? Flag* Width? Precision? Type\n-//! Parameter := [0-9]+ '$'\n-//! Flag := [ 0#+-]\n-//! Width := Parameter | [0-9]+\n-//! Precision := '.' [0-9]+\n-//! Type := [bcdfiostuxX?]\n-//! ~~~~~~\n-//!\n-//! * Parameter is the 1-based argument to apply the format to. Currently not\n-//! implemented.\n-//! * Flag 0 causes leading zeros to be used for padding when converting\n-//! numbers.\n-//! * Flag # causes the conversion to be done in an *alternative* manner.\n-//! Currently not implemented.\n-//! * Flag + causes signed numbers to always be prepended with a sign\n-//! character.\n-//! * Flag - left justifies the result\n-//! * Width specifies the minimum field width of the result. By default\n-//! leading spaces are added.\n-//! * Precision specifies the minimum number of digits for integral types\n-//! and the minimum number\n-//! of decimal places for float.\n-//!\n-//! The types currently supported are:\n-//!\n-//! * b - bool\n-//! * c - char\n-//! * d - int\n-//! * f - float\n-//! * i - int (same as d)\n-//! * o - uint as octal\n-//! * t - uint as binary\n-//! * u - uint\n-//! * x - uint as lower-case hexadecimal\n-//! * X - uint as upper-case hexadecimal\n-//! * s - str (any flavor)\n-//! * ? - arbitrary type (does not use the to_str trait)\n-\n-/*\n-Syntax Extension: fmt\n-\n-Format a string\n-\n-The 'fmt' extension is modeled on the posix printf system.\n-\n-A posix conversion ostensibly looks like this\n-\n-> %~[parameter]~[flags]~[width]~[.precision]~[length]type\n-\n-Given the different numeric type bestiary we have, we omit the 'length'\n-parameter and support slightly different conversions for 'type'\n-\n-> %~[parameter]~[flags]~[width]~[.precision]type\n-\n-we also only support translating-to-rust a tiny subset of the possible\n-combinations at the moment.\n-\n-Example:\n-\n-debug!(\"hello, %s!\", \"world\");\n-\n-*/\n-\n-use prelude::*;\n-\n-/*\n- * We have a 'ct' (compile-time) module that parses format strings into a\n- * sequence of conversions. From those conversions AST fragments are built\n- * that call into properly-typed functions in the 'rt' (run-time) module.\n- * Each of those run-time conversion functions accepts another conversion\n- * description that specifies how to format its output.\n- *\n- * The building of the AST is currently done in a module inside the compiler,\n- * but should migrate over here as the plugin interface is defined.\n- */\n-\n-// Functions used by the fmt extension at compile time\n-#[doc(hidden)]\n-pub mod ct {\n-    use char;\n-    use container::Container;\n-    use prelude::*;\n-    use str;\n-\n-    #[deriving(Eq)]\n-    pub enum Signedness { Signed, Unsigned, }\n-\n-    #[deriving(Eq)]\n-    pub enum Caseness { CaseUpper, CaseLower, }\n-\n-    #[deriving(Eq)]\n-    pub enum Ty {\n-        TyBool,\n-        TyStr,\n-        TyChar,\n-        TyInt(Signedness),\n-        TyBits,\n-        TyHex(Caseness),\n-        TyOctal,\n-        TyFloat,\n-        TyPointer,\n-        TyPoly,\n-    }\n-\n-    #[deriving(Eq)]\n-    pub enum Flag {\n-        FlagLeftJustify,\n-        FlagLeftZeroPad,\n-        FlagSpaceForSign,\n-        FlagSignAlways,\n-        FlagAlternate,\n-    }\n-\n-    #[deriving(Eq)]\n-    pub enum Count {\n-        CountIs(uint),\n-        CountIsParam(uint),\n-        CountIsNextParam,\n-        CountImplied,\n-    }\n-\n-    #[deriving(Eq)]\n-    struct Parsed<T> {\n-        val: T,\n-        next: uint\n-    }\n-\n-    impl<T> Parsed<T> {\n-        pub fn new(val: T, next: uint) -> Parsed<T> {\n-            Parsed {val: val, next: next}\n-        }\n-    }\n-\n-    // A formatted conversion from an expression to a string\n-    #[deriving(Eq)]\n-    pub struct Conv {\n-        param: Option<uint>,\n-        flags: ~[Flag],\n-        width: Count,\n-        precision: Count,\n-        ty: Ty\n-    }\n-\n-    // A fragment of the output sequence\n-    #[deriving(Eq)]\n-    pub enum Piece {\n-        PieceString(~str),\n-        PieceConv(Conv),\n-    }\n-\n-    pub type ErrorFn<'self> = &'self fn(&str) -> !;\n-\n-    pub fn parse_fmt_string<'a>(s: &str, err: ErrorFn<'a>) -> ~[Piece] {\n-        fn push_slice(ps: &mut ~[Piece], s: &str, from: uint, to: uint) {\n-            if to > from {\n-                ps.push(PieceString(s.slice(from, to).to_owned()));\n-            }\n-        }\n-\n-        let lim = s.len();\n-        let mut h = 0;\n-        let mut i = 0;\n-        let mut pieces = ~[];\n-\n-        while i < lim {\n-            if s[i] == '%' as u8 {\n-                i += 1;\n-\n-                if i >= lim {\n-                    err(\"unterminated conversion at end of string\");\n-                } else if s[i] == '%' as u8 {\n-                    push_slice(&mut pieces, s, h, i);\n-                    i += 1;\n-                } else {\n-                    push_slice(&mut pieces, s, h, i - 1);\n-                    let Parsed {\n-                        val,\n-                        next\n-                    } = parse_conversion(s, i, lim, |s| err(s));\n-                    pieces.push(val);\n-                    i = next;\n-                }\n-\n-                h = i;\n-            } else {\n-                i += str::utf8_char_width(s[i]);\n-            }\n-        }\n-\n-        push_slice(&mut pieces, s, h, i);\n-        pieces\n-    }\n-\n-    pub fn peek_num(s: &str, i: uint, lim: uint) -> Option<Parsed<uint>> {\n-        let mut i = i;\n-        let mut accum = 0;\n-        let mut found = false;\n-\n-        while i < lim {\n-            match char::to_digit(s[i] as char, 10) {\n-                Some(x) => {\n-                    found = true;\n-                    accum *= 10;\n-                    accum += x;\n-                    i += 1;\n-                }\n-                None => break\n-            }\n-        }\n-\n-        if found {\n-            Some(Parsed::new(accum, i))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn parse_conversion<'a>(s: &str, i: uint, lim: uint, err: ErrorFn<'a>)\n-                                -> Parsed<Piece> {\n-        let param = parse_parameter(s, i, lim);\n-        // avoid copying ~[Flag] by destructuring\n-        let Parsed {val: flags_val, next: flags_next} = parse_flags(s,\n-            param.next, lim);\n-        let width = parse_count(s, flags_next, lim);\n-        let prec = parse_precision(s, width.next, lim);\n-        let ty = parse_type(s, prec.next, lim, err);\n-\n-        Parsed::new(PieceConv(Conv {\n-            param: param.val,\n-            flags: flags_val,\n-            width: width.val,\n-            precision: prec.val,\n-            ty: ty.val}), ty.next)\n-    }\n-\n-    pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n-        Parsed<Option<uint>> {\n-        if i >= lim { return Parsed::new(None, i); }\n-\n-        match peek_num(s, i, lim) {\n-            Some(num) if num.next < lim && s[num.next] == '$' as u8 =>\n-                Parsed::new(Some(num.val), num.next + 1),\n-            _ => Parsed::new(None, i)\n-        }\n-    }\n-\n-    pub fn parse_flags(s: &str, i: uint, lim: uint) -> Parsed<~[Flag]> {\n-        let mut i = i;\n-        let mut flags = ~[];\n-\n-        while i < lim {\n-            let f = match s[i] as char {\n-                '-' => FlagLeftJustify,\n-                '0' => FlagLeftZeroPad,\n-                ' ' => FlagSpaceForSign,\n-                '+' => FlagSignAlways,\n-                '#' => FlagAlternate,\n-                _ => break\n-            };\n-\n-            flags.push(f);\n-            i += 1;\n-        }\n-\n-        Parsed::new(flags, i)\n-    }\n-\n-    pub fn parse_count(s: &str, i: uint, lim: uint) -> Parsed<Count> {\n-        if i >= lim {\n-            Parsed::new(CountImplied, i)\n-        } else if s[i] == '*' as u8 {\n-            let param = parse_parameter(s, i + 1, lim);\n-            let j = param.next;\n-\n-            match param.val {\n-                None => Parsed::new(CountIsNextParam, j),\n-                Some(n) => Parsed::new(CountIsParam(n), j)\n-            }\n-        } else {\n-            match peek_num(s, i, lim) {\n-                None => Parsed::new(CountImplied, i),\n-                Some(num) => Parsed::new(CountIs(num.val), num.next)\n-            }\n-        }\n-    }\n-\n-    pub fn parse_precision(s: &str, i: uint, lim: uint) -> Parsed<Count> {\n-        if i < lim && s[i] == '.' as u8 {\n-            let count = parse_count(s, i + 1, lim);\n-\n-            // If there were no digits specified, i.e. the precision\n-            // was \".\", then the precision is 0\n-            match count.val {\n-                CountImplied => Parsed::new(CountIs(0), count.next),\n-                _ => count\n-            }\n-        } else {\n-            Parsed::new(CountImplied, i)\n-        }\n-    }\n-\n-    pub fn parse_type<'a>(s: &str, i: uint, lim: uint, err: ErrorFn<'a>)\n-                          -> Parsed<Ty> {\n-        if i >= lim { err(\"missing type in conversion\"); }\n-\n-        // FIXME (#2249): Do we really want two signed types here?\n-        // How important is it to be printf compatible?\n-        let t = match s[i] as char {\n-            'b' => TyBool,\n-            's' => TyStr,\n-            'c' => TyChar,\n-            'd' | 'i' => TyInt(Signed),\n-            'u' => TyInt(Unsigned),\n-            'x' => TyHex(CaseLower),\n-            'X' => TyHex(CaseUpper),\n-            't' => TyBits,\n-            'o' => TyOctal,\n-            'f' => TyFloat,\n-            'p' => TyPointer,\n-            '?' => TyPoly,\n-            _ => err(format!(\"unknown type in conversion: {}\", s.char_at(i)))\n-        };\n-\n-        Parsed::new(t, i + 1)\n-    }\n-\n-    #[cfg(test)]\n-    fn die(s: &str) -> ! { fail2!(s.to_owned()) }\n-\n-    #[test]\n-    fn test_parse_count() {\n-        fn test(s: &str, count: Count, next: uint) -> bool {\n-            parse_count(s, 0, s.len()) == Parsed::new(count, next)\n-        }\n-\n-        assert!(test(\"\", CountImplied, 0));\n-        assert!(test(\"*\", CountIsNextParam, 1));\n-        assert!(test(\"*1\", CountIsNextParam, 1));\n-        assert!(test(\"*1$\", CountIsParam(1), 3));\n-        assert!(test(\"123\", CountIs(123), 3));\n-    }\n-\n-    #[test]\n-    fn test_parse_flags() {\n-        fn pack(fs: &[Flag]) -> uint {\n-            fs.iter().fold(0, |p, &f| p | (1 << f as uint))\n-        }\n-\n-        fn test(s: &str, flags: &[Flag], next: uint) {\n-            let f = parse_flags(s, 0, s.len());\n-            assert_eq!(pack(f.val), pack(flags));\n-            assert_eq!(f.next, next);\n-        }\n-\n-        test(\"\", [], 0);\n-        test(\"!#-+ 0\", [], 0);\n-        test(\"#-+\", [FlagAlternate, FlagLeftJustify, FlagSignAlways], 3);\n-        test(\" 0\", [FlagSpaceForSign, FlagLeftZeroPad], 2);\n-    }\n-\n-    #[test]\n-    fn test_parse_fmt_string() {\n-        assert!(parse_fmt_string(\"foo %s bar\", die) == ~[\n-            PieceString(~\"foo \"),\n-            PieceConv(Conv {\n-                param: None,\n-                flags: ~[],\n-                width: CountImplied,\n-                precision: CountImplied,\n-                ty: TyStr,\n-            }),\n-            PieceString(~\" bar\")]);\n-\n-        assert!(parse_fmt_string(\"%s\", die) == ~[\n-            PieceConv(Conv {\n-                param: None,\n-                flags: ~[],\n-                width: CountImplied,\n-                precision: CountImplied,\n-                ty: TyStr,\n-            })]);\n-\n-        assert!(parse_fmt_string(\"%%%%\", die) == ~[\n-            PieceString(~\"%\"), PieceString(~\"%\")]);\n-    }\n-\n-    #[test]\n-    fn test_parse_parameter() {\n-        fn test(s: &str, param: Option<uint>, next: uint) -> bool {\n-            parse_parameter(s, 0, s.len()) == Parsed::new(param, next)\n-        }\n-\n-        assert!(test(\"\", None, 0));\n-        assert!(test(\"foo\", None, 0));\n-        assert!(test(\"123\", None, 0));\n-        assert!(test(\"123$\", Some(123), 4));\n-    }\n-\n-    #[test]\n-    fn test_parse_precision() {\n-        fn test(s: &str, count: Count, next: uint) -> bool {\n-            parse_precision(s, 0, s.len()) == Parsed::new(count, next)\n-        }\n-\n-        assert!(test(\"\", CountImplied, 0));\n-        assert!(test(\".\", CountIs(0), 1));\n-        assert!(test(\".*\", CountIsNextParam, 2));\n-        assert!(test(\".*1\", CountIsNextParam, 2));\n-        assert!(test(\".*1$\", CountIsParam(1), 4));\n-        assert!(test(\".123\", CountIs(123), 4));\n-    }\n-\n-    #[test]\n-    fn test_parse_type() {\n-        fn test(s: &str, ty: Ty) -> bool {\n-            parse_type(s, 0, s.len(), die) == Parsed::new(ty, 1)\n-        }\n-\n-        assert!(test(\"b\", TyBool));\n-        assert!(test(\"c\", TyChar));\n-        assert!(test(\"d\", TyInt(Signed)));\n-        assert!(test(\"f\", TyFloat));\n-        assert!(test(\"i\", TyInt(Signed)));\n-        assert!(test(\"o\", TyOctal));\n-        assert!(test(\"s\", TyStr));\n-        assert!(test(\"t\", TyBits));\n-        assert!(test(\"x\", TyHex(CaseLower)));\n-        assert!(test(\"X\", TyHex(CaseUpper)));\n-        assert!(test(\"p\", TyPointer));\n-        assert!(test(\"?\", TyPoly));\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_parse_type_missing() {\n-        parse_type(\"\", 0, 0, die);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_parse_type_unknown() {\n-        parse_type(\"!\", 0, 1, die);\n-    }\n-\n-    #[test]\n-    fn test_peek_num() {\n-        let s1 = \"\";\n-        assert!(peek_num(s1, 0, s1.len()).is_none());\n-\n-        let s2 = \"foo\";\n-        assert!(peek_num(s2, 0, s2.len()).is_none());\n-\n-        let s3 = \"123\";\n-        assert_eq!(peek_num(s3, 0, s3.len()), Some(Parsed::new(123, 3)));\n-\n-        let s4 = \"123foo\";\n-        assert_eq!(peek_num(s4, 0, s4.len()), Some(Parsed::new(123, 3)));\n-    }\n-}\n-\n-// Functions used by the fmt extension at runtime. For now there are a lot of\n-// decisions made a runtime. If it proves worthwhile then some of these\n-// conditions can be evaluated at compile-time. For now though it's cleaner to\n-// implement it this way, I think.\n-#[doc(hidden)]\n-#[allow(non_uppercase_statics)]\n-pub mod rt {\n-    use f64;\n-    use str;\n-    use sys;\n-    use num;\n-    use vec;\n-    use option::{Some, None, Option};\n-\n-    pub static flag_none : u32 = 0u32;\n-    pub static flag_left_justify   : u32 = 0b00000000000001u32;\n-    pub static flag_left_zero_pad  : u32 = 0b00000000000010u32;\n-    pub static flag_space_for_sign : u32 = 0b00000000000100u32;\n-    pub static flag_sign_always    : u32 = 0b00000000001000u32;\n-    pub static flag_alternate      : u32 = 0b00000000010000u32;\n-\n-    pub enum Count { CountIs(uint), CountImplied, }\n-\n-    pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n-\n-    pub struct Conv {\n-        flags: u32,\n-        width: Count,\n-        precision: Count,\n-        ty: Ty,\n-    }\n-\n-    pub fn conv_int(cv: Conv, i: int, buf: &mut ~str) {\n-        let radix = 10;\n-        let prec = get_int_precision(cv);\n-        let s : ~str = uint_to_str_prec(num::abs(i) as uint, radix, prec);\n-\n-        let head = if i >= 0 {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                Some('+')\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                Some(' ')\n-            } else {\n-                None\n-            }\n-        } else { Some('-') };\n-        pad(cv, s, head, PadSigned, buf);\n-    }\n-    pub fn conv_uint(cv: Conv, u: uint, buf: &mut ~str) {\n-        let prec = get_int_precision(cv);\n-        let rs =\n-            match cv.ty {\n-              TyDefault => uint_to_str_prec(u, 10, prec),\n-              TyHexLower => uint_to_str_prec(u, 16, prec),\n-\n-              // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-              // to_ascii_move and to_str_move to not do a unnecessary copy.\n-              TyHexUpper => {\n-                let s = uint_to_str_prec(u, 16, prec);\n-                s.to_ascii().to_upper().to_str_ascii()\n-              }\n-              TyBits => uint_to_str_prec(u, 2, prec),\n-              TyOctal => uint_to_str_prec(u, 8, prec)\n-            };\n-        pad(cv, rs, None, PadUnsigned, buf);\n-    }\n-    pub fn conv_bool(cv: Conv, b: bool, buf: &mut ~str) {\n-        let s = if b { \"true\" } else { \"false\" };\n-        // run the boolean conversion through the string conversion logic,\n-        // giving it the same rules for precision, etc.\n-        conv_str(cv, s, buf);\n-    }\n-    pub fn conv_char(cv: Conv, c: char, buf: &mut ~str) {\n-        pad(cv, \"\", Some(c), PadNozero, buf);\n-    }\n-    pub fn conv_str(cv: Conv, s: &str, buf: &mut ~str) {\n-        // For strings, precision is the maximum characters\n-        // displayed\n-        let unpadded = match cv.precision {\n-            CountImplied => s,\n-            CountIs(max) => {\n-                if (max as uint) < s.char_len() {\n-                    s.slice(0, max as uint)\n-                } else {\n-                    s\n-                }\n-            }\n-        };\n-        pad(cv, unpadded, None, PadNozero, buf);\n-    }\n-    pub fn conv_float(cv: Conv, f: f64, buf: &mut ~str) {\n-        let (to_str, digits) = match cv.precision {\n-              CountIs(c) => (f64::to_str_exact, c as uint),\n-              CountImplied => (f64::to_str_digits, 6u)\n-        };\n-        let s = to_str(f, digits);\n-        let head = if 0.0 <= f {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                Some('+')\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                Some(' ')\n-            } else {\n-                None\n-            }\n-        } else { None };\n-        pad(cv, s, head, PadFloat, buf);\n-    }\n-    pub fn conv_pointer<T>(cv: Conv, ptr: *T, buf: &mut ~str) {\n-        let s = ~\"0x\" + uint_to_str_prec(ptr as uint, 16, 1u);\n-        pad(cv, s, None, PadNozero, buf);\n-    }\n-    pub fn conv_poly<T>(cv: Conv, v: &T, buf: &mut ~str) {\n-        let s = sys::log_str(v);\n-        conv_str(cv, s, buf);\n-    }\n-\n-    // Convert a uint to string with a minimum number of digits.  If precision\n-    // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to uint: but it doesn't seem all that useful.\n-    pub fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n-        return if prec == 0u && num == 0u {\n-                ~\"\"\n-            } else {\n-                let s = num.to_str_radix(radix);\n-                let len = s.char_len();\n-                if len < prec {\n-                    let diff = prec - len;\n-                    let pad = str::from_chars(vec::from_elem(diff, '0'));\n-                    pad + s\n-                } else { s }\n-            };\n-    }\n-    pub fn get_int_precision(cv: Conv) -> uint {\n-        return match cv.precision {\n-              CountIs(c) => c as uint,\n-              CountImplied => 1u\n-            };\n-    }\n-\n-    #[deriving(Eq)]\n-    pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n-\n-    pub fn pad(cv: Conv, s: &str, head: Option<char>, mode: PadMode,\n-               buf: &mut ~str) {\n-        let headsize = match head { Some(_) => 1, _ => 0 };\n-        let uwidth : uint = match cv.width {\n-            CountImplied => {\n-                for &c in head.iter() {\n-                    buf.push_char(c);\n-                }\n-                return buf.push_str(s);\n-            }\n-            CountIs(width) => { width as uint }\n-        };\n-        let strlen = s.char_len() + headsize;\n-        if uwidth <= strlen {\n-            for &c in head.iter() {\n-                buf.push_char(c);\n-            }\n-            return buf.push_str(s);\n-        }\n-        let mut padchar = ' ';\n-        let diff = uwidth - strlen;\n-        if have_flag(cv.flags, flag_left_justify) {\n-            for &c in head.iter() {\n-                buf.push_char(c);\n-            }\n-            buf.push_str(s);\n-            do diff.times {\n-                buf.push_char(padchar);\n-            }\n-            return;\n-        }\n-        let (might_zero_pad, signed) = match mode {\n-          PadNozero   => (false, true),\n-          PadSigned   => (true, true),\n-          PadFloat    => (true, true),\n-          PadUnsigned => (true, false)\n-        };\n-        fn have_precision(cv: Conv) -> bool {\n-            return match cv.precision { CountImplied => false, _ => true };\n-        }\n-        let zero_padding = {\n-            if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n-                (!have_precision(cv) || mode == PadFloat) {\n-                padchar = '0';\n-                true\n-            } else {\n-                false\n-            }\n-        };\n-        let padstr = str::from_chars(vec::from_elem(diff, padchar));\n-        // This is completely heinous. If we have a signed value then\n-        // potentially rip apart the intermediate result and insert some\n-        // zeros. It may make sense to convert zero padding to a precision\n-        // instead.\n-\n-        if signed && zero_padding {\n-            for &head in head.iter() {\n-                if head == '+' || head == '-' || head == ' ' {\n-                    buf.push_char(head);\n-                    buf.push_str(padstr);\n-                    buf.push_str(s);\n-                    return;\n-                }\n-            }\n-        }\n-        buf.push_str(padstr);\n-        for &c in head.iter() {\n-            buf.push_char(c);\n-        }\n-        buf.push_str(s);\n-    }\n-    #[inline]\n-    pub fn have_flag(flags: u32, f: u32) -> bool {\n-        flags & f != 0\n-    }\n-}\n-\n-// Bulk of the tests are in src/test/run-pass/syntax-extension-fmt.rs\n-#[cfg(test)]\n-mod test {\n-    #[test]\n-    fn fmt_slice() {\n-        let s = \"abc\";\n-        let _s = format!(\"{}\", s);\n-    }\n-}"}, {"sha": "835b16996b5f27deede094122f2935354e09989c", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1", "patch": "@@ -21,7 +21,6 @@ pub mod dynamic_lib;\n pub mod finally;\n pub mod intrinsics;\n pub mod simd;\n-pub mod extfmt;\n #[cfg(not(test))]\n pub mod lang;\n pub mod sync;"}, {"sha": "78c4d6b6f4b3bd04706a553b68a4d7c43366377d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1", "patch": "@@ -222,7 +222,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 span: None,\n                             } as @SyntaxExpanderTTItemTrait,\n                             None)));\n-    syntax_expanders.insert(intern(&\"oldfmt\"),\n+    syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt_no_ctxt(\n                                 ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"format_args\"),"}, {"sha": "bc91283b47bb30422e90dc825c05b0030226eae7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 16, "deletions": 52, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1", "patch": "@@ -809,51 +809,7 @@ pub fn std_macros() -> @str {\n \n     macro_rules! ignore (($($x:tt)*) => (()))\n \n-    #[cfg(not(nofmt))]\n-    mod fmt_extension {\n-        #[macro_escape];\n-\n-        macro_rules! fmt(($($arg:tt)*) => (oldfmt!($($arg)*)))\n-\n-        macro_rules! log(\n-            ($lvl:expr, $arg:expr) => ({\n-                let lvl = $lvl;\n-                if lvl <= __log_level() {\n-                    format_args!(|args| {\n-                        ::std::logging::log(lvl, args)\n-                    }, \\\"{}\\\", fmt!(\\\"%?\\\", $arg))\n-                }\n-            });\n-            ($lvl:expr, $($arg:expr),+) => ({\n-                let lvl = $lvl;\n-                if lvl <= __log_level() {\n-                    format_args!(|args| {\n-                        ::std::logging::log(lvl, args)\n-                    }, \\\"{}\\\", fmt!($($arg),+))\n-                }\n-            })\n-        )\n-        macro_rules! error( ($($arg:tt)*) => (log!(1u32, $($arg)*)) )\n-        macro_rules! warn ( ($($arg:tt)*) => (log!(2u32, $($arg)*)) )\n-        macro_rules! info ( ($($arg:tt)*) => (log!(3u32, $($arg)*)) )\n-        macro_rules! debug( ($($arg:tt)*) => (\n-            if cfg!(not(ndebug)) { log!(4u32, $($arg)*) }\n-        ))\n-\n-        macro_rules! fail(\n-            () => (\n-                fail2!(\\\"explicit failure\\\")\n-            );\n-            ($msg:expr) => (\n-                ::std::sys::FailWithCause::fail_with($msg, file!(), line!())\n-            );\n-            ($( $arg:expr ),+) => (\n-                ::std::sys::FailWithCause::fail_with(fmt!( $($arg),+ ), file!(), line!())\n-            )\n-        )\n-    }\n-\n-    macro_rules! log2(\n+    macro_rules! log(\n         ($lvl:expr, $($arg:tt)+) => ({\n             let lvl = $lvl;\n             if lvl <= __log_level() {\n@@ -863,16 +819,16 @@ pub fn std_macros() -> @str {\n             }\n         })\n     )\n-    macro_rules! error2( ($($arg:tt)*) => (log2!(1u32, $($arg)*)) )\n-    macro_rules! warn2 ( ($($arg:tt)*) => (log2!(2u32, $($arg)*)) )\n-    macro_rules! info2 ( ($($arg:tt)*) => (log2!(3u32, $($arg)*)) )\n-    macro_rules! debug2( ($($arg:tt)*) => (\n-        if cfg!(not(ndebug)) { log2!(4u32, $($arg)*) }\n+    macro_rules! error( ($($arg:tt)*) => (log!(1u32, $($arg)*)) )\n+    macro_rules! warn ( ($($arg:tt)*) => (log!(2u32, $($arg)*)) )\n+    macro_rules! info ( ($($arg:tt)*) => (log!(3u32, $($arg)*)) )\n+    macro_rules! debug( ($($arg:tt)*) => (\n+        if cfg!(not(ndebug)) { log!(4u32, $($arg)*) }\n     ))\n \n-    macro_rules! fail2(\n+    macro_rules! fail(\n         () => (\n-            fail2!(\\\"explicit failure\\\")\n+            fail!(\\\"explicit failure\\\")\n         );\n         ($fmt:expr) => (\n             ::std::sys::FailWithCause::fail_with($fmt, file!(), line!())\n@@ -882,6 +838,14 @@ pub fn std_macros() -> @str {\n         )\n     )\n \n+    // NOTE (acrichto): remove these after the next snapshot\n+    macro_rules! log2( ($($arg:tt)*) => (log!($($arg)*)) )\n+    macro_rules! error2( ($($arg:tt)*) => (error!($($arg)*)) )\n+    macro_rules! warn2 ( ($($arg:tt)*) => (warn!($($arg)*)) )\n+    macro_rules! info2 ( ($($arg:tt)*) => (info!($($arg)*)) )\n+    macro_rules! debug2( ($($arg:tt)*) => (debug!($($arg)*)) )\n+    macro_rules! fail2( ($($arg:tt)*) => (fail!($($arg)*)) )\n+\n     macro_rules! assert(\n         ($cond:expr) => {\n             if !$cond {"}, {"sha": "5e3e4e15d8e74db55aa5b5ce553e88328de60ba1", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 8, "deletions": 309, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=29c58c473f086af1c55f4a33ef9e6cbaa19ffdb1", "patch": "@@ -8,320 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n- * The compiler code necessary to support the fmt! extension. Eventually this\n- * should all get sucked into either the standard library extfmt module or the\n- * compiler syntax extension plugin interface.\n- */\n+/// Deprecated fmt! syntax extension\n \n use ast;\n use codemap::Span;\n-use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n \n-use std::option;\n-use std::unstable::extfmt::ct::*;\n-use parse::token::{str_to_ident};\n+pub fn expand_syntax_ext(ecx: @base::ExtCtxt, sp: Span,\n+                         _tts: &[ast::token_tree]) -> base::MacResult {\n+    ecx.span_err(sp, \"`fmt!` is deprecated, use `format!` instead\");\n+    ecx.parse_sess.span_diagnostic.span_note(sp,\n+        \"see http://static.rust-lang.org/doc/master/std/fmt/index.html \\\n+         for documentation\");\n \n-pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n-    -> base::MacResult {\n-    let args = get_exprs_from_tts(cx, sp, tts);\n-    if args.len() == 0 {\n-        cx.span_fatal(sp, \"fmt! takes at least 1 argument.\");\n-    }\n-    let (fmt, _fmt_str_style) =\n-        expr_to_str(cx, args[0],\n-                    \"first argument to fmt! must be a string literal.\");\n-    let fmtspan = args[0].span;\n-    debug2!(\"Format string: {}\", fmt);\n-    fn parse_fmt_err_(cx: @ExtCtxt, sp: Span, msg: &str) -> ! {\n-        cx.span_fatal(sp, msg);\n-    }\n-    let parse_fmt_err: &fn(&str) -> ! = |s| parse_fmt_err_(cx, fmtspan, s);\n-    let pieces = parse_fmt_string(fmt, parse_fmt_err);\n-    MRExpr(pieces_to_expr(cx, sp, pieces, args))\n-}\n-\n-// FIXME (#2249): A lot of these functions for producing expressions can\n-// probably be factored out in common with other code that builds\n-// expressions.  Also: Cleanup the naming of these functions.\n-// Note: Moved many of the common ones to build.rs --kevina\n-fn pieces_to_expr(cx: @ExtCtxt, sp: Span,\n-                  pieces: ~[Piece], args: ~[@ast::Expr])\n-   -> @ast::Expr {\n-    fn make_path_vec(ident: &str) -> ~[ast::Ident] {\n-        return ~[str_to_ident(\"std\"),\n-                 str_to_ident(\"unstable\"),\n-                 str_to_ident(\"extfmt\"),\n-                 str_to_ident(\"rt\"),\n-                 str_to_ident(ident)];\n-    }\n-    fn make_rt_path_expr(cx: @ExtCtxt, sp: Span, nm: &str) -> @ast::Expr {\n-        let path = make_path_vec(nm);\n-        cx.expr_path(cx.path_global(sp, path))\n-    }\n-    // Produces an AST expression that represents a RT::conv record,\n-    // which tells the RT::conv* functions how to perform the conversion\n-\n-    fn make_rt_conv_expr(cx: @ExtCtxt, sp: Span, cnv: &Conv) -> @ast::Expr {\n-        fn make_flags(cx: @ExtCtxt, sp: Span, flags: &[Flag]) -> @ast::Expr {\n-            let mut tmp_expr = make_rt_path_expr(cx, sp, \"flag_none\");\n-            for f in flags.iter() {\n-                let fstr = match *f {\n-                  FlagLeftJustify => \"flag_left_justify\",\n-                  FlagLeftZeroPad => \"flag_left_zero_pad\",\n-                  FlagSpaceForSign => \"flag_space_for_sign\",\n-                  FlagSignAlways => \"flag_sign_always\",\n-                  FlagAlternate => \"flag_alternate\"\n-                };\n-                tmp_expr = cx.expr_binary(sp, ast::BiBitOr, tmp_expr,\n-                                          make_rt_path_expr(cx, sp, fstr));\n-            }\n-            return tmp_expr;\n-        }\n-        fn make_count(cx: @ExtCtxt, sp: Span, cnt: Count) -> @ast::Expr {\n-            match cnt {\n-              CountImplied => {\n-                return make_rt_path_expr(cx, sp, \"CountImplied\");\n-              }\n-              CountIs(c) => {\n-                let count_lit = cx.expr_uint(sp, c as uint);\n-                let count_is_path = make_path_vec(\"CountIs\");\n-                let count_is_args = ~[count_lit];\n-                return cx.expr_call_global(sp, count_is_path, count_is_args);\n-              }\n-              _ => cx.span_unimpl(sp, \"unimplemented fmt! conversion\")\n-            }\n-        }\n-        fn make_ty(cx: @ExtCtxt, sp: Span, t: Ty) -> @ast::Expr {\n-            let rt_type = match t {\n-              TyHex(c) => match c {\n-                CaseUpper =>  \"TyHexUpper\",\n-                CaseLower =>  \"TyHexLower\"\n-              },\n-              TyBits =>  \"TyBits\",\n-              TyOctal =>  \"TyOctal\",\n-              _ =>  \"TyDefault\"\n-            };\n-            return make_rt_path_expr(cx, sp, rt_type);\n-        }\n-        fn make_conv_struct(cx: @ExtCtxt, sp: Span, flags_expr: @ast::Expr,\n-                         width_expr: @ast::Expr, precision_expr: @ast::Expr,\n-                         ty_expr: @ast::Expr) -> @ast::Expr {\n-            cx.expr_struct(\n-                sp,\n-                cx.path_global(sp, make_path_vec(\"Conv\")),\n-                ~[\n-                    cx.field_imm(sp, str_to_ident(\"flags\"), flags_expr),\n-                    cx.field_imm(sp, str_to_ident(\"width\"), width_expr),\n-                    cx.field_imm(sp, str_to_ident(\"precision\"), precision_expr),\n-                    cx.field_imm(sp, str_to_ident(\"ty\"), ty_expr)\n-                ]\n-            )\n-        }\n-        let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n-        let rt_conv_width = make_count(cx, sp, cnv.width);\n-        let rt_conv_precision = make_count(cx, sp, cnv.precision);\n-        let rt_conv_ty = make_ty(cx, sp, cnv.ty);\n-        make_conv_struct(cx, sp, rt_conv_flags, rt_conv_width,\n-                         rt_conv_precision, rt_conv_ty)\n-    }\n-    fn make_conv_call(cx: @ExtCtxt, sp: Span, conv_type: &str, cnv: &Conv,\n-                      arg: @ast::Expr, buf: @ast::Expr) -> @ast::Expr {\n-        let fname = ~\"conv_\" + conv_type;\n-        let path = make_path_vec(fname);\n-        let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n-        let args = ~[cnv_expr, arg, buf];\n-        cx.expr_call_global(arg.span, path, args)\n-    }\n-\n-    fn make_new_conv(cx: @ExtCtxt, sp: Span, cnv: &Conv,\n-                     arg: @ast::Expr, buf: @ast::Expr) -> @ast::Expr {\n-        fn is_signed_type(cnv: &Conv) -> bool {\n-            match cnv.ty {\n-              TyInt(s) => match s {\n-                Signed => return true,\n-                Unsigned => return false\n-              },\n-              TyFloat => return true,\n-              _ => return false\n-            }\n-        }\n-        let unsupported = ~\"conversion not supported in fmt! string\";\n-        match cnv.param {\n-          option::None => (),\n-          _ => cx.span_unimpl(sp, unsupported)\n-        }\n-        for f in cnv.flags.iter() {\n-            match *f {\n-              FlagLeftJustify => (),\n-              FlagSignAlways => {\n-                if !is_signed_type(cnv) {\n-                    cx.span_fatal(sp,\n-                                  \"+ flag only valid in \\\n-                                   signed fmt! conversion\");\n-                }\n-              }\n-              FlagSpaceForSign => {\n-                if !is_signed_type(cnv) {\n-                    cx.span_fatal(sp,\n-                                  \"space flag only valid in \\\n-                                   signed fmt! conversions\");\n-                }\n-              }\n-              FlagLeftZeroPad => (),\n-              _ => cx.span_unimpl(sp, unsupported)\n-            }\n-        }\n-        match cnv.width {\n-          CountImplied => (),\n-          CountIs(_) => (),\n-          _ => cx.span_unimpl(sp, unsupported)\n-        }\n-        match cnv.precision {\n-          CountImplied => (),\n-          CountIs(_) => (),\n-          _ => cx.span_unimpl(sp, unsupported)\n-        }\n-        let (name, actual_arg) = match cnv.ty {\n-            TyStr => (\"str\", arg),\n-            TyInt(Signed) => (\"int\", arg),\n-            TyBool => (\"bool\", arg),\n-            TyChar => (\"char\", arg),\n-            TyBits | TyOctal | TyHex(_) | TyInt(Unsigned) => (\"uint\", arg),\n-            TyFloat => (\"float\", arg),\n-            TyPointer => (\"pointer\", arg),\n-            TyPoly => (\"poly\", cx.expr_addr_of(sp, arg))\n-        };\n-        return make_conv_call(cx, arg.span, name, cnv, actual_arg,\n-                              cx.expr_mut_addr_of(arg.span, buf));\n-    }\n-    fn log_conv(c: &Conv) {\n-        debug2!(\"Building conversion:\");\n-        match c.param {\n-          Some(p) => { debug2!(\"param: {}\", p.to_str()); }\n-          _ => debug2!(\"param: none\")\n-        }\n-        for f in c.flags.iter() {\n-            match *f {\n-              FlagLeftJustify => debug2!(\"flag: left justify\"),\n-              FlagLeftZeroPad => debug2!(\"flag: left zero pad\"),\n-              FlagSpaceForSign => debug2!(\"flag: left space pad\"),\n-              FlagSignAlways => debug2!(\"flag: sign always\"),\n-              FlagAlternate => debug2!(\"flag: alternate\")\n-            }\n-        }\n-        match c.width {\n-          CountIs(i) =>\n-              debug2!(\"width: count is {}\", i.to_str()),\n-          CountIsParam(i) =>\n-              debug2!(\"width: count is param {}\", i.to_str()),\n-          CountIsNextParam => debug2!(\"width: count is next param\"),\n-          CountImplied => debug2!(\"width: count is implied\")\n-        }\n-        match c.precision {\n-          CountIs(i) =>\n-              debug2!(\"prec: count is {}\", i.to_str()),\n-          CountIsParam(i) =>\n-              debug2!(\"prec: count is param {}\", i.to_str()),\n-          CountIsNextParam => debug2!(\"prec: count is next param\"),\n-          CountImplied => debug2!(\"prec: count is implied\")\n-        }\n-        match c.ty {\n-          TyBool => debug2!(\"type: bool\"),\n-          TyStr => debug2!(\"type: str\"),\n-          TyChar => debug2!(\"type: char\"),\n-          TyInt(s) => match s {\n-            Signed => debug2!(\"type: signed\"),\n-            Unsigned => debug2!(\"type: unsigned\")\n-          },\n-          TyBits => debug2!(\"type: bits\"),\n-          TyHex(cs) => match cs {\n-            CaseUpper => debug2!(\"type: uhex\"),\n-            CaseLower => debug2!(\"type: lhex\"),\n-          },\n-          TyOctal => debug2!(\"type: octal\"),\n-          TyFloat => debug2!(\"type: float\"),\n-          TyPointer => debug2!(\"type: pointer\"),\n-          TyPoly => debug2!(\"type: poly\")\n-        }\n-    }\n-\n-    /* Short circuit an easy case up front (won't work otherwise) */\n-    if pieces.len() == 0 {\n-        return cx.expr_str_uniq(args[0].span, @\"\");\n-    }\n-\n-    let fmt_sp = args[0].span;\n-    let mut n = 0u;\n-    let nargs = args.len();\n-\n-    /* 'ident' is the local buffer building up the result of fmt! */\n-    let ident = str_to_ident(\"__fmtbuf\");\n-    let buf = || cx.expr_ident(fmt_sp, ident);\n-    let core_ident = str_to_ident(\"std\");\n-    let str_ident = str_to_ident(\"str\");\n-    let push_ident = str_to_ident(\"push_str\");\n-    let mut stms = ~[];\n-\n-    /* Translate each piece (portion of the fmt expression) by invoking the\n-       corresponding function in std::unstable::extfmt. Each function takes a\n-       buffer to insert data into along with the data being formatted. */\n-    let npieces = pieces.len();\n-    for (i, pc) in pieces.move_iter().enumerate() {\n-        match pc {\n-            /* Raw strings get appended via str::push_str */\n-            PieceString(s) => {\n-                /* If this is the first portion, then initialize the local\n-                   buffer with it directly. If it's actually the only piece,\n-                   then there's no need for it to be mutable */\n-                if i == 0 {\n-                    stms.push(cx.stmt_let(fmt_sp, npieces > 1,\n-                                          ident, cx.expr_str_uniq(fmt_sp, s.to_managed())));\n-                } else {\n-                    // we call the push_str function because the\n-                    // bootstrap doesnt't seem to work if we call the\n-                    // method.\n-                    let args = ~[cx.expr_mut_addr_of(fmt_sp, buf()),\n-                                 cx.expr_str(fmt_sp, s.to_managed())];\n-                    let call = cx.expr_call_global(fmt_sp,\n-                                                   ~[core_ident,\n-                                                     str_ident,\n-                                                     push_ident],\n-                                                   args);\n-                    stms.push(cx.stmt_expr(call));\n-                }\n-            }\n-\n-            /* Invoke the correct conv function in extfmt */\n-            PieceConv(ref conv) => {\n-                n += 1u;\n-                if n >= nargs {\n-                    cx.span_fatal(sp,\n-                                  \"not enough arguments to fmt! \\\n-                                   for the given format string\");\n-                }\n-\n-                log_conv(conv);\n-                /* If the first portion is a conversion, then the local buffer\n-                   must be initialized as an empty string */\n-                if i == 0 {\n-                    stms.push(cx.stmt_let(fmt_sp, true, ident,\n-                                          cx.expr_str_uniq(fmt_sp, @\"\")));\n-                }\n-                stms.push(cx.stmt_expr(make_new_conv(cx, fmt_sp, conv,\n-                                                     args[n], buf())));\n-            }\n-        }\n-    }\n-\n-    let expected_nargs = n + 1u; // n conversions + the fmt string\n-    if expected_nargs < nargs {\n-        cx.span_fatal\n-            (sp, format!(\"too many arguments to fmt!. found {}, expected {}\",\n-                           nargs, expected_nargs));\n-    }\n-\n-    cx.expr_block(cx.block(fmt_sp, stms, Some(buf())))\n+    base::MRExpr(ecx.expr_uint(sp, 2))\n }"}, {"sha": "7602656eabb074b28a90fd34168539266fb39d2d", "filename": "src/test/compile-fail/extfmt-missing-type.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:missing type\n-\n-fn main() { oldfmt!(\"%+\"); }"}, {"sha": "2721c780ac6cf3e2a3bfaa8dc39a2964dada0cbf", "filename": "src/test/compile-fail/extfmt-no-args.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:fmt! takes at least 1 argument\n-\n-fn main() { oldfmt!(); }"}, {"sha": "7aa744a11caac933b8cff947910e3eafc81bfcaa", "filename": "src/test/compile-fail/extfmt-non-literal.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: literal\n-\n-fn main() {\n-    // fmt!'s first argument must be a literal.  Hopefully this\n-    // restriction can be eased eventually to just require a\n-    // compile-time constant.\n-    let x = oldfmt!(\"a\" + \"b\");\n-}"}, {"sha": "e25eae821275f3a49cd4398a91218d66f4391890", "filename": "src/test/compile-fail/extfmt-non-literal2.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: literal\n-\n-fn main() {\n-    // fmt!'s first argument must be a literal.  Hopefully this\n-    // restriction can be eased eventually to just require a\n-    // compile-time constant.\n-    let x = oldfmt!(20);\n-}"}, {"sha": "5fd17fe92c14579067f63eaaabf67a017f4d05c5", "filename": "src/test/compile-fail/extfmt-not-enough-args.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:not enough arguments\n-\n-extern mod extra;\n-\n-fn main() { let s = oldfmt!(\"%s%s%s\", \"test\", \"test\"); }"}, {"sha": "5e12543ce8f0e600f65e99623ee8999ef11cf6dc", "filename": "src/test/compile-fail/extfmt-too-many-args.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:too many arguments\n-\n-extern mod extra;\n-\n-fn main() { let s = oldfmt!(\"%s\", \"test\", \"test\"); }"}, {"sha": "94ded1c528fdbfe507c154b1336dd14110d5fe09", "filename": "src/test/compile-fail/extfmt-unknown-type.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:unknown type\n-\n-fn main() { oldfmt!(\"%w\"); }"}, {"sha": "4e165153c0bdcad27dfda119540dde51e3938ada", "filename": "src/test/compile-fail/extfmt-unsigned-plus.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:only valid in signed fmt! conversion\n-\n-fn main() {\n-    // Can't use a sign on unsigned conversions\n-    oldfmt!(\"%+u\", 10u);\n-}"}, {"sha": "8396ecc25c16ec7ee341a8f3a4a73e4d09a7dce8", "filename": "src/test/compile-fail/extfmt-unsigned-space.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:only valid in signed fmt! conversion\n-\n-fn main() {\n-    // Can't use a space on unsigned conversions\n-    oldfmt!(\"% u\", 10u);\n-}"}, {"sha": "373a10e99cfd0560473beb9355d93b9fbf4daa72", "filename": "src/test/compile-fail/extfmt-unterminated-conv.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:unterminated conversion\n-\n-fn main() { oldfmt!(\"%\"); }"}, {"sha": "d7cf9f2cd2f78505a333376e249e4757d90a1588", "filename": "src/test/run-pass/pure-fmt.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Frun-pass%2Fpure-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Frun-pass%2Fpure-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpure-fmt.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Testing that calling fmt! (via info2!) doesn't complain about impure borrows\n-\n-struct Big { b: @~str, c: uint, d: int, e: char,\n-            f: f64, g: bool }\n-\n-fn foo() {\n-    let a = Big {\n-        b: @~\"hi\",\n-        c: 0,\n-        d: 1,\n-        e: 'a',\n-        f: 0.0,\n-        g: true\n-    };\n-    info2!(\"test {:?}\", a.b);\n-    info2!(\"test {:u}\", a.c);\n-    info2!(\"test {:i}\", a.d);\n-    info2!(\"test {:c}\", a.e);\n-    info2!(\"test {:f}\", a.f);\n-    info2!(\"test {:b}\", a.g);\n-}\n-\n-pub fn main() {\n-}"}, {"sha": "15a343044e13c2c8a42f448213dc9983efc27a48", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "removed", "additions": 0, "deletions": 282, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,282 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(macro_rules)];\n-\n-// compile-flags: --cfg nofmt\n-\n-extern mod extra;\n-\n-macro_rules! fmt(($($arg:tt)*) => (oldfmt!($($arg)*)))\n-\n-fn test(actual: ~str, expected: ~str) {\n-    info2!(\"{}\", actual.clone());\n-    info2!(\"{}\", expected.clone());\n-    assert_eq!(actual, expected);\n-}\n-\n-pub fn main() {\n-    test(fmt!(\"hello %d friends and %s things\", 10, \"formatted\"),\n-         ~\"hello 10 friends and formatted things\");\n-\n-    test(fmt!(\"test\"), ~\"test\");\n-\n-    // a quadratic optimization in LLVM (jump-threading) makes this test a\n-    // bit slow to compile unless we break it up\n-    part1();\n-    part2();\n-    part3();\n-    part4();\n-    part5();\n-    part6();\n-    percent();\n-    more_floats();\n-    pointer();\n-}\n-\n-fn part1() {\n-    // Simple tests for types\n-\n-    test(fmt!(\"%d\", 1), ~\"1\");\n-    test(fmt!(\"%i\", 2), ~\"2\");\n-    test(fmt!(\"%i\", -1), ~\"-1\");\n-    test(fmt!(\"%u\", 10u), ~\"10\");\n-    test(fmt!(\"%s\", \"test\"), ~\"test\");\n-    test(fmt!(\"%b\", true), ~\"true\");\n-    test(fmt!(\"%b\", false), ~\"false\");\n-    test(fmt!(\"%c\", 'A'), ~\"A\");\n-    test(fmt!(\"%x\", 0xff_u), ~\"ff\");\n-    test(fmt!(\"%X\", 0x12ab_u), ~\"12AB\");\n-    test(fmt!(\"%o\", 10u), ~\"12\");\n-    test(fmt!(\"%t\", 0b11010101_u), ~\"11010101\");\n-    test(fmt!(\"%f\", 5.82), ~\"5.82\");\n-    // 32-bit limits\n-\n-    test(fmt!(\"%i\", -2147483648), ~\"-2147483648\");\n-    test(fmt!(\"%i\", 2147483647), ~\"2147483647\");\n-    test(fmt!(\"%u\", 4294967295u), ~\"4294967295\");\n-    test(fmt!(\"%x\", 0xffffffff_u), ~\"ffffffff\");\n-    test(fmt!(\"%o\", 0xffffffff_u), ~\"37777777777\");\n-    test(fmt!(\"%t\", 0xffffffff_u), ~\"11111111111111111111111111111111\");\n-\n-    // Don't result in a compilation error\n-    test(fmt!(\"\"), ~\"\");\n-}\n-fn part2() {\n-    // Widths\n-\n-    test(fmt!(\"%1d\", 500), ~\"500\");\n-    test(fmt!(\"%10d\", 500), ~\"       500\");\n-    test(fmt!(\"%10d\", -500), ~\"      -500\");\n-    test(fmt!(\"%10u\", 500u), ~\"       500\");\n-    test(fmt!(\"%10s\", \"test\"), ~\"      test\");\n-    test(fmt!(\"%10b\", true), ~\"      true\");\n-    test(fmt!(\"%10x\", 0xff_u), ~\"        ff\");\n-    test(fmt!(\"%10X\", 0xff_u), ~\"        FF\");\n-    test(fmt!(\"%10o\", 10u), ~\"        12\");\n-    test(fmt!(\"%10t\", 0xff_u), ~\"  11111111\");\n-    test(fmt!(\"%10c\", 'A'), ~\"         A\");\n-    test(fmt!(\"%10f\", 5.82), ~\"      5.82\");\n-    // Left justify\n-\n-    test(fmt!(\"%-10d\", 500), ~\"500       \");\n-    test(fmt!(\"%-10d\", -500), ~\"-500      \");\n-    test(fmt!(\"%-10u\", 500u), ~\"500       \");\n-    test(fmt!(\"%-10s\", \"test\"), ~\"test      \");\n-    test(fmt!(\"%-10b\", true), ~\"true      \");\n-    test(fmt!(\"%-10x\", 0xff_u), ~\"ff        \");\n-    test(fmt!(\"%-10X\", 0xff_u), ~\"FF        \");\n-    test(fmt!(\"%-10o\", 10u), ~\"12        \");\n-    test(fmt!(\"%-10t\", 0xff_u), ~\"11111111  \");\n-    test(fmt!(\"%-10c\", 'A'), ~\"A         \");\n-    test(fmt!(\"%-10f\", 5.82), ~\"5.82      \");\n-}\n-\n-fn part3() {\n-    // Precision\n-\n-    test(fmt!(\"%.d\", 0), ~\"\");\n-    test(fmt!(\"%.u\", 0u), ~\"\");\n-    test(fmt!(\"%.x\", 0u), ~\"\");\n-    test(fmt!(\"%.t\", 0u), ~\"\");\n-    test(fmt!(\"%.d\", 10), ~\"10\");\n-    test(fmt!(\"%.d\", -10), ~\"-10\");\n-    test(fmt!(\"%.u\", 10u), ~\"10\");\n-    test(fmt!(\"%.s\", \"test\"), ~\"\");\n-    test(fmt!(\"%.x\", 127u), ~\"7f\");\n-    test(fmt!(\"%.o\", 10u), ~\"12\");\n-    test(fmt!(\"%.t\", 3u), ~\"11\");\n-    test(fmt!(\"%.c\", 'A'), ~\"A\");\n-    test(fmt!(\"%.f\", 5.82), ~\"6\");\n-    test(fmt!(\"%.0d\", 0), ~\"\");\n-    test(fmt!(\"%.0u\", 0u), ~\"\");\n-    test(fmt!(\"%.0x\", 0u), ~\"\");\n-    test(fmt!(\"%.0t\", 0u), ~\"\");\n-    test(fmt!(\"%.0d\", 10), ~\"10\");\n-    test(fmt!(\"%.0d\", -10), ~\"-10\");\n-    test(fmt!(\"%.0u\", 10u), ~\"10\");\n-    test(fmt!(\"%.0s\", \"test\"), ~\"\");\n-    test(fmt!(\"%.0x\", 127u), ~\"7f\");\n-    test(fmt!(\"%.0o\", 10u), ~\"12\");\n-    test(fmt!(\"%.0t\", 3u), ~\"11\");\n-    test(fmt!(\"%.0c\", 'A'), ~\"A\");\n-    test(fmt!(\"%.0f\", 5.892), ~\"6\");\n-    test(fmt!(\"%.1d\", 0), ~\"0\");\n-    test(fmt!(\"%.1u\", 0u), ~\"0\");\n-    test(fmt!(\"%.1x\", 0u), ~\"0\");\n-    test(fmt!(\"%.1t\", 0u), ~\"0\");\n-    test(fmt!(\"%.1d\", 10), ~\"10\");\n-    test(fmt!(\"%.1d\", -10), ~\"-10\");\n-    test(fmt!(\"%.1u\", 10u), ~\"10\");\n-    test(fmt!(\"%.1s\", \"test\"), ~\"t\");\n-    test(fmt!(\"%.1x\", 127u), ~\"7f\");\n-    test(fmt!(\"%.1o\", 10u), ~\"12\");\n-    test(fmt!(\"%.1t\", 3u), ~\"11\");\n-    test(fmt!(\"%.1c\", 'A'), ~\"A\");\n-    test(fmt!(\"%.1f\", 5.82), ~\"5.8\");\n-}\n-fn part4() {\n-    test(fmt!(\"%.5d\", 0), ~\"00000\");\n-    test(fmt!(\"%.5u\", 0u), ~\"00000\");\n-    test(fmt!(\"%.5x\", 0u), ~\"00000\");\n-    test(fmt!(\"%.5t\", 0u), ~\"00000\");\n-    test(fmt!(\"%.5d\", 10), ~\"00010\");\n-    test(fmt!(\"%.5d\", -10), ~\"-00010\");\n-    test(fmt!(\"%.5u\", 10u), ~\"00010\");\n-    test(fmt!(\"%.5s\", \"test\"), ~\"test\");\n-    test(fmt!(\"%.5x\", 127u), ~\"0007f\");\n-    test(fmt!(\"%.5o\", 10u), ~\"00012\");\n-    test(fmt!(\"%.5t\", 3u), ~\"00011\");\n-    test(fmt!(\"%.5c\", 'A'), ~\"A\");\n-    test(fmt!(\"%.5f\", 5.82), ~\"5.82000\");\n-    test(fmt!(\"%.5f\", 5.0), ~\"5.00000\");\n-    test(fmt!(\"%.100f\", 1.1), ~\"1.1000000000000000888178419700125232338905334472656250000000000000000000000000000000000000000000000000\");\n-\n-    // Bool precision. I'm not sure if it's good or bad to have bool\n-    // conversions support precision - it's not standard printf so we\n-    // can do whatever. For now I'm making it behave the same as string\n-    // conversions.\n-\n-    test(fmt!(\"%.b\", true), ~\"\");\n-    test(fmt!(\"%.0b\", true), ~\"\");\n-    test(fmt!(\"%.1b\", true), ~\"t\");\n-}\n-\n-fn part5() {\n-    // Explicit + sign. Only for signed conversions\n-\n-    test(fmt!(\"%+d\", 0), ~\"+0\");\n-    test(fmt!(\"%+d\", 1), ~\"+1\");\n-    test(fmt!(\"%+d\", -1), ~\"-1\");\n-    test(fmt!(\"%+f\", 0.0), ~\"+0\");\n-    // Leave space for sign\n-\n-    test(fmt!(\"% d\", 0), ~\" 0\");\n-    test(fmt!(\"% d\", 1), ~\" 1\");\n-    test(fmt!(\"% d\", -1), ~\"-1\");\n-    test(fmt!(\"% f\", 0.0), ~\" 0\");\n-    // Plus overrides space\n-\n-    test(fmt!(\"% +d\", 0), ~\"+0\");\n-    test(fmt!(\"%+ d\", 0), ~\"+0\");\n-    test(fmt!(\"% +f\", 0.0), ~\"+0\");\n-    test(fmt!(\"%+ f\", 0.0), ~\"+0\");\n-    // 0-padding\n-\n-    test(fmt!(\"%05d\", 0), ~\"00000\");\n-    test(fmt!(\"%05d\", 1), ~\"00001\");\n-    test(fmt!(\"%05d\", -1), ~\"-0001\");\n-    test(fmt!(\"%05u\", 1u), ~\"00001\");\n-    test(fmt!(\"%05x\", 127u), ~\"0007f\");\n-    test(fmt!(\"%05X\", 127u), ~\"0007F\");\n-    test(fmt!(\"%05o\", 10u), ~\"00012\");\n-    test(fmt!(\"%05t\", 3u), ~\"00011\");\n-    test(fmt!(\"%05f\", 5.82), ~\"05.82\");\n-    // 0-padding a string is undefined but glibc does this:\n-\n-    test(fmt!(\"%05s\", \"test\"), ~\" test\");\n-    test(fmt!(\"%05c\", 'A'), ~\"    A\");\n-    test(fmt!(\"%05b\", true), ~\" true\");\n-    // Left-justify overrides 0-padding\n-\n-    test(fmt!(\"%-05d\", 0), ~\"0    \");\n-    test(fmt!(\"%-05d\", 1), ~\"1    \");\n-    test(fmt!(\"%-05d\", -1), ~\"-1   \");\n-    test(fmt!(\"%-05u\", 1u), ~\"1    \");\n-    test(fmt!(\"%-05x\", 127u), ~\"7f   \");\n-    test(fmt!(\"%-05X\", 127u), ~\"7F   \");\n-    test(fmt!(\"%-05o\", 10u), ~\"12   \");\n-    test(fmt!(\"%-05t\", 3u), ~\"11   \");\n-    test(fmt!(\"%-05s\", \"test\"), ~\"test \");\n-    test(fmt!(\"%-05c\", 'A'), ~\"A    \");\n-    test(fmt!(\"%-05b\", true), ~\"true \");\n-    test(fmt!(\"%-05f\", 5.82), ~\"5.82 \");\n-}\n-fn part6() {\n-    // Precision overrides 0-padding\n-    // FIXME #2481: Recent gcc's report some of these as warnings\n-\n-    test(fmt!(\"%06.5d\", 0), ~\" 00000\");\n-    test(fmt!(\"%06.5u\", 0u), ~\" 00000\");\n-    test(fmt!(\"%06.5x\", 0u), ~\" 00000\");\n-    test(fmt!(\"%06.5d\", 10), ~\" 00010\");\n-    test(fmt!(\"%06.5d\", -10), ~\"-00010\");\n-    test(fmt!(\"%06.5u\", 10u), ~\" 00010\");\n-    test(fmt!(\"%06.5s\", \"test\"), ~\"  test\");\n-    test(fmt!(\"%06.5c\", 'A'), ~\"     A\");\n-    test(fmt!(\"%06.5x\", 127u), ~\" 0007f\");\n-    test(fmt!(\"%06.5X\", 127u), ~\" 0007F\");\n-    test(fmt!(\"%06.5o\", 10u), ~\" 00012\");\n-\n-    // Precision does not override zero-padding for floats\n-    test(fmt!(\"%08.5f\", 5.82), ~\"05.82000\");\n-\n-    // Signed combinations\n-\n-    test(fmt!(\"% 5d\", 1), ~\"    1\");\n-    test(fmt!(\"% 5d\", -1), ~\"   -1\");\n-    test(fmt!(\"%+5d\", 1), ~\"   +1\");\n-    test(fmt!(\"%+5d\", -1), ~\"   -1\");\n-    test(fmt!(\"% 05d\", 1), ~\" 0001\");\n-    test(fmt!(\"% 05d\", -1), ~\"-0001\");\n-    test(fmt!(\"%+05d\", 1), ~\"+0001\");\n-    test(fmt!(\"%+05d\", -1), ~\"-0001\");\n-    test(fmt!(\"%- 5d\", 1), ~\" 1   \");\n-    test(fmt!(\"%- 5d\", -1), ~\"-1   \");\n-    test(fmt!(\"%-+5d\", 1), ~\"+1   \");\n-    test(fmt!(\"%-+5d\", -1), ~\"-1   \");\n-    test(fmt!(\"%- 05d\", 1), ~\" 1   \");\n-    test(fmt!(\"%- 05d\", -1), ~\"-1   \");\n-    test(fmt!(\"%-+05d\", 1), ~\"+1   \");\n-    test(fmt!(\"%-+05d\", -1), ~\"-1   \");\n-}\n-\n-fn percent() {\n-    let s = fmt!(\"ab%%cd\");\n-    assert_eq!(s, ~\"ab%cd\");\n-}\n-\n-fn more_floats() {\n-    assert_eq!(~\"3.1416\", fmt!(\"%.4f\", 3.14159));\n-    assert_eq!(~\"3\", fmt!(\"%.0f\", 3.14159));\n-    assert_eq!(~\"99\", fmt!(\"%.0f\", 98.5));\n-    assert_eq!(~\"7.0000\", fmt!(\"%.4f\", 6.999999999));\n-    assert_eq!(~\"3.141590000\", fmt!(\"%.9f\", 3.14159));\n-}\n-\n-fn pointer() {\n-    do 10.times {\n-        let x: uint = ::std::rand::random();\n-        assert_eq!(fmt!(\"%p\", x as *uint), fmt!(\"0x%x\", x));\n-    }\n-\n-    let i = &1;\n-    assert_eq!(fmt!(\"%p\", i), fmt!(\"0x%x\", i as *uint as uint));\n-}"}]}