{"sha": "7b0f588b7706f4ec212e7772084eb7c0e90cfb56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMGY1ODhiNzcwNmY0ZWMyMTJlNzc3MjA4NGViN2MwZTkwY2ZiNTY=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-08T20:04:33Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:13:32Z"}, "message": "Refactor check_for_loop_over_map_kv to its own module", "tree": {"sha": "618bf5cb4e36d1909d291b50dbf565330bcfc87e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/618bf5cb4e36d1909d291b50dbf565330bcfc87e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b0f588b7706f4ec212e7772084eb7c0e90cfb56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b0f588b7706f4ec212e7772084eb7c0e90cfb56", "html_url": "https://github.com/rust-lang/rust/commit/7b0f588b7706f4ec212e7772084eb7c0e90cfb56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b0f588b7706f4ec212e7772084eb7c0e90cfb56/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "408368a82c2c394b65524cb995e01ecfc3c1867c", "url": "https://api.github.com/repos/rust-lang/rust/commits/408368a82c2c394b65524cb995e01ecfc3c1867c", "html_url": "https://github.com/rust-lang/rust/commit/408368a82c2c394b65524cb995e01ecfc3c1867c"}], "stats": {"total": 136, "additions": 71, "deletions": 65}, "files": [{"sha": "c5f0b0909ba648b37c50304c946dc471e883de78", "filename": "clippy_lints/src/loops/for_loop_over_map_kv.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7b0f588b7706f4ec212e7772084eb7c0e90cfb56/clippy_lints%2Fsrc%2Floops%2Ffor_loop_over_map_kv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0f588b7706f4ec212e7772084eb7c0e90cfb56/clippy_lints%2Fsrc%2Floops%2Ffor_loop_over_map_kv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_loop_over_map_kv.rs?ref=7b0f588b7706f4ec212e7772084eb7c0e90cfb56", "patch": "@@ -0,0 +1,69 @@\n+use crate::utils::visitors::LocalUsedVisitor;\n+use crate::utils::{is_type_diagnostic_item, match_type, multispan_sugg, paths, snippet, span_lint_and_then, sugg};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+/// Checks for the `FOR_KV_MAP` lint.\n+pub(super) fn check_for_loop_over_map_kv<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    let pat_span = pat.span;\n+\n+    if let PatKind::Tuple(ref pat, _) = pat.kind {\n+        if pat.len() == 2 {\n+            let arg_span = arg.span;\n+            let (new_pat_span, kind, ty, mutbl) = match *cx.typeck_results().expr_ty(arg).kind() {\n+                ty::Ref(_, ty, mutbl) => match (&pat[0].kind, &pat[1].kind) {\n+                    (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", ty, mutbl),\n+                    (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", ty, Mutability::Not),\n+                    _ => return,\n+                },\n+                _ => return,\n+            };\n+            let mutbl = match mutbl {\n+                Mutability::Not => \"\",\n+                Mutability::Mut => \"_mut\",\n+            };\n+            let arg = match arg.kind {\n+                ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) => &**expr,\n+                _ => arg,\n+            };\n+\n+            if is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) || match_type(cx, ty, &paths::BTREEMAP) {\n+                span_lint_and_then(\n+                    cx,\n+                    super::FOR_KV_MAP,\n+                    expr.span,\n+                    &format!(\"you seem to want to iterate on a map's {}s\", kind),\n+                    |diag| {\n+                        let map = sugg::Sugg::hir(cx, arg, \"map\");\n+                        multispan_sugg(\n+                            diag,\n+                            \"use the corresponding method\",\n+                            vec![\n+                                (pat_span, snippet(cx, new_pat_span, kind).into_owned()),\n+                                (arg_span, format!(\"{}.{}s{}()\", map.maybe_par(), kind, mutbl)),\n+                            ],\n+                        );\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns `true` if the pattern is a `PatWild` or an ident prefixed with `_`.\n+fn pat_is_wild<'tcx>(pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n+    match *pat {\n+        PatKind::Wild => true,\n+        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => {\n+            !LocalUsedVisitor::new(id).check_expr(body)\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "672f07318595f165f36ae2d85ef5f7f3fbd7293a", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 2, "deletions": 65, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7b0f588b7706f4ec212e7772084eb7c0e90cfb56/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0f588b7706f4ec212e7772084eb7c0e90cfb56/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=7b0f588b7706f4ec212e7772084eb7c0e90cfb56", "patch": "@@ -1,4 +1,5 @@\n mod for_loop_arg;\n+mod for_loop_over_map_kv;\n mod manual_flatten;\n mod utils;\n \n@@ -863,7 +864,7 @@ fn check_for_loop<'tcx>(\n         check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n     }\n     for_loop_arg::check_for_loop_arg(cx, pat, arg, expr);\n-    check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n+    for_loop_over_map_kv::check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n     check_for_mut_range_bound(cx, arg, body);\n     check_for_single_element_loop(cx, pat, arg, body, expr);\n     detect_same_item_push(cx, pat, arg, body, expr);\n@@ -1732,59 +1733,6 @@ fn check_for_loop_explicit_counter<'tcx>(\n     }\n }\n \n-/// Checks for the `FOR_KV_MAP` lint.\n-fn check_for_loop_over_map_kv<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &'tcx Pat<'_>,\n-    arg: &'tcx Expr<'_>,\n-    body: &'tcx Expr<'_>,\n-    expr: &'tcx Expr<'_>,\n-) {\n-    let pat_span = pat.span;\n-\n-    if let PatKind::Tuple(ref pat, _) = pat.kind {\n-        if pat.len() == 2 {\n-            let arg_span = arg.span;\n-            let (new_pat_span, kind, ty, mutbl) = match *cx.typeck_results().expr_ty(arg).kind() {\n-                ty::Ref(_, ty, mutbl) => match (&pat[0].kind, &pat[1].kind) {\n-                    (key, _) if pat_is_wild(cx, key, body) => (pat[1].span, \"value\", ty, mutbl),\n-                    (_, value) if pat_is_wild(cx, value, body) => (pat[0].span, \"key\", ty, Mutability::Not),\n-                    _ => return,\n-                },\n-                _ => return,\n-            };\n-            let mutbl = match mutbl {\n-                Mutability::Not => \"\",\n-                Mutability::Mut => \"_mut\",\n-            };\n-            let arg = match arg.kind {\n-                ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) => &**expr,\n-                _ => arg,\n-            };\n-\n-            if is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) || match_type(cx, ty, &paths::BTREEMAP) {\n-                span_lint_and_then(\n-                    cx,\n-                    FOR_KV_MAP,\n-                    expr.span,\n-                    &format!(\"you seem to want to iterate on a map's {}s\", kind),\n-                    |diag| {\n-                        let map = sugg::Sugg::hir(cx, arg, \"map\");\n-                        multispan_sugg(\n-                            diag,\n-                            \"use the corresponding method\",\n-                            vec![\n-                                (pat_span, snippet(cx, new_pat_span, kind).into_owned()),\n-                                (arg_span, format!(\"{}.{}s{}()\", map.maybe_par(), kind, mutbl)),\n-                            ],\n-                        );\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}\n-\n fn check_for_single_element_loop<'tcx>(\n     cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n@@ -1927,17 +1875,6 @@ fn check_for_mutation<'tcx>(\n     delegate.mutation_span()\n }\n \n-/// Returns `true` if the pattern is a `PatWild` or an ident prefixed with `_`.\n-fn pat_is_wild<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n-    match *pat {\n-        PatKind::Wild => true,\n-        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => {\n-            !LocalUsedVisitor::new(cx, id).check_expr(body)\n-        },\n-        _ => false,\n-    }\n-}\n-\n struct VarVisitor<'a, 'tcx> {\n     /// context reference\n     cx: &'a LateContext<'tcx>,"}]}