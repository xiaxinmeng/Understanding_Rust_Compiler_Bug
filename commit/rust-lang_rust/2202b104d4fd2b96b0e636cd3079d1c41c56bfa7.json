{"sha": "2202b104d4fd2b96b0e636cd3079d1c41c56bfa7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMDJiMTA0ZDRmZDJiOTZiMGU2MzZjZDMwNzlkMWM0MWM1NmJmYTc=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-06-02T08:26:02Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-06-04T17:04:38Z"}, "message": "collections: optimize `HashMap`. Add `DefaultResizePolicy`.\n\nRefactored the load factor and the minimum capacity out of HashMap.\nThe size of HashMap<K, V> is now 64 bytes by default on a 64-bit platform\n(or 48 bytes, that is 2 words less, with FNV)\nAdded a documentation in a few places to clarify the behavior.", "tree": {"sha": "1950c2b57527f5fd1aaa028ce1b022b265fd282e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1950c2b57527f5fd1aaa028ce1b022b265fd282e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2202b104d4fd2b96b0e636cd3079d1c41c56bfa7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2202b104d4fd2b96b0e636cd3079d1c41c56bfa7", "html_url": "https://github.com/rust-lang/rust/commit/2202b104d4fd2b96b0e636cd3079d1c41c56bfa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2202b104d4fd2b96b0e636cd3079d1c41c56bfa7/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6401b52263336c22879d4ffae3eded97949ee7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6401b52263336c22879d4ffae3eded97949ee7b", "html_url": "https://github.com/rust-lang/rust/commit/a6401b52263336c22879d4ffae3eded97949ee7b"}], "stats": {"total": 189, "additions": 117, "deletions": 72}, "files": [{"sha": "dfcb85a3e39b22224e26f7cfc1a2f6dfc99e8022", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 117, "deletions": 72, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/2202b104d4fd2b96b0e636cd3079d1c41c56bfa7/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2202b104d4fd2b96b0e636cd3079d1c41c56bfa7/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=2202b104d4fd2b96b0e636cd3079d1c41c56bfa7", "patch": "@@ -101,6 +101,7 @@ mod table {\n     /// There's currently no \"debug-only\" asserts in rust, so if you're reading\n     /// this and going \"what? of course there are debug-only asserts!\", then\n     /// please make this use them!\n+    #[unsafe_no_drop_flag]\n     pub struct RawTable<K, V> {\n         capacity: uint,\n         size:     uint,\n@@ -549,38 +550,59 @@ mod table {\n \n             assert_eq!(self.size, 0);\n \n-            let hashes_size = self.capacity * size_of::<u64>();\n-            let keys_size = self.capacity * size_of::<K>();\n-            let vals_size = self.capacity * size_of::<V>();\n-            let (align, _, _, _, size) = calculate_offsets(hashes_size, min_align_of::<u64>(),\n-                                                           keys_size, min_align_of::<K>(),\n-                                                           vals_size, min_align_of::<V>());\n+            if self.hashes.is_not_null() {\n+                let hashes_size = self.capacity * size_of::<u64>();\n+                let keys_size = self.capacity * size_of::<K>();\n+                let vals_size = self.capacity * size_of::<V>();\n+                let (align, _, _, _, size) = calculate_offsets(hashes_size, min_align_of::<u64>(),\n+                                                               keys_size, min_align_of::<K>(),\n+                                                               vals_size, min_align_of::<V>());\n+\n+                unsafe {\n+                    deallocate(self.hashes as *mut u8, size, align);\n+                    // Remember how everything was allocated out of one buffer\n+                    // during initialization? We only need one call to free here.\n+                }\n \n-            unsafe {\n-                deallocate(self.hashes as *mut u8, size, align);\n-                // Remember how everything was allocated out of one buffer\n-                // during initialization? We only need one call to free here.\n+                self.hashes = RawPtr::null();\n             }\n         }\n     }\n }\n \n-// We use this type for the load factor, to avoid floating point operations\n-// which might not be supported efficiently on some hardware.\n-//\n-// We use small u16s here to save space in the hashtable. They get upcasted\n-// to u64s when we actually use them.\n-type Fraction = (u16, u16); // (numerator, denominator)\n-\n-// multiplication by a fraction, in a way that won't generally overflow for\n-// array sizes outside a factor of 10 of U64_MAX.\n-fn fraction_mul(lhs: uint, (num, den): Fraction) -> uint {\n-    (((lhs as u64) * (num as u64)) / (den as u64)) as uint\n-}\n-\n static INITIAL_LOG2_CAP: uint = 5;\n static INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n-static INITIAL_LOAD_FACTOR: Fraction = (9, 10);\n+\n+/// The default behavior of HashMap implements a load factor of 90.9%.\n+/// This behavior is characterized by the following conditions:\n+///\n+/// - if `size * 1.1 < cap < size * 4` then shouldn't resize\n+/// - if `cap < minimum_capacity * 2` then shouldn't shrink\n+#[deriving(Clone)]\n+struct DefaultResizePolicy {\n+    /// Doubled minimal capacity. The capacity must never drop below\n+    /// the minimum capacity. (The check happens before the capacity\n+    /// is potentially halved.)\n+    minimum_capacity2: uint\n+}\n+\n+impl DefaultResizePolicy {\n+    fn new(new_capacity: uint) -> DefaultResizePolicy {\n+        DefaultResizePolicy {\n+            minimum_capacity2: new_capacity << 1\n+        }\n+    }\n+\n+    #[inline]\n+    fn capacity_range(&self, new_size: uint) -> (uint, uint) {\n+        ((new_size * 11) / 10, max(new_size << 3, self.minimum_capacity2))\n+    }\n+\n+    #[inline]\n+    fn reserve(&mut self, new_capacity: uint) {\n+        self.minimum_capacity2 = new_capacity << 1;\n+    }\n+}\n \n // The main performance trick in this hashmap is called Robin Hood Hashing.\n // It gains its excellent performance from one key invariant:\n@@ -593,13 +615,13 @@ static INITIAL_LOAD_FACTOR: Fraction = (9, 10);\n // high load factors with good performance. The 90% load factor I use is rather\n // conservative.\n //\n-// > Why a load factor of 90%?\n+// > Why a load factor of approximately 90%?\n //\n // In general, all the distances to initial buckets will converge on the mean.\n // At a load factor of \u03b1, the odds of finding the target bucket after k\n // probes is approximately 1-\u03b1^k. If we set this equal to 50% (since we converge\n // on the mean) and set k=8 (64-byte cache line / 8-byte hash), \u03b1=0.92. I round\n-// this down to 0.90 to make the math easier on the CPU and avoid its FPU.\n+// this down to make the math easier on the CPU and avoid its FPU.\n // Since on average we start the probing in the middle of a cache line, this\n // strategy pulls in two cache lines of hashes on every lookup. I think that's\n // pretty good, but if you want to trade off some space, it could go down to one\n@@ -616,8 +638,6 @@ static INITIAL_LOAD_FACTOR: Fraction = (9, 10);\n // ============================\n //\n // Allow the load factor to be changed dynamically and/or at initialization.\n-// I'm having trouble figuring out a sane API for this without exporting my\n-// hackish fraction type, while still avoiding floating point.\n //\n // Also, would it be possible for us to reuse storage when growing the\n // underlying table? This is exactly the use case for 'realloc', and may\n@@ -715,31 +735,13 @@ pub struct HashMap<K, V, H = sip::SipHasher> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n     hasher: H,\n \n-    // When size == grow_at, we double the capacity.\n-    grow_at: uint,\n-\n-    // The capacity must never drop below this.\n-    minimum_capacity: uint,\n-\n     table: table::RawTable<K, V>,\n \n-    // We keep this at the end since it's 4-bytes, unlike everything else\n-    // in this struct. Might as well save a word of padding!\n-    load_factor: Fraction,\n-}\n-\n-/// Get the number of elements which will force the capacity to grow.\n-fn grow_at(capacity: uint, load_factor: Fraction) -> uint {\n-    fraction_mul(capacity, load_factor)\n+    // We keep this at the end since it might as well have tail padding.\n+    resize_policy: DefaultResizePolicy,\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n-    /// Get the number of elements which will force the capacity to shrink.\n-    /// When size == self.shrink_at(), we halve the capacity.\n-    fn shrink_at(&self) -> uint {\n-        self.table.capacity() >> 2\n-    }\n-\n     // Probe the `idx`th bucket for a given hash, returning the index of the\n     // target bucket.\n     //\n@@ -931,9 +933,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Container for HashMap<K, V, H> {\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n-    /// Clear the map, removing all key-value pairs.\n+    /// Clear the map, removing all key-value pairs. Keeps the allocated memory\n+    /// for reuse.\n     fn clear(&mut self) {\n-        self.minimum_capacity = self.table.size();\n+        // Prevent reallocations from happening from now on. Makes it possible\n+        // for the map to be reused but has a downside: reserves permanently.\n+        self.resize_policy.reserve(self.table.size());\n \n         for i in range(0, self.table.capacity()) {\n             match self.table.peek(i) {\n@@ -944,7 +949,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n     }\n }\n \n-\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n     fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n         self.search(k).map(|idx| {\n@@ -1057,11 +1061,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> {\n         let cap = num::next_power_of_two(max(INITIAL_CAPACITY, capacity));\n         HashMap {\n-            hasher:           hasher,\n-            load_factor:      INITIAL_LOAD_FACTOR,\n-            grow_at:          grow_at(cap, INITIAL_LOAD_FACTOR),\n-            minimum_capacity: cap,\n-            table:            table::RawTable::new(cap),\n+            hasher:        hasher,\n+            resize_policy: DefaultResizePolicy::new(cap),\n+            table:         table::RawTable::new(cap),\n         }\n     }\n \n@@ -1075,7 +1077,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         let cap = num::next_power_of_two(\n             max(INITIAL_CAPACITY, new_minimum_capacity));\n \n-        self.minimum_capacity = cap;\n+        self.resize_policy.reserve(cap);\n \n         if self.table.capacity() < cap {\n             self.resize(cap);\n@@ -1090,8 +1092,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         assert!(self.table.size() <= new_capacity);\n         assert!(num::is_power_of_two(new_capacity));\n \n-        self.grow_at = grow_at(new_capacity, self.load_factor);\n-\n         let old_table = replace(&mut self.table, table::RawTable::new(new_capacity));\n         let old_size  = old_table.size();\n \n@@ -1105,19 +1105,18 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Performs any necessary resize operations, such that there's space for\n     /// new_size elements.\n     fn make_some_room(&mut self, new_size: uint) {\n-        let should_shrink = new_size <= self.shrink_at();\n-        let should_grow   = self.grow_at <= new_size;\n+        let (grow_at, shrink_at) = self.resize_policy.capacity_range(new_size);\n+        let cap = self.table.capacity();\n \n-        if should_grow {\n-            let new_capacity = self.table.capacity() << 1;\n-            self.resize(new_capacity);\n-        } else if should_shrink {\n-            let new_capacity = self.table.capacity() >> 1;\n+        // An invalid value shouldn't make us run out of space.\n+        debug_assert!(grow_at >= new_size);\n \n-            // Never shrink below the minimum capacity\n-            if self.minimum_capacity <= new_capacity {\n-                self.resize(new_capacity);\n-            }\n+        if cap <= grow_at {\n+            let new_capacity = cap << 1;\n+            self.resize(new_capacity);\n+        } else if shrink_at <= cap {\n+            let new_capacity = cap >> 1;\n+            self.resize(new_capacity);\n         }\n     }\n \n@@ -2025,8 +2024,8 @@ mod test_map {\n         assert!(m.is_empty());\n \n         let mut i = 0u;\n-        let old_resize_at = m.grow_at;\n-        while old_resize_at == m.grow_at {\n+        let old_cap = m.table.capacity();\n+        while old_cap == m.table.capacity() {\n             m.insert(i, i);\n             i += 1;\n         }\n@@ -2035,6 +2034,52 @@ mod test_map {\n         assert!(!m.is_empty());\n     }\n \n+    #[test]\n+    fn test_resize_policy() {\n+        let mut m = HashMap::new();\n+\n+        assert_eq!(m.len(), 0);\n+        assert!(m.is_empty());\n+\n+        let initial_cap = m.table.capacity();\n+        m.reserve(initial_cap * 2);\n+        let cap = m.table.capacity();\n+\n+        assert_eq!(cap, initial_cap * 2);\n+\n+        let mut i = 0u;\n+        for _ in range(0, cap * 3 / 4) {\n+            m.insert(i, i);\n+            i += 1;\n+        }\n+\n+        assert_eq!(m.len(), i);\n+        assert_eq!(m.table.capacity(), cap);\n+\n+        for _ in range(0, cap / 4) {\n+            m.insert(i, i);\n+            i += 1;\n+        }\n+\n+        let new_cap = m.table.capacity();\n+        assert_eq!(new_cap, cap * 2);\n+\n+        for _ in range(0, cap / 2) {\n+            i -= 1;\n+            m.remove(&i);\n+            assert_eq!(m.table.capacity(), new_cap);\n+        }\n+\n+        for _ in range(0, cap / 2 - 1) {\n+            i -= 1;\n+            m.remove(&i);\n+        }\n+\n+        assert_eq!(m.table.capacity(), cap);\n+        assert_eq!(m.len(), i);\n+        assert!(!m.is_empty());\n+    }\n+\n     #[test]\n     fn test_find_equiv() {\n         let mut m = HashMap::new();"}]}