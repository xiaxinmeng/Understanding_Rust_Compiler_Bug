{"sha": "ab2a397ae7db45bc5cafe7cfc6f77a095b248ff1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMmEzOTdhZTdkYjQ1YmM1Y2FmZTdjZmM2Zjc3YTA5NWIyNDhmZjE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-03-22T21:44:31Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-03-22T21:45:16Z"}, "message": "docs: Copyedit my randomly assigned sections of the manual", "tree": {"sha": "9cd1b5a6b6bf22cf44403fa3f9740cf72f5e2b37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cd1b5a6b6bf22cf44403fa3f9740cf72f5e2b37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab2a397ae7db45bc5cafe7cfc6f77a095b248ff1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab2a397ae7db45bc5cafe7cfc6f77a095b248ff1", "html_url": "https://github.com/rust-lang/rust/commit/ab2a397ae7db45bc5cafe7cfc6f77a095b248ff1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab2a397ae7db45bc5cafe7cfc6f77a095b248ff1/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9b077c0e94f101a3121a7d615f46366ea4080bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9b077c0e94f101a3121a7d615f46366ea4080bf", "html_url": "https://github.com/rust-lang/rust/commit/e9b077c0e94f101a3121a7d615f46366ea4080bf"}], "stats": {"total": 275, "additions": 143, "deletions": 132}, "files": [{"sha": "3d240086812e2d27db11c5b0e8e74994ffc3661c", "filename": "doc/rust.md", "status": "modified", "additions": 143, "deletions": 132, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/ab2a397ae7db45bc5cafe7cfc6f77a095b248ff1/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/ab2a397ae7db45bc5cafe7cfc6f77a095b248ff1/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=ab2a397ae7db45bc5cafe7cfc6f77a095b248ff1", "patch": "@@ -91,11 +91,10 @@ This EBNF dialect should hopefully be familiar to many readers.\n \n ## Unicode productions\n \n-A small number of productions in Rust's grammar permit Unicode codepoints\n-outside the ASCII range; these productions are defined in terms of character\n-properties given by the Unicode standard, rather than ASCII-range\n-codepoints. These are given in the section [Special Unicode\n-Productions](#special-unicode-productions).\n+A few productions in Rust's grammar permit Unicode codepoints outside the ASCII range.\n+We define these productions in terms of character properties specified in the Unicode standard,\n+rather than in terms of ASCII-range codepoints.\n+The section [Special Unicode Productions](#special-unicode-productions) lists these productions.\n \n ## String table productions\n \n@@ -222,8 +221,8 @@ unsafe use\n while\n ~~~~~~~~\n \n-Any of these have special meaning in their respective grammars, and are\n-excluded from the `ident` rule.\n+Each of these keywords has special meaning in its grammar,\n+and all of them are excluded from the `ident` rule.\n \n ### Literals\n \n@@ -486,16 +485,18 @@ transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n \n ~~~~~~~~\n \n-User-defined syntax extensions are called \"macros\", and they can be defined\n-with the `macro_rules!` syntax extension. User-defined macros can currently\n-be invoked as expressions, statements, or items.\n+User-defined syntax extensions are called \"macros\",\n+and the `macro_rules` syntax extension defines them.\n+Currently, user-defined macros can expand to expressions, statements, or items.\n \n-(A `sep_token` is any token other than `*` and `+`. A `non_special_token` is\n-any token other than a delimiter or `$`.)\n+(A `sep_token` is any token other than `*` and `+`.\n+A `non_special_token` is any token other than a delimiter or `$`.)\n \n-Macro invocations are looked up by name, and each macro rule is tried in turn;\n-the first successful match is transcribed. The matching and transcription\n-processes are closely related, and will be described together:\n+The macro expander looks up macro invocations by name,\n+and tries each macro rule in turn.\n+It transcribes the first successful match.\n+Matching and transcription are closely related to each other,\n+and we will describe them together.\n \n ### Macro By Example\n \n@@ -548,12 +549,10 @@ This requirement most often affects name-designator pairs when they occur at the\n ## Syntax extensions useful for the macro author\n \n * `log_syntax!` : print out the arguments at compile time\n-* `trace_macros!` : supply `true` or `false` to enable or disable printing of the macro expansion process.\n+* `trace_macros!` : supply `true` or `false` to enable or disable macro expansion logging\n * `stringify!` : turn the identifier argument into a string literal\n * `concat_idents!` : create a new identifier by concatenating the arguments\n \n-\n-\n # Crates and source files\n \n Rust is a *compiled* language.\n@@ -785,22 +784,19 @@ path_glob : ident [ \"::\" path_glob ] ?\n ~~~~~~~~\n \n A _use declaration_ creates one or more local name bindings synonymous\n-with some other [path](#paths). Usually a `use` declaration is used to\n-shorten the path required to refer to a module item.\n+with some other [path](#paths).\n+Usually a `use` declaration is used to shorten the path required to refer to a module item.\n \n-*Note*: unlike many languages, Rust's `use` declarations do *not* declare\n-linkage-dependency with external crates. Linkage dependencies are\n-independently declared with\n-[`extern mod` declarations](#extern-mod-declarations).\n+*Note*: Unlike in many languages,\n+`use` declarations in Rust do *not* declare linkage dependency with external crates.\n+Rather, [`extern mod` declarations](#extern-mod-declarations) declare linkage dependencies.\n \n-Use declarations support a number of \"convenience\" notations:\n+Use declarations support a number of convenient shortcuts:\n \n-  * Rebinding the target name as a new local name, using the\n-    syntax `use x = p::q::r;`.\n-  * Simultaneously binding a list of paths differing only in final element,\n+  * Rebinding the target name as a new local name, using the syntax `use x = p::q::r;`.\n+  * Simultaneously binding a list of paths differing only in their final element,\n     using the glob-like brace syntax `use a::b::{c,d,e,f};`\n-  * Binding all paths matching a given prefix,\n-    using the glob-like asterisk syntax `use a::b::*;`\n+  * Binding all paths matching a given prefix, using the asterisk wildcard syntax `use a::b::*;`\n \n An example of `use` declarations:\n \n@@ -825,9 +821,10 @@ fn main() {\n Like items, `use` declarations are private to the containing module, by default.\n Also like items, a `use` declaration can be public, if qualified by the `pub` keyword.\n Such a `use` declaration serves to _re-export_ a name.\n-A public `use` declaration can therefore be used to _redirect_ some public name to a different target definition,\n+A public `use` declaration can therefore _redirect_ some public name to a different target definition:\n even a definition with a private canonical path, inside a different module.\n-If a sequence of such redirections form a cycle or cannot be unambiguously resolved, they represent a compile-time error.\n+If a sequence of such redirections form a cycle or cannot be resolved unambiguously,\n+they represent a compile-time error.\n \n An example of re-exporting:\n ~~~~\n@@ -844,8 +841,8 @@ mod quux {\n \n In this example, the module `quux` re-exports all of the public names defined in `foo`.\n \n-Also note that the paths contained in `use` items are relative to the crate root; so, in the previous\n-example, the use refers to `quux::foo::*`, and not simply to `foo::*`.\n+Also note that the paths contained in `use` items are relative to the crate root.\n+So, in the previous example, the `use` refers to `quux::foo::*`, and not simply to `foo::*`.\n \n ### Functions\n \n@@ -994,27 +991,27 @@ Thus the return type on `f` only needs to reflect the `if` branch of the conditi\n \n #### Extern functions\n \n-Extern functions are part of Rust's foreign function interface, providing\n-the opposite functionality to [foreign modules](#foreign-modules). Whereas\n-foreign modules allow Rust code to call foreign code, extern functions with\n-bodies defined in Rust code _can be called by foreign code_. They are defined the\n-same as any other Rust function, except that they are prepended with the\n-`extern` keyword.\n+Extern functions are part of Rust's foreign function interface,\n+providing the opposite functionality to [foreign modules](#foreign-modules).\n+Whereas foreign modules allow Rust code to call foreign code,\n+extern functions with bodies defined in Rust code _can be called by foreign code_.\n+They are defined in the same way as any other Rust function,\n+except that they have the `extern` modifier.\n \n ~~~\n extern fn new_vec() -> ~[int] { ~[] }\n ~~~\n \n-Extern functions may not be called from Rust code, but their value\n-may be taken as a raw `u8` pointer.\n+Extern functions may not be called from Rust code,\n+but Rust code may take their value as a raw `u8` pointer.\n \n ~~~\n # extern fn new_vec() -> ~[int] { ~[] }\n let fptr: *u8 = new_vec;\n ~~~\n \n-The primary motivation of extern functions is to create callbacks\n-for foreign functions that expect to receive function pointers.\n+The primary motivation for extern functions is\n+to create callbacks for foreign functions that expect to receive function pointers.\n \n ### Type definitions\n \n@@ -1052,7 +1049,7 @@ let p = Point(10, 11);\n let px: int = match p { Point(x, _) => x };\n ~~~~\n \n-A _unit-like struct_ is a structure without any fields, defined by leaving off the fields list entirely.\n+A _unit-like struct_ is a structure without any fields, defined by leaving off the list of fields entirely.\n Such types will have a single value, just like the [unit value `()`](#unit-and-boolean-literals) of the unit type.\n For example:\n \n@@ -1484,23 +1481,25 @@ Any slots introduced by a slot declaration are visible from the point of declara\n ### Expression statements\n \n An _expression statement_ is one that evaluates an [expression](#expressions)\n-and drops its result. The purpose of an expression statement is often to cause\n-the side effects of the expression's evaluation.\n+and ignores its result.\n+The type of an expression statement `e;` is always `()`, regardless of the type of `e`.\n+As a rule, an expression statement's purpose is to trigger the effects of evaluating its expression.\n \n ## Expressions\n \n-An expression plays the dual roles of causing side effects and producing a\n-*value*. Expressions are said to *evaluate to* a value, and the side effects\n-are caused during *evaluation*. Many expressions contain sub-expressions as\n-operands; the definition of each kind of expression dictates whether or not,\n-and in which order, it will evaluate its sub-expressions, and how the\n-expression's value derives from the value of its sub-expressions.\n+An expression may have two roles: it always produces a *value*, and it may have *effects*\n+(otherwise known as \"side effects\").\n+An expression *evaluates to* a value, and has effects during *evaluation*.\n+Many expressions contain sub-expressions (operands).\n+The meaning of each kind of expression dictates several things:\n+  * Whether or not to evaluate the sub-expressions when evaluating the expression\n+  * The order in which to evaluate the sub-expressions\n+  * How to combine the sub-expressions' values to obtain the value of the expression.\n \n-In this way, the structure of execution -- both the overall sequence of\n-observable side effects and the final produced value -- is dictated by the\n-structure of expressions. Blocks themselves are expressions, so the nesting\n-sequence of block, statement, expression, and block can repeatedly nest to an\n-arbitrary depth.\n+In this way, the structure of expressions dictates the structure of execution.\n+Blocks are just another kind of expression,\n+so blocks, statements, expressions, and blocks again can recursively nest inside each other\n+to an arbitrary depth.\n \n #### Lvalues, rvalues and temporaries\n \n@@ -1579,11 +1578,11 @@ A _structure expression_ consists of the [path](#paths) of a [structure item](#s\n followed by a brace-enclosed list of one or more comma-separated name-value pairs,\n providing the field values of a new instance of the structure.\n A field name can be any identifier, and is separated from its value expression by a colon.\n-To indicate that a field is mutable, the `mut` keyword is written before its name.\n+The location denoted by a structure field is mutable if and only if the enclosing structure is mutable.\n \n A _tuple structure expression_ consists of the [path](#paths) of a [structure item](#structures),\n followed by a parenthesized list of one or more comma-separated expressions\n-(in other words, the path of a structured item followed by a tuple expression).\n+(in other words, the path of a structure item followed by a tuple expression).\n The structure item must be a tuple structure item.\n \n A _unit-like structure expression_ consists only of the [path](#paths) of a [structure item](#structures).\n@@ -1597,16 +1596,18 @@ The following are examples of structure expressions:\n # struct Cookie; fn some_fn<T>(t: T) {}\n Point {x: 10f, y: 20f};\n TuplePoint(10f, 20f);\n-let u = game::User {name: \"Joe\", age: 35u, score: 100_000};\n+let u = game::User {name: \"Joe\", age: 35, score: 100_000};\n some_fn::<Cookie>(Cookie);\n ~~~~\n \n A structure expression forms a new value of the named structure type.\n Note that for a given *unit-like* structure type, this will always be the same value.\n \n A structure expression can terminate with the syntax `..` followed by an expression to denote a functional update.\n-The expression following `..` (the base) must be of the same structure type as the new structure type being formed.\n-A new structure will be created, of the same type as the base expression, with the given values for the fields that were explicitly specified,\n+The expression following `..` (the base) must have the same structure type as the new structure type being formed.\n+The entire expression denotes the result of allocating a new structure\n+(with the same type as the base expression)\n+with the given values for the fields that were explicitly specified\n and the values in the base record for all other fields.\n \n ~~~~\n@@ -1758,36 +1759,35 @@ The default meaning of the operators on standard types is given here.\n \n #### Bitwise operators\n \n-Bitwise operators are, like the [arithmetic operators](#arithmetic-operators),\n-syntactic sugar for calls to built-in traits.\n+Like the [arithmetic operators](#arithmetic-operators), bitwise operators\n+are syntactic sugar for calls to methods of built-in traits.\n This means that bitwise operators can be overridden for user-defined types.\n The default meaning of the operators on standard types is given here.\n \n `&`\n   : And.\n-    Calls the `bitand` method on the `core::ops::BitAnd` trait.\n+    Calls the `bitand` method of the `core::ops::BitAnd` trait.\n `|`\n   : Inclusive or.\n-    Calls the `bitor` method on the `core::ops::BitOr` trait.\n+    Calls the `bitor` method of the `core::ops::BitOr` trait.\n `^`\n   : Exclusive or.\n-    Calls the `bitxor` method on the `core::ops::BitXor` trait.\n+    Calls the `bitxor` method of the `core::ops::BitXor` trait.\n `<<`\n   : Logical left shift.\n-    Calls the `shl` method on the `core::ops::Shl` trait.\n+    Calls the `shl` method of the `core::ops::Shl` trait.\n `>>`\n   : Logical right shift.\n-    Calls the `shr` method on the `core::ops::Shr` trait.\n+    Calls the `shr` method of the `core::ops::Shr` trait.\n \n #### Lazy boolean operators\n \n-The operators `||` and `&&` may be applied to operands of boolean\n-type. The first performs the 'or' operation, and the second the 'and'\n-operation. They differ from `|` and `&` in that the right-hand operand\n-is only evaluated when the left-hand operand does not already\n-determine the outcome of the expression. That is, `||` only evaluates\n-its right-hand operand when the left-hand operand evaluates to `false`,\n-and `&&` only when it evaluates to `true`.\n+The operators `||` and `&&` may be applied to operands of boolean type.\n+The `||` operator denotes logical 'or', and the `&&` operator denotes logical 'and'.\n+They differ from `|` and `&` in that the right-hand operand is only evaluated\n+when the left-hand operand does not already determine the result of the expression.\n+That is, `||` only evaluates its right-hand operand\n+when the left-hand operand evaluates to `false`, and `&&` only when it evaluates to `true`.\n \n #### Comparison operators\n \n@@ -1937,6 +1937,9 @@ let x = (2 + 3) * 4;\n copy_expr : \"copy\" expr ;\n ~~~~~~~~\n \n+> **Note:** `copy` expressions are deprecated. It's preferable to use\n+> the `Clone` trait and `clone()` method.\n+\n A _unary copy expression_ consists of the unary `copy` operator applied to\n some argument expression.\n \n@@ -2013,27 +2016,29 @@ ident_list : [ ident [ ',' ident ]* ] ? ;\n lambda_expr : '|' ident_list '|' expr ;\n ~~~~~~~~\n \n-A _lambda expression_ (a.k.a. \"anonymous function expression\") defines a function and denotes it as a value,\n+A _lambda expression_ (sometimes called an \"anonymous function expression\") defines a function and denotes it as a value,\n in a single expression.\n-Lambda expressions are written by prepending a list of identifiers, surrounded by pipe symbols (`|`),\n-to an expression.\n+A lambda expression is a pipe-symbol-delimited (`|`) list of identifiers followed by an expression.\n \n-A lambda expression denotes a function mapping parameters to the expression to the right of the `ident_list`.\n-The identifiers in the `ident_list` are the parameters to the function, with types inferred from context.\n+A lambda expression denotes a function that maps a list of parameters (`ident_list`)\n+onto the expression that follows the `ident_list`.\n+The identifiers in the `ident_list` are the parameters to the function.\n+These parameters' types need not be specified, as the compiler infers them from context.\n \n Lambda expressions are most useful when passing functions as arguments to other functions,\n-as an abbreviation for defining and capturing a separate fucntion.\n+as an abbreviation for defining and capturing a separate function.\n \n Significantly, lambda expressions _capture their environment_,\n which regular [function definitions](#functions) do not.\n+The exact type of capture depends on the [function type](#function-types) inferred for the lambda expression.\n+In the simplest and least-expensive form (analogous to a ```&fn() { }``` expression),\n+the lambda expression captures its environment by reference,\n+effectively borrowing pointers to all outer variables mentioned inside the function.\n+Alternately, the compiler may infer that a lambda expression should copy or move values (depending on their type.)\n+from the environment into the lambda expression's captured environment.\n \n-The exact type of capture depends on the [function type](#function-types) inferred for the lambda expression;\n-in the simplest and least-expensive form, the environment is captured by reference,\n-effectively borrowing pointers to all outer variables referenced inside the function.\n-Other forms of capture include making copies of captured variables,\n-and moving values from the environment into the lambda expression's captured environment.\n-\n-An example of a lambda expression:\n+In this example, we define a function `ten_times` that takes a higher-order function argument,\n+and call it with a lambda expression as an argument.\n \n ~~~~\n fn ten_times(f: &fn(int)) {\n@@ -2428,12 +2433,12 @@ type `float` may not be equal to the largest *supported* floating-point type.\n \n The types `char` and `str` hold textual data.\n \n-A value of type `char` is a Unicode character, represented as a 32-bit\n-unsigned word holding a UCS-4 codepoint.\n+A value of type `char` is a Unicode character,\n+represented as a 32-bit unsigned word holding a UCS-4 codepoint.\n \n-A value of type `str` is a Unicode string, represented as a vector of 8-bit\n-unsigned bytes holding a sequence of UTF-8 codepoints.\n-Since `str` is of indefinite size, it is not a _first class_ type,\n+A value of type `str` is a Unicode string,\n+represented as a vector of 8-bit unsigned bytes holding a sequence of UTF-8 codepoints.\n+Since `str` is of unknown size, it is not a _first class_ type,\n but can only be instantiated through a pointer type,\n such as `&str`, `@str` or `~str`.\n \n@@ -2465,15 +2470,17 @@ fail_unless!(b != \"world\");\n \n ### Vector types\n \n-The vector type-constructor represents a homogeneous array of values of a given type.\n+The vector type constructor represents a homogeneous array of values of a given type.\n A vector has a fixed size.\n-A vector type can be accompanied by _definite_ size, written with a trailing asterisk and integer literal, such as `[int * 10]`.\n-Such a definite-sized vector can be treated as a first class type since its size is known statically.\n+A vector type can be annotated with a _definite_ size,\n+written with a trailing asterisk and integer literal, such as `[int * 10]`.\n+Such a definite-sized vector type is a first-class type, since its size is known statically.\n A vector without such a size is said to be of _indefinite_ size,\n-and is therefore not a _first class_ type,\n-can only be instantiated through a pointer type,\n+and is therefore not a _first-class_ type.\n+An indefinite-size vector can only be instantiated through a pointer type,\n such as `&[T]`, `@[T]` or `~[T]`.\n-The kind of a vector type depends on the kind of its member type, as with other simple structural types.\n+The kind of a vector type depends on the kind of its element type,\n+as with other simple structural types.\n \n An example of a vector type and its use:\n \n@@ -2483,7 +2490,8 @@ let i: int = v[2];\n fail_unless!(i == 3);\n ~~~~\n \n-All accessible elements of a vector are always initialized, and access to a vector is always bounds-checked.\n+All in-bounds elements of a vector are always initialized,\n+and access to a vector is always bounds-checked.\n \n \n ### Structure types\n@@ -2605,9 +2613,9 @@ Raw pointers (`*`)\n \n ### Function types\n \n-The function type-constructor `fn` forms new function types. A function type\n-consists of a set of function-type modifiers (`unsafe`, `extern`, etc.),\n-a sequence of input slots and an output slot.\n+The function type constructor `fn` forms new function types.\n+A function type consists of a possibly-empty set of function-type modifiers\n+(such as `unsafe` or `extern`), a sequence of input types and an output type.\n \n An example of a `fn` type:\n \n@@ -2916,24 +2924,28 @@ fn main() {\n \n ## Tasks\n \n-An executing Rust program consists of a tree of tasks. A Rust _task_\n-consists of an entry function, a stack, a set of outgoing communication\n-channels and incoming communication ports, and ownership of some portion of\n-the heap of a single operating-system process.\n-\n-Multiple Rust tasks may coexist in a single operating-system process. The\n-runtime scheduler maps tasks to a certain number of operating-system threads;\n-by default a number of threads is used based on the number of concurrent\n-physical CPUs detected at startup, but this can be changed dynamically at\n-runtime. When the number of tasks exceeds the number of threads -- which is\n-quite possible -- the tasks are multiplexed onto the threads ^[This is an M:N\n-scheduler, which is known to give suboptimal results for CPU-bound concurrency\n-problems. In such cases, running with the same number of threads as tasks can\n-give better results. The M:N scheduling in Rust exists to support very large\n-numbers of tasks in contexts where threads are too resource-intensive to use\n-in a similar volume. The cost of threads varies substantially per operating\n-system, and is sometimes quite low, so this flexibility is not always worth\n-exploiting.]\n+An executing Rust program consists of a tree of tasks.\n+A Rust _task_ consists of an entry function, a stack,\n+a set of outgoing communication channels and incoming communication ports,\n+and ownership of some portion of the heap of a single operating-system process.\n+(We expect that many programs will not use channels and ports directly,\n+but will instead use higher-level abstractions provided in standard libraries,\n+such as pipes.)\n+\n+Multiple Rust tasks may coexist in a single operating-system process.\n+The runtime scheduler maps tasks to a certain number of operating-system threads.\n+By default, the scheduler chooses the number of threads based on\n+the number of concurrent physical CPUs detected at startup.\n+It's also possible to override this choice at runtime.\n+When the number of tasks exceeds the number of threads -- which is likely --\n+the scheduler multiplexes the tasks onto threads.^[\n+This is an M:N scheduler,\n+which is known to give suboptimal results for CPU-bound concurrency problems.\n+In such cases, running with the same number of threads and tasks can yield better results.\n+Rust has M:N scheduling in order to support very large numbers of tasks\n+in contexts where threads are too resource-intensive to use in large number.\n+The cost of threads varies substantially per operating system, and is sometimes quite low,\n+so this flexibility is not always worth exploiting.]\n \n \n ### Communication between tasks\n@@ -3024,16 +3036,15 @@ communication and logging.\n \n ### Memory allocation\n \n-The runtime memory-management system is based on a _service-provider\n-interface_, through which the runtime requests blocks of memory from its\n-environment and releases them back to its environment when they are no longer\n-in use. The default implementation of the service-provider interface consists\n-of the C runtime functions `malloc` and `free`.\n-\n-The runtime memory-management system in turn supplies Rust tasks with\n-facilities for allocating, extending and releasing stacks, as well as\n-allocating and freeing boxed values.\n+The runtime memory-management system is based on a _service-provider interface_,\n+through which the runtime requests blocks of memory from its environment\n+and releases them back to its environment when they are no longer needed.\n+The default implementation of the service-provider interface\n+consists of the C runtime functions `malloc` and `free`.\n \n+The runtime memory-management system, in turn, supplies Rust tasks\n+with facilities for allocating, extending and releasing stacks,\n+as well as allocating and freeing heap data.\n \n ### Built in types\n "}]}