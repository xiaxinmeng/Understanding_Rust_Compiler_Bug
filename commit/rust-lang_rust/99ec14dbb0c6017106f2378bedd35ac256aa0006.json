{"sha": "99ec14dbb0c6017106f2378bedd35ac256aa0006", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZWMxNGRiYjBjNjAxNzEwNmYyMzc4YmVkZDM1YWMyNTZhYTAwMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-19T12:06:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-19T12:06:00Z"}, "message": "auto merge of #9267 : Kimundi/rust/master, r=huonw", "tree": {"sha": "5c2ffedd075cc3e3cbde3c3aa7e777d165e1010f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c2ffedd075cc3e3cbde3c3aa7e777d165e1010f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99ec14dbb0c6017106f2378bedd35ac256aa0006", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99ec14dbb0c6017106f2378bedd35ac256aa0006", "html_url": "https://github.com/rust-lang/rust/commit/99ec14dbb0c6017106f2378bedd35ac256aa0006", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99ec14dbb0c6017106f2378bedd35ac256aa0006/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4904bc33cc20044709286794d3998d7464277ab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4904bc33cc20044709286794d3998d7464277ab4", "html_url": "https://github.com/rust-lang/rust/commit/4904bc33cc20044709286794d3998d7464277ab4"}, {"sha": "06d1dccf95a1566137528a489fc573a610316bcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/06d1dccf95a1566137528a489fc573a610316bcf", "html_url": "https://github.com/rust-lang/rust/commit/06d1dccf95a1566137528a489fc573a610316bcf"}], "stats": {"total": 1261, "additions": 641, "deletions": 620}, "files": [{"sha": "93324007f982ead5389c6f8555fc36f7436eb0ee", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=99ec14dbb0c6017106f2378bedd35ac256aa0006", "patch": "@@ -91,64 +91,62 @@ pub fn parse_config(args: ~[~str]) -> config {\n     let matches =\n         &match getopts::groups::getopts(args_, groups) {\n           Ok(m) => m,\n-          Err(f) => fail!(getopts::fail_str(f))\n+          Err(f) => fail!(f.to_err_msg())\n         };\n \n-    if getopts::opt_present(matches, \"h\") || getopts::opt_present(matches, \"help\") {\n+    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         let message = fmt!(\"Usage: %s [OPTIONS]  [TESTNAME...]\", argv0);\n         println(getopts::groups::usage(message, groups));\n         println(\"\");\n         fail!()\n     }\n \n     fn opt_path(m: &getopts::Matches, nm: &str) -> Path {\n-        Path(getopts::opt_str(m, nm))\n+        Path(m.opt_str(nm).unwrap())\n     }\n \n     config {\n-        compile_lib_path: getopts::opt_str(matches, \"compile-lib-path\"),\n-        run_lib_path: getopts::opt_str(matches, \"run-lib-path\"),\n+        compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n+        run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n-        clang_path: getopts::opt_maybe_str(matches, \"clang-path\").map_move(|s| Path(s)),\n-        llvm_bin_path: getopts::opt_maybe_str(matches, \"llvm-bin-path\").map_move(|s| Path(s)),\n+        clang_path: matches.opt_str(\"clang-path\").map_move(|s| Path(s)),\n+        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map_move(|s| Path(s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n-        stage_id: getopts::opt_str(matches, \"stage-id\"),\n-        mode: str_mode(getopts::opt_str(matches, \"mode\")),\n-        run_ignored: getopts::opt_present(matches, \"ignored\"),\n+        stage_id: matches.opt_str(\"stage-id\").unwrap(),\n+        mode: str_mode(matches.opt_str(\"mode\").unwrap()),\n+        run_ignored: matches.opt_present(\"ignored\"),\n         filter:\n             if !matches.free.is_empty() {\n                  Some(matches.free[0].clone())\n             } else {\n                 None\n             },\n-        logfile: getopts::opt_maybe_str(matches, \"logfile\").map_move(|s| Path(s)),\n-        save_metrics: getopts::opt_maybe_str(matches, \"save-metrics\").map_move(|s| Path(s)),\n+        logfile: matches.opt_str(\"logfile\").map_move(|s| Path(s)),\n+        save_metrics: matches.opt_str(\"save-metrics\").map_move(|s| Path(s)),\n         ratchet_metrics:\n-            getopts::opt_maybe_str(matches, \"ratchet-metrics\").map_move(|s| Path(s)),\n+            matches.opt_str(\"ratchet-metrics\").map_move(|s| Path(s)),\n         ratchet_noise_percent:\n-            getopts::opt_maybe_str(matches,\n-                                   \"ratchet-noise-percent\").map_move(|s|\n-                                                                     from_str::<f64>(s).unwrap()),\n-        runtool: getopts::opt_maybe_str(matches, \"runtool\"),\n-        rustcflags: getopts::opt_maybe_str(matches, \"rustcflags\"),\n-        jit: getopts::opt_present(matches, \"jit\"),\n-        target: opt_str2(getopts::opt_maybe_str(matches, \"target\")).to_str(),\n-        adb_path: opt_str2(getopts::opt_maybe_str(matches, \"adb-path\")).to_str(),\n+            matches.opt_str(\"ratchet-noise-percent\").and_then(|s| from_str::<f64>(s)),\n+        runtool: matches.opt_str(\"runtool\"),\n+        rustcflags: matches.opt_str(\"rustcflags\"),\n+        jit: matches.opt_present(\"jit\"),\n+        target: opt_str2(matches.opt_str(\"target\")).to_str(),\n+        adb_path: opt_str2(matches.opt_str(\"adb-path\")).to_str(),\n         adb_test_dir:\n-            opt_str2(getopts::opt_maybe_str(matches, \"adb-test-dir\")).to_str(),\n+            opt_str2(matches.opt_str(\"adb-test-dir\")).to_str(),\n         adb_device_status:\n-            if (opt_str2(getopts::opt_maybe_str(matches, \"target\")) ==\n+            if (opt_str2(matches.opt_str(\"target\")) ==\n                 ~\"arm-linux-androideabi\") {\n-                if (opt_str2(getopts::opt_maybe_str(matches, \"adb-test-dir\")) !=\n+                if (opt_str2(matches.opt_str(\"adb-test-dir\")) !=\n                     ~\"(none)\" &&\n-                    opt_str2(getopts::opt_maybe_str(matches, \"adb-test-dir\")) !=\n+                    opt_str2(matches.opt_str(\"adb-test-dir\")) !=\n                     ~\"\") { true }\n                 else { false }\n             } else { false },\n-        test_shard: test::opt_shard(getopts::opt_maybe_str(matches, \"test-shard\")),\n-        verbose: getopts::opt_present(matches, \"verbose\")\n+        test_shard: test::opt_shard(matches.opt_str(\"test-shard\")),\n+        verbose: matches.opt_present(\"verbose\")\n     }\n }\n "}, {"sha": "0116c5a1f66013df4f01744ea2f6dafaf30eb88f", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 522, "deletions": 495, "changes": 1017, "blob_url": "https://github.com/rust-lang/rust/blob/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=99ec14dbb0c6017106f2378bedd35ac256aa0006", "patch": "@@ -8,195 +8,287 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * Simple getopt alternative.\n- *\n- * Construct a vector of options, either by using reqopt, optopt, and optflag\n- * or by building them from components yourself, and pass them to getopts,\n- * along with a vector of actual arguments (not including argv[0]). You'll\n- * either get a failure code back, or a match. You'll have to verify whether\n- * the amount of 'free' arguments in the match is what you expect. Use opt_*\n- * accessors to get argument values out of the matches object.\n- *\n- * Single-character options are expected to appear on the command line with a\n- * single preceding dash; multiple-character options are expected to be\n- * proceeded by two dashes. Options that expect an argument accept their\n- * argument following either a space or an equals sign. Single-character\n- * options don't require the space.\n- *\n- * # Example\n- *\n- * The following example shows simple command line parsing for an application\n- * that requires an input file to be specified, accepts an optional output\n- * file name following -o, and accepts both -h and --help as optional flags.\n- *\n- * ```\n- *    extern mod extra;\n- *    use extra::getopts::*;\n- *    use std::os;\n- *\n- *    fn do_work(in: &str, out: Option<~str>) {\n- *        println(in);\n- *        println(match out {\n- *            Some(x) => x,\n- *            None => ~\"No Output\"\n- *        });\n- *    }\n- *\n- *    fn print_usage(program: &str, _opts: &[Opt]) {\n- *        printfln!(\"Usage: %s [options]\", program);\n- *        println(\"-o\\t\\tOutput\");\n- *        println(\"-h --help\\tUsage\");\n- *    }\n- *\n- *    fn main() {\n- *        let args = os::args();\n- *\n- *        let program = args[0].clone();\n- *\n- *        let opts = ~[\n- *            optopt(\"o\"),\n- *            optflag(\"h\"),\n- *            optflag(\"help\")\n- *        ];\n- *        let matches = match getopts(args.tail(), opts) {\n- *            Ok(m) => { m }\n- *            Err(f) => { fail!(fail_str(f)) }\n- *        };\n- *        if opt_present(&matches, \"h\") || opt_present(&matches, \"help\") {\n- *            print_usage(program, opts);\n- *            return;\n- *        }\n- *        let output = opt_maybe_str(&matches, \"o\");\n- *        let input: &str = if !matches.free.is_empty() {\n- *            matches.free[0].clone()\n- *        } else {\n- *            print_usage(program, opts);\n- *            return;\n- *        };\n- *        do_work(input, output);\n- *    }\n- * ```\n- */\n-\n-#[allow(missing_doc)];\n-\n+//! Simple getopt alternative.\n+//!\n+//! Construct a vector of options, either by using reqopt, optopt, and optflag\n+//! or by building them from components yourself, and pass them to getopts,\n+//! along with a vector of actual arguments (not including argv[0]). You'll\n+//! either get a failure code back, or a match. You'll have to verify whether\n+//! the amount of 'free' arguments in the match is what you expect. Use opt_*\n+//! accessors to get argument values out of the matches object.\n+//!\n+//! Single-character options are expected to appear on the command line with a\n+//! single preceding dash; multiple-character options are expected to be\n+//! proceeded by two dashes. Options that expect an argument accept their\n+//! argument following either a space or an equals sign. Single-character\n+//! options don't require the space.\n+//!\n+//! # Example\n+//!\n+//! The following example shows simple command line parsing for an application\n+//! that requires an input file to be specified, accepts an optional output\n+//! file name following -o, and accepts both -h and --help as optional flags.\n+//!\n+//! ```\n+//! exter mod extra;\n+//! use extra::getopts::*;\n+//! use std::os;\n+//!\n+//! fn do_work(inp: &str, out: Option<~str>) {\n+//!     println(inp);\n+//!     println(match out {\n+//!         Some(x) => x,\n+//!         None => ~\"No Output\"\n+//!     });\n+//! }\n+//!\n+//! fn print_usage(program: &str, _opts: &[Opt]) {\n+//!     printfln!(\"Usage: %s [options]\", program);\n+//!     println(\"-o\\t\\tOutput\");\n+//!     println(\"-h --help\\tUsage\");\n+//! }\n+//!\n+//! fn main() {\n+//!     let args = os::args();\n+//!\n+//!     let program = args[0].clone();\n+//!\n+//!     let opts = ~[\n+//!         optopt(\"o\"),\n+//!         optflag(\"h\"),\n+//!         optflag(\"help\")\n+//!     ];\n+//!     let matches = match getopts(args.tail(), opts) {\n+//!         Ok(m) => { m }\n+//!         Err(f) => { fail!(f.to_err_msg()) }\n+//!     };\n+//!     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+//!         print_usage(program, opts);\n+//!         return;\n+//!     }\n+//!     let output = matches.opt_str(\"o\");\n+//!     let input: &str = if !matches.free.is_empty() {\n+//!         matches.free[0].clone()\n+//!     } else {\n+//!         print_usage(program, opts);\n+//!         return;\n+//!     };\n+//!     do_work(input, output);\n+//! }\n+//! ```\n \n use std::cmp::Eq;\n use std::result::{Err, Ok};\n use std::result;\n use std::option::{Some, None};\n-use std::str;\n use std::vec;\n \n+/// Name of an option. Either a string or a single char.\n #[deriving(Clone, Eq)]\n pub enum Name {\n     Long(~str),\n     Short(char),\n }\n \n+/// Describes whether an option has an argument.\n #[deriving(Clone, Eq)]\n pub enum HasArg {\n     Yes,\n     No,\n     Maybe,\n }\n \n+/// Describes how often an option may occur.\n #[deriving(Clone, Eq)]\n pub enum Occur {\n     Req,\n     Optional,\n     Multi,\n }\n \n-/// A description of a possible option\n+/// A description of a possible option.\n #[deriving(Clone, Eq)]\n pub struct Opt {\n+    /// Name of the option\n     name: Name,\n+    /// Wheter it has an argument\n     hasarg: HasArg,\n+    /// How often it can occur\n     occur: Occur,\n+    /// Which options it aliases\n     aliases: ~[Opt],\n }\n \n-fn mkname(nm: &str) -> Name {\n-  if nm.len() == 1u {\n-      Short(nm.char_at(0u))\n-  } else {\n-      Long(nm.to_owned())\n-  }\n+/// Describes wether an option is given at all or has a value.\n+#[deriving(Clone, Eq)]\n+enum Optval {\n+    Val(~str),\n+    Given,\n }\n \n-/// Create an option that is required and takes an argument\n-pub fn reqopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Req, aliases: ~[]};\n+/// The result of checking command line arguments. Contains a vector\n+/// of matches and a vector of free strings.\n+#[deriving(Clone, Eq)]\n+pub struct Matches {\n+    /// Options that matched\n+    opts: ~[Opt],\n+    /// Values of the Options that matched\n+    vals: ~[~[Optval]],\n+    /// Free string fragments\n+    free: ~[~str]\n }\n \n-/// Create an option that is optional and takes an argument\n-pub fn optopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Optional, aliases: ~[]};\n+/// The type returned when the command line does not conform to the\n+/// expected format. Pass this value to <fail_str> to get an error message.\n+#[deriving(Clone, Eq, ToStr)]\n+pub enum Fail_ {\n+    ArgumentMissing(~str),\n+    UnrecognizedOption(~str),\n+    OptionMissing(~str),\n+    OptionDuplicated(~str),\n+    UnexpectedArgument(~str),\n }\n \n-/// Create an option that is optional and does not take an argument\n-pub fn optflag(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: No, occur: Optional, aliases: ~[]};\n+/// The type of failure that occured.\n+#[deriving(Eq)]\n+pub enum FailType {\n+    ArgumentMissing_,\n+    UnrecognizedOption_,\n+    OptionMissing_,\n+    OptionDuplicated_,\n+    UnexpectedArgument_,\n }\n \n-/** Create an option that is optional, does not take an argument,\n-  * and may occur multiple times.\n-  */\n-pub fn optflagmulti(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: No, occur: Multi, aliases: ~[]};\n-}\n+/// The result of parsing a command line with a set of options.\n+pub type Result = result::Result<Matches, Fail_>;\n \n-/// Create an option that is optional and takes an optional argument\n-pub fn optflagopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Maybe, occur: Optional, aliases: ~[]};\n-}\n+impl Name {\n+    fn from_str(nm: &str) -> Name {\n+        if nm.len() == 1u {\n+            Short(nm.char_at(0u))\n+        } else {\n+            Long(nm.to_owned())\n+        }\n+    }\n \n-/**\n- * Create an option that is optional, takes an argument, and may occur\n- * multiple times\n- */\n-pub fn optmulti(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Multi, aliases: ~[]};\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            Short(ch) => ch.to_str(),\n+            Long(ref s) => s.to_owned()\n+        }\n+    }\n }\n \n-#[deriving(Clone, Eq)]\n-enum Optval {\n-    Val(~str),\n-    Given,\n-}\n+impl Matches {\n+    /// FIXME: #9311 This used to be private, but rustpkg somehow managed to depend on it.\n+    /// No idea what this does.\n+    pub fn opt_vals(&self, nm: &str) -> ~[Optval] {\n+        match find_opt(self.opts, Name::from_str(nm)) {\n+            Some(id) => self.vals[id].clone(),\n+            None => fail!(\"No option '%s' defined\", nm)\n+        }\n+    }\n \n-/**\n- * The result of checking command line arguments. Contains a vector\n- * of matches and a vector of free strings.\n- */\n-#[deriving(Clone, Eq)]\n-pub struct Matches {\n-    opts: ~[Opt],\n-    vals: ~[~[Optval]],\n-    free: ~[~str]\n-}\n+    /// FIXME: #9311 This used to be private, but rustpkg somehow managed to depend on it.\n+    /// No idea what this does.\n+    pub fn opt_val(&self, nm: &str) -> Option<Optval> {\n+        let vals = self.opt_vals(nm);\n+        if (vals.is_empty()) {\n+            None\n+        } else {\n+            Some(vals[0].clone())\n+        }\n+    }\n+\n+    /// Returns true if an option was matched.\n+    pub fn opt_present(&self, nm: &str) -> bool {\n+        !self.opt_vals(nm).is_empty()\n+    }\n+\n+    /// Returns the number of times an option was matched.\n+    pub fn opt_count(&self, nm: &str) -> uint {\n+        self.opt_vals(nm).len()\n+    }\n+\n+    /// Returns true if any of several options were matched.\n+    pub fn opts_present(&self, names: &[~str]) -> bool {\n+        for nm in names.iter() {\n+            match find_opt(self.opts, Name::from_str(*nm)) {\n+                Some(id) if !self.vals[id].is_empty() => return true,\n+                _ => (),\n+            };\n+        }\n+        false\n+    }\n+\n+    /// Returns the string argument supplied to one of several matching options or `None`.\n+    pub fn opts_str(&self, names: &[~str]) -> Option<~str> {\n+        for nm in names.iter() {\n+            match self.opt_val(*nm) {\n+                Some(Val(ref s)) => return Some(s.clone()),\n+                _ => ()\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Returns a vector of the arguments provided to all matches of the given\n+    /// option.\n+    ///\n+    /// Used when an option accepts multiple values.\n+    pub fn opt_strs(&self, nm: &str) -> ~[~str] {\n+        let mut acc: ~[~str] = ~[];\n+        let r = self.opt_vals(nm);\n+        for v in r.iter() {\n+            match *v {\n+                Val(ref s) => acc.push((*s).clone()),\n+                _ => ()\n+            }\n+        }\n+        acc\n+    }\n+\n+    /// Returns the string argument supplied to a matching option or `None`.\n+    pub fn opt_str(&self, nm: &str) -> Option<~str> {\n+        let vals = self.opt_vals(nm);\n+        if vals.is_empty() {\n+            return None::<~str>;\n+        }\n+        match vals[0] {\n+            Val(ref s) => Some((*s).clone()),\n+            _ => None\n+        }\n+    }\n+\n+\n+    /// Returns the matching string, a default, or none.\n+    ///\n+    /// Returns none if the option was not present, `def` if the option was\n+    /// present but no argument was provided, and the argument if the option was\n+    /// present and an argument was provided.\n+    pub fn opt_default(&self, nm: &str, def: &str) -> Option<~str> {\n+        let vals = self.opt_vals(nm);\n+        if vals.is_empty() { return None; }\n+        match vals[0] {\n+            Val(ref s) => Some((*s).clone()),\n+            _ => Some(def.to_owned())\n+        }\n+    }\n \n-fn is_arg(arg: &str) -> bool {\n-    return arg.len() > 1 && arg[0] == '-' as u8;\n }\n \n-fn name_str(nm: &Name) -> ~str {\n-    return match *nm {\n-      Short(ch) => str::from_char(ch),\n-      Long(ref s) => (*s).clone()\n-    };\n+fn is_arg(arg: &str) -> bool {\n+    arg.len() > 1 && arg[0] == '-' as u8\n }\n \n fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n-    // search main options\n+    // Search main options.\n     let pos = opts.iter().position(|opt| opt.name == nm);\n     if pos.is_some() {\n         return pos\n     }\n \n-    // search in aliases\n+    // Search in aliases.\n     for candidate in opts.iter() {\n         if candidate.aliases.iter().position(|opt| opt.name == nm).is_some() {\n             return opts.iter().position(|opt| opt.name == candidate.name);\n@@ -206,56 +298,101 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n     None\n }\n \n-/**\n- * The type returned when the command line does not conform to the\n- * expected format. Pass this value to <fail_str> to get an error message.\n- */\n-#[deriving(Clone, Eq, ToStr)]\n-pub enum Fail_ {\n-    ArgumentMissing(~str),\n-    UnrecognizedOption(~str),\n-    OptionMissing(~str),\n-    OptionDuplicated(~str),\n-    UnexpectedArgument(~str),\n+/// Create an option that is required and takes an argument.\n+pub fn reqopt(name: &str) -> Opt {\n+    Opt {\n+        name: Name::from_str(name),\n+        hasarg: Yes,\n+        occur: Req,\n+        aliases: ~[]\n+    }\n }\n \n-/// Convert a `fail_` enum into an error string\n-pub fn fail_str(f: Fail_) -> ~str {\n-    return match f {\n-        ArgumentMissing(ref nm) => {\n-            fmt!(\"Argument to option '%s' missing.\", *nm)\n-        }\n-        UnrecognizedOption(ref nm) => {\n-            fmt!(\"Unrecognized option: '%s'.\", *nm)\n-        }\n-        OptionMissing(ref nm) => {\n-            fmt!(\"Required option '%s' missing.\", *nm)\n-        }\n-        OptionDuplicated(ref nm) => {\n-            fmt!(\"Option '%s' given more than once.\", *nm)\n-        }\n-        UnexpectedArgument(ref nm) => {\n-            fmt!(\"Option '%s' does not take an argument.\", *nm)\n-        }\n-    };\n+/// Create an option that is optional and takes an argument.\n+pub fn optopt(name: &str) -> Opt {\n+    Opt {\n+        name: Name::from_str(name),\n+        hasarg: Yes,\n+        occur: Optional,\n+        aliases: ~[]\n+    }\n }\n \n-/**\n- * The result of parsing a command line with a set of options\n- * (result::t<Matches, Fail_>)\n- */\n-pub type Result = result::Result<Matches, Fail_>;\n+/// Create an option that is optional and does not take an argument.\n+pub fn optflag(name: &str) -> Opt {\n+    Opt {\n+        name: Name::from_str(name),\n+        hasarg: No,\n+        occur: Optional,\n+        aliases: ~[]\n+    }\n+}\n+\n+/// Create an option that is optional, does not take an argument,\n+/// and may occur multiple times.\n+pub fn optflagmulti(name: &str) -> Opt {\n+    Opt {\n+        name: Name::from_str(name),\n+        hasarg: No,\n+        occur: Multi,\n+        aliases: ~[]\n+    }\n+}\n+\n+/// Create an option that is optional and takes an optional argument.\n+pub fn optflagopt(name: &str) -> Opt {\n+    Opt {\n+        name: Name::from_str(name),\n+        hasarg: Maybe,\n+        occur: Optional,\n+        aliases: ~[]\n+    }\n+}\n+\n+/// Create an option that is optional, takes an argument, and may occur\n+/// multiple times.\n+pub fn optmulti(name: &str) -> Opt {\n+    Opt {\n+        name: Name::from_str(name),\n+        hasarg: Yes,\n+        occur: Multi,\n+        aliases: ~[]\n+    }\n+}\n \n-/**\n- * Parse command line arguments according to the provided options\n- *\n- * On success returns `ok(Opt)`. Use functions such as `opt_present`\n- * `opt_str`, etc. to interrogate results.  Returns `err(Fail_)` on failure.\n- * Use <fail_str> to get an error message.\n- */\n+impl Fail_ {\n+    /// Convert a `Fail_` enum into an error string.\n+    pub fn to_err_msg(self) -> ~str {\n+        match self {\n+            ArgumentMissing(ref nm) => {\n+                fmt!(\"Argument to option '%s' missing.\", *nm)\n+            }\n+            UnrecognizedOption(ref nm) => {\n+                fmt!(\"Unrecognized option: '%s'.\", *nm)\n+            }\n+            OptionMissing(ref nm) => {\n+                fmt!(\"Required option '%s' missing.\", *nm)\n+            }\n+            OptionDuplicated(ref nm) => {\n+                fmt!(\"Option '%s' given more than once.\", *nm)\n+            }\n+            UnexpectedArgument(ref nm) => {\n+                fmt!(\"Option '%s' does not take an argument.\", *nm)\n+            }\n+        }\n+    }\n+}\n+\n+/// Parse command line arguments according to the provided options.\n+///\n+/// On success returns `Ok(Opt)`. Use methods such as `opt_present`\n+/// `opt_str`, etc. to interrogate results.  Returns `Err(Fail_)` on failure.\n+/// Use `to_err_msg` to get an error message.\n pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n     let n_opts = opts.len();\n+\n     fn f(_x: uint) -> ~[Optval] { return ~[]; }\n+\n     let mut vals = vec::from_fn(n_opts, f);\n     let mut free: ~[~str] = ~[];\n     let l = args.len();\n@@ -325,12 +462,12 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                 name_pos += 1;\n                 let optid = match find_opt(opts, (*nm).clone()) {\n                   Some(id) => id,\n-                  None => return Err(UnrecognizedOption(name_str(nm)))\n+                  None => return Err(UnrecognizedOption(nm.to_str()))\n                 };\n                 match opts[optid].hasarg {\n                   No => {\n                     if !i_arg.is_none() {\n-                        return Err(UnexpectedArgument(name_str(nm)));\n+                        return Err(UnexpectedArgument(nm.to_str()));\n                     }\n                     vals[optid].push(Given);\n                   }\n@@ -346,7 +483,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                     if !i_arg.is_none() {\n                         vals[optid].push(Val(i_arg.clone().unwrap()));\n                     } else if i + 1 == l {\n-                        return Err(ArgumentMissing(name_str(nm)));\n+                        return Err(ArgumentMissing(nm.to_str()));\n                     } else { i += 1; vals[optid].push(Val(args[i].clone())); }\n                   }\n                 }\n@@ -360,289 +497,183 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n         let occ = opts[i].occur;\n         if occ == Req {\n             if n == 0 {\n-                return Err(OptionMissing(name_str(&(opts[i].name))));\n+                return Err(OptionMissing(opts[i].name.to_str()));\n             }\n         }\n         if occ != Multi {\n             if n > 1 {\n-                return Err(OptionDuplicated(name_str(&(opts[i].name))));\n+                return Err(OptionDuplicated(opts[i].name.to_str()));\n             }\n         }\n         i += 1;\n     }\n-    return Ok(Matches {opts: opts.to_owned(),\n-               vals: vals,\n-               free: free});\n-}\n-\n-fn opt_vals(mm: &Matches, nm: &str) -> ~[Optval] {\n-    return match find_opt(mm.opts, mkname(nm)) {\n-      Some(id) => mm.vals[id].clone(),\n-      None => {\n-        error!(\"No option '%s' defined\", nm);\n-        fail!()\n-      }\n-    };\n-}\n-\n-fn opt_val(mm: &Matches, nm: &str) -> Option<Optval> {\n-    let vals = opt_vals(mm, nm);\n-    if (vals.is_empty()) {\n-        None\n-    } else {\n-        Some(opt_vals(mm, nm)[0].clone())\n-    }\n-}\n-\n-/// Returns true if an option was matched\n-pub fn opt_present(mm: &Matches, nm: &str) -> bool {\n-    !opt_vals(mm, nm).is_empty()\n-}\n-\n-/// Returns the number of times an option was matched\n-pub fn opt_count(mm: &Matches, nm: &str) -> uint {\n-    opt_vals(mm, nm).len()\n-}\n-\n-/// Returns true if any of several options were matched\n-pub fn opts_present(mm: &Matches, names: &[~str]) -> bool {\n-    for nm in names.iter() {\n-        match find_opt(mm.opts, mkname(*nm)) {\n-            Some(id) if !mm.vals[id].is_empty() => return true,\n-            _ => (),\n-        };\n-    }\n-    false\n-}\n-\n-\n-/**\n- * Returns the string argument supplied to a matching option\n- *\n- * Fails if the option was not matched or if the match did not take an\n- * argument\n- */\n-pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n-    return match opt_val(mm, nm) {\n-        Some(Val(s)) => s,\n-        _ => fail!()\n-    };\n-}\n-\n-/**\n- * Returns the string argument supplied to one of several matching options\n- *\n- * Fails if the no option was provided from the given list, or if the no such\n- * option took an argument\n- */\n-pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n-    for nm in names.iter() {\n-        match opt_val(mm, *nm) {\n-          Some(Val(ref s)) => return (*s).clone(),\n-          _ => ()\n-        }\n-    }\n-    fail!();\n+    Ok(Matches {\n+        opts: opts.to_owned(),\n+        vals: vals,\n+        free: free\n+    })\n }\n \n-\n-/**\n- * Returns a vector of the arguments provided to all matches of the given\n- * option.\n- *\n- * Used when an option accepts multiple values.\n- */\n-pub fn opt_strs(mm: &Matches, nm: &str) -> ~[~str] {\n-    let mut acc: ~[~str] = ~[];\n-    let r = opt_vals(mm, nm);\n-    for v in r.iter() {\n-        match *v { Val(ref s) => acc.push((*s).clone()), _ => () }\n-    }\n-    acc\n-}\n-\n-/// Returns the string argument supplied to a matching option or none\n-pub fn opt_maybe_str(mm: &Matches, nm: &str) -> Option<~str> {\n-    let vals = opt_vals(mm, nm);\n-    if vals.is_empty() { return None::<~str>; }\n-    return match vals[0] {\n-        Val(ref s) => Some((*s).clone()),\n-        _ => None\n-    };\n-}\n-\n-\n-/**\n- * Returns the matching string, a default, or none\n- *\n- * Returns none if the option was not present, `def` if the option was\n- * present but no argument was provided, and the argument if the option was\n- * present and an argument was provided.\n- */\n-pub fn opt_default(mm: &Matches, nm: &str, def: &str) -> Option<~str> {\n-    let vals = opt_vals(mm, nm);\n-    if vals.is_empty() { return None::<~str>; }\n-    return match vals[0] { Val(ref s) => Some::<~str>((*s).clone()),\n-                           _      => Some::<~str>(def.to_owned()) }\n-}\n-\n-#[deriving(Eq)]\n-pub enum FailType {\n-    ArgumentMissing_,\n-    UnrecognizedOption_,\n-    OptionMissing_,\n-    OptionDuplicated_,\n-    UnexpectedArgument_,\n-}\n-\n-/** A module which provides a way to specify descriptions and\n- *  groups of short and long option names, together.\n- */\n+/// A module which provides a way to specify descriptions and\n+/// groups of short and long option names, together.\n pub mod groups {\n     use getopts::{HasArg, Long, Maybe, Multi, No, Occur, Opt, Optional, Req};\n     use getopts::{Short, Yes};\n \n-    /** one group of options, e.g., both -h and --help, along with\n-     * their shared description and properties\n-     */\n+    /// One group of options, e.g., both -h and --help, along with\n+    /// their shared description and properties.\n     #[deriving(Clone, Eq)]\n     pub struct OptGroup {\n+        /// Short Name of the `OptGroup`\n         short_name: ~str,\n+        /// Long Name of the `OptGroup`\n         long_name: ~str,\n+        /// Hint\n         hint: ~str,\n+        /// Description\n         desc: ~str,\n+        /// Whether it has an argument\n         hasarg: HasArg,\n+        /// How often it can occur\n         occur: Occur\n     }\n \n-    /// Create a long option that is required and takes an argument\n-    pub fn reqopt(short_name: &str, long_name: &str,\n-                  desc: &str, hint: &str) -> OptGroup {\n+    impl OptGroup {\n+        /// Translate OptGroup into Opt.\n+        /// (Both short and long names correspond to different Opts).\n+        pub fn long_to_short(&self) -> Opt {\n+            let OptGroup {\n+                short_name: short_name,\n+                long_name: long_name,\n+                hasarg: hasarg,\n+                occur: occur,\n+                _\n+            } = (*self).clone();\n+\n+            match (short_name.len(), long_name.len()) {\n+                (0,0) => fail!(\"this long-format option was given no name\"),\n+                (0,_) => Opt {\n+                    name: Long((long_name)),\n+                    hasarg: hasarg,\n+                    occur: occur,\n+                    aliases: ~[]\n+                },\n+                (1,0) => Opt {\n+                    name: Short(short_name.char_at(0)),\n+                    hasarg: hasarg,\n+                    occur: occur,\n+                    aliases: ~[]\n+                },\n+                (1,_) => Opt {\n+                    name: Long((long_name)),\n+                    hasarg: hasarg,\n+                    occur:  occur,\n+                    aliases: ~[\n+                        Opt {\n+                            name: Short(short_name.char_at(0)),\n+                            hasarg: hasarg,\n+                            occur:  occur,\n+                            aliases: ~[]\n+                        }\n+                    ]\n+                },\n+                (_,_) => fail!(\"something is wrong with the long-form opt\")\n+            }\n+        }\n+    }\n+\n+    /// Create a long option that is required and takes an argument.\n+    pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup { short_name: short_name.to_owned(),\n-                long_name: long_name.to_owned(),\n-                hint: hint.to_owned(),\n-                desc: desc.to_owned(),\n-                hasarg: Yes,\n-                occur: Req};\n+        OptGroup {\n+            short_name: short_name.to_owned(),\n+            long_name: long_name.to_owned(),\n+            hint: hint.to_owned(),\n+            desc: desc.to_owned(),\n+            hasarg: Yes,\n+            occur: Req\n+        }\n     }\n \n-    /// Create a long option that is optional and takes an argument\n-    pub fn optopt(short_name: &str, long_name: &str,\n-                  desc: &str, hint: &str) -> OptGroup {\n+    /// Create a long option that is optional and takes an argument.\n+    pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: short_name.to_owned(),\n-                long_name: long_name.to_owned(),\n-                hint: hint.to_owned(),\n-                desc: desc.to_owned(),\n-                hasarg: Yes,\n-                occur: Optional};\n+        OptGroup {\n+            short_name: short_name.to_owned(),\n+            long_name: long_name.to_owned(),\n+            hint: hint.to_owned(),\n+            desc: desc.to_owned(),\n+            hasarg: Yes,\n+            occur: Optional\n+        }\n     }\n \n-    /// Create a long option that is optional and does not take an argument\n-    pub fn optflag(short_name: &str, long_name: &str,\n-                   desc: &str) -> OptGroup {\n+    /// Create a long option that is optional and does not take an argument.\n+    pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: short_name.to_owned(),\n-                long_name: long_name.to_owned(),\n-                hint: ~\"\",\n-                desc: desc.to_owned(),\n-                hasarg: No,\n-                occur: Optional};\n+        OptGroup {\n+            short_name: short_name.to_owned(),\n+            long_name: long_name.to_owned(),\n+            hint: ~\"\",\n+            desc: desc.to_owned(),\n+            hasarg: No,\n+            occur: Optional\n+        }\n     }\n \n     /// Create a long option that can occur more than once and does not\n-    /// take an argument\n-    pub fn optflagmulti(short_name: &str, long_name: &str,\n-                   desc: &str) -> OptGroup {\n+    /// take an argument.\n+    pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: short_name.to_owned(),\n-                long_name: long_name.to_owned(),\n-                hint: ~\"\",\n-                desc: desc.to_owned(),\n-                hasarg: No,\n-                occur: Multi};\n+        OptGroup {\n+            short_name: short_name.to_owned(),\n+            long_name: long_name.to_owned(),\n+            hint: ~\"\",\n+            desc: desc.to_owned(),\n+            hasarg: No,\n+            occur: Multi\n+        }\n     }\n \n-    /// Create a long option that is optional and takes an optional argument\n-    pub fn optflagopt(short_name: &str, long_name: &str,\n-                      desc: &str, hint: &str) -> OptGroup {\n+    /// Create a long option that is optional and takes an optional argument.\n+    pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: short_name.to_owned(),\n-                long_name: long_name.to_owned(),\n-                hint: hint.to_owned(),\n-                desc: desc.to_owned(),\n-                hasarg: Maybe,\n-                occur: Optional};\n-    }\n-\n-    /**\n-     * Create a long option that is optional, takes an argument, and may occur\n-     * multiple times\n-     */\n-    pub fn optmulti(short_name: &str, long_name: &str,\n-                    desc: &str, hint: &str) -> OptGroup {\n+        OptGroup {\n+            short_name: short_name.to_owned(),\n+            long_name: long_name.to_owned(),\n+            hint: hint.to_owned(),\n+            desc: desc.to_owned(),\n+            hasarg: Maybe,\n+            occur: Optional\n+        }\n+    }\n+\n+    /// Create a long option that is optional, takes an argument, and may occur\n+    /// multiple times.\n+    pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: short_name.to_owned(),\n-                long_name: long_name.to_owned(),\n-                hint: hint.to_owned(),\n-                desc: desc.to_owned(),\n-                hasarg: Yes,\n-                occur: Multi};\n-    }\n-\n-    // translate OptGroup into Opt\n-    // (both short and long names correspond to different Opts)\n-    pub fn long_to_short(lopt: &OptGroup) -> Opt {\n-        let OptGroup{short_name: short_name,\n-                     long_name: long_name,\n-                     hasarg: hasarg,\n-                     occur: occur,\n-                     _} = (*lopt).clone();\n-\n-        match (short_name.len(), long_name.len()) {\n-            (0,0) => fail!(\"this long-format option was given no name\"),\n-\n-            (0,_) => Opt {name: Long((long_name)),\n-                          hasarg: hasarg,\n-                          occur: occur,\n-                          aliases: ~[]},\n-\n-            (1,0) => Opt {name: Short(short_name.char_at(0)),\n-                          hasarg: hasarg,\n-                          occur: occur,\n-                          aliases: ~[]},\n-\n-            (1,_) => Opt {name: Long((long_name)),\n-                          hasarg: hasarg,\n-                          occur:  occur,\n-                          aliases: ~[Opt {\n-                              name: Short(short_name.char_at(0)),\n-                              hasarg: hasarg,\n-                              occur:  occur,\n-                              aliases: ~[]\n-                          }]},\n-\n-            (_,_) => fail!(\"something is wrong with the long-form opt\")\n-        }\n-    }\n-\n-    /*\n-     * Parse command line args with the provided long format options\n-     */\n+        OptGroup {\n+            short_name: short_name.to_owned(),\n+            long_name: long_name.to_owned(),\n+            hint: hint.to_owned(),\n+            desc: desc.to_owned(),\n+            hasarg: Yes,\n+            occur: Multi\n+        }\n+    }\n+\n+    /// Parse command line args with the provided long format options.\n     pub fn getopts(args: &[~str], opts: &[OptGroup]) -> ::getopts::Result {\n-        ::getopts::getopts(args, opts.map(long_to_short))\n+        ::getopts::getopts(args, opts.map(|x| x.long_to_short()))\n     }\n \n-    /**\n-     * Derive a usage message from a set of long options\n-     */\n+    /// Derive a usage message from a set of long options.\n     pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n         let desc_sep = \"\\n\" + \" \".repeat(24);\n@@ -721,28 +752,24 @@ pub mod groups {\n             row\n         });\n \n-        return brief.to_owned() +\n-               \"\\n\\nOptions:\\n\" +\n-               rows.collect::<~[~str]>().connect(\"\\n\") +\n-               \"\\n\";\n-    }\n-\n-    /** Splits a string into substrings with possibly internal whitespace,\n-     *  each of them at most `lim` bytes long. The substrings have leading and trailing\n-     *  whitespace removed, and are only cut at whitespace boundaries.\n-     *\n-     *  Note: Function was moved here from `std::str` because this module is the only place that\n-     *  uses it, and because it was to specific for a general string function.\n-     *\n-     *  #Failure:\n-     *\n-     *  Fails during iteration if the string contains a non-whitespace\n-     *  sequence longer than the limit.\n-     */\n+        fmt!(\"%s\\n\\nOptions:\\n%s\\n\", brief, rows.collect::<~[~str]>().connect(\"\\n\"))\n+    }\n+\n+    /// Splits a string into substrings with possibly internal whitespace,\n+    /// each of them at most `lim` bytes long. The substrings have leading and trailing\n+    /// whitespace removed, and are only cut at whitespace boundaries.\n+    ///\n+    /// Note: Function was moved here from `std::str` because this module is the only place that\n+    /// uses it, and because it was to specific for a general string function.\n+    ///\n+    /// #Failure:\n+    ///\n+    /// Fails during iteration if the string contains a non-whitespace\n+    /// sequence longer than the limit.\n     fn each_split_within<'a>(ss: &'a str,\n                              lim: uint,\n                              it: &fn(&'a str) -> bool) -> bool {\n-        // Just for fun, let's write this as an state machine:\n+        // Just for fun, let's write this as a state machine:\n \n         enum SplitWithinState {\n             A,  // leading whitespace, initial state\n@@ -853,8 +880,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, \"test\")));\n-            assert_eq!(opt_str(m, \"test\"), ~\"20\");\n+            assert!(m.opt_present(\"test\"));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n           _ => { fail!(\"test_reqopt_long failed\"); }\n         }\n@@ -900,8 +927,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, \"t\")));\n-            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n+            assert!(m.opt_present(\"t\"));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -949,8 +976,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, \"test\")));\n-            assert_eq!(opt_str(m, \"test\"), ~\"20\");\n+            assert!(m.opt_present(\"test\"));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -962,7 +989,7 @@ mod tests {\n         let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, \"test\")),\n+          Ok(ref m) => assert!(!m.opt_present(\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -996,8 +1023,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, \"t\")));\n-            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n+            assert!((m.opt_present(\"t\")));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -1009,7 +1036,7 @@ mod tests {\n         let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, \"t\")),\n+          Ok(ref m) => assert!(!m.opt_present(\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -1044,7 +1071,7 @@ mod tests {\n         let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(opt_present(m, \"test\")),\n+          Ok(ref m) => assert!(m.opt_present(\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -1055,7 +1082,7 @@ mod tests {\n         let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, \"test\")),\n+          Ok(ref m) => assert!(!m.opt_present(\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -1067,7 +1094,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => {\n-            error!(fail_str(f.clone()));\n+            error!(f.clone().to_err_msg());\n             check_fail_type(f, UnexpectedArgument_);\n           }\n           _ => fail!()\n@@ -1091,7 +1118,7 @@ mod tests {\n         let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(opt_present(m, \"t\")),\n+          Ok(ref m) => assert!(m.opt_present(\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -1102,7 +1129,7 @@ mod tests {\n         let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, \"t\")),\n+          Ok(ref m) => assert!(!m.opt_present(\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -1141,7 +1168,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, \"v\"), 1);\n+            assert_eq!(m.opt_count(\"v\"), 1);\n           }\n           _ => fail!()\n         }\n@@ -1154,7 +1181,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, \"v\"), 2);\n+            assert_eq!(m.opt_count(\"v\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -1167,7 +1194,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, \"v\"), 2);\n+            assert_eq!(m.opt_count(\"v\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -1180,7 +1207,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, \"verbose\"), 1);\n+            assert_eq!(m.opt_count(\"verbose\"), 1);\n           }\n           _ => fail!()\n         }\n@@ -1193,7 +1220,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, \"verbose\"), 2);\n+            assert_eq!(m.opt_count(\"verbose\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -1207,8 +1234,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, \"test\")));\n-            assert_eq!(opt_str(m, \"test\"), ~\"20\");\n+            assert!((m.opt_present(\"test\")));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -1220,7 +1247,7 @@ mod tests {\n         let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, \"test\")),\n+          Ok(ref m) => assert!(!m.opt_present(\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -1243,9 +1270,9 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-              assert!(opt_present(m, \"test\"));\n-              assert_eq!(opt_str(m, \"test\"), ~\"20\");\n-              let pair = opt_strs(m, \"test\");\n+              assert!(m.opt_present(\"test\"));\n+              assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+              let pair = m.opt_strs(\"test\");\n               assert!(pair[0] == ~\"20\");\n               assert!(pair[1] == ~\"30\");\n           }\n@@ -1260,8 +1287,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, \"t\")));\n-            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n+            assert!((m.opt_present(\"t\")));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -1273,7 +1300,7 @@ mod tests {\n         let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, \"t\")),\n+          Ok(ref m) => assert!(!m.opt_present(\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -1296,9 +1323,9 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, \"t\")));\n-            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n-            let pair = opt_strs(m, \"t\");\n+            assert!((m.opt_present(\"t\")));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n+            let pair = m.opt_strs(\"t\");\n             assert!(pair[0] == ~\"20\");\n             assert!(pair[1] == ~\"30\");\n           }\n@@ -1343,18 +1370,18 @@ mod tests {\n           Ok(ref m) => {\n             assert!(m.free[0] == ~\"prog\");\n             assert!(m.free[1] == ~\"free1\");\n-            assert_eq!(opt_str(m, \"s\"), ~\"20\");\n+            assert_eq!(m.opt_str(\"s\").unwrap(), ~\"20\");\n             assert!(m.free[2] == ~\"free2\");\n-            assert!((opt_present(m, \"flag\")));\n-            assert_eq!(opt_str(m, \"long\"), ~\"30\");\n-            assert!((opt_present(m, \"f\")));\n-            let pair = opt_strs(m, \"m\");\n+            assert!((m.opt_present(\"flag\")));\n+            assert_eq!(m.opt_str(\"long\").unwrap(), ~\"30\");\n+            assert!((m.opt_present(\"f\")));\n+            let pair = m.opt_strs(\"m\");\n             assert!(pair[0] == ~\"40\");\n             assert!(pair[1] == ~\"50\");\n-            let pair = opt_strs(m, \"n\");\n+            let pair = m.opt_strs(\"n\");\n             assert!(pair[0] == ~\"-A B\");\n             assert!(pair[1] == ~\"-60 70\");\n-            assert!((!opt_present(m, \"notpresent\")));\n+            assert!((!m.opt_present(\"notpresent\")));\n           }\n           _ => fail!()\n         }\n@@ -1369,34 +1396,34 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(opts_present(matches_single, [~\"e\"]));\n-        assert!(opts_present(matches_single, [~\"encrypt\", ~\"e\"]));\n-        assert!(opts_present(matches_single, [~\"e\", ~\"encrypt\"]));\n-        assert!(!opts_present(matches_single, [~\"encrypt\"]));\n-        assert!(!opts_present(matches_single, [~\"thing\"]));\n-        assert!(!opts_present(matches_single, []));\n+        assert!(matches_single.opts_present([~\"e\"]));\n+        assert!(matches_single.opts_present([~\"encrypt\", ~\"e\"]));\n+        assert!(matches_single.opts_present([~\"e\", ~\"encrypt\"]));\n+        assert!(!matches_single.opts_present([~\"encrypt\"]));\n+        assert!(!matches_single.opts_present([~\"thing\"]));\n+        assert!(!matches_single.opts_present([]));\n \n-        assert_eq!(opts_str(matches_single, [~\"e\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches_single, [~\"e\", ~\"encrypt\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches_single, [~\"encrypt\", ~\"e\"]), ~\"foo\");\n+        assert_eq!(matches_single.opts_str([~\"e\"]).unwrap(), ~\"foo\");\n+        assert_eq!(matches_single.opts_str([~\"e\", ~\"encrypt\"]).unwrap(), ~\"foo\");\n+        assert_eq!(matches_single.opts_str([~\"encrypt\", ~\"e\"]).unwrap(), ~\"foo\");\n \n         let args_both = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let matches_both = &match getopts(args_both, opts) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(opts_present(matches_both, [~\"e\"]));\n-        assert!(opts_present(matches_both, [~\"encrypt\"]));\n-        assert!(opts_present(matches_both, [~\"encrypt\", ~\"e\"]));\n-        assert!(opts_present(matches_both, [~\"e\", ~\"encrypt\"]));\n-        assert!(!opts_present(matches_both, [~\"f\"]));\n-        assert!(!opts_present(matches_both, [~\"thing\"]));\n-        assert!(!opts_present(matches_both, []));\n+        assert!(matches_both.opts_present([~\"e\"]));\n+        assert!(matches_both.opts_present([~\"encrypt\"]));\n+        assert!(matches_both.opts_present([~\"encrypt\", ~\"e\"]));\n+        assert!(matches_both.opts_present([~\"e\", ~\"encrypt\"]));\n+        assert!(!matches_both.opts_present([~\"f\"]));\n+        assert!(!matches_both.opts_present([~\"thing\"]));\n+        assert!(!matches_both.opts_present([]));\n \n-        assert_eq!(opts_str(matches_both, [~\"e\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches_both, [~\"encrypt\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches_both, [~\"e\", ~\"encrypt\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches_both, [~\"encrypt\", ~\"e\"]), ~\"foo\");\n+        assert_eq!(matches_both.opts_str([~\"e\"]).unwrap(), ~\"foo\");\n+        assert_eq!(matches_both.opts_str([~\"encrypt\"]).unwrap(), ~\"foo\");\n+        assert_eq!(matches_both.opts_str([~\"e\", ~\"encrypt\"]).unwrap(), ~\"foo\");\n+        assert_eq!(matches_both.opts_str([~\"encrypt\", ~\"e\"]).unwrap(), ~\"foo\");\n     }\n \n     #[test]\n@@ -1407,10 +1434,10 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(opts_present(matches, [~\"L\"]));\n-        assert_eq!(opts_str(matches, [~\"L\"]), ~\"foo\");\n-        assert!(opts_present(matches, [~\"M\"]));\n-        assert_eq!(opts_str(matches, [~\"M\"]), ~\".\");\n+        assert!(matches.opts_present([~\"L\"]));\n+        assert_eq!(matches.opts_str([~\"L\"]).unwrap(), ~\"foo\");\n+        assert!(matches.opts_present([~\"M\"]));\n+        assert_eq!(matches.opts_str([~\"M\"]).unwrap(), ~\".\");\n \n     }\n \n@@ -1475,7 +1502,7 @@ mod tests {\n         short.aliases = ~[reqopt(\"b\")];\n         let verbose = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n-        assert_eq!(groups::long_to_short(&verbose), short);\n+        assert_eq!(verbose.long_to_short(), short);\n     }\n \n     #[test]\n@@ -1519,8 +1546,8 @@ mod tests {\n         let args = ~[~\"-a\", ~\"--apple\", ~\"-a\"];\n \n         let matches = groups::getopts(args, opts).unwrap();\n-        assert_eq!(3, opt_count(&matches, \"a\"));\n-        assert_eq!(3, opt_count(&matches, \"apple\"));\n+        assert_eq!(3, matches.opt_count(\"a\"));\n+        assert_eq!(3, matches.opt_count(\"apple\"));\n     }\n \n     #[test]"}, {"sha": "cc80da1506aa17b3a16118609dd6ff3f3cbcb37e", "filename": "src/libextra/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=99ec14dbb0c6017106f2378bedd35ac256aa0006", "patch": "@@ -226,11 +226,11 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n     let matches =\n         match groups::getopts(args_, optgroups()) {\n           Ok(m) => m,\n-          Err(f) => return Err(getopts::fail_str(f))\n+          Err(f) => return Err(f.to_err_msg())\n         };\n \n-    if getopts::opt_present(&matches, \"h\") { usage(args[0], \"h\"); }\n-    if getopts::opt_present(&matches, \"help\") { usage(args[0], \"help\"); }\n+    if matches.opt_present(\"h\") { usage(args[0], \"h\"); }\n+    if matches.opt_present(\"help\") { usage(args[0], \"help\"); }\n \n     let filter =\n         if matches.free.len() > 0 {\n@@ -239,25 +239,25 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n             None\n         };\n \n-    let run_ignored = getopts::opt_present(&matches, \"ignored\");\n+    let run_ignored = matches.opt_present(\"ignored\");\n \n-    let logfile = getopts::opt_maybe_str(&matches, \"logfile\");\n+    let logfile = matches.opt_str(\"logfile\");\n     let logfile = logfile.map_move(|s| Path(s));\n \n-    let run_benchmarks = getopts::opt_present(&matches, \"bench\");\n+    let run_benchmarks = matches.opt_present(\"bench\");\n     let run_tests = ! run_benchmarks ||\n-        getopts::opt_present(&matches, \"test\");\n+        matches.opt_present(\"test\");\n \n-    let ratchet_metrics = getopts::opt_maybe_str(&matches, \"ratchet-metrics\");\n+    let ratchet_metrics = matches.opt_str(\"ratchet-metrics\");\n     let ratchet_metrics = ratchet_metrics.map_move(|s| Path(s));\n \n-    let ratchet_noise_percent = getopts::opt_maybe_str(&matches, \"ratchet-noise-percent\");\n+    let ratchet_noise_percent = matches.opt_str(\"ratchet-noise-percent\");\n     let ratchet_noise_percent = ratchet_noise_percent.map_move(|s| from_str::<f64>(s).unwrap());\n \n-    let save_metrics = getopts::opt_maybe_str(&matches, \"save-metrics\");\n+    let save_metrics = matches.opt_str(\"save-metrics\");\n     let save_metrics = save_metrics.map_move(|s| Path(s));\n \n-    let test_shard = getopts::opt_maybe_str(&matches, \"test-shard\");\n+    let test_shard = matches.opt_str(\"test-shard\");\n     let test_shard = opt_shard(test_shard);\n \n     let test_opts = TestOpts {"}, {"sha": "bd0462119bdedb0b06d1a9e80d794b4aeb71cd50", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=99ec14dbb0c6017106f2378bedd35ac256aa0006", "patch": "@@ -30,7 +30,6 @@ use std::io;\n use std::os;\n use std::vec;\n use extra::getopts::groups::{optopt, optmulti, optflag, optflagopt};\n-use extra::getopts::{opt_present};\n use extra::getopts;\n use syntax::ast;\n use syntax::abi;\n@@ -606,15 +605,15 @@ pub fn build_session_options(binary: @str,\n                              matches: &getopts::Matches,\n                              demitter: diagnostic::Emitter)\n                           -> @session::options {\n-    let crate_type = if opt_present(matches, \"lib\") {\n+    let crate_type = if matches.opt_present(\"lib\") {\n         session::lib_crate\n-    } else if opt_present(matches, \"bin\") {\n+    } else if matches.opt_present(\"bin\") {\n         session::bin_crate\n     } else {\n         session::unknown_crate\n     };\n-    let parse_only = opt_present(matches, \"parse-only\");\n-    let no_trans = opt_present(matches, \"no-trans\");\n+    let parse_only = matches.opt_present(\"parse-only\");\n+    let no_trans = matches.opt_present(\"no-trans\");\n \n     let lint_levels = [lint::allow, lint::warn,\n                        lint::deny, lint::forbid];\n@@ -627,8 +626,8 @@ pub fn build_session_options(binary: @str,\n         // to_ascii_move and to_str_move to not do a unnecessary copy.\n         let level_short = level_name.slice_chars(0, 1);\n         let level_short = level_short.to_ascii().to_upper().to_str_ascii();\n-        let flags = vec::append(getopts::opt_strs(matches, level_short),\n-                                getopts::opt_strs(matches, level_name));\n+        let flags = vec::append(matches.opt_strs(level_short),\n+                                matches.opt_strs(level_name));\n         for lint_name in flags.iter() {\n             let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find_equiv(&lint_name) {\n@@ -644,7 +643,7 @@ pub fn build_session_options(binary: @str,\n     }\n \n     let mut debugging_opts = 0u;\n-    let debug_flags = getopts::opt_strs(matches, \"Z\");\n+    let debug_flags = matches.opt_strs(\"Z\");\n     let debug_map = session::debugging_opts_map();\n     for debug_flag in debug_flags.iter() {\n         let mut this_bit = 0u;\n@@ -670,31 +669,31 @@ pub fn build_session_options(binary: @str,\n     let output_type =\n         if parse_only || no_trans {\n             link::output_type_none\n-        } else if opt_present(matches, \"S\") &&\n-                  opt_present(matches, \"emit-llvm\") {\n+        } else if matches.opt_present(\"S\") &&\n+                  matches.opt_present(\"emit-llvm\") {\n             link::output_type_llvm_assembly\n-        } else if opt_present(matches, \"S\") {\n+        } else if matches.opt_present(\"S\") {\n             link::output_type_assembly\n-        } else if opt_present(matches, \"c\") {\n+        } else if matches.opt_present(\"c\") {\n             link::output_type_object\n-        } else if opt_present(matches, \"emit-llvm\") {\n+        } else if matches.opt_present(\"emit-llvm\") {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n-    let sysroot_opt = getopts::opt_maybe_str(matches, \"sysroot\").map_move(|m| @Path(m));\n-    let target = getopts::opt_maybe_str(matches, \"target\").unwrap_or(host_triple());\n-    let target_cpu = getopts::opt_maybe_str(matches, \"target-cpu\").unwrap_or(~\"generic\");\n-    let target_feature = getopts::opt_maybe_str(matches, \"target-feature\").unwrap_or(~\"\");\n-    let save_temps = getopts::opt_present(matches, \"save-temps\");\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map_move(|m| @Path(m));\n+    let target = matches.opt_str(\"target\").unwrap_or(host_triple());\n+    let target_cpu = matches.opt_str(\"target-cpu\").unwrap_or(~\"generic\");\n+    let target_feature = matches.opt_str(\"target-feature\").unwrap_or(~\"\");\n+    let save_temps = matches.opt_present(\"save-temps\");\n     let opt_level = {\n         if (debugging_opts & session::no_opt) != 0 {\n             No\n-        } else if opt_present(matches, \"O\") {\n-            if opt_present(matches, \"opt-level\") {\n+        } else if matches.opt_present(\"O\") {\n+            if matches.opt_present(\"opt-level\") {\n                 early_error(demitter, ~\"-O and --opt-level both provided\");\n             }\n             Default\n-        } else if opt_present(matches, \"opt-level\") {\n-            match getopts::opt_str(matches, \"opt-level\") {\n+        } else if matches.opt_present(\"opt-level\") {\n+            match matches.opt_str(\"opt-level\").unwrap() {\n               ~\"0\" => No,\n               ~\"1\" => Less,\n               ~\"2\" => Default,\n@@ -720,26 +719,25 @@ pub fn build_session_options(binary: @str,\n \n     let statik = debugging_opts & session::statik != 0;\n \n-    let addl_lib_search_paths = getopts::opt_strs(matches, \"L\").map(|s| Path(*s));\n-    let linker = getopts::opt_maybe_str(matches, \"linker\");\n-    let linker_args = getopts::opt_strs(matches, \"link-args\").flat_map( |a| {\n+    let addl_lib_search_paths = matches.opt_strs(\"L\").map(|s| Path(*s));\n+    let linker = matches.opt_str(\"linker\");\n+    let linker_args = matches.opt_strs(\"link-args\").flat_map( |a| {\n         a.split_iter(' ').map(|arg| arg.to_owned()).collect()\n     });\n \n-    let cfg = parse_cfgspecs(getopts::opt_strs(matches, \"cfg\"), demitter);\n-    let test = opt_present(matches, \"test\");\n-    let android_cross_path = getopts::opt_maybe_str(\n-        matches, \"android-cross-path\");\n+    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"), demitter);\n+    let test = matches.opt_present(\"test\");\n+    let android_cross_path = matches.opt_str(\"android-cross-path\");\n \n-    let custom_passes = match getopts::opt_maybe_str(matches, \"passes\") {\n+    let custom_passes = match matches.opt_str(\"passes\") {\n         None => ~[],\n         Some(s) => {\n             s.split_iter(|c: char| c == ' ' || c == ',').map(|s| {\n                 s.trim().to_owned()\n             }).collect()\n         }\n     };\n-    let llvm_args = match getopts::opt_maybe_str(matches, \"llvm-args\") {\n+    let llvm_args = match matches.opt_str(\"llvm-args\") {\n         None => ~[],\n         Some(s) => {\n             s.split_iter(|c: char| c == ' ' || c == ',').map(|s| {\n@@ -1020,7 +1018,6 @@ mod test {\n     use driver::driver::{build_session_options, optgroups};\n \n     use extra::getopts::groups::getopts;\n-    use extra::getopts;\n     use syntax::attr;\n     use syntax::diagnostic;\n \n@@ -1030,7 +1027,7 @@ mod test {\n         let matches =\n             &match getopts([~\"--test\"], optgroups()) {\n               Ok(m) => m,\n-              Err(f) => fail!(\"test_switch_implies_cfg_test: %s\", getopts::fail_str(f))\n+              Err(f) => fail!(\"test_switch_implies_cfg_test: %s\", f.to_err_msg())\n             };\n         let sessopts = build_session_options(\n             @\"rustc\", matches, diagnostic::emit);\n@@ -1047,7 +1044,7 @@ mod test {\n             &match getopts([~\"--test\", ~\"--cfg=test\"], optgroups()) {\n               Ok(m) => m,\n               Err(f) => {\n-                fail!(\"test_switch_implies_cfg_test_unless_cfg_test: %s\", getopts::fail_str(f));\n+                fail!(\"test_switch_implies_cfg_test_unless_cfg_test: %s\", f.to_err_msg());\n               }\n             };\n         let sessopts = build_session_options("}, {"sha": "8c3e198e5d6f495a0c32ab7af4290a3d09eddff7", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=99ec14dbb0c6017106f2378bedd35ac256aa0006", "patch": "@@ -40,7 +40,7 @@ use std::result;\n use std::str;\n use std::task;\n use std::vec;\n-use extra::getopts::{groups, opt_present};\n+use extra::getopts::groups;\n use extra::getopts;\n use syntax::codemap;\n use syntax::diagnostic;\n@@ -204,39 +204,39 @@ pub fn run_compiler(args: &[~str], demitter: diagnostic::Emitter) {\n         &match getopts::groups::getopts(args, optgroups()) {\n           Ok(m) => m,\n           Err(f) => {\n-            early_error(demitter, getopts::fail_str(f));\n+            early_error(demitter, f.to_err_msg());\n           }\n         };\n \n-    if opt_present(matches, \"h\") || opt_present(matches, \"help\") {\n+    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         usage(binary);\n         return;\n     }\n \n     // Display the available lint options if \"-W help\" or only \"-W\" is given.\n-    let lint_flags = vec::append(getopts::opt_strs(matches, \"W\"),\n-                                 getopts::opt_strs(matches, \"warn\"));\n+    let lint_flags = vec::append(matches.opt_strs(\"W\"),\n+                                 matches.opt_strs(\"warn\"));\n \n     let show_lint_options = lint_flags.iter().any(|x| x == &~\"help\") ||\n-        (opt_present(matches, \"W\") && lint_flags.is_empty());\n+        (matches.opt_present(\"W\") && lint_flags.is_empty());\n \n     if show_lint_options {\n         describe_warnings();\n         return;\n     }\n \n-    let r = getopts::opt_strs(matches, \"Z\");\n+    let r = matches.opt_strs(\"Z\");\n     if r.iter().any(|x| x == &~\"help\") {\n         describe_debug_flags();\n         return;\n     }\n \n-    if getopts::opt_maybe_str(matches, \"passes\") == Some(~\"list\") {\n+    if matches.opt_str(\"passes\") == Some(~\"list\") {\n         unsafe { lib::llvm::llvm::LLVMRustPrintPasses(); }\n         return;\n     }\n \n-    if opt_present(matches, \"v\") || opt_present(matches, \"version\") {\n+    if matches.opt_present(\"v\") || matches.opt_present(\"version\") {\n         version(binary);\n         return;\n     }\n@@ -256,10 +256,10 @@ pub fn run_compiler(args: &[~str], demitter: diagnostic::Emitter) {\n \n     let sopts = build_session_options(binary, matches, demitter);\n     let sess = build_session(sopts, demitter);\n-    let odir = getopts::opt_maybe_str(matches, \"out-dir\").map_move(|o| Path(o));\n-    let ofile = getopts::opt_maybe_str(matches, \"o\").map_move(|o| Path(o));\n+    let odir = matches.opt_str(\"out-dir\").map_move(|o| Path(o));\n+    let ofile = matches.opt_str(\"o\").map_move(|o| Path(o));\n     let cfg = build_configuration(sess);\n-    let pretty = do getopts::opt_default(matches, \"pretty\", \"normal\").map_move |a| {\n+    let pretty = do matches.opt_default(\"pretty\", \"normal\").map_move |a| {\n         parse_pretty(sess, a)\n     };\n     match pretty {\n@@ -269,7 +269,7 @@ pub fn run_compiler(args: &[~str], demitter: diagnostic::Emitter) {\n       }\n       None::<PpMode> => {/* continue */ }\n     }\n-    let ls = opt_present(matches, \"ls\");\n+    let ls = matches.opt_present(\"ls\");\n     if ls {\n         match input {\n           file_input(ref ifile) => {"}, {"sha": "71ece1788078266a67ef2e3137f79f87a38b80c3", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=99ec14dbb0c6017106f2378bedd35ac256aa0006", "patch": "@@ -125,7 +125,7 @@ pub fn parse_config_(\n             }\n         }\n         Err(f) => {\n-            Err(getopts::fail_str(f))\n+            Err(f.to_err_msg())\n         }\n     }\n }\n@@ -139,15 +139,15 @@ fn config_from_opts(\n     let config = default_config(input_crate);\n     let result = result::Ok(config);\n     let result = do result.and_then |config| {\n-        let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n+        let output_dir = matches.opt_str(opt_output_dir());\n         let output_dir = output_dir.map_move(|s| Path(s));\n         result::Ok(Config {\n             output_dir: output_dir.unwrap_or(config.output_dir.clone()),\n             .. config\n         })\n     };\n     let result = do result.and_then |config| {\n-        let output_format = getopts::opt_maybe_str(matches, opt_output_format());\n+        let output_format = matches.opt_str(opt_output_format());\n         do output_format.map_move_default(result::Ok(config.clone())) |output_format| {\n             do parse_output_format(output_format).and_then |output_format| {\n                 result::Ok(Config {\n@@ -159,7 +159,7 @@ fn config_from_opts(\n     };\n     let result = do result.and_then |config| {\n         let output_style =\n-            getopts::opt_maybe_str(matches, opt_output_style());\n+            matches.opt_str(opt_output_style());\n         do output_style.map_move_default(result::Ok(config.clone())) |output_style| {\n             do parse_output_style(output_style).and_then |output_style| {\n                 result::Ok(Config {\n@@ -171,7 +171,7 @@ fn config_from_opts(\n     };\n     let process_output = Cell::new(process_output);\n     let result = do result.and_then |config| {\n-        let pandoc_cmd = getopts::opt_maybe_str(matches, opt_pandoc_cmd());\n+        let pandoc_cmd = matches.opt_str(opt_pandoc_cmd());\n         let pandoc_cmd = maybe_find_pandoc(\n             &config, pandoc_cmd, process_output.take());\n         do pandoc_cmd.and_then |pandoc_cmd| {"}, {"sha": "0187a8d189c3fd0aa64a19a4f85c097c18faccb2", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=99ec14dbb0c6017106f2378bedd35ac256aa0006", "patch": "@@ -641,53 +641,53 @@ pub fn main_args(args: &[~str]) {\n     let matches = &match getopts::getopts(args, opts) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n-            error(fmt!(\"%s\", getopts::fail_str(f)));\n+            error(fmt!(\"%s\", f.to_err_msg()));\n \n             return;\n         }\n     };\n-    let mut help = getopts::opt_present(matches, \"h\") ||\n-                   getopts::opt_present(matches, \"help\");\n-    let no_link = getopts::opt_present(matches, \"no-link\");\n-    let no_trans = getopts::opt_present(matches, \"no-trans\");\n-    let supplied_sysroot = getopts::opt_val(matches, \"sysroot\");\n-    let generate_asm = getopts::opt_present(matches, \"S\") ||\n-        getopts::opt_present(matches, \"assembly\");\n-    let parse_only = getopts::opt_present(matches, \"parse-only\");\n-    let pretty = getopts::opt_present(matches, \"pretty\");\n-    let emit_llvm = getopts::opt_present(matches, \"emit-llvm\");\n-\n-    if getopts::opt_present(matches, \"v\") ||\n-       getopts::opt_present(matches, \"version\") {\n+    let mut help = matches.opt_present(\"h\") ||\n+                   matches.opt_present(\"help\");\n+    let no_link = matches.opt_present(\"no-link\");\n+    let no_trans = matches.opt_present(\"no-trans\");\n+    let supplied_sysroot = matches.opt_val(\"sysroot\");\n+    let generate_asm = matches.opt_present(\"S\") ||\n+        matches.opt_present(\"assembly\");\n+    let parse_only = matches.opt_present(\"parse-only\");\n+    let pretty = matches.opt_present(\"pretty\");\n+    let emit_llvm = matches.opt_present(\"emit-llvm\");\n+\n+    if matches.opt_present(\"v\") ||\n+       matches.opt_present(\"version\") {\n         rustc::version(args[0]);\n         return;\n     }\n \n-    let use_rust_path_hack = getopts::opt_present(matches, \"r\") ||\n-                             getopts::opt_present(matches, \"rust-path-hack\");\n+    let use_rust_path_hack = matches.opt_present(\"r\") ||\n+                             matches.opt_present(\"rust-path-hack\");\n \n-    let linker = getopts::opt_maybe_str(matches, \"linker\");\n-    let link_args = getopts::opt_maybe_str(matches, \"link-args\");\n-    let cfgs = getopts::opt_strs(matches, \"cfg\") + getopts::opt_strs(matches, \"c\");\n+    let linker = matches.opt_str(\"linker\");\n+    let link_args = matches.opt_str(\"link-args\");\n+    let cfgs = matches.opt_strs(\"cfg\") + matches.opt_strs(\"c\");\n     let mut user_supplied_opt_level = true;\n-    let opt_level = match getopts::opt_maybe_str(matches, \"opt-level\") {\n+    let opt_level = match matches.opt_str(\"opt-level\") {\n         Some(~\"0\") => session::No,\n         Some(~\"1\") => session::Less,\n         Some(~\"2\") => session::Default,\n         Some(~\"3\") => session::Aggressive,\n-        _ if getopts::opt_present(matches, \"O\") => session::Default,\n+        _ if matches.opt_present(\"O\") => session::Default,\n         _ => {\n             user_supplied_opt_level = false;\n             session::No\n         }\n     };\n \n-    let save_temps = getopts::opt_present(matches, \"save-temps\");\n-    let target     = getopts::opt_maybe_str(matches, \"target\");\n-    let target_cpu = getopts::opt_maybe_str(matches, \"target-cpu\");\n+    let save_temps = matches.opt_present(\"save-temps\");\n+    let target     = matches.opt_str(\"target\");\n+    let target_cpu = matches.opt_str(\"target-cpu\");\n     let experimental_features = {\n-        let strs = getopts::opt_strs(matches, \"Z\");\n-        if getopts::opt_present(matches, \"Z\") {\n+        let strs = matches.opt_strs(\"Z\");\n+        if matches.opt_present(\"Z\") {\n             Some(strs)\n         }\n         else {"}, {"sha": "a4e3bc50d110243b6d02a8fd5f2b6ead316c5f82", "filename": "src/rustdoc_ng/rustdoc_ng.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Frustdoc_ng%2Frustdoc_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Frustdoc_ng%2Frustdoc_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Frustdoc_ng.rs?ref=99ec14dbb0c6017106f2378bedd35ac256aa0006", "patch": "@@ -41,7 +41,6 @@ pub fn main() {\n }\n \n pub fn main_args(args: &[~str]) {\n-    use extra::getopts::*;\n     use extra::getopts::groups::*;\n \n     let opts = ~[\n@@ -56,20 +55,20 @@ pub fn main_args(args: &[~str]) {\n \n     let matches = getopts(args.tail(), opts).unwrap();\n \n-    if opt_present(&matches, \"h\") || opt_present(&matches, \"help\") {\n+    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         println(usage(args[0], opts));\n         return;\n     }\n \n-    let libs = Cell::new(opt_strs(&matches, \"L\").map(|s| Path(*s)));\n+    let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path(*s)));\n \n-    let mut passes = if opt_present(&matches, \"n\") {\n+    let mut passes = if matches.opt_present(\"n\") {\n         ~[]\n     } else {\n         ~[~\"collapse-docs\", ~\"clean-comments\", ~\"collapse-privacy\" ]\n     };\n \n-    opt_strs(&matches, \"a\").map(|x| passes.push(x.clone()));\n+    matches.opt_strs(\"a\").map(|x| passes.push(x.clone()));\n \n     if matches.free.len() != 1 {\n         println(usage(args[0], opts));\n@@ -99,7 +98,7 @@ pub fn main_args(args: &[~str]) {\n         })\n     }\n \n-    for pname in opt_strs(&matches, \"p\").move_iter() {\n+    for pname in matches.opt_strs(\"p\").move_iter() {\n         pm.load_plugin(pname);\n     }\n "}, {"sha": "0896682b32225b5df486d0b92cae6c197458dc77", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=99ec14dbb0c6017106f2378bedd35ac256aa0006", "patch": "@@ -64,7 +64,7 @@ fn parse_opts(argv: ~[~str]) -> Config {\n \n     match getopts::getopts(opt_args, opts) {\n       Ok(ref m) => {\n-          return Config {stress: getopts::opt_present(m, \"stress\")}\n+          return Config {stress: m.opt_present(\"stress\")}\n       }\n       Err(_) => { fail!(); }\n     }"}, {"sha": "d1964b5d94b82db4f08a3dbc25c65bae5585916b", "filename": "src/test/run-pass/getopts_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ec14dbb0c6017106f2378bedd35ac256aa0006/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs?ref=99ec14dbb0c6017106f2378bedd35ac256aa0006", "patch": "@@ -20,8 +20,8 @@ pub fn main() {\n \n     match getopts(args, opts) {\n         Ok(ref m)  =>\n-            assert!(!opt_present(m, \"b\")),\n-        Err(ref f) => fail!(fail_str((*f).clone()))\n+            assert!(!m.opt_present(\"b\")),\n+        Err(ref f) => fail!((*f).clone().to_err_msg())\n     };\n \n }"}]}