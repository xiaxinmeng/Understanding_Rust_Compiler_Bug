{"sha": "766b10a8d544550712fd6352863457a86f46db3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NmIxMGE4ZDU0NDU1MDcxMmZkNjM1Mjg2MzQ1N2E4NmY0NmRiM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-06T04:43:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-06T04:43:03Z"}, "message": "Auto merge of #62987 - Thomasdezeeuw:ioslice-advance, r=Thomasdezeeuw\n\nAdd {IoSlice, IoSliceMut}::advance\n\nAPI inspired by the [`Buf::advance`](https://docs.rs/bytes/0.4.12/bytes/trait.Buf.html#tymethod.advance) method found in the [bytes](https://docs.rs/bytes) crate.\n\nCloses #62726.", "tree": {"sha": "7d18a9a0c8a0eb875742a65518c9dfdfab56cd82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d18a9a0c8a0eb875742a65518c9dfdfab56cd82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/766b10a8d544550712fd6352863457a86f46db3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/766b10a8d544550712fd6352863457a86f46db3c", "html_url": "https://github.com/rust-lang/rust/commit/766b10a8d544550712fd6352863457a86f46db3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/766b10a8d544550712fd6352863457a86f46db3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4715198b50d1cdaad44b6e250844362b77dcdd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4715198b50d1cdaad44b6e250844362b77dcdd7", "html_url": "https://github.com/rust-lang/rust/commit/c4715198b50d1cdaad44b6e250844362b77dcdd7"}, {"sha": "dad56c39474377c7d47e261b380d0be3aed104cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/dad56c39474377c7d47e261b380d0be3aed104cc", "html_url": "https://github.com/rust-lang/rust/commit/dad56c39474377c7d47e261b380d0be3aed104cc"}], "stats": {"total": 352, "additions": 351, "deletions": 1}, "files": [{"sha": "f2b6ce6feb295e3bf20b7fa984bcec6b7b2d8cf4", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 199, "deletions": 1, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -942,6 +942,62 @@ impl<'a> IoSliceMut<'a> {\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n         IoSliceMut(sys::io::IoSliceMut::new(buf))\n     }\n+\n+    /// Advance the internal cursor of the slice.\n+    ///\n+    /// # Notes\n+    ///\n+    /// Elements in the slice may be modified if the cursor is not advanced to\n+    /// the end of the slice. For example if we have a slice of buffers with 2\n+    /// `IoSliceMut`s, both of length 8, and we advance the cursor by 10 bytes\n+    /// the first `IoSliceMut` will be untouched however the second will be\n+    /// modified to remove the first 2 bytes (10 - 8).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(io_slice_advance)]\n+    ///\n+    /// use std::io::IoSliceMut;\n+    /// use std::mem;\n+    /// use std::ops::Deref;\n+    ///\n+    /// let mut buf1 = [1; 8];\n+    /// let mut buf2 = [2; 16];\n+    /// let mut buf3 = [3; 8];\n+    /// let mut bufs = &mut [\n+    ///     IoSliceMut::new(&mut buf1),\n+    ///     IoSliceMut::new(&mut buf2),\n+    ///     IoSliceMut::new(&mut buf3),\n+    /// ][..];\n+    ///\n+    /// // Mark 10 bytes as read.\n+    /// bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 10);\n+    /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n+    /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n+    /// ```\n+    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n+    #[inline]\n+    pub fn advance<'b>(bufs: &'b mut [IoSliceMut<'a>], n: usize) -> &'b mut [IoSliceMut<'a>] {\n+        // Number of buffers to remove.\n+        let mut remove = 0;\n+        // Total length of all the to be removed buffers.\n+        let mut accumulated_len = 0;\n+        for buf in bufs.iter() {\n+            if accumulated_len + buf.len() > n {\n+                break;\n+            } else {\n+                accumulated_len += buf.len();\n+                remove += 1;\n+            }\n+        }\n+\n+        let bufs = &mut bufs[remove..];\n+        if !bufs.is_empty() {\n+            bufs[0].0.advance(n - accumulated_len)\n+        }\n+        bufs\n+    }\n }\n \n #[stable(feature = \"iovec\", since = \"1.36.0\")]\n@@ -989,6 +1045,61 @@ impl<'a> IoSlice<'a> {\n     pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n         IoSlice(sys::io::IoSlice::new(buf))\n     }\n+\n+    /// Advance the internal cursor of the slice.\n+    ///\n+    /// # Notes\n+    ///\n+    /// Elements in the slice may be modified if the cursor is not advanced to\n+    /// the end of the slice. For example if we have a slice of buffers with 2\n+    /// `IoSlice`s, both of length 8, and we advance the cursor by 10 bytes the\n+    /// first `IoSlice` will be untouched however the second will be modified to\n+    /// remove the first 2 bytes (10 - 8).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(io_slice_advance)]\n+    ///\n+    /// use std::io::IoSlice;\n+    /// use std::mem;\n+    /// use std::ops::Deref;\n+    ///\n+    /// let mut buf1 = [1; 8];\n+    /// let mut buf2 = [2; 16];\n+    /// let mut buf3 = [3; 8];\n+    /// let mut bufs = &mut [\n+    ///     IoSlice::new(&mut buf1),\n+    ///     IoSlice::new(&mut buf2),\n+    ///     IoSlice::new(&mut buf3),\n+    /// ][..];\n+    ///\n+    /// // Mark 10 bytes as written.\n+    /// bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 10);\n+    /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n+    /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n+    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n+    #[inline]\n+    pub fn advance<'b>(bufs: &'b mut [IoSlice<'a>], n: usize) -> &'b mut [IoSlice<'a>] {\n+        // Number of buffers to remove.\n+        let mut remove = 0;\n+        // Total length of all the to be removed buffers.\n+        let mut accumulated_len = 0;\n+        for buf in bufs.iter() {\n+            if accumulated_len + buf.len() > n {\n+                break;\n+            } else {\n+                accumulated_len += buf.len();\n+                remove += 1;\n+            }\n+        }\n+\n+        let bufs = &mut bufs[remove..];\n+        if !bufs.is_empty() {\n+            bufs[0].0.advance(n - accumulated_len)\n+        }\n+        bufs\n+    }\n }\n \n #[stable(feature = \"iovec\", since = \"1.36.0\")]\n@@ -2268,8 +2379,10 @@ impl<B: BufRead> Iterator for Lines<B> {\n #[cfg(test)]\n mod tests {\n     use crate::io::prelude::*;\n-    use crate::io;\n     use super::{Cursor, SeekFrom, repeat};\n+    use crate::io::{self, IoSlice, IoSliceMut};\n+    use crate::mem;\n+    use crate::ops::Deref;\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n@@ -2537,4 +2650,89 @@ mod tests {\n \n         Ok(())\n     }\n+\n+    #[test]\n+    fn io_slice_mut_advance() {\n+        let mut buf1 = [1; 8];\n+        let mut buf2 = [2; 16];\n+        let mut buf3 = [3; 8];\n+        let mut bufs = &mut [\n+            IoSliceMut::new(&mut buf1),\n+            IoSliceMut::new(&mut buf2),\n+            IoSliceMut::new(&mut buf3),\n+        ][..];\n+\n+        // Only in a single buffer..\n+        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 1);\n+        assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n+        assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n+        assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n+\n+        // Removing a buffer, leaving others as is.\n+        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 7);\n+        assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n+        assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n+\n+        // Removing a buffer and removing from the next buffer.\n+        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 18);\n+        assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n+    }\n+\n+    #[test]\n+    fn io_slice_mut_advance_empty_slice() {\n+        let mut empty_bufs = &mut [][..];\n+        // Shouldn't panic.\n+        IoSliceMut::advance(&mut empty_bufs, 1);\n+    }\n+\n+    #[test]\n+    fn io_slice_mut_advance_beyond_total_length() {\n+        let mut buf1 = [1; 8];\n+        let mut bufs = &mut [IoSliceMut::new(&mut buf1)][..];\n+\n+        // Going beyond the total length should be ok.\n+        bufs = IoSliceMut::advance(mem::replace(&mut bufs, &mut []), 9);\n+        assert!(bufs.is_empty());\n+    }\n+\n+    #[test]\n+    fn io_slice_advance() {\n+        let mut buf1 = [1; 8];\n+        let mut buf2 = [2; 16];\n+        let mut buf3 = [3; 8];\n+        let mut bufs =\n+            &mut [IoSlice::new(&mut buf1), IoSlice::new(&mut buf2), IoSlice::new(&mut buf3)][..];\n+\n+        // Only in a single buffer..\n+        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 1);\n+        assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n+        assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n+        assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n+\n+        // Removing a buffer, leaving others as is.\n+        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 7);\n+        assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n+        assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n+\n+        // Removing a buffer and removing from the next buffer.\n+        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 18);\n+        assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n+    }\n+\n+    #[test]\n+    fn io_slice_advance_empty_slice() {\n+        let mut empty_bufs = &mut [][..];\n+        // Shouldn't panic.\n+        IoSlice::advance(&mut empty_bufs, 1);\n+    }\n+\n+    #[test]\n+    fn io_slice_advance_beyond_total_length() {\n+        let mut buf1 = [1; 8];\n+        let mut bufs = &mut [IoSlice::new(&mut buf1)][..];\n+\n+        // Going beyond the total length should be ok.\n+        bufs = IoSlice::advance(mem::replace(&mut bufs, &mut []), 9);\n+        assert!(bufs.is_empty());\n+    }\n }"}, {"sha": "976e122463d1b80ea9f60350ffb8dad875e9b741", "filename": "src/libstd/sys/cloudabi/io.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fcloudabi%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fcloudabi%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fio.rs?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -1,3 +1,5 @@\n+use crate::mem;\n+\n pub struct IoSlice<'a>(&'a [u8]);\n \n impl<'a> IoSlice<'a> {\n@@ -6,6 +8,11 @@ impl<'a> IoSlice<'a> {\n         IoSlice(buf)\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        self.0 = &self.0[n..]\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         self.0\n@@ -20,6 +27,13 @@ impl<'a> IoSliceMut<'a> {\n         IoSliceMut(buf)\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        let slice = mem::replace(&mut self.0, &mut []);\n+        let (_, remaining) = slice.split_at_mut(n);\n+        self.0 = remaining;\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         self.0"}, {"sha": "976e122463d1b80ea9f60350ffb8dad875e9b741", "filename": "src/libstd/sys/redox/io.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fredox%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fredox%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fio.rs?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -1,3 +1,5 @@\n+use crate::mem;\n+\n pub struct IoSlice<'a>(&'a [u8]);\n \n impl<'a> IoSlice<'a> {\n@@ -6,6 +8,11 @@ impl<'a> IoSlice<'a> {\n         IoSlice(buf)\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        self.0 = &self.0[n..]\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         self.0\n@@ -20,6 +27,13 @@ impl<'a> IoSliceMut<'a> {\n         IoSliceMut(buf)\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        let slice = mem::replace(&mut self.0, &mut []);\n+        let (_, remaining) = slice.split_at_mut(n);\n+        self.0 = remaining;\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         self.0"}, {"sha": "976e122463d1b80ea9f60350ffb8dad875e9b741", "filename": "src/libstd/sys/sgx/io.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fsgx%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fsgx%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fio.rs?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -1,3 +1,5 @@\n+use crate::mem;\n+\n pub struct IoSlice<'a>(&'a [u8]);\n \n impl<'a> IoSlice<'a> {\n@@ -6,6 +8,11 @@ impl<'a> IoSlice<'a> {\n         IoSlice(buf)\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        self.0 = &self.0[n..]\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         self.0\n@@ -20,6 +27,13 @@ impl<'a> IoSliceMut<'a> {\n         IoSliceMut(buf)\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        let slice = mem::replace(&mut self.0, &mut []);\n+        let (_, remaining) = slice.split_at_mut(n);\n+        self.0 = remaining;\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         self.0"}, {"sha": "a3a7291917697b0d83f1b1a07aa22c8e6f64262f", "filename": "src/libstd/sys/unix/io.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fio.rs?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -21,6 +21,18 @@ impl<'a> IoSlice<'a> {\n         }\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        if self.vec.iov_len < n {\n+            panic!(\"advancing IoSlice beyond its length\");\n+        }\n+\n+        unsafe {\n+            self.vec.iov_len -= n;\n+            self.vec.iov_base = self.vec.iov_base.add(n);\n+        }\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         unsafe {\n@@ -47,6 +59,18 @@ impl<'a> IoSliceMut<'a> {\n         }\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        if self.vec.iov_len < n {\n+            panic!(\"advancing IoSliceMut beyond its length\");\n+        }\n+\n+        unsafe {\n+            self.vec.iov_len -= n;\n+            self.vec.iov_base = self.vec.iov_base.add(n);\n+        }\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         unsafe {"}, {"sha": "8cd11cbf5df4ed3763ce1370b814b731890b949b", "filename": "src/libstd/sys/vxworks/io.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -21,6 +21,18 @@ impl<'a> IoSlice<'a> {\n         }\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        if self.vec.iov_len < n {\n+            panic!(\"advancing IoSlice beyond its length\");\n+        }\n+\n+        unsafe {\n+            self.vec.iov_len -= n;\n+            self.vec.iov_base = self.vec.iov_base.add(n);\n+        }\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         unsafe {\n@@ -46,6 +58,18 @@ impl<'a> IoSliceMut<'a> {\n         }\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        if self.vec.iov_len < n {\n+            panic!(\"advancing IoSliceMut beyond its length\");\n+        }\n+\n+        unsafe {\n+            self.vec.iov_len -= n;\n+            self.vec.iov_base = self.vec.iov_base.add(n);\n+        }\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         unsafe {"}, {"sha": "ffecca5d1b6fff07635edb3434a836c309820891", "filename": "src/libstd/sys/wasi/io.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -21,6 +21,18 @@ impl<'a> IoSlice<'a> {\n         }\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        if self.vec.buf_len < n {\n+            panic!(\"advancing IoSlice beyond its length\");\n+        }\n+\n+        unsafe {\n+            self.vec.buf_len -= n;\n+            self.vec.buf = self.vec.buf.add(n);\n+        }\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         unsafe {\n@@ -47,6 +59,18 @@ impl<'a> IoSliceMut<'a> {\n         }\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        if self.vec.buf_len < n {\n+            panic!(\"advancing IoSlice beyond its length\");\n+        }\n+\n+        unsafe {\n+            self.vec.buf_len -= n;\n+            self.vec.buf = self.vec.buf.add(n);\n+        }\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         unsafe {"}, {"sha": "976e122463d1b80ea9f60350ffb8dad875e9b741", "filename": "src/libstd/sys/wasm/io.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fwasm%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fwasm%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fio.rs?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -1,3 +1,5 @@\n+use crate::mem;\n+\n pub struct IoSlice<'a>(&'a [u8]);\n \n impl<'a> IoSlice<'a> {\n@@ -6,6 +8,11 @@ impl<'a> IoSlice<'a> {\n         IoSlice(buf)\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        self.0 = &self.0[n..]\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         self.0\n@@ -20,6 +27,13 @@ impl<'a> IoSliceMut<'a> {\n         IoSliceMut(buf)\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        let slice = mem::replace(&mut self.0, &mut []);\n+        let (_, remaining) = slice.split_at_mut(n);\n+        self.0 = remaining;\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         self.0"}, {"sha": "e44dcbe164daf2d041902dda729e1ef2932b78f3", "filename": "src/libstd/sys/windows/io.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -21,6 +21,18 @@ impl<'a> IoSlice<'a> {\n         }\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        if (self.vec.len as usize) < n {\n+            panic!(\"advancing IoSlice beyond its length\");\n+        }\n+\n+        unsafe {\n+            self.vec.len -= n as c::ULONG;\n+            self.vec.buf = self.vec.buf.add(n);\n+        }\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         unsafe {\n@@ -48,6 +60,18 @@ impl<'a> IoSliceMut<'a> {\n         }\n     }\n \n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        if (self.vec.len as usize) < n {\n+            panic!(\"advancing IoSliceMut beyond its length\");\n+        }\n+\n+        unsafe {\n+            self.vec.len -= n as c::ULONG;\n+            self.vec.buf = self.vec.buf.add(n);\n+        }\n+    }\n+\n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n         unsafe {"}]}