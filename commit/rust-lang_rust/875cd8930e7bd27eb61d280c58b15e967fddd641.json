{"sha": "875cd8930e7bd27eb61d280c58b15e967fddd641", "node_id": "C_kwDOAAsO6NoAKDg3NWNkODkzMGU3YmQyN2ViNjFkMjgwYzU4YjE1ZTk2N2ZkZGQ2NDE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-04-24T22:05:06Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-04-24T22:05:06Z"}, "message": "remove indentation in report_method_error", "tree": {"sha": "9b5e4b0b1e393476221a33a2508b37972e0ad5f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b5e4b0b1e393476221a33a2508b37972e0ad5f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/875cd8930e7bd27eb61d280c58b15e967fddd641", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/875cd8930e7bd27eb61d280c58b15e967fddd641", "html_url": "https://github.com/rust-lang/rust/commit/875cd8930e7bd27eb61d280c58b15e967fddd641", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/875cd8930e7bd27eb61d280c58b15e967fddd641/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f314e7027fe7084aaab8620c624a0d7bd29e70", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f314e7027fe7084aaab8620c624a0d7bd29e70", "html_url": "https://github.com/rust-lang/rust/commit/18f314e7027fe7084aaab8620c624a0d7bd29e70"}], "stats": {"total": 342, "additions": 162, "deletions": 180}, "files": [{"sha": "f45859cc50962fa54c167def592809ab610be5a2", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 162, "deletions": 180, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/875cd8930e7bd27eb61d280c58b15e967fddd641/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875cd8930e7bd27eb61d280c58b15e967fddd641/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=875cd8930e7bd27eb61d280c58b15e967fddd641", "patch": "@@ -271,205 +271,187 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         (None, true) => \"variant\",\n                     }\n                 };\n-                // FIXME(eddyb) this indentation is probably unnecessary.\n-                let mut err = {\n-                    // Suggest clamping down the type if the method that is being attempted to\n-                    // be used exists at all, and the type is an ambiguous numeric type\n-                    // ({integer}/{float}).\n-                    let mut candidates = all_traits(self.tcx)\n-                        .into_iter()\n-                        .filter_map(|info| self.associated_value(info.def_id, item_name));\n-                    // There are methods that are defined on the primitive types and won't be\n-                    // found when exploring `all_traits`, but we also need them to be accurate on\n-                    // our suggestions (#47759).\n-                    let found_assoc = |ty: Ty<'tcx>| {\n-                        simplify_type(tcx, ty, TreatParams::AsPlaceholders)\n-                            .and_then(|simp| {\n-                                tcx.incoherent_impls(simp)\n-                                    .iter()\n-                                    .find_map(|&id| self.associated_value(id, item_name))\n-                            })\n-                            .is_some()\n-                    };\n-                    let found_candidate = candidates.next().is_some()\n-                        || found_assoc(tcx.types.i8)\n-                        || found_assoc(tcx.types.i16)\n-                        || found_assoc(tcx.types.i32)\n-                        || found_assoc(tcx.types.i64)\n-                        || found_assoc(tcx.types.i128)\n-                        || found_assoc(tcx.types.u8)\n-                        || found_assoc(tcx.types.u16)\n-                        || found_assoc(tcx.types.u32)\n-                        || found_assoc(tcx.types.u64)\n-                        || found_assoc(tcx.types.u128)\n-                        || found_assoc(tcx.types.f32)\n-                        || found_assoc(tcx.types.f32);\n-                    if let (true, false, SelfSource::MethodCall(expr), true) = (\n-                        actual.is_numeric(),\n-                        actual.has_concrete_skeleton(),\n-                        source,\n-                        found_candidate,\n-                    ) {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            span,\n-                            E0689,\n-                            \"can't call {} `{}` on ambiguous numeric type `{}`\",\n-                            item_kind,\n-                            item_name,\n-                            ty_str\n-                        );\n-                        let concrete_type = if actual.is_integral() { \"i32\" } else { \"f32\" };\n-                        match expr.kind {\n-                            ExprKind::Lit(ref lit) => {\n-                                // numeric literal\n-                                let snippet = tcx\n-                                    .sess\n-                                    .source_map()\n-                                    .span_to_snippet(lit.span)\n-                                    .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n-\n-                                // If this is a floating point literal that ends with '.',\n-                                // get rid of it to stop this from becoming a member access.\n-                                let snippet = snippet.strip_suffix('.').unwrap_or(&snippet);\n-\n-                                err.span_suggestion(\n-                                    lit.span,\n-                                    &format!(\n-                                        \"you must specify a concrete type for this numeric value, \\\n+                // Suggest clamping down the type if the method that is being attempted to\n+                // be used exists at all, and the type is an ambiguous numeric type\n+                // ({integer}/{float}).\n+                let mut candidates = all_traits(self.tcx)\n+                    .into_iter()\n+                    .filter_map(|info| self.associated_value(info.def_id, item_name));\n+                // There are methods that are defined on the primitive types and won't be\n+                // found when exploring `all_traits`, but we also need them to be accurate on\n+                // our suggestions (#47759).\n+                let found_assoc = |ty: Ty<'tcx>| {\n+                    simplify_type(tcx, ty, TreatParams::AsPlaceholders)\n+                        .and_then(|simp| {\n+                            tcx.incoherent_impls(simp)\n+                                .iter()\n+                                .find_map(|&id| self.associated_value(id, item_name))\n+                        })\n+                        .is_some()\n+                };\n+                let found_candidate = candidates.next().is_some()\n+                    || found_assoc(tcx.types.i8)\n+                    || found_assoc(tcx.types.i16)\n+                    || found_assoc(tcx.types.i32)\n+                    || found_assoc(tcx.types.i64)\n+                    || found_assoc(tcx.types.i128)\n+                    || found_assoc(tcx.types.u8)\n+                    || found_assoc(tcx.types.u16)\n+                    || found_assoc(tcx.types.u32)\n+                    || found_assoc(tcx.types.u64)\n+                    || found_assoc(tcx.types.u128)\n+                    || found_assoc(tcx.types.f32)\n+                    || found_assoc(tcx.types.f32);\n+                if let (true, false, SelfSource::MethodCall(expr), true) =\n+                    (actual.is_numeric(), actual.has_concrete_skeleton(), source, found_candidate)\n+                {\n+                    let mut err = struct_span_err!(\n+                        tcx.sess,\n+                        span,\n+                        E0689,\n+                        \"can't call {} `{}` on ambiguous numeric type `{}`\",\n+                        item_kind,\n+                        item_name,\n+                        ty_str\n+                    );\n+                    let concrete_type = if actual.is_integral() { \"i32\" } else { \"f32\" };\n+                    match expr.kind {\n+                        ExprKind::Lit(ref lit) => {\n+                            // numeric literal\n+                            let snippet = tcx\n+                                .sess\n+                                .source_map()\n+                                .span_to_snippet(lit.span)\n+                                .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n+\n+                            // If this is a floating point literal that ends with '.',\n+                            // get rid of it to stop this from becoming a member access.\n+                            let snippet = snippet.strip_suffix('.').unwrap_or(&snippet);\n+\n+                            err.span_suggestion(\n+                                lit.span,\n+                                &format!(\n+                                    \"you must specify a concrete type for this numeric value, \\\n                                          like `{}`\",\n-                                        concrete_type\n-                                    ),\n-                                    format!(\"{snippet}_{concrete_type}\"),\n-                                    Applicability::MaybeIncorrect,\n+                                    concrete_type\n+                                ),\n+                                format!(\"{snippet}_{concrete_type}\"),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                        ExprKind::Path(QPath::Resolved(_, path)) => {\n+                            // local binding\n+                            if let hir::def::Res::Local(hir_id) = path.res {\n+                                let span = tcx.hir().span(hir_id);\n+                                let snippet = tcx.sess.source_map().span_to_snippet(span);\n+                                let filename = tcx.sess.source_map().span_to_filename(span);\n+\n+                                let parent_node =\n+                                    self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id));\n+                                let msg = format!(\n+                                    \"you must specify a type for this binding, like `{}`\",\n+                                    concrete_type,\n                                 );\n-                            }\n-                            ExprKind::Path(QPath::Resolved(_, path)) => {\n-                                // local binding\n-                                if let hir::def::Res::Local(hir_id) = path.res {\n-                                    let span = tcx.hir().span(hir_id);\n-                                    let snippet = tcx.sess.source_map().span_to_snippet(span);\n-                                    let filename = tcx.sess.source_map().span_to_filename(span);\n-\n-                                    let parent_node =\n-                                        self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id));\n-                                    let msg = format!(\n-                                        \"you must specify a type for this binding, like `{}`\",\n-                                        concrete_type,\n-                                    );\n \n-                                    match (filename, parent_node, snippet) {\n-                                        (\n-                                            FileName::Real(_),\n-                                            Node::Local(hir::Local {\n-                                                source: hir::LocalSource::Normal,\n-                                                ty,\n-                                                ..\n-                                            }),\n-                                            Ok(ref snippet),\n-                                        ) => {\n-                                            err.span_suggestion(\n-                                                // account for `let x: _ = 42;`\n-                                                //                  ^^^^\n-                                                span.to(ty\n-                                                    .as_ref()\n-                                                    .map(|ty| ty.span)\n-                                                    .unwrap_or(span)),\n-                                                &msg,\n-                                                format!(\"{}: {}\", snippet, concrete_type),\n-                                                Applicability::MaybeIncorrect,\n-                                            );\n-                                        }\n-                                        _ => {\n-                                            err.span_label(span, msg);\n-                                        }\n+                                match (filename, parent_node, snippet) {\n+                                    (\n+                                        FileName::Real(_),\n+                                        Node::Local(hir::Local {\n+                                            source: hir::LocalSource::Normal,\n+                                            ty,\n+                                            ..\n+                                        }),\n+                                        Ok(ref snippet),\n+                                    ) => {\n+                                        err.span_suggestion(\n+                                            // account for `let x: _ = 42;`\n+                                            //                  ^^^^\n+                                            span.to(ty.as_ref().map(|ty| ty.span).unwrap_or(span)),\n+                                            &msg,\n+                                            format!(\"{}: {}\", snippet, concrete_type),\n+                                            Applicability::MaybeIncorrect,\n+                                        );\n+                                    }\n+                                    _ => {\n+                                        err.span_label(span, msg);\n                                     }\n                                 }\n                             }\n-                            _ => {}\n                         }\n-                        err.emit();\n-                        return None;\n-                    } else {\n-                        span = item_name.span;\n-\n-                        // Don't show generic arguments when the method can't be found in any implementation (#81576).\n-                        let mut ty_str_reported = ty_str.clone();\n-                        if let ty::Adt(_, generics) = actual.kind() {\n-                            if generics.len() > 0 {\n-                                let mut autoderef = self.autoderef(span, actual);\n-                                let candidate_found = autoderef.any(|(ty, _)| {\n-                                    if let ty::Adt(adt_deref, _) = ty.kind() {\n-                                        self.tcx\n-                                            .inherent_impls(adt_deref.did())\n-                                            .iter()\n-                                            .filter_map(|def_id| {\n-                                                self.associated_value(*def_id, item_name)\n-                                            })\n-                                            .count()\n-                                            >= 1\n-                                    } else {\n-                                        false\n-                                    }\n-                                });\n-                                let has_deref = autoderef.step_count() > 0;\n-                                if !candidate_found\n-                                    && !has_deref\n-                                    && unsatisfied_predicates.is_empty()\n-                                {\n-                                    if let Some((path_string, _)) = ty_str.split_once('<') {\n-                                        ty_str_reported = path_string.to_string();\n-                                    }\n-                                }\n+                        _ => {}\n+                    }\n+                    err.emit();\n+                    return None;\n+                }\n+                span = item_name.span;\n+\n+                // Don't show generic arguments when the method can't be found in any implementation (#81576).\n+                let mut ty_str_reported = ty_str.clone();\n+                if let ty::Adt(_, generics) = actual.kind() {\n+                    if generics.len() > 0 {\n+                        let mut autoderef = self.autoderef(span, actual);\n+                        let candidate_found = autoderef.any(|(ty, _)| {\n+                            if let ty::Adt(adt_deref, _) = ty.kind() {\n+                                self.tcx\n+                                    .inherent_impls(adt_deref.did())\n+                                    .iter()\n+                                    .filter_map(|def_id| self.associated_value(*def_id, item_name))\n+                                    .count()\n+                                    >= 1\n+                            } else {\n+                                false\n+                            }\n+                        });\n+                        let has_deref = autoderef.step_count() > 0;\n+                        if !candidate_found && !has_deref && unsatisfied_predicates.is_empty() {\n+                            if let Some((path_string, _)) = ty_str.split_once('<') {\n+                                ty_str_reported = path_string.to_string();\n                             }\n                         }\n+                    }\n+                }\n \n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            span,\n-                            E0599,\n-                            \"no {} named `{}` found for {} `{}` in the current scope\",\n-                            item_kind,\n-                            item_name,\n-                            actual.prefix_string(self.tcx),\n-                            ty_str_reported,\n-                        );\n-                        if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0599,\n+                    \"no {} named `{}` found for {} `{}` in the current scope\",\n+                    item_kind,\n+                    item_name,\n+                    actual.prefix_string(self.tcx),\n+                    ty_str_reported,\n+                );\n+                if actual.references_error() {\n+                    err.downgrade_to_delayed_bug();\n+                }\n+\n+                if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n                             self.suggest_await_before_method(\n                                 &mut err, item_name, actual, cal, span,\n                             );\n                         }\n-                        if let Some(span) =\n-                            tcx.resolutions(()).confused_type_with_std_module.get(&span)\n-                        {\n-                            if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*span) {\n-                                err.span_suggestion(\n-                                    *span,\n-                                    \"you are looking for the module in `std`, \\\n+                if let Some(span) = tcx.resolutions(()).confused_type_with_std_module.get(&span) {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*span) {\n+                        err.span_suggestion(\n+                            *span,\n+                            \"you are looking for the module in `std`, \\\n                                      not the primitive type\",\n-                                    format!(\"std::{}\", snippet),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                        }\n-                        if let ty::RawPtr(_) = &actual.kind() {\n-                            err.note(\n-                                \"try using `<*const T>::as_ref()` to get a reference to the \\\n+                            format!(\"std::{}\", snippet),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                if let ty::RawPtr(_) = &actual.kind() {\n+                    err.note(\n+                        \"try using `<*const T>::as_ref()` to get a reference to the \\\n                                       type behind the pointer: https://doc.rust-lang.org/std/\\\n                                       primitive.pointer.html#method.as_ref\",\n-                            );\n-                            err.note(\n-                                \"using `<*const T>::as_ref()` on a pointer \\\n+                    );\n+                    err.note(\n+                        \"using `<*const T>::as_ref()` on a pointer \\\n                                       which is unaligned or points to invalid \\\n                                       or uninitialized memory is undefined behavior\",\n-                            );\n-                        }\n-                        err\n-                    }\n-                };\n-\n-                if actual.references_error() {\n-                    err.downgrade_to_delayed_bug();\n+                    );\n                 }\n \n                 if let Some(def) = actual.ty_adt_def() {"}]}