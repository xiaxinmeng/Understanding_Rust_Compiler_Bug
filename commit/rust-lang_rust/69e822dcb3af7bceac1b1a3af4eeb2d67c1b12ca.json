{"sha": "69e822dcb3af7bceac1b1a3af4eeb2d67c1b12ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZTgyMmRjYjNhZjdiY2VhYzFiMWEzYWY0ZWViMmQ2N2MxYjEyY2E=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-13T11:53:13Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-15T02:09:18Z"}, "message": "port reachable.rs from oldvisit to <V:Visitor> trait.", "tree": {"sha": "ecb6cb7444ad694dce7a7548a797b8a861aa2049", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecb6cb7444ad694dce7a7548a797b8a861aa2049"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69e822dcb3af7bceac1b1a3af4eeb2d67c1b12ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69e822dcb3af7bceac1b1a3af4eeb2d67c1b12ca", "html_url": "https://github.com/rust-lang/rust/commit/69e822dcb3af7bceac1b1a3af4eeb2d67c1b12ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69e822dcb3af7bceac1b1a3af4eeb2d67c1b12ca/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18be88f64a9e8ed398843431783230dc5f076799", "url": "https://api.github.com/repos/rust-lang/rust/commits/18be88f64a9e8ed398843431783230dc5f076799", "html_url": "https://github.com/rust-lang/rust/commit/18be88f64a9e8ed398843431783230dc5f076799"}], "stats": {"total": 207, "additions": 118, "deletions": 89}, "files": [{"sha": "b6a4ac49391a3b6902ded6efaf41724c08e84c5c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 118, "deletions": 89, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/69e822dcb3af7bceac1b1a3af4eeb2d67c1b12ca/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e822dcb3af7bceac1b1a3af4eeb2d67c1b12ca/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=69e822dcb3af7bceac1b1a3af4eeb2d67c1b12ca", "patch": "@@ -24,8 +24,8 @@ use syntax::ast_map;\n use syntax::ast_util::def_id_of_def;\n use syntax::attr;\n use syntax::parse::token;\n-use syntax::oldvisit::Visitor;\n-use syntax::oldvisit;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n \n // Returns true if the given set of attributes contains the `#[inline]`\n // attribute.\n@@ -94,48 +94,37 @@ struct ReachableContext {\n     worklist: @mut ~[NodeId],\n }\n \n-impl ReachableContext {\n-    // Creates a new reachability computation context.\n-    fn new(tcx: ty::ctxt, method_map: typeck::method_map)\n-           -> ReachableContext {\n-        ReachableContext {\n-            tcx: tcx,\n-            method_map: method_map,\n-            reachable_symbols: @mut HashSet::new(),\n-            worklist: @mut ~[],\n-        }\n-    }\n+struct ReachableVisitor {\n+    reachable_symbols: @mut HashSet<NodeId>,\n+    worklist: @mut ~[NodeId],\n+}\n+\n+impl Visitor<PrivacyContext> for ReachableVisitor {\n+\n+    fn visit_item(&mut self, item:@item, privacy_context:PrivacyContext) {\n \n-    // Step 1: Mark all public symbols, and add all public symbols that might\n-    // be inlined to a worklist.\n-    fn mark_public_symbols(&self, crate: @Crate) {\n-        let reachable_symbols = self.reachable_symbols;\n-        let worklist = self.worklist;\n-        let visitor = oldvisit::mk_vt(@Visitor {\n-            visit_item: |item, (privacy_context, visitor):\n-                    (PrivacyContext, oldvisit::vt<PrivacyContext>)| {\n                 match item.node {\n                     item_fn(*) => {\n                         if privacy_context == PublicContext {\n-                            reachable_symbols.insert(item.id);\n+                            self.reachable_symbols.insert(item.id);\n                         }\n                         if item_might_be_inlined(item) {\n-                            worklist.push(item.id)\n+                            self.worklist.push(item.id)\n                         }\n                     }\n                     item_struct(ref struct_def, _) => {\n                         match struct_def.ctor_id {\n                             Some(ctor_id) if\n                                     privacy_context == PublicContext => {\n-                                reachable_symbols.insert(ctor_id);\n+                                self.reachable_symbols.insert(ctor_id);\n                             }\n                             Some(_) | None => {}\n                         }\n                     }\n                     item_enum(ref enum_def, _) => {\n                         if privacy_context == PublicContext {\n                             for variant in enum_def.variants.iter() {\n-                                reachable_symbols.insert(variant.node.id);\n+                                self.reachable_symbols.insert(variant.node.id);\n                             }\n                         }\n                     }\n@@ -155,7 +144,7 @@ impl ReachableContext {\n                         // Mark all public methods as reachable.\n                         for &method in methods.iter() {\n                             if should_be_considered_public(method) {\n-                                reachable_symbols.insert(method.id);\n+                                self.reachable_symbols.insert(method.id);\n                             }\n                         }\n \n@@ -164,7 +153,7 @@ impl ReachableContext {\n                             // symbols to the worklist.\n                             for &method in methods.iter() {\n                                 if should_be_considered_public(method) {\n-                                    worklist.push(method.id)\n+                                    self.worklist.push(method.id)\n                                 }\n                             }\n                         } else {\n@@ -176,7 +165,7 @@ impl ReachableContext {\n                                 if generics_require_inlining(generics) ||\n                                         attributes_specify_inlining(*attrs) ||\n                                         should_be_considered_public(*method) {\n-                                    worklist.push(method.id)\n+                                    self.worklist.push(method.id)\n                                 }\n                             }\n                         }\n@@ -187,8 +176,8 @@ impl ReachableContext {\n                             for trait_method in trait_methods.iter() {\n                                 match *trait_method {\n                                     provided(method) => {\n-                                        reachable_symbols.insert(method.id);\n-                                        worklist.push(method.id)\n+                                        self.reachable_symbols.insert(method.id);\n+                                        self.worklist.push(method.id)\n                                     }\n                                     required(_) => {}\n                                 }\n@@ -199,15 +188,97 @@ impl ReachableContext {\n                 }\n \n                 if item.vis == public && privacy_context == PublicContext {\n-                    oldvisit::visit_item(item, (PublicContext, visitor))\n+                    visit::walk_item(self, item, PublicContext)\n                 } else {\n-                    oldvisit::visit_item(item, (PrivateContext, visitor))\n+                    visit::walk_item(self, item, PrivateContext)\n                 }\n-            },\n-            .. *oldvisit::default_visitor()\n-        });\n+    }\n+\n+}\n+\n+struct MarkSymbolVisitor {\n+    worklist: @mut ~[NodeId],\n+    method_map: typeck::method_map,\n+    tcx: ty::ctxt,\n+    reachable_symbols: @mut HashSet<NodeId>,\n+}\n+\n+impl Visitor<()> for MarkSymbolVisitor {\n \n-        oldvisit::visit_crate(crate, (PublicContext, visitor))\n+    fn visit_expr(&mut self, expr:@expr, _:()) {\n+\n+                match expr.node {\n+                    expr_path(_) => {\n+                        let def = match self.tcx.def_map.find(&expr.id) {\n+                            Some(&def) => def,\n+                            None => {\n+                                self.tcx.sess.span_bug(expr.span,\n+                                                  \"def ID not in def map?!\")\n+                            }\n+                        };\n+\n+                        let def_id = def_id_of_def(def);\n+                        if ReachableContext::\n+                                def_id_represents_local_inlined_item(self.tcx,\n+                                                                     def_id) {\n+                            self.worklist.push(def_id.node)\n+                        }\n+                        self.reachable_symbols.insert(def_id.node);\n+                    }\n+                    expr_method_call(*) => {\n+                        match self.method_map.find(&expr.id) {\n+                            Some(&typeck::method_map_entry {\n+                                origin: typeck::method_static(def_id),\n+                                _\n+                            }) => {\n+                                if ReachableContext::\n+                                    def_id_represents_local_inlined_item(\n+                                        self.tcx,\n+                                        def_id) {\n+                                    self.worklist.push(def_id.node)\n+                                }\n+                                self.reachable_symbols.insert(def_id.node);\n+                            }\n+                            Some(_) => {}\n+                            None => {\n+                                self.tcx.sess.span_bug(expr.span,\n+                                                  \"method call expression \\\n+                                                   not in method map?!\")\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                visit::walk_expr(self, expr, ())\n+    }\n+}\n+\n+impl ReachableContext {\n+    // Creates a new reachability computation context.\n+    fn new(tcx: ty::ctxt, method_map: typeck::method_map)\n+           -> ReachableContext {\n+        ReachableContext {\n+            tcx: tcx,\n+            method_map: method_map,\n+            reachable_symbols: @mut HashSet::new(),\n+            worklist: @mut ~[],\n+        }\n+    }\n+\n+    // Step 1: Mark all public symbols, and add all public symbols that might\n+    // be inlined to a worklist.\n+    fn mark_public_symbols(&self, crate: @Crate) {\n+        let reachable_symbols = self.reachable_symbols;\n+        let worklist = self.worklist;\n+\n+        let mut visitor = ReachableVisitor {\n+            reachable_symbols: reachable_symbols,\n+            worklist: worklist,\n+        };\n+\n+\n+        visit::walk_crate(&mut visitor, crate, PublicContext);\n     }\n \n     // Returns true if the given def ID represents a local item that is\n@@ -269,63 +340,21 @@ impl ReachableContext {\n     }\n \n     // Helper function to set up a visitor for `propagate()` below.\n-    fn init_visitor(&self) -> oldvisit::vt<()> {\n+    fn init_visitor(&self) -> MarkSymbolVisitor {\n         let (worklist, method_map) = (self.worklist, self.method_map);\n         let (tcx, reachable_symbols) = (self.tcx, self.reachable_symbols);\n-        oldvisit::mk_vt(@oldvisit::Visitor {\n-            visit_expr: |expr, (_, visitor)| {\n-                match expr.node {\n-                    expr_path(_) => {\n-                        let def = match tcx.def_map.find(&expr.id) {\n-                            Some(&def) => def,\n-                            None => {\n-                                tcx.sess.span_bug(expr.span,\n-                                                  \"def ID not in def map?!\")\n-                            }\n-                        };\n-\n-                        let def_id = def_id_of_def(def);\n-                        if ReachableContext::\n-                                def_id_represents_local_inlined_item(tcx,\n-                                                                     def_id) {\n-                            worklist.push(def_id.node)\n-                        }\n-                        reachable_symbols.insert(def_id.node);\n-                    }\n-                    expr_method_call(*) => {\n-                        match method_map.find(&expr.id) {\n-                            Some(&typeck::method_map_entry {\n-                                origin: typeck::method_static(def_id),\n-                                _\n-                            }) => {\n-                                if ReachableContext::\n-                                    def_id_represents_local_inlined_item(\n-                                        tcx,\n-                                        def_id) {\n-                                    worklist.push(def_id.node)\n-                                }\n-                                reachable_symbols.insert(def_id.node);\n-                            }\n-                            Some(_) => {}\n-                            None => {\n-                                tcx.sess.span_bug(expr.span,\n-                                                  \"method call expression \\\n-                                                   not in method map?!\")\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n \n-                oldvisit::visit_expr(expr, ((), visitor))\n-            },\n-            ..*oldvisit::default_visitor()\n-        })\n+        MarkSymbolVisitor {\n+            worklist: worklist,\n+            method_map: method_map,\n+            tcx: tcx,\n+            reachable_symbols: reachable_symbols,\n+        }\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     fn propagate(&self) {\n-        let visitor = self.init_visitor();\n+        let mut visitor = self.init_visitor();\n         let mut scanned = HashSet::new();\n         while self.worklist.len() > 0 {\n             let search_item = self.worklist.pop();\n@@ -342,7 +371,7 @@ impl ReachableContext {\n                 Some(&ast_map::node_item(item, _)) => {\n                     match item.node {\n                         item_fn(_, _, _, _, ref search_block) => {\n-                            oldvisit::visit_block(search_block, ((), visitor))\n+                            visit::walk_block(&mut visitor, search_block, ())\n                         }\n                         _ => {\n                             self.tcx.sess.span_bug(item.span,\n@@ -359,12 +388,12 @@ impl ReachableContext {\n                                                     worklist?!\")\n                         }\n                         provided(ref method) => {\n-                            oldvisit::visit_block(&method.body, ((), visitor))\n+                            visit::walk_block(&mut visitor, &method.body, ())\n                         }\n                     }\n                 }\n                 Some(&ast_map::node_method(ref method, _, _)) => {\n-                    oldvisit::visit_block(&method.body, ((), visitor))\n+                    visit::walk_block(&mut visitor, &method.body, ())\n                 }\n                 Some(_) => {\n                     let ident_interner = token::get_ident_interner();"}]}