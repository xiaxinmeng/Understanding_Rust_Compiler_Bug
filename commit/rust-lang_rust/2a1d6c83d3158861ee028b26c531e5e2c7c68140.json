{"sha": "2a1d6c83d3158861ee028b26c531e5e2c7c68140", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMWQ2YzgzZDMxNTg4NjFlZTAyOGIyNmM1MzFlNWUyYzdjNjgxNDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-05T12:46:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-05T12:46:15Z"}, "message": "Auto merge of #61484 - nnethercote:avoid-more-hygiene-lookups, r=petrochenkov\n\nAvoid more hygiene lookups\n\nMostly by combining multiple `HygieneData::with` calls into a single call on hot paths.\n\nr? @petrochenkov", "tree": {"sha": "791f3846d3a18ed9b7a9e4413385f717557c1e3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/791f3846d3a18ed9b7a9e4413385f717557c1e3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a1d6c83d3158861ee028b26c531e5e2c7c68140", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a1d6c83d3158861ee028b26c531e5e2c7c68140", "html_url": "https://github.com/rust-lang/rust/commit/2a1d6c83d3158861ee028b26c531e5e2c7c68140", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a1d6c83d3158861ee028b26c531e5e2c7c68140/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "817d2feb13dd1faad47ec699cd473b8be2093ec9", "url": "https://api.github.com/repos/rust-lang/rust/commits/817d2feb13dd1faad47ec699cd473b8be2093ec9", "html_url": "https://github.com/rust-lang/rust/commit/817d2feb13dd1faad47ec699cd473b8be2093ec9"}, {"sha": "4c9ecbf3d1a0fdac1d97c77783685c6281136c0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9ecbf3d1a0fdac1d97c77783685c6281136c0b", "html_url": "https://github.com/rust-lang/rust/commit/4c9ecbf3d1a0fdac1d97c77783685c6281136c0b"}], "stats": {"total": 466, "additions": 282, "deletions": 184}, "files": [{"sha": "e585f9939a0141e0f48e6bc717b779f95ee18ebe", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2a1d6c83d3158861ee028b26c531e5e2c7c68140", "patch": "@@ -3089,7 +3089,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // comparison fails frequently, and we want to avoid the expensive\n         // `modern()` calls required for the span comparison whenever possible.\n         use_name.name == def_name.name &&\n-        self.adjust_ident(use_name, def_parent_def_id).span.ctxt() == def_name.modern().span.ctxt()\n+        use_name.span.ctxt().hygienic_eq(def_name.span.ctxt(),\n+                                         self.expansion_that_defined(def_parent_def_id))\n     }\n \n     fn expansion_that_defined(self, scope: DefId) -> Mark {\n@@ -3100,15 +3101,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId) -> Ident {\n-        ident = ident.modern();\n-        ident.span.adjust(self.expansion_that_defined(scope));\n+        ident.span.modernize_and_adjust(self.expansion_that_defined(scope));\n         ident\n     }\n \n     pub fn adjust_ident_and_get_scope(self, mut ident: Ident, scope: DefId, block: hir::HirId)\n                                       -> (Ident, DefId) {\n-        ident = ident.modern();\n-        let scope = match ident.span.adjust(self.expansion_that_defined(scope)) {\n+        let scope = match ident.span.modernize_and_adjust(self.expansion_that_defined(scope)) {\n             Some(actual_expansion) =>\n                 self.hir().definitions().parent_module_of_macro_def(actual_expansion),\n             None => self.hir().get_module_parent_by_hir_id(block),"}, {"sha": "4dbc2ab1b358ec33885af85d613a407d6004212d", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=2a1d6c83d3158861ee028b26c531e5e2c7c68140", "patch": "@@ -844,9 +844,8 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx\n         if span_data.ctxt == SyntaxContext::empty() {\n             TAG_NO_EXPANSION_INFO.encode(self)\n         } else {\n-            let mark = span_data.ctxt.outer();\n-\n-            if let Some(expn_info) = mark.expn_info() {\n+            let (mark, expn_info) = span_data.ctxt.outer_and_expn_info();\n+            if let Some(expn_info) = expn_info {\n                 if let Some(pos) = self.expn_info_shorthands.get(&mark).cloned() {\n                     TAG_EXPANSION_INFO_SHORTHAND.encode(self)?;\n                     pos.encode(self)"}, {"sha": "dd69d358313181b66690daf5c06aff76fbe2ce29", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=2a1d6c83d3158861ee028b26c531e5e2c7c68140", "patch": "@@ -128,14 +128,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             // Walk up the macro expansion chain until we reach a non-expanded span.\n             // We also stop at the function body level because no line stepping can occur\n             // at the level above that.\n-            let mut span = source_info.span;\n-            while span.ctxt() != NO_EXPANSION && span.ctxt() != self.mir.span.ctxt() {\n-                if let Some(info) = span.ctxt().outer_expn_info() {\n-                    span = info.call_site;\n-                } else {\n-                    break;\n-                }\n-            }\n+            let span = syntax_pos::hygiene::walk_chain(source_info.span, self.mir.span.ctxt());\n             let scope = self.scope_metadata_for_loc(source_info.scope, span.lo());\n             // Use span of the outermost expansion site, while keeping the original lexical scope.\n             (scope, span)"}, {"sha": "9b9cf80f822b027c8487f31c4b7b0693c1eb3d73", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2a1d6c83d3158861ee028b26c531e5e2c7c68140", "patch": "@@ -2330,14 +2330,12 @@ impl<'a> Resolver<'a> {\n         let orig_current_module = self.current_module;\n         match module {\n             ModuleOrUniformRoot::Module(module) => {\n-                ident.span = ident.span.modern();\n-                if let Some(def) = ident.span.adjust(module.expansion) {\n+                if let Some(def) = ident.span.modernize_and_adjust(module.expansion) {\n                     self.current_module = self.macro_def_scope(def);\n                 }\n             }\n             ModuleOrUniformRoot::ExternPrelude => {\n-                ident.span = ident.span.modern();\n-                ident.span.adjust(Mark::root());\n+                ident.span.modernize_and_adjust(Mark::root());\n             }\n             ModuleOrUniformRoot::CrateRootAndExternPrelude |\n             ModuleOrUniformRoot::CurrentScope => {\n@@ -4525,7 +4523,7 @@ impl<'a> Resolver<'a> {\n                 let mut ident = ident;\n                 if ident.span.glob_adjust(\n                     module.expansion,\n-                    binding.span.ctxt().modern(),\n+                    binding.span,\n                 ).is_none() {\n                     continue\n                 }"}, {"sha": "d24d8f8c2b5b11ed23d09e2828079271a99275af", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=2a1d6c83d3158861ee028b26c531e5e2c7c68140", "patch": "@@ -388,7 +388,7 @@ impl<'a> Resolver<'a> {\n                 None => return Err((Undetermined, Weak::Yes)),\n             };\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n-            match ident.span.glob_adjust(module.expansion, glob_import.span.ctxt().modern()) {\n+            match ident.span.glob_adjust(module.expansion, glob_import.span) {\n                 Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n                 Some(None) => {}\n                 None => continue,\n@@ -605,8 +605,7 @@ impl<'a> Resolver<'a> {\n         // Define `binding` in `module`s glob importers.\n         for directive in module.glob_importers.borrow_mut().iter() {\n             let mut ident = ident.modern();\n-            let scope = match ident.span.reverse_glob_adjust(module.expansion,\n-                                                             directive.span.ctxt().modern()) {\n+            let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n                 Some(None) => directive.parent_scope.module,\n                 None => continue,\n@@ -1359,8 +1358,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             resolution.borrow().binding().map(|binding| (ident, binding))\n         }).collect::<Vec<_>>();\n         for ((mut ident, ns), binding) in bindings {\n-            let scope = match ident.span.reverse_glob_adjust(module.expansion,\n-                                                             directive.span.ctxt().modern()) {\n+            let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n                 Some(None) => self.current_module,\n                 None => continue,"}, {"sha": "39fcd29e1b084399f959cd59e90f25df6288b153", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2a1d6c83d3158861ee028b26c531e5e2c7c68140", "patch": "@@ -2083,13 +2083,6 @@ impl<'a> Parser<'a> {\n                     hi = path.span;\n                     return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n-                if self.span.rust_2018() && self.check_keyword(kw::Async) {\n-                    return if self.is_async_block() { // check for `async {` and `async move {`\n-                        self.parse_async_block(attrs)\n-                    } else {\n-                        self.parse_lambda_expr(attrs)\n-                    };\n-                }\n                 if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n                     return self.parse_lambda_expr(attrs);\n                 }\n@@ -2161,6 +2154,16 @@ impl<'a> Parser<'a> {\n                     assert!(self.eat_keyword(kw::Try));\n                     return self.parse_try_block(lo, attrs);\n                 }\n+\n+                // Span::rust_2018() is somewhat expensive; don't get it repeatedly.\n+                let is_span_rust_2018 = self.span.rust_2018();\n+                if is_span_rust_2018 && self.check_keyword(kw::Async) {\n+                    return if self.is_async_block() { // check for `async {` and `async move {`\n+                        self.parse_async_block(attrs)\n+                    } else {\n+                        self.parse_lambda_expr(attrs)\n+                    };\n+                }\n                 if self.eat_keyword(kw::Return) {\n                     if self.token.can_begin_expr() {\n                         let e = self.parse_expr()?;\n@@ -2196,7 +2199,7 @@ impl<'a> Parser<'a> {\n                     db.span_label(self.span, \"expected expression\");\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n-                } else if self.span.rust_2018() && self.eat_keyword(kw::Await) {\n+                } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n                     let (await_hi, e_kind) = self.parse_await_macro_or_alt(lo, self.prev_span)?;\n                     hi = await_hi;\n                     ex = e_kind;"}, {"sha": "213993996a63cc3fd3ee15808e85cdc5dc7346a8", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 246, "deletions": 145, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=2a1d6c83d3158861ee028b26c531e5e2c7c68140", "patch": "@@ -5,6 +5,26 @@\n //! and definition contexts*. J. Funct. Program. 22, 2 (March 2012), 181-216.\n //! DOI=10.1017/S0956796812000093 <https://doi.org/10.1017/S0956796812000093>\n \n+// Hygiene data is stored in a global variable and accessed via TLS, which\n+// means that accesses are somewhat expensive. (`HygieneData::with`\n+// encapsulates a single access.) Therefore, on hot code paths it is worth\n+// ensuring that multiple HygieneData accesses are combined into a single\n+// `HygieneData::with`.\n+//\n+// This explains why `HygieneData`, `SyntaxContext` and `Mark` have interfaces\n+// with a certain amount of redundancy in them. For example,\n+// `SyntaxContext::outer_expn_info` combines `SyntaxContext::outer` and\n+// `Mark::expn_info` so that two `HygieneData` accesses can be performed within\n+// a single `HygieneData::with` call.\n+//\n+// It also explains why many functions appear in `HygieneData` and again in\n+// `SyntaxContext` or `Mark`. For example, `HygieneData::outer` and\n+// `SyntaxContext::outer` do the same thing, but the former is for use within a\n+// `HygieneData::with` call while the latter is for use outside such a call.\n+// When modifying this file it is important to understand this distinction,\n+// because getting it wrong can lead to nested `HygieneData::with` calls that\n+// trigger runtime aborts. (Fortunately these are obvious and easy to fix.)\n+\n use crate::GLOBALS;\n use crate::Span;\n use crate::edition::Edition;\n@@ -98,7 +118,7 @@ impl Mark {\n \n     #[inline]\n     pub fn expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.marks[self.0 as usize].expn_info.clone())\n+        HygieneData::with(|data| data.expn_info(self))\n     }\n \n     #[inline]\n@@ -200,10 +220,6 @@ impl HygieneData {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn outer(&self, ctxt: SyntaxContext) -> Mark {\n-        self.syntax_contexts[ctxt.0 as usize].outer_mark\n-    }\n-\n     fn expn_info(&self, mark: Mark) -> Option<ExpnInfo> {\n         self.marks[mark.0 as usize].expn_info.clone()\n     }\n@@ -217,12 +233,174 @@ impl HygieneData {\n         }\n         true\n     }\n+\n+    fn default_transparency(&self, mark: Mark) -> Transparency {\n+        self.marks[mark.0 as usize].default_transparency\n+    }\n+\n+    fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n+        self.syntax_contexts[ctxt.0 as usize].opaque\n+    }\n+\n+    fn modern_and_legacy(&self, ctxt: SyntaxContext) -> SyntaxContext {\n+        self.syntax_contexts[ctxt.0 as usize].opaque_and_semitransparent\n+    }\n+\n+    fn outer(&self, ctxt: SyntaxContext) -> Mark {\n+        self.syntax_contexts[ctxt.0 as usize].outer_mark\n+    }\n+\n+    fn transparency(&self, ctxt: SyntaxContext) -> Transparency {\n+        self.syntax_contexts[ctxt.0 as usize].transparency\n+    }\n+\n+    fn prev_ctxt(&self, ctxt: SyntaxContext) -> SyntaxContext {\n+        self.syntax_contexts[ctxt.0 as usize].prev_ctxt\n+    }\n+\n+    fn remove_mark(&self, ctxt: &mut SyntaxContext) -> Mark {\n+        let outer_mark = self.syntax_contexts[ctxt.0 as usize].outer_mark;\n+        *ctxt = self.prev_ctxt(*ctxt);\n+        outer_mark\n+    }\n+\n+    fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(Mark, Transparency)> {\n+        let mut marks = Vec::new();\n+        while ctxt != SyntaxContext::empty() {\n+            let outer_mark = self.outer(ctxt);\n+            let transparency = self.transparency(ctxt);\n+            let prev_ctxt = self.prev_ctxt(ctxt);\n+            marks.push((outer_mark, transparency));\n+            ctxt = prev_ctxt;\n+        }\n+        marks.reverse();\n+        marks\n+    }\n+\n+    fn walk_chain(&self, mut span: Span, to: SyntaxContext) -> Span {\n+        while span.ctxt() != crate::NO_EXPANSION && span.ctxt() != to {\n+            if let Some(info) = self.expn_info(self.outer(span.ctxt())) {\n+                span = info.call_site;\n+            } else {\n+                break;\n+            }\n+        }\n+        span\n+    }\n+\n+    fn adjust(&self, ctxt: &mut SyntaxContext, expansion: Mark) -> Option<Mark> {\n+        let mut scope = None;\n+        while !self.is_descendant_of(expansion, self.outer(*ctxt)) {\n+            scope = Some(self.remove_mark(ctxt));\n+        }\n+        scope\n+    }\n+\n+    fn apply_mark(&mut self, ctxt: SyntaxContext, mark: Mark) -> SyntaxContext {\n+        assert_ne!(mark, Mark::root());\n+        self.apply_mark_with_transparency(ctxt, mark, self.default_transparency(mark))\n+    }\n+\n+    fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, mark: Mark,\n+                                    transparency: Transparency) -> SyntaxContext {\n+        assert_ne!(mark, Mark::root());\n+        if transparency == Transparency::Opaque {\n+            return self.apply_mark_internal(ctxt, mark, transparency);\n+        }\n+\n+        let call_site_ctxt =\n+            self.expn_info(mark).map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n+        let mut call_site_ctxt = if transparency == Transparency::SemiTransparent {\n+            self.modern(call_site_ctxt)\n+        } else {\n+            self.modern_and_legacy(call_site_ctxt)\n+        };\n+\n+        if call_site_ctxt == SyntaxContext::empty() {\n+            return self.apply_mark_internal(ctxt, mark, transparency);\n+        }\n+\n+        // Otherwise, `mark` is a macros 1.0 definition and the call site is in a\n+        // macros 2.0 expansion, i.e., a macros 1.0 invocation is in a macros 2.0 definition.\n+        //\n+        // In this case, the tokens from the macros 1.0 definition inherit the hygiene\n+        // at their invocation. That is, we pretend that the macros 1.0 definition\n+        // was defined at its invocation (i.e., inside the macros 2.0 definition)\n+        // so that the macros 2.0 definition remains hygienic.\n+        //\n+        // See the example at `test/run-pass/hygiene/legacy_interaction.rs`.\n+        for (mark, transparency) in self.marks(ctxt) {\n+            call_site_ctxt = self.apply_mark_internal(call_site_ctxt, mark, transparency);\n+        }\n+        self.apply_mark_internal(call_site_ctxt, mark, transparency)\n+    }\n+\n+    fn apply_mark_internal(&mut self, ctxt: SyntaxContext, mark: Mark, transparency: Transparency)\n+                           -> SyntaxContext {\n+        let syntax_contexts = &mut self.syntax_contexts;\n+        let mut opaque = syntax_contexts[ctxt.0 as usize].opaque;\n+        let mut opaque_and_semitransparent =\n+            syntax_contexts[ctxt.0 as usize].opaque_and_semitransparent;\n+\n+        if transparency >= Transparency::Opaque {\n+            let prev_ctxt = opaque;\n+            opaque = *self.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n+                let new_opaque = SyntaxContext(syntax_contexts.len() as u32);\n+                syntax_contexts.push(SyntaxContextData {\n+                    outer_mark: mark,\n+                    transparency,\n+                    prev_ctxt,\n+                    opaque: new_opaque,\n+                    opaque_and_semitransparent: new_opaque,\n+                    dollar_crate_name: kw::DollarCrate,\n+                });\n+                new_opaque\n+            });\n+        }\n+\n+        if transparency >= Transparency::SemiTransparent {\n+            let prev_ctxt = opaque_and_semitransparent;\n+            opaque_and_semitransparent =\n+                    *self.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n+                let new_opaque_and_semitransparent =\n+                    SyntaxContext(syntax_contexts.len() as u32);\n+                syntax_contexts.push(SyntaxContextData {\n+                    outer_mark: mark,\n+                    transparency,\n+                    prev_ctxt,\n+                    opaque,\n+                    opaque_and_semitransparent: new_opaque_and_semitransparent,\n+                    dollar_crate_name: kw::DollarCrate,\n+                });\n+                new_opaque_and_semitransparent\n+            });\n+        }\n+\n+        let prev_ctxt = ctxt;\n+        *self.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n+            let new_opaque_and_semitransparent_and_transparent =\n+                SyntaxContext(syntax_contexts.len() as u32);\n+            syntax_contexts.push(SyntaxContextData {\n+                outer_mark: mark,\n+                transparency,\n+                prev_ctxt,\n+                opaque,\n+                opaque_and_semitransparent,\n+                dollar_crate_name: kw::DollarCrate,\n+            });\n+            new_opaque_and_semitransparent_and_transparent\n+        })\n+    }\n }\n \n pub fn clear_markings() {\n     HygieneData::with(|data| data.markings = FxHashMap::default());\n }\n \n+pub fn walk_chain(span: Span, to: SyntaxContext) -> Span {\n+    HygieneData::with(|data| data.walk_chain(span, to))\n+}\n+\n impl SyntaxContext {\n     #[inline]\n     pub const fn empty() -> Self {\n@@ -269,104 +447,13 @@ impl SyntaxContext {\n \n     /// Extend a syntax context with a given mark and default transparency for that mark.\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n-        assert_ne!(mark, Mark::root());\n-        self.apply_mark_with_transparency(\n-            mark, HygieneData::with(|data| data.marks[mark.0 as usize].default_transparency)\n-        )\n+        HygieneData::with(|data| data.apply_mark(self, mark))\n     }\n \n     /// Extend a syntax context with a given mark and transparency\n     pub fn apply_mark_with_transparency(self, mark: Mark, transparency: Transparency)\n                                         -> SyntaxContext {\n-        assert_ne!(mark, Mark::root());\n-        if transparency == Transparency::Opaque {\n-            return self.apply_mark_internal(mark, transparency);\n-        }\n-\n-        let call_site_ctxt =\n-            mark.expn_info().map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n-        let call_site_ctxt = if transparency == Transparency::SemiTransparent {\n-            call_site_ctxt.modern()\n-        } else {\n-            call_site_ctxt.modern_and_legacy()\n-        };\n-\n-        if call_site_ctxt == SyntaxContext::empty() {\n-            return self.apply_mark_internal(mark, transparency);\n-        }\n-\n-        // Otherwise, `mark` is a macros 1.0 definition and the call site is in a\n-        // macros 2.0 expansion, i.e., a macros 1.0 invocation is in a macros 2.0 definition.\n-        //\n-        // In this case, the tokens from the macros 1.0 definition inherit the hygiene\n-        // at their invocation. That is, we pretend that the macros 1.0 definition\n-        // was defined at its invocation (i.e., inside the macros 2.0 definition)\n-        // so that the macros 2.0 definition remains hygienic.\n-        //\n-        // See the example at `test/run-pass/hygiene/legacy_interaction.rs`.\n-        let mut ctxt = call_site_ctxt;\n-        for (mark, transparency) in self.marks() {\n-            ctxt = ctxt.apply_mark_internal(mark, transparency);\n-        }\n-        ctxt.apply_mark_internal(mark, transparency)\n-    }\n-\n-    fn apply_mark_internal(self, mark: Mark, transparency: Transparency) -> SyntaxContext {\n-        HygieneData::with(|data| {\n-            let syntax_contexts = &mut data.syntax_contexts;\n-            let mut opaque = syntax_contexts[self.0 as usize].opaque;\n-            let mut opaque_and_semitransparent =\n-                syntax_contexts[self.0 as usize].opaque_and_semitransparent;\n-\n-            if transparency >= Transparency::Opaque {\n-                let prev_ctxt = opaque;\n-                opaque = *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n-                    let new_opaque = SyntaxContext(syntax_contexts.len() as u32);\n-                    syntax_contexts.push(SyntaxContextData {\n-                        outer_mark: mark,\n-                        transparency,\n-                        prev_ctxt,\n-                        opaque: new_opaque,\n-                        opaque_and_semitransparent: new_opaque,\n-                        dollar_crate_name: kw::DollarCrate,\n-                    });\n-                    new_opaque\n-                });\n-            }\n-\n-            if transparency >= Transparency::SemiTransparent {\n-                let prev_ctxt = opaque_and_semitransparent;\n-                opaque_and_semitransparent =\n-                        *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n-                    let new_opaque_and_semitransparent =\n-                        SyntaxContext(syntax_contexts.len() as u32);\n-                    syntax_contexts.push(SyntaxContextData {\n-                        outer_mark: mark,\n-                        transparency,\n-                        prev_ctxt,\n-                        opaque,\n-                        opaque_and_semitransparent: new_opaque_and_semitransparent,\n-                        dollar_crate_name: kw::DollarCrate,\n-                    });\n-                    new_opaque_and_semitransparent\n-                });\n-            }\n-\n-            let prev_ctxt = self;\n-            *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n-                let new_opaque_and_semitransparent_and_transparent =\n-                    SyntaxContext(syntax_contexts.len() as u32);\n-                syntax_contexts.push(SyntaxContextData {\n-                    outer_mark: mark,\n-                    transparency,\n-                    prev_ctxt,\n-                    opaque,\n-                    opaque_and_semitransparent,\n-                    dollar_crate_name: kw::DollarCrate,\n-                });\n-                new_opaque_and_semitransparent_and_transparent\n-            })\n-        })\n+        HygieneData::with(|data| data.apply_mark_with_transparency(self, mark, transparency))\n     }\n \n     /// Pulls a single mark off of the syntax context. This effectively moves the\n@@ -386,24 +473,11 @@ impl SyntaxContext {\n     /// invocation of f that created g1.\n     /// Returns the mark that was removed.\n     pub fn remove_mark(&mut self) -> Mark {\n-        HygieneData::with(|data| {\n-            let outer_mark = data.syntax_contexts[self.0 as usize].outer_mark;\n-            *self = data.syntax_contexts[self.0 as usize].prev_ctxt;\n-            outer_mark\n-        })\n+        HygieneData::with(|data| data.remove_mark(self))\n     }\n \n-    pub fn marks(mut self) -> Vec<(Mark, Transparency)> {\n-        HygieneData::with(|data| {\n-            let mut marks = Vec::new();\n-            while self != SyntaxContext::empty() {\n-                let ctxt_data = &data.syntax_contexts[self.0 as usize];\n-                marks.push((ctxt_data.outer_mark, ctxt_data.transparency));\n-                self = ctxt_data.prev_ctxt;\n-            }\n-            marks.reverse();\n-            marks\n-        })\n+    pub fn marks(self) -> Vec<(Mark, Transparency)> {\n+        HygieneData::with(|data| data.marks(self))\n     }\n \n     /// Adjust this context for resolution in a scope created by the given expansion.\n@@ -431,11 +505,15 @@ impl SyntaxContext {\n     /// This returns the expansion whose definition scope we use to privacy check the resolution,\n     /// or `None` if we privacy check as usual (i.e., not w.r.t. a macro definition scope).\n     pub fn adjust(&mut self, expansion: Mark) -> Option<Mark> {\n-        let mut scope = None;\n-        while !expansion.outer_is_descendant_of(*self) {\n-            scope = Some(self.remove_mark());\n-        }\n-        scope\n+        HygieneData::with(|data| data.adjust(self, expansion))\n+    }\n+\n+    /// Like `SyntaxContext::adjust`, but also modernizes `self`.\n+    pub fn modernize_and_adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+        HygieneData::with(|data| {\n+            *self = data.modern(*self);\n+            data.adjust(self, expansion)\n+        })\n     }\n \n     /// Adjust this context for resolution in a scope created by the given expansion\n@@ -463,19 +541,21 @@ impl SyntaxContext {\n     /// ```\n     /// This returns `None` if the context cannot be glob-adjusted.\n     /// Otherwise, it returns the scope to use when privacy checking (see `adjust` for details).\n-    pub fn glob_adjust(&mut self, expansion: Mark, mut glob_ctxt: SyntaxContext)\n-                       -> Option<Option<Mark>> {\n-        let mut scope = None;\n-        while !expansion.outer_is_descendant_of(glob_ctxt) {\n-            scope = Some(glob_ctxt.remove_mark());\n-            if self.remove_mark() != scope.unwrap() {\n+    pub fn glob_adjust(&mut self, expansion: Mark, glob_span: Span) -> Option<Option<Mark>> {\n+        HygieneData::with(|data| {\n+            let mut scope = None;\n+            let mut glob_ctxt = data.modern(glob_span.ctxt());\n+            while !data.is_descendant_of(expansion, data.outer(glob_ctxt)) {\n+                scope = Some(data.remove_mark(&mut glob_ctxt));\n+                if data.remove_mark(self) != scope.unwrap() {\n+                    return None;\n+                }\n+            }\n+            if data.adjust(self, expansion).is_some() {\n                 return None;\n             }\n-        }\n-        if self.adjust(expansion).is_some() {\n-            return None;\n-        }\n-        Some(scope)\n+            Some(scope)\n+        })\n     }\n \n     /// Undo `glob_adjust` if possible:\n@@ -485,32 +565,43 @@ impl SyntaxContext {\n     ///     assert!(self.glob_adjust(expansion, glob_ctxt) == Some(privacy_checking_scope));\n     /// }\n     /// ```\n-    pub fn reverse_glob_adjust(&mut self, expansion: Mark, mut glob_ctxt: SyntaxContext)\n+    pub fn reverse_glob_adjust(&mut self, expansion: Mark, glob_span: Span)\n                                -> Option<Option<Mark>> {\n-        if self.adjust(expansion).is_some() {\n-            return None;\n-        }\n+        HygieneData::with(|data| {\n+            if data.adjust(self, expansion).is_some() {\n+                return None;\n+            }\n \n-        let mut marks = Vec::new();\n-        while !expansion.outer_is_descendant_of(glob_ctxt) {\n-            marks.push(glob_ctxt.remove_mark());\n-        }\n+            let mut glob_ctxt = data.modern(glob_span.ctxt());\n+            let mut marks = Vec::new();\n+            while !data.is_descendant_of(expansion, data.outer(glob_ctxt)) {\n+                marks.push(data.remove_mark(&mut glob_ctxt));\n+            }\n \n-        let scope = marks.last().cloned();\n-        while let Some(mark) = marks.pop() {\n-            *self = self.apply_mark(mark);\n-        }\n-        Some(scope)\n+            let scope = marks.last().cloned();\n+            while let Some(mark) = marks.pop() {\n+                *self = data.apply_mark(*self, mark);\n+            }\n+            Some(scope)\n+        })\n+    }\n+\n+    pub fn hygienic_eq(self, other: SyntaxContext, mark: Mark) -> bool {\n+        HygieneData::with(|data| {\n+            let mut self_modern = data.modern(self);\n+            data.adjust(&mut self_modern, mark);\n+            self_modern == data.modern(other)\n+        })\n     }\n \n     #[inline]\n     pub fn modern(self) -> SyntaxContext {\n-        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].opaque)\n+        HygieneData::with(|data| data.modern(self))\n     }\n \n     #[inline]\n     pub fn modern_and_legacy(self) -> SyntaxContext {\n-        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].opaque_and_semitransparent)\n+        HygieneData::with(|data| data.modern_and_legacy(self))\n     }\n \n     #[inline]\n@@ -525,6 +616,16 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.expn_info(data.outer(self)))\n     }\n \n+    /// `ctxt.outer_and_expn_info()` is equivalent to but faster than\n+    /// `{ let outer = ctxt.outer(); (outer, outer.expn_info()) }`.\n+    #[inline]\n+    pub fn outer_and_expn_info(self) -> (Mark, Option<ExpnInfo>) {\n+        HygieneData::with(|data| {\n+            let outer = data.outer(self);\n+            (outer, data.expn_info(outer))\n+        })\n+    }\n+\n     pub fn dollar_crate_name(self) -> Symbol {\n         HygieneData::with(|data| data.syntax_contexts[self.0 as usize].dollar_crate_name)\n     }"}, {"sha": "24aa82184ced58d9e4c7900a9c444b35ccd8545c", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d6c83d3158861ee028b26c531e5e2c7c68140/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=2a1d6c83d3158861ee028b26c531e5e2c7c68140", "patch": "@@ -535,19 +535,26 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn glob_adjust(&mut self, expansion: Mark, glob_ctxt: SyntaxContext)\n-                       -> Option<Option<Mark>> {\n+    pub fn modernize_and_adjust(&mut self, expansion: Mark) -> Option<Mark> {\n         let mut span = self.data();\n-        let mark = span.ctxt.glob_adjust(expansion, glob_ctxt);\n+        let mark = span.ctxt.modernize_and_adjust(expansion);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn reverse_glob_adjust(&mut self, expansion: Mark, glob_ctxt: SyntaxContext)\n+    pub fn glob_adjust(&mut self, expansion: Mark, glob_span: Span) -> Option<Option<Mark>> {\n+        let mut span = self.data();\n+        let mark = span.ctxt.glob_adjust(expansion, glob_span);\n+        *self = Span::new(span.lo, span.hi, span.ctxt);\n+        mark\n+    }\n+\n+    #[inline]\n+    pub fn reverse_glob_adjust(&mut self, expansion: Mark, glob_span: Span)\n                                -> Option<Option<Mark>> {\n         let mut span = self.data();\n-        let mark = span.ctxt.reverse_glob_adjust(expansion, glob_ctxt);\n+        let mark = span.ctxt.reverse_glob_adjust(expansion, glob_span);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }"}]}