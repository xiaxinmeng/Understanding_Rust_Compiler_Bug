{"sha": "1f175fa35d4263f1d2c4c3433a495a78996305f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmMTc1ZmEzNWQ0MjYzZjFkMmM0YzM0MzNhNDk1YTc4OTk2MzA1ZjQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-22T08:39:51Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-05-25T05:51:50Z"}, "message": "Hygienize `librustc_resolve`.", "tree": {"sha": "5c82cc94964d2e84147ed74a74f53d25c00fc29c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c82cc94964d2e84147ed74a74f53d25c00fc29c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f175fa35d4263f1d2c4c3433a495a78996305f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f175fa35d4263f1d2c4c3433a495a78996305f4", "html_url": "https://github.com/rust-lang/rust/commit/1f175fa35d4263f1d2c4c3433a495a78996305f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f175fa35d4263f1d2c4c3433a495a78996305f4/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cded8472ed034739ff31e314f5cf76ebe5d07c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cded8472ed034739ff31e314f5cf76ebe5d07c1", "html_url": "https://github.com/rust-lang/rust/commit/1cded8472ed034739ff31e314f5cf76ebe5d07c1"}], "stats": {"total": 680, "additions": 491, "deletions": 189}, "files": [{"sha": "1e4114add814d786848b01140741d10bc44c5d14", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -393,7 +393,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn allow_internal_unstable(&self, reason: &'static str, mut span: Span) -> Span {\n-        let mark = Mark::fresh();\n+        let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(codemap::ExpnInfo {\n             call_site: span,\n             callee: codemap::NameAndSpan {"}, {"sha": "9d098557367cd48311369dfc59557c7f5a1ee188", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -388,7 +388,7 @@ impl CrateStore for cstore::CStore {\n             attrs: attrs.iter().cloned().collect(),\n             node: ast::ItemKind::MacroDef(ast::MacroDef {\n                 tokens: body.into(),\n-                legacy: true,\n+                legacy: def.legacy,\n             }),\n             vis: ast::Visibility::Inherited,\n         })"}, {"sha": "07c475949d4357555c41e90dc33776106bc121c1", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -1104,6 +1104,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         Entry {\n             kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n                 body: pprust::tts_to_string(&macro_def.body.trees().collect::<Vec<_>>()),\n+                legacy: macro_def.legacy,\n             })),\n             visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&macro_def.span),"}, {"sha": "2ffe7cc02aaacec21feca4538057c9159a306b3b", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -433,9 +433,10 @@ impl_stable_hash_for!(struct ModData { reexports });\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct MacroDef {\n     pub body: String,\n+    pub legacy: bool,\n }\n \n-impl_stable_hash_for!(struct MacroDef { body });\n+impl_stable_hash_for!(struct MacroDef { body, legacy });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData {"}, {"sha": "72f555b47cc9a87c6ff06a6a30e49b7e1a430898", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -23,7 +23,7 @@ use {resolve_error, resolve_struct_error, ResolutionError};\n \n use rustc::middle::cstore::LoadedMacro;\n use rustc::hir::def::*;\n-use rustc::hir::def_id::{CrateNum, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n \n use std::cell::Cell;\n@@ -150,7 +150,7 @@ impl<'a> Resolver<'a> {\n                                           view_path.span,\n                                           ResolutionError::SelfImportsOnlyAllowedWithin);\n                         } else if source_name == \"$crate\" && full_path.segments.len() == 1 {\n-                            let crate_root = self.resolve_crate_var(source.ctxt, item.span);\n+                            let crate_root = self.resolve_crate_root(source.ctxt);\n                             let crate_name = match crate_root.kind {\n                                 ModuleKind::Def(_, name) => name,\n                                 ModuleKind::Block(..) => unreachable!(),\n@@ -247,7 +247,8 @@ impl<'a> Resolver<'a> {\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n-                let module = self.get_extern_crate_root(crate_id, item.span);\n+                let module =\n+                    self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 self.populate_module_if_necessary(module);\n                 let used = self.process_legacy_macro_imports(item, module, expansion);\n                 let binding =\n@@ -279,7 +280,7 @@ impl<'a> Resolver<'a> {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n-                    ..ModuleData::new(Some(parent), module_kind, def_id, item.span)\n+                    ..ModuleData::new(Some(parent), module_kind, def_id, expansion, item.span)\n                 });\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.module_map.insert(def_id, module);\n@@ -317,6 +318,7 @@ impl<'a> Resolver<'a> {\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n+                                             expansion,\n                                              item.span);\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n@@ -376,6 +378,7 @@ impl<'a> Resolver<'a> {\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n+                                             expansion,\n                                              item.span);\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n@@ -421,12 +424,13 @@ impl<'a> Resolver<'a> {\n         self.define(parent, item.ident, ValueNS, (def, vis, item.span, expansion));\n     }\n \n-    fn build_reduced_graph_for_block(&mut self, block: &Block) {\n+    fn build_reduced_graph_for_block(&mut self, block: &Block, expansion: Mark) {\n         let parent = self.current_module;\n         if self.block_needs_anonymous_module(block) {\n             let module = self.new_module(parent,\n                                          ModuleKind::Block(block.id),\n                                          parent.normal_ancestor_id,\n+                                         expansion,\n                                          block.span);\n             self.block_map.insert(block.id, module);\n             self.current_module = module; // Descend into the block.\n@@ -440,23 +444,24 @@ impl<'a> Resolver<'a> {\n         let def_id = def.def_id();\n         let vis = self.session.cstore.visibility(def_id);\n         let span = child.span;\n-\n+        let expansion = Mark::root(); // FIXME(jseyfried) intercrate hygiene\n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n                 let module = self.new_module(parent,\n                                              ModuleKind::Def(def, ident.name),\n                                              def_id,\n+                                             expansion,\n                                              span);\n-                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n             Def::Variant(..) | Def::TyAlias(..) => {\n-                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n             }\n             Def::Fn(..) | Def::Static(..) | Def::Const(..) | Def::VariantCtor(..) => {\n-                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n             }\n             Def::StructCtor(..) => {\n-                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n \n                 if let Some(struct_def_id) =\n                         self.session.cstore.def_key(def_id).parent\n@@ -469,14 +474,15 @@ impl<'a> Resolver<'a> {\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n+                                             expansion,\n                                              span);\n-                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n \n                 for child in self.session.cstore.item_children(def_id) {\n                     let ns = if let Def::AssociatedTy(..) = child.def { TypeNS } else { ValueNS };\n                     let ident = Ident::with_empty_ctxt(child.name);\n                     self.define(module, ident, ns, (child.def, ty::Visibility::Public,\n-                                                    DUMMY_SP, Mark::root()));\n+                                                    DUMMY_SP, expansion));\n \n                     if self.session.cstore.associated_item_cloned(child.def.def_id())\n                            .method_has_self_argument {\n@@ -486,31 +492,42 @@ impl<'a> Resolver<'a> {\n                 module.populated.set(true);\n             }\n             Def::Struct(..) | Def::Union(..) => {\n-                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::Macro(..) => {\n-                self.define(parent, ident, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, MacroNS, (def, vis, DUMMY_SP, expansion));\n             }\n             _ => bug!(\"unexpected definition: {:?}\", def)\n         }\n     }\n \n-    fn get_extern_crate_root(&mut self, cnum: CrateNum, span: Span) -> Module<'a> {\n-        let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-        let name = self.session.cstore.crate_name(cnum);\n-        let macros_only = self.session.cstore.dep_kind(cnum).macros_only();\n-        let module_kind = ModuleKind::Def(Def::Mod(def_id), name);\n-        let arenas = self.arenas;\n-        *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n-            arenas.alloc_module(ModuleData::new(None, module_kind, def_id, span))\n-        })\n+    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n+        if def_id.krate == LOCAL_CRATE {\n+            return self.module_map[&def_id]\n+        }\n+\n+        let macros_only = self.session.cstore.dep_kind(def_id.krate).macros_only();\n+        if let Some(&module) = self.extern_module_map.get(&(def_id, macros_only)) {\n+            return module;\n+        }\n+\n+        let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n+            (self.session.cstore.crate_name(def_id.krate), None)\n+        } else {\n+            let def_key = self.session.cstore.def_key(def_id);\n+            (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n+             Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n+        };\n+\n+        let kind = ModuleKind::Def(Def::Mod(def_id), name);\n+        self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP))\n     }\n \n-    pub fn macro_def_scope(&mut self, expansion: Mark, span: Span) -> Module<'a> {\n+    pub fn macro_def_scope(&mut self, expansion: Mark) -> Module<'a> {\n         let def_id = self.macro_defs[&expansion];\n         if let Some(id) = self.definitions.as_local_node_id(def_id) {\n             self.local_macro_def_scopes[&id]\n@@ -519,7 +536,7 @@ impl<'a> Resolver<'a> {\n             self.graph_root\n         } else {\n             let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n-            self.get_extern_crate_root(module_def_id.krate, span)\n+            self.get_module(module_def_id)\n         }\n     }\n \n@@ -766,7 +783,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_block(&mut self, block: &'a Block) {\n         let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n-        self.resolver.build_reduced_graph_for_block(block);\n+        self.resolver.build_reduced_graph_for_block(block, self.expansion);\n         visit::walk_block(self, block);\n         self.resolver.current_module = parent;\n         self.legacy_scope = legacy_scope;"}, {"sha": "180a608e631040d75acb263f3237cd784264ae6f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 152, "deletions": 64, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -43,15 +43,15 @@ use rustc::middle::cstore::CrateLoader;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n-use syntax::ext::base::Determinacy::{Determined, Undetermined};\n+use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -861,6 +861,8 @@ pub struct ModuleData<'a> {\n \n     /// Span of the module itself. Used for error reporting.\n     span: Span,\n+\n+    expansion: Mark,\n }\n \n pub type Module<'a> = &'a ModuleData<'a>;\n@@ -869,6 +871,7 @@ impl<'a> ModuleData<'a> {\n     fn new(parent: Option<Module<'a>>,\n            kind: ModuleKind,\n            normal_ancestor_id: DefId,\n+           expansion: Mark,\n            span: Span) -> Self {\n         ModuleData {\n             parent: parent,\n@@ -884,6 +887,7 @@ impl<'a> ModuleData<'a> {\n             traits: RefCell::new(None),\n             populated: Cell::new(normal_ancestor_id.is_local()),\n             span: span,\n+            expansion: expansion,\n         }\n     }\n \n@@ -1165,7 +1169,7 @@ pub struct Resolver<'a> {\n     // entry block for `f`.\n     block_map: NodeMap<Module<'a>>,\n     module_map: FxHashMap<DefId, Module<'a>>,\n-    extern_crate_roots: FxHashMap<(CrateNum, bool /* MacrosOnly? */), Module<'a>>,\n+    extern_module_map: FxHashMap<(DefId, bool /* MacrosOnly? */), Module<'a>>,\n \n     pub make_glob_map: bool,\n     // Maps imports to the names of items actually imported (this actually maps\n@@ -1185,9 +1189,9 @@ pub struct Resolver<'a> {\n     use_extern_macros: bool, // true if `#![feature(use_extern_macros)]`\n \n     crate_loader: &'a mut CrateLoader,\n-    macro_names: FxHashSet<Name>,\n+    macro_names: FxHashSet<Ident>,\n     global_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n-    lexical_macro_resolutions: Vec<(Name, &'a Cell<LegacyScope<'a>>)>,\n+    lexical_macro_resolutions: Vec<(Ident, &'a Cell<LegacyScope<'a>>)>,\n     macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n     macro_defs: FxHashMap<Mark, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n@@ -1310,7 +1314,7 @@ impl<'a> Resolver<'a> {\n         let root_module_kind = ModuleKind::Def(Def::Mod(root_def_id), keywords::Invalid.name());\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n-            ..ModuleData::new(None, root_module_kind, root_def_id, krate.span)\n+            ..ModuleData::new(None, root_module_kind, root_def_id, Mark::root(), krate.span)\n         });\n         let mut module_map = FxHashMap();\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n@@ -1364,7 +1368,7 @@ impl<'a> Resolver<'a> {\n             trait_map: NodeMap(),\n             module_map: module_map,\n             block_map: NodeMap(),\n-            extern_crate_roots: FxHashMap(),\n+            extern_module_map: FxHashMap(),\n \n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n@@ -1449,9 +1453,11 @@ impl<'a> Resolver<'a> {\n         parent: Module<'a>,\n         kind: ModuleKind,\n         normal_ancestor_id: DefId,\n+        expansion: Mark,\n         span: Span,\n     ) -> Module<'a> {\n-        self.arenas.alloc_module(ModuleData::new(Some(parent), kind, normal_ancestor_id, span))\n+        let module = ModuleData::new(Some(parent), kind, normal_ancestor_id, expansion, span);\n+        self.arenas.alloc_module(module)\n     }\n \n     fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n@@ -1513,10 +1519,11 @@ impl<'a> Resolver<'a> {\n                                       path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n-            ident = ident.unhygienize();\n+            ident.ctxt = ident.ctxt.modern();\n         }\n \n         // Walk backwards up the ribs in scope.\n+        let mut module = self.graph_root;\n         for i in (0 .. self.ribs[ns].len()).rev() {\n             if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n@@ -1525,45 +1532,120 @@ impl<'a> Resolver<'a> {\n                 ));\n             }\n \n-            if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n-                let item = self.resolve_ident_in_module(module, ident, ns, false,\n-                                                        record_used, path_span);\n-                if let Ok(binding) = item {\n-                    // The ident resolves to an item.\n-                    return Some(LexicalScopeBinding::Item(binding));\n+            module = match self.ribs[ns][i].kind {\n+                ModuleRibKind(module) => module,\n+                MacroDefinition(def) if def == self.macro_defs[&ident.ctxt.outer()] => {\n+                    // If an invocation of this macro created `ident`, give up on `ident`\n+                    // and switch to `ident`'s source from the macro definition.\n+                    ident.ctxt.remove_mark();\n+                    continue\n                 }\n+                _ => continue,\n+            };\n \n-                if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n-                } else if !module.no_implicit_prelude {\n-                    return self.prelude.and_then(|prelude| {\n-                        self.resolve_ident_in_module(prelude, ident, ns, false,\n-                                                     false, path_span).ok()\n-                    }).map(LexicalScopeBinding::Item)\n-                } else {\n-                    return None;\n-                }\n+            let item = self.resolve_ident_in_module_unadjusted(\n+                module, ident, ns, false, record_used, path_span,\n+            );\n+            if let Ok(binding) = item {\n+                // The ident resolves to an item.\n+                return Some(LexicalScopeBinding::Item(binding));\n             }\n \n-            if let MacroDefinition(def) = self.ribs[ns][i].kind {\n-                // If an invocation of this macro created `ident`, give up on `ident`\n-                // and switch to `ident`'s source from the macro definition.\n-                let ctxt_data = ident.ctxt.data();\n-                if def == self.macro_defs[&ctxt_data.outer_mark] {\n-                    ident.ctxt = ctxt_data.prev_ctxt;\n-                }\n+            match module.kind {\n+                ModuleKind::Block(..) => {}, // We can see through blocks\n+                _ => break,\n+            }\n+        }\n+\n+        ident.ctxt = ident.ctxt.modern();\n+        loop {\n+            module = unwrap_or!(self.hygienic_lexical_parent(module, &mut ident.ctxt), break);\n+            let orig_current_module = self.current_module;\n+            self.current_module = module; // Lexical resolutions can never be a privacy error.\n+            let result = self.resolve_ident_in_module_unadjusted(\n+                module, ident, ns, false, record_used, path_span,\n+            );\n+            self.current_module = orig_current_module;\n+\n+            match result {\n+                Ok(binding) => return Some(LexicalScopeBinding::Item(binding)),\n+                Err(Undetermined) => return None,\n+                Err(Determined) => {}\n+            }\n+        }\n+\n+        match self.prelude {\n+            Some(prelude) if !module.no_implicit_prelude => {\n+                self.resolve_ident_in_module_unadjusted(prelude, ident, ns, false, false, path_span)\n+                    .ok().map(LexicalScopeBinding::Item)\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn hygienic_lexical_parent(&mut self, mut module: Module<'a>, ctxt: &mut SyntaxContext)\n+                               -> Option<Module<'a>> {\n+        if !module.expansion.is_descendant_of(ctxt.outer()) {\n+            return Some(self.macro_def_scope(ctxt.remove_mark()));\n+        }\n+\n+        if let ModuleKind::Block(..) = module.kind {\n+            return Some(module.parent.unwrap());\n+        }\n+\n+        let mut module_expansion = module.expansion.modern(); // for backward compatability\n+        while let Some(parent) = module.parent {\n+            let parent_expansion = parent.expansion.modern();\n+            if module_expansion.is_descendant_of(parent_expansion) &&\n+               parent_expansion != module_expansion {\n+                return if parent_expansion.is_descendant_of(ctxt.outer()) {\n+                    Some(parent)\n+                } else {\n+                    None\n+                };\n             }\n+            module = parent;\n+            module_expansion = parent_expansion;\n         }\n \n         None\n     }\n \n-    fn resolve_crate_var(&mut self, crate_var_ctxt: SyntaxContext, span: Span) -> Module<'a> {\n-        let mut ctxt_data = crate_var_ctxt.data();\n-        while ctxt_data.prev_ctxt != SyntaxContext::empty() {\n-            ctxt_data = ctxt_data.prev_ctxt.data();\n+    fn resolve_ident_in_module(&mut self,\n+                               module: Module<'a>,\n+                               mut ident: Ident,\n+                               ns: Namespace,\n+                               ignore_unresolved_invocations: bool,\n+                               record_used: bool,\n+                               span: Span)\n+                               -> Result<&'a NameBinding<'a>, Determinacy> {\n+        ident.ctxt = ident.ctxt.modern();\n+        let orig_current_module = self.current_module;\n+        if let Some(def) = ident.ctxt.adjust(module.expansion) {\n+            self.current_module = self.macro_def_scope(def);\n+        }\n+        let result = self.resolve_ident_in_module_unadjusted(\n+            module, ident, ns, ignore_unresolved_invocations, record_used, span,\n+        );\n+        self.current_module = orig_current_module;\n+        result\n+    }\n+\n+    fn resolve_crate_root(&mut self, mut ctxt: SyntaxContext) -> Module<'a> {\n+        let module = match ctxt.adjust(Mark::root()) {\n+            Some(def) => self.macro_def_scope(def),\n+            None => return self.graph_root,\n+        };\n+        self.get_module(DefId { index: CRATE_DEF_INDEX, ..module.normal_ancestor_id })\n+    }\n+\n+    fn resolve_self(&mut self, ctxt: &mut SyntaxContext, module: Module<'a>) -> Module<'a> {\n+        let mut module = self.get_module(module.normal_ancestor_id);\n+        while module.span.ctxt.modern() != *ctxt {\n+            let parent = module.parent.unwrap_or_else(|| self.macro_def_scope(ctxt.remove_mark()));\n+            module = self.get_module(parent.normal_ancestor_id);\n         }\n-        let module = self.macro_def_scope(ctxt_data.outer_mark, span);\n-        if module.is_local() { self.graph_root } else { module }\n+        module\n     }\n \n     // AST resolution\n@@ -1611,15 +1693,12 @@ impl<'a> Resolver<'a> {\n     fn search_label(&self, mut ident: Ident) -> Option<Def> {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n-                NormalRibKind => {\n-                    // Continue\n-                }\n+                NormalRibKind => {}\n+                // If an invocation of this macro created `ident`, give up on `ident`\n+                // and switch to `ident`'s source from the macro definition.\n                 MacroDefinition(def) => {\n-                    // If an invocation of this macro created `ident`, give up on `ident`\n-                    // and switch to `ident`'s source from the macro definition.\n-                    let ctxt_data = ident.ctxt.data();\n-                    if def == self.macro_defs[&ctxt_data.outer_mark] {\n-                        ident.ctxt = ctxt_data.prev_ctxt;\n+                    if def == self.macro_defs[&ident.ctxt.outer()] {\n+                        ident.ctxt.remove_mark();\n                     }\n                 }\n                 _ => {\n@@ -1751,7 +1830,7 @@ impl<'a> Resolver<'a> {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = FxHashMap();\n                 for type_parameter in &generics.ty_params {\n-                    let ident = type_parameter.ident.unhygienize();\n+                    let ident = type_parameter.ident.modern();\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n                     if seen_bindings.contains_key(&ident) {\n@@ -2504,7 +2583,7 @@ impl<'a> Resolver<'a> {\n         }\n         let is_global = self.global_macros.get(&path[0].name).cloned()\n             .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n-        if primary_ns != MacroNS && (is_global || self.macro_names.contains(&path[0].name)) {\n+        if primary_ns != MacroNS && (is_global || self.macro_names.contains(&path[0].modern())) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n@@ -2613,13 +2692,17 @@ impl<'a> Resolver<'a> {\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n \n             if i == 0 && ns == TypeNS && ident.name == keywords::SelfValue.name() {\n-                module = Some(self.module_map[&self.current_module.normal_ancestor_id]);\n+                let mut ctxt = ident.ctxt.modern();\n+                module = Some(self.resolve_self(&mut ctxt, self.current_module));\n                 continue\n             } else if allow_super && ns == TypeNS && ident.name == keywords::Super.name() {\n-                let current_module = if i == 0 { self.current_module } else { module.unwrap() };\n-                let self_module = self.module_map[&current_module.normal_ancestor_id];\n+                let mut ctxt = ident.ctxt.modern();\n+                let self_module = match i {\n+                    0 => self.resolve_self(&mut ctxt, self.current_module),\n+                    _ => module.unwrap(),\n+                };\n                 if let Some(parent) = self_module.parent {\n-                    module = Some(self.module_map[&parent.normal_ancestor_id]);\n+                    module = Some(self.resolve_self(&mut ctxt, parent));\n                     continue\n                 } else {\n                     let msg = \"There are too many initial `super`s.\".to_string();\n@@ -2629,10 +2712,10 @@ impl<'a> Resolver<'a> {\n             allow_super = false;\n \n             if i == 0 && ns == TypeNS && ident.name == keywords::CrateRoot.name() {\n-                module = Some(self.graph_root);\n+                module = Some(self.resolve_crate_root(ident.ctxt.modern()));\n                 continue\n             } else if i == 0 && ns == TypeNS && ident.name == \"$crate\" {\n-                module = Some(self.resolve_crate_var(ident.ctxt, path_span));\n+                module = Some(self.resolve_crate_root(ident.ctxt));\n                 continue\n             }\n \n@@ -3108,7 +3191,8 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn get_traits_containing_item(&mut self, ident: Ident, ns: Namespace) -> Vec<TraitCandidate> {\n+    fn get_traits_containing_item(&mut self, mut ident: Ident, ns: Namespace)\n+                                  -> Vec<TraitCandidate> {\n         debug!(\"(getting traits containing item) looking for '{}'\", ident.name);\n \n         let mut found_traits = Vec::new();\n@@ -3120,13 +3204,12 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n+        ident.ctxt = ident.ctxt.modern();\n         let mut search_module = self.current_module;\n         loop {\n             self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n-            match search_module.kind {\n-                ModuleKind::Block(..) => search_module = search_module.parent.unwrap(),\n-                _ => break,\n-            }\n+            search_module =\n+                unwrap_or!(self.hygienic_lexical_parent(search_module, &mut ident.ctxt), break);\n         }\n \n         if let Some(prelude) = self.prelude {\n@@ -3157,7 +3240,12 @@ impl<'a> Resolver<'a> {\n \n         for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n             let module = binding.module().unwrap();\n-            if self.resolve_ident_in_module(module, ident, ns, false, false, module.span).is_ok() {\n+            let mut ident = ident;\n+            if ident.ctxt.glob_adjust(module.expansion, binding.span.ctxt.modern()).is_none() {\n+                continue\n+            }\n+            if self.resolve_ident_in_module_unadjusted(module, ident, ns, false, false, module.span)\n+                   .is_ok() {\n                 let import_id = match binding.kind {\n                     NameBindingKind::Import { directive, .. } => {\n                         self.maybe_unused_trait_imports.insert(directive.id);\n@@ -3348,15 +3436,15 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn report_shadowing_errors(&mut self) {\n-        for (name, scope) in replace(&mut self.lexical_macro_resolutions, Vec::new()) {\n-            self.resolve_legacy_scope(scope, name, true);\n+        for (ident, scope) in replace(&mut self.lexical_macro_resolutions, Vec::new()) {\n+            self.resolve_legacy_scope(scope, ident, true);\n         }\n \n         let mut reported_errors = FxHashSet();\n         for binding in replace(&mut self.disallowed_shadowing, Vec::new()) {\n-            if self.resolve_legacy_scope(&binding.parent, binding.name, false).is_some() &&\n-               reported_errors.insert((binding.name, binding.span)) {\n-                let msg = format!(\"`{}` is already in scope\", binding.name);\n+            if self.resolve_legacy_scope(&binding.parent, binding.ident, false).is_some() &&\n+               reported_errors.insert((binding.ident, binding.span)) {\n+                let msg = format!(\"`{}` is already in scope\", binding.ident);\n                 self.session.struct_span_err(binding.span, &msg)\n                     .note(\"macro-expanded `macro_rules!`s may not shadow \\\n                            existing macros (see RFC 1560)\")"}, {"sha": "9aba892e0ff5eb3df58eca83329b29f44fbd0071", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -76,7 +76,7 @@ pub enum LegacyScope<'a> {\n \n pub struct LegacyBinding<'a> {\n     pub parent: Cell<LegacyScope<'a>>,\n-    pub name: ast::Name,\n+    pub ident: Ident,\n     def_id: DefId,\n     pub span: Span,\n }\n@@ -110,7 +110,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n-        let mark = Mark::fresh();\n+        let mark = Mark::fresh(Mark::root());\n         let module = self.module_map[&self.definitions.local_def_id(id)];\n         self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n             module: Cell::new(module),\n@@ -130,7 +130,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 let ident = path.segments[0].identifier;\n                 if ident.name == \"$crate\" {\n                     path.segments[0].identifier.name = keywords::CrateRoot.name();\n-                    let module = self.0.resolve_crate_var(ident.ctxt, self.1);\n+                    let module = self.0.resolve_crate_root(ident.ctxt);\n                     if !module.is_local() {\n                         let span = path.segments[0].span;\n                         path.segments.insert(1, match module.kind {\n@@ -292,7 +292,11 @@ impl<'a> base::Resolver for Resolver<'a> {\n         };\n         self.macro_defs.insert(invoc.expansion_data.mark, def.def_id());\n         self.unused_macros.remove(&def.def_id());\n-        Ok(Some(self.get_macro(def)))\n+        let ext = self.get_macro(def);\n+        if ext.is_modern() {\n+            invoc.expansion_data.mark.set_modern();\n+        }\n+        Ok(Some(ext))\n     }\n \n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n@@ -416,8 +420,7 @@ impl<'a> Resolver<'a> {\n             return def;\n         }\n \n-        let name = path[0].name;\n-        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, name, false);\n+        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n         let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n             Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n         } else {\n@@ -439,26 +442,31 @@ impl<'a> Resolver<'a> {\n \n     // Resolve the initial segment of a non-global macro path (e.g. `foo` in `foo::bar!();`)\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n-                                              ident: Ident,\n+                                              mut ident: Ident,\n                                               ns: Namespace,\n                                               record_used: bool,\n                                               path_span: Span)\n                                               -> Result<MacroBinding<'a>, Determinacy> {\n+        ident = ident.modern();\n         let mut module = Some(self.current_module);\n         let mut potential_illegal_shadower = Err(Determinacy::Determined);\n         let determinacy =\n             if record_used { Determinacy::Determined } else { Determinacy::Undetermined };\n         loop {\n+            let orig_current_module = self.current_module;\n             let result = if let Some(module) = module {\n+                self.current_module = module; // Lexical resolutions can never be a privacy error.\n                 // Since expanded macros may not shadow the lexical scope and\n                 // globs may not shadow global macros (both enforced below),\n                 // we resolve with restricted shadowing (indicated by the penultimate argument).\n-                self.resolve_ident_in_module(module, ident, ns, true, record_used, path_span)\n-                    .map(MacroBinding::Modern)\n+                self.resolve_ident_in_module_unadjusted(\n+                    module, ident, ns, true, record_used, path_span,\n+                ).map(MacroBinding::Modern)\n             } else {\n                 self.global_macros.get(&ident.name).cloned().ok_or(determinacy)\n                     .map(MacroBinding::Global)\n             };\n+            self.current_module = orig_current_module;\n \n             match result.map(MacroBinding::binding) {\n                 Ok(binding) => {\n@@ -491,20 +499,18 @@ impl<'a> Resolver<'a> {\n             }\n \n             module = match module {\n-                Some(module) => match module.kind {\n-                    ModuleKind::Block(..) => module.parent,\n-                    ModuleKind::Def(..) => None,\n-                },\n+                Some(module) => self.hygienic_lexical_parent(module, &mut ident.ctxt),\n                 None => return potential_illegal_shadower,\n             }\n         }\n     }\n \n     pub fn resolve_legacy_scope(&mut self,\n                                 mut scope: &'a Cell<LegacyScope<'a>>,\n-                                name: Name,\n+                                ident: Ident,\n                                 record_used: bool)\n                                 -> Option<MacroBinding<'a>> {\n+        let ident = ident.modern();\n         let mut possible_time_travel = None;\n         let mut relative_depth: u32 = 0;\n         let mut binding = None;\n@@ -531,7 +537,7 @@ impl<'a> Resolver<'a> {\n                     scope = &invocation.legacy_scope;\n                 }\n                 LegacyScope::Binding(potential_binding) => {\n-                    if potential_binding.name == name {\n+                    if potential_binding.ident == ident {\n                         if (!self.use_extern_macros || record_used) && relative_depth > 0 {\n                             self.disallowed_shadowing.push(potential_binding);\n                         }\n@@ -545,9 +551,9 @@ impl<'a> Resolver<'a> {\n \n         let binding = if let Some(binding) = binding {\n             MacroBinding::Legacy(binding)\n-        } else if let Some(binding) = self.global_macros.get(&name).cloned() {\n+        } else if let Some(binding) = self.global_macros.get(&ident.name).cloned() {\n             if !self.use_extern_macros {\n-                self.record_use(Ident::with_empty_ctxt(name), MacroNS, binding, DUMMY_SP);\n+                self.record_use(ident, MacroNS, binding, DUMMY_SP);\n             }\n             MacroBinding::Global(binding)\n         } else {\n@@ -557,7 +563,7 @@ impl<'a> Resolver<'a> {\n         if !self.use_extern_macros {\n             if let Some(scope) = possible_time_travel {\n                 // Check for disallowed shadowing later\n-                self.lexical_macro_resolutions.push((name, scope));\n+                self.lexical_macro_resolutions.push((ident, scope));\n             }\n         }\n \n@@ -578,7 +584,7 @@ impl<'a> Resolver<'a> {\n \n         for &(mark, ident, span, kind) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n-            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n+            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident, true);\n             let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, span);\n             match (legacy_resolution, resolution) {\n                 (Some(MacroBinding::Legacy(legacy_binding)), Ok(MacroBinding::Modern(binding))) => {\n@@ -615,7 +621,7 @@ impl<'a> Resolver<'a> {\n                           err: &mut DiagnosticBuilder<'a>, span: Span) {\n         // First check if this is a locally-defined bang macro.\n         let suggestion = if let MacroKind::Bang = kind {\n-            find_best_match_for_name(self.macro_names.iter(), name, None)\n+            find_best_match_for_name(self.macro_names.iter().map(|ident| &ident.name), name, None)\n         } else {\n             None\n         // Then check global macros.\n@@ -705,9 +711,10 @@ impl<'a> Resolver<'a> {\n \n         let def = match item.node { ast::ItemKind::MacroDef(ref def) => def, _ => unreachable!() };\n         if def.legacy {\n-            self.macro_names.insert(ident.name);\n+            let ident = ident.modern();\n+            self.macro_names.insert(ident);\n             *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n-                parent: Cell::new(*legacy_scope), name: ident.name, def_id: def_id, span: item.span,\n+                parent: Cell::new(*legacy_scope), ident: ident, def_id: def_id, span: item.span,\n             }));\n             if attr::contains_name(&item.attrs, \"macro_export\") {\n                 let def = Def::Macro(def_id, MacroKind::Bang);"}, {"sha": "f304aad4638cead713a6b555c1dbeebe91af3e98", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -134,21 +134,20 @@ impl<'a> NameResolution<'a> {\n impl<'a> Resolver<'a> {\n     fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n                   -> &'a RefCell<NameResolution<'a>> {\n-        let ident = ident.unhygienize();\n-        *module.resolutions.borrow_mut().entry((ident, ns))\n+        *module.resolutions.borrow_mut().entry((ident.modern(), ns))\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n \n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n     /// Invariant: if `record_used` is `Some`, import resolution must be complete.\n-    pub fn resolve_ident_in_module(&mut self,\n-                                   module: Module<'a>,\n-                                   ident: Ident,\n-                                   ns: Namespace,\n-                                   restricted_shadowing: bool,\n-                                   record_used: bool,\n-                                   path_span: Span)\n-                                   -> Result<&'a NameBinding<'a>, Determinacy> {\n+    pub fn resolve_ident_in_module_unadjusted(&mut self,\n+                                              module: Module<'a>,\n+                                              ident: Ident,\n+                                              ns: Namespace,\n+                                              restricted_shadowing: bool,\n+                                              record_used: bool,\n+                                              path_span: Span)\n+                                              -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.populate_module_if_necessary(module);\n \n         let resolution = self.resolution(module, ident, ns)\n@@ -233,20 +232,22 @@ impl<'a> Resolver<'a> {\n             return Err(Determined);\n         }\n         for directive in module.globs.borrow().iter() {\n-            if self.is_accessible(directive.vis.get()) {\n-                if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_ident_in_module(module,\n-                                                              ident,\n-                                                              ns,\n-                                                              false,\n-                                                              false,\n-                                                              path_span);\n-                    if let Err(Undetermined) = result {\n-                        return Err(Undetermined);\n-                    }\n-                } else {\n-                    return Err(Undetermined);\n-                }\n+            if !self.is_accessible(directive.vis.get()) {\n+                continue\n+            }\n+            let module = unwrap_or!(directive.imported_module.get(), return Err(Undetermined));\n+            let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n+            match ident.ctxt.glob_adjust(module.expansion, directive.span.ctxt.modern()) {\n+                Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n+                Some(None) => {}\n+                None => continue,\n+            };\n+            let result = self.resolve_ident_in_module_unadjusted(\n+                module, ident, ns, false, false, path_span,\n+            );\n+            self.current_module = orig_current_module;\n+            if let Err(Undetermined) = result {\n+                return Err(Undetermined);\n             }\n         }\n \n@@ -394,7 +395,14 @@ impl<'a> Resolver<'a> {\n \n         // Define `binding` in `module`s glob importers.\n         for directive in module.glob_importers.borrow_mut().iter() {\n-            if self.is_accessible_from(binding.vis, directive.parent) {\n+            let mut ident = ident.modern();\n+            let scope = match ident.ctxt.reverse_glob_adjust(module.expansion,\n+                                                             directive.span.ctxt.modern()) {\n+                Some(Some(def)) => self.macro_def_scope(def),\n+                Some(None) => directive.parent,\n+                None => continue,\n+            };\n+            if self.is_accessible_from(binding.vis, scope) {\n                 let imported_binding = self.import(binding, directive);\n                 let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }\n@@ -767,8 +775,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let bindings = module.resolutions.borrow().iter().filter_map(|(&ident, resolution)| {\n             resolution.borrow().binding().map(|binding| (ident, binding))\n         }).collect::<Vec<_>>();\n-        for ((ident, ns), binding) in bindings {\n-            if binding.pseudo_vis() == ty::Visibility::Public || self.is_accessible(binding.vis) {\n+        for ((mut ident, ns), binding) in bindings {\n+            let scope = match ident.ctxt.reverse_glob_adjust(module.expansion,\n+                                                             directive.span.ctxt.modern()) {\n+                Some(Some(def)) => self.macro_def_scope(def),\n+                Some(None) => self.current_module,\n+                None => continue,\n+            };\n+            if self.is_accessible_from(binding.pseudo_vis(), scope) {\n                 let imported_binding = self.import(binding, directive);\n                 let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }"}, {"sha": "71dc81c37592322da76ee9bddf245d21577ec2ae", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -550,12 +550,16 @@ pub enum SyntaxExtension {\n \n     /// An attribute-like procedural macro that derives a builtin trait.\n     BuiltinDerive(BuiltinDeriveFn),\n+\n+    /// A declarative macro, e.g. `macro m() {}`.\n+    DeclMacro(Box<TTMacroExpander>, Option<Span> /* definition site span */),\n }\n \n impl SyntaxExtension {\n     /// Return which kind of macro calls this syntax extension.\n     pub fn kind(&self) -> MacroKind {\n         match *self {\n+            SyntaxExtension::DeclMacro(..) |\n             SyntaxExtension::NormalTT(..) |\n             SyntaxExtension::IdentTT(..) |\n             SyntaxExtension::ProcMacro(..) =>\n@@ -569,6 +573,13 @@ impl SyntaxExtension {\n                 MacroKind::Derive,\n         }\n     }\n+\n+    pub fn is_modern(&self) -> bool {\n+        match *self {\n+            SyntaxExtension::DeclMacro(..) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);"}, {"sha": "be077b481113f12c17fad392137df5465040e1b2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -288,7 +288,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let derives = derives.entry(invoc.expansion_data.mark).or_insert_with(Vec::new);\n \n                     for path in &traits {\n-                        let mark = Mark::fresh();\n+                        let mark = Mark::fresh(self.cx.current_expansion.mark);\n                         derives.push(mark);\n                         let item = match self.cx.resolver.resolve_macro(\n                                 Mark::root(), path, MacroKind::Derive, false) {\n@@ -455,25 +455,37 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let path = &mac.node.path;\n \n         let ident = ident.unwrap_or_else(|| keywords::Invalid.ident());\n+        let validate_and_set_expn_info = |def_site_span, allow_internal_unstable| {\n+            if ident.name != keywords::Invalid.name() {\n+                return Err(format!(\"macro {}! expects no ident argument, given '{}'\", path, ident));\n+            }\n+            mark.set_expn_info(ExpnInfo {\n+                call_site: span,\n+                callee: NameAndSpan {\n+                    format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n+                    span: def_site_span,\n+                    allow_internal_unstable: allow_internal_unstable,\n+                },\n+            });\n+            Ok(())\n+        };\n+\n         let marked_tts = noop_fold_tts(mac.node.stream(), &mut Marker(mark));\n         let opt_expanded = match *ext {\n-            NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n-                if ident.name != keywords::Invalid.name() {\n-                    let msg =\n-                        format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n+            SyntaxExtension::DeclMacro(ref expand, def_site_span) => {\n+                if let Err(msg) = validate_and_set_expn_info(def_site_span, false) {\n                     self.cx.span_err(path.span, &msg);\n                     return kind.dummy(span);\n                 }\n+                kind.make_from(expand.expand(self.cx, span, marked_tts))\n+            }\n \n-                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                    call_site: span,\n-                    callee: NameAndSpan {\n-                        format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n-                        span: exp_span.map(|(_, s)| s),\n-                        allow_internal_unstable: allow_internal_unstable,\n-                    },\n-                });\n-\n+            NormalTT(ref expandfun, def_info, allow_internal_unstable) => {\n+                if let Err(msg) = validate_and_set_expn_info(def_info.map(|(_, s)| s),\n+                                                             allow_internal_unstable) {\n+                    self.cx.span_err(path.span, &msg);\n+                    return kind.dummy(span);\n+                }\n                 kind.make_from(expandfun.expand(self.cx, span, marked_tts))\n             }\n \n@@ -687,7 +699,7 @@ macro_rules! fully_configure {\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, expansion_kind: ExpansionKind, kind: InvocationKind) -> Expansion {\n-        let mark = Mark::fresh();\n+        let mark = Mark::fresh(self.cx.current_expansion.mark);\n         self.invocations.push(Invocation {\n             kind: kind,\n             expansion_kind: expansion_kind,"}, {"sha": "a9252d0818e38039a1152589515cc821b1a156d3", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -253,9 +253,12 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n         valid: valid,\n     });\n \n-    NormalTT(exp,\n-             Some((def.id, def.span)),\n-             attr::contains_name(&def.attrs, \"allow_internal_unstable\"))\n+    if body.legacy {\n+        let allow_internal_unstable = attr::contains_name(&def.attrs, \"allow_internal_unstable\");\n+        NormalTT(exp, Some((def.id, def.span)), allow_internal_unstable)\n+    } else {\n+        SyntaxExtension::DeclMacro(exp, Some(def.span))\n+    }\n }\n \n fn check_lhs_nt_follows(sess: &ParseSess,"}, {"sha": "5bbda5f2689d308a91e048026e5bf6df7b9e11e0", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -428,7 +428,7 @@ pub fn noop_fold_global_asm<T: Folder>(ga: P<GlobalAsm>,\n pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n     Spanned {\n         node: Variant_ {\n-            name: v.node.name,\n+            name: fld.fold_ident(v.node.name),\n             attrs: fold_attrs(v.node.attrs, fld),\n             data: fld.fold_variant_data(v.node.data),\n             disr_expr: v.node.disr_expr.map(|e| fld.fold_expr(e)),"}, {"sha": "a8a9ae556f1084509a43ecd8c961ca7d3d93346e", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -21,7 +21,7 @@ use tokenstream::TokenStream;\n /// call to codemap's `is_internal` check.\n /// The expanded code uses the unstable `#[prelude_import]` attribute.\n fn ignored_span(sp: Span) -> Span {\n-    let mark = Mark::fresh();\n+    let mark = Mark::fresh(Mark::root());\n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {"}, {"sha": "3df61fadc350382dd31a3d146e48c70969420bed", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -276,7 +276,7 @@ fn generate_test_harness(sess: &ParseSess,\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n \n-    let mark = Mark::fresh();\n+    let mark = Mark::fresh(Mark::root());\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,"}, {"sha": "00dcfc7a587069a2294d750d2a92a2a2ecba14ae", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -162,7 +162,7 @@ fn call_intrinsic(cx: &ExtCtxt,\n     } else { // Avoid instability errors with user defined curstom derives, cc #36316\n         let mut info = cx.current_expansion.mark.expn_info().unwrap();\n         info.callee.allow_internal_unstable = true;\n-        let mark = Mark::fresh();\n+        let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(info);\n         span.ctxt = SyntaxContext::empty().apply_mark(mark);\n     }"}, {"sha": "ab6d73e5061a0a5252834ca345137a95c3b46dc2", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -361,7 +361,7 @@ fn mk_registrar(cx: &mut ExtCtxt,\n                 custom_derives: &[ProcMacroDerive],\n                 custom_attrs: &[ProcMacroDef],\n                 custom_macros: &[ProcMacroDef]) -> P<ast::Item> {\n-    let mark = Mark::fresh();\n+    let mark = Mark::fresh(Mark::root());\n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {"}, {"sha": "24a21faa7eb9ad45b0e1e8c53d128bd2070a1cad", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 170, "deletions": 22, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -24,23 +24,31 @@ use std::collections::HashMap;\n use std::fmt;\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n pub struct SyntaxContext(u32);\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Default)]\n pub struct SyntaxContextData {\n     pub outer_mark: Mark,\n     pub prev_ctxt: SyntaxContext,\n+    pub modern: SyntaxContext,\n }\n \n /// A mark is a unique id associated with a macro expansion.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default, RustcEncodable, RustcDecodable)]\n pub struct Mark(u32);\n \n+#[derive(Default)]\n+struct MarkData {\n+    parent: Mark,\n+    modern: bool,\n+    expn_info: Option<ExpnInfo>,\n+}\n+\n impl Mark {\n-    pub fn fresh() -> Self {\n+    pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            data.marks.push(None);\n+            data.marks.push(MarkData { parent: parent, modern: false, expn_info: None });\n             Mark(data.marks.len() as u32 - 1)\n         })\n     }\n@@ -59,28 +67,52 @@ impl Mark {\n     }\n \n     pub fn expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.marks[self.0 as usize].clone())\n+        HygieneData::with(|data| data.marks[self.0 as usize].expn_info.clone())\n     }\n \n     pub fn set_expn_info(self, info: ExpnInfo) {\n-        HygieneData::with(|data| data.marks[self.0 as usize] = Some(info))\n+        HygieneData::with(|data| data.marks[self.0 as usize].expn_info = Some(info))\n+    }\n+\n+    pub fn modern(mut self) -> Mark {\n+        HygieneData::with(|data| {\n+            loop {\n+                if self == Mark::root() || data.marks[self.0 as usize].modern {\n+                    return self;\n+                }\n+                self = data.marks[self.0 as usize].parent;\n+            }\n+        })\n+    }\n+\n+    pub fn set_modern(self) {\n+        HygieneData::with(|data| data.marks[self.0 as usize].modern = true)\n+    }\n+\n+    pub fn is_descendant_of(mut self, ancestor: Mark) -> bool {\n+        HygieneData::with(|data| {\n+            while self != ancestor {\n+                if self == Mark::root() {\n+                    return false;\n+                }\n+                self = data.marks[self.0 as usize].parent;\n+            }\n+            true\n+        })\n     }\n }\n \n struct HygieneData {\n-    marks: Vec<Option<ExpnInfo>>,\n+    marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n     markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n }\n \n impl HygieneData {\n     fn new() -> Self {\n         HygieneData {\n-            marks: vec![None],\n-            syntax_contexts: vec![SyntaxContextData {\n-                outer_mark: Mark::root(),\n-                prev_ctxt: SyntaxContext::empty(),\n-            }],\n+            marks: vec![MarkData::default()],\n+            syntax_contexts: vec![SyntaxContextData::default()],\n             markings: HashMap::new(),\n         }\n     }\n@@ -102,30 +134,146 @@ impl SyntaxContext {\n         SyntaxContext(0)\n     }\n \n-    pub fn data(self) -> SyntaxContextData {\n-        HygieneData::with(|data| data.syntax_contexts[self.0 as usize])\n-    }\n-\n     /// Extend a syntax context with a given mark\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n-        // Applying the same mark twice is a no-op\n-        let ctxt_data = self.data();\n-        if mark == ctxt_data.outer_mark {\n-            return ctxt_data.prev_ctxt;\n-        }\n-\n         HygieneData::with(|data| {\n             let syntax_contexts = &mut data.syntax_contexts;\n+            let ctxt_data = syntax_contexts[self.0 as usize];\n+            if mark == ctxt_data.outer_mark {\n+                return ctxt_data.prev_ctxt;\n+            }\n+\n+            let modern = if data.marks[mark.0 as usize].modern {\n+                *data.markings.entry((ctxt_data.modern, mark)).or_insert_with(|| {\n+                    let modern = SyntaxContext(syntax_contexts.len() as u32);\n+                    syntax_contexts.push(SyntaxContextData {\n+                        outer_mark: mark,\n+                        prev_ctxt: ctxt_data.modern,\n+                        modern: modern,\n+                    });\n+                    modern\n+                })\n+            } else {\n+                ctxt_data.modern\n+            };\n+\n             *data.markings.entry((self, mark)).or_insert_with(|| {\n                 syntax_contexts.push(SyntaxContextData {\n                     outer_mark: mark,\n                     prev_ctxt: self,\n+                    modern: modern,\n                 });\n                 SyntaxContext(syntax_contexts.len() as u32 - 1)\n             })\n         })\n     }\n \n+    pub fn remove_mark(&mut self) -> Mark {\n+        HygieneData::with(|data| {\n+            let outer_mark = data.syntax_contexts[self.0 as usize].outer_mark;\n+            *self = data.syntax_contexts[self.0 as usize].prev_ctxt;\n+            outer_mark\n+        })\n+    }\n+\n+    /// Adjust this context for resolution in a scope created by the given expansion.\n+    /// For example, consider the following three resolutions of `f`:\n+    /// ```rust\n+    /// mod foo { pub fn f() {} } // `f`'s `SyntaxContext` is empty.\n+    /// m!(f);\n+    /// macro m($f:ident) {\n+    ///     mod bar {\n+    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `Mark` from `m`.\n+    ///         pub fn $f() {} // `$f`'s `SyntaxContext` is empty.\n+    ///     }\n+    ///     foo::f(); // `f`'s `SyntaxContext` has a single `Mark` from `m`\n+    ///     //^ Since `mod foo` is outside this expansion, `adjust` removes the mark from `f`,\n+    ///     //| and it resolves to `::foo::f`.\n+    ///     bar::f(); // `f`'s `SyntaxContext` has a single `Mark` from `m`\n+    ///     //^ Since `mod bar` not outside this expansion, `adjust` does not change `f`,\n+    ///     //| and it resolves to `::bar::f`.\n+    ///     bar::$f(); // `f`'s `SyntaxContext` is empty.\n+    ///     //^ Since `mod bar` is not outside this expansion, `adjust` does not change `$f`,\n+    ///     //| and it resolves to `::bar::$f`.\n+    /// }\n+    /// ```\n+    /// This returns the expansion whose definition scope we use to privacy check the resolution,\n+    /// or `None` if we privacy check as usual (i.e. not w.r.t. a macro definition scope).\n+    pub fn adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+        let mut scope = None;\n+        while !expansion.is_descendant_of(self.outer()) {\n+            scope = Some(self.remove_mark());\n+        }\n+        scope\n+    }\n+\n+    /// Adjust this context for resolution in a scope created by the given expansion\n+    /// via a glob import with the given `SyntaxContext`.\n+    /// For example,\n+    /// ```rust\n+    /// m!(f);\n+    /// macro m($i:ident) {\n+    ///     mod foo {\n+    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `Mark` from `m`.\n+    ///         pub fn $i() {} // `$i`'s `SyntaxContext` is empty.\n+    ///     }\n+    ///     n(f);\n+    ///     macro n($j:ident) {\n+    ///         use foo::*;\n+    ///         f(); // `f`'s `SyntaxContext` has a mark from `m` and a mark from `n`\n+    ///         //^ `glob_adjust` removes the mark from `n`, so this resolves to `foo::f`.\n+    ///         $i(); // `$i`'s `SyntaxContext` has a mark from `n`\n+    ///         //^ `glob_adjust` removes the mark from `n`, so this resolves to `foo::$i`.\n+    ///         $j(); // `$j`'s `SyntaxContext` has a mark from `m`\n+    ///         //^ This cannot be glob-adjusted, so this is a resolution error.\n+    ///     }\n+    /// }\n+    /// ```\n+    /// This returns `None` if the context cannot be glob-adjusted.\n+    /// Otherwise, it returns the scope to use when privacy checking (see `adjust` for details).\n+    pub fn glob_adjust(&mut self, expansion: Mark, mut glob_ctxt: SyntaxContext)\n+                       -> Option<Option<Mark>> {\n+        let mut scope = None;\n+        while !expansion.is_descendant_of(glob_ctxt.outer()) {\n+            scope = Some(glob_ctxt.remove_mark());\n+            if self.remove_mark() != scope.unwrap() {\n+                return None;\n+            }\n+        }\n+        if self.adjust(expansion).is_some() {\n+            return None;\n+        }\n+        Some(scope)\n+    }\n+\n+    /// Undo `glob_adjust` if possible:\n+    /// ```rust\n+    /// if let Some(privacy_checking_scope) = self.reverse_glob_adjust(expansion, glob_ctxt) {\n+    ///     assert!(self.glob_adjust(expansion, glob_ctxt) == Some(privacy_checking_scope));\n+    /// }\n+    /// ```\n+    pub fn reverse_glob_adjust(&mut self, expansion: Mark, mut glob_ctxt: SyntaxContext)\n+                               -> Option<Option<Mark>> {\n+        if self.adjust(expansion).is_some() {\n+            return None;\n+        }\n+\n+        let mut marks = Vec::new();\n+        while !expansion.is_descendant_of(glob_ctxt.outer()) {\n+            marks.push(glob_ctxt.remove_mark());\n+        }\n+\n+        let scope = marks.last().cloned();\n+        while let Some(mark) = marks.pop() {\n+            *self = self.apply_mark(mark);\n+        }\n+        Some(scope)\n+    }\n+\n+    pub fn modern(self) -> SyntaxContext {\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].modern)\n+    }\n+\n     pub fn outer(self) -> Mark {\n         HygieneData::with(|data| data.syntax_contexts[self.0 as usize].outer_mark)\n     }"}, {"sha": "070fab57afa82814454b3c85a226f17c0b8e945b", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f175fa35d4263f1d2c4c3433a495a78996305f4/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=1f175fa35d4263f1d2c4c3433a495a78996305f4", "patch": "@@ -35,8 +35,8 @@ impl Ident {\n         Ident::with_empty_ctxt(Symbol::intern(string))\n     }\n \n-    pub fn unhygienize(self) -> Ident {\n-        Ident { name: self.name, ctxt: SyntaxContext::empty() }\n+    pub fn modern(self) -> Ident {\n+        Ident { name: self.name, ctxt: self.ctxt.modern() }\n     }\n }\n "}]}