{"sha": "707944184304acbd81c026156a04b98570c6ef9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNzk0NDE4NDMwNGFjYmQ4MWMwMjYxNTZhMDRiOTg1NzBjNmVmOWM=", "commit": {"author": {"name": "Zack Corr", "email": "zack@z0w0.me", "date": "2013-01-23T01:19:13Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-16T02:04:10Z"}, "message": "rustpkg: Add preliminary imperative API support", "tree": {"sha": "f3cd82efda760e524f64b6b6a88a16fab988982a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3cd82efda760e524f64b6b6a88a16fab988982a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/707944184304acbd81c026156a04b98570c6ef9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/707944184304acbd81c026156a04b98570c6ef9c", "html_url": "https://github.com/rust-lang/rust/commit/707944184304acbd81c026156a04b98570c6ef9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/707944184304acbd81c026156a04b98570c6ef9c/comments", "author": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd28fa4af5b5200b274b8e965a422174fb7ad354", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd28fa4af5b5200b274b8e965a422174fb7ad354", "html_url": "https://github.com/rust-lang/rust/commit/bd28fa4af5b5200b274b8e965a422174fb7ad354"}], "stats": {"total": 1092, "additions": 811, "deletions": 281}, "files": [{"sha": "5fc284bc9fc49f30224ded62e48a15ae12bbdd7f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/707944184304acbd81c026156a04b98570c6ef9c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707944184304acbd81c026156a04b98570c6ef9c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=707944184304acbd81c026156a04b98570c6ef9c", "patch": "@@ -184,14 +184,14 @@ pub enum compile_upto {\n     cu_everything,\n }\n \n-pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n-                    input: input, upto: compile_upto,\n-                    outputs: Option<output_filenames>)\n-                 -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n+// For continuing compilation after a parsed crate has been\n+// modified\n+pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n+                    upto: compile_upto, outputs: Option<output_filenames>,\n+                    curr: Option<@ast::crate>)\n+    -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n     let time_passes = sess.time_passes();\n-    let mut crate = time(time_passes, ~\"parsing\",\n-                         || parse_input(sess, copy cfg, input) );\n-    if upto == cu_parse { return {crate: crate, tcx: None}; }\n+    let mut crate = curr.get();\n \n     *sess.building_library = session::building_library(\n         sess.opts.crate_type, crate, sess.opts.test);\n@@ -322,7 +322,6 @@ pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n \n     };\n \n-\n     time(time_passes, ~\"LLVM passes\", ||\n         link::write::run_passes(sess, llmod,\n                                 &outputs.obj_filename));\n@@ -342,9 +341,20 @@ pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n     return {crate: crate, tcx: None};\n }\n \n+pub fn compile_upto(sess: Session, +cfg: ast::crate_cfg,\n+                input: input, upto: compile_upto,\n+                outputs: Option<output_filenames>)\n+    -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n+    let time_passes = sess.time_passes();\n+    let mut crate = time(time_passes, ~\"parsing\",\n+                         || parse_input(sess, copy cfg, input) );\n+    if upto == cu_parse { return {crate: crate, tcx: None}; }\n+\n+    compile_rest(sess, cfg, upto, outputs, Some(crate))\n+}\n+\n pub fn compile_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n                      outdir: &Option<Path>, output: &Option<Path>) {\n-\n     let upto = if sess.opts.parse_only { cu_parse }\n                else if sess.opts.no_trans { cu_no_trans }\n                else { cu_everything };"}, {"sha": "d431db27e68404b530bd39ebbe40edc42cd5fb3e", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 111, "deletions": 5, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/707944184304acbd81c026156a04b98570c6ef9c/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707944184304acbd81c026156a04b98570c6ef9c/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=707944184304acbd81c026156a04b98570c6ef9c", "patch": "@@ -1,24 +1,130 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use core::*;\n+use util::{compile_crate, note};\n \n+/// A crate is a unit of Rust code to be compiled into a binary or library\n pub struct Crate {\n     file: ~str,\n     flags: ~[~str],\n-    cfg: ~[~str]\n+    cfgs: ~[~str]\n+}\n+\n+pub struct Listener {\n+    cmd: ~str,\n+    cb: fn~()\n+}\n+\n+pub fn run(listeners: ~[Listener]) {\n+    io::println(src_dir().to_str());\n+    io::println(work_dir().to_str());\n+\n+    let cmd = os::args()[1];\n+\n+    for listeners.each |listener| {\n+        if listener.cmd == cmd {\n+            (listener.cb)();\n+        }\n+    }\n }\n \n pub impl Crate {\n-    fn flag(flag: ~str) -> Crate {\n+   fn flag(flag: ~str) -> Crate {\n         Crate {\n             flags: vec::append(copy self.flags, ~[flag]),\n             .. copy self\n         }\n     }\n+\n+    fn flags(flags: ~[~str]) -> Crate {\n+        Crate {\n+            flags: vec::append(copy self.flags, flags),\n+            .. copy self\n+        }\n+    }\n+\n+   fn cfg(cfg: ~str) -> Crate {\n+        Crate {\n+            cfgs: vec::append(copy self.cfgs, ~[cfg]),\n+            .. copy self\n+        }\n+    }\n+\n+    fn cfgs(cfgs: ~[~str]) -> Crate {\n+        Crate {\n+            cfgs: vec::append(copy self.cfgs, cfgs),\n+            .. copy self\n+        }\n+    }\n+}\n+\n+/// Create a crate target from a source file\n+pub fn Crate(file: ~str) -> Crate {\n+    Crate {\n+        file: file,\n+        flags: ~[],\n+        cfgs: ~[]\n+    }\n }\n \n-pub fn build(_targets: ~[Crate]) {\n-    // TODO: magic\n+/** \n+ * Get the working directory of the package script.\n+ * Assumes that the package script has been compiled\n+ * in is the working directory.\n+ */\n+fn work_dir() -> Path {\n+    os::self_exe_path().get()\n+}\n+\n+/**\n+ * Get the source directory of the package (i.e.\n+ * where the crates are located). Assumes\n+ * that the cwd is changed to it before\n+ * running this executable.\n+ */\n+fn src_dir() -> Path {\n+    os::getcwd()\n+}\n+\n+pub fn args() -> ~[~str] {\n+    let mut args = os::args();\n+\n+    args.shift();\n+    args.shift();\n+\n+    args\n+}\n+\n+/// Build a set of crates, should be called once\n+pub fn build(crates: ~[Crate]) -> bool {\n+    let dir = src_dir();\n+    let work_dir = work_dir();\n+    let mut success = true;\n+\n+    for crates.each |&crate| {\n+        let path = &dir.push_rel(&Path(crate.file)).normalize();\n+\n+        note(fmt!(\"compiling %s\", path.to_str()));\n+\n+        success = compile_crate(path, &work_dir, crate.flags, crate.cfgs,\n+                                false, false);\n+\n+        if !success { break; }\n+    }\n+\n+    os::set_exit_status(101);\n+\n+    success\n }\n \n pub mod util {\n-    \n+    // TODO: utilities for working with things like autotools\n }"}, {"sha": "9d29bf76d6ca4f646f8dc6de8e143acf0d381c6e", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 112, "deletions": 267, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/707944184304acbd81c026156a04b98570c6ef9c/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/707944184304acbd81c026156a04b98570c6ef9c/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=707944184304acbd81c026156a04b98570c6ef9c", "patch": "@@ -31,7 +31,6 @@ use std::getopts;\n use std::net::url;\n use send_map::linear::LinearMap;\n use rustc::driver::{driver, session};\n-use rustc::metadata::{filesearch};\n use syntax::{ast, attr, codemap, diagnostic, parse, visit};\n use semver::Version;\n \n@@ -46,19 +45,33 @@ struct PackageScript {\n     name: ~str,\n     vers: Version,\n     crates: ~[~str],\n-    deps: ~[(~str, Option<~str>)]\n+    deps: ~[(~str, Option<~str>)],\n+    input: driver::input,\n+    sess: session::Session,\n+    cfg: ast::crate_cfg,\n+    crate: @ast::crate,\n+    custom: bool\n }\n \n impl PackageScript {\n-    static fn parse(parent: Path) -> Result<PackageScript, ~str> {\n+    static fn parse(parent: &Path) -> Result<PackageScript, ~str> {\n         let script = parent.push(~\"package.rs\");\n \n         if !os::path_exists(&script) {\n             return result::Err(~\"no package.rs file\");\n         }\n \n-        let sess = parse::new_parse_sess(None);\n-        let crate = parse::parse_crate_from_file(&script, ~[], sess);\n+        let binary = os::args()[0];\n+        let options: @session::options = @{\n+            binary: binary,\n+            crate_type: session::bin_crate,\n+            .. *session::basic_options()\n+        };\n+        let input = driver::file_input(script);\n+        let sess = driver::build_session(options, diagnostic::emit);\n+        let cfg = driver::build_configuration(sess, binary, input);\n+        let {crate, _} = driver::compile_upto(sess, cfg, input,\n+                                              driver::cu_parse, None);\n         let mut id = None;\n         let mut vers = None;\n         let mut crates = ~[];\n@@ -165,8 +178,19 @@ impl PackageScript {\n             }\n         }\n \n+        let mut custom = false;\n+\n+        // If we hit a function, we assume they want to use\n+        // the build API.\n+        for crate.node.module.items.each |i| {\n+            match i.node {\n+                ast::item_fn(_, _, _, _) => custom = true,\n+                _ => {}\n+            }\n+        }\n+\n         if id.is_none() || vers.is_none() {\n-            return result::Err(~\"package's pkg attr is missing required data (id, vers)\");\n+            return result::Err(~\"pkg attr without (id, vers) values\");\n         }\n \n         let id = id.get();\n@@ -184,12 +208,35 @@ impl PackageScript {\n             name: name,\n             vers: vers,\n             crates: crates,\n-            deps: deps\n+            deps: deps,\n+            input: input,\n+            sess: sess,\n+            cfg: cfg,\n+            crate: crate,\n+            custom: custom\n         })\n     }\n \n+    // Build the bootstrap and run a command\n+    // TODO: Use JIT once it works, it should be faster\n+    fn run(cmd: ~str) -> int {\n+        let work_dir = self.work_dir();\n+        let input = self.input;\n+        let sess = self.sess;\n+        let cfg = self.cfg;\n+        let crate = util::ready_crate(sess, self.crate);\n+        let outputs = driver::build_output_filenames(input, &Some(work_dir),\n+                                                     &None, sess);\n+        let exe = work_dir.push(~\"package\" + util::exe_suffix());\n+\n+        driver::compile_rest(sess, cfg, driver::cu_parse,\n+                         Some(outputs), Some(crate));\n+        run::run_program(exe.to_str(), ~[cmd])\n+    }\n+\n     fn hash() -> ~str {\n-        fmt!(\"%s-%s-%s\", self.name, util::hash(self.id + self.vers.to_str()), self.vers.to_str())\n+        fmt!(\"%s-%s-%s\", self.name, util::hash(self.id + self.vers.to_str()),\n+                         self.vers.to_str())\n     }\n \n     fn work_dir() -> Path {\n@@ -198,7 +245,7 @@ impl PackageScript {\n }\n \n struct Ctx {\n-    cfg: ast::crate_cfg,\n+    cfgs: ~[~str],\n     mut dep_cache: LinearMap<~str, bool>\n }\n \n@@ -229,13 +276,17 @@ impl Ctx {\n         }\n \n         match cmd {\n-            ~\"build\" => self.build(),\n-            ~\"clean\" => self.clean(),\n+            ~\"build\" => {\n+                self.build(&os::getcwd(), true, false, false);\n+            }\n+            ~\"clean\" => {\n+                self.clean();\n+            }\n             ~\"install\" => {\n                 self.install(if args.len() >= 1 { Some(args[0]) }\n                              else { None }, \n                              if args.len() >= 2 { Some(args[1]) }\n-                             else { None }, false)\n+                             else { None }, false);\n             }\n             ~\"prefer\" => {\n                 if args.len() < 1 {\n@@ -244,17 +295,19 @@ impl Ctx {\n \n                 let (name, vers) = sep_name_vers(args[0]);\n \n-                self.prefer(name.get(), vers)\n+                self.prefer(name.get(), vers);\n+            }\n+            ~\"test\" => {\n+                self.test();\n             }\n-            ~\"test\" => self.test(),\n             ~\"uninstall\" => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n \n                 let (name, vers) = sep_name_vers(args[0]);\n \n-                self.uninstall(name.get(), vers)\n+                self.uninstall(name.get(), vers);\n             }\n             ~\"unprefer\" => {\n                 if args.len() < 1 {\n@@ -263,28 +316,27 @@ impl Ctx {\n \n                 let (name, vers) = sep_name_vers(args[0]);\n \n-                self.unprefer(name.get(), vers)\n+                self.unprefer(name.get(), vers);\n             }\n             _ => fail ~\"reached an unhandled command\"\n-        };\n+        }\n     }\n \n-    fn build() -> bool {\n-        let dir = os::getcwd();\n+    fn build(dir: &Path, verbose: bool, opt: bool,\n+             test: bool) -> Option<PackageScript> {\n+        let cwd = &os::getcwd();\n         let script = match PackageScript::parse(dir) {\n             result::Ok(script) => script,\n             result::Err(err) => {\n                 util::error(err);\n \n-                return false; \n+                return None; \n             }\n         };\n         let work_dir = script.work_dir();\n         let mut success = true;\n \n         util::need_dir(&work_dir);\n-        util::note(fmt!(\"building %s v%s (%s)\", script.name, script.vers.to_str(),\n-                                                script.id));\n \n         if script.deps.len() >= 1 {\n             util::note(~\"installing dependencies\");\n@@ -302,176 +354,56 @@ impl Ctx {\n                 util::error(fmt!(\"building %s v%s failed: a dep wasn't installed\",\n                                  script.name, script.vers.to_str()));\n \n-                return false;\n+                return None;\n             }\n \n             util::note(~\"installed dependencies\");\n         }\n \n-        for script.crates.each |&crate| {\n-            success = self.compile(&work_dir, &dir.push_rel(&Path(crate)), ~[],\n-                                   false, false);\n-\n-            if !success { break; }\n-        }\n+        // Build imperative crates\n+        os::change_dir(dir);\n \n-        if !success {\n-            util::error(fmt!(\"building %s v%s failed: a crate failed to compile\",\n+        if script.custom && script.run(~\"build\") != 0 {\n+            util::error(fmt!(\"building %s v%s failed: custom build logic failed\",\n                              script.name, script.vers.to_str()));\n \n-            return false;\n+            return None;\n         }\n \n-        util::note(fmt!(\"built %s v%s\", script.name, script.vers.to_str()));\n-\n-        true\n-    }\n-\n-    fn compile(dir: &Path, crate: &Path, flags: ~[~str],\n-               opt: bool, test: bool) -> bool {\n-        util::note(~\"compiling \" + crate.to_str());\n-\n-        let lib_dir = dir.push(~\"lib\");\n-        let bin_dir = dir.push(~\"bin\");\n-        let test_dir = dir.push(~\"test\");\n-        let binary = os::args()[0];\n-        let options: @session::options = @{\n-            binary: binary,\n-            addl_lib_search_paths: ~[util::root().push(~\"lib\")],\n-            crate_type: session::unknown_crate,\n-            optimize: if opt { session::Aggressive } else { session::No },\n-            test: test,\n-            .. *session::basic_options()\n-        };\n-        let input = driver::file_input(*crate);\n-        let sess = driver::build_session(options, diagnostic::emit);\n-        let cfg = driver::build_configuration(sess, binary, input);\n-        let mut outputs = driver::build_output_filenames(input, &None, &None,\n-                                                         sess);\n-        let {crate, _} = driver::compile_upto(sess, cfg, input, driver::cu_parse,\n-                                              Some(outputs));\n-\n-        let mut name = None;\n-        let mut vers = None;\n-        let mut uuid = None;\n-        let mut crate_type = None;\n-\n-        fn load_link_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n-                                                       Option<~str>,\n-                                                       Option<~str>) {\n-            let mut name = None;\n-            let mut vers = None;\n-            let mut uuid = None;\n-\n-            for mis.each |a| {\n-                match a.node {\n-                    ast::meta_name_value(v, ast::spanned {node: ast::lit_str(s),\n-                                             span: _}) => {\n-                        match v {\n-                            ~\"name\" => name = Some(*s),\n-                            ~\"vers\" => vers = Some(*s),\n-                            ~\"uuid\" => uuid = Some(*s),\n-                            _ => { }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            (name, vers, uuid)\n-        }\n+        os::change_dir(cwd);\n \n-        for crate.node.attrs.each |a| {\n-            match a.node.value.node {\n-                ast::meta_name_value(v, ast::spanned {node: ast::lit_str(s),\n-                                         span: _}) => {\n-                    match v {\n-                        ~\"crate_type\" => crate_type = Some(*s),\n-                        _ => {}\n-                    }\n-                }\n-                ast::meta_list(v, mis) => {\n-                    match v {\n-                        ~\"link\" => {\n-                            let (n, v, u) = load_link_attr(mis);\n+        for script.crates.each |&crate| {\n+            let crate = &dir.push_rel(&Path(crate)).normalize();\n \n-                            name = n;\n-                            vers = v;\n-                            uuid = u;\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n+            util::note(fmt!(\"compiling %s\", crate.to_str()));\n \n-        if name.is_none() || vers.is_none() || uuid.is_none() {\n-            util::error(~\"crate's link attr is missing required data (name, vers, uuid)\");\n+            success = self.compile(crate, &work_dir, ~[],\n+                                   ~[], opt, test);\n \n-            return false;\n+            if !success { break; }\n         }\n \n-        let name = name.get();\n-        let vers = vers.get();\n-        let uuid = uuid.get();\n-\n-        let is_bin = match crate_type {\n-            Some(crate_type) => {\n-                match crate_type {\n-                    ~\"bin\" => true,\n-                    ~\"lib\" => false,\n-                    _ => {\n-                        util::warn(~\"unknown crate_type, falling back to lib\");\n-\n-                        false\n-                    }\n-                }\n-            }\n-            None => {\n-                util::warn(~\"missing crate_type attr, assuming lib\");\n-\n-                false\n-            }\n-        };\n-\n-        if test {\n-            util::need_dir(&test_dir);\n+        if !success {\n+            util::error(fmt!(\"building %s v%s failed: a crate failed to compile\",\n+                             script.name, script.vers.to_str()));\n \n-            outputs = driver::build_output_filenames(input, &Some(test_dir),\n-                                                     &None, sess)\n+            return None;\n         }\n-        else if is_bin {\n-            util::need_dir(&bin_dir);\n-\n-            #[cfg(windows)]\n-            fn suffix() -> ~str { ~\".exe\" }\n-\n-            #[cfg(target_os = \"linux\")]\n-            #[cfg(target_os = \"android\")]\n-            #[cfg(target_os = \"freebsd\")]\n-            #[cfg(target_os = \"macos\")]\n-            fn suffix() -> ~str { ~\"\" }\n-\n-            let path = bin_dir.push(fmt!(\"%s-%s-%s%s\", name,\n-                                                       util::hash(name + uuid + vers),\n-                                                       vers, suffix()));\n-            outputs = driver::build_output_filenames(input, &None, &Some(path), sess);\n-        } else {\n-            util::need_dir(&lib_dir);\n \n-            outputs = driver::build_output_filenames(input, &Some(lib_dir),\n-                                                     &None, sess)\n+        if verbose {\n+            util::note(fmt!(\"built %s v%s\", script.name, script.vers.to_str()));\n         }\n \n-        driver::compile_upto(sess, cfg, input, driver::cu_everything,\n-                             Some(outputs));\n+        Some(script)\n+    }\n \n-        true\n+    fn compile(crate: &Path, dir: &Path, flags: ~[~str],\n+               cfgs: ~[~str], opt: bool, test: bool) -> bool {\n+        util::compile_crate(crate, dir, flags, cfgs, opt, test)\n     }\n \n     fn clean() -> bool {\n-        let script = match PackageScript::parse(os::getcwd()) {\n+        let script = match PackageScript::parse(&os::getcwd()) {\n             result::Ok(script) => script,\n             result::Err(err) => {\n                 util::error(err);\n@@ -505,7 +437,8 @@ impl Ctx {\n             dir = os::getcwd();\n         } else {\n             let url = url.get();\n-            let hash = util::hash(if !target.is_none() { url + target.get() } else { url });\n+            let hash = util::hash(if !target.is_none() { url + target.get() }\n+                                  else { url });\n \n             if self.dep_cache.contains_key(&hash) {\n                 util::warn(~\"already installed dep this run\");\n@@ -528,53 +461,13 @@ impl Ctx {\n             }\n         }\n \n-        let script = match PackageScript::parse(dir) {\n-            result::Ok(script) => script,\n-            result::Err(err) => {\n-                util::error(err);\n-\n+        let script = match self.build(&dir, false, true, false) {\n+            Some(script) => script,\n+            None => {\n                 return false;\n             }\n         };\n         let work_dir = script.work_dir();\n-\n-        util::need_dir(&work_dir);\n-        util::note(fmt!(\"installing %s v%s (%s)\", script.name, script.vers.to_str(),\n-                                                  script.id));\n-\n-        if script.deps.len() >= 1 {\n-            util::note(~\"installing dependencies\");\n-\n-            for script.deps.each |&dep| {\n-                let (url, target) = dep;\n-\n-                success = self.install(Some(url), target, false);\n-\n-                if !success { break; }\n-            }\n-\n-            if !success {\n-                util::error(fmt!(\"installing %s v%s failed: a dep wasn't installed\",\n-                                 script.name, script.vers.to_str()));\n-                return false;\n-            }\n-\n-            util::note(~\"installed dependencies\");\n-        }\n-\n-        for script.crates.each |&crate| {\n-            success = self.compile(&work_dir, &dir.push_rel(&Path(crate)), ~[],\n-                                 true, false);\n-\n-            if !success { break; }\n-        }\n-\n-        if !success {\n-            util::error(fmt!(\"installing %s v%s failed: a crate failed to compile\",\n-                             script.name, script.vers.to_str()));\n-            return false;\n-        }\n-\n         let from_bin_dir = work_dir.push(~\"bin\");\n         let from_lib_dir = work_dir.push(~\"lib\");\n         let to_bin_dir = util::root().push(~\"bin\");\n@@ -728,58 +621,14 @@ impl Ctx {\n     }\n \n     fn test() -> bool {\n-        let dir = os::getcwd();\n-        let script = match PackageScript::parse(dir) {\n-            result::Ok(script) => script,\n-            result::Err(err) => {\n-                util::error(err);\n-\n-                return false; \n+        let script = match self.build(&os::getcwd(), false, false, true) {\n+            Some(script) => script,\n+            None => {\n+                return false;\n             }\n         };\n         let work_dir = script.work_dir();\n         let test_dir = work_dir.push(~\"test\");\n-        let mut success = true;\n-\n-        util::need_dir(&work_dir);\n-        util::note(fmt!(\"testing %s v%s (%s)\", script.name, script.vers.to_str(),\n-                                               script.id));\n-\n-        if script.deps.len() >= 1 {\n-            util::note(~\"installing dependencies\");\n-\n-            for script.deps.each |&dep| {\n-                let (url, target) = dep;\n-\n-                success = self.install(Some(url), target, true);\n-\n-                if !success { break; }\n-            }\n-\n-\n-            if !success {\n-                util::error(fmt!(\"testing %s v%s failed: a dep wasn't installed\",\n-                                 script.name, script.vers.to_str()));\n-\n-                return false;\n-            }\n-\n-            util::note(~\"installed dependencies\");\n-        }\n-\n-        for script.crates.each |&crate| {\n-            success = self.compile(&work_dir, &dir.push_rel(&Path(crate)), ~[],\n-                                   false, true);\n-\n-            if !success { break; }\n-        }\n-\n-        if !success {\n-            util::error(fmt!(\"testing %s v%s failed: a crate failed to compile\",\n-                             script.name, script.vers.to_str()));\n-\n-            return false;\n-        }\n \n         for os::walk_dir(&test_dir) |test| {\n             util::note(fmt!(\"running %s\", test.to_str()));\n@@ -892,7 +741,7 @@ pub fn main() {\n     };\n     let help = getopts::opt_present(matches, ~\"h\") ||\n                getopts::opt_present(matches, ~\"help\");\n-    let cfg = vec::append(getopts::opt_strs(matches, ~\"cfg\"),\n+    let cfgs = vec::append(getopts::opt_strs(matches, ~\"cfg\"),\n                            getopts::opt_strs(matches, ~\"c\"));\n     let mut args = copy matches.free;\n \n@@ -919,18 +768,14 @@ pub fn main() {\n         };\n     }\n \n-    let mut cfg_specs = ~[];\n-\n-    for cfg.each |s| {\n-        cfg_specs.push(attr::mk_word_item(/*bad*/copy *s));\n-    }\n-\n     Ctx {\n-        cfg: cfg_specs,\n+        cfgs: cfgs,\n         mut dep_cache: LinearMap()\n     }.run(cmd, args);\n }\n \n pub use Crate = api::Crate;\n pub use build = api::build;\n pub use util = api::util;\n+pub use Listener = api::Listener;\n+pub use run = api::run;"}, {"sha": "cad5aa650db0773d95c50440881b230a36f50b5d", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/707944184304acbd81c026156a04b98570c6ef9c/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707944184304acbd81c026156a04b98570c6ef9c/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=707944184304acbd81c026156a04b98570c6ef9c", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use core::io;\n  \n pub fn general() {"}, {"sha": "b7d6ad17f052e199e21e75093de5ff306a2b4c21", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 559, "deletions": 0, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/707944184304acbd81c026156a04b98570c6ef9c/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707944184304acbd81c026156a04b98570c6ef9c/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=707944184304acbd81c026156a04b98570c6ef9c", "patch": "@@ -1,8 +1,23 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use core::*;\n use send_map::linear::LinearMap;\n use rustc::metadata::filesearch;\n+use rustc::driver::{driver, session};\n+use syntax::ast_util::*;\n+use syntax::{ast, attr, codemap, diagnostic, fold, parse, visit};\n+use codemap::span;\n use semver::Version;\n use std::{json, term, sort};\n+use api::Listener;\n \n pub struct Package {\n     id: ~str,\n@@ -41,6 +56,401 @@ pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n     result::Ok(parts.last())\n }\n \n+fn mk_rustpkg_use(ctx: @ReadyCtx) -> @ast::view_item {\n+    let vers = ast::lit_str(@~\"0.6\");\n+    let vers = no_span(vers);\n+    let mi = ast::meta_name_value(~\"vers\", vers);\n+    let mi = no_span(mi);\n+    let vi = ast::view_item_use(ctx.sess.ident_of(~\"rustpkg\"),\n+                                ~[@mi],\n+                                ctx.sess.next_node_id());\n+\n+    @ast::view_item {\n+        node: vi,\n+        attrs: ~[],\n+        vis: ast::private,\n+        span: dummy_sp()\n+    }\n+}\n+\n+struct ListenerFn {\n+    span: codemap::span,\n+    path: ~[ast::ident]\n+}\n+\n+struct ReadyCtx {\n+    sess: session::Session,\n+    crate: @ast::crate,\n+    mut path: ~[ast::ident],\n+    mut fns: ~[ListenerFn]\n+}\n+\n+fn fold_mod(ctx: @ReadyCtx, m: ast::_mod,\n+            fold: fold::ast_fold) -> ast::_mod {\n+    fn strip_main(item: @ast::item) -> @ast::item {\n+        @ast::item {\n+            attrs: do item.attrs.filtered |attr| {\n+                attr::get_attr_name(*attr) != ~\"main\"\n+            },\n+            .. copy *item\n+        }\n+    }\n+\n+    fold::noop_fold_mod({\n+        view_items: vec::append_one(m.view_items, mk_rustpkg_use(ctx)),\n+        items: do vec::map(m.items) |item| {\n+            strip_main(*item)\n+        }\n+    }, fold)\n+}\n+\n+fn fold_crate(ctx: @ReadyCtx, crate: ast::crate_,\n+              fold: fold::ast_fold) -> ast::crate_ {\n+    let folded = fold::noop_fold_crate(crate, fold);\n+\n+    ast::crate_ {\n+        module: add_pkg_module(ctx, /*bad*/copy folded.module),\n+        .. folded\n+    }\n+}\n+\n+fn fold_item(ctx: @ReadyCtx, &&item: @ast::item,\n+             fold: fold::ast_fold) -> Option<@ast::item> {\n+\n+    ctx.path.push(item.ident);\n+\n+    if attr::find_attrs_by_name(item.attrs, ~\"pkg_do\").is_not_empty() {\n+        ctx.fns.push(ListenerFn {\n+            span: item.span,\n+            path: /*bad*/copy ctx.path\n+        });\n+    }\n+\n+    let res = fold::noop_fold_item(item, fold);\n+\n+    ctx.path.pop();\n+\n+    res\n+}\n+\n+fn mk_rustpkg_import(ctx: @ReadyCtx) -> @ast::view_item {\n+    let path = @ast::path {\n+        span: dummy_sp(),\n+        global: false,\n+        idents: ~[ctx.sess.ident_of(~\"rustpkg\")],\n+        rp: None,\n+        types: ~[]\n+    };\n+    let vp = @no_span(ast::view_path_simple(ctx.sess.ident_of(~\"rustpkg\"),\n+                                            path, ast::type_value_ns,\n+                                            ctx.sess.next_node_id()));\n+\n+    @ast::view_item {\n+        node: ast::view_item_import(~[vp]),\n+        attrs: ~[],\n+        vis: ast::private,\n+        span: dummy_sp()\n+    }\n+}\n+\n+fn add_pkg_module(ctx: @ReadyCtx, m: ast::_mod) -> ast::_mod {\n+    let listeners = mk_listeners(ctx);\n+    let main = mk_main(ctx);\n+    let pkg_mod = @{\n+        view_items: ~[mk_rustpkg_import(ctx)],\n+        items: ~[main, listeners]\n+    };\n+    let resolve_unexported_attr =\n+        attr::mk_attr(attr::mk_word_item(~\"!resolve_unexported\"));\n+    let item_ = ast::item_mod(*pkg_mod);\n+    let item = @ast::item {\n+        ident: ctx.sess.ident_of(~\"__pkg\"),\n+        attrs: ~[resolve_unexported_attr],\n+        id: ctx.sess.next_node_id(),\n+        node: item_,\n+        vis: ast::public,\n+        span: dummy_sp(),\n+    };\n+\n+    {\n+        items: vec::append_one(/*bad*/copy m.items, item),\n+        .. m\n+    }\n+}\n+\n+fn no_span<T: Copy>(t: T) -> ast::spanned<T> {\n+    ast::spanned {\n+        node: t,\n+        span: dummy_sp()\n+    }\n+}\n+\n+fn path_node(ids: ~[ast::ident]) -> @ast::path {\n+    @ast::path {\n+        span: dummy_sp(),\n+        global: false,\n+        idents: ids,\n+        rp: None,\n+        types: ~[]\n+    }\n+}\n+\n+fn path_node_global(ids: ~[ast::ident]) -> @ast::path {\n+    @ast::path {\n+        span: dummy_sp(),\n+        global: true,\n+        idents: ids,\n+        rp: None,\n+        types: ~[]\n+    }\n+}\n+\n+fn mk_listeners(ctx: @ReadyCtx) -> @ast::item {\n+    let ret_ty = mk_listener_vec_ty(ctx);\n+    let decl = {\n+        inputs: ~[],\n+        output: ret_ty,\n+        cf: ast::return_val\n+    };\n+    let listeners = mk_listener_vec(ctx);\n+    let body_ = default_block(~[], option::Some(listeners),\n+                              ctx.sess.next_node_id());\n+    let body = no_span(body_);\n+    let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n+\n+    @ast::item {\n+        ident: ctx.sess.ident_of(~\"listeners\"),\n+        attrs: ~[],\n+        id: ctx.sess.next_node_id(),\n+        node: item_,\n+        vis: ast::public,\n+        span: dummy_sp(),\n+    }\n+}\n+\n+fn mk_path(ctx: @ReadyCtx, path: ~[ast::ident]) -> @ast::path {\n+    path_node(~[ctx.sess.ident_of(~\"rustpkg\")] + path)\n+}\n+\n+fn mk_listener_vec_ty(ctx: @ReadyCtx) -> @ast::Ty {\n+    let listener_ty_path = mk_path(ctx, ~[ctx.sess.ident_of(~\"Listener\")]);\n+    let listener_ty = {\n+        id: ctx.sess.next_node_id(),\n+        node: ast::ty_path(listener_ty_path,\n+                           ctx.sess.next_node_id()),\n+        span: dummy_sp()\n+    };\n+    let vec_mt = ast::mt {\n+        ty: @listener_ty,\n+        mutbl: ast::m_imm\n+    };\n+    let inner_ty = @{\n+        id: ctx.sess.next_node_id(),\n+        node: ast::ty_vec(vec_mt),\n+        span: dummy_sp()\n+    };\n+\n+    @{\n+        id: ctx.sess.next_node_id(),\n+        node: ast::ty_uniq(ast::mt {\n+            ty: inner_ty,\n+            mutbl: ast::m_imm\n+        }),\n+        span: dummy_sp()\n+    }\n+}\n+\n+fn mk_listener_vec(ctx: @ReadyCtx) -> @ast::expr {\n+    let fns = ctx.fns;\n+\n+    let descs = do fns.map |listener| {\n+        mk_listener_rec(ctx, *listener)\n+    };\n+    let inner_expr = @{\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: ast::expr_vec(descs, ast::m_imm),\n+        span: dummy_sp()\n+    };\n+\n+    @{\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: ast::expr_vstore(inner_expr, ast::expr_vstore_uniq),\n+        span: dummy_sp()\n+    }\n+}\n+\n+fn mk_listener_rec(ctx: @ReadyCtx, listener: ListenerFn) -> @ast::expr {\n+    let span = listener.span;\n+    let path = /*bad*/copy listener.path;\n+    let cmd_lit = no_span(ast::lit_str(@path_name_i(path,\n+                                       ctx.sess.parse_sess.interner)));\n+    let cmd_expr_inner = @{\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: ast::expr_lit(@cmd_lit),\n+        span: span\n+    };\n+    let cmd_expr = {\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: ast::expr_vstore(cmd_expr_inner, ast::expr_vstore_uniq),\n+        span: dummy_sp()\n+    };\n+    let cmd_field = no_span(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: ctx.sess.ident_of(~\"cmd\"),\n+        expr: @cmd_expr,\n+    });\n+\n+    let cb_path = path_node_global(path);\n+    let cb_expr = {\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: ast::expr_path(cb_path),\n+        span: span\n+    };\n+    let cb_wrapper_expr = mk_fn_wrapper(ctx, cb_expr, span);\n+    let cb_field = no_span(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: ctx.sess.ident_of(~\"cb\"),\n+        expr: cb_wrapper_expr\n+    });\n+\n+    let listener_path = mk_path(ctx, ~[ctx.sess.ident_of(~\"Listener\")]);\n+    let listener_rec_ = ast::expr_struct(listener_path,\n+                                         ~[cmd_field, cb_field],\n+                                         option::None);\n+    @{\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: listener_rec_,\n+        span: span\n+    }\n+}\n+\n+fn mk_fn_wrapper(ctx: @ReadyCtx, fn_path_expr: ast::expr,\n+                 span: span) -> @ast::expr {\n+    let call_expr = {\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: ast::expr_call(@fn_path_expr, ~[], false),\n+        span: span\n+    };\n+    let call_stmt = no_span(ast::stmt_semi(@call_expr, ctx.sess.next_node_id()));\n+    let wrapper_decl = {\n+        inputs: ~[],\n+        output: @{\n+            id: ctx.sess.next_node_id(),\n+            node: ast::ty_nil, span: span\n+        },\n+        cf: ast::return_val\n+    };\n+    let wrapper_body = no_span(ast::blk_ {\n+        view_items: ~[],\n+        stmts: ~[@call_stmt],\n+        expr: option::None,\n+        id: ctx.sess.next_node_id(),\n+        rules: ast::default_blk\n+    });\n+\n+    @{\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: ast::expr_fn(ast::ProtoBare, wrapper_decl,\n+                           wrapper_body, @~[]),\n+        span: span\n+    }\n+}\n+\n+fn mk_main(ctx: @ReadyCtx) -> @ast::item {\n+    let ret_ty = {\n+        id: ctx.sess.next_node_id(),\n+        node: ast::ty_nil,\n+        span: dummy_sp()\n+    };\n+    let decl = {\n+        inputs: ~[],\n+        output: @ret_ty,\n+        cf: ast::return_val\n+    };\n+    let run_call_expr = mk_run_call(ctx);\n+    let body_ = default_block(~[], option::Some(run_call_expr),\n+                              ctx.sess.next_node_id());\n+    let body = ast::spanned {\n+        node: body_,\n+        span: dummy_sp()\n+    };\n+    let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n+\n+    @ast::item {\n+        ident: ctx.sess.ident_of(~\"main\"),\n+        attrs: ~[attr::mk_attr(attr::mk_word_item(~\"main\"))],\n+        id: ctx.sess.next_node_id(),\n+        node: item_,\n+        vis: ast::public,\n+        span: dummy_sp(),\n+    }\n+}\n+\n+fn mk_run_call(ctx: @ReadyCtx) -> @ast::expr {\n+    let listener_path = path_node(~[ctx.sess.ident_of(~\"listeners\")]);\n+    let listener_path_expr_ = ast::expr_path(listener_path);\n+    let listener_path_expr = {\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: listener_path_expr_,\n+        span: dummy_sp()\n+    };\n+    let listener_call_expr_ = ast::expr_call(@listener_path_expr, ~[], false);\n+    let listener_call_expr = {\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: listener_call_expr_,\n+        span: dummy_sp()\n+    };\n+    let rustpkg_run_path = mk_path(ctx, ~[ctx.sess.ident_of(~\"run\")]);\n+\n+    let rustpkg_run_path_expr_ = ast::expr_path(rustpkg_run_path);\n+    let rustpkg_run_path_expr = {\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: rustpkg_run_path_expr_,\n+        span: dummy_sp()\n+    };\n+    let rustpkg_run_call_expr_ = ast::expr_call(@rustpkg_run_path_expr,\n+                                               ~[@listener_call_expr],\n+                                               false);\n+    @{\n+        id: ctx.sess.next_node_id(),\n+        callee_id: ctx.sess.next_node_id(),\n+        node: rustpkg_run_call_expr_,\n+        span: dummy_sp()\n+    }\n+}\n+\n+/// Generate/filter main function, add the list of commands, etc.\n+pub fn ready_crate(sess: session::Session,\n+                   crate: @ast::crate) -> @ast::crate {\n+    let ctx = @ReadyCtx {\n+        sess: sess,\n+        crate: crate,\n+        mut path: ~[],\n+        mut fns: ~[]\n+    };\n+    let precursor = @fold::AstFoldFns {\n+        fold_crate: fold::wrap(|a, b| fold_crate(ctx, a, b)),\n+        fold_item: |a, b| fold_item(ctx, a, b),\n+        fold_mod: |a, b| fold_mod(ctx, a, b),\n+        .. *fold::default_ast_fold()\n+    };\n+\n+    let fold = fold::make_fold(precursor);\n+\n+    @fold.fold_crate(*crate)\n+}\n+\n pub fn parse_vers(vers: ~str) -> result::Result<Version, ~str> {\n     match semver::parse(vers) {\n         Some(vers) => result::Ok(vers),\n@@ -417,6 +827,155 @@ pub fn remove_pkg(pkg: &Package) -> bool {\n     true\n }\n \n+pub fn compile_input(input: driver::input, dir: &Path,\n+               flags: ~[~str], cfgs: ~[~str], opt: bool, test: bool) -> bool {\n+    let lib_dir = dir.push(~\"lib\");\n+    let bin_dir = dir.push(~\"bin\");\n+    let test_dir = dir.push(~\"test\");\n+    let binary = os::args()[0];\n+    let options: @session::options = @{\n+        binary: binary,\n+        crate_type: session::unknown_crate,\n+        optimize: if opt { session::Aggressive } else { session::No },\n+        test: test,\n+        .. *session::basic_options()\n+    };\n+    let sess = driver::build_session(options, diagnostic::emit);\n+    let cfg = driver::build_configuration(sess, binary, input);\n+    let mut outputs = driver::build_output_filenames(input, &None, &None,\n+                                                     sess);\n+    let {crate, _} = driver::compile_upto(sess, cfg, input, driver::cu_parse,\n+                                          Some(outputs));\n+\n+    let mut name = None;\n+    let mut vers = None;\n+    let mut uuid = None;\n+    let mut crate_type = None;\n+\n+    fn load_link_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+                                                   Option<~str>,\n+                                                   Option<~str>) {\n+        let mut name = None;\n+        let mut vers = None;\n+        let mut uuid = None;\n+\n+        for mis.each |a| {\n+            match a.node {\n+                ast::meta_name_value(v, ast::spanned {node: ast::lit_str(s),\n+                                         span: _}) => {\n+                    match v {\n+                        ~\"name\" => name = Some(*s),\n+                        ~\"vers\" => vers = Some(*s),\n+                        ~\"uuid\" => uuid = Some(*s),\n+                        _ => { }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        (name, vers, uuid)\n+    }\n+\n+    for crate.node.attrs.each |a| {\n+        match a.node.value.node {\n+            ast::meta_name_value(v, ast::spanned {node: ast::lit_str(s),\n+                                     span: _}) => {\n+                match v {\n+                    ~\"crate_type\" => crate_type = Some(*s),\n+                    _ => {}\n+                }\n+            }\n+            ast::meta_list(v, mis) => {\n+                match v {\n+                    ~\"link\" => {\n+                        let (n, v, u) = load_link_attr(mis);\n+\n+                        name = n;\n+                        vers = v;\n+                        uuid = u;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    if name.is_none() || vers.is_none() || uuid.is_none() {\n+        error(~\"link attr without (name, vers, uuid) values\");\n+\n+        return false;\n+    }\n+\n+    let name = name.get();\n+    let vers = vers.get();\n+    let uuid = uuid.get();\n+\n+    let is_bin = match crate_type {\n+        Some(crate_type) => {\n+            match crate_type {\n+                ~\"bin\" => true,\n+                ~\"lib\" => false,\n+                _ => {\n+                    warn(~\"unknown crate_type, falling back to lib\");\n+\n+                    false\n+                }\n+            }\n+        }\n+        None => {\n+            warn(~\"missing crate_type attr, assuming lib\");\n+\n+            false\n+        }\n+    };\n+\n+    if test {\n+        need_dir(&test_dir);\n+\n+        outputs = driver::build_output_filenames(input, &Some(test_dir),\n+                                                 &None, sess)\n+    }\n+    else if is_bin {\n+        need_dir(&bin_dir);\n+\n+        let path = bin_dir.push(fmt!(\"%s-%s-%s%s\", name,\n+                                                   hash(name + uuid + vers),\n+                                                   vers, exe_suffix()));\n+        outputs = driver::build_output_filenames(input, &None, &Some(path), sess);\n+    } else {\n+        need_dir(&lib_dir);\n+\n+        outputs = driver::build_output_filenames(input, &Some(lib_dir),\n+                                                 &None, sess)\n+    }\n+\n+    driver::compile_rest(sess, cfg, driver::cu_everything,\n+                         Some(outputs), Some(crate));\n+\n+    true\n+}\n+\n+#[cfg(windows)]\n+pub fn exe_suffix() -> ~str { ~\".exe\" }\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"macos\")]\n+pub fn exe_suffix() -> ~str { ~\"\" }\n+\n+pub fn compile_crate(crate: &Path, dir: &Path, flags: ~[~str],\n+               cfgs: ~[~str], opt: bool, test: bool) -> bool {\n+    compile_input(driver::file_input(*crate), dir, flags, cfgs, opt, test)\n+}\n+\n+pub fn compile_str(code: ~str, dir: &Path, flags: ~[~str],\n+                   cfgs: ~[~str], opt: bool, test: bool) -> bool {\n+    compile_input(driver::str_input(code), dir, flags, cfgs, opt, test)\n+}\n+\n #[cfg(windows)]\n pub fn link_exe(_src: &Path, _dest: &Path) -> bool{\n     /* FIXME: Investigate how to do this on win32"}]}