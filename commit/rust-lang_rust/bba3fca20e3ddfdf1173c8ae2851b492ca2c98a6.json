{"sha": "bba3fca20e3ddfdf1173c8ae2851b492ca2c98a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYTNmY2EyMGUzZGRmZGYxMTczYzhhZTI4NTFiNDkyY2EyYzk4YTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-30T22:43:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-30T22:43:52Z"}, "message": "Auto merge of #36866 - alexcrichton:fix-hash-again, r=eddyb\n\nrustc: More fixes for arch-independent hashing\n\nIn another attempt to fix #36793 this commit attempts to head off any future\nproblems by adding a custom `WidentUsizeHasher` which will widen any hashing of\n`isize` and `usize` to a `u64` as necessary. This obviates the need for a\nprevious number of `as u64` annotations and will hopefully protect us against\nfuture problems here.\n\nCloses #36793 (hopefully)", "tree": {"sha": "6732f74f4a9788994344854a42643c9d7c39081a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6732f74f4a9788994344854a42643c9d7c39081a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bba3fca20e3ddfdf1173c8ae2851b492ca2c98a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bba3fca20e3ddfdf1173c8ae2851b492ca2c98a6", "html_url": "https://github.com/rust-lang/rust/commit/bba3fca20e3ddfdf1173c8ae2851b492ca2c98a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bba3fca20e3ddfdf1173c8ae2851b492ca2c98a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "html_url": "https://github.com/rust-lang/rust/commit/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3"}, {"sha": "faae99deb7c613f580f4aca4087ffeec4159e1de", "url": "https://api.github.com/repos/rust-lang/rust/commits/faae99deb7c613f580f4aca4087ffeec4159e1de", "html_url": "https://github.com/rust-lang/rust/commit/faae99deb7c613f580f4aca4087ffeec4159e1de"}], "stats": {"total": 87, "additions": 76, "deletions": 11}, "files": [{"sha": "c209503e90e7d50c83b88a412b409ed1b5ca3ba8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 73, "deletions": 8, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/bba3fca20e3ddfdf1173c8ae2851b492ca2c98a6/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba3fca20e3ddfdf1173c8ae2851b492ca2c98a6/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=bba3fca20e3ddfdf1173c8ae2851b492ca2c98a6", "patch": "@@ -12,6 +12,7 @@\n \n use hir::def_id::DefId;\n use infer::InferCtxt;\n+use hir::map as ast_map;\n use hir::pat_util;\n use traits::{self, Reveal};\n use ty::{self, Ty, AdtKind, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n@@ -388,16 +389,77 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+// When hashing a type this ends up affecting properties like symbol names. We\n+// want these symbol names to be calculated independent of other factors like\n+// what architecture you're compiling *from*.\n+//\n+// The hashing just uses the standard `Hash` trait, but the implementations of\n+// `Hash` for the `usize` and `isize` types are *not* architecture independent\n+// (e.g. they has 4 or 8 bytes). As a result we want to avoid `usize` and\n+// `isize` completely when hashing. To ensure that these don't leak in we use a\n+// custom hasher implementation here which inflates the size of these to a `u64`\n+// and `i64`.\n+struct WidenUsizeHasher<H> {\n+    inner: H,\n+}\n+\n+impl<H> WidenUsizeHasher<H> {\n+    fn new(inner: H) -> WidenUsizeHasher<H> {\n+        WidenUsizeHasher { inner: inner }\n+    }\n+}\n+\n+impl<H: Hasher> Hasher for WidenUsizeHasher<H> {\n+    fn write(&mut self, bytes: &[u8]) {\n+        self.inner.write(bytes)\n+    }\n+\n+    fn finish(&self) -> u64 {\n+        self.inner.finish()\n+    }\n+\n+    fn write_u8(&mut self, i: u8) {\n+        self.inner.write_u8(i)\n+    }\n+    fn write_u16(&mut self, i: u16) {\n+        self.inner.write_u16(i)\n+    }\n+    fn write_u32(&mut self, i: u32) {\n+        self.inner.write_u32(i)\n+    }\n+    fn write_u64(&mut self, i: u64) {\n+        self.inner.write_u64(i)\n+    }\n+    fn write_usize(&mut self, i: usize) {\n+        self.inner.write_u64(i as u64)\n+    }\n+    fn write_i8(&mut self, i: i8) {\n+        self.inner.write_i8(i)\n+    }\n+    fn write_i16(&mut self, i: i16) {\n+        self.inner.write_i16(i)\n+    }\n+    fn write_i32(&mut self, i: i32) {\n+        self.inner.write_i32(i)\n+    }\n+    fn write_i64(&mut self, i: i64) {\n+        self.inner.write_i64(i)\n+    }\n+    fn write_isize(&mut self, i: isize) {\n+        self.inner.write_i64(i as i64)\n+    }\n+}\n+\n pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, H> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: H\n+    state: WidenUsizeHasher<H>,\n }\n \n impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, state: H) -> Self {\n         TypeIdHasher {\n             tcx: tcx,\n-            state: state\n+            state: WidenUsizeHasher::new(state),\n         }\n     }\n \n@@ -421,9 +483,12 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     fn def_id(&mut self, did: DefId) {\n         // Hash the DefPath corresponding to the DefId, which is independent\n         // of compiler internal state.\n-        let tcx = self.tcx;\n-        let def_path = tcx.def_path(did);\n-        def_path.deterministic_hash_to(tcx, &mut self.state);\n+        let path = self.tcx.def_path(did);\n+        self.def_path(&path)\n+    }\n+\n+    pub fn def_path(&mut self, def_path: &ast_map::DefPath) {\n+        def_path.deterministic_hash_to(self.tcx, &mut self.state);\n     }\n }\n \n@@ -436,7 +501,7 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tc\n             TyInt(i) => self.hash(i),\n             TyUint(u) => self.hash(u),\n             TyFloat(f) => self.hash(f),\n-            TyArray(_, n) => self.hash(n as u64),\n+            TyArray(_, n) => self.hash(n),\n             TyRawPtr(m) |\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |\n@@ -447,14 +512,14 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tc\n                 self.hash(f.unsafety);\n                 self.hash(f.abi);\n                 self.hash(f.sig.variadic());\n-                self.hash(f.sig.inputs().skip_binder().len() as u64);\n+                self.hash(f.sig.inputs().skip_binder().len());\n             }\n             TyTrait(ref data) => {\n                 self.def_id(data.principal.def_id());\n                 self.hash(data.builtin_bounds);\n             }\n             TyTuple(tys) => {\n-                self.hash(tys.len() as u64);\n+                self.hash(tys.len());\n             }\n             TyParam(p) => {\n                 self.hash(p.idx);"}, {"sha": "f0661e03bc8153f0f38a09a4dae47b1de386bbfd", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba3fca20e3ddfdf1173c8ae2851b492ca2c98a6/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba3fca20e3ddfdf1173c8ae2851b492ca2c98a6/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=bba3fca20e3ddfdf1173c8ae2851b492ca2c98a6", "patch": "@@ -152,17 +152,17 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     let mut hash_state = scx.symbol_hasher().borrow_mut();\n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n         hash_state.reset();\n-        let mut hasher = Sha256Hasher(&mut hash_state);\n+        let hasher = Sha256Hasher(&mut hash_state);\n+        let mut hasher = ty::util::TypeIdHasher::new(tcx, hasher);\n \n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n-        def_path.deterministic_hash_to(tcx, &mut hasher);\n+        hasher.def_path(def_path);\n \n         // Include the main item-type. Note that, in this case, the\n         // assertions about `needs_subst` may not hold, but this item-type\n         // ought to be the same for every reference anyway.\n-        let mut hasher = ty::util::TypeIdHasher::new(tcx, hasher);\n         assert!(!item_type.has_erasable_regions());\n         hasher.visit_ty(item_type);\n "}]}