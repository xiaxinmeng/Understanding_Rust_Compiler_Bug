{"sha": "a9b92151b024920d39010b73bf34a5ee68d08b64", "node_id": "C_kwDOAAsO6NoAKGE5YjkyMTUxYjAyNDkyMGQzOTAxMGI3M2JmMzRhNWVlNjhkMDhiNjQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-15T09:44:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-15T09:44:11Z"}, "message": "Rollup merge of #104316 - cjgillot:simplify-async-suggestion, r=estebank\n\nSimplify suggestions for errors in generators.\n\nSplit from https://github.com/rust-lang/rust/pull/101692/", "tree": {"sha": "f0f013e7df17cbe7230db7054ea07b0157f4e5c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0f013e7df17cbe7230db7054ea07b0157f4e5c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9b92151b024920d39010b73bf34a5ee68d08b64", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjc19rCRBK7hj4Ov3rIwAAm7MIAErIu9PDF7VI64wvuVIKisBL\n1LF4Y0y61XqAu9S9X24INd+OljhfVQlvvczXm1bp4+qMT+RBfg2BvlBIMO5m5uzo\n7SPTcF6keLWOr557cBPf9bt70UdwqA+pdT0/b8wILZFTL542HdVOVvT/QZ218cq2\n0Xj2t+SRWCD9pa0c2ETFec0imSNcoEpKlEIS6lyoM85dGj9egciQD8lArMzR+oHj\n8ESN18RUX1Tjw58egyi24xwXR9DsoZnn/EfwzIrbRv4PX/QUpnpxceAOhbaveznU\n1vXteX2EzBNCg1mXJUbk1nrXL8HZI65WQTaF4L9hlwbYYTsXqGnycfoFWOcmjg8=\n=uXk9\n-----END PGP SIGNATURE-----\n", "payload": "tree f0f013e7df17cbe7230db7054ea07b0157f4e5c3\nparent 769f231371d09ef81193f028be070a3bdec9a202\nparent 3a05db66e2a7f5db2e292f683b36505a493190b9\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1668505451 +0100\ncommitter GitHub <noreply@github.com> 1668505451 +0100\n\nRollup merge of #104316 - cjgillot:simplify-async-suggestion, r=estebank\n\nSimplify suggestions for errors in generators.\n\nSplit from https://github.com/rust-lang/rust/pull/101692/\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9b92151b024920d39010b73bf34a5ee68d08b64", "html_url": "https://github.com/rust-lang/rust/commit/a9b92151b024920d39010b73bf34a5ee68d08b64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9b92151b024920d39010b73bf34a5ee68d08b64/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "769f231371d09ef81193f028be070a3bdec9a202", "url": "https://api.github.com/repos/rust-lang/rust/commits/769f231371d09ef81193f028be070a3bdec9a202", "html_url": "https://github.com/rust-lang/rust/commit/769f231371d09ef81193f028be070a3bdec9a202"}, {"sha": "3a05db66e2a7f5db2e292f683b36505a493190b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a05db66e2a7f5db2e292f683b36505a493190b9", "html_url": "https://github.com/rust-lang/rust/commit/3a05db66e2a7f5db2e292f683b36505a493190b9"}], "stats": {"total": 93, "additions": 42, "deletions": 51}, "files": [{"sha": "84daaf97ecfa8c2dccca83da1b694ec15a6a054f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 42, "deletions": 51, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/a9b92151b024920d39010b73bf34a5ee68d08b64/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b92151b024920d39010b73bf34a5ee68d08b64/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a9b92151b024920d39010b73bf34a5ee68d08b64", "patch": "@@ -44,7 +44,7 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n #[derive(Debug)]\n pub enum GeneratorInteriorOrUpvar {\n     // span of interior type\n-    Interior(Span),\n+    Interior(Span, Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>),\n     // span of upvar\n     Upvar(Span),\n }\n@@ -283,7 +283,6 @@ pub trait TypeErrCtxtExt<'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         interior_or_upvar_span: GeneratorInteriorOrUpvar,\n-        interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         is_async: bool,\n         outer_generator: Option<DefId>,\n         trait_pred: ty::TraitPredicate<'tcx>,\n@@ -2003,17 +2002,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             .as_local()\n             .and_then(|def_id| hir.maybe_body_owned_by(def_id))\n             .map(|body_id| hir.body(body_id));\n-        let is_async = match generator_did.as_local() {\n-            Some(_) => generator_body\n-                .and_then(|body| body.generator_kind())\n-                .map(|generator_kind| matches!(generator_kind, hir::GeneratorKind::Async(..)))\n-                .unwrap_or(false),\n-            None => self\n-                .tcx\n-                .generator_kind(generator_did)\n-                .map(|generator_kind| matches!(generator_kind, hir::GeneratorKind::Async(..)))\n-                .unwrap_or(false),\n-        };\n+        let is_async = self\n+            .tcx\n+            .generator_kind(generator_did)\n+            .map(|generator_kind| matches!(generator_kind, hir::GeneratorKind::Async(..)))\n+            .unwrap_or(false);\n         let mut visitor = AwaitsVisitor::default();\n         if let Some(body) = generator_body {\n             visitor.visit_body(body);\n@@ -2043,61 +2036,60 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             eq\n         };\n \n-        let mut interior_or_upvar_span = None;\n-        let mut interior_extra_info = None;\n-\n         // Get the typeck results from the infcx if the generator is the function we are currently\n         // type-checking; otherwise, get them by performing a query.  This is needed to avoid\n         // cycles. If we can't use resolved types because the generator comes from another crate,\n         // we still provide a targeted error but without all the relevant spans.\n-        let generator_data: Option<GeneratorData<'tcx, '_>> = match &self.typeck_results {\n-            Some(t) if t.hir_owner.to_def_id() == generator_did_root => {\n-                Some(GeneratorData::Local(&t))\n-            }\n+        let generator_data = match &self.typeck_results {\n+            Some(t) if t.hir_owner.to_def_id() == generator_did_root => GeneratorData::Local(&t),\n             _ if generator_did.is_local() => {\n-                Some(GeneratorData::Local(self.tcx.typeck(generator_did.expect_local())))\n+                GeneratorData::Local(self.tcx.typeck(generator_did.expect_local()))\n             }\n-            _ => self\n-                .tcx\n-                .generator_diagnostic_data(generator_did)\n-                .as_ref()\n-                .map(|generator_diag_data| GeneratorData::Foreign(generator_diag_data)),\n+            _ if let Some(generator_diag_data) = self.tcx.generator_diagnostic_data(generator_did) => {\n+                GeneratorData::Foreign(generator_diag_data)\n+            }\n+            _ => return false,\n         };\n \n-        if let Some(generator_data) = generator_data.as_ref() {\n-            interior_or_upvar_span =\n-                generator_data.try_get_upvar_span(&self, generator_did, ty_matches);\n+        let mut interior_or_upvar_span = None;\n \n-            // The generator interior types share the same binders\n-            if let Some(cause) =\n-                generator_data.get_generator_interior_types().skip_binder().iter().find(\n-                    |ty::GeneratorInteriorTypeCause { ty, .. }| {\n-                        ty_matches(generator_data.get_generator_interior_types().rebind(*ty))\n-                    },\n-                )\n-            {\n-                let from_awaited_ty = generator_data.get_from_await_ty(visitor, hir, ty_matches);\n-                let ty::GeneratorInteriorTypeCause { span, scope_span, yield_span, expr, .. } =\n-                    cause;\n+        let from_awaited_ty = generator_data.get_from_await_ty(visitor, hir, ty_matches);\n+        debug!(?from_awaited_ty);\n \n-                interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(*span));\n-                interior_extra_info = Some((*scope_span, *yield_span, *expr, from_awaited_ty));\n-            }\n+        // The generator interior types share the same binders\n+        if let Some(cause) =\n+            generator_data.get_generator_interior_types().skip_binder().iter().find(\n+                |ty::GeneratorInteriorTypeCause { ty, .. }| {\n+                    ty_matches(generator_data.get_generator_interior_types().rebind(*ty))\n+                },\n+            )\n+        {\n+            let ty::GeneratorInteriorTypeCause { span, scope_span, yield_span, expr, .. } = cause;\n \n-            if interior_or_upvar_span.is_none() && generator_data.is_foreign() {\n-                interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(span));\n-            }\n+            interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(\n+                *span,\n+                Some((*scope_span, *yield_span, *expr, from_awaited_ty)),\n+            ));\n         }\n \n+        if interior_or_upvar_span.is_none() {\n+            interior_or_upvar_span =\n+                generator_data.try_get_upvar_span(&self, generator_did, ty_matches);\n+        }\n+\n+        if interior_or_upvar_span.is_none() && generator_data.is_foreign() {\n+            interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(span, None));\n+        }\n+\n+        debug!(?interior_or_upvar_span);\n         if let Some(interior_or_upvar_span) = interior_or_upvar_span {\n-            let typeck_results = generator_data.and_then(|generator_data| match generator_data {\n+            let typeck_results = match generator_data {\n                 GeneratorData::Local(typeck_results) => Some(typeck_results),\n                 GeneratorData::Foreign(_) => None,\n-            });\n+            };\n             self.note_obligation_cause_for_async_await(\n                 err,\n                 interior_or_upvar_span,\n-                interior_extra_info,\n                 is_async,\n                 outer_generator,\n                 trait_ref,\n@@ -2119,7 +2111,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         interior_or_upvar_span: GeneratorInteriorOrUpvar,\n-        interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         is_async: bool,\n         outer_generator: Option<DefId>,\n         trait_pred: ty::TraitPredicate<'tcx>,\n@@ -2241,7 +2232,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n         };\n         match interior_or_upvar_span {\n-            GeneratorInteriorOrUpvar::Interior(interior_span) => {\n+            GeneratorInteriorOrUpvar::Interior(interior_span, interior_extra_info) => {\n                 if let Some((scope_span, yield_span, expr, from_awaited_ty)) = interior_extra_info {\n                     if let Some(await_span) = from_awaited_ty {\n                         // The type causing this obligation is one being awaited at await_span."}]}