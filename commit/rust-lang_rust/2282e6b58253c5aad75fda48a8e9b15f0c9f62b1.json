{"sha": "2282e6b58253c5aad75fda48a8e9b15f0c9f62b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyODJlNmI1ODI1M2M1YWFkNzVmZGE0OGE4ZTliMTVmMGM5ZjYyYjE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-14T09:59:38Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-24T10:04:13Z"}, "message": "represent single field structs as their single field", "tree": {"sha": "9bead3a43427def75e0e57e2e2f49b1ff16b59b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bead3a43427def75e0e57e2e2f49b1ff16b59b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAliwBR0ACgkQpp+NIls6\n19kJqQ//XIYfdZ7FuuvxrQ99cRI0PfWyPXmNmpO1n/f8XzfnQsLI8PeLR5nOjRV8\nApHLzWYEn+7HwiiTmKCvSky3LtUyz6++m0BDXxvHZoRtdfJdC8jsxC/yOUGooust\nQQC/pZgR4ymxtEn5dl9HT7T0pCjqPRWcVB/JmQc1CIW1UGwhl7dYBZw+pS/Dwc8e\nqsLrYp9w76dA99TK8EyxseJCXIc59kqh4EDNRVhsld/Gf2XO6V5zVudsGjpozxRo\nX4EIFyIdauif1V508+vB3RQkAH1SK+fGw9UHFFOonAxB7WfzDCJmEBWcD0zwcn2l\nM0pQyA/vSBhYTLDNsDrxGXTDOEOmlFXrQYV0km+AxpSnb8S95TsUVqRgeC6wMnI0\ngqMiQM8pLsyTxkhJjLLX5hUwz44ukJJa9+dq9O2QNFx73cxXx1iYULksdKxMUlys\nOC8E9IKtmTIttfwazuKemkaIuw+v5dlhqAx3l9QjFCCwMI+5lg3QZ4Ywg2RObKjL\nYN66J0/9nhWVieGQmPcec8gA9nq4RLeQnmu4AXmYS9ILXp5w6R38IDd+bpcHw1qx\neTUQDbco3lmt92Ljzepd2NbmgVXDZO3r/OMZm9j2Q9xTXtEzWoUqlIiSik/v6V/p\nkWbz+Y7kJCLosP9Xc50bQkwaRFu8YZMsuLN1sQuf/GPGksmbMCU=\n=icqO\n-----END PGP SIGNATURE-----", "payload": "tree 9bead3a43427def75e0e57e2e2f49b1ff16b59b3\nparent de42764b5231bf2a8d9ebaaa5572cc1e46dce7f8\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1487066378 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1487930653 +0100\n\nrepresent single field structs as their single field\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1", "html_url": "https://github.com/rust-lang/rust/commit/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de42764b5231bf2a8d9ebaaa5572cc1e46dce7f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/de42764b5231bf2a8d9ebaaa5572cc1e46dce7f8", "html_url": "https://github.com/rust-lang/rust/commit/de42764b5231bf2a8d9ebaaa5572cc1e46dce7f8"}], "stats": {"total": 80, "additions": 64, "deletions": 16}, "files": [{"sha": "123d1f5d47f8ff48f6bd6d4039ac7ea657efae34", "filename": "src/eval_context.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=2282e6b58253c5aad75fda48a8e9b15f0c9f62b1", "patch": "@@ -312,14 +312,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match global_value.value {\n                     Value::ByRef(ptr) => self.memory.mark_static_initalized(ptr.alloc_id, mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n-                        self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n+                        self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n                     },\n                     Value::ByValPair(val1, val2) => {\n                         if let PrimVal::Ptr(ptr) = val1 {\n-                            self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n+                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n                         }\n                         if let PrimVal::Ptr(ptr) = val2 {\n-                            self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n+                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n                         }\n                     },\n                 }\n@@ -369,7 +369,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         discr_val: u128,\n         variant_idx: usize,\n         discr_size: u64,\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        where J::IntoIter: ExactSizeIterator,\n+    {\n         // FIXME(solson)\n         let dest_ptr = self.force_allocation(dest)?.to_ptr();\n \n@@ -392,7 +394,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n         operands: J,\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        where J::IntoIter: ExactSizeIterator,\n+    {\n+        if self.type_size(dest_ty)? == Some(0) {\n+            // zst assigning is a nop\n+            return Ok(());\n+        }\n+        if self.ty_to_primval_kind(dest_ty).is_ok() {\n+            let mut iter = operands.into_iter();\n+            assert_eq!(iter.len(), 1);\n+            let (value, value_ty) = iter.next().unwrap().into_val_ty_pair(self)?;\n+            return self.write_value(value, dest, value_ty);\n+        }\n         for (field_index, operand) in operands.into_iter().enumerate() {\n             let (value, value_ty) = operand.into_val_ty_pair(self)?;\n             let field_dest = self.lvalue_field(dest, field_index, dest_ty, value_ty)?;\n@@ -780,7 +794,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn get_field_count(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, usize> {\n+    pub fn get_field_count(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, usize> {\n         let layout = self.type_layout(ty)?;\n \n         use rustc::ty::layout::Layout::*;\n@@ -1037,8 +1051,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         a: PrimVal,\n         b: PrimVal,\n         ptr: Pointer,\n-        ty: Ty<'tcx>\n+        mut ty: Ty<'tcx>\n     ) -> EvalResult<'tcx> {\n+        while self.get_field_count(ty)? == 1 {\n+            ty = self.get_field_ty(ty, 0)?;\n+        }\n         assert_eq!(self.get_field_count(ty)?, 2);\n         let field_0 = self.get_field_offset(ty, 0)?.bytes();\n         let field_1 = self.get_field_offset(ty, 1)?.bytes();\n@@ -1094,7 +1111,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             ty::TyAdt(ref def, _) if def.is_box() => PrimValKind::Ptr,\n \n-            ty::TyAdt(..) => {\n+            ty::TyAdt(ref def, substs) => {\n                 use rustc::ty::layout::Layout::*;\n                 match *self.type_layout(ty)? {\n                     CEnum { discr, signed, .. } => {\n@@ -1117,6 +1134,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         }\n                     }\n \n+                    // represent single field structs as their single field\n+                    Univariant { .. } => {\n+                        // enums with just one variant are no different, but `.struct_variant()` doesn't work for enums\n+                        let variant = &def.variants[0];\n+                        // FIXME: also allow structs with only a single non zst field\n+                        if variant.fields.len() == 1 {\n+                            return self.ty_to_primval_kind(variant.fields[0].ty(self.tcx, substs));\n+                        } else {\n+                            return Err(EvalError::TypeNotPrimitive(ty));\n+                        }\n+                    }\n+\n                     _ => return Err(EvalError::TypeNotPrimitive(ty)),\n                 }\n             }\n@@ -1305,8 +1334,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                     return self.unsize_into_ptr(src, src_ty, dest, dest_ty, src_ty.boxed_ty(), dest_ty.boxed_ty());\n                 }\n-                // FIXME(solson)\n-                let dest = self.force_allocation(dest)?.to_ptr();\n+                if self.ty_to_primval_kind(src_ty).is_ok() {\n+                    let sty = self.get_field_ty(src_ty, 0)?;\n+                    let dty = self.get_field_ty(dest_ty, 0)?;\n+                    return self.unsize_into(src, sty, dest, dty);\n+                }\n                 // unsizing of generic struct with pointer fields\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n@@ -1323,6 +1355,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => bug!(\"expected pointer, got {:?}\", src),\n                 };\n \n+                // FIXME(solson)\n+                let dest = self.force_allocation(dest)?.to_ptr();\n                 let iter = src_fields.zip(dst_fields).enumerate();\n                 for (i, (src_f, dst_f)) in iter {\n                     let src_fty = monomorphize_field_ty(self.tcx, src_f, substs_a);"}, {"sha": "240b7ced220c8ff5d29913d6b4595964f553d55b", "filename": "src/lvalue.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=2282e6b58253c5aad75fda48a8e9b15f0c9f62b1", "patch": "@@ -223,10 +223,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     (self.force_allocation(base)?.to_ptr(), LvalueExtra::None)\n                 },\n                 Value::ByVal(_) => {\n-                    assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n+                    assert_eq!(field_index, 0, \"ByVal can only have 1 non zst field with offset 0\");\n                     return Ok(base);\n                 },\n                 Value::ByValPair(_, _) => {\n+                    let field_count = self.get_field_count(base_ty)?;\n+                    if field_count == 1 {\n+                        assert_eq!(field_index, 0, \"{:?} has only one field\", base_ty);\n+                        return Ok(base);\n+                    }\n+                    assert_eq!(field_count, 2);\n                     assert!(field_index < 2);\n                     return Ok(Lvalue::Local {\n                         frame,"}, {"sha": "86ca0083f27cd6d13254235034010b5046402479", "filename": "src/memory.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=2282e6b58253c5aad75fda48a8e9b15f0c9f62b1", "patch": "@@ -673,13 +673,24 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     /// mark an allocation as being the entry point to a static (see `static_alloc` field)\n     pub fn mark_static(&mut self, alloc_id: AllocId) {\n+        trace!(\"mark_static: {:?}\", alloc_id);\n         if alloc_id != NEVER_ALLOC_ID && alloc_id != ZST_ALLOC_ID && !self.static_alloc.insert(alloc_id) {\n             bug!(\"tried to mark an allocation ({:?}) as static twice\", alloc_id);\n         }\n     }\n \n+    /// mark an allocation pointed to by a static as static and initialized\n+    pub fn mark_inner_allocation(&mut self, alloc: AllocId, mutable: bool) -> EvalResult<'tcx> {\n+        // relocations into other statics are not \"inner allocations\"\n+        if !self.static_alloc.contains(&alloc) {\n+            self.mark_static_initalized(alloc, mutable)?;\n+        }\n+        Ok(())\n+    }\n+\n     /// mark an allocation as static and initialized, either mutable or not\n     pub fn mark_static_initalized(&mut self, alloc_id: AllocId, mutable: bool) -> EvalResult<'tcx> {\n+        trace!(\"mark_static_initialized {:?}, mutable: {:?}\", alloc_id, mutable);\n         // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n@@ -699,10 +710,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n-            // relocations into other statics are not \"inner allocations\"\n-            if !self.static_alloc.contains(&alloc) {\n-                self.mark_static_initalized(alloc, mutable)?;\n-            }\n+            self.mark_inner_allocation(alloc, mutable)?;\n         }\n         // put back the relocations\n         self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;"}, {"sha": "c258d56ded421bfbb63a516a55eeb1a70ee537be", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282e6b58253c5aad75fda48a8e9b15f0c9f62b1/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=2282e6b58253c5aad75fda48a8e9b15f0c9f62b1", "patch": "@@ -490,7 +490,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 args.push((undef, field_ty));\n                             }\n                         },\n-                        _ => bug!(\"rust-call ABI tuple argument was {:?}\", last),\n+                        _ => bug!(\"rust-call ABI tuple argument was {:?}, but {:?} were expected\", last, fields),\n                     }\n                 }\n                 ty => bug!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),"}]}