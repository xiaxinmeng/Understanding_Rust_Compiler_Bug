{"sha": "7b7b938be1123631fed4e021fd3ef9562cf81b0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiN2I5MzhiZTExMjM2MzFmZWQ0ZTAyMWZkM2VmOTU2MmNmODFiMGM=", "commit": {"author": {"name": "Mihnea Dobrescu-Balaur", "email": "mihnea@linux.com", "date": "2015-02-25T23:03:06Z"}, "committer": {"name": "Mihnea Dobrescu-Balaur", "email": "mihnea@linux.com", "date": "2015-03-14T18:45:27Z"}, "message": "Add support to search functions by type to rustdoc.", "tree": {"sha": "c518135a0d0d90e440eaddf8964dd0c3cc5c4d61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c518135a0d0d90e440eaddf8964dd0c3cc5c4d61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b7b938be1123631fed4e021fd3ef9562cf81b0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7b938be1123631fed4e021fd3ef9562cf81b0c", "html_url": "https://github.com/rust-lang/rust/commit/7b7b938be1123631fed4e021fd3ef9562cf81b0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b7b938be1123631fed4e021fd3ef9562cf81b0c/comments", "author": {"login": "mihneadb", "id": 643127, "node_id": "MDQ6VXNlcjY0MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/643127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mihneadb", "html_url": "https://github.com/mihneadb", "followers_url": "https://api.github.com/users/mihneadb/followers", "following_url": "https://api.github.com/users/mihneadb/following{/other_user}", "gists_url": "https://api.github.com/users/mihneadb/gists{/gist_id}", "starred_url": "https://api.github.com/users/mihneadb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mihneadb/subscriptions", "organizations_url": "https://api.github.com/users/mihneadb/orgs", "repos_url": "https://api.github.com/users/mihneadb/repos", "events_url": "https://api.github.com/users/mihneadb/events{/privacy}", "received_events_url": "https://api.github.com/users/mihneadb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mihneadb", "id": 643127, "node_id": "MDQ6VXNlcjY0MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/643127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mihneadb", "html_url": "https://github.com/mihneadb", "followers_url": "https://api.github.com/users/mihneadb/followers", "following_url": "https://api.github.com/users/mihneadb/following{/other_user}", "gists_url": "https://api.github.com/users/mihneadb/gists{/gist_id}", "starred_url": "https://api.github.com/users/mihneadb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mihneadb/subscriptions", "organizations_url": "https://api.github.com/users/mihneadb/orgs", "repos_url": "https://api.github.com/users/mihneadb/repos", "events_url": "https://api.github.com/users/mihneadb/events{/privacy}", "received_events_url": "https://api.github.com/users/mihneadb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "880fb89bde126aa43fc348d0b93839d3d18a1f51", "url": "https://api.github.com/repos/rust-lang/rust/commits/880fb89bde126aa43fc348d0b93839d3d18a1f51", "html_url": "https://github.com/rust-lang/rust/commit/880fb89bde126aa43fc348d0b93839d3d18a1f51"}], "stats": {"total": 145, "additions": 142, "deletions": 3}, "files": [{"sha": "c481b72916478c5b95968ff1bc95aec34dca6fe1", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 107, "deletions": 1, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7b7b938be1123631fed4e021fd3ef9562cf81b0c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7b938be1123631fed4e021fd3ef9562cf81b0c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7b7b938be1123631fed4e021fd3ef9562cf81b0c", "patch": "@@ -34,6 +34,7 @@\n //! both occur before the crate is rendered.\n pub use self::ExternalLocation::*;\n \n+use std::ascii::OwnedAsciiExt;\n use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::collections::{HashMap, HashSet};\n@@ -246,6 +247,51 @@ struct IndexItem {\n     path: String,\n     desc: String,\n     parent: Option<ast::DefId>,\n+    search_type: Option<IndexItemFunctionType>,\n+}\n+\n+/// A type used for the search index.\n+struct Type {\n+    name: Option<String>,\n+}\n+\n+impl fmt::Display for Type {\n+    /// Formats type as {name: $name}.\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // Wrapping struct fmt should never call us when self.name is None,\n+        // but just to be safe we write `null` in that case.\n+        match self.name {\n+            Some(ref n) => write!(f, \"{{\\\"name\\\":\\\"{}\\\"}}\", n),\n+            None => write!(f, \"null\")\n+        }\n+    }\n+}\n+\n+/// Full type of functions/methods in the search index.\n+struct IndexItemFunctionType {\n+    inputs: Vec<Type>,\n+    output: Option<Type>\n+}\n+\n+impl fmt::Display for IndexItemFunctionType {\n+    /// Formats a full fn type as a JSON {inputs: [Type], outputs: Type/null}.\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // If we couldn't figure out a type, just write `null`.\n+        if self.inputs.iter().any(|ref i| i.name.is_none()) ||\n+           (self.output.is_some() && self.output.as_ref().unwrap().name.is_none()) {\n+            return write!(f, \"null\")\n+        }\n+\n+        let inputs: Vec<String> = self.inputs.iter().map(|ref t| format!(\"{}\", t)).collect();\n+        try!(write!(f, \"{{\\\"inputs\\\":[{}],\\\"output\\\":\", inputs.connect(\",\")));\n+\n+        match self.output {\n+            Some(ref t) => try!(write!(f, \"{}\", t)),\n+            None => try!(write!(f, \"null\"))\n+        };\n+\n+        Ok(try!(write!(f, \"}}\")))\n+    }\n }\n \n // TLS keys used to carry information around during rendering.\n@@ -413,6 +459,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> old_io::IoResult<Stri\n                         path: fqp[..fqp.len() - 1].connect(\"::\"),\n                         desc: shorter(item.doc_value()).to_string(),\n                         parent: Some(did),\n+                        search_type: None,\n                     });\n                 },\n                 None => {}\n@@ -462,7 +509,11 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> old_io::IoResult<Stri\n                 let pathid = *nodeid_to_pathid.get(&nodeid).unwrap();\n                 try!(write!(&mut w, \",{}\", pathid));\n             }\n-            None => {}\n+            None => try!(write!(&mut w, \",null\"))\n+        }\n+        match item.search_type {\n+            Some(ref t) => try!(write!(&mut w, \",{}\", t)),\n+            None => try!(write!(&mut w, \",null\"))\n         }\n         try!(write!(&mut w, \"]\"));\n     }\n@@ -877,12 +928,21 @@ impl DocFolder for Cache {\n \n             match parent {\n                 (parent, Some(path)) if is_method || (!self.privmod && !hidden_field) => {\n+                    // Needed to determine `self` type.\n+                    let parent_basename = self.parent_stack.first().and_then(|parent| {\n+                        match self.paths.get(parent) {\n+                            Some(&(ref fqp, _)) => Some(fqp[fqp.len() - 1].clone()),\n+                            _ => None\n+                        }\n+                    });\n+\n                     self.search_index.push(IndexItem {\n                         ty: shortty(&item),\n                         name: s.to_string(),\n                         path: path.connect(\"::\").to_string(),\n                         desc: shorter(item.doc_value()).to_string(),\n                         parent: parent,\n+                        search_type: get_index_search_type(&item, parent_basename),\n                     });\n                 }\n                 (Some(parent), None) if is_method || (!self.privmod && !hidden_field)=> {\n@@ -2304,6 +2364,52 @@ fn make_item_keywords(it: &clean::Item) -> String {\n     format!(\"{}, {}\", get_basic_keywords(), it.name.as_ref().unwrap())\n }\n \n+fn get_index_search_type(item: &clean::Item,\n+                         parent: Option<String>) -> Option<IndexItemFunctionType> {\n+    let decl = match item.inner {\n+        clean::FunctionItem(ref f) => &f.decl,\n+        clean::MethodItem(ref m) => &m.decl,\n+        clean::TyMethodItem(ref m) => &m.decl,\n+        _ => return None\n+    };\n+\n+    let mut inputs = Vec::new();\n+\n+    // Consider `self` an argument as well.\n+    if let Some(name) = parent {\n+        inputs.push(Type { name: Some(name.into_ascii_lowercase()) });\n+    }\n+\n+    inputs.extend(&mut decl.inputs.values.iter().map(|arg| {\n+        get_index_type(&arg.type_)\n+    }));\n+\n+    let output = match decl.output {\n+        clean::FunctionRetTy::Return(ref return_type) => Some(get_index_type(return_type)),\n+        _ => None\n+    };\n+\n+    Some(IndexItemFunctionType { inputs: inputs, output: output })\n+}\n+\n+fn get_index_type(clean_type: &clean::Type) -> Type {\n+    Type { name: get_index_type_name(clean_type).map(|s| s.into_ascii_lowercase()) }\n+}\n+\n+fn get_index_type_name(clean_type: &clean::Type) -> Option<String> {\n+    match *clean_type {\n+        clean::ResolvedPath { ref path, .. } => {\n+            let segments = &path.segments;\n+            Some(segments[segments.len() - 1].name.clone())\n+        },\n+        clean::Generic(ref s) => Some(s.clone()),\n+        clean::Primitive(ref p) => Some(format!(\"{:?}\", p)),\n+        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_),\n+        // FIXME: add all from clean::Type.\n+        _ => None\n+    }\n+}\n+\n pub fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }"}, {"sha": "64478bf7227b01de755c55827b42c2fc1add84b9", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7b7b938be1123631fed4e021fd3ef9562cf81b0c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/7b7b938be1123631fed4e021fd3ef9562cf81b0c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=7b7b938be1123631fed4e021fd3ef9562cf81b0c", "patch": "@@ -205,6 +205,33 @@\n                         break;\n                     }\n                 }\n+            // searching by type\n+            } else if (val.search(\"->\") > -1) {\n+                var trimmer = function (s) { return s.trim(); };\n+                var parts = val.split(\"->\").map(trimmer);\n+                var input = parts[0];\n+                // sort inputs so that order does not matter\n+                var inputs = input.split(\",\").map(trimmer).sort();\n+                var output = parts[1];\n+\n+                for (var i = 0; i < nSearchWords; ++i) {\n+                    var type = searchIndex[i].type;\n+                    if (!type) {\n+                        continue;\n+                    }\n+\n+                    // sort index inputs so that order does not matter\n+                    var typeInputs = type.inputs.map(function (input) {\n+                        return input.name;\n+                    }).sort();\n+\n+                    // allow searching for void (no output) functions as well\n+                    var typeOutput = type.output ? type.output.name : \"\";\n+                    if (inputs.toString() === typeInputs.toString() &&\n+                        output == typeOutput) {\n+                        results.push({id: i, index: -1, dontValidate: true});\n+                    }\n+                }\n             } else {\n                 // gather matching search results up to a certain maximum\n                 val = val.replace(/\\_/g, \"\");\n@@ -325,6 +352,11 @@\n                     path = result.item.path.toLowerCase(),\n                     parent = result.item.parent;\n \n+                // this validation does not make sense when searching by types\n+                if (result.dontValidate) {\n+                    continue;\n+                }\n+\n                 var valid = validateResult(name, path, split, parent);\n                 if (!valid) {\n                     result.id = -1;\n@@ -590,7 +622,8 @@\n                 //              (String) name,\n                 //              (String) full path or empty string for previous path,\n                 //              (String) description,\n-                //              (optional Number) the parent path index to `paths`]\n+                //              (Number | null) the parent path index to `paths`]\n+                //              (Object | null) the type of the function (if any)\n                 var items = rawSearchIndex[crate].items;\n                 // an array of [(Number) item type,\n                 //              (String) name]\n@@ -615,7 +648,7 @@\n                     var rawRow = items[i];\n                     var row = {crate: crate, ty: rawRow[0], name: rawRow[1],\n                                path: rawRow[2] || lastPath, desc: rawRow[3],\n-                               parent: paths[rawRow[4]]};\n+                               parent: paths[rawRow[4]], type: rawRow[5]};\n                     searchIndex.push(row);\n                     if (typeof row.name === \"string\") {\n                         var word = row.name.toLowerCase();"}]}