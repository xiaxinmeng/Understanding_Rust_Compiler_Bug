{"sha": "8f3e96d6589fad610107fa05ba80fc708965561b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmM2U5NmQ2NTg5ZmFkNjEwMTA3ZmEwNWJhODBmYzcwODk2NTU2MWI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-28T12:12:20Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-05-01T12:40:17Z"}, "message": "Monomorphise try_execute_query.", "tree": {"sha": "b9ca877c0379fb4d7cb5d2265429ce1f9663c4ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9ca877c0379fb4d7cb5d2265429ce1f9663c4ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f3e96d6589fad610107fa05ba80fc708965561b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f3e96d6589fad610107fa05ba80fc708965561b", "html_url": "https://github.com/rust-lang/rust/commit/8f3e96d6589fad610107fa05ba80fc708965561b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f3e96d6589fad610107fa05ba80fc708965561b/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c7376e7979ee8179c030d101af2d7919369caa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c7376e7979ee8179c030d101af2d7919369caa7", "html_url": "https://github.com/rust-lang/rust/commit/1c7376e7979ee8179c030d101af2d7919369caa7"}], "stats": {"total": 81, "additions": 38, "deletions": 43}, "files": [{"sha": "a334e897e400e9f3fadf70badbfe7d2a3693f62a", "filename": "src/librustc_query_system/query/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f3e96d6589fad610107fa05ba80fc708965561b/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3e96d6589fad610107fa05ba80fc708965561b/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs?ref=8f3e96d6589fad610107fa05ba80fc708965561b", "patch": "@@ -28,6 +28,7 @@ pub(crate) struct QueryVtable<CTX: QueryContext, K, V> {\n     pub anon: bool,\n     pub dep_kind: CTX::DepKind,\n     pub eval_always: bool,\n+    pub to_dep_node: fn(CTX, &K) -> DepNode<CTX::DepKind>,\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n     pub compute: fn(CTX, K) -> V,\n@@ -39,6 +40,10 @@ pub(crate) struct QueryVtable<CTX: QueryContext, K, V> {\n }\n \n impl<CTX: QueryContext, K, V> QueryVtable<CTX, K, V> {\n+    pub(crate) fn to_dep_node(&self, tcx: CTX, key: &K) -> DepNode<CTX::DepKind> {\n+        (self.to_dep_node)(tcx, key)\n+    }\n+\n     pub(crate) fn compute(&self, tcx: CTX, key: K) -> V {\n         (self.compute)(tcx, key)\n     }\n@@ -112,6 +117,7 @@ where\n     const VTABLE: QueryVtable<CTX, Q::Key, Q::Value> = QueryVtable {\n         anon: Q::ANON,\n         dep_kind: Q::DEP_KIND,\n+        to_dep_node: Q::to_dep_node,\n         eval_always: Q::EVAL_ALWAYS,\n         compute: Q::compute,\n         hash_result: Q::hash_result,"}, {"sha": "74a2288cfa790304052d5d92c36ca8171e09303b", "filename": "src/librustc_query_system/query/plumbing.rs", "status": "modified", "additions": 32, "deletions": 43, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8f3e96d6589fad610107fa05ba80fc708965561b/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3e96d6589fad610107fa05ba80fc708965561b/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs?ref=8f3e96d6589fad610107fa05ba80fc708965561b", "patch": "@@ -382,17 +382,21 @@ where\n }\n \n #[inline(always)]\n-fn try_execute_query<Q, CTX>(\n+fn try_execute_query<CTX, C>(\n     tcx: CTX,\n+    state: &QueryState<CTX, C>,\n     span: Span,\n-    key: Q::Key,\n-    lookup: QueryLookup<'_, CTX, Q::Key, <Q::Cache as QueryCache>::Sharded>,\n-) -> Q::Stored\n+    key: C::Key,\n+    lookup: QueryLookup<'_, CTX, C::Key, C::Sharded>,\n+    query: &QueryVtable<CTX, C::Key, C::Value>,\n+) -> C::Stored\n where\n-    Q: QueryDescription<CTX>,\n+    C: QueryCache,\n+    C::Key: Eq + Clone + Debug,\n+    C::Stored: Clone,\n     CTX: QueryContext,\n {\n-    let job = match JobOwner::try_start(tcx, Q::query_state(tcx), span, &key, lookup, &Q::VTABLE) {\n+    let job = match JobOwner::try_start(tcx, state, span, &key, lookup, query) {\n         TryGetJob::NotYetStarted(job) => job,\n         TryGetJob::Cycle(result) => return result,\n         #[cfg(parallel_compiler)]\n@@ -406,18 +410,32 @@ where\n     // expensive for some `DepKind`s.\n     if !tcx.dep_graph().is_fully_enabled() {\n         let null_dep_node = DepNode::new_no_params(DepKind::NULL);\n-        return force_query_with_job(tcx, key, job, null_dep_node, &Q::VTABLE).0;\n+        return force_query_with_job(tcx, key, job, null_dep_node, query).0;\n     }\n \n-    if Q::ANON {\n-        let (result, dep_node_index) = try_execute_anon_query(tcx, key, job.id, &Q::VTABLE);\n+    if query.anon {\n+        let prof_timer = tcx.profiler().query_provider();\n+\n+        let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n+            tcx.start_query(job.id, diagnostics, |tcx| {\n+                tcx.dep_graph().with_anon_task(query.dep_kind, || query.compute(tcx, key))\n+            })\n+        });\n+\n+        prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n+\n+        tcx.dep_graph().read_index(dep_node_index);\n+\n+        if unlikely!(!diagnostics.is_empty()) {\n+            tcx.store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+        }\n \n         return job.complete(tcx, result, dep_node_index);\n     }\n \n-    let dep_node = Q::to_dep_node(tcx, &key);\n+    let dep_node = query.to_dep_node(tcx, &key);\n \n-    if !Q::EVAL_ALWAYS {\n+    if !query.eval_always {\n         // The diagnostics for this query will be\n         // promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n@@ -431,7 +449,7 @@ where\n                         prev_dep_node_index,\n                         dep_node_index,\n                         &dep_node,\n-                        &Q::VTABLE,\n+                        query,\n                     ),\n                     dep_node_index,\n                 )\n@@ -442,40 +460,11 @@ where\n         }\n     }\n \n-    let (result, dep_node_index) = force_query_with_job(tcx, key, job, dep_node, &Q::VTABLE);\n+    let (result, dep_node_index) = force_query_with_job(tcx, key, job, dep_node, query);\n     tcx.dep_graph().read_index(dep_node_index);\n     result\n }\n \n-fn try_execute_anon_query<CTX, K, V>(\n-    tcx: CTX,\n-    key: K,\n-    job_id: QueryJobId<CTX::DepKind>,\n-    query: &QueryVtable<CTX, K, V>,\n-) -> (V, DepNodeIndex)\n-where\n-    CTX: QueryContext,\n-{\n-    debug_assert!(query.anon);\n-    let prof_timer = tcx.profiler().query_provider();\n-\n-    let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-        tcx.start_query(job_id, diagnostics, |tcx| {\n-            tcx.dep_graph().with_anon_task(query.dep_kind, || query.compute(tcx, key))\n-        })\n-    });\n-\n-    prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n-\n-    tcx.dep_graph().read_index(dep_node_index);\n-\n-    if unlikely!(!diagnostics.is_empty()) {\n-        tcx.store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n-    }\n-\n-    (result, dep_node_index)\n-}\n-\n fn load_from_disk_and_cache_in_memory<CTX, K, V>(\n     tcx: CTX,\n     key: K,\n@@ -639,7 +628,7 @@ where\n             tcx.dep_graph().read_index(index);\n             value.clone()\n         },\n-        |key, lookup| try_execute_query::<Q, _>(tcx, span, key, lookup),\n+        |key, lookup| try_execute_query(tcx, Q::query_state(tcx), span, key, lookup, &Q::VTABLE),\n     )\n }\n "}]}