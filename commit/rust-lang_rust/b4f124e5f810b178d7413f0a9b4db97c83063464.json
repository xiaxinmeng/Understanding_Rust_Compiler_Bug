{"sha": "b4f124e5f810b178d7413f0a9b4db97c83063464", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZjEyNGU1ZjgxMGIxNzhkNzQxM2YwYTliNGRiOTdjODMwNjM0NjQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-05T00:58:13Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-05T01:01:00Z"}, "message": "docs: Don't talk about mutable vecs in tutorial. Use inherited mutability", "tree": {"sha": "2b4d14e3917ef7ecabb71421a997c815855c7c1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b4d14e3917ef7ecabb71421a997c815855c7c1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4f124e5f810b178d7413f0a9b4db97c83063464", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4f124e5f810b178d7413f0a9b4db97c83063464", "html_url": "https://github.com/rust-lang/rust/commit/b4f124e5f810b178d7413f0a9b4db97c83063464", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4f124e5f810b178d7413f0a9b4db97c83063464/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88ae10165b42bbd8fbad2d458b64c02e2b66e77b", "url": "https://api.github.com/repos/rust-lang/rust/commits/88ae10165b42bbd8fbad2d458b64c02e2b66e77b", "html_url": "https://github.com/rust-lang/rust/commit/88ae10165b42bbd8fbad2d458b64c02e2b66e77b"}], "stats": {"total": 99, "additions": 55, "deletions": 44}, "files": [{"sha": "7b4c5c5e7b64e8b6a4a35610f0f43ab13e5b96e8", "filename": "doc/tutorial.md", "status": "modified", "additions": 55, "deletions": 44, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b4f124e5f810b178d7413f0a9b4db97c83063464/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b4f124e5f810b178d7413f0a9b4db97c83063464/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=b4f124e5f810b178d7413f0a9b4db97c83063464", "patch": "@@ -1237,109 +1237,120 @@ pointers to vectors are also called 'slices'.\n enum Crayon {\n     Almond, AntiqueBrass, Apricot,\n     Aquamarine, Asparagus, AtomicTangerine,\n-    BananaMania, Beaver, Bittersweet\n+    BananaMania, Beaver, Bittersweet,\n+    Black, BlizzardBlue, Blue\n }\n \n // A fixed-size stack vector\n let stack_crayons: [Crayon * 3] = [Almond, AntiqueBrass, Apricot];\n \n // A borrowed pointer to stack allocated vector\n-let stack_crayons: &[Crayon] = &[Almond, AntiqueBrass, Apricot];\n+let stack_crayons: &[Crayon] = &[Aquamarine, Asparagus, AtomicTangerine];\n \n // A local heap (managed) vector of crayons\n-let local_crayons: @[Crayon] = @[Aquamarine, Asparagus, AtomicTangerine];\n+let local_crayons: @[Crayon] = @[BananaMania, Beaver, Bittersweet];\n \n // An exchange heap (owned) vector of crayons\n-let exchange_crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n+let exchange_crayons: ~[Crayon] = ~[Black, BlizzardBlue, Blue];\n ~~~\n \n-Vector literals are enclosed in square brackets and dereferencing is\n-also done with square brackets (zero-based):\n+The `+` operator means concatenation when applied to vector types.\n \n ~~~~\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n #               Aquamarine, Asparagus, AtomicTangerine,\n #               BananaMania, Beaver, Bittersweet };\n-# fn draw_scene(c: Crayon) { }\n \n-let crayons: [Crayon * 3] = [BananaMania, Beaver, Bittersweet];\n-match crayons[0] {\n-    Bittersweet => draw_scene(crayons[0]),\n-    _ => ()\n-}\n+let my_crayons = ~[Almond, AntiqueBrass, Apricot];\n+let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n+\n+// Add two vectors to create a new one\n+let our_crayons = my_crayons + your_crayons;\n+\n+// += will append to a vector, provided it leves\n+// in a mutable slot\n+let mut my_crayons = move my_crayons;\n+my_crayons += your_crayons;\n ~~~~\n \n-By default, vectors are immutable\u2014you can not replace their elements.\n-The type written as `[mut T]` is a vector with mutable\n-elements. Mutable vector literals are written `[mut]` (empty) or `[mut\n-1, 2, 3]` (with elements).\n+> ***Note:*** The above examples of vector addition use owned\n+> vectors. Some operations on slices and stack vectors are\n+> not well supported yet, owned vectors are often the most\n+> usable.\n+\n+Indexing into vectors is done with square brackets:\n \n ~~~~\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n #               Aquamarine, Asparagus, AtomicTangerine,\n #               BananaMania, Beaver, Bittersweet };\n-\n-let crayons: [mut Crayon * 3] = [mut BananaMania, Beaver, Bittersweet];\n-crayons[0] = AtomicTangerine;\n+# fn draw_scene(c: Crayon) { }\n+let crayons: [Crayon * 3] = [BananaMania, Beaver, Bittersweet];\n+match crayons[0] {\n+    Bittersweet => draw_scene(crayons[0]),\n+    _ => ()\n+}\n ~~~~\n \n-The `+` operator means concatenation when applied to vector types.\n+The elements of a vector _inherit the mutability of the vector_,\n+and as such individual elements may not be reassigned when the\n+vector lives in an immutable slot.\n \n-~~~~\n+~~~ {.xfail-test}\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n #               Aquamarine, Asparagus, AtomicTangerine,\n #               BananaMania, Beaver, Bittersweet };\n+let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n \n-let my_crayons = ~[Almond, AntiqueBrass, Apricot];\n-let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n-\n-let our_crayons = my_crayons + your_crayons;\n-~~~~\n+crayons[0] = Apricot; // ERROR: Can't assign to immutable vector\n+~~~\n \n-The `+=` operator also works as expected, provided the assignee\n-lives in a mutable slot.\n+Moving it into a mutable slot makes the elements assignable.\n \n-~~~~\n+~~~\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n #               Aquamarine, Asparagus, AtomicTangerine,\n #               BananaMania, Beaver, Bittersweet };\n+let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n \n-let mut my_crayons = ~[Almond, AntiqueBrass, Apricot];\n-let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n+// Put the vector into a mutable slot\n+let mut mutable_crayons = move crayons;\n \n-my_crayons += your_crayons;\n-~~~~\n+// Now it's mutable to the bone\n+mutable_crayons[0] = Apricot;\n+~~~\n \n-> ***Note:*** The above examples of vector addition use owned\n-> vectors. Some operations on slices and stack vectors are\n-> not well supported yet, owned vectors are often the most\n-> usable.\n+This is a simple example of Rust's _dual-mode data structures_, also\n+referred to as _freezing and thawing_.\n \n Strings are implemented with vectors of `[u8]`, though they have a distinct\n type. They support most of the same allocation options as\n vectors, though the string literal without a storage sigil, e.g.\n `\"foo\"` is treated differently than a comparable vector (`[foo]`).\n Whereas plain vectors are stack-allocated fixed-length vectors,\n-plain strings are region pointers to read-only memory.\n+plain strings are region pointers to read-only memory. Strings\n+are always immutable.\n \n ~~~\n // A plain string is a slice to read-only (static) memory\n let stack_crayons: &str = \"Almond, AntiqueBrass, Apricot\";\n \n // The same thing, but with the `&`\n-let stack_crayons: &str = &\"Almond, AntiqueBrass, Apricot\";\n+let stack_crayons: &str = &\"Aquamarine, Asparagus, AtomicTangerine\";\n \n // A local heap (managed) string\n-let local_crayons: @str = @\"Aquamarine, Asparagus, AtomicTangerine\";\n+let local_crayons: @str = @\"BananMania, Beaver, Bittersweet\";\n \n // An exchange heap (owned) string\n-let exchange_crayons: ~str = ~\"BananaMania, Beaver, Bittersweet\";\n+let exchange_crayons: ~str = ~\"Black, BlizzardBlue, Blue\";\n ~~~\n \n Both vectors and strings support a number of useful\n-[methods](#implementation).  While we haven't covered methods yet,\n-most vector functionality is provided by methods, so let's have a\n-brief look at a few common ones.\n+[methods](#functions-and-methods), defined in [`core::vec`]\n+and [`core::str`]. Here are some examples.\n+\n+[`core::vec`]: core/vec.html\n+[`core::str`]: core/str.html\n \n ~~~\n # use io::println;"}]}