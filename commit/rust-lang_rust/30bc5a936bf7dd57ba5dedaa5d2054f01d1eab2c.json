{"sha": "30bc5a936bf7dd57ba5dedaa5d2054f01d1eab2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYmM1YTkzNmJmN2RkNTdiYTVkZWRhYTVkMjA1NGYwMWQxZWFiMmM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2021-07-13T20:56:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2021-08-03T14:06:19Z"}, "message": "Move abort_unwinding_calls earlier", "tree": {"sha": "1f126efd7e6d2368315bced76c324a081808c7f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f126efd7e6d2368315bced76c324a081808c7f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30bc5a936bf7dd57ba5dedaa5d2054f01d1eab2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30bc5a936bf7dd57ba5dedaa5d2054f01d1eab2c", "html_url": "https://github.com/rust-lang/rust/commit/30bc5a936bf7dd57ba5dedaa5d2054f01d1eab2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30bc5a936bf7dd57ba5dedaa5d2054f01d1eab2c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c07096a45a15de64216f12ec726333870e372b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c07096a45a15de64216f12ec726333870e372b1", "html_url": "https://github.com/rust-lang/rust/commit/1c07096a45a15de64216f12ec726333870e372b1"}], "stats": {"total": 80, "additions": 54, "deletions": 26}, "files": [{"sha": "44287dbd608e91372c50f66c1086ffacd9c7db6e", "filename": "compiler/rustc_mir/src/transform/abort_unwinding_calls.rs", "status": "modified", "additions": 50, "deletions": 22, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/30bc5a936bf7dd57ba5dedaa5d2054f01d1eab2c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fabort_unwinding_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bc5a936bf7dd57ba5dedaa5d2054f01d1eab2c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fabort_unwinding_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fabort_unwinding_calls.rs?ref=30bc5a936bf7dd57ba5dedaa5d2054f01d1eab2c", "patch": "@@ -1,4 +1,5 @@\n use crate::transform::MirPass;\n+use rustc_hir::def::DefKind;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::*;\n use rustc_middle::ty::layout;\n@@ -24,15 +25,28 @@ pub struct AbortUnwindingCalls;\n \n impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let def_id = body.source.def_id();\n+        let kind = tcx.def_kind(def_id);\n+\n+        // We don't simplify the MIR of constants at this time because that\n+        // namely results in a cyclic query when we call `tcx.type_of` below.\n+        let is_function = match kind {\n+            DefKind::Fn | DefKind::AssocFn | DefKind::Ctor(..) => true,\n+            _ => tcx.is_closure(def_id),\n+        };\n+        if !is_function {\n+            return;\n+        }\n+\n         // This pass only runs on functions which themselves cannot unwind,\n         // forcibly changing the body of the function to structurally provide\n         // this guarantee by aborting on an unwind. If this function can unwind,\n         // then there's nothing to do because it already should work correctly.\n         //\n         // Here we test for this function itself whether its ABI allows\n         // unwinding or not.\n-        let body_flags = tcx.codegen_fn_attrs(body.source.def_id()).flags;\n-        let body_ty = tcx.type_of(body.source.def_id());\n+        let body_flags = tcx.codegen_fn_attrs(def_id).flags;\n+        let body_ty = tcx.type_of(def_id);\n         let body_abi = match body_ty.kind() {\n             ty::FnDef(..) => body_ty.fn_sig(tcx).abi(),\n             ty::Closure(..) => Abi::RustCall,\n@@ -51,22 +65,31 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n             if block.is_cleanup {\n                 continue;\n             }\n+            let terminator = match &block.terminator {\n+                Some(terminator) => terminator,\n+                None => continue,\n+            };\n+            let span = terminator.source_info.span;\n \n-            let (func, source_info) = match &block.terminator {\n-                Some(Terminator { kind: TerminatorKind::Call { func, .. }, source_info }) => {\n-                    (func, source_info)\n+            let call_can_unwind = match &terminator.kind {\n+                TerminatorKind::Call { func, .. } => {\n+                    let ty = func.ty(body, tcx);\n+                    let sig = ty.fn_sig(tcx);\n+                    let flags = match ty.kind() {\n+                        ty::FnPtr(_) => CodegenFnAttrFlags::empty(),\n+                        ty::FnDef(def_id, _) => tcx.codegen_fn_attrs(*def_id).flags,\n+                        _ => span_bug!(span, \"invalid callee of type {:?}\", ty),\n+                    };\n+                    layout::fn_can_unwind(tcx, flags, sig.abi())\n+                }\n+                TerminatorKind::Drop { .. }\n+                | TerminatorKind::DropAndReplace { .. }\n+                | TerminatorKind::Assert { .. }\n+                | TerminatorKind::FalseUnwind { .. } => {\n+                    layout::fn_can_unwind(tcx, CodegenFnAttrFlags::empty(), Abi::Rust)\n                 }\n                 _ => continue,\n             };\n-            let ty = func.ty(body, tcx);\n-            let sig = ty.fn_sig(tcx);\n-            let flags = match ty.kind() {\n-                ty::FnPtr(_) => CodegenFnAttrFlags::empty(),\n-                ty::FnDef(def_id, _) => tcx.codegen_fn_attrs(*def_id).flags,\n-                _ => span_bug!(source_info.span, \"invalid callee of type {:?}\", ty),\n-            };\n-\n-            let call_can_unwind = layout::fn_can_unwind(tcx, flags, sig.abi());\n \n             // If this function call can't unwind, then there's no need for it\n             // to have a landing pad. This means that we can remove any cleanup\n@@ -102,23 +125,28 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n             let abort_bb = body.basic_blocks_mut().push(bb);\n \n             for bb in calls_to_terminate {\n-                let cleanup = match &mut body.basic_blocks_mut()[bb].terminator {\n-                    Some(Terminator { kind: TerminatorKind::Call { cleanup, .. }, .. }) => cleanup,\n-                    _ => unreachable!(),\n-                };\n+                let cleanup = get_cleanup(body.basic_blocks_mut()[bb].terminator_mut());\n                 *cleanup = Some(abort_bb);\n             }\n         }\n \n         for id in cleanups_to_remove {\n-            let cleanup = match &mut body.basic_blocks_mut()[id].terminator {\n-                Some(Terminator { kind: TerminatorKind::Call { cleanup, .. }, .. }) => cleanup,\n-                _ => unreachable!(),\n-            };\n+            let cleanup = get_cleanup(body.basic_blocks_mut()[id].terminator_mut());\n             *cleanup = None;\n         }\n \n         // We may have invalidated some `cleanup` blocks so clean those up now.\n         super::simplify::remove_dead_blocks(tcx, body);\n     }\n }\n+\n+fn get_cleanup<'a>(t: &'a mut Terminator<'_>) -> &'a mut Option<BasicBlock> {\n+    match &mut t.kind {\n+        TerminatorKind::Call { cleanup, .. }\n+        | TerminatorKind::Drop { unwind: cleanup, .. }\n+        | TerminatorKind::DropAndReplace { unwind: cleanup, .. }\n+        | TerminatorKind::Assert { cleanup, .. }\n+        | TerminatorKind::FalseUnwind { unwind: cleanup, .. } => cleanup,\n+        _ => unreachable!(),\n+    }\n+}"}, {"sha": "fa648a6dd49ff5f2d2c22d33f9ed26b137a86d16", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30bc5a936bf7dd57ba5dedaa5d2054f01d1eab2c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bc5a936bf7dd57ba5dedaa5d2054f01d1eab2c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=30bc5a936bf7dd57ba5dedaa5d2054f01d1eab2c", "patch": "@@ -458,6 +458,10 @@ fn run_post_borrowck_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tc\n         // These next passes must be executed together\n         &add_call_guards::CriticalCallEdges,\n         &elaborate_drops::ElaborateDrops,\n+        // This will remove extraneous landing pads which are no longer\n+        // necessary as well as well as forcing any call in a non-unwinding\n+        // function calling a possibly-unwinding function to abort the process.\n+        &abort_unwinding_calls::AbortUnwindingCalls,\n         // AddMovesForPackedDrops needs to run after drop\n         // elaboration.\n         &add_moves_for_packed_drops::AddMovesForPackedDrops,\n@@ -528,10 +532,6 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n \n     // Some cleanup necessary at least for LLVM and potentially other codegen backends.\n     let pre_codegen_cleanup: &[&dyn MirPass<'tcx>] = &[\n-        // This will remove extraneous landing pads which are no longer\n-        // necessary as well as well as forcing any call in a non-unwinding\n-        // function calling a possibly-unwinding function to abort the process.\n-        &abort_unwinding_calls::AbortUnwindingCalls,\n         &add_call_guards::CriticalCallEdges,\n         // Dump the end result for testing and debugging purposes.\n         &dump_mir::Marker(\"PreCodegen\"),"}]}