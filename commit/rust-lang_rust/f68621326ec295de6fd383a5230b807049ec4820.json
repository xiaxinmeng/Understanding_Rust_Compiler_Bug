{"sha": "f68621326ec295de6fd383a5230b807049ec4820", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ODYyMTMyNmVjMjk1ZGU2ZmQzODNhNTIzMGI4MDcwNDllYzQ4MjA=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-29T18:16:26Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-29T23:48:17Z"}, "message": "extra: Implement RandomAccessIterator for RingBuf", "tree": {"sha": "be21071b024b6a058c5d7b93ee5e958c708522c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be21071b024b6a058c5d7b93ee5e958c708522c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f68621326ec295de6fd383a5230b807049ec4820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f68621326ec295de6fd383a5230b807049ec4820", "html_url": "https://github.com/rust-lang/rust/commit/f68621326ec295de6fd383a5230b807049ec4820", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f68621326ec295de6fd383a5230b807049ec4820/comments", "author": null, "committer": null, "parents": [{"sha": "2f10d1e295d0ba0b2ce2777443fbfbeb9711787d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f10d1e295d0ba0b2ce2777443fbfbeb9711787d", "html_url": "https://github.com/rust-lang/rust/commit/2f10d1e295d0ba0b2ce2777443fbfbeb9711787d"}], "stats": {"total": 41, "additions": 26, "deletions": 15}, "files": [{"sha": "90f37cbf526f512e0d06b92667fa2447bd30ef03", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f68621326ec295de6fd383a5230b807049ec4820/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f68621326ec295de6fd383a5230b807049ec4820/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=f68621326ec295de6fd383a5230b807049ec4820", "patch": "@@ -16,7 +16,7 @@\n use std::num;\n use std::uint;\n use std::vec;\n-use std::iterator::{FromIterator, Invert};\n+use std::iterator::{FromIterator, Invert, RandomAccessIterator};\n \n use container::Deque;\n \n@@ -176,8 +176,7 @@ impl<T> RingBuf<T> {\n \n     /// Front-to-back iterator.\n     pub fn iter<'a>(&'a self) -> RingBufIterator<'a, T> {\n-        RingBufIterator{index: 0, rindex: self.nelts - 1,\n-                        nelts: self.nelts, elts: self.elts, lo: self.lo}\n+        RingBufIterator{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts}\n     }\n \n     /// Back-to-front iterator.\n@@ -187,8 +186,7 @@ impl<T> RingBuf<T> {\n \n     /// Front-to-back iterator which returns mutable values.\n     pub fn mut_iter<'a>(&'a mut self) -> RingBufMutIterator<'a, T> {\n-        RingBufMutIterator{index: 0, rindex: self.nelts - 1,\n-                           nelts: self.nelts, elts: self.elts, lo: self.lo}\n+        RingBufMutIterator{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts}\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n@@ -202,18 +200,18 @@ macro_rules! iterator {\n         impl<'self, T> Iterator<$elem> for $name<'self, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n-                if self.nelts == 0 {\n+                if self.index == self.rindex {\n                     return None;\n                 }\n                 let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n                 self.index += 1;\n-                self.nelts -= 1;\n-                Some(self.elts[raw_index]. $getter ())\n+                Some(self.elts[raw_index] . $getter ())\n             }\n \n             #[inline]\n             fn size_hint(&self) -> (uint, Option<uint>) {\n-                (self.nelts, Some(self.nelts))\n+                let len = self.rindex - self.index;\n+                (len, Some(len))\n             }\n         }\n     }\n@@ -224,33 +222,46 @@ macro_rules! iterator_rev {\n         impl<'self, T> DoubleEndedIterator<$elem> for $name<'self, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n-                if self.nelts == 0 {\n+                if self.index == self.rindex {\n                     return None;\n                 }\n-                let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n                 self.rindex -= 1;\n-                self.nelts -= 1;\n-                Some(self.elts[raw_index]. $getter ())\n+                let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n+                Some(self.elts[raw_index] . $getter ())\n             }\n         }\n     }\n }\n \n+\n /// RingBuf iterator\n pub struct RingBufIterator<'self, T> {\n     priv lo: uint,\n-    priv nelts: uint,\n     priv index: uint,\n     priv rindex: uint,\n     priv elts: &'self [Option<T>],\n }\n iterator!{impl RingBufIterator -> &'self T, get_ref}\n iterator_rev!{impl RingBufIterator -> &'self T, get_ref}\n \n+impl<'self, T> RandomAccessIterator<&'self T> for RingBufIterator<'self, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint { self.rindex - self.index }\n+\n+    #[inline]\n+    fn idx(&self, j: uint) -> Option<&'self T> {\n+        if j >= self.indexable() {\n+            None\n+        } else {\n+            let raw_index = raw_index(self.lo, self.elts.len(), self.index + j);\n+            Some(self.elts[raw_index].get_ref())\n+        }\n+    }\n+}\n+\n /// RingBuf mutable iterator\n pub struct RingBufMutIterator<'self, T> {\n     priv lo: uint,\n-    priv nelts: uint,\n     priv index: uint,\n     priv rindex: uint,\n     priv elts: &'self mut [Option<T>],"}]}