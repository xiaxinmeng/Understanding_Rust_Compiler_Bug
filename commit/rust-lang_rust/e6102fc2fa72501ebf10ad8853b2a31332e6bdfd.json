{"sha": "e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MTAyZmMyZmE3MjUwMWViZjEwYWQ4ODUzYjJhMzEzMzJlNmJkZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-28T17:56:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-28T17:56:34Z"}, "message": "auto merge of #10079 : alexcrichton/rust/no-reader-util, r=brson\n\nThese methods are all excellent candidates for default methods, so there's no need to require extra imports of various traits. Additionally, this was able to remove all the weird underscores after the method names. Yay!", "tree": {"sha": "4f553f9e135627ec1ef98dbc305888f0950d5e68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f553f9e135627ec1ef98dbc305888f0950d5e68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "html_url": "https://github.com/rust-lang/rust/commit/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a9a706b20ee43c601c2c70d62059610d40198fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a9a706b20ee43c601c2c70d62059610d40198fe", "html_url": "https://github.com/rust-lang/rust/commit/0a9a706b20ee43c601c2c70d62059610d40198fe"}, {"sha": "72557d83124aac4a362b99cbdb31a00f46be4bae", "url": "https://api.github.com/repos/rust-lang/rust/commits/72557d83124aac4a362b99cbdb31a00f46be4bae", "html_url": "https://github.com/rust-lang/rust/commit/72557d83124aac4a362b99cbdb31a00f46be4bae"}], "stats": {"total": 1157, "additions": 517, "deletions": 640}, "files": [{"sha": "e7e1b11028923c6cc9c057df87e7e198bbc55c60", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -23,7 +23,7 @@ use util::logv;\n use std::cell::Cell;\n use std::rt::io;\n use std::rt::io::Writer;\n-use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::Reader;\n use std::rt::io::file::FileInfo;\n use std::os;\n use std::str;"}, {"sha": "9f75d6771360ac85ff55b021a389bec494ad8f0d", "filename": "src/libextra/json.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -22,7 +22,6 @@ use std::f64;\n use std::hashmap::HashMap;\n use std::rt::io;\n use std::rt::io::Decorator;\n-use std::rt::io::extensions::ReaderUtil;\n use std::rt::io::mem::MemWriter;\n use std::num;\n use std::str;\n@@ -843,7 +842,7 @@ impl<T : Iterator<char>> Parser<T> {\n }\n \n /// Decodes a json value from an `&mut io::Reader`\n-pub fn from_reader(mut rdr: &mut io::Reader) -> Result<Json, Error> {\n+pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n     let s = str::from_utf8(rdr.read_to_end());\n     let mut parser = Parser(~s.iter());\n     parser.parse()"}, {"sha": "b530c1b6334ed2c5456d55500e5c7f2a52487055", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -16,7 +16,6 @@\n use std::{vec, str};\n use std::hashmap::HashMap;\n use std::rt::io;\n-use std::rt::io::extensions::{ReaderByteConversions, ReaderUtil};\n use super::super::TermInfo;\n \n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n@@ -161,7 +160,7 @@ pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"cs\n     \"box1\"];\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n-pub fn parse(mut file: &mut io::Reader,\n+pub fn parse(file: &mut io::Reader,\n              longnames: bool) -> Result<~TermInfo, ~str> {\n     let bnames;\n     let snames;\n@@ -178,17 +177,17 @@ pub fn parse(mut file: &mut io::Reader,\n     }\n \n     // Check magic number\n-    let magic = file.read_le_u16_();\n+    let magic = file.read_le_u16();\n     if (magic != 0x011A) {\n         return Err(format!(\"invalid magic number: expected {:x} but found {:x}\",\n                            0x011A, magic as uint));\n     }\n \n-    let names_bytes          = file.read_le_i16_() as int;\n-    let bools_bytes          = file.read_le_i16_() as int;\n-    let numbers_count        = file.read_le_i16_() as int;\n-    let string_offsets_count = file.read_le_i16_() as int;\n-    let string_table_bytes   = file.read_le_i16_() as int;\n+    let names_bytes          = file.read_le_i16() as int;\n+    let bools_bytes          = file.read_le_i16() as int;\n+    let numbers_count        = file.read_le_i16() as int;\n+    let string_offsets_count = file.read_le_i16() as int;\n+    let string_table_bytes   = file.read_le_i16() as int;\n \n     assert!(names_bytes          > 0);\n \n@@ -247,7 +246,7 @@ pub fn parse(mut file: &mut io::Reader,\n     let mut numbers_map = HashMap::new();\n     if numbers_count != 0 {\n         for i in range(0, numbers_count) {\n-            let n = file.read_le_u16_();\n+            let n = file.read_le_u16();\n             if n != 0xFFFF {\n                 debug!(\"{}\\\\#{}\", nnames[i], n);\n                 numbers_map.insert(nnames[i].to_owned(), n);\n@@ -262,7 +261,7 @@ pub fn parse(mut file: &mut io::Reader,\n     if string_offsets_count != 0 {\n         let mut string_offsets = vec::with_capacity(10);\n         for _ in range(0, string_offsets_count) {\n-            string_offsets.push(file.read_le_u16_());\n+            string_offsets.push(file.read_le_u16());\n         }\n \n         debug!(\"offsets: {:?}\", string_offsets);"}, {"sha": "507962c0b1a2afd2c7d23454f80a8b06b620f2c8", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -20,6 +20,7 @@ use std::comm::{PortOne, oneshot};\n use std::{os, str, task};\n use std::rt::io;\n use std::rt::io::Writer;\n+use std::rt::io::Reader;\n use std::rt::io::Decorator;\n use std::rt::io::mem::MemWriter;\n use std::rt::io::file::FileInfo;\n@@ -481,7 +482,7 @@ impl<'self, T:Send +\n #[test]\n fn test() {\n     use std::{os, run};\n-    use std::rt::io::ReaderUtil;\n+    use std::rt::io::Reader;\n     use std::str::from_utf8_owned;\n \n     // Create a path to a new file 'filename' in the directory in which"}, {"sha": "ade5bfe85e4bc1c80551096c80171d18c5d49747", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -22,7 +22,6 @@ use middle::typeck;\n use middle;\n \n use std::hashmap::{HashMap, HashSet};\n-use std::rt::io::extensions::WriterByteConversions;\n use std::rt::io::{Writer, Seek, Decorator};\n use std::rt::io::mem::MemWriter;\n use std::str;\n@@ -894,11 +893,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         vis: ast::visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index_(item: @item, ebml_w: &writer::Encoder,\n+    fn add_to_index(item: @item, ebml_w: &writer::Encoder,\n                      index: @mut ~[entry<i64>]) {\n         index.push(entry { val: item.id as i64, pos: ebml_w.writer.tell() });\n     }\n-    let add_to_index: &fn() = || add_to_index_(item, ebml_w, index);\n+    let add_to_index: &fn() = || add_to_index(item, ebml_w, index);\n \n     debug!(\"encoding info for item at {}\",\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n@@ -1411,7 +1410,7 @@ fn encode_index<T:'static>(\n             assert!(elt.pos < 0xffff_ffff);\n             {\n                 let wr: &mut MemWriter = ebml_w.writer;\n-                wr.write_be_u32_(elt.pos as u32);\n+                wr.write_be_u32(elt.pos as u32);\n             }\n             write_fn(ebml_w.writer, &elt.val);\n             ebml_w.end_tag();\n@@ -1423,7 +1422,7 @@ fn encode_index<T:'static>(\n     for pos in bucket_locs.iter() {\n         assert!(*pos < 0xffff_ffff);\n         let wr: &mut MemWriter = ebml_w.writer;\n-        wr.write_be_u32_(*pos as u32);\n+        wr.write_be_u32(*pos as u32);\n     }\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n@@ -1436,7 +1435,7 @@ fn write_str(writer: @mut MemWriter, s: ~str) {\n fn write_i64(writer: @mut MemWriter, &n: &i64) {\n     let wr: &mut MemWriter = writer;\n     assert!(n < 0x7fff_ffff);\n-    wr.write_be_u32_(n as u32);\n+    wr.write_be_u32(n as u32);\n }\n \n fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n@@ -1591,14 +1590,14 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n                 ebml_w.start_tag(tag_lang_items_item_id);\n                 {\n                     let wr: &mut MemWriter = ebml_w.writer;\n-                    wr.write_be_u32_(i as u32);\n+                    wr.write_be_u32(i as u32);\n                 }\n                 ebml_w.end_tag();   // tag_lang_items_item_id\n \n                 ebml_w.start_tag(tag_lang_items_item_node_id);\n                 {\n                     let wr: &mut MemWriter = ebml_w.writer;\n-                    wr.write_be_u32_(id.node as u32);\n+                    wr.write_be_u32(id.node as u32);\n                 }\n                 ebml_w.end_tag();   // tag_lang_items_item_node_id\n "}, {"sha": "6a5ed2f9e6eea26865347fb3a9ac9f17f84f92ff", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -37,7 +37,7 @@ use middle::lint;\n \n use std::comm;\n use std::rt::io;\n-use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::Reader;\n use std::num;\n use std::os;\n use std::result;"}, {"sha": "2e4894b854d5c145b8855004df8d23835537a79f", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::rt::io;\n-use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::Reader;\n use std::rt::io::file::FileInfo;\n use extra::workcache;\n use sha1::{Digest, Sha1};"}, {"sha": "b98dade4bf613e9f47cdc7da45170679904d1743", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -12,7 +12,6 @@\n \n use option::{Some, None};\n use rt::io::Reader;\n-use rt::io::ReaderByteConversions;\n \n use rand::Rng;\n \n@@ -51,17 +50,17 @@ impl<R: Reader> Rng for ReaderRng<R> {\n         // platform just involves blitting the bytes into the memory\n         // of the u32, similarly for BE on BE; avoiding byteswapping.\n         if cfg!(target_endian=\"little\") {\n-            self.reader.read_le_u32_()\n+            self.reader.read_le_u32()\n         } else {\n-            self.reader.read_be_u32_()\n+            self.reader.read_be_u32()\n         }\n     }\n     fn next_u64(&mut self) -> u64 {\n         // see above for explanation.\n         if cfg!(target_endian=\"little\") {\n-            self.reader.read_le_u64_()\n+            self.reader.read_le_u64()\n         } else {\n-            self.reader.read_be_u64_()\n+            self.reader.read_be_u64()\n         }\n     }\n     fn fill_bytes(&mut self, v: &mut [u8]) {"}, {"sha": "8bbc4b62eb92320f5af8badf2c9eabab1c517e94", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 19, "deletions": 599, "changes": 618, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -13,344 +13,9 @@\n // XXX: Not sure how this should be structured\n // XXX: Iteration should probably be considered separately\n \n-use uint;\n-use int;\n use iter::Iterator;\n-use vec;\n-use rt::io::{Reader, Writer, Decorator};\n-use rt::io::{io_error, standard_error, EndOfFile, DEFAULT_BUF_SIZE};\n-use option::{Option, Some, None};\n-use unstable::finally::Finally;\n-use cast;\n-\n-pub trait ReaderUtil {\n-\n-    /// Reads a single byte. Returns `None` on EOF.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as the `read` method. Returns\n-    /// `None` if the condition is handled.\n-    fn read_byte(&mut self) -> Option<u8>;\n-\n-    /// Reads `len` bytes and appends them to a vector.\n-    ///\n-    /// May push fewer than the requested number of bytes on error\n-    /// or EOF. Returns true on success, false on EOF or error.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as `read`. Additionally raises `io_error`\n-    /// on EOF. If `io_error` is handled then `push_bytes` may push less\n-    /// than the requested number of bytes.\n-    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint);\n-\n-    /// Reads `len` bytes and gives you back a new vector of length `len`\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as `read`. Additionally raises `io_error`\n-    /// on EOF. If `io_error` is handled then the returned vector may\n-    /// contain less than the requested number of bytes.\n-    fn read_bytes(&mut self, len: uint) -> ~[u8];\n-\n-    /// Reads all remaining bytes from the stream.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as the `read` method.\n-    fn read_to_end(&mut self) -> ~[u8];\n-\n-    /// Create an iterator that reads a single byte on\n-    /// each iteration, until EOF.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as the `read` method, for\n-    /// each call to its `.next()` method.\n-    /// Ends the iteration if the condition is handled.\n-    fn bytes(self) -> ByteIterator<Self>;\n-\n-}\n-\n-pub trait ReaderByteConversions {\n-    /// Reads `n` little-endian unsigned integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_uint_n_(&mut self, nbytes: uint) -> u64;\n-\n-    /// Reads `n` little-endian signed integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_int_n_(&mut self, nbytes: uint) -> i64;\n-\n-    /// Reads `n` big-endian unsigned integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_uint_n_(&mut self, nbytes: uint) -> u64;\n-\n-    /// Reads `n` big-endian signed integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_int_n_(&mut self, nbytes: uint) -> i64;\n-\n-    /// Reads a little-endian unsigned integer.\n-    ///\n-    /// The number of bytes returned is system-dependant.\n-    fn read_le_uint_(&mut self) -> uint;\n-\n-    /// Reads a little-endian integer.\n-    ///\n-    /// The number of bytes returned is system-dependant.\n-    fn read_le_int_(&mut self) -> int;\n-\n-    /// Reads a big-endian unsigned integer.\n-    ///\n-    /// The number of bytes returned is system-dependant.\n-    fn read_be_uint_(&mut self) -> uint;\n-\n-    /// Reads a big-endian integer.\n-    ///\n-    /// The number of bytes returned is system-dependant.\n-    fn read_be_int_(&mut self) -> int;\n-\n-    /// Reads a big-endian `u64`.\n-    ///\n-    /// `u64`s are 8 bytes long.\n-    fn read_be_u64_(&mut self) -> u64;\n-\n-    /// Reads a big-endian `u32`.\n-    ///\n-    /// `u32`s are 4 bytes long.\n-    fn read_be_u32_(&mut self) -> u32;\n-\n-    /// Reads a big-endian `u16`.\n-    ///\n-    /// `u16`s are 2 bytes long.\n-    fn read_be_u16_(&mut self) -> u16;\n-\n-    /// Reads a big-endian `i64`.\n-    ///\n-    /// `i64`s are 8 bytes long.\n-    fn read_be_i64_(&mut self) -> i64;\n-\n-    /// Reads a big-endian `i32`.\n-    ///\n-    /// `i32`s are 4 bytes long.\n-    fn read_be_i32_(&mut self) -> i32;\n-\n-    /// Reads a big-endian `i16`.\n-    ///\n-    /// `i16`s are 2 bytes long.\n-    fn read_be_i16_(&mut self) -> i16;\n-\n-    /// Reads a big-endian `f64`.\n-    ///\n-    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_be_f64_(&mut self) -> f64;\n-\n-    /// Reads a big-endian `f32`.\n-    ///\n-    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_be_f32_(&mut self) -> f32;\n-\n-    /// Reads a little-endian `u64`.\n-    ///\n-    /// `u64`s are 8 bytes long.\n-    fn read_le_u64_(&mut self) -> u64;\n-\n-    /// Reads a little-endian `u32`.\n-    ///\n-    /// `u32`s are 4 bytes long.\n-    fn read_le_u32_(&mut self) -> u32;\n-\n-    /// Reads a little-endian `u16`.\n-    ///\n-    /// `u16`s are 2 bytes long.\n-    fn read_le_u16_(&mut self) -> u16;\n-\n-    /// Reads a little-endian `i64`.\n-    ///\n-    /// `i64`s are 8 bytes long.\n-    fn read_le_i64_(&mut self) -> i64;\n-\n-    /// Reads a little-endian `i32`.\n-    ///\n-    /// `i32`s are 4 bytes long.\n-    fn read_le_i32_(&mut self) -> i32;\n-\n-    /// Reads a little-endian `i16`.\n-    ///\n-    /// `i16`s are 2 bytes long.\n-    fn read_le_i16_(&mut self) -> i16;\n-\n-    /// Reads a little-endian `f64`.\n-    ///\n-    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_le_f64_(&mut self) -> f64;\n-\n-    /// Reads a little-endian `f32`.\n-    ///\n-    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_le_f32_(&mut self) -> f32;\n-\n-    /// Read a u8.\n-    ///\n-    /// `u8`s are 1 byte.\n-    fn read_u8_(&mut self) -> u8;\n-\n-    /// Read an i8.\n-    ///\n-    /// `i8`s are 1 byte.\n-    fn read_i8_(&mut self) -> i8;\n-\n-}\n-\n-pub trait WriterByteConversions {\n-    /// Write the result of passing n through `int::to_str_bytes`.\n-    fn write_int_(&mut self, n: int);\n-\n-    /// Write the result of passing n through `uint::to_str_bytes`.\n-    fn write_uint_(&mut self, n: uint);\n-\n-    /// Write a little-endian uint (number of bytes depends on system).\n-    fn write_le_uint_(&mut self, n: uint);\n-\n-    /// Write a little-endian int (number of bytes depends on system).\n-    fn write_le_int_(&mut self, n: int);\n-\n-    /// Write a big-endian uint (number of bytes depends on system).\n-    fn write_be_uint_(&mut self, n: uint);\n-\n-    /// Write a big-endian int (number of bytes depends on system).\n-    fn write_be_int_(&mut self, n: int);\n-\n-    /// Write a big-endian u64 (8 bytes).\n-    fn write_be_u64_(&mut self, n: u64);\n-\n-    /// Write a big-endian u32 (4 bytes).\n-    fn write_be_u32_(&mut self, n: u32);\n-\n-    /// Write a big-endian u16 (2 bytes).\n-    fn write_be_u16_(&mut self, n: u16);\n-\n-    /// Write a big-endian i64 (8 bytes).\n-    fn write_be_i64_(&mut self, n: i64);\n-\n-    /// Write a big-endian i32 (4 bytes).\n-    fn write_be_i32_(&mut self, n: i32);\n-\n-    /// Write a big-endian i16 (2 bytes).\n-    fn write_be_i16_(&mut self, n: i16);\n-\n-    /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    fn write_be_f64_(&mut self, f: f64);\n-\n-    /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    fn write_be_f32_(&mut self, f: f32);\n-\n-    /// Write a little-endian u64 (8 bytes).\n-    fn write_le_u64_(&mut self, n: u64);\n-\n-    /// Write a little-endian u32 (4 bytes).\n-    fn write_le_u32_(&mut self, n: u32);\n-\n-    /// Write a little-endian u16 (2 bytes).\n-    fn write_le_u16_(&mut self, n: u16);\n-\n-    /// Write a little-endian i64 (8 bytes).\n-    fn write_le_i64_(&mut self, n: i64);\n-\n-    /// Write a little-endian i32 (4 bytes).\n-    fn write_le_i32_(&mut self, n: i32);\n-\n-    /// Write a little-endian i16 (2 bytes).\n-    fn write_le_i16_(&mut self, n: i16);\n-\n-    /// Write a little-endian IEEE754 double-precision floating-point\n-    /// (8 bytes).\n-    fn write_le_f64_(&mut self, f: f64);\n-\n-    /// Write a little-endian IEEE754 single-precision floating-point\n-    /// (4 bytes).\n-    fn write_le_f32_(&mut self, f: f32);\n-\n-    /// Write a u8 (1 byte).\n-    fn write_u8_(&mut self, n: u8);\n-\n-    /// Write a i8 (1 byte).\n-    fn write_i8_(&mut self, n: i8);\n-}\n-\n-impl<T: Reader> ReaderUtil for T {\n-    fn read_byte(&mut self) -> Option<u8> {\n-        let mut buf = [0];\n-        match self.read(buf) {\n-            Some(0) => {\n-                debug!(\"read 0 bytes. trying again\");\n-                self.read_byte()\n-            }\n-            Some(1) => Some(buf[0]),\n-            Some(_) => unreachable!(),\n-            None => None\n-        }\n-    }\n-\n-    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) {\n-        unsafe {\n-            let start_len = buf.len();\n-            let mut total_read = 0;\n-\n-            buf.reserve_additional(len);\n-            vec::raw::set_len(buf, start_len + len);\n-\n-            do (|| {\n-                while total_read < len {\n-                    let len = buf.len();\n-                    let slice = buf.mut_slice(start_len + total_read, len);\n-                    match self.read(slice) {\n-                        Some(nread) => {\n-                            total_read += nread;\n-                        }\n-                        None => {\n-                            io_error::cond.raise(standard_error(EndOfFile));\n-                            break;\n-                        }\n-                    }\n-                }\n-            }).finally {\n-                vec::raw::set_len(buf, start_len + total_read);\n-            }\n-        }\n-    }\n-\n-    fn read_bytes(&mut self, len: uint) -> ~[u8] {\n-        let mut buf = vec::with_capacity(len);\n-        self.push_bytes(&mut buf, len);\n-        return buf;\n-    }\n-\n-    fn read_to_end(&mut self) -> ~[u8] {\n-        let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n-        let mut keep_reading = true;\n-        do io_error::cond.trap(|e| {\n-            if e.kind == EndOfFile {\n-                keep_reading = false;\n-            } else {\n-                io_error::cond.raise(e)\n-            }\n-        }).inside {\n-            while keep_reading {\n-                self.push_bytes(&mut buf, DEFAULT_BUF_SIZE)\n-            }\n-        }\n-        return buf;\n-    }\n-\n-    fn bytes(self) -> ByteIterator<T> {\n-        ByteIterator{reader: self}\n-    }\n-}\n+use option::Option;\n+use rt::io::{Reader, Decorator};\n \n /// An iterator that reads a single byte on each iteration,\n /// until `.read_byte()` returns `None`.\n@@ -370,6 +35,12 @@ pub struct ByteIterator<T> {\n     priv reader: T,\n }\n \n+impl<R: Reader> ByteIterator<R> {\n+    pub fn new(r: R) -> ByteIterator<R> {\n+        ByteIterator { reader: r }\n+    }\n+}\n+\n impl<R> Decorator<R> for ByteIterator<R> {\n     fn inner(self) -> R { self.reader }\n     fn inner_ref<'a>(&'a self) -> &'a R { &self.reader }\n@@ -383,256 +54,6 @@ impl<'self, R: Reader> Iterator<u8> for ByteIterator<R> {\n     }\n }\n \n-impl<T: Reader> ReaderByteConversions for T {\n-    fn read_le_uint_n_(&mut self, nbytes: uint) -> u64 {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0u64;\n-        let mut pos = 0;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            val += (self.read_u8_() as u64) << pos;\n-            pos += 8;\n-            i -= 1;\n-        }\n-        val\n-    }\n-\n-    fn read_le_int_n_(&mut self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_le_uint_n_(nbytes), nbytes)\n-    }\n-\n-    fn read_be_uint_n_(&mut self, nbytes: uint) -> u64 {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0u64;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            i -= 1;\n-            val += (self.read_u8_() as u64) << i * 8;\n-        }\n-        val\n-    }\n-\n-    fn read_be_int_n_(&mut self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_be_uint_n_(nbytes), nbytes)\n-    }\n-\n-    fn read_le_uint_(&mut self) -> uint {\n-        self.read_le_uint_n_(uint::bytes) as uint\n-    }\n-\n-    fn read_le_int_(&mut self) -> int {\n-        self.read_le_int_n_(int::bytes) as int\n-    }\n-\n-    fn read_be_uint_(&mut self) -> uint {\n-        self.read_be_uint_n_(uint::bytes) as uint\n-    }\n-\n-    fn read_be_int_(&mut self) -> int {\n-        self.read_be_int_n_(int::bytes) as int\n-    }\n-\n-    fn read_be_u64_(&mut self) -> u64 {\n-        self.read_be_uint_n_(8) as u64\n-    }\n-\n-    fn read_be_u32_(&mut self) -> u32 {\n-        self.read_be_uint_n_(4) as u32\n-    }\n-\n-    fn read_be_u16_(&mut self) -> u16 {\n-        self.read_be_uint_n_(2) as u16\n-    }\n-\n-    fn read_be_i64_(&mut self) -> i64 {\n-        self.read_be_int_n_(8) as i64\n-    }\n-\n-    fn read_be_i32_(&mut self) -> i32 {\n-        self.read_be_int_n_(4) as i32\n-    }\n-\n-    fn read_be_i16_(&mut self) -> i16 {\n-        self.read_be_int_n_(2) as i16\n-    }\n-\n-    fn read_be_f64_(&mut self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_be_u64_())\n-        }\n-    }\n-\n-    fn read_be_f32_(&mut self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_be_u32_())\n-        }\n-    }\n-\n-    fn read_le_u64_(&mut self) -> u64 {\n-        self.read_le_uint_n_(8) as u64\n-    }\n-\n-    fn read_le_u32_(&mut self) -> u32 {\n-        self.read_le_uint_n_(4) as u32\n-    }\n-\n-    fn read_le_u16_(&mut self) -> u16 {\n-        self.read_le_uint_n_(2) as u16\n-    }\n-\n-    fn read_le_i64_(&mut self) -> i64 {\n-        self.read_le_int_n_(8) as i64\n-    }\n-\n-    fn read_le_i32_(&mut self) -> i32 {\n-        self.read_le_int_n_(4) as i32\n-    }\n-\n-    fn read_le_i16_(&mut self) -> i16 {\n-        self.read_le_int_n_(2) as i16\n-    }\n-\n-    fn read_le_f64_(&mut self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_le_u64_())\n-        }\n-    }\n-\n-    fn read_le_f32_(&mut self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_le_u32_())\n-        }\n-    }\n-\n-    fn read_u8_(&mut self) -> u8 {\n-        match self.read_byte() {\n-            Some(b) => b as u8,\n-            None => 0\n-        }\n-    }\n-\n-    fn read_i8_(&mut self) -> i8 {\n-        match self.read_byte() {\n-            Some(b) => b as i8,\n-            None => 0\n-        }\n-    }\n-\n-}\n-\n-impl<T: Writer> WriterByteConversions for T {\n-    fn write_int_(&mut self, n: int) {\n-        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n-    }\n-\n-    fn write_uint_(&mut self, n: uint) {\n-        uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n-    }\n-\n-    fn write_le_uint_(&mut self, n: uint) {\n-        u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n-    }\n-\n-    fn write_le_int_(&mut self, n: int) {\n-        u64_to_le_bytes(n as u64, int::bytes, |v| self.write(v))\n-    }\n-\n-    fn write_be_uint_(&mut self, n: uint) {\n-        u64_to_be_bytes(n as u64, uint::bytes, |v| self.write(v))\n-    }\n-\n-    fn write_be_int_(&mut self, n: int) {\n-        u64_to_be_bytes(n as u64, int::bytes, |v| self.write(v))\n-    }\n-\n-    fn write_be_u64_(&mut self, n: u64) {\n-        u64_to_be_bytes(n, 8u, |v| self.write(v))\n-    }\n-\n-    fn write_be_u32_(&mut self, n: u32) {\n-        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-\n-    fn write_be_u16_(&mut self, n: u16) {\n-        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-\n-    fn write_be_i64_(&mut self, n: i64) {\n-        u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n-    }\n-\n-    fn write_be_i32_(&mut self, n: i32) {\n-        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-\n-    fn write_be_i16_(&mut self, n: i16) {\n-        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-\n-    fn write_be_f64_(&mut self, f: f64) {\n-        unsafe {\n-            self.write_be_u64_(cast::transmute(f))\n-        }\n-    }\n-\n-    fn write_be_f32_(&mut self, f: f32) {\n-        unsafe {\n-            self.write_be_u32_(cast::transmute(f))\n-        }\n-    }\n-\n-    fn write_le_u64_(&mut self, n: u64) {\n-        u64_to_le_bytes(n, 8u, |v| self.write(v))\n-    }\n-\n-    fn write_le_u32_(&mut self, n: u32) {\n-        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-\n-    fn write_le_u16_(&mut self, n: u16) {\n-        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-\n-    fn write_le_i64_(&mut self, n: i64) {\n-        u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n-    }\n-\n-    fn write_le_i32_(&mut self, n: i32) {\n-        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-\n-    fn write_le_i16_(&mut self, n: i16) {\n-        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-\n-    fn write_le_f64_(&mut self, f: f64) {\n-        unsafe {\n-            self.write_le_u64_(cast::transmute(f))\n-        }\n-    }\n-\n-    fn write_le_f32_(&mut self, f: f32) {\n-        unsafe {\n-            self.write_le_u32_(cast::transmute(f))\n-        }\n-    }\n-\n-    fn write_u8_(&mut self, n: u8) {\n-        self.write([n])\n-    }\n-\n-    fn write_i8_(&mut self, n: i8) {\n-        self.write([n as u8])\n-    }\n-}\n-\n-fn extend_sign(val: u64, nbytes: uint) -> i64 {\n-    let shift = (8 - nbytes) * 8;\n-    (val << shift) as i64 >> shift\n-}\n-\n pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n                           f: &fn(v: &[u8]) -> T) -> T {\n     assert!(size <= 8u);\n@@ -717,7 +138,6 @@ pub fn u64_from_be_bytes(data: &[u8],\n \n #[cfg(test)]\n mod test {\n-    use super::ReaderUtil;\n     use option::{Some, None};\n     use cell::Cell;\n     use rt::io::mem::{MemReader, MemWriter};\n@@ -999,12 +419,12 @@ mod test {\n \n         let mut writer = MemWriter::new();\n         for i in uints.iter() {\n-            writer.write_le_u64_(*i);\n+            writer.write_le_u64(*i);\n         }\n \n         let mut reader = MemReader::new(writer.inner());\n         for i in uints.iter() {\n-            assert!(reader.read_le_u64_() == *i);\n+            assert!(reader.read_le_u64() == *i);\n         }\n     }\n \n@@ -1015,12 +435,12 @@ mod test {\n \n         let mut writer = MemWriter::new();\n         for i in uints.iter() {\n-            writer.write_be_u64_(*i);\n+            writer.write_be_u64(*i);\n         }\n \n         let mut reader = MemReader::new(writer.inner());\n         for i in uints.iter() {\n-            assert!(reader.read_be_u64_() == *i);\n+            assert!(reader.read_be_u64() == *i);\n         }\n     }\n \n@@ -1030,14 +450,14 @@ mod test {\n \n         let mut writer = MemWriter::new();\n         for i in ints.iter() {\n-            writer.write_be_i32_(*i);\n+            writer.write_be_i32(*i);\n         }\n \n         let mut reader = MemReader::new(writer.inner());\n         for i in ints.iter() {\n             // this tests that the sign extension is working\n             // (comparing the values as i32 would not test this)\n-            assert!(reader.read_be_int_n_(4) == *i as i64);\n+            assert!(reader.read_be_int_n(4) == *i as i64);\n         }\n     }\n \n@@ -1050,7 +470,7 @@ mod test {\n         writer.write(buf);\n \n         let mut reader = MemReader::new(writer.inner());\n-        let f = reader.read_be_f32_();\n+        let f = reader.read_be_f32();\n         assert!(f == 8.1250);\n     }\n \n@@ -1059,12 +479,12 @@ mod test {\n         let f:f32 = 8.1250;\n \n         let mut writer = MemWriter::new();\n-        writer.write_be_f32_(f);\n-        writer.write_le_f32_(f);\n+        writer.write_be_f32(f);\n+        writer.write_le_f32(f);\n \n         let mut reader = MemReader::new(writer.inner());\n-        assert!(reader.read_be_f32_() == 8.1250);\n-        assert!(reader.read_le_f32_() == 8.1250);\n+        assert!(reader.read_be_f32() == 8.1250);\n+        assert!(reader.read_le_f32() == 8.1250);\n     }\n \n }"}, {"sha": "5eba3b2b801d2c68120d5bfb96ac292bb33000bc", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 468, "deletions": 7, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -242,10 +242,15 @@ Out of scope\n \n */\n \n+use cast;\n+use int;\n+use path::Path;\n use prelude::*;\n-use to_str::ToStr;\n use str::{StrSlice, OwnedStr};\n-use path::Path;\n+use to_str::ToStr;\n+use uint;\n+use unstable::finally::Finally;\n+use vec;\n \n // Reexports\n pub use self::stdio::stdin;\n@@ -263,11 +268,6 @@ pub use self::net::udp::UdpStream;\n pub use self::pipe::PipeStream;\n pub use self::process::Process;\n \n-// Some extension traits that all Readers and Writers get.\n-pub use self::extensions::ReaderUtil;\n-pub use self::extensions::ReaderByteConversions;\n-pub use self::extensions::WriterByteConversions;\n-\n /// Synchronous, non-blocking file I/O.\n pub mod file;\n \n@@ -422,6 +422,9 @@ pub fn ignore_io_error<T>(cb: &fn() -> T) -> T {\n }\n \n pub trait Reader {\n+\n+    // Only two methods which need to get implemented for this trait\n+\n     /// Read bytes, up to the length of `buf` and place them in `buf`.\n     /// Returns the number of bytes read. The number of bytes read my\n     /// be less than the number requested, even 0. Returns `None` on EOF.\n@@ -459,6 +462,329 @@ pub trait Reader {\n     ///\n     /// Returns `true` on failure.\n     fn eof(&mut self) -> bool;\n+\n+    // Convenient helper methods based on the above methods\n+\n+    /// Reads a single byte. Returns `None` on EOF.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the same conditions as the `read` method. Returns\n+    /// `None` if the condition is handled.\n+    fn read_byte(&mut self) -> Option<u8> {\n+        let mut buf = [0];\n+        match self.read(buf) {\n+            Some(0) => {\n+                debug!(\"read 0 bytes. trying again\");\n+                self.read_byte()\n+            }\n+            Some(1) => Some(buf[0]),\n+            Some(_) => unreachable!(),\n+            None => None\n+        }\n+    }\n+\n+    /// Reads `len` bytes and appends them to a vector.\n+    ///\n+    /// May push fewer than the requested number of bytes on error\n+    /// or EOF. Returns true on success, false on EOF or error.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the same conditions as `read`. Additionally raises `io_error`\n+    /// on EOF. If `io_error` is handled then `push_bytes` may push less\n+    /// than the requested number of bytes.\n+    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) {\n+        unsafe {\n+            let start_len = buf.len();\n+            let mut total_read = 0;\n+\n+            buf.reserve_additional(len);\n+            vec::raw::set_len(buf, start_len + len);\n+\n+            do (|| {\n+                while total_read < len {\n+                    let len = buf.len();\n+                    let slice = buf.mut_slice(start_len + total_read, len);\n+                    match self.read(slice) {\n+                        Some(nread) => {\n+                            total_read += nread;\n+                        }\n+                        None => {\n+                            io_error::cond.raise(standard_error(EndOfFile));\n+                            break;\n+                        }\n+                    }\n+                }\n+            }).finally {\n+                vec::raw::set_len(buf, start_len + total_read);\n+            }\n+        }\n+    }\n+\n+    /// Reads `len` bytes and gives you back a new vector of length `len`\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the same conditions as `read`. Additionally raises `io_error`\n+    /// on EOF. If `io_error` is handled then the returned vector may\n+    /// contain less than the requested number of bytes.\n+    fn read_bytes(&mut self, len: uint) -> ~[u8] {\n+        let mut buf = vec::with_capacity(len);\n+        self.push_bytes(&mut buf, len);\n+        return buf;\n+    }\n+\n+    /// Reads all remaining bytes from the stream.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the same conditions as the `read` method.\n+    fn read_to_end(&mut self) -> ~[u8] {\n+        let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n+        let mut keep_reading = true;\n+        do io_error::cond.trap(|e| {\n+            if e.kind == EndOfFile {\n+                keep_reading = false;\n+            } else {\n+                io_error::cond.raise(e)\n+            }\n+        }).inside {\n+            while keep_reading {\n+                self.push_bytes(&mut buf, DEFAULT_BUF_SIZE)\n+            }\n+        }\n+        return buf;\n+    }\n+\n+    /// Create an iterator that reads a single byte on\n+    /// each iteration, until EOF.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the same conditions as the `read` method, for\n+    /// each call to its `.next()` method.\n+    /// Ends the iteration if the condition is handled.\n+    fn bytes(self) -> extensions::ByteIterator<Self> {\n+        extensions::ByteIterator::new(self)\n+    }\n+\n+    // Byte conversion helpers\n+\n+    /// Reads `n` little-endian unsigned integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    fn read_le_uint_n(&mut self, nbytes: uint) -> u64 {\n+        assert!(nbytes > 0 && nbytes <= 8);\n+\n+        let mut val = 0u64;\n+        let mut pos = 0;\n+        let mut i = nbytes;\n+        while i > 0 {\n+            val += (self.read_u8() as u64) << pos;\n+            pos += 8;\n+            i -= 1;\n+        }\n+        val\n+    }\n+\n+    /// Reads `n` little-endian signed integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    fn read_le_int_n(&mut self, nbytes: uint) -> i64 {\n+        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n+    }\n+\n+    /// Reads `n` big-endian unsigned integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    fn read_be_uint_n(&mut self, nbytes: uint) -> u64 {\n+        assert!(nbytes > 0 && nbytes <= 8);\n+\n+        let mut val = 0u64;\n+        let mut i = nbytes;\n+        while i > 0 {\n+            i -= 1;\n+            val += (self.read_u8() as u64) << i * 8;\n+        }\n+        val\n+    }\n+\n+    /// Reads `n` big-endian signed integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    fn read_be_int_n(&mut self, nbytes: uint) -> i64 {\n+        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n+    }\n+\n+    /// Reads a little-endian unsigned integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    fn read_le_uint(&mut self) -> uint {\n+        self.read_le_uint_n(uint::bytes) as uint\n+    }\n+\n+    /// Reads a little-endian integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    fn read_le_int(&mut self) -> int {\n+        self.read_le_int_n(int::bytes) as int\n+    }\n+\n+    /// Reads a big-endian unsigned integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    fn read_be_uint(&mut self) -> uint {\n+        self.read_be_uint_n(uint::bytes) as uint\n+    }\n+\n+    /// Reads a big-endian integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    fn read_be_int(&mut self) -> int {\n+        self.read_be_int_n(int::bytes) as int\n+    }\n+\n+    /// Reads a big-endian `u64`.\n+    ///\n+    /// `u64`s are 8 bytes long.\n+    fn read_be_u64(&mut self) -> u64 {\n+        self.read_be_uint_n(8) as u64\n+    }\n+\n+    /// Reads a big-endian `u32`.\n+    ///\n+    /// `u32`s are 4 bytes long.\n+    fn read_be_u32(&mut self) -> u32 {\n+        self.read_be_uint_n(4) as u32\n+    }\n+\n+    /// Reads a big-endian `u16`.\n+    ///\n+    /// `u16`s are 2 bytes long.\n+    fn read_be_u16(&mut self) -> u16 {\n+        self.read_be_uint_n(2) as u16\n+    }\n+\n+    /// Reads a big-endian `i64`.\n+    ///\n+    /// `i64`s are 8 bytes long.\n+    fn read_be_i64(&mut self) -> i64 {\n+        self.read_be_int_n(8) as i64\n+    }\n+\n+    /// Reads a big-endian `i32`.\n+    ///\n+    /// `i32`s are 4 bytes long.\n+    fn read_be_i32(&mut self) -> i32 {\n+        self.read_be_int_n(4) as i32\n+    }\n+\n+    /// Reads a big-endian `i16`.\n+    ///\n+    /// `i16`s are 2 bytes long.\n+    fn read_be_i16(&mut self) -> i16 {\n+        self.read_be_int_n(2) as i16\n+    }\n+\n+    /// Reads a big-endian `f64`.\n+    ///\n+    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n+    fn read_be_f64(&mut self) -> f64 {\n+        unsafe {\n+            cast::transmute::<u64, f64>(self.read_be_u64())\n+        }\n+    }\n+\n+    /// Reads a big-endian `f32`.\n+    ///\n+    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n+    fn read_be_f32(&mut self) -> f32 {\n+        unsafe {\n+            cast::transmute::<u32, f32>(self.read_be_u32())\n+        }\n+    }\n+\n+    /// Reads a little-endian `u64`.\n+    ///\n+    /// `u64`s are 8 bytes long.\n+    fn read_le_u64(&mut self) -> u64 {\n+        self.read_le_uint_n(8) as u64\n+    }\n+\n+    /// Reads a little-endian `u32`.\n+    ///\n+    /// `u32`s are 4 bytes long.\n+    fn read_le_u32(&mut self) -> u32 {\n+        self.read_le_uint_n(4) as u32\n+    }\n+\n+    /// Reads a little-endian `u16`.\n+    ///\n+    /// `u16`s are 2 bytes long.\n+    fn read_le_u16(&mut self) -> u16 {\n+        self.read_le_uint_n(2) as u16\n+    }\n+\n+    /// Reads a little-endian `i64`.\n+    ///\n+    /// `i64`s are 8 bytes long.\n+    fn read_le_i64(&mut self) -> i64 {\n+        self.read_le_int_n(8) as i64\n+    }\n+\n+    /// Reads a little-endian `i32`.\n+    ///\n+    /// `i32`s are 4 bytes long.\n+    fn read_le_i32(&mut self) -> i32 {\n+        self.read_le_int_n(4) as i32\n+    }\n+\n+    /// Reads a little-endian `i16`.\n+    ///\n+    /// `i16`s are 2 bytes long.\n+    fn read_le_i16(&mut self) -> i16 {\n+        self.read_le_int_n(2) as i16\n+    }\n+\n+    /// Reads a little-endian `f64`.\n+    ///\n+    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n+    fn read_le_f64(&mut self) -> f64 {\n+        unsafe {\n+            cast::transmute::<u64, f64>(self.read_le_u64())\n+        }\n+    }\n+\n+    /// Reads a little-endian `f32`.\n+    ///\n+    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n+    fn read_le_f32(&mut self) -> f32 {\n+        unsafe {\n+            cast::transmute::<u32, f32>(self.read_le_u32())\n+        }\n+    }\n+\n+    /// Read a u8.\n+    ///\n+    /// `u8`s are 1 byte.\n+    fn read_u8(&mut self) -> u8 {\n+        match self.read_byte() {\n+            Some(b) => b as u8,\n+            None => 0\n+        }\n+    }\n+\n+    /// Read an i8.\n+    ///\n+    /// `i8`s are 1 byte.\n+    fn read_i8(&mut self) -> i8 {\n+        match self.read_byte() {\n+            Some(b) => b as i8,\n+            None => 0\n+        }\n+    }\n+\n }\n \n impl Reader for ~Reader {\n@@ -471,6 +797,11 @@ impl<'self> Reader for &'self mut Reader {\n     fn eof(&mut self) -> bool { self.eof() }\n }\n \n+fn extend_sign(val: u64, nbytes: uint) -> i64 {\n+    let shift = (8 - nbytes) * 8;\n+    (val << shift) as i64 >> shift\n+}\n+\n pub trait Writer {\n     /// Write the given buffer\n     ///\n@@ -481,6 +812,136 @@ pub trait Writer {\n \n     /// Flush output\n     fn flush(&mut self);\n+\n+    /// Write the result of passing n through `int::to_str_bytes`.\n+    fn write_int(&mut self, n: int) {\n+        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n+    }\n+\n+    /// Write the result of passing n through `uint::to_str_bytes`.\n+    fn write_uint(&mut self, n: uint) {\n+        uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n+    }\n+\n+    /// Write a little-endian uint (number of bytes depends on system).\n+    fn write_le_uint(&mut self, n: uint) {\n+        extensions::u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n+    }\n+\n+    /// Write a little-endian int (number of bytes depends on system).\n+    fn write_le_int(&mut self, n: int) {\n+        extensions::u64_to_le_bytes(n as u64, int::bytes, |v| self.write(v))\n+    }\n+\n+    /// Write a big-endian uint (number of bytes depends on system).\n+    fn write_be_uint(&mut self, n: uint) {\n+        extensions::u64_to_be_bytes(n as u64, uint::bytes, |v| self.write(v))\n+    }\n+\n+    /// Write a big-endian int (number of bytes depends on system).\n+    fn write_be_int(&mut self, n: int) {\n+        extensions::u64_to_be_bytes(n as u64, int::bytes, |v| self.write(v))\n+    }\n+\n+    /// Write a big-endian u64 (8 bytes).\n+    fn write_be_u64(&mut self, n: u64) {\n+        extensions::u64_to_be_bytes(n, 8u, |v| self.write(v))\n+    }\n+\n+    /// Write a big-endian u32 (4 bytes).\n+    fn write_be_u32(&mut self, n: u32) {\n+        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    /// Write a big-endian u16 (2 bytes).\n+    fn write_be_u16(&mut self, n: u16) {\n+        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    /// Write a big-endian i64 (8 bytes).\n+    fn write_be_i64(&mut self, n: i64) {\n+        extensions::u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n+    }\n+\n+    /// Write a big-endian i32 (4 bytes).\n+    fn write_be_i32(&mut self, n: i32) {\n+        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    /// Write a big-endian i16 (2 bytes).\n+    fn write_be_i16(&mut self, n: i16) {\n+        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n+    fn write_be_f64(&mut self, f: f64) {\n+        unsafe {\n+            self.write_be_u64(cast::transmute(f))\n+        }\n+    }\n+\n+    /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n+    fn write_be_f32(&mut self, f: f32) {\n+        unsafe {\n+            self.write_be_u32(cast::transmute(f))\n+        }\n+    }\n+\n+    /// Write a little-endian u64 (8 bytes).\n+    fn write_le_u64(&mut self, n: u64) {\n+        extensions::u64_to_le_bytes(n, 8u, |v| self.write(v))\n+    }\n+\n+    /// Write a little-endian u32 (4 bytes).\n+    fn write_le_u32(&mut self, n: u32) {\n+        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    /// Write a little-endian u16 (2 bytes).\n+    fn write_le_u16(&mut self, n: u16) {\n+        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    /// Write a little-endian i64 (8 bytes).\n+    fn write_le_i64(&mut self, n: i64) {\n+        extensions::u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n+    }\n+\n+    /// Write a little-endian i32 (4 bytes).\n+    fn write_le_i32(&mut self, n: i32) {\n+        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    /// Write a little-endian i16 (2 bytes).\n+    fn write_le_i16(&mut self, n: i16) {\n+        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    /// Write a little-endian IEEE754 double-precision floating-point\n+    /// (8 bytes).\n+    fn write_le_f64(&mut self, f: f64) {\n+        unsafe {\n+            self.write_le_u64(cast::transmute(f))\n+        }\n+    }\n+\n+    /// Write a little-endian IEEE754 single-precision floating-point\n+    /// (4 bytes).\n+    fn write_le_f32(&mut self, f: f32) {\n+        unsafe {\n+            self.write_le_u32(cast::transmute(f))\n+        }\n+    }\n+\n+    /// Write a u8 (1 byte).\n+    fn write_u8(&mut self, n: u8) {\n+        self.write([n])\n+    }\n+\n+    /// Write a i8 (1 byte).\n+    fn write_i8(&mut self, n: i8) {\n+        self.write([n as u8])\n+    }\n }\n \n impl Writer for ~Writer {"}, {"sha": "973e866e335c46cfd4d73b05a63ed9866bdc563d", "filename": "src/libstd/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -19,7 +19,7 @@ use libc;\n use prelude::*;\n use rt::io::process;\n use rt::io;\n-use rt::io::extensions::ReaderUtil;\n+use rt::io::Reader;\n use task;\n \n /**"}, {"sha": "fda6f782af4504d11b7c953f1116e227cf600cae", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -20,7 +20,7 @@ use parse::token::{get_ident_interner};\n use print::pprust;\n \n use std::rt::io;\n-use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::Reader;\n use std::rt::io::file::FileInfo;\n use std::str;\n "}, {"sha": "38fd65836aaeccaca88cb07838021e9c7bb1da90", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -19,7 +19,6 @@ use parse::token;\n use parse::token::{get_ident_interner};\n \n use std::rt::io;\n-use std::rt::io::extensions::ReaderUtil;\n use std::str;\n use std::uint;\n \n@@ -347,7 +346,7 @@ pub struct lit {\n pub fn gather_comments_and_literals(span_diagnostic:\n                                     @mut diagnostic::span_handler,\n                                     path: @str,\n-                                    mut srdr: &mut io::Reader)\n+                                    srdr: &mut io::Reader)\n                                  -> (~[cmnt], ~[lit]) {\n     let src = str::from_utf8(srdr.read_to_end()).to_managed();\n     let cm = CodeMap::new();"}, {"sha": "003bc006ebec01d7db1a5fd76eb5a1f465c7d939", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6102fc2fa72501ebf10ad8853b2a31332e6bdfd/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e6102fc2fa72501ebf10ad8853b2a31332e6bdfd", "patch": "@@ -21,7 +21,7 @@ use parse::parser::Parser;\n \n use std::path::Path;\n use std::rt::io;\n-use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::Reader;\n use std::rt::io::file::FileInfo;\n use std::str;\n "}]}