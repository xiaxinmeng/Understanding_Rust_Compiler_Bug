{"sha": "0ff9872b2280009f094af0df3dcdc542cc46a5fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmZjk4NzJiMjI4MDAwOWYwOTRhZjBkZjNkY2RjNTQyY2M0NmE1ZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-28T11:24:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-28T11:24:23Z"}, "message": "Auto merge of #48608 - kennytm:rollup, r=kennytm\n\nRollup of 15 pull requests\n\n- Successful merges: #48266, #48321, #48365, #48381, #48450, #48473, #48479, #48484, #48488, #48497, #48541, #48548, #48558, #48560, #48565\n- Failed merges:", "tree": {"sha": "65509a458d8fb7808cc501d6767b68ff7a08ca11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65509a458d8fb7808cc501d6767b68ff7a08ca11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ff9872b2280009f094af0df3dcdc542cc46a5fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff9872b2280009f094af0df3dcdc542cc46a5fd", "html_url": "https://github.com/rust-lang/rust/commit/0ff9872b2280009f094af0df3dcdc542cc46a5fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ff9872b2280009f094af0df3dcdc542cc46a5fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddab91a5debadfda47c057117c8b498a31abaae7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddab91a5debadfda47c057117c8b498a31abaae7", "html_url": "https://github.com/rust-lang/rust/commit/ddab91a5debadfda47c057117c8b498a31abaae7"}, {"sha": "fed0c4201cb838eeeb1152f83fab88afa87ca825", "url": "https://api.github.com/repos/rust-lang/rust/commits/fed0c4201cb838eeeb1152f83fab88afa87ca825", "html_url": "https://github.com/rust-lang/rust/commit/fed0c4201cb838eeeb1152f83fab88afa87ca825"}], "stats": {"total": 2092, "additions": 698, "deletions": 1394}, "files": [{"sha": "552961b9b66c13ca69ab58671ed2bea808558d93", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -623,6 +623,7 @@ For people new to Rust, and just starting to contribute, or even for\n more seasoned developers, some useful places to look for information\n are:\n \n+* The [rustc guide] contains information about how various parts of the compiler work\n * [Rust Forge][rustforge] contains additional documentation, including write-ups of how to achieve common tasks\n * The [Rust Internals forum][rif], a place to ask questions and\n   discuss Rust's internals\n@@ -635,6 +636,7 @@ are:\n * **Google!** ([search only in Rust Documentation][gsearchdocs] to find types, traits, etc. quickly)\n * Don't be afraid to ask! The Rust community is friendly and helpful.\n \n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html\n [gdfrustc]: http://manishearth.github.io/rust-internals-docs/rustc/\n [gsearchdocs]: https://www.google.com/search?q=site:doc.rust-lang.org+your+query+here\n [rif]: http://internals.rust-lang.org"}, {"sha": "fd35606ec0dbb21ccad4ba00f59d5f983f3ef843", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -227,9 +227,13 @@ variety of channels on Mozilla's IRC network, irc.mozilla.org. The\n most popular channel is [#rust], a venue for general discussion about\n Rust. And a good place to ask for help would be [#rust-beginners].\n \n+Also, the [rustc guide] might be a good place to start if you want to\n+find out how various parts of the compiler work.\n+\n [IRC]: https://en.wikipedia.org/wiki/Internet_Relay_Chat\n [#rust]: irc://irc.mozilla.org/rust\n [#rust-beginners]: irc://irc.mozilla.org/rust-beginners\n+[rustc-guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html\n \n ## License\n [license]: #license"}, {"sha": "690ab674c64ebd96bf1700994b0097f506c58955", "filename": "src/README.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -0,0 +1,15 @@\n+This directory contains the source code of the rust project, including:\n+- `rustc` and its tests\n+- `libstd`\n+- Various submodules for tools, like rustdoc, rls, etc.\n+\n+For more information on how various parts of the compiler work, see the [rustc guide].\n+\n+Their is also useful content in the following READMEs, which are gradually being moved over to the guide:\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/ty/maps\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n+- https://github.com/rust-lang/rust/blob/master/src/librustc/infer/region_constraints\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html"}, {"sha": "2c9f0ddb6c33d197f8bd05df8ef36359a4abb5f4", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -1007,6 +1007,10 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n             continue\n         };\n         if json[\"reason\"].as_str() != Some(\"compiler-artifact\") {\n+            if build.config.rustc_error_format.as_ref().map_or(false, |e| e == \"json\") {\n+                // most likely not a cargo message, so let's send it out as well\n+                println!(\"{}\", line);\n+            }\n             continue\n         }\n         for filename in json[\"filenames\"].as_array().unwrap() {"}, {"sha": "af50ad1e96b9f184039dc17c15503feb322e4ff9", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -119,7 +119,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n-        opts.optflag(\"\", \"error-format\", \"rustc error format\");\n+        opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n \n         // fn usage()\n         let usage = |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {"}, {"sha": "653606e5d24b596b62fe1c45b93ddadbbca0dfa5", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -480,6 +480,7 @@ impl Step for Openssl {\n             \"mips64el-unknown-linux-gnuabi64\" => \"linux64-mips64\",\n             \"mipsel-unknown-linux-gnu\" => \"linux-mips32\",\n             \"powerpc-unknown-linux-gnu\" => \"linux-ppc\",\n+            \"powerpc-unknown-linux-gnuspe\" => \"linux-ppc\",\n             \"powerpc-unknown-netbsd\" => \"BSD-generic32\",\n             \"powerpc64-unknown-linux-gnu\" => \"linux-ppc64\",\n             \"powerpc64le-unknown-linux-gnu\" => \"linux-ppc64le\","}, {"sha": "2de0ffb4b26113a69f58feb8a525b283670585d1", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -13,7 +13,6 @@\n #![feature(i128_type)]\n #![feature(rand)]\n #![feature(repr_simd)]\n-#![feature(slice_rotate)]\n #![feature(test)]\n \n extern crate rand;"}, {"sha": "d250cfe1880fc09ca8553363336edd1dffe6c847", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -79,7 +79,6 @@\n #![cfg_attr(test, feature(placement_in))]\n #![cfg_attr(not(test), feature(core_float))]\n #![cfg_attr(not(test), feature(exact_size_is_empty))]\n-#![cfg_attr(not(test), feature(slice_rotate))]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(rand, test))]\n #![feature(allow_internal_unstable)]"}, {"sha": "dc40062ef13df5ebccebd317cbb8be313bb75c23", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -1460,8 +1460,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(slice_rotate)]\n-    ///\n     /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n     /// a.rotate_left(2);\n     /// assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n@@ -1470,23 +1468,15 @@ impl<T> [T] {\n     /// Rotating a subslice:\n     ///\n     /// ```\n-    /// #![feature(slice_rotate)]\n-    ///\n     /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n     /// a[1..5].rotate_left(1);\n     /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n-    /// ```\n-    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n+   /// ```\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     pub fn rotate_left(&mut self, mid: usize) {\n         core_slice::SliceExt::rotate_left(self, mid);\n     }\n \n-    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n-    #[rustc_deprecated(since = \"\", reason = \"renamed to `rotate_left`\")]\n-    pub fn rotate(&mut self, mid: usize) {\n-        core_slice::SliceExt::rotate_left(self, mid);\n-    }\n-\n     /// Rotates the slice in-place such that the first `self.len() - k`\n     /// elements of the slice move to the end while the last `k` elements move\n     /// to the front. After calling `rotate_right`, the element previously at\n@@ -1505,8 +1495,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(slice_rotate)]\n-    ///\n     /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n     /// a.rotate_right(2);\n     /// assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n@@ -1515,13 +1503,11 @@ impl<T> [T] {\n     /// Rotate a subslice:\n     ///\n     /// ```\n-    /// #![feature(slice_rotate)]\n-    ///\n     /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n     /// a[1..5].rotate_right(1);\n     /// assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);\n     /// ```\n-    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     pub fn rotate_right(&mut self, k: usize) {\n         core_slice::SliceExt::rotate_right(self, k);\n     }"}, {"sha": "168dbb2ce9b1f1685851ef8ed7828a0b5e4a7971", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -23,7 +23,6 @@\n #![feature(pattern)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n-#![feature(slice_rotate)]\n #![feature(splice)]\n #![feature(str_escape)]\n #![feature(string_retain)]"}, {"sha": "419ae96b94bd6caf4fc425b9363239c19d490dfc", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -863,6 +863,9 @@ impl<T: ?Sized> !Sync for RefCell<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RefCell<T> {\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently mutably borrowed.\n     #[inline]\n     fn clone(&self) -> RefCell<T> {\n         RefCell::new(self.borrow().clone())\n@@ -880,6 +883,9 @@ impl<T:Default> Default for RefCell<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for RefCell<T> {\n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()\n@@ -891,26 +897,41 @@ impl<T: ?Sized + Eq> Eq for RefCell<T> {}\n \n #[stable(feature = \"cell_ord\", since = \"1.10.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for RefCell<T> {\n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn partial_cmp(&self, other: &RefCell<T>) -> Option<Ordering> {\n         self.borrow().partial_cmp(&*other.borrow())\n     }\n \n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn lt(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() < *other.borrow()\n     }\n \n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn le(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() <= *other.borrow()\n     }\n \n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn gt(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() > *other.borrow()\n     }\n \n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn ge(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() >= *other.borrow()\n@@ -919,6 +940,9 @@ impl<T: ?Sized + PartialOrd> PartialOrd for RefCell<T> {\n \n #[stable(feature = \"cell_ord\", since = \"1.10.0\")]\n impl<T: ?Sized + Ord> Ord for RefCell<T> {\n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn cmp(&self, other: &RefCell<T>) -> Ordering {\n         self.borrow().cmp(&*other.borrow())"}, {"sha": "59a67fff48cfed422001fc5e06ef6527210f9a73", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -634,6 +634,46 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n+overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(8\", stringify!($SelfT), \".checked_pow(2), Some(64));\n+assert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\",\n+$EndFeature, \"\n+```\"),\n+\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc.checked_mul(base)?;\n+                    }\n+                    exp /= 2;\n+                    base = base.checked_mul(base)?;\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    acc = acc.checked_mul(base)?;\n+                }\n+\n+                Some(acc)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n bounds instead of overflowing.\n@@ -713,6 +753,34 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Saturating integer exponentiation. Computes `self.pow(exp)`,\n+saturating at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n+\n+assert_eq!((-4\", stringify!($SelfT), \").saturating_pow(3), -64);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT), \"::MIN);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn saturating_pow(self, exp: u32) -> Self {\n+                match self.checked_pow(exp) {\n+                    Some(x) => x,\n+                    None if self < 0 && exp % 2 == 1 => Self::min_value(),\n+                    None => Self::max_value(),\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\n boundary of the type.\n@@ -947,6 +1015,46 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n+wrapping around at the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(4), 81);\n+assert_eq!(3i8.wrapping_pow(5), -13);\n+assert_eq!(3i8.wrapping_pow(6), -39);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn wrapping_pow(self, mut exp: u32) -> Self {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc.wrapping_mul(base);\n+                    }\n+                    exp /= 2;\n+                    base = base.wrapping_mul(base);\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    acc = acc.wrapping_mul(base);\n+                }\n+\n+                acc\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates `self` + `rhs`\n \n@@ -1202,6 +1310,56 @@ $EndFeature, \"\n         doc_comment! {\n             concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n \n+Returns a tuple of the exponentiation along with a bool indicating\n+whether an overflow happened.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(4), (81, false));\n+assert_eq!(3i8.overflowing_pow(5), (-13, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+                let mut overflown = false;\n+                // Scratch space for storing results of overflowing_mul.\n+                let mut r;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        r = acc.overflowing_mul(base);\n+                        acc = r.0;\n+                        overflown |= r.1;\n+                    }\n+                    exp /= 2;\n+                    r = base.overflowing_mul(base);\n+                    base = r.0;\n+                    overflown |= r.1;\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    r = acc.overflowing_mul(base);\n+                    acc = r.0;\n+                    overflown |= r.1;\n+                }\n+\n+                (acc, overflown)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n+\n # Examples\n \n Basic usage:\n@@ -1887,6 +2045,44 @@ assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\", $EndFeature,\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n+overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\n+assert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\", $EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc.checked_mul(base)?;\n+                    }\n+                    exp /= 2;\n+                    base = base.checked_mul(base)?;\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    acc = acc.checked_mul(base)?;\n+                }\n+\n+                Some(acc)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at\n the numeric bounds instead of overflowing.\n@@ -1953,6 +2149,32 @@ assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($Se\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Saturating integer exponentiation. Computes `self.pow(exp)`,\n+saturating at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn saturating_pow(self, exp: u32) -> Self {\n+                match self.checked_pow(exp) {\n+                    Some(x) => x,\n+                    None => Self::max_value(),\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n@@ -2147,6 +2369,44 @@ assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\", $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n+wrapping around at the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\n+assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn wrapping_pow(self, mut exp: u32) -> Self {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc.wrapping_mul(base);\n+                    }\n+                    exp /= 2;\n+                    base = base.wrapping_mul(base);\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    acc = acc.wrapping_mul(base);\n+                }\n+\n+                acc\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates `self` + `rhs`\n \n@@ -2353,7 +2613,55 @@ assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\", $E\n             pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n             }\n+        }\n \n+        doc_comment! {\n+            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n+\n+Returns a tuple of the exponentiation along with a bool indicating\n+whether an overflow happened.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\n+assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+                let mut overflown = false;\n+                // Scratch space for storing results of overflowing_mul.\n+                let mut r;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        r = acc.overflowing_mul(base);\n+                        acc = r.0;\n+                        overflown |= r.1;\n+                    }\n+                    exp /= 2;\n+                    r = base.overflowing_mul(base);\n+                    base = r.0;\n+                    overflown |= r.1;\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    r = acc.overflowing_mul(base);\n+                    acc = r.0;\n+                    overflown |= r.1;\n+                }\n+\n+                (acc, overflown)\n+            }\n         }\n \n         doc_comment! {"}, {"sha": "a43ed65907f831a716de1b8866b9e7b5722d6afd", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -211,10 +211,10 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n-    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     fn rotate_left(&mut self, mid: usize);\n \n-    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     fn rotate_right(&mut self, k: usize);\n \n     #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]"}, {"sha": "0049ed66a102a1369e0cf0164228102b69195d64", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -37,7 +37,6 @@\n #![feature(refcell_replace_swap)]\n #![feature(sip_hash_13)]\n #![feature(slice_patterns)]\n-#![feature(slice_rotate)]\n #![feature(sort_internals)]\n #![feature(specialization)]\n #![feature(step_trait)]"}, {"sha": "9909ff91a18aabe186dc2142bb4e1cf47464f65c", "filename": "src/librustc/README.md", "status": "modified", "additions": 2, "deletions": 203, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -1,204 +1,3 @@\n-An informal guide to reading and working on the rustc compiler.\n-==================================================================\n+For more information about how rustc works, see the [rustc guide].\n \n-If you wish to expand on this document, or have a more experienced\n-Rust contributor add anything else to it, please get in touch:\n-\n-* https://internals.rust-lang.org/\n-* https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n-\n-or file a bug:\n-\n-https://github.com/rust-lang/rust/issues\n-\n-Your concerns are probably the same as someone else's.\n-\n-You may also be interested in the\n-[Rust Forge](https://forge.rust-lang.org/), which includes a number of\n-interesting bits of information.\n-\n-Finally, at the end of this file is a GLOSSARY defining a number of\n-common (and not necessarily obvious!) names that are used in the Rust\n-compiler code. If you see some funky name and you'd like to know what\n-it stands for, check there!\n-\n-The crates of rustc\n-===================\n-\n-Rustc consists of a number of crates, including `syntax`,\n-`rustc`, `rustc_back`, `rustc_trans`, `rustc_driver`, and\n-many more. The source for each crate can be found in a directory\n-like `src/libXXX`, where `XXX` is the crate name.\n-\n-(NB. The names and divisions of these crates are not set in\n-stone and may change over time -- for the time being, we tend towards\n-a finer-grained division to help with compilation time, though as\n-incremental improves that may change.)\n-\n-The dependency structure of these crates is roughly a diamond:\n-\n-```\n-                  rustc_driver\n-                /      |       \\\n-              /        |         \\\n-            /          |           \\\n-          /            v             \\\n-rustc_trans    rustc_borrowck   ...  rustc_metadata\n-          \\            |            /\n-            \\          |          /\n-              \\        |        /\n-                \\      v      /\n-                    rustc\n-                       |\n-                       v\n-                    syntax\n-                    /    \\\n-                  /       \\\n-           syntax_pos  syntax_ext\n-```                    \n-\n-The `rustc_driver` crate, at the top of this lattice, is effectively\n-the \"main\" function for the rust compiler. It doesn't have much \"real\n-code\", but instead ties together all of the code defined in the other\n-crates and defines the overall flow of execution. (As we transition\n-more and more to the [query model](ty/maps/README.md), however, the\n-\"flow\" of compilation is becoming less centrally defined.)\n-\n-At the other extreme, the `rustc` crate defines the common and\n-pervasive data structures that all the rest of the compiler uses\n-(e.g., how to represent types, traits, and the program itself). It\n-also contains some amount of the compiler itself, although that is\n-relatively limited.\n-\n-Finally, all the crates in the bulge in the middle define the bulk of\n-the compiler -- they all depend on `rustc`, so that they can make use\n-of the various types defined there, and they export public routines\n-that `rustc_driver` will invoke as needed (more and more, what these\n-crates export are \"query definitions\", but those are covered later\n-on).\n-\n-Below `rustc` lie various crates that make up the parser and error\n-reporting mechanism. For historical reasons, these crates do not have\n-the `rustc_` prefix, but they are really just as much an internal part\n-of the compiler and not intended to be stable (though they do wind up\n-getting used by some crates in the wild; a practice we hope to\n-gradually phase out).\n-\n-Each crate has a `README.md` file that describes, at a high-level,\n-what it contains, and tries to give some kind of explanation (some\n-better than others).\n-\n-The compiler process\n-====================\n-\n-The Rust compiler is in a bit of transition right now. It used to be a\n-purely \"pass-based\" compiler, where we ran a number of passes over the\n-entire program, and each did a particular check of transformation.\n-\n-We are gradually replacing this pass-based code with an alternative\n-setup based on on-demand **queries**. In the query-model, we work\n-backwards, executing a *query* that expresses our ultimate goal (e.g.,\n-\"compile this crate\"). This query in turn may make other queries\n-(e.g., \"get me a list of all modules in the crate\"). Those queries\n-make other queries that ultimately bottom out in the base operations,\n-like parsing the input, running the type-checker, and so forth. This\n-on-demand model permits us to do exciting things like only do the\n-minimal amount of work needed to type-check a single function. It also\n-helps with incremental compilation. (For details on defining queries,\n-check out `src/librustc/ty/maps/README.md`.)\n-\n-Regardless of the general setup, the basic operations that the\n-compiler must perform are the same. The only thing that changes is\n-whether these operations are invoked front-to-back, or on demand.  In\n-order to compile a Rust crate, these are the general steps that we\n-take:\n-\n-1. **Parsing input**\n-    - this processes the `.rs` files and produces the AST (\"abstract syntax tree\")\n-    - the AST is defined in `syntax/ast.rs`. It is intended to match the lexical\n-      syntax of the Rust language quite closely.\n-2. **Name resolution, macro expansion, and configuration**\n-    - once parsing is complete, we process the AST recursively, resolving paths\n-      and expanding macros. This same process also processes `#[cfg]` nodes, and hence\n-      may strip things out of the AST as well.\n-3. **Lowering to HIR**\n-    - Once name resolution completes, we convert the AST into the HIR,\n-      or \"high-level IR\". The HIR is defined in `src/librustc/hir/`; that module also includes\n-      the lowering code.\n-    - The HIR is a lightly desugared variant of the AST. It is more processed than the\n-      AST and more suitable for the analyses that follow. It is **not** required to match\n-      the syntax of the Rust language.\n-    - As a simple example, in the **AST**, we preserve the parentheses\n-      that the user wrote, so `((1 + 2) + 3)` and `1 + 2 + 3` parse\n-      into distinct trees, even though they are equivalent. In the\n-      HIR, however, parentheses nodes are removed, and those two\n-      expressions are represented in the same way.\n-3. **Type-checking and subsequent analyses**\n-    - An important step in processing the HIR is to perform type\n-      checking. This process assigns types to every HIR expression,\n-      for example, and also is responsible for resolving some\n-      \"type-dependent\" paths, such as field accesses (`x.f` -- we\n-      can't know what field `f` is being accessed until we know the\n-      type of `x`) and associated type references (`T::Item` -- we\n-      can't know what type `Item` is until we know what `T` is).\n-    - Type checking creates \"side-tables\" (`TypeckTables`) that include\n-      the types of expressions, the way to resolve methods, and so forth.\n-    - After type-checking, we can do other analyses, such as privacy checking.\n-4. **Lowering to MIR and post-processing**\n-    - Once type-checking is done, we can lower the HIR into MIR (\"middle IR\"), which\n-      is a **very** desugared version of Rust, well suited to the borrowck but also\n-      certain high-level optimizations. \n-5. **Translation to LLVM and LLVM optimizations**\n-    - From MIR, we can produce LLVM IR.\n-    - LLVM then runs its various optimizations, which produces a number of `.o` files\n-      (one for each \"codegen unit\").\n-6. **Linking**\n-    - Finally, those `.o` files are linked together.\n-\n-Glossary\n-========\n-\n-The compiler uses a number of...idiosyncratic abbreviations and\n-things. This glossary attempts to list them and give you a few\n-pointers for understanding them better.\n-\n-- AST -- the **abstract syntax tree** produced by the `syntax` crate; reflects user syntax\n-  very closely. \n-- codegen unit -- when we produce LLVM IR, we group the Rust code into a number of codegen\n-  units. Each of these units is processed by LLVM independently from one another,\n-  enabling parallelism. They are also the unit of incremental re-use. \n-- cx -- we tend to use \"cx\" as an abbrevation for context. See also tcx, infcx, etc.\n-- `DefId` -- an index identifying a **definition** (see `librustc/hir/def_id.rs`). Uniquely\n-  identifies a `DefPath`.\n-- HIR -- the **High-level IR**, created by lowering and desugaring the AST. See `librustc/hir`.\n-- `HirId` -- identifies a particular node in the HIR by combining a\n-  def-id with an \"intra-definition offset\".\n-- `'gcx` -- the lifetime of the global arena (see `librustc/ty`).\n-- generics -- the set of generic type parameters defined on a type or item\n-- ICE -- internal compiler error. When the compiler crashes.\n-- ICH -- incremental compilation hash.\n-- infcx -- the inference context (see `librustc/infer`)\n-- MIR -- the **Mid-level IR** that is created after type-checking for use by borrowck and trans.\n-  Defined in the `src/librustc/mir/` module, but much of the code that manipulates it is\n-  found in `src/librustc_mir`.\n-- obligation -- something that must be proven by the trait system; see `librustc/traits`.\n-- local crate -- the crate currently being compiled.\n-- node-id or `NodeId` -- an index identifying a particular node in the\n-  AST or HIR; gradually being phased out and replaced with `HirId`.\n-- query -- perhaps some sub-computation during compilation; see `librustc/maps`.\n-- provider -- the function that executes a query; see `librustc/maps`.\n-- sess -- the **compiler session**, which stores global data used throughout compilation\n-- side tables -- because the AST and HIR are immutable once created, we often carry extra\n-  information about them in the form of hashtables, indexed by the id of a particular node.\n-- span -- a location in the user's source code, used for error\n-  reporting primarily.  These are like a file-name/line-number/column\n-  tuple on steroids: they carry a start/end point, and also track\n-  macro expansions and compiler desugaring. All while being packed\n-  into a few bytes (really, it's an index into a table). See the\n-  `Span` datatype for more.\n-- substs -- the **substitutions** for a given generic type or item\n-  (e.g., the `i32, u32` in `HashMap<i32, u32>`)\n-- tcx -- the \"typing context\", main data structure of the compiler (see `librustc/ty`).\n-- trans -- the code to **translate** MIR into LLVM IR.\n-- trait reference -- a trait and values for its type parameters (see `librustc/ty`).\n-- ty -- the internal representation of a **type** (see `librustc/ty`).\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/"}, {"sha": "61a8fb09118bfa4b6aff217e5ebd59b84c021535", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -168,7 +168,7 @@ impl DepGraph {\n     /// what state they have access to. In particular, we want to\n     /// prevent implicit 'leaks' of tracked state into the task (which\n     /// could then be read without generating correct edges in the\n-    /// dep-graph -- see the module-level [README] for more details on\n+    /// dep-graph -- see the [rustc guide] for more details on\n     /// the dep-graph). To this end, the task function gets exactly two\n     /// pieces of state: the context `cx` and an argument `arg`. Both\n     /// of these bits of state must be of some type that implements\n@@ -188,7 +188,7 @@ impl DepGraph {\n     /// - If you need 3+ arguments, use a tuple for the\n     ///   `arg` parameter.\n     ///\n-    /// [README]: https://github.com/rust-lang/rust/blob/master/src/librustc/dep_graph/README.md\n+    /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/incremental-compilation.html\n     pub fn with_task<C, A, R, HCX>(&self,\n                                    key: DepNode,\n                                    cx: C,"}, {"sha": "e283fc40c50a345fc9ed5658753bc45eb9d6836a", "filename": "src/librustc/hir/README.md", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Fhir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Fhir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2FREADME.md?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -1,119 +0,0 @@\n-# Introduction to the HIR\n-\n-The HIR -- \"High-level IR\" -- is the primary IR used in most of\n-rustc. It is a desugared version of the \"abstract syntax tree\" (AST)\n-that is generated after parsing, macro expansion, and name resolution\n-have completed. Many parts of HIR resemble Rust surface syntax quite\n-closely, with the exception that some of Rust's expression forms have\n-been desugared away (as an example, `for` loops are converted into a\n-`loop` and do not appear in the HIR).\n-\n-This README covers the main concepts of the HIR.\n-\n-### Out-of-band storage and the `Crate` type\n-\n-The top-level data-structure in the HIR is the `Crate`, which stores\n-the contents of the crate currently being compiled (we only ever\n-construct HIR for the current crate). Whereas in the AST the crate\n-data structure basically just contains the root module, the HIR\n-`Crate` structure contains a number of maps and other things that\n-serve to organize the content of the crate for easier access.\n-\n-For example, the contents of individual items (e.g., modules,\n-functions, traits, impls, etc) in the HIR are not immediately\n-accessible in the parents. So, for example, if had a module item `foo`\n-containing a function `bar()`:\n-\n-```\n-mod foo {\n-  fn bar() { }\n-}\n-```\n-\n-Then in the HIR the representation of module `foo` (the `Mod`\n-stuct) would have only the **`ItemId`** `I` of `bar()`. To get the\n-details of the function `bar()`, we would lookup `I` in the\n-`items` map.\n-\n-One nice result from this representation is that one can iterate\n-over all items in the crate by iterating over the key-value pairs\n-in these maps (without the need to trawl through the IR in total).\n-There are similar maps for things like trait items and impl items,\n-as well as \"bodies\" (explained below).\n-\n-The other reason to setup the representation this way is for better\n-integration with incremental compilation. This way, if you gain access\n-to a `&hir::Item` (e.g. for the mod `foo`), you do not immediately\n-gain access to the contents of the function `bar()`. Instead, you only\n-gain access to the **id** for `bar()`, and you must invoke some\n-function to lookup the contents of `bar()` given its id; this gives us\n-a chance to observe that you accessed the data for `bar()` and record\n-the dependency.\n-\n-### Identifiers in the HIR\n-\n-Most of the code that has to deal with things in HIR tends not to\n-carry around references into the HIR, but rather to carry around\n-*identifier numbers* (or just \"ids\"). Right now, you will find four\n-sorts of identifiers in active use:\n-\n-- `DefId`, which primarily names \"definitions\" or top-level items.\n-  - You can think of a `DefId` as being shorthand for a very explicit\n-    and complete path, like `std::collections::HashMap`. However,\n-    these paths are able to name things that are not nameable in\n-    normal Rust (e.g., impls), and they also include extra information\n-    about the crate (such as its version number, as two versions of\n-    the same crate can co-exist).\n-  - A `DefId` really consists of two parts, a `CrateNum` (which\n-    identifies the crate) and a `DefIndex` (which indixes into a list\n-    of items that is maintained per crate).\n-- `HirId`, which combines the index of a particular item with an\n-  offset within that item.\n-  - the key point of a `HirId` is that it is *relative* to some item (which is named\n-    via a `DefId`).\n-- `BodyId`, this is an absolute identifier that refers to a specific\n-  body (definition of a function or constant) in the crate. It is currently\n-  effectively a \"newtype'd\" `NodeId`.\n-- `NodeId`, which is an absolute id that identifies a single node in the HIR tree.\n-  - While these are still in common use, **they are being slowly phased out**.\n-  - Since they are absolute within the crate, adding a new node\n-    anywhere in the tree causes the node-ids of all subsequent code in\n-    the crate to change. This is terrible for incremental compilation,\n-    as you can perhaps imagine.\n-\n-### HIR Map\n-\n-Most of the time when you are working with the HIR, you will do so via\n-the **HIR Map**, accessible in the tcx via `tcx.hir` (and defined in\n-the `hir::map` module). The HIR map contains a number of methods to\n-convert between ids of various kinds and to lookup data associated\n-with a HIR node.\n-\n-For example, if you have a `DefId`, and you would like to convert it\n-to a `NodeId`, you can use `tcx.hir.as_local_node_id(def_id)`. This\n-returns an `Option<NodeId>` -- this will be `None` if the def-id\n-refers to something outside of the current crate (since then it has no\n-HIR node), but otherwise returns `Some(n)` where `n` is the node-id of\n-the definition.\n-\n-Similarly, you can use `tcx.hir.find(n)` to lookup the node for a\n-`NodeId`. This returns a `Option<Node<'tcx>>`, where `Node` is an enum\n-defined in the map; by matching on this you can find out what sort of\n-node the node-id referred to and also get a pointer to the data\n-itself. Often, you know what sort of node `n` is -- e.g., if you know\n-that `n` must be some HIR expression, you can do\n-`tcx.hir.expect_expr(n)`, which will extract and return the\n-`&hir::Expr`, panicking if `n` is not in fact an expression.\n-\n-Finally, you can use the HIR map to find the parents of nodes, via\n-calls like `tcx.hir.get_parent_node(n)`.\n-\n-### HIR Bodies\n-\n-A **body** represents some kind of executable code, such as the body\n-of a function/closure or the definition of a constant. Bodies are\n-associated with an **owner**, which is typically some kind of item\n-(e.g., a `fn()` or `const`), but could also be a closure expression\n-(e.g., `|x, y| x + y`). You can use the HIR map to find the body\n-associated with a given def-id (`maybe_body_owned_by()`) or to find\n-the owner of a body (`body_owner_def_id()`)."}, {"sha": "34ed325705ab98c231f0ae9ac578fd252c6a6f1d", "filename": "src/librustc/hir/map/README.md", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -1,4 +0,0 @@\n-The HIR map, accessible via `tcx.hir`, allows you to quickly navigate the\n-HIR and convert between various forms of identifiers. See [the HIR README] for more information.\n-\n-[the HIR README]: ../README.md"}, {"sha": "c4873cb83076a1cb636a27aa3ba08b8cdb5ed7c2", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -602,9 +602,9 @@ pub type CrateConfig = HirVec<P<MetaItem>>;\n /// The top-level data structure that stores the entire contents of\n /// the crate currently being compiled.\n ///\n-/// For more details, see the module-level [README].\n+/// For more details, see the [rustc guide].\n ///\n-/// [README]: https://github.com/rust-lang/rust/blob/master/src/librustc/hir/README.md.\n+/// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/hir.html\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,"}, {"sha": "7f58d03906026ee0a79f23334f48c86d63d111b7", "filename": "src/librustc/infer/README.md", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Finfer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Finfer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2FREADME.md?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -1,227 +0,0 @@\n-# Type inference engine\n-\n-The type inference is based on standard HM-type inference, but\n-extended in various way to accommodate subtyping, region inference,\n-and higher-ranked types.\n-\n-## A note on terminology\n-\n-We use the notation `?T` to refer to inference variables, also called\n-existential variables.\n-\n-We use the term \"region\" and \"lifetime\" interchangeably. Both refer to\n-the `'a` in `&'a T`.\n-\n-The term \"bound region\" refers to regions bound in a function\n-signature, such as the `'a` in `for<'a> fn(&'a u32)`. A region is\n-\"free\" if it is not bound.\n-\n-## Creating an inference context\n-\n-You create and \"enter\" an inference context by doing something like\n-the following:\n-\n-```rust\n-tcx.infer_ctxt().enter(|infcx| {\n-    // use the inference context `infcx` in here\n-})\n-```\n-\n-Each inference context creates a short-lived type arena to store the\n-fresh types and things that it will create, as described in\n-[the README in the ty module][ty-readme]. This arena is created by the `enter`\n-function and disposed after it returns.\n-\n-[ty-readme]: src/librustc/ty/README.md\n-\n-Within the closure, the infcx will have the type `InferCtxt<'cx, 'gcx,\n-'tcx>` for some fresh `'cx` and `'tcx` -- the latter corresponds to\n-the lifetime of this temporary arena, and the `'cx` is the lifetime of\n-the `InferCtxt` itself. (Again, see [that ty README][ty-readme] for\n-more details on this setup.)\n-\n-The `tcx.infer_ctxt` method actually returns a build, which means\n-there are some kinds of configuration you can do before the `infcx` is\n-created. See `InferCtxtBuilder` for more information.\n-\n-## Inference variables\n-\n-The main purpose of the inference context is to house a bunch of\n-**inference variables** -- these represent types or regions whose precise\n-value is not yet known, but will be uncovered as we perform type-checking.\n-\n-If you're familiar with the basic ideas of unification from H-M type\n-systems, or logic languages like Prolog, this is the same concept. If\n-you're not, you might want to read a tutorial on how H-M type\n-inference works, or perhaps this blog post on\n-[unification in the Chalk project].\n-\n-[Unification in the Chalk project]: http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/\n-\n-All told, the inference context stores four kinds of inference variables as of this\n-writing:\n-\n-- Type variables, which come in three varieties:\n-  - General type variables (the most common). These can be unified with any type.\n-  - Integral type variables, which can only be unified with an integral type, and\n-    arise from an integer literal expression like `22`.\n-  - Float type variables, which can only be unified with a float type, and\n-    arise from a float literal expression like `22.0`.\n-- Region variables, which represent lifetimes, and arise all over the dang place.\n-\n-All the type variables work in much the same way: you can create a new\n-type variable, and what you get is `Ty<'tcx>` representing an\n-unresolved type `?T`. Then later you can apply the various operations\n-that the inferencer supports, such as equality or subtyping, and it\n-will possibly **instantiate** (or **bind**) that `?T` to a specific\n-value as a result.\n-\n-The region variables work somewhat differently, and are described\n-below in a separate section.\n-\n-## Enforcing equality / subtyping\n-\n-The most basic operations you can perform in the type inferencer is\n-**equality**, which forces two types `T` and `U` to be the same. The\n-recommended way to add an equality constraint is using the `at`\n-method, roughly like so:\n-\n-```\n-infcx.at(...).eq(t, u);\n-```\n-\n-The first `at()` call provides a bit of context, i.e., why you are\n-doing this unification, and in what environment, and the `eq` method\n-performs the actual equality constraint.\n-\n-When you equate things, you force them to be precisely equal. Equating\n-returns a `InferResult` -- if it returns `Err(err)`, then equating\n-failed, and the enclosing `TypeError` will tell you what went wrong.\n-\n-The success case is perhaps more interesting. The \"primary\" return\n-type of `eq` is `()` -- that is, when it succeeds, it doesn't return a\n-value of any particular interest. Rather, it is executed for its\n-side-effects of constraining type variables and so forth. However, the\n-actual return type is not `()`, but rather `InferOk<()>`. The\n-`InferOk` type is used to carry extra trait obligations -- your job is\n-to ensure that these are fulfilled (typically by enrolling them in a\n-fulfillment context). See the [trait README] for more background here.\n-\n-[trait README]: ../traits/README.md\n-\n-You can also enforce subtyping through `infcx.at(..).sub(..)`. The same\n-basic concepts apply as above.\n-\n-## \"Trying\" equality\n-\n-Sometimes you would like to know if it is *possible* to equate two\n-types without error.  You can test that with `infcx.can_eq` (or\n-`infcx.can_sub` for subtyping). If this returns `Ok`, then equality\n-is possible -- but in all cases, any side-effects are reversed.\n-\n-Be aware though that the success or failure of these methods is always\n-**modulo regions**. That is, two types `&'a u32` and `&'b u32` will\n-return `Ok` for `can_eq`, even if `'a != 'b`.  This falls out from the\n-\"two-phase\" nature of how we solve region constraints.\n-\n-## Snapshots\n-\n-As described in the previous section on `can_eq`, often it is useful\n-to be able to do a series of operations and then roll back their\n-side-effects. This is done for various reasons: one of them is to be\n-able to backtrack, trying out multiple possibilities before settling\n-on which path to take. Another is in order to ensure that a series of\n-smaller changes take place atomically or not at all.\n-\n-To allow for this, the inference context supports a `snapshot` method.\n-When you call it, it will start recording changes that occur from the\n-operations you perform. When you are done, you can either invoke\n-`rollback_to`, which will undo those changes, or else `confirm`, which\n-will make the permanent. Snapshots can be nested as long as you follow\n-a stack-like discipline.\n-\n-Rather than use snapshots directly, it is often helpful to use the\n-methods like `commit_if_ok` or `probe` that encapsulate higher-level\n-patterns.\n-\n-## Subtyping obligations\n-\n-One thing worth discussing are subtyping obligations. When you force\n-two types to be a subtype, like `?T <: i32`, we can often convert those\n-into equality constraints. This follows from Rust's rather limited notion\n-of subtyping: so, in the above case, `?T <: i32` is equivalent to `?T = i32`.\n-\n-However, in some cases we have to be more careful. For example, when\n-regions are involved. So if you have `?T <: &'a i32`, what we would do\n-is to first \"generalize\" `&'a i32` into a type with a region variable:\n-`&'?b i32`, and then unify `?T` with that (`?T = &'?b i32`). We then\n-relate this new variable with the original bound:\n-\n-    &'?b i32 <: &'a i32\n-    \n-This will result in a region constraint (see below) of `'?b: 'a`.\n-\n-One final interesting case is relating two unbound type variables,\n-like `?T <: ?U`.  In that case, we can't make progress, so we enqueue\n-an obligation `Subtype(?T, ?U)` and return it via the `InferOk`\n-mechanism. You'll have to try again when more details about `?T` or\n-`?U` are known.\n-\n-## Region constraints\n-\n-Regions are inferred somewhat differently from types. Rather than\n-eagerly unifying things, we simply collect constraints as we go, but\n-make (almost) no attempt to solve regions. These constraints have the\n-form of an outlives constraint:\n-\n-    'a: 'b\n-    \n-Actually the code tends to view them as a subregion relation, but it's the same\n-idea:\n-\n-    'b <= 'a\n-\n-(There are various other kinds of constriants, such as \"verifys\"; see\n-the `region_constraints` module for details.)\n-\n-There is one case where we do some amount of eager unification. If you have an equality constraint\n-between two regions\n-\n-    'a = 'b\n-    \n-we will record that fact in a unification table. You can then use\n-`opportunistic_resolve_var` to convert `'b` to `'a` (or vice\n-versa). This is sometimes needed to ensure termination of fixed-point\n-algorithms.\n-\n-## Extracting region constraints\n-\n-Ultimately, region constraints are only solved at the very end of\n-type-checking, once all other constraints are known. There are two\n-ways to solve region constraints right now: lexical and\n-non-lexical. Eventually there will only be one.\n-\n-To solve **lexical** region constraints, you invoke\n-`resolve_regions_and_report_errors`.  This will \"close\" the region\n-constraint process and invoke the `lexical_region_resolve` code. Once\n-this is done, any further attempt to equate or create a subtyping\n-relationship will yield an ICE.\n-\n-Non-lexical region constraints are not handled within the inference\n-context. Instead, the NLL solver (actually, the MIR type-checker)\n-invokes `take_and_reset_region_constraints` periodically. This\n-extracts all of the outlives constraints from the region solver, but\n-leaves the set of variables intact. This is used to get *just* the\n-region constraints that resulted from some particular point in the\n-program, since the NLL solver needs to know not just *what* regions\n-were subregions but *where*. Finally, the NLL solver invokes\n-`take_region_var_origins`, which \"closes\" the region constraint\n-process in the same way as normal solving.\n-\n-## Lexical region resolution\n-\n-Lexical region resolution is done by initially assigning each region\n-variable to an empty value. We then process each outlives constraint\n-repeatedly, growing region variables until a fixed-point is reached.\n-Region variables can be grown using a least-upper-bound relation on\n-the region lattice in a fairly straight-forward fashion."}, {"sha": "d08a41010ab166ab452ac807e248f1b2479d35bc", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -28,8 +28,9 @@\n //!   this code handles low-level equality and subtyping operations. The\n //!   type check pass in the compiler is found in the `librustc_typeck` crate.\n //!\n-//! For a deeper explanation of how the compiler works and is\n-//! organized, see the README.md file in this directory.\n+//! For more information about how rustc works, see the [rustc guide].\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/\n //!\n //! # Note\n //!"}, {"sha": "cac86be0fcb75c76a191cfb3a5223704ff868d37", "filename": "src/librustc/mir/README.md", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Fmir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Fmir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2FREADME.md?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -1,90 +0,0 @@\n-# MIR definition and pass system\n-\n-This file contains the definition of the MIR datatypes along with the\n-various types for the \"MIR Pass\" system, which lets you easily\n-register and define new MIR transformations and analyses.\n-\n-Most of the code that operates on MIR can be found in the\n-`librustc_mir` crate or other crates. The code found here in\n-`librustc` is just the datatype definitions, along with the functions\n-which operate on MIR to be placed everywhere else.\n-\n-## MIR Data Types and visitor\n-\n-The main MIR data type is `rustc::mir::Mir`, defined in `mod.rs`.\n-There is also the MIR visitor (in `visit.rs`) which allows you to walk\n-the MIR and override what actions will be taken at various points (you\n-can visit in either shared or mutable mode; the latter allows changing\n-the MIR in place). Finally `traverse.rs` contains various traversal\n-routines for visiting the MIR CFG in [different standard orders][traversal]\n-(e.g. pre-order, reverse post-order, and so forth).\n-\n-[traversal]: https://en.wikipedia.org/wiki/Tree_traversal\n-\n-## MIR pass suites and their integration into the query system\n-\n-As a MIR *consumer*, you are expected to use one of the queries that\n-returns a \"final MIR\". As of the time of this writing, there is only\n-one: `optimized_mir(def_id)`, but more are expected to come in the\n-future. For foreign def-ids, we simply read the MIR from the other\n-crate's metadata. But for local def-ids, the query will construct the\n-MIR and then iteratively optimize it by putting it through various\n-pipeline stages. This section describes those pipeline stages and how\n-you can extend them.\n-\n-To produce the `optimized_mir(D)` for a given def-id `D`, the MIR\n-passes through several suites of optimizations, each represented by a\n-query. Each suite consists of multiple optimizations and\n-transformations. These suites represent useful intermediate points\n-where we want to access the MIR for type checking or other purposes:\n-\n-- `mir_build(D)` -- not a query, but this constructs the initial MIR\n-- `mir_const(D)` -- applies some simple transformations to make MIR ready for constant evaluation;\n-- `mir_validated(D)` -- applies some more transformations, making MIR ready for borrow checking;\n-- `optimized_mir(D)` -- the final state, after all optimizations have been performed.\n-\n-### Stealing\n-\n-The intermediate queries `mir_const()` and `mir_validated()` yield up\n-a `&'tcx Steal<Mir<'tcx>>`, allocated using\n-`tcx.alloc_steal_mir()`. This indicates that the result may be\n-**stolen** by the next suite of optimizations -- this is an\n-optimization to avoid cloning the MIR. Attempting to use a stolen\n-result will cause a panic in the compiler. Therefore, it is important\n-that you do not read directly from these intermediate queries except as\n-part of the MIR processing pipeline.\n-\n-Because of this stealing mechanism, some care must also be taken to\n-ensure that, before the MIR at a particular phase in the processing\n-pipeline is stolen, anyone who may want to read from it has already\n-done so. Concretely, this means that if you have some query `foo(D)`\n-that wants to access the result of `mir_const(D)` or\n-`mir_validated(D)`, you need to have the successor pass \"force\"\n-`foo(D)` using `ty::queries::foo::force(...)`. This will force a query\n-to execute even though you don't directly require its result.\n-\n-As an example, consider MIR const qualification. It wants to read the\n-result produced by the `mir_const()` suite. However, that result will\n-be **stolen** by the `mir_validated()` suite. If nothing was done,\n-then `mir_const_qualif(D)` would succeed if it came before\n-`mir_validated(D)`, but fail otherwise. Therefore, `mir_validated(D)`\n-will **force** `mir_const_qualif` before it actually steals, thus\n-ensuring that the reads have already happened:\n-\n-```\n-mir_const(D) --read-by--> mir_const_qualif(D)\n-     |                       ^\n-  stolen-by                  |\n-     |                    (forces)\n-     v                       |\n-mir_validated(D) ------------+\n-```\n-\n-### Implementing and registering a pass\n-\n-To create a new MIR pass, you simply implement the `MirPass` trait for\n-some fresh singleton type `Foo`. Once you have implemented a trait for\n-your type `Foo`, you then have to insert `Foo` into one of the suites;\n-this is done in `librustc_driver/driver.rs` by invoking `push_pass(S,\n-Foo)` with the appropriate suite substituted for `S`.\n-"}, {"sha": "fa7f5c08608bb6486aa3b0e9444c8eeca9b6a885", "filename": "src/librustc/traits/README.md", "status": "removed", "additions": 0, "deletions": 482, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2FREADME.md?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -1,482 +0,0 @@\n-# TRAIT RESOLUTION\n-\n-This document describes the general process and points out some non-obvious\n-things.\n-\n-## Major concepts\n-\n-Trait resolution is the process of pairing up an impl with each\n-reference to a trait. So, for example, if there is a generic function like:\n-\n-```rust\n-fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { /*...*/ }\n-```\n-\n-and then a call to that function:\n-\n-```rust\n-let v: Vec<isize> = clone_slice(&[1, 2, 3])\n-```\n-\n-it is the job of trait resolution to figure out (in which case)\n-whether there exists an impl of `isize : Clone`\n-\n-Note that in some cases, like generic functions, we may not be able to\n-find a specific impl, but we can figure out that the caller must\n-provide an impl. To see what I mean, consider the body of `clone_slice`:\n-\n-```rust\n-fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n-    let mut v = Vec::new();\n-    for e in &x {\n-        v.push((*e).clone()); // (*)\n-    }\n-}\n-```\n-\n-The line marked `(*)` is only legal if `T` (the type of `*e`)\n-implements the `Clone` trait. Naturally, since we don't know what `T`\n-is, we can't find the specific impl; but based on the bound `T:Clone`,\n-we can say that there exists an impl which the caller must provide.\n-\n-We use the term *obligation* to refer to a trait reference in need of\n-an impl.\n-\n-## Overview\n-\n-Trait resolution consists of three major parts:\n-\n-- SELECTION: Deciding how to resolve a specific obligation. For\n-  example, selection might decide that a specific obligation can be\n-  resolved by employing an impl which matches the self type, or by\n-  using a parameter bound. In the case of an impl, Selecting one\n-  obligation can create *nested obligations* because of where clauses\n-  on the impl itself. It may also require evaluating those nested\n-  obligations to resolve ambiguities.\n-\n-- FULFILLMENT: The fulfillment code is what tracks that obligations\n-  are completely fulfilled. Basically it is a worklist of obligations\n-  to be selected: once selection is successful, the obligation is\n-  removed from the worklist and any nested obligations are enqueued.\n-\n-- COHERENCE: The coherence checks are intended to ensure that there\n-  are never overlapping impls, where two impls could be used with\n-  equal precedence.\n-\n-## Selection\n-\n-Selection is the process of deciding whether an obligation can be\n-resolved and, if so, how it is to be resolved (via impl, where clause, etc).\n-The main interface is the `select()` function, which takes an obligation\n-and returns a `SelectionResult`. There are three possible outcomes:\n-\n-- `Ok(Some(selection))` -- yes, the obligation can be resolved, and\n-  `selection` indicates how. If the impl was resolved via an impl,\n-  then `selection` may also indicate nested obligations that are required\n-  by the impl.\n-\n-- `Ok(None)` -- we are not yet sure whether the obligation can be\n-  resolved or not. This happens most commonly when the obligation\n-  contains unbound type variables.\n-\n-- `Err(err)` -- the obligation definitely cannot be resolved due to a\n-  type error, or because there are no impls that could possibly apply,\n-  etc.\n-\n-The basic algorithm for selection is broken into two big phases:\n-candidate assembly and confirmation.\n-\n-### Candidate assembly\n-\n-Searches for impls/where-clauses/etc that might\n-possibly be used to satisfy the obligation. Each of those is called\n-a candidate. To avoid ambiguity, we want to find exactly one\n-candidate that is definitively applicable. In some cases, we may not\n-know whether an impl/where-clause applies or not -- this occurs when\n-the obligation contains unbound inference variables.\n-\n-The basic idea for candidate assembly is to do a first pass in which\n-we identify all possible candidates. During this pass, all that we do\n-is try and unify the type parameters. (In particular, we ignore any\n-nested where clauses.) Presuming that this unification succeeds, the\n-impl is added as a candidate.\n-\n-Once this first pass is done, we can examine the set of candidates. If\n-it is a singleton set, then we are done: this is the only impl in\n-scope that could possibly apply. Otherwise, we can winnow down the set\n-of candidates by using where clauses and other conditions. If this\n-reduced set yields a single, unambiguous entry, we're good to go,\n-otherwise the result is considered ambiguous.\n-\n-#### The basic process: Inferring based on the impls we see\n-\n-This process is easier if we work through some examples. Consider\n-the following trait:\n-\n-```rust\n-trait Convert<Target> {\n-    fn convert(&self) -> Target;\n-}\n-```\n-\n-This trait just has one method. It's about as simple as it gets. It\n-converts from the (implicit) `Self` type to the `Target` type. If we\n-wanted to permit conversion between `isize` and `usize`, we might\n-implement `Convert` like so:\n-\n-```rust\n-impl Convert<usize> for isize { /*...*/ } // isize -> usize\n-impl Convert<isize> for usize { /*...*/ } // usize -> isize\n-```\n-\n-Now imagine there is some code like the following:\n-\n-```rust\n-let x: isize = ...;\n-let y = x.convert();\n-```\n-\n-The call to convert will generate a trait reference `Convert<$Y> for\n-isize`, where `$Y` is the type variable representing the type of\n-`y`. When we match this against the two impls we can see, we will find\n-that only one remains: `Convert<usize> for isize`. Therefore, we can\n-select this impl, which will cause the type of `$Y` to be unified to\n-`usize`. (Note that while assembling candidates, we do the initial\n-unifications in a transaction, so that they don't affect one another.)\n-\n-There are tests to this effect in src/test/run-pass:\n-\n-   traits-multidispatch-infer-convert-source-and-target.rs\n-   traits-multidispatch-infer-convert-target.rs\n-\n-#### Winnowing: Resolving ambiguities\n-\n-But what happens if there are multiple impls where all the types\n-unify? Consider this example:\n-\n-```rust\n-trait Get {\n-    fn get(&self) -> Self;\n-}\n-\n-impl<T:Copy> Get for T {\n-    fn get(&self) -> T { *self }\n-}\n-\n-impl<T:Get> Get for Box<T> {\n-    fn get(&self) -> Box<T> { box get_it(&**self) }\n-}\n-```\n-\n-What happens when we invoke `get_it(&box 1_u16)`, for example? In this\n-case, the `Self` type is `Box<u16>` -- that unifies with both impls,\n-because the first applies to all types, and the second to all\n-boxes. In the olden days we'd have called this ambiguous. But what we\n-do now is do a second *winnowing* pass that considers where clauses\n-and attempts to remove candidates -- in this case, the first impl only\n-applies if `Box<u16> : Copy`, which doesn't hold. After winnowing,\n-then, we are left with just one candidate, so we can proceed. There is\n-a test of this in `src/test/run-pass/traits-conditional-dispatch.rs`.\n-\n-#### Matching\n-\n-The subroutines that decide whether a particular impl/where-clause/etc\n-applies to a particular obligation. At the moment, this amounts to\n-unifying the self types, but in the future we may also recursively\n-consider some of the nested obligations, in the case of an impl.\n-\n-#### Lifetimes and selection\n-\n-Because of how that lifetime inference works, it is not possible to\n-give back immediate feedback as to whether a unification or subtype\n-relationship between lifetimes holds or not. Therefore, lifetime\n-matching is *not* considered during selection. This is reflected in\n-the fact that subregion assignment is infallible. This may yield\n-lifetime constraints that will later be found to be in error (in\n-contrast, the non-lifetime-constraints have already been checked\n-during selection and can never cause an error, though naturally they\n-may lead to other errors downstream).\n-\n-#### Where clauses\n-\n-Besides an impl, the other major way to resolve an obligation is via a\n-where clause. The selection process is always given a *parameter\n-environment* which contains a list of where clauses, which are\n-basically obligations that can assume are satisfiable. We will iterate\n-over that list and check whether our current obligation can be found\n-in that list, and if so it is considered satisfied. More precisely, we\n-want to check whether there is a where-clause obligation that is for\n-the same trait (or some subtrait) and for which the self types match,\n-using the definition of *matching* given above.\n-\n-Consider this simple example:\n-\n-```rust\n-trait A1 { /*...*/ }\n-trait A2 : A1 { /*...*/ }\n-\n-trait B { /*...*/ }\n-\n-fn foo<X:A2+B> { /*...*/ }\n-```\n-\n-Clearly we can use methods offered by `A1`, `A2`, or `B` within the\n-body of `foo`. In each case, that will incur an obligation like `X :\n-A1` or `X : A2`. The parameter environment will contain two\n-where-clauses, `X : A2` and `X : B`. For each obligation, then, we\n-search this list of where-clauses.  To resolve an obligation `X:A1`,\n-we would note that `X:A2` implies that `X:A1`.\n-\n-### Confirmation\n-\n-Confirmation unifies the output type parameters of the trait with the\n-values found in the obligation, possibly yielding a type error.  If we\n-return to our example of the `Convert` trait from the previous\n-section, confirmation is where an error would be reported, because the\n-impl specified that `T` would be `usize`, but the obligation reported\n-`char`. Hence the result of selection would be an error.\n-\n-### Selection during translation\n-\n-During type checking, we do not store the results of trait selection.\n-We simply wish to verify that trait selection will succeed. Then\n-later, at trans time, when we have all concrete types available, we\n-can repeat the trait selection.  In this case, we do not consider any\n-where-clauses to be in scope. We know that therefore each resolution\n-will resolve to a particular impl.\n-\n-One interesting twist has to do with nested obligations. In general, in trans,\n-we only need to do a \"shallow\" selection for an obligation. That is, we wish to\n-identify which impl applies, but we do not (yet) need to decide how to select\n-any nested obligations. Nonetheless, we *do* currently do a complete resolution,\n-and that is because it can sometimes inform the results of type inference. That is,\n-we do not have the full substitutions in terms of the type variables of the impl available\n-to us, so we must run trait selection to figure everything out.\n-\n-Here is an example:\n-\n-```rust\n-trait Foo { /*...*/ }\n-impl<U,T:Bar<U>> Foo for Vec<T> { /*...*/ }\n-\n-impl Bar<usize> for isize { /*...*/ }\n-```\n-\n-After one shallow round of selection for an obligation like `Vec<isize>\n-: Foo`, we would know which impl we want, and we would know that\n-`T=isize`, but we do not know the type of `U`.  We must select the\n-nested obligation `isize : Bar<U>` to find out that `U=usize`.\n-\n-It would be good to only do *just as much* nested resolution as\n-necessary. Currently, though, we just do a full resolution.\n-\n-# Higher-ranked trait bounds\n-\n-One of the more subtle concepts at work are *higher-ranked trait\n-bounds*. An example of such a bound is `for<'a> MyTrait<&'a isize>`.\n-Let's walk through how selection on higher-ranked trait references\n-works.\n-\n-## Basic matching and skolemization leaks\n-\n-Let's walk through the test `compile-fail/hrtb-just-for-static.rs` to see\n-how it works. The test starts with the trait `Foo`:\n-\n-```rust\n-trait Foo<X> {\n-    fn foo(&self, x: X) { }\n-}\n-```\n-\n-Let's say we have a function `want_hrtb` that wants a type which\n-implements `Foo<&'a isize>` for any `'a`:\n-\n-```rust\n-fn want_hrtb<T>() where T : for<'a> Foo<&'a isize> { ... }\n-```\n-\n-Now we have a struct `AnyInt` that implements `Foo<&'a isize>` for any\n-`'a`:\n-\n-```rust\n-struct AnyInt;\n-impl<'a> Foo<&'a isize> for AnyInt { }\n-```\n-\n-And the question is, does `AnyInt : for<'a> Foo<&'a isize>`? We want the\n-answer to be yes. The algorithm for figuring it out is closely related\n-to the subtyping for higher-ranked types (which is described in\n-`middle::infer::higher_ranked::doc`, but also in a [paper by SPJ] that\n-I recommend you read).\n-\n-1. Skolemize the obligation.\n-2. Match the impl against the skolemized obligation.\n-3. Check for skolemization leaks.\n-\n-[paper by SPJ]: http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n-\n-So let's work through our example. The first thing we would do is to\n-skolemize the obligation, yielding `AnyInt : Foo<&'0 isize>` (here `'0`\n-represents skolemized region #0). Note that now have no quantifiers;\n-in terms of the compiler type, this changes from a `ty::PolyTraitRef`\n-to a `TraitRef`. We would then create the `TraitRef` from the impl,\n-using fresh variables for it's bound regions (and thus getting\n-`Foo<&'$a isize>`, where `'$a` is the inference variable for `'a`). Next\n-we relate the two trait refs, yielding a graph with the constraint\n-that `'0 == '$a`. Finally, we check for skolemization \"leaks\" -- a\n-leak is basically any attempt to relate a skolemized region to another\n-skolemized region, or to any region that pre-existed the impl match.\n-The leak check is done by searching from the skolemized region to find\n-the set of regions that it is related to in any way. This is called\n-the \"taint\" set. To pass the check, that set must consist *solely* of\n-itself and region variables from the impl. If the taint set includes\n-any other region, then the match is a failure. In this case, the taint\n-set for `'0` is `{'0, '$a}`, and hence the check will succeed.\n-\n-Let's consider a failure case. Imagine we also have a struct\n-\n-```rust\n-struct StaticInt;\n-impl Foo<&'static isize> for StaticInt;\n-```\n-\n-We want the obligation `StaticInt : for<'a> Foo<&'a isize>` to be\n-considered unsatisfied. The check begins just as before. `'a` is\n-skolemized to `'0` and the impl trait reference is instantiated to\n-`Foo<&'static isize>`. When we relate those two, we get a constraint\n-like `'static == '0`. This means that the taint set for `'0` is `{'0,\n-'static}`, which fails the leak check.\n-\n-## Higher-ranked trait obligations\n-\n-Once the basic matching is done, we get to another interesting topic:\n-how to deal with impl obligations. I'll work through a simple example\n-here. Imagine we have the traits `Foo` and `Bar` and an associated impl:\n-\n-```rust\n-trait Foo<X> {\n-    fn foo(&self, x: X) { }\n-}\n-\n-trait Bar<X> {\n-    fn bar(&self, x: X) { }\n-}\n-\n-impl<X,F> Foo<X> for F\n-    where F : Bar<X>\n-{\n-}\n-```\n-\n-Now let's say we have a obligation `for<'a> Foo<&'a isize>` and we match\n-this impl. What obligation is generated as a result? We want to get\n-`for<'a> Bar<&'a isize>`, but how does that happen?\n-\n-After the matching, we are in a position where we have a skolemized\n-substitution like `X => &'0 isize`. If we apply this substitution to the\n-impl obligations, we get `F : Bar<&'0 isize>`. Obviously this is not\n-directly usable because the skolemized region `'0` cannot leak out of\n-our computation.\n-\n-What we do is to create an inverse mapping from the taint set of `'0`\n-back to the original bound region (`'a`, here) that `'0` resulted\n-from. (This is done in `higher_ranked::plug_leaks`). We know that the\n-leak check passed, so this taint set consists solely of the skolemized\n-region itself plus various intermediate region variables. We then walk\n-the trait-reference and convert every region in that taint set back to\n-a late-bound region, so in this case we'd wind up with `for<'a> F :\n-Bar<&'a isize>`.\n-\n-# Caching and subtle considerations therewith\n-\n-In general we attempt to cache the results of trait selection.  This\n-is a somewhat complex process. Part of the reason for this is that we\n-want to be able to cache results even when all the types in the trait\n-reference are not fully known. In that case, it may happen that the\n-trait selection process is also influencing type variables, so we have\n-to be able to not only cache the *result* of the selection process,\n-but *replay* its effects on the type variables.\n-\n-## An example\n-\n-The high-level idea of how the cache works is that we first replace\n-all unbound inference variables with skolemized versions. Therefore,\n-if we had a trait reference `usize : Foo<$1>`, where `$n` is an unbound\n-inference variable, we might replace it with `usize : Foo<%0>`, where\n-`%n` is a skolemized type. We would then look this up in the cache.\n-If we found a hit, the hit would tell us the immediate next step to\n-take in the selection process: i.e., apply impl #22, or apply where\n-clause `X : Foo<Y>`. Let's say in this case there is no hit.\n-Therefore, we search through impls and where clauses and so forth, and\n-we come to the conclusion that the only possible impl is this one,\n-with def-id 22:\n-\n-```rust\n-impl Foo<isize> for usize { ... } // Impl #22\n-```\n-\n-We would then record in the cache `usize : Foo<%0> ==>\n-ImplCandidate(22)`. Next we would confirm `ImplCandidate(22)`, which\n-would (as a side-effect) unify `$1` with `isize`.\n-\n-Now, at some later time, we might come along and see a `usize :\n-Foo<$3>`.  When skolemized, this would yield `usize : Foo<%0>`, just as\n-before, and hence the cache lookup would succeed, yielding\n-`ImplCandidate(22)`. We would confirm `ImplCandidate(22)` which would\n-(as a side-effect) unify `$3` with `isize`.\n-\n-## Where clauses and the local vs global cache\n-\n-One subtle interaction is that the results of trait lookup will vary\n-depending on what where clauses are in scope. Therefore, we actually\n-have *two* caches, a local and a global cache. The local cache is\n-attached to the `ParamEnv` and the global cache attached to the\n-`tcx`. We use the local cache whenever the result might depend on the\n-where clauses that are in scope. The determination of which cache to\n-use is done by the method `pick_candidate_cache` in `select.rs`. At\n-the moment, we use a very simple, conservative rule: if there are any\n-where-clauses in scope, then we use the local cache.  We used to try\n-and draw finer-grained distinctions, but that led to a serious of\n-annoying and weird bugs like #22019 and #18290. This simple rule seems\n-to be pretty clearly safe and also still retains a very high hit rate\n-(~95% when compiling rustc).\n-\n-# Specialization\n-\n-Defined in the `specialize` module.\n-\n-The basic strategy is to build up a *specialization graph* during\n-coherence checking. Insertion into the graph locates the right place\n-to put an impl in the specialization hierarchy; if there is no right\n-place (due to partial overlap but no containment), you get an overlap\n-error. Specialization is consulted when selecting an impl (of course),\n-and the graph is consulted when propagating defaults down the\n-specialization hierarchy.\n-\n-You might expect that the specialization graph would be used during\n-selection -- i.e., when actually performing specialization. This is\n-not done for two reasons:\n-\n-- It's merely an optimization: given a set of candidates that apply,\n-  we can determine the most specialized one by comparing them directly\n-  for specialization, rather than consulting the graph. Given that we\n-  also cache the results of selection, the benefit of this\n-  optimization is questionable.\n-\n-- To build the specialization graph in the first place, we need to use\n-  selection (because we need to determine whether one impl specializes\n-  another). Dealing with this reentrancy would require some additional\n-  mode switch for selection. Given that there seems to be no strong\n-  reason to use the graph anyway, we stick with a simpler approach in\n-  selection, and use the graph only for propagating default\n-  implementations.\n-\n-Trait impl selection can succeed even when multiple impls can apply,\n-as long as they are part of the same specialization family. In that\n-case, it returns a *single* impl on success -- this is the most\n-specialized impl *known* to apply. However, if there are any inference\n-variables in play, the returned impl may not be the actual impl we\n-will use at trans time. Thus, we take special care to avoid projecting\n-associated types unless either (1) the associated type does not use\n-`default` and thus cannot be overridden or (2) all input types are\n-known concretely."}, {"sha": "a9f1c8750f4be77f61c8e8d9c18e6bbff12d8764", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -8,7 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See `README.md` for high-level documentation\n+//! See rustc guide chapters on [trait-resolution] and [trait-specialization] for more info on how\n+//! this works.\n+//!\n+//! [trait-resolution]: https://rust-lang-nursery.github.io/rustc-guide/trait-resolution.html\n+//! [trait-specialization]: https://rust-lang-nursery.github.io/rustc-guide/trait-specialization.html\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use syntax_pos::DUMMY_SP;"}, {"sha": "c1ffc10c3c0f0f65e51b1904915c3d8b91c1e0e5", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Trait Resolution. See README.md for an overview of how this works.\n+//! Trait Resolution. See [rustc guide] for more info on how this works.\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-resolution.html\n \n pub use self::SelectionError::*;\n pub use self::FulfillmentErrorCode::*;"}, {"sha": "f21ec295c5f7b014d075f8feb3b1901c15e09014", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See `README.md` for high-level documentation\n+//! See [rustc guide] for more info on how this works.\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-resolution.html#selection\n \n use self::SelectionCandidate::*;\n use self::EvaluationResult::*;\n@@ -1045,8 +1047,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     //\n     // The selection process begins by examining all in-scope impls,\n     // caller obligations, and so forth and assembling a list of\n-    // candidates. See `README.md` and the `Candidate` type for more\n-    // details.\n+    // candidates. See [rustc guide] for more details.\n+    //\n+    // [rustc guide]:\n+    // https://rust-lang-nursery.github.io/rustc-guide/trait-resolution.html#candidate-assembly\n \n     fn candidate_from_obligation<'o>(&mut self,\n                                      stack: &TraitObligationStack<'o, 'tcx>)\n@@ -2333,7 +2337,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     //\n     // Confirmation unifies the output type parameters of the trait\n     // with the values found in the obligation, possibly yielding a\n-    // type error.  See `README.md` for more details.\n+    // type error.  See [rustc guide] for more details.\n+    //\n+    // [rustc guide]:\n+    // https://rust-lang-nursery.github.io/rustc-guide/trait-resolution.html#confirmation\n \n     fn confirm_candidate(&mut self,\n                          obligation: &TraitObligation<'tcx>,"}, {"sha": "72d9dd9012ca98f892ded68e8dff277c4304efef", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Logic and data structures related to impl specialization, explained in\n-// greater detail below.\n-//\n-// At the moment, this implementation support only the simple \"chain\" rule:\n-// If any two impls overlap, one must be a strict subset of the other.\n-//\n-// See traits/README.md for a bit more detail on how specialization\n-// fits together with the rest of the trait machinery.\n+//! Logic and data structures related to impl specialization, explained in\n+//! greater detail below.\n+//!\n+//! At the moment, this implementation support only the simple \"chain\" rule:\n+//! If any two impls overlap, one must be a strict subset of the other.\n+//!\n+//! See the [rustc guide] for a bit more detail on how specialization\n+//! fits together with the rest of the trait machinery.\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-specialization.html\n \n use super::{SelectionContext, FulfillmentContext};\n use super::util::impl_trait_ref_and_oblig;"}, {"sha": "3fd956ecfb87dea7f60567b9cf192103b7b5c8e2", "filename": "src/librustc/ty/README.md", "status": "removed", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Fty%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddab91a5debadfda47c057117c8b498a31abaae7/src%2Flibrustc%2Fty%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2FREADME.md?ref=ddab91a5debadfda47c057117c8b498a31abaae7", "patch": "@@ -1,165 +0,0 @@\n-# Types and the Type Context\n-\n-The `ty` module defines how the Rust compiler represents types\n-internally. It also defines the *typing context* (`tcx` or `TyCtxt`),\n-which is the central data structure in the compiler.\n-\n-## The tcx and how it uses lifetimes\n-\n-The `tcx` (\"typing context\") is the central data structure in the\n-compiler. It is the context that you use to perform all manner of\n-queries. The struct `TyCtxt` defines a reference to this shared context:\n-\n-```rust\n-tcx: TyCtxt<'a, 'gcx, 'tcx>\n-//          --  ----  ----\n-//          |   |     |\n-//          |   |     innermost arena lifetime (if any)\n-//          |   \"global arena\" lifetime\n-//          lifetime of this reference\n-```\n-\n-As you can see, the `TyCtxt` type takes three lifetime parameters.\n-These lifetimes are perhaps the most complex thing to understand about\n-the tcx. During Rust compilation, we allocate most of our memory in\n-**arenas**, which are basically pools of memory that get freed all at\n-once. When you see a reference with a lifetime like `'tcx` or `'gcx`,\n-you know that it refers to arena-allocated data (or data that lives as\n-long as the arenas, anyhow).\n-\n-We use two distinct levels of arenas. The outer level is the \"global\n-arena\". This arena lasts for the entire compilation: so anything you\n-allocate in there is only freed once compilation is basically over\n-(actually, when we shift to executing LLVM).\n-\n-To reduce peak memory usage, when we do type inference, we also use an\n-inner level of arena. These arenas get thrown away once type inference\n-is over. This is done because type inference generates a lot of\n-\"throw-away\" types that are not particularly interesting after type\n-inference completes, so keeping around those allocations would be\n-wasteful.\n-\n-Often, we wish to write code that explicitly asserts that it is not\n-taking place during inference. In that case, there is no \"local\"\n-arena, and all the types that you can access are allocated in the\n-global arena.  To express this, the idea is to use the same lifetime\n-for the `'gcx` and `'tcx` parameters of `TyCtxt`. Just to be a touch\n-confusing, we tend to use the name `'tcx` in such contexts. Here is an\n-example:\n-\n-```rust\n-fn not_in_inference<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    //                                        ----  ----\n-    //                                        Using the same lifetime here asserts\n-    //                                        that the innermost arena accessible through\n-    //                                        this reference *is* the global arena.\n-}\n-```\n-\n-In contrast, if we want to code that can be usable during type inference, then you\n-need to declare a distinct `'gcx` and `'tcx` lifetime parameter:\n-\n-```rust\n-fn maybe_in_inference<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) {\n-    //                                                ----  ----\n-    //                                        Using different lifetimes here means that\n-    //                                        the innermost arena *may* be distinct\n-    //                                        from the global arena (but doesn't have to be).\n-}\n-```\n-\n-### Allocating and working with types\n-\n-Rust types are represented using the `Ty<'tcx>` defined in the `ty`\n-module (not to be confused with the `Ty` struct from [the HIR]). This\n-is in fact a simple type alias for a reference with `'tcx` lifetime:\n-\n-```rust\n-pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n-```\n-\n-[the HIR]: ../hir/README.md\n-\n-You can basically ignore the `TyS` struct -- you will basically never\n-access it explicitly. We always pass it by reference using the\n-`Ty<'tcx>` alias -- the only exception I think is to define inherent\n-methods on types. Instances of `TyS` are only ever allocated in one of\n-the rustc arenas (never e.g. on the stack).\n-\n-One common operation on types is to **match** and see what kinds of\n-types they are. This is done by doing `match ty.sty`, sort of like this:\n-\n-```rust\n-fn test_type<'tcx>(ty: Ty<'tcx>) {\n-    match ty.sty {\n-        ty::TyArray(elem_ty, len) => { ... }\n-        ...\n-    }\n-}\n-```\n-\n-The `sty` field (the origin of this name is unclear to me; perhaps\n-structural type?) is of type `TypeVariants<'tcx>`, which is an enum\n-defining all of the different kinds of types in the compiler.\n-\n-> NB: inspecting the `sty` field on types during type inference can be\n-> risky, as there may be inference variables and other things to\n-> consider, or sometimes types are not yet known that will become\n-> known later.).\n-\n-To allocate a new type, you can use the various `mk_` methods defined\n-on the `tcx`. These have names that correpond mostly to the various kinds\n-of type variants. For example:\n-\n-```rust\n-let array_ty = tcx.mk_array(elem_ty, len * 2);\n-```\n-\n-These methods all return a `Ty<'tcx>` -- note that the lifetime you\n-get back is the lifetime of the innermost arena that this `tcx` has\n-access to. In fact, types are always canonicalized and interned (so we\n-never allocate exactly the same type twice) and are always allocated\n-in the outermost arena where they can be (so, if they do not contain\n-any inference variables or other \"temporary\" types, they will be\n-allocated in the global arena). However, the lifetime `'tcx` is always\n-a safe approximation, so that is what you get back.\n-\n-> NB. Because types are interned, it is possible to compare them for\n-> equality efficiently using `==` -- however, this is almost never what\n-> you want to do unless you happen to be hashing and looking for\n-> duplicates. This is because often in Rust there are multiple ways to\n-> represent the same type, particularly once inference is involved. If\n-> you are going to be testing for type equality, you probably need to\n-> start looking into the inference code to do it right.\n-\n-You can also find various common types in the `tcx` itself by accessing\n-`tcx.types.bool`, `tcx.types.char`, etc (see `CommonTypes` for more).\n-\n-### Beyond types: Other kinds of arena-allocated data structures\n-\n-In addition to types, there are a number of other arena-allocated data\n-structures that you can allocate, and which are found in this\n-module. Here are a few examples:\n-\n-- `Substs`, allocated with `mk_substs` -- this will intern a slice of types, often used to\n-  specify the values to be substituted for generics (e.g., `HashMap<i32, u32>`\n-  would be represented as a slice `&'tcx [tcx.types.i32, tcx.types.u32]`).\n-- `TraitRef`, typically passed by value -- a **trait reference**\n-  consists of a reference to a trait along with its various type\n-  parameters (including `Self`), like `i32: Display` (here, the def-id\n-  would reference the `Display` trait, and the substs would contain\n-  `i32`).\n-- `Predicate` defines something the trait system has to prove (see `traits` module).\n-\n-### Import conventions\n-\n-Although there is no hard and fast rule, the `ty` module tends to be used like so:\n-\n-```rust\n-use ty::{self, Ty, TyCtxt};\n-```\n-\n-In particular, since they are so common, the `Ty` and `TyCtxt` types\n-are imported directly. Other types are often referenced with an\n-explicit `ty::` prefix (e.g., `ty::TraitRef<'tcx>`). But some modules\n-choose to import a larger or smaller set of names explicitly."}, {"sha": "3613a34f66af6505f6552ef12b87ccf0c8c6cdd5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -779,9 +779,9 @@ impl<'tcx> CommonTypes<'tcx> {\n /// The central data structure of the compiler. It stores references\n /// to the various **arenas** and also houses the results of the\n /// various **compiler queries** that have been performed. See the\n-/// module-level [README] for more details.\n+/// [rustc guide] for more details.\n ///\n-/// [README]: https://github.com/rust-lang/rust/blob/master/src/librustc/ty/README.md\n+/// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/ty.html\n #[derive(Copy, Clone)]\n pub struct TyCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     gcx: &'a GlobalCtxt<'gcx>,"}, {"sha": "72173b62594e9658cd77fa4802f6d154d4ccd44d", "filename": "src/librustc_back/target/apple_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -46,6 +46,7 @@ pub fn opts() -> TargetOptions {\n         pre_link_args: LinkArgs::new(),\n         exe_allocation_crate: super::maybe_jemalloc(),\n         has_elf_tls: version >= (10, 7),\n+        abi_return_struct_as_int: true,\n         .. Default::default()\n     }\n }"}, {"sha": "291b22768998c556f3f98deb1a1fab37088f7463", "filename": "src/librustc_back/target/freebsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -36,6 +36,7 @@ pub fn opts() -> TargetOptions {\n         eliminate_frame_pointer: false, // FIXME 43575\n         relro_level: RelroLevel::Full,\n         exe_allocation_crate: super::maybe_jemalloc(),\n+        abi_return_struct_as_int: true,\n         .. Default::default()\n     }\n }"}, {"sha": "be69127d8f2ab5dec12179f3ce901a16381a9862", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -143,6 +143,7 @@ supported_targets! {\n     (\"mips64el-unknown-linux-gnuabi64\", mips64el_unknown_linux_gnuabi64),\n     (\"mipsel-unknown-linux-gnu\", mipsel_unknown_linux_gnu),\n     (\"powerpc-unknown-linux-gnu\", powerpc_unknown_linux_gnu),\n+    (\"powerpc-unknown-linux-gnuspe\", powerpc_unknown_linux_gnuspe),\n     (\"powerpc64-unknown-linux-gnu\", powerpc64_unknown_linux_gnu),\n     (\"powerpc64le-unknown-linux-gnu\", powerpc64le_unknown_linux_gnu),\n     (\"s390x-unknown-linux-gnu\", s390x_unknown_linux_gnu),\n@@ -345,9 +346,8 @@ pub struct TargetOptions {\n     pub staticlib_suffix: String,\n     /// OS family to use for conditional compilation. Valid options: \"unix\", \"windows\".\n     pub target_family: Option<String>,\n-    /// Whether the target toolchain is like OpenBSD's.\n-    /// Only useful for compiling against OpenBSD, for configuring abi when returning a struct.\n-    pub is_like_openbsd: bool,\n+    /// Whether the target toolchain's ABI supports returning small structs as an integer.\n+    pub abi_return_struct_as_int: bool,\n     /// Whether the target toolchain is like macOS's. Only useful for compiling against iOS/macOS,\n     /// in particular running dsymutil and some other stuff like `-dead_strip`. Defaults to false.\n     pub is_like_osx: bool,\n@@ -503,7 +503,7 @@ impl Default for TargetOptions {\n             staticlib_prefix: \"lib\".to_string(),\n             staticlib_suffix: \".a\".to_string(),\n             target_family: None,\n-            is_like_openbsd: false,\n+            abi_return_struct_as_int: false,\n             is_like_osx: false,\n             is_like_solaris: false,\n             is_like_windows: false,\n@@ -758,7 +758,7 @@ impl Target {\n         key!(staticlib_prefix);\n         key!(staticlib_suffix);\n         key!(target_family, optional);\n-        key!(is_like_openbsd, bool);\n+        key!(abi_return_struct_as_int, bool);\n         key!(is_like_osx, bool);\n         key!(is_like_solaris, bool);\n         key!(is_like_windows, bool);\n@@ -956,7 +956,7 @@ impl ToJson for Target {\n         target_option_val!(staticlib_prefix);\n         target_option_val!(staticlib_suffix);\n         target_option_val!(target_family);\n-        target_option_val!(is_like_openbsd);\n+        target_option_val!(abi_return_struct_as_int);\n         target_option_val!(is_like_osx);\n         target_option_val!(is_like_solaris);\n         target_option_val!(is_like_windows);"}, {"sha": "311e260ee3f34a113f0a5e005e679f6d499da36c", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -31,7 +31,7 @@ pub fn opts() -> TargetOptions {\n         target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n-        is_like_openbsd: true,\n+        abi_return_struct_as_int: true,\n         pre_link_args: args,\n         position_independent_executables: true,\n         eliminate_frame_pointer: false, // FIXME 43575"}, {"sha": "ffcc321749b5ad553f0e4025d3a057d521220d22", "filename": "src/librustc_back/target/powerpc_unknown_linux_gnuspe.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnuspe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnuspe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnuspe.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use LinkerFlavor;\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_base::opts();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-mspe\".to_string());\n+    base.max_atomic_width = Some(32);\n+\n+    // see #36994\n+    base.exe_allocation_crate = None;\n+\n+    Ok(Target {\n+        llvm_target: \"powerpc-unknown-linux-gnuspe\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-p:32:32-i64:64-n32\".to_string(),\n+        arch: \"powerpc\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "30038400f6c81ca13785d2aed11334f610e5902f", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -101,6 +101,7 @@ pub fn opts() -> TargetOptions {\n             \"rsend.o\".to_string()\n         ],\n         custom_unwind_resume: true,\n+        abi_return_struct_as_int: true,\n \n         .. Default::default()\n     }"}, {"sha": "e0bf36ee4077e392346cdc87a585f452862735eb", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -34,6 +34,7 @@ pub fn opts() -> TargetOptions {\n         pre_link_args: args,\n         crt_static_allows_dylibs: true,\n         crt_static_respected: true,\n+        abi_return_struct_as_int: true,\n \n         .. Default::default()\n     }"}, {"sha": "6af7a23f66d73919c344d4ea214ee9e07048f571", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 80, "deletions": 5, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -139,6 +139,19 @@ pub mod target_features {\n const BUG_REPORT_URL: &'static str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n                                       md#bug-reports\";\n \n+const ICE_REPORT_COMPILER_FLAGS: &'static [&'static str] = &[\n+    \"Z\",\n+    \"C\",\n+    \"crate-type\",\n+];\n+const ICE_REPORT_COMPILER_FLAGS_EXCLUDE: &'static [&'static str] = &[\n+    \"metadata\",\n+    \"extra-filename\",\n+];\n+const ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE: &'static [&'static str] = &[\n+    \"incremental\",\n+];\n+\n pub fn abort_on_err<T>(result: Result<T, CompileIncomplete>, sess: &Session) -> T {\n     match result {\n         Err(CompileIncomplete::Errored(ErrorReported)) => {\n@@ -1431,6 +1444,57 @@ pub fn in_rustc_thread<F, R>(f: F) -> Result<R, Box<Any + Send>>\n     thread.unwrap().join()\n }\n \n+/// Get a list of extra command-line flags provided by the user, as strings.\n+///\n+/// This function is used during ICEs to show more information useful for\n+/// debugging, since some ICEs only happens with non-default compiler flags\n+/// (and the users don't always report them).\n+fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n+    let mut args = Vec::new();\n+    for arg in env::args_os() {\n+        args.push(arg.to_string_lossy().to_string());\n+    }\n+\n+    let matches = if let Some(matches) = handle_options(&args) {\n+        matches\n+    } else {\n+        return None;\n+    };\n+\n+    let mut result = Vec::new();\n+    let mut excluded_cargo_defaults = false;\n+    for flag in ICE_REPORT_COMPILER_FLAGS {\n+        let prefix = if flag.len() == 1 { \"-\" } else { \"--\" };\n+\n+        for content in &matches.opt_strs(flag) {\n+            // Split always returns the first element\n+            let name = if let Some(first) = content.split('=').next() {\n+                first\n+            } else {\n+                &content\n+            };\n+\n+            let content = if ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.contains(&name) {\n+                name\n+            } else {\n+                content\n+            };\n+\n+            if !ICE_REPORT_COMPILER_FLAGS_EXCLUDE.contains(&name) {\n+                result.push(format!(\"{}{} {}\", prefix, flag, content));\n+            } else {\n+                excluded_cargo_defaults = true;\n+            }\n+        }\n+    }\n+\n+    if result.len() > 0 {\n+        Some((result, excluded_cargo_defaults))\n+    } else {\n+        None\n+    }\n+}\n+\n /// Run a procedure which will detect panics in the compiler and print nicer\n /// error messages rather than just failing the test.\n ///\n@@ -1462,11 +1526,22 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n                              errors::Level::Bug);\n             }\n \n-            let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n-                      format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL),\n-                      format!(\"rustc {} running on {}\",\n-                              option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n-                              config::host_triple())];\n+            let mut xs = vec![\n+                \"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n+                format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL),\n+                format!(\"rustc {} running on {}\",\n+                        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n+                        config::host_triple()),\n+            ];\n+\n+            if let Some((flags, excluded_cargo_defaults)) = extra_compiler_flags() {\n+                xs.push(format!(\"compiler flags: {}\", flags.join(\" \")));\n+\n+                if excluded_cargo_defaults {\n+                    xs.push(\"some of the compiler flags provided by cargo are hidden\".to_string());\n+                }\n+            }\n+\n             for note in &xs {\n                 handler.emit(&MultiSpan::new(),\n                              &note,"}, {"sha": "7c86f5a4b1a84fce0f87807b4745ba719715e4b6", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -118,10 +118,13 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n \n         match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => {\n+                let entry_def_id =\n+                    tcx.sess.entry_fn.borrow().map(|(id, _)| tcx.hir.local_def_id(id));\n                 // If this function isn't inlined or otherwise has explicit\n                 // linkage, then we'll be creating a globally shared version.\n                 if self.explicit_linkage(tcx).is_some() ||\n-                    !instance.def.requires_local(tcx)\n+                    !instance.def.requires_local(tcx) ||\n+                    Some(instance.def_id()) == entry_def_id\n                 {\n                     return InstantiationMode::GloballyShared  { may_conflict: false }\n                 }"}, {"sha": "8f308e726865cd938714c29592d6db61fce9b5a6", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -849,7 +849,19 @@ fn exec_linker(sess: &Session, cmd: &mut Command, tmpdir: &Path)\n         args.push_str(\"\\n\");\n     }\n     let file = tmpdir.join(\"linker-arguments\");\n-    fs::write(&file, args.as_bytes())?;\n+    let bytes = if sess.target.target.options.is_like_msvc {\n+        let mut out = vec![];\n+        // start the stream with a UTF-16 BOM\n+        for c in vec![0xFEFF].into_iter().chain(args.encode_utf16()) {\n+            // encode in little endian\n+            out.push(c as u8);\n+            out.push((c >> 8) as u8);\n+        }\n+        out\n+    } else {\n+        args.into_bytes()\n+    };\n+    fs::write(&file, &bytes)?;\n     cmd2.arg(format!(\"@{}\", file.display()));\n     return cmd2.output();\n "}, {"sha": "b14558448067cc9e67ac6a7a3919bfa12785a43f", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -52,8 +52,7 @@ pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             // http://www.angelcode.com/dev/callconv/callconv.html\n             // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n             let t = &cx.sess().target.target;\n-            if t.options.is_like_osx || t.options.is_like_windows\n-                || t.options.is_like_openbsd {\n+            if t.options.abi_return_struct_as_int {\n                 // According to Clang, everyone but MSVC returns single-element\n                 // float aggregates directly in a floating-point register.\n                 if !t.options.is_like_msvc && is_single_fp_element(cx, fty.ret.layout) {"}, {"sha": "00ac9d802457c5a294006c1c745e628105426051", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -87,7 +87,7 @@ const X86_WHITELIST: &'static [&'static str] = &[\"aes\", \"avx\", \"avx2\", \"avx512bw\n                                                  \"avx512cd\", \"avx512dq\", \"avx512er\",\n                                                  \"avx512f\", \"avx512ifma\", \"avx512pf\",\n                                                  \"avx512vbmi\", \"avx512vl\", \"avx512vpopcntdq\",\n-                                                 \"bmi\", \"bmi2\", \"fma\", \"fxsr\",\n+                                                 \"bmi1\", \"bmi2\", \"fma\", \"fxsr\",\n                                                  \"lzcnt\", \"mmx\", \"pclmulqdq\",\n                                                  \"popcnt\", \"rdrand\", \"rdseed\",\n                                                  \"sse\", \"sse2\", \"sse3\", \"sse4.1\",\n@@ -108,6 +108,7 @@ pub fn to_llvm_feature(s: &str) -> &str {\n     match s {\n         \"pclmulqdq\" => \"pclmul\",\n         \"rdrand\" => \"rdrnd\",\n+        \"bmi1\" => \"bmi\",\n         s => s,\n     }\n }"}, {"sha": "3654de6fb2ed2f585fb873f28f76cc5f0afbc2e0", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                 AdtKind::Struct => Def::Struct,\n                 AdtKind::Enum => Def::Enum,\n                 AdtKind::Union => Def::Union,\n-            },\n+            }\n             _ => panic!(\"Unexpected type {:?}\", def_id),\n         };\n "}, {"sha": "870b5383852b03c34e28f6989a22df14c55e7b46", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -3428,7 +3428,11 @@ fn build_deref_target_impls(cx: &DocContext,\n         let primitive = match *target {\n             ResolvedPath { did, .. } if did.is_local() => continue,\n             ResolvedPath { did, .. } => {\n-                ret.extend(inline::build_impls(cx, did, true));\n+                // We set the last parameter to false to avoid looking for auto-impls for traits\n+                // and therefore avoid an ICE.\n+                // The reason behind this is that auto-traits don't propagate through Deref so\n+                // we're not supposed to synthesise impls for them.\n+                ret.extend(inline::build_impls(cx, did, false));\n                 continue\n             }\n             _ => match target.primitive_type() {"}, {"sha": "960f2f198d8b089fe5f09f172798a146d6557c1c", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -96,14 +96,6 @@\n         }\n     }\n \n-    function onEach(arr, func) {\n-        if (arr && arr.length > 0 && func) {\n-            for (var i = 0; i < arr.length; i++) {\n-                func(arr[i]);\n-            }\n-        }\n-    }\n-\n     function isHidden(elem) {\n         return (elem.offsetParent === null)\n     }"}, {"sha": "b70dc37fdd55e69ab9370a190d772fd9b3f4f49b", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -1202,6 +1202,10 @@ kbd {\n \ttop: 19px;\n }\n \n+.theme-picker button {\n+\toutline: none;\n+}\n+\n #theme-picker {\n \tpadding: 4px;\n \twidth: 27px;"}, {"sha": "f21dfc8af92984410aec95bb76f2120b3808bd96", "filename": "src/librustdoc/html/static/storage.js", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -13,6 +13,18 @@\n var currentTheme = document.getElementById(\"themeStyle\");\n var mainTheme = document.getElementById(\"mainThemeStyle\");\n \n+var savedHref = [];\n+\n+function onEach(arr, func) {\n+    if (arr && arr.length > 0 && func) {\n+        for (var i = 0; i < arr.length; i++) {\n+            if (func(arr[i]) === true) {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n function updateLocalStorage(name, value) {\n     if (typeof(Storage) !== \"undefined\") {\n         localStorage[name] = value;\n@@ -29,8 +41,24 @@ function getCurrentValue(name) {\n }\n \n function switchTheme(styleElem, mainStyleElem, newTheme) {\n-    styleElem.href = mainStyleElem.href.replace(\"rustdoc.css\", newTheme + \".css\");\n-    updateLocalStorage('theme', newTheme);\n+    var newHref = mainStyleElem.href.replace(\"rustdoc.css\", newTheme + \".css\");\n+    var found = false;\n+\n+    if (savedHref.length === 0) {\n+        onEach(document.getElementsByTagName(\"link\"), function(el) {\n+            savedHref.push(el.href);\n+        });\n+    }\n+    onEach(savedHref, function(el) {\n+        if (el === newHref) {\n+            found = true;\n+            return true;\n+        }\n+    });\n+    if (found === true) {\n+        styleElem.href = newHref;\n+        updateLocalStorage('rustdoc-theme', newTheme);\n+    }\n }\n \n-switchTheme(currentTheme, mainTheme, getCurrentValue('theme') || 'main');\n+switchTheme(currentTheme, mainTheme, getCurrentValue('rustdoc-theme') || 'main');"}, {"sha": "e5fc33e241c896c653fc919cb7d55fb6d96a82f8", "filename": "src/libstd/process.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -1080,6 +1080,15 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+/// This is ridiculously unstable, as it's a completely-punted-upon part\n+/// of the `?`-in-`main` RFC.  It's here only to allow experimenting with\n+/// returning a code directly from main.  It will definitely change\n+/// drastically before being stabilized, if it doesn't just get deleted.\n+#[doc(hidden)]\n+#[derive(Clone, Copy, Debug)]\n+#[unstable(feature = \"process_exitcode_placeholder\", issue = \"43301\")]\n+pub struct ExitCode(pub i32);\n+\n impl Child {\n     /// Forces the child to exit. This is equivalent to sending a\n     /// SIGKILL on unix platforms.\n@@ -1428,7 +1437,7 @@ impl Termination for () {\n }\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n-impl<T: Termination, E: fmt::Debug> Termination for Result<T, E> {\n+impl<E: fmt::Debug> Termination for Result<(), E> {\n     fn report(self) -> i32 {\n         match self {\n             Ok(val) => val.report(),\n@@ -1442,20 +1451,23 @@ impl<T: Termination, E: fmt::Debug> Termination for Result<T, E> {\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n impl Termination for ! {\n-    fn report(self) -> i32 { unreachable!(); }\n+    fn report(self) -> i32 { self }\n }\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n-impl Termination for bool {\n+impl<E: fmt::Debug> Termination for Result<!, E> {\n     fn report(self) -> i32 {\n-        if self { exit::SUCCESS } else { exit::FAILURE }\n+        let Err(err) = self;\n+        eprintln!(\"Error: {:?}\", err);\n+        exit::FAILURE\n     }\n }\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n-impl Termination for i32 {\n+impl Termination for ExitCode {\n     fn report(self) -> i32 {\n-        self\n+        let ExitCode(code) = self;\n+        code\n     }\n }\n "}, {"sha": "a7df821f92d719bf18bdb312bd67e638346b7ebf", "filename": "src/test/run-make/atomic-lock-free/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frun-make%2Fatomic-lock-free%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frun-make%2Fatomic-lock-free%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fatomic-lock-free%2FMakefile?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -32,6 +32,8 @@ endif\n ifeq ($(filter powerpc,$(LLVM_COMPONENTS)),powerpc)\n \t$(RUSTC) --target=powerpc-unknown-linux-gnu atomic_lock_free.rs\n \tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | $(CGREP) -v __atomic_fetch_add\n+\t$(RUSTC) --target=powerpc-unknown-linux-gnuspe atomic_lock_free.rs\n+\tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | $(CGREP) -v __atomic_fetch_add\n \t$(RUSTC) --target=powerpc64-unknown-linux-gnu atomic_lock_free.rs\n \tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | $(CGREP) -v __atomic_fetch_add\n \t$(RUSTC) --target=powerpc64le-unknown-linux-gnu atomic_lock_free.rs"}, {"sha": "67d8ad0b67255bf25e7fc9ac58cf1c569d8616be", "filename": "src/test/run-make/long-linker-command-lines-cmd-exe/foo.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2Ffoo.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -36,8 +36,11 @@ fn main() {\n     let ok = tmpdir.join(\"ok\");\n     let not_ok = tmpdir.join(\"not_ok\");\n     if env::var(\"YOU_ARE_A_LINKER\").is_ok() {\n-        match env::args().find(|a| a.contains(\"@\")) {\n-            Some(file) => { fs::copy(&file[1..], &ok).unwrap(); }\n+        match env::args_os().find(|a| a.to_string_lossy().contains(\"@\")) {\n+            Some(file) => {\n+                let file = file.to_str().unwrap();\n+                fs::copy(&file[1..], &ok).unwrap();\n+            }\n             None => { File::create(&not_ok).unwrap(); }\n         }\n         return\n@@ -84,11 +87,23 @@ fn main() {\n             continue\n         }\n \n-        let mut contents = String::new();\n-        File::open(&ok).unwrap().read_to_string(&mut contents).unwrap();\n+        let mut contents = Vec::new();\n+        File::open(&ok).unwrap().read_to_end(&mut contents).unwrap();\n \n         for j in 0..i {\n-            assert!(contents.contains(&format!(\"{}{}\", lib_name, j)));\n+            let exp = format!(\"{}{}\", lib_name, j);\n+            let exp = if cfg!(target_env = \"msvc\") {\n+                let mut out = Vec::with_capacity(exp.len() * 2);\n+                for c in exp.encode_utf16() {\n+                    // encode in little endian\n+                    out.push(c as u8);\n+                    out.push((c >> 8) as u8);\n+                }\n+                out\n+            } else {\n+                exp.into_bytes()\n+            };\n+            assert!(contents.windows(exp.len()).any(|w| w == &exp[..]));\n         }\n \n         break"}, {"sha": "2ac240982afc4d5c4fe650f5dc3786de8313aec3", "filename": "src/test/run-make/long-linker-command-lines/foo.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frun-make%2Flong-linker-command-lines%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frun-make%2Flong-linker-command-lines%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flong-linker-command-lines%2Ffoo.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -27,7 +27,8 @@ fn main() {\n     let tmpdir = PathBuf::from(env::var_os(\"TMPDIR\").unwrap());\n     let ok = tmpdir.join(\"ok\");\n     if env::var(\"YOU_ARE_A_LINKER\").is_ok() {\n-        if let Some(file) = env::args().find(|a| a.contains(\"@\")) {\n+        if let Some(file) = env::args_os().find(|a| a.to_string_lossy().contains(\"@\")) {\n+            let file = file.to_str().expect(\"non-utf8 file argument\");\n             fs::copy(&file[1..], &ok).unwrap();\n         }\n         return\n@@ -76,11 +77,23 @@ fn main() {\n             continue\n         }\n \n-        let mut contents = String::new();\n-        File::open(&ok).unwrap().read_to_string(&mut contents).unwrap();\n+        let mut contents = Vec::new();\n+        File::open(&ok).unwrap().read_to_end(&mut contents).unwrap();\n \n         for j in 0..i {\n-            assert!(contents.contains(&format!(\"{}{}\", lib_name, j)));\n+            let exp = format!(\"{}{}\", lib_name, j);\n+            let exp = if cfg!(target_env = \"msvc\") {\n+                let mut out = Vec::with_capacity(exp.len() * 2);\n+                for c in exp.encode_utf16() {\n+                    // encode in little endian\n+                    out.push(c as u8);\n+                    out.push((c >> 8) as u8);\n+                }\n+                out\n+            } else {\n+                exp.into_bytes()\n+            };\n+            assert!(contents.windows(exp.len()).any(|w| w == &exp[..]));\n         }\n \n         break"}, {"sha": "1288c37d615cdeb08dc048eb39e1907ae981f73c", "filename": "src/test/run-pass/inlined-main.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frun-pass%2Finlined-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frun-pass%2Finlined-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finlined-main.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[inline(always)]\n+fn main() {}"}, {"sha": "30ecc4e89372b461736b14eec3301813092f726a", "filename": "src/test/run-pass/rfc-1937-termination-trait/termination-trait-for-exitcode.rs", "status": "renamed", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-exitcode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-exitcode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-exitcode.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -9,7 +9,10 @@\n // except according to those terms.\n \n #![feature(termination_trait)]\n+#![feature(process_exitcode_placeholder)]\n \n-fn main() -> i32 {\n-    0\n+use std::process::ExitCode;\n+\n+fn main() -> ExitCode {\n+    ExitCode(0)\n }", "previous_filename": "src/test/run-pass/rfc-1937-termination-trait/termination-trait-for-i32.rs"}, {"sha": "3cd6e7aa4b3d24c6297e38e29dc892038930888e", "filename": "src/test/rustdoc/auto-impl-for-trait.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frustdoc%2Fauto-impl-for-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftest%2Frustdoc%2Fauto-impl-for-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauto-impl-for-trait.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for https://github.com/rust-lang/rust/issues/48463 issue.\n+\n+use std::any::Any;\n+use std::ops::Deref;\n+\n+pub struct AnyValue {\n+    val: Box<Any>,\n+}\n+\n+impl Deref for AnyValue {\n+    type Target = Any;\n+\n+    fn deref(&self) -> &Any {\n+        &*self.val\n+    }\n+}"}, {"sha": "49b054f8b9e504c1cddc00dacde3cf5554dde7d3", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -83,6 +83,7 @@ static TARGETS: &'static [&'static str] = &[\n     \"mipsel-unknown-linux-gnu\",\n     \"mipsel-unknown-linux-musl\",\n     \"powerpc-unknown-linux-gnu\",\n+    \"powerpc-unknown-linux-gnuspe\",\n     \"powerpc64-unknown-linux-gnu\",\n     \"powerpc64le-unknown-linux-gnu\",\n     \"s390x-unknown-linux-gnu\","}, {"sha": "304143eaa0bfffcd32ea7c10e1303791786a9ca1", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -736,17 +736,12 @@ fn analyze_gdb(gdb: Option<String>) -> (Option<String>, Option<u32>, bool) {\n         Some(ref s) => s,\n     };\n \n-    let version_line = Command::new(gdb)\n-        .arg(\"--version\")\n-        .output()\n-        .map(|output| {\n-            String::from_utf8_lossy(&output.stdout)\n-                .lines()\n-                .next()\n-                .unwrap()\n-                .to_string()\n-        })\n-        .ok();\n+    let mut version_line = None;\n+    if let Ok(output) = Command::new(gdb).arg(\"--version\").output() {\n+        if let Some(first_line) = String::from_utf8_lossy(&output.stdout).lines().next() {\n+            version_line = Some(first_line.to_string());\n+        }\n+    }\n \n     let version = match version_line {\n         Some(line) => extract_gdb_version(&line),"}]}