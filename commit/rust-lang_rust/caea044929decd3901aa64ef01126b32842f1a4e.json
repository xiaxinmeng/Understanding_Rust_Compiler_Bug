{"sha": "caea044929decd3901aa64ef01126b32842f1a4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZWEwNDQ5MjlkZWNkMzkwMWFhNjRlZjAxMTI2YjMyODQyZjFhNGU=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-03-03T23:03:25Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-04-03T12:48:07Z"}, "message": "Move a big attribute fn into trans::attributes", "tree": {"sha": "b2a4a32857bb8aeea97d39c19b3b1c5a8bf83db7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2a4a32857bb8aeea97d39c19b3b1c5a8bf83db7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caea044929decd3901aa64ef01126b32842f1a4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caea044929decd3901aa64ef01126b32842f1a4e", "html_url": "https://github.com/rust-lang/rust/commit/caea044929decd3901aa64ef01126b32842f1a4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caea044929decd3901aa64ef01126b32842f1a4e/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "deb097a1d252d3681d790db56cd44080bb34a6bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/deb097a1d252d3681d790db56cd44080bb34a6bd", "html_url": "https://github.com/rust-lang/rust/commit/deb097a1d252d3681d790db56cd44080bb34a6bd"}], "stats": {"total": 394, "additions": 199, "deletions": 195}, "files": [{"sha": "a8e9ef98d71d98f0bedc00b3c31687f81723563b", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 184, "deletions": 9, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/caea044929decd3901aa64ef01126b32842f1a4e/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caea044929decd3901aa64ef01126b32842f1a4e/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=caea044929decd3901aa64ef01126b32842f1a4e", "patch": "@@ -9,13 +9,17 @@\n // except according to those terms.\n //! Set and unset common attributes on LLVM values.\n \n+use libc::{c_uint, c_ulonglong};\n use llvm::{self, ValueRef, AttrHelper};\n+use middle::ty::{self, ClosureTyper};\n+use syntax::abi;\n use syntax::ast;\n-use syntax::attr::InlineAttr;\n-pub use syntax::attr::InlineAttr::*;\n+pub use syntax::attr::InlineAttr;\n+use trans::base;\n+use trans::common;\n use trans::context::CrateContext;\n-\n-use libc::{c_uint, c_ulonglong};\n+use trans::machine;\n+use trans::type_of;\n \n /// Mark LLVM function to use split stack.\n #[inline]\n@@ -33,11 +37,12 @@ pub fn split_stack(val: ValueRef, set: bool) {\n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n pub fn inline(val: ValueRef, inline: InlineAttr) {\n+    use self::InlineAttr::*;\n     match inline {\n-        InlineHint   => llvm::SetFunctionAttribute(val, llvm::InlineHintAttribute),\n-        InlineAlways => llvm::SetFunctionAttribute(val, llvm::AlwaysInlineAttribute),\n-        InlineNever  => llvm::SetFunctionAttribute(val, llvm::NoInlineAttribute),\n-        InlineNone   => {\n+        Hint   => llvm::SetFunctionAttribute(val, llvm::InlineHintAttribute),\n+        Always => llvm::SetFunctionAttribute(val, llvm::AlwaysInlineAttribute),\n+        Never  => llvm::SetFunctionAttribute(val, llvm::NoInlineAttribute),\n+        None   => {\n             let attr = llvm::InlineHintAttribute |\n                        llvm::AlwaysInlineAttribute |\n                        llvm::NoInlineAttribute;\n@@ -88,7 +93,7 @@ pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n \n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n-pub fn convert_fn_attrs_to_llvm(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRef) {\n+pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRef) {\n     use syntax::attr::*;\n     inline(llfn, find_inline_attr(Some(ccx.sess().diagnostic()), attrs));\n \n@@ -106,3 +111,173 @@ pub fn convert_fn_attrs_to_llvm(ccx: &CrateContext, attrs: &[ast::Attribute], ll\n         }\n     }\n }\n+\n+/// Composite function which converts function type into LLVM attributes for the function.\n+pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx>)\n+                              -> llvm::AttrBuilder {\n+    use middle::ty::{BrAnon, ReLateBound};\n+\n+    let function_type;\n+    let (fn_sig, abi, env_ty) = match fn_type.sty {\n+        ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, None),\n+        ty::ty_closure(closure_did, substs) => {\n+            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n+            function_type = typer.closure_type(closure_did, substs);\n+            let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n+            (&function_type.sig, abi::RustCall, Some(self_type))\n+        }\n+        _ => ccx.sess().bug(\"expected closure or function.\")\n+    };\n+\n+    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n+\n+    let mut attrs = llvm::AttrBuilder::new();\n+    let ret_ty = fn_sig.output;\n+\n+    // These have an odd calling convention, so we need to manually\n+    // unpack the input ty's\n+    let input_tys = match fn_type.sty {\n+        ty::ty_closure(..) => {\n+            assert!(abi == abi::RustCall);\n+\n+            match fn_sig.inputs[0].sty {\n+                ty::ty_tup(ref inputs) => {\n+                    let mut full_inputs = vec![env_ty.expect(\"Missing closure environment\")];\n+                    full_inputs.push_all(inputs);\n+                    full_inputs\n+                }\n+                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n+            }\n+        },\n+        ty::ty_bare_fn(..) if abi == abi::RustCall => {\n+            let mut inputs = vec![fn_sig.inputs[0]];\n+\n+            match fn_sig.inputs[1].sty {\n+                ty::ty_tup(ref t_in) => {\n+                    inputs.push_all(&t_in[..]);\n+                    inputs\n+                }\n+                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n+            }\n+        }\n+        _ => fn_sig.inputs.clone()\n+    };\n+\n+    // Index 0 is the return value of the llvm func, so we start at 1\n+    let mut first_arg_offset = 1;\n+    if let ty::FnConverging(ret_ty) = ret_ty {\n+        // A function pointer is called without the declaration\n+        // available, so we have to apply any attributes with ABI\n+        // implications directly to the call instruction. Right now,\n+        // the only attribute we need to worry about is `sret`.\n+        if type_of::return_uses_outptr(ccx, ret_ty) {\n+            let llret_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, ret_ty));\n+\n+            // The outptr can be noalias and nocapture because it's entirely\n+            // invisible to the program. We also know it's nonnull as well\n+            // as how many bytes we can dereference\n+            attrs.arg(1, llvm::StructRetAttribute)\n+                 .arg(1, llvm::NoAliasAttribute)\n+                 .arg(1, llvm::NoCaptureAttribute)\n+                 .arg(1, llvm::DereferenceableAttribute(llret_sz));\n+\n+            // Add one more since there's an outptr\n+            first_arg_offset += 1;\n+        } else {\n+            // The `noalias` attribute on the return value is useful to a\n+            // function ptr caller.\n+            match ret_ty.sty {\n+                // `~` pointer return values never alias because ownership\n+                // is transferred\n+                ty::ty_uniq(it) if !common::type_is_sized(ccx.tcx(), it) => {}\n+                ty::ty_uniq(_) => {\n+                    attrs.ret(llvm::NoAliasAttribute);\n+                }\n+                _ => {}\n+            }\n+\n+            // We can also mark the return value as `dereferenceable` in certain cases\n+            match ret_ty.sty {\n+                // These are not really pointers but pairs, (pointer, len)\n+                ty::ty_uniq(it) |\n+                ty::ty_rptr(_, ty::mt { ty: it, .. }) if !common::type_is_sized(ccx.tcx(), it) => {}\n+                ty::ty_uniq(inner) | ty::ty_rptr(_, ty::mt { ty: inner, .. }) => {\n+                    let llret_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n+                    attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n+                }\n+                _ => {}\n+            }\n+\n+            if let ty::ty_bool = ret_ty.sty {\n+                attrs.ret(llvm::ZExtAttribute);\n+            }\n+        }\n+    }\n+\n+    for (idx, &t) in input_tys.iter().enumerate().map(|(i, v)| (i + first_arg_offset, v)) {\n+        match t.sty {\n+            // this needs to be first to prevent fat pointers from falling through\n+            _ if !common::type_is_immediate(ccx, t) => {\n+                let llarg_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, t));\n+\n+                // For non-immediate arguments the callee gets its own copy of\n+                // the value on the stack, so there are no aliases. It's also\n+                // program-invisible so can't possibly capture\n+                attrs.arg(idx, llvm::NoAliasAttribute)\n+                     .arg(idx, llvm::NoCaptureAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n+            }\n+\n+            ty::ty_bool => {\n+                attrs.arg(idx, llvm::ZExtAttribute);\n+            }\n+\n+            // `~` pointer parameters never alias because ownership is transferred\n+            ty::ty_uniq(inner) => {\n+                let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n+\n+                attrs.arg(idx, llvm::NoAliasAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n+            }\n+\n+            // `&mut` pointer parameters never alias other parameters, or mutable global data\n+            //\n+            // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as both\n+            // `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely on\n+            // memory dependencies rather than pointer equality\n+            ty::ty_rptr(b, mt) if mt.mutbl == ast::MutMutable ||\n+                                  !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n+\n+                let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n+                attrs.arg(idx, llvm::NoAliasAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n+\n+                if mt.mutbl == ast::MutImmutable {\n+                    attrs.arg(idx, llvm::ReadOnlyAttribute);\n+                }\n+\n+                if let ReLateBound(_, BrAnon(_)) = *b {\n+                    attrs.arg(idx, llvm::NoCaptureAttribute);\n+                }\n+            }\n+\n+            // When a reference in an argument has no named lifetime, it's impossible for that\n+            // reference to escape this function (returned or stored beyond the call by a closure).\n+            ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n+                let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n+                attrs.arg(idx, llvm::NoCaptureAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n+            }\n+\n+            // & pointer parameters are also never null and we know exactly how\n+            // many bytes we can dereference\n+            ty::ty_rptr(_, mt) => {\n+                let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n+                attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    attrs\n+}"}, {"sha": "a1fa4e77a131bb02935ac8231849e39c56e026a1", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 178, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/caea044929decd3901aa64ef01126b32842f1a4e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caea044929decd3901aa64ef01126b32842f1a4e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=caea044929decd3901aa64ef01126b32842f1a4e", "patch": "@@ -227,7 +227,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n     let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n-    attributes::convert_fn_attrs_to_llvm(ccx, &attrs[..], f);\n+    attributes::from_fn_attrs(ccx, &attrs[..], f);\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n     f\n@@ -770,7 +770,7 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 _ => {\n                     let llfn = foreign::register_foreign_item_fn(ccx, fn_ty.abi, t, &name[..]);\n                     let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n-                    attributes::convert_fn_attrs_to_llvm(ccx, &attrs, llfn);\n+                    attributes::from_fn_attrs(ccx, &attrs, llfn);\n                     llfn\n                 }\n             }\n@@ -792,7 +792,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return (C_null(Type::i8(bcx.ccx())), bcx);\n     }\n \n-    let attributes = get_fn_llvm_attributes(bcx.ccx(), fn_ty);\n+    let attributes = attributes::from_fn_type(bcx.ccx(), fn_ty);\n \n     match bcx.opt_node_id {\n         None => {\n@@ -2226,176 +2226,6 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     llfn\n }\n \n-pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>)\n-                                        -> llvm::AttrBuilder\n-{\n-    use middle::ty::{BrAnon, ReLateBound};\n-\n-    let function_type;\n-    let (fn_sig, abi, env_ty) = match fn_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, None),\n-        ty::ty_closure(closure_did, substs) => {\n-            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n-            function_type = typer.closure_type(closure_did, substs);\n-            let self_type = self_type_for_closure(ccx, closure_did, fn_ty);\n-            (&function_type.sig, RustCall, Some(self_type))\n-        }\n-        _ => ccx.sess().bug(\"expected closure or function.\")\n-    };\n-\n-    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n-\n-    let mut attrs = llvm::AttrBuilder::new();\n-    let ret_ty = fn_sig.output;\n-\n-    // These have an odd calling convention, so we need to manually\n-    // unpack the input ty's\n-    let input_tys = match fn_ty.sty {\n-        ty::ty_closure(..) => {\n-            assert!(abi == RustCall);\n-\n-            match fn_sig.inputs[0].sty {\n-                ty::ty_tup(ref inputs) => {\n-                    let mut full_inputs = vec![env_ty.expect(\"Missing closure environment\")];\n-                    full_inputs.push_all(inputs);\n-                    full_inputs\n-                }\n-                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n-            }\n-        },\n-        ty::ty_bare_fn(..) if abi == RustCall => {\n-            let mut inputs = vec![fn_sig.inputs[0]];\n-\n-            match fn_sig.inputs[1].sty {\n-                ty::ty_tup(ref t_in) => {\n-                    inputs.push_all(&t_in[..]);\n-                    inputs\n-                }\n-                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n-            }\n-        }\n-        _ => fn_sig.inputs.clone()\n-    };\n-\n-    // Index 0 is the return value of the llvm func, so we start at 1\n-    let mut first_arg_offset = 1;\n-    if let ty::FnConverging(ret_ty) = ret_ty {\n-        // A function pointer is called without the declaration\n-        // available, so we have to apply any attributes with ABI\n-        // implications directly to the call instruction. Right now,\n-        // the only attribute we need to worry about is `sret`.\n-        if type_of::return_uses_outptr(ccx, ret_ty) {\n-            let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, ret_ty));\n-\n-            // The outptr can be noalias and nocapture because it's entirely\n-            // invisible to the program. We also know it's nonnull as well\n-            // as how many bytes we can dereference\n-            attrs.arg(1, llvm::StructRetAttribute)\n-                 .arg(1, llvm::NoAliasAttribute)\n-                 .arg(1, llvm::NoCaptureAttribute)\n-                 .arg(1, llvm::DereferenceableAttribute(llret_sz));\n-\n-            // Add one more since there's an outptr\n-            first_arg_offset += 1;\n-        } else {\n-            // The `noalias` attribute on the return value is useful to a\n-            // function ptr caller.\n-            match ret_ty.sty {\n-                // `~` pointer return values never alias because ownership\n-                // is transferred\n-                ty::ty_uniq(it) if !common::type_is_sized(ccx.tcx(), it) => {}\n-                ty::ty_uniq(_) => {\n-                    attrs.ret(llvm::NoAliasAttribute);\n-                }\n-                _ => {}\n-            }\n-\n-            // We can also mark the return value as `dereferenceable` in certain cases\n-            match ret_ty.sty {\n-                // These are not really pointers but pairs, (pointer, len)\n-                ty::ty_uniq(it) |\n-                ty::ty_rptr(_, ty::mt { ty: it, .. }) if !common::type_is_sized(ccx.tcx(), it) => {}\n-                ty::ty_uniq(inner) | ty::ty_rptr(_, ty::mt { ty: inner, .. }) => {\n-                    let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-                    attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n-                }\n-                _ => {}\n-            }\n-\n-            if let ty::ty_bool = ret_ty.sty {\n-                attrs.ret(llvm::ZExtAttribute);\n-            }\n-        }\n-    }\n-\n-    for (idx, &t) in input_tys.iter().enumerate().map(|(i, v)| (i + first_arg_offset, v)) {\n-        match t.sty {\n-            // this needs to be first to prevent fat pointers from falling through\n-            _ if !type_is_immediate(ccx, t) => {\n-                let llarg_sz = llsize_of_real(ccx, type_of::type_of(ccx, t));\n-\n-                // For non-immediate arguments the callee gets its own copy of\n-                // the value on the stack, so there are no aliases. It's also\n-                // program-invisible so can't possibly capture\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n-                     .arg(idx, llvm::NoCaptureAttribute)\n-                     .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n-            }\n-\n-            ty::ty_bool => {\n-                attrs.arg(idx, llvm::ZExtAttribute);\n-            }\n-\n-            // `~` pointer parameters never alias because ownership is transferred\n-            ty::ty_uniq(inner) => {\n-                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n-                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n-            }\n-\n-            // `&mut` pointer parameters never alias other parameters, or mutable global data\n-            //\n-            // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as both\n-            // `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely on\n-            // memory dependencies rather than pointer equality\n-            ty::ty_rptr(b, mt) if mt.mutbl == ast::MutMutable ||\n-                                  !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n-\n-                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n-                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n-\n-                if mt.mutbl == ast::MutImmutable {\n-                    attrs.arg(idx, llvm::ReadOnlyAttribute);\n-                }\n-\n-                if let ReLateBound(_, BrAnon(_)) = *b {\n-                    attrs.arg(idx, llvm::NoCaptureAttribute);\n-                }\n-            }\n-\n-            // When a reference in an argument has no named lifetime, it's impossible for that\n-            // reference to escape this function (returned or stored beyond the call by a closure).\n-            ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n-                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::NoCaptureAttribute)\n-                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n-            }\n-\n-            // & pointer parameters are also never null and we know exactly how\n-            // many bytes we can dereference\n-            ty::ty_rptr(_, mt) => {\n-                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n-            }\n-            _ => ()\n-        }\n-    }\n-\n-    attrs\n-}\n-\n // only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n pub fn register_fn_llvmty(ccx: &CrateContext,\n                           sp: Span,\n@@ -2605,7 +2435,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                    sym,\n                                                                    i.id)\n                     };\n-                    attributes::convert_fn_attrs_to_llvm(ccx, &i.attrs, llfn);\n+                    attributes::from_fn_attrs(ccx, &i.attrs, llfn);\n                     llfn\n                 }\n \n@@ -2666,7 +2496,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n                     let llfn = foreign::register_foreign_item_fn(ccx, abi, ty, &name);\n-                    attributes::convert_fn_attrs_to_llvm(ccx, &ni.attrs, llfn);\n+                    attributes::from_fn_attrs(ccx, &ni.attrs, llfn);\n                     llfn\n                 }\n                 ast::ForeignItemStatic(..) => {\n@@ -2698,7 +2528,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n                 _ => ccx.sess().bug(\"NodeVariant, shouldn't happen\")\n             };\n-            attributes::inline(llfn, attributes::InlineHint);\n+            attributes::inline(llfn, attributes::InlineAttr::Hint);\n             llfn\n         }\n \n@@ -2720,7 +2550,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                     &struct_item.attrs);\n             let llfn = register_fn(ccx, struct_item.span,\n                                    sym, ctor_id, ty);\n-            attributes::inline(llfn, attributes::InlineHint);\n+            attributes::inline(llfn, attributes::InlineAttr::Hint);\n             llfn\n         }\n \n@@ -2755,7 +2585,7 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n         } else {\n             foreign::register_rust_fn_with_foreign_abi(ccx, span, sym, id)\n         };\n-        attributes::convert_fn_attrs_to_llvm(ccx, &attrs, llfn);\n+        attributes::from_fn_attrs(ccx, &attrs, llfn);\n         return llfn;\n     } else {\n         ccx.sess().span_bug(span, \"expected bare rust function\");"}, {"sha": "c343d705e866f029b3e3868cf9981dcfcdd1f120", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caea044929decd3901aa64ef01126b32842f1a4e/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caea044929decd3901aa64ef01126b32842f1a4e/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=caea044929decd3901aa64ef01126b32842f1a4e", "patch": "@@ -165,7 +165,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n     let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[..]);\n \n     // set an inline hint for all closures\n-    attributes::inline(llfn, attributes::InlineHint);\n+    attributes::inline(llfn, attributes::InlineAttr::Hint);\n \n     debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n             closure {:?} (type {})\","}, {"sha": "20da3c1c9f89518ebfb31bdbccc4ef70486fbe88", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/caea044929decd3901aa64ef01126b32842f1a4e/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caea044929decd3901aa64ef01126b32842f1a4e/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=caea044929decd3901aa64ef01126b32842f1a4e", "patch": "@@ -209,7 +209,6 @@ pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let llfn = get_extern_fn(ccx, &mut *ccx.externs().borrow_mut(), name, cc, llfn_ty, fty);\n     add_argument_attributes(&tys, llfn);\n-\n     llfn\n }\n \n@@ -484,7 +483,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                     }\n \n                     let llfn = register_foreign_item_fn(ccx, abi, ty, &lname);\n-                    base::set_llvm_fn_attrs(ccx, &foreign_item.attrs, llfn);\n+                    attributes::from_fn_attrs(ccx, &foreign_item.attrs, llfn);\n                     // Unlike for other items, we shouldn't call\n                     // `base::update_linkage` here.  Foreign items have\n                     // special linkage requirements, which are handled\n@@ -625,7 +624,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                id, t.repr(tcx));\n \n         let llfn = base::decl_internal_rust_fn(ccx, t, &ps[..]);\n-        attributes::convert_fn_attrs_to_llvm(ccx, attrs, llfn);\n+        attributes::from_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn\n     }\n@@ -818,7 +817,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Perform the call itself\n         debug!(\"calling llrustfn = {}, t = {}\",\n                ccx.tn().val_to_string(llrustfn), t.repr(ccx.tcx()));\n-        let attributes = base::get_fn_llvm_attributes(ccx, t);\n+        let attributes = attributes::from_fn_type(ccx, t);\n         let llrust_ret_val = builder.call(llrustfn, &llrust_args, Some(attributes));\n \n         // Get the return value where the foreign fn expects it."}, {"sha": "862eb31303e4fa9eda58493877e94dc44763a9c3", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/caea044929decd3901aa64ef01126b32842f1a4e/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caea044929decd3901aa64ef01126b32842f1a4e/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=caea044929decd3901aa64ef01126b32842f1a4e", "patch": "@@ -151,7 +151,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     };\n     let setup_lldecl = |lldecl, attrs: &[ast::Attribute]| {\n         base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n-        attributes::convert_fn_attrs_to_llvm(ccx, attrs, lldecl);\n+        attributes::from_fn_attrs(ccx, attrs, lldecl);\n \n         let is_first = !ccx.available_monomorphizations().borrow().contains(&s);\n         if is_first {\n@@ -200,7 +200,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n             let this_tv = tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl(abi::Rust);\n-            attributes::inline(d, attributes::InlineHint);\n+            attributes::inline(d, attributes::InlineAttr::Hint);\n             match v.node.kind {\n                 ast::TupleVariantKind(ref args) => {\n                     trans_enum_variant(ccx,\n@@ -259,7 +259,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n-            attributes::inline(d, attributes::InlineHint);\n+            attributes::inline(d, attributes::InlineAttr::Hint);\n             base::trans_tuple_struct(ccx,\n                                      &struct_def.fields,\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\"}]}