{"sha": "ddb015a09e9512a035b5c2017feb65d8b9a44bd8", "node_id": "C_kwDOAAsO6NoAKGRkYjAxNWEwOWU5NTEyYTAzNWI1YzIwMTdmZWI2NWQ4YjlhNDRiZDg", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2021-12-16T03:06:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-16T03:06:16Z"}, "message": "Fix discarded in-out constraint in inline asm (#110)\n\nFixes #109", "tree": {"sha": "2d3aa78cbd030fc16bc74b99f9bd99b5c9c44131", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d3aa78cbd030fc16bc74b99f9bd99b5c9c44131"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddb015a09e9512a035b5c2017feb65d8b9a44bd8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhuq0oCRBK7hj4Ov3rIwAAx4kIALAn/F/v+f5b/4BqzWS30K8T\nzkAQ+xCNFyTSMzzH+ux+AUAyIDBNaELXGoXcI1z+it6Yhsai70QfKCXoyyGbZaam\nKdlBxv0BWriDSJ4MDVKhEr4ikfPA+WTV9xBTZhKaQS1RdTUyNpT+m5bBbyKlWYKL\nMD8xWKD6jNoRFHWExnTgdrMHg4k54/0J999cpyeYVBjbRO8NzsPCB9PmJsahALao\nyWKLcI6RW7ryIv2vZUGsnKXFdPDB5oKS5FhvHOTe9Un4lks0u7lyVLS3HbSsYgNA\nc6E4T5LeR4D8d9eBprqlRXokxZ4lvygfC8NzWiGS43qp1JXZJkRWofh7UgtBFEM=\n=kIrQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 2d3aa78cbd030fc16bc74b99f9bd99b5c9c44131\nparent ebe6f6785c5f3ba6c2a18876829774bc215476f5\nauthor antoyo <antoyo@users.noreply.github.com> 1639623976 -0500\ncommitter GitHub <noreply@github.com> 1639623976 -0500\n\nFix discarded in-out constraint in inline asm (#110)\n\nFixes #109"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddb015a09e9512a035b5c2017feb65d8b9a44bd8", "html_url": "https://github.com/rust-lang/rust/commit/ddb015a09e9512a035b5c2017feb65d8b9a44bd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddb015a09e9512a035b5c2017feb65d8b9a44bd8/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebe6f6785c5f3ba6c2a18876829774bc215476f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe6f6785c5f3ba6c2a18876829774bc215476f5", "html_url": "https://github.com/rust-lang/rust/commit/ebe6f6785c5f3ba6c2a18876829774bc215476f5"}], "stats": {"total": 138, "additions": 73, "deletions": 65}, "files": [{"sha": "2d3cde7b69e44ff3590b9745be0a6be51a094a52", "filename": "src/asm.rs", "status": "modified", "additions": 51, "deletions": 60, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ddb015a09e9512a035b5c2017feb65d8b9a44bd8/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb015a09e9512a035b5c2017feb65d8b9a44bd8/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=ddb015a09e9512a035b5c2017feb65d8b9a44bd8", "patch": "@@ -18,30 +18,30 @@ use crate::type_of::LayoutGccExt;\n \n // Rust asm! and GCC Extended Asm semantics differ substantially.\n //\n-// 1. Rust asm operands go along as one list of operands. Operands themselves indicate \n-//    if they're \"in\" or \"out\". \"In\" and \"out\" operands can interleave. One operand can be \n+// 1. Rust asm operands go along as one list of operands. Operands themselves indicate\n+//    if they're \"in\" or \"out\". \"In\" and \"out\" operands can interleave. One operand can be\n //    both \"in\" and \"out\" (`inout(reg)`).\n //\n-//    GCC asm has two different lists for \"in\" and \"out\" operands. In terms of gccjit, \n-//    this means that all \"out\" operands must go before \"in\" operands. \"In\" and \"out\" operands \n+//    GCC asm has two different lists for \"in\" and \"out\" operands. In terms of gccjit,\n+//    this means that all \"out\" operands must go before \"in\" operands. \"In\" and \"out\" operands\n //    cannot interleave.\n //\n-// 2. Operand lists in both Rust and GCC are indexed. Index starts from 0. Indexes are important \n+// 2. Operand lists in both Rust and GCC are indexed. Index starts from 0. Indexes are important\n //    because the asm template refers to operands by index.\n //\n //    Mapping from Rust to GCC index would be 1-1 if it wasn't for...\n //\n-// 3. Clobbers. GCC has a separate list of clobbers, and clobbers don't have indexes. \n-//    Contrary, Rust expresses clobbers through \"out\" operands that aren't tied to \n+// 3. Clobbers. GCC has a separate list of clobbers, and clobbers don't have indexes.\n+//    Contrary, Rust expresses clobbers through \"out\" operands that aren't tied to\n //    a variable (`_`),  and such \"clobbers\" do have index.\n //\n-// 4. Furthermore, GCC Extended Asm does not support explicit register constraints \n-//    (like `out(\"eax\")`) directly, offering so-called \"local register variables\" \n-//    as a workaround. These variables need to be declared and initialized *before* \n-//    the Extended Asm block but *after* normal local variables \n+// 4. Furthermore, GCC Extended Asm does not support explicit register constraints\n+//    (like `out(\"eax\")`) directly, offering so-called \"local register variables\"\n+//    as a workaround. These variables need to be declared and initialized *before*\n+//    the Extended Asm block but *after* normal local variables\n //    (see comment in `codegen_inline_asm` for explanation).\n //\n-// With that in mind, let's see how we translate Rust syntax to GCC \n+// With that in mind, let's see how we translate Rust syntax to GCC\n // (from now on, `CC` stands for \"constraint code\"):\n //\n // * `out(reg_class) var`   -> translated to output operand: `\"=CC\"(var)`\n@@ -52,18 +52,17 @@ use crate::type_of::LayoutGccExt;\n //\n // * `out(\"explicit register\") _` -> not translated to any operands, register is simply added to clobbers list\n //\n-// * `inout(reg_class) in_var => out_var` -> translated to two operands: \n+// * `inout(reg_class) in_var => out_var` -> translated to two operands:\n //                              output: `\"=CC\"(in_var)`\n-//                              input:  `\"num\"(out_var)` where num is the GCC index \n+//                              input:  `\"num\"(out_var)` where num is the GCC index\n //                                       of the corresponding output operand\n //\n-// * `inout(reg_class) in_var => _` -> same as `inout(reg_class) in_var => tmp`, \n+// * `inout(reg_class) in_var => _` -> same as `inout(reg_class) in_var => tmp`,\n //                                      where \"tmp\" is a temporary unused variable\n //\n-// * `out/in/inout(\"explicit register\") var` -> translated to one or two operands as described above \n-//                                              with `\"r\"(var)` constraint, \n+// * `out/in/inout(\"explicit register\") var` -> translated to one or two operands as described above\n+//                                              with `\"r\"(var)` constraint,\n //                                              and one register variable assigned to the desired register.\n-// \n \n const ATT_SYNTAX_INS: &str = \".att_syntax noprefix\\n\\t\";\n const INTEL_SYNTAX_INS: &str = \"\\n\\t.intel_syntax noprefix\";\n@@ -124,7 +123,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let att_dialect = is_x86 && options.contains(InlineAsmOptions::ATT_SYNTAX);\n         let intel_dialect = is_x86 && !options.contains(InlineAsmOptions::ATT_SYNTAX);\n \n-        // GCC index of an output operand equals its position in the array \n+        // GCC index of an output operand equals its position in the array\n         let mut outputs = vec![];\n \n         // GCC index of an input operand equals its position in the array\n@@ -138,9 +137,9 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let mut constants_len = 0;\n \n         // There are rules we must adhere to if we want GCC to do the right thing:\n-        // \n+        //\n         // * Every local variable that the asm block uses as an output must be declared *before*\n-        //   the asm block. \n+        //   the asm block.\n         // * There must be no instructions whatsoever between the register variables and the asm.\n         //\n         // Therefore, the backend must generate the instructions strictly in this order:\n@@ -152,7 +151,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // We also must make sure that no input operands are emitted before output operands.\n         //\n         // This is why we work in passes, first emitting local vars, then local register vars.\n-        // Also, we don't emit any asm operands immediately; we save them to \n+        // Also, we don't emit any asm operands immediately; we save them to\n         // the one of the buffers to be emitted later.\n \n         // 1. Normal variables (and saving operands to buffers).\n@@ -165,7 +164,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx, false)),\n                         // When `reg` is a class and not an explicit register but the out place is not specified,\n                         // we need to create an unused output variable to assign the output to. This var\n-                        // needs to be of a type that's \"compatible\" with the register class, but specific type \n+                        // needs to be of a type that's \"compatible\" with the register class, but specific type\n                         // doesn't matter.\n                         (Constraint(constraint), None) => (constraint, dummy_output_type(self.cx, reg.reg_class())),\n                         (Register(_), Some(_)) => {\n@@ -193,7 +192,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n                     let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                     outputs.push(AsmOutOperand {\n-                        constraint, \n+                        constraint,\n                         rust_idx,\n                         late,\n                         readwrite: false,\n@@ -204,12 +203,12 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n                 InlineAsmOperandRef::In { reg, value } => {\n                     if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n-                        inputs.push(AsmInOperand { \n-                            constraint: Cow::Borrowed(constraint), \n-                            rust_idx, \n+                        inputs.push(AsmInOperand {\n+                            constraint: Cow::Borrowed(constraint),\n+                            rust_idx,\n                             val: value.immediate()\n                         });\n-                    } \n+                    }\n                     else {\n                         // left for the next pass\n                         continue\n@@ -219,7 +218,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n                     let constraint = if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n                         constraint\n-                    } \n+                    }\n                     else {\n                         // left for the next pass\n                         continue\n@@ -228,22 +227,22 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // Rustc frontend guarantees that input and output types are \"compatible\",\n                     // so we can just use input var's type for the output variable.\n                     //\n-                    // This decision is also backed by the fact that LLVM needs in and out \n-                    // values to be of *exactly the same type*, not just \"compatible\". \n+                    // This decision is also backed by the fact that LLVM needs in and out\n+                    // values to be of *exactly the same type*, not just \"compatible\".\n                     // I'm not sure if GCC is so picky too, but better safe than sorry.\n                     let ty = in_value.layout.gcc_type(self.cx, false);\n                     let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n \n                     // If the out_place is None (i.e `inout(reg) _` syntax was used), we translate\n-                    // it to one \"readwrite (+) output variable\", otherwise we translate it to two \n+                    // it to one \"readwrite (+) output variable\", otherwise we translate it to two\n                     // \"out and tied in\" vars as described above.\n                     let readwrite = out_place.is_none();\n                     outputs.push(AsmOutOperand {\n-                        constraint, \n+                        constraint,\n                         rust_idx,\n                         late,\n                         readwrite,\n-                        tmp_var, \n+                        tmp_var,\n                         out_place,\n                     });\n \n@@ -252,8 +251,8 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         let constraint = Cow::Owned(out_gcc_idx.to_string());\n \n                         inputs.push(AsmInOperand {\n-                            constraint, \n-                            rust_idx, \n+                            constraint,\n+                            rust_idx,\n                             val: in_value.immediate()\n                         });\n                     }\n@@ -280,7 +279,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n                         let out_place = if let Some(place) = place {\n                             place\n-                        } \n+                        }\n                         else {\n                             // processed in the previous pass\n                             continue\n@@ -291,7 +290,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         tmp_var.set_register_name(reg_name);\n \n                         outputs.push(AsmOutOperand {\n-                            constraint: \"r\".into(), \n+                            constraint: \"r\".into(),\n                             rust_idx,\n                             late,\n                             readwrite: false,\n@@ -311,9 +310,9 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         reg_var.set_register_name(reg_name);\n                         self.llbb().add_assignment(None, reg_var, value.immediate());\n \n-                        inputs.push(AsmInOperand { \n-                            constraint: \"r\".into(), \n-                            rust_idx, \n+                        inputs.push(AsmInOperand {\n+                            constraint: \"r\".into(),\n+                            rust_idx,\n                             val: reg_var.to_rvalue()\n                         });\n                     }\n@@ -324,31 +323,23 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 // `inout(\"explicit register\") in_var => out_var`\n                 InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n-                        let out_place = if let Some(place) = out_place {\n-                            place\n-                        } \n-                        else {\n-                            // processed in the previous pass\n-                            continue\n-                        };\n-\n                         // See explanation in the first pass.\n                         let ty = in_value.layout.gcc_type(self.cx, false);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n \n                         outputs.push(AsmOutOperand {\n-                            constraint: \"r\".into(), \n+                            constraint: \"r\".into(),\n                             rust_idx,\n                             late,\n                             readwrite: false,\n                             tmp_var,\n-                            out_place: Some(out_place)\n+                            out_place,\n                         });\n \n                         let constraint = Cow::Owned((outputs.len() - 1).to_string());\n-                        inputs.push(AsmInOperand { \n-                            constraint, \n+                        inputs.push(AsmInOperand {\n+                            constraint,\n                             rust_idx,\n                             val: in_value.immediate()\n                         });\n@@ -357,8 +348,8 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // processed in the previous pass\n                 }\n \n-                InlineAsmOperandRef::Const { .. } \n-                | InlineAsmOperandRef::SymFn { .. } \n+                InlineAsmOperandRef::Const { .. }\n+                | InlineAsmOperandRef::SymFn { .. }\n                 | InlineAsmOperandRef::SymStatic { .. } => {\n                     // processed in the previous pass\n                 }\n@@ -453,7 +444,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         if !intel_dialect {\n             template_str.push_str(INTEL_SYNTAX_INS);\n         }\n-        \n+\n         // 4. Generate Extended Asm block\n \n         let block = self.llbb();\n@@ -472,7 +463,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         }\n \n         if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n-            // TODO(@Commeownist): I'm not 100% sure this one clobber is sufficient \n+            // TODO(@Commeownist): I'm not 100% sure this one clobber is sufficient\n             // on all architectures. For instance, what about FP stack?\n             extended_asm.add_clobber(\"cc\");\n         }\n@@ -491,18 +482,18 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n             self.call(self.type_void(), builtin_unreachable, &[], None);\n         }\n \n-        // Write results to outputs. \n+        // Write results to outputs.\n         //\n         // We need to do this because:\n-        //  1. Turning `PlaceRef` into `RValue` is error-prone and has nasty edge cases \n+        //  1. Turning `PlaceRef` into `RValue` is error-prone and has nasty edge cases\n         //     (especially with current `rustc_backend_ssa` API).\n         //  2. Not every output operand has an `out_place`, and it's required by `add_output_operand`.\n         //\n         // Instead, we generate a temporary output variable for each output operand, and then this loop,\n         // generates `out_place = tmp_var;` assignments if out_place exists.\n         for op in &outputs {\n             if let Some(place) = op.out_place {\n-                OperandValue::Immediate(op.tmp_var.to_rvalue()).store(self, place);                \n+                OperandValue::Immediate(op.tmp_var.to_rvalue()).store(self, place);\n             }\n         }\n "}, {"sha": "254d946e52764502fa9215718990c3725194857e", "filename": "tests/run/asm.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ddb015a09e9512a035b5c2017feb65d8b9a44bd8/tests%2Frun%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb015a09e9512a035b5c2017feb65d8b9a44bd8/tests%2Frun%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fasm.rs?ref=ddb015a09e9512a035b5c2017feb65d8b9a44bd8", "patch": "@@ -17,6 +17,16 @@ extern \"C\" {\n     fn add_asm(a: i64, b: i64) -> i64;\n }\n \n+pub unsafe fn mem_cpy(dst: *mut u8, src: *const u8, len: usize) {\n+    asm!(\n+        \"rep movsb\",\n+        inout(\"rdi\") dst => _,\n+        inout(\"rsi\") src => _,\n+        inout(\"rcx\") len => _,\n+        options(preserves_flags, nostack)\n+    );\n+}\n+\n fn main() {\n     unsafe {\n         asm!(\"nop\");\n@@ -62,11 +72,11 @@ fn main() {\n     }\n     assert_eq!(x, 43);\n \n-    // check inout(reg_class) x \n+    // check inout(reg_class) x\n     let mut x: u64 = 42;\n     unsafe {\n         asm!(\"add {0}, {0}\",\n-            inout(reg) x \n+            inout(reg) x\n         );\n     }\n     assert_eq!(x, 84);\n@@ -75,7 +85,7 @@ fn main() {\n     let mut x: u64 = 42;\n     unsafe {\n         asm!(\"add r11, r11\",\n-            inout(\"r11\") x \n+            inout(\"r11\") x\n         );\n     }\n     assert_eq!(x, 84);\n@@ -98,12 +108,12 @@ fn main() {\n     assert_eq!(res, 7);\n     assert_eq!(rem, 2);\n \n-    // check const \n+    // check const\n     let mut x: u64 = 42;\n     unsafe {\n         asm!(\"add {}, {}\",\n             inout(reg) x,\n-            const 1 \n+            const 1\n         );\n     }\n     assert_eq!(x, 43);\n@@ -150,4 +160,11 @@ fn main() {\n     assert_eq!(x, 42);\n \n     assert_eq!(unsafe { add_asm(40, 2) }, 42);\n+\n+    let array1 = [1u8, 2, 3];\n+    let mut array2 = [0u8, 0, 0];\n+    unsafe {\n+        mem_cpy(array2.as_mut_ptr(), array1.as_ptr(), 3);\n+    }\n+    assert_eq!(array1, array2);\n }"}]}