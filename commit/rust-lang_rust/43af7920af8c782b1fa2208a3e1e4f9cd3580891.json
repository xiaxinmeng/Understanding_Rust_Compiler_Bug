{"sha": "43af7920af8c782b1fa2208a3e1e4f9cd3580891", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYWY3OTIwYWY4Yzc4MmIxZmEyMjA4YTNlMWU0ZjljZDM1ODA4OTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-13T11:19:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-13T11:19:16Z"}, "message": "Merge #9871\n\n9871: Jump to generated func r=mahdi-frms a=rylev\n\nWorked on this with `@yoshuawuyts.`\r\n\r\nWe thought we ran into an issue with the `generate_function` assist where the code was not being generated in a certain situations. However, it wasn't actually a bug just a very confusing implementation where the cursor is not moved to the newly generated function. This happened when the return type was successfully inferred (and not unit). The function would be generated, but selection would not be changed.\r\n\r\nThis can be very confusing: If the function is generated somewhat far from where the assist is being invoked, the user never sees that the code was generated (nor are they given the chance to actually implement the function body). \r\n\r\nThis PR makes it so that the cursor is _always_ moved to somewhere in the newly generated function. In addition, if we can infer unit as the type, then we do not still generate `-> ()` as the return type. Instead, we simply omit the return type.\r\n\r\nThis means the selection will move to either one of two places:\r\n* A generated `-> ()` return type when we cannot successfully infer the return type.\r\n* The `todo!()` body when we can successfully infer the return type.\n\nCo-authored-by: Ryan Levick <me@ryanlevick.com>", "tree": {"sha": "2e4ec8b13db055daf7d6bef0ae4b6b3021b1eb30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e4ec8b13db055daf7d6bef0ae4b6b3021b1eb30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43af7920af8c782b1fa2208a3e1e4f9cd3580891", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhFlU0CRBK7hj4Ov3rIwAAAfQIAGHNHo/0O8mu7DkXHPP3v94I\nw5I66fjra2lrQfsdlbeI7+orECI9xqKSXLt4tzuzkEKpJVBFG0icoCdvYcrDwTGh\nXR+EbsUisHssIjHb3jkRljhmAhKVgawqBbgxwERVbursx60AlGVVYyIBuq+FOUQP\ni2HkaDN1zSiCnept3JUAllBJlyKY2F2e97OBwRdHLweHZma8KLZZ5yOI6OMGlRuK\nKH1ZaO7N2nfJLeceFjBcWxc/PJQh0FgrJLJ+OJoxFDX/VbG2GAVy6hp/eRTDYcVv\n5cLibIYByKTFjTxcNG3/hxwkeCNJEREo2n+f5Waee/Yy3AwjpgyllsyzPloFCV4=\n=gYEN\n-----END PGP SIGNATURE-----\n", "payload": "tree 2e4ec8b13db055daf7d6bef0ae4b6b3021b1eb30\nparent c00ccdeb528bd5eacc30dfc89c937ebad8ef0c66\nparent 1cc43ab7f4a4e1c4d3400302566a5d6c86532d32\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628853556 +0000\ncommitter GitHub <noreply@github.com> 1628853556 +0000\n\nMerge #9871\n\n9871: Jump to generated func r=mahdi-frms a=rylev\n\nWorked on this with `@yoshuawuyts.`\r\n\r\nWe thought we ran into an issue with the `generate_function` assist where the code was not being generated in a certain situations. However, it wasn't actually a bug just a very confusing implementation where the cursor is not moved to the newly generated function. This happened when the return type was successfully inferred (and not unit). The function would be generated, but selection would not be changed.\r\n\r\nThis can be very confusing: If the function is generated somewhat far from where the assist is being invoked, the user never sees that the code was generated (nor are they given the chance to actually implement the function body). \r\n\r\nThis PR makes it so that the cursor is _always_ moved to somewhere in the newly generated function. In addition, if we can infer unit as the type, then we do not still generate `-> ()` as the return type. Instead, we simply omit the return type.\r\n\r\nThis means the selection will move to either one of two places:\r\n* A generated `-> ()` return type when we cannot successfully infer the return type.\r\n* The `todo!()` body when we can successfully infer the return type.\n\nCo-authored-by: Ryan Levick <me@ryanlevick.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43af7920af8c782b1fa2208a3e1e4f9cd3580891", "html_url": "https://github.com/rust-lang/rust/commit/43af7920af8c782b1fa2208a3e1e4f9cd3580891", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43af7920af8c782b1fa2208a3e1e4f9cd3580891/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c00ccdeb528bd5eacc30dfc89c937ebad8ef0c66", "url": "https://api.github.com/repos/rust-lang/rust/commits/c00ccdeb528bd5eacc30dfc89c937ebad8ef0c66", "html_url": "https://github.com/rust-lang/rust/commit/c00ccdeb528bd5eacc30dfc89c937ebad8ef0c66"}, {"sha": "1cc43ab7f4a4e1c4d3400302566a5d6c86532d32", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc43ab7f4a4e1c4d3400302566a5d6c86532d32", "html_url": "https://github.com/rust-lang/rust/commit/1cc43ab7f4a4e1c4d3400302566a5d6c86532d32"}], "stats": {"total": 213, "additions": 103, "deletions": 110}, "files": [{"sha": "754e995e5769a769d54011e7df54cf777eb71948", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 103, "deletions": 110, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/43af7920af8c782b1fa2208a3e1e4f9cd3580891/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43af7920af8c782b1fa2208a3e1e4f9cd3580891/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=43af7920af8c782b1fa2208a3e1e4f9cd3580891", "patch": "@@ -171,20 +171,32 @@ struct FunctionTemplate {\n     insert_offset: TextSize,\n     leading_ws: String,\n     fn_def: ast::Fn,\n-    ret_type: ast::RetType,\n-    should_render_snippet: bool,\n+    ret_type: Option<ast::RetType>,\n+    should_focus_return_type: bool,\n     trailing_ws: String,\n     file: FileId,\n+    tail_expr: ast::Expr,\n }\n \n impl FunctionTemplate {\n     fn to_string(&self, cap: Option<SnippetCap>) -> String {\n-        let f = match (cap, self.should_render_snippet) {\n-            (Some(cap), true) => {\n-                render_snippet(cap, self.fn_def.syntax(), Cursor::Replace(self.ret_type.syntax()))\n+        let f = match cap {\n+            Some(cap) => {\n+                let cursor = if self.should_focus_return_type {\n+                    // Focus the return type if there is one\n+                    if let Some(ref ret_type) = self.ret_type {\n+                        ret_type.syntax()\n+                    } else {\n+                        self.tail_expr.syntax()\n+                    }\n+                } else {\n+                    self.tail_expr.syntax()\n+                };\n+                render_snippet(cap, self.fn_def.syntax(), Cursor::Replace(cursor))\n             }\n-            _ => self.fn_def.to_string(),\n+            None => self.fn_def.to_string(),\n         };\n+\n         format!(\"{}{}{}\", self.leading_ws, f, self.trailing_ws)\n     }\n }\n@@ -194,8 +206,8 @@ struct FunctionBuilder {\n     fn_name: ast::Name,\n     type_params: Option<ast::GenericParamList>,\n     params: ast::ParamList,\n-    ret_type: ast::RetType,\n-    should_render_snippet: bool,\n+    ret_type: Option<ast::RetType>,\n+    should_focus_return_type: bool,\n     file: FileId,\n     needs_pub: bool,\n     is_async: bool,\n@@ -228,41 +240,16 @@ impl FunctionBuilder {\n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n \n-        // should_render_snippet intends to express a rough level of confidence about\n-        // the correctness of the return type.\n-        //\n-        // If we are able to infer some return type, and that return type is not unit, we\n-        // don't want to render the snippet. The assumption here is in this situation the\n-        // return type is just as likely to be correct as any other part of the generated\n-        // function.\n-        //\n-        // In the case where the return type is inferred as unit it is likely that the\n-        // user does in fact intend for this generated function to return some non unit\n-        // type, but that the current state of their code doesn't allow that return type\n-        // to be accurately inferred.\n-        let (ret_ty, should_render_snippet) = {\n-            match ctx.sema.type_of_expr(&ast::Expr::CallExpr(call.clone())).map(TypeInfo::original)\n-            {\n-                Some(ty) if ty.is_unknown() || ty.is_unit() => (make::ty_unit(), true),\n-                Some(ty) => {\n-                    let rendered = ty.display_source_code(ctx.db(), target_module.into());\n-                    match rendered {\n-                        Ok(rendered) => (make::ty(&rendered), false),\n-                        Err(_) => (make::ty_unit(), true),\n-                    }\n-                }\n-                None => (make::ty_unit(), true),\n-            }\n-        };\n-        let ret_type = make::ret_type(ret_ty);\n+        let (ret_type, should_focus_return_type) =\n+            make_return_type(ctx, &ast::Expr::CallExpr(call.clone()), target_module);\n \n         Some(Self {\n             target,\n             fn_name,\n             type_params,\n             params,\n             ret_type,\n-            should_render_snippet,\n+            should_focus_return_type,\n             file,\n             needs_pub,\n             is_async,\n@@ -298,44 +285,16 @@ impl FunctionBuilder {\n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n \n-        // should_render_snippet intends to express a rough level of confidence about\n-        // the correctness of the return type.\n-        //\n-        // If we are able to infer some return type, and that return type is not unit, we\n-        // don't want to render the snippet. The assumption here is in this situation the\n-        // return type is just as likely to be correct as any other part of the generated\n-        // function.\n-        //\n-        // In the case where the return type is inferred as unit it is likely that the\n-        // user does in fact intend for this generated function to return some non unit\n-        // type, but that the current state of their code doesn't allow that return type\n-        // to be accurately inferred.\n-        let (ret_ty, should_render_snippet) = {\n-            match ctx\n-                .sema\n-                .type_of_expr(&ast::Expr::MethodCallExpr(call.clone()))\n-                .map(TypeInfo::original)\n-            {\n-                Some(ty) if ty.is_unknown() || ty.is_unit() => (make::ty_unit(), true),\n-                Some(ty) => {\n-                    let rendered = ty.display_source_code(ctx.db(), target_module.into());\n-                    match rendered {\n-                        Ok(rendered) => (make::ty(&rendered), false),\n-                        Err(_) => (make::ty_unit(), true),\n-                    }\n-                }\n-                None => (make::ty_unit(), true),\n-            }\n-        };\n-        let ret_type = make::ret_type(ret_ty);\n+        let (ret_type, should_focus_return_type) =\n+            make_return_type(ctx, &ast::Expr::MethodCallExpr(call.clone()), target_module);\n \n         Some(Self {\n             target,\n             fn_name,\n             type_params,\n             params,\n             ret_type,\n-            should_render_snippet,\n+            should_focus_return_type,\n             file,\n             needs_pub,\n             is_async,\n@@ -352,7 +311,7 @@ impl FunctionBuilder {\n             self.type_params,\n             self.params,\n             fn_body,\n-            Some(self.ret_type),\n+            self.ret_type,\n             self.is_async,\n         );\n         let leading_ws;\n@@ -378,15 +337,49 @@ impl FunctionBuilder {\n         FunctionTemplate {\n             insert_offset,\n             leading_ws,\n-            ret_type: fn_def.ret_type().unwrap(),\n-            should_render_snippet: self.should_render_snippet,\n+            ret_type: fn_def.ret_type(),\n+            // PANIC: we guarantee we always create a function body with a tail expr\n+            tail_expr: fn_def.body().unwrap().tail_expr().unwrap(),\n+            should_focus_return_type: self.should_focus_return_type,\n             fn_def,\n             trailing_ws,\n             file: self.file,\n         }\n     }\n }\n \n+/// Makes an optional return type along with whether the return type should be focused by the cursor.\n+/// If we cannot infer what the return type should be, we create unit as a placeholder.\n+///\n+/// The rule for whether we focus a return type or not (and thus focus the function body),\n+/// is rather simple:\n+/// * If we could *not* infer what the return type should be, focus it (so the user can fill-in\n+/// the correct return type).\n+/// * If we could infer the return type, don't focus it (and thus focus the function body) so the\n+/// user can change the `todo!` function body.\n+fn make_return_type(\n+    ctx: &AssistContext,\n+    call: &ast::Expr,\n+    target_module: Module,\n+) -> (Option<ast::RetType>, bool) {\n+    let (ret_ty, should_focus_return_type) = {\n+        match ctx.sema.type_of_expr(call).map(TypeInfo::original) {\n+            Some(ty) if ty.is_unknown() => (Some(make::ty_unit()), true),\n+            None => (Some(make::ty_unit()), true),\n+            Some(ty) if ty.is_unit() => (None, false),\n+            Some(ty) => {\n+                let rendered = ty.display_source_code(ctx.db(), target_module.into());\n+                match rendered {\n+                    Ok(rendered) => (Some(make::ty(&rendered)), false),\n+                    Err(_) => (Some(make::ty_unit()), true),\n+                }\n+            }\n+        }\n+    };\n+    let ret_type = ret_ty.map(|rt| make::ret_type(rt));\n+    (ret_type, should_focus_return_type)\n+}\n+\n enum GeneratedFunctionTarget {\n     BehindItem(SyntaxNode),\n     InEmptyItemList(SyntaxNode),\n@@ -795,7 +788,7 @@ impl Baz {\n }\n \n fn bar(baz: Baz) -> Baz {\n-    todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -815,8 +808,8 @@ fn foo() {\n     bar(\"bar\")\n }\n \n-fn bar(arg: &str) ${0:-> ()} {\n-    todo!()\n+fn bar(arg: &str) {\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -836,8 +829,8 @@ fn foo() {\n     bar('x')\n }\n \n-fn bar(arg: char) ${0:-> ()} {\n-    todo!()\n+fn bar(arg: char) {\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -857,8 +850,8 @@ fn foo() {\n     bar(42)\n }\n \n-fn bar(arg: i32) ${0:-> ()} {\n-    todo!()\n+fn bar(arg: i32) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -878,8 +871,8 @@ fn foo() {\n     bar(42 as u8)\n }\n \n-fn bar(arg: u8) ${0:-> ()} {\n-    todo!()\n+fn bar(arg: u8) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -903,8 +896,8 @@ fn foo() {\n     bar(x as u8)\n }\n \n-fn bar(x: u8) ${0:-> ()} {\n-    todo!()\n+fn bar(x: u8) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -926,8 +919,8 @@ fn foo() {\n     bar(worble)\n }\n \n-fn bar(worble: ()) ${0:-> ()} {\n-    todo!()\n+fn bar(worble: ()) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -956,8 +949,8 @@ fn baz() {\n     bar(foo())\n }\n \n-fn bar(foo: impl Foo) ${0:-> ()} {\n-    todo!()\n+fn bar(foo: impl Foo) {\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -983,8 +976,8 @@ fn foo() {\n     bar(&baz())\n }\n \n-fn bar(baz: &Baz) ${0:-> ()} {\n-    todo!()\n+fn bar(baz: &Baz) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1012,8 +1005,8 @@ fn foo() {\n     bar(Baz::baz())\n }\n \n-fn bar(baz: Baz::Bof) ${0:-> ()} {\n-    todo!()\n+fn bar(baz: Baz::Bof) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1034,8 +1027,8 @@ fn foo<T>(t: T) {\n     bar(t)\n }\n \n-fn bar(t: T) ${0:-> ()} {\n-    todo!()\n+fn bar(t: T) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1088,8 +1081,8 @@ fn foo() {\n     bar(closure)\n }\n \n-fn bar(closure: ()) ${0:-> ()} {\n-    todo!()\n+fn bar(closure: ()) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1109,8 +1102,8 @@ fn foo() {\n     bar(baz)\n }\n \n-fn bar(baz: ()) ${0:-> ()} {\n-    todo!()\n+fn bar(baz: ()) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1134,8 +1127,8 @@ fn foo() {\n     bar(baz(), baz())\n }\n \n-fn bar(baz_1: Baz, baz_2: Baz) ${0:-> ()} {\n-    todo!()\n+fn bar(baz_1: Baz, baz_2: Baz) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1159,8 +1152,8 @@ fn foo() {\n     bar(baz(), baz(), \"foo\", \"bar\")\n }\n \n-fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) ${0:-> ()} {\n-    todo!()\n+fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -1179,8 +1172,8 @@ fn foo() {\n \",\n             r\"\n mod bar {\n-    pub(crate) fn my_fn() ${0:-> ()} {\n-        todo!()\n+    pub(crate) fn my_fn() {\n+        ${0:todo!()}\n     }\n }\n \n@@ -1215,8 +1208,8 @@ fn bar() {\n     baz(foo)\n }\n \n-fn baz(foo: foo::Foo) ${0:-> ()} {\n-    todo!()\n+fn baz(foo: foo::Foo) {\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -1239,8 +1232,8 @@ fn foo() {\n mod bar {\n     fn something_else() {}\n \n-    pub(crate) fn my_fn() ${0:-> ()} {\n-        todo!()\n+    pub(crate) fn my_fn() {\n+        ${0:todo!()}\n     }\n }\n \n@@ -1267,8 +1260,8 @@ fn foo() {\n             r\"\n mod bar {\n     mod baz {\n-        pub(crate) fn my_fn() ${0:-> ()} {\n-            todo!()\n+        pub(crate) fn my_fn() {\n+            ${0:todo!()}\n         }\n     }\n }\n@@ -1296,8 +1289,8 @@ fn main() {\n             r\"\n \n \n-pub(crate) fn bar() ${0:-> ()} {\n-    todo!()\n+pub(crate) fn bar() {\n+    ${0:todo!()}\n }\",\n         )\n     }\n@@ -1317,7 +1310,7 @@ fn main() {\n }\n \n fn foo() -> u32 {\n-    todo!()\n+    ${0:todo!()}\n }\n \",\n         )"}]}