{"sha": "c488d59addf6bc66725a2ca7314629ee0f92b4e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ODhkNTlhZGRmNmJjNjY3MjVhMmNhNzMxNDYyOWVlMGY5MmI0ZTU=", "commit": {"author": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2018-08-03T14:50:13Z"}, "committer": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2018-08-18T23:07:33Z"}, "message": "Integrate OperandValue::UnsizedRef into OperandValue::Ref.", "tree": {"sha": "eeb01a2196648be187d3ce8b0760336bc25838cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeb01a2196648be187d3ce8b0760336bc25838cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c488d59addf6bc66725a2ca7314629ee0f92b4e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c488d59addf6bc66725a2ca7314629ee0f92b4e5", "html_url": "https://github.com/rust-lang/rust/commit/c488d59addf6bc66725a2ca7314629ee0f92b4e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c488d59addf6bc66725a2ca7314629ee0f92b4e5/comments", "author": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e15e7c1267e26d2bab3d0ded8454a2a45669d55", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e15e7c1267e26d2bab3d0ded8454a2a45669d55", "html_url": "https://github.com/rust-lang/rust/commit/6e15e7c1267e26d2bab3d0ded8454a2a45669d55"}], "stats": {"total": 70, "additions": 27, "deletions": 43}, "files": [{"sha": "79343505c78a5b41705667d8ddf35c5994635df9", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=c488d59addf6bc66725a2ca7314629ee0f92b4e5", "patch": "@@ -188,7 +188,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n         }\n         let cx = bx.cx;\n         if self.is_sized_indirect() {\n-            OperandValue::Ref(val, self.layout.align).store(bx, dst)\n+            OperandValue::Ref(val, None, self.layout.align).store(bx, dst)\n         } else if self.is_unsized_indirect() {\n             bug!(\"unsized ArgType must be handled through store_fn_arg\");\n         } else if let PassMode::Cast(cast) = self.mode {\n@@ -249,7 +249,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n             PassMode::Indirect(_, Some(_)) => {\n-                OperandValue::UnsizedRef(next(), next()).store(bx, dst);\n+                OperandValue::Ref(next(), Some(next()), self.layout.align).store(bx, dst);\n             }\n             PassMode::Direct(_) | PassMode::Indirect(_, None) | PassMode::Cast(_) => {\n                 self.store(bx, next(), dst);"}, {"sha": "bd0c62e4766aed81588e0a0cdef2a048e7cbb337", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=c488d59addf6bc66725a2ca7314629ee0f92b4e5", "patch": "@@ -295,7 +295,7 @@ pub fn coerce_unsized_into(\n             OperandValue::Immediate(base) => {\n                 unsize_thin_ptr(bx, base, src_ty, dst_ty)\n             }\n-            OperandValue::Ref(..) | OperandValue::UnsizedRef(..) => bug!()\n+            OperandValue::Ref(..) => bug!()\n         };\n         OperandValue::Pair(base, info).store(bx, dst);\n     };"}, {"sha": "be3e0d9d4b1ed3a6a92d33f7eb7aae27b656397f", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=c488d59addf6bc66725a2ca7314629ee0f92b4e5", "patch": "@@ -605,7 +605,7 @@ pub fn codegen_intrinsic_call(\n                         // etc.\n                         assert!(!bx.cx.type_needs_drop(arg.layout.ty));\n                         let (ptr, align) = match arg.val {\n-                            OperandValue::Ref(ptr, align) => (ptr, align),\n+                            OperandValue::Ref(ptr, None, align) => (ptr, align),\n                             _ => bug!()\n                         };\n                         let arg = PlaceRef::new_sized(ptr, arg.layout, align);"}, {"sha": "5f718ae456c4138ff8217f402e147288b9156c55", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=c488d59addf6bc66725a2ca7314629ee0f92b4e5", "patch": "@@ -32,7 +32,7 @@ use syntax_pos::Pos;\n use super::{FunctionCx, LocalRef};\n use super::place::PlaceRef;\n use super::operand::OperandRef;\n-use super::operand::OperandValue::{Pair, Ref, UnsizedRef, Immediate};\n+use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_block(&mut self, bb: mir::BasicBlock) {\n@@ -232,10 +232,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n                     PassMode::Direct(_) | PassMode::Pair(..) => {\n                         let op = self.codegen_consume(&bx, &mir::Place::Local(mir::RETURN_PLACE));\n-                        if let Ref(llval, align) = op.val {\n+                        if let Ref(llval, _, align) = op.val {\n                             bx.load(llval, align)\n-                        } else if let UnsizedRef(..) = op.val {\n-                            bug!(\"return type must be sized\");\n                         } else {\n                             op.immediate_or_packed_pair(&bx)\n                         }\n@@ -247,7 +245,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                             LocalRef::Operand(None) => bug!(\"use of return before def\"),\n                             LocalRef::Place(cg_place) => {\n                                 OperandRef {\n-                                    val: Ref(cg_place.llval, cg_place.align),\n+                                    val: Ref(cg_place.llval, None, cg_place.align),\n                                     layout: cg_place.layout\n                                 }\n                             }\n@@ -259,12 +257,11 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                                 op.val.store(&bx, scratch);\n                                 scratch.llval\n                             }\n-                            Ref(llval, align) => {\n+                            Ref(llval, _, align) => {\n                                 assert_eq!(align.abi(), op.layout.align.abi(),\n                                            \"return place is unaligned!\");\n                                 llval\n                             }\n-                            UnsizedRef(..) => bug!(\"return type must be sized\"),\n                         };\n                         bx.load(\n                             bx.pointercast(llslot, cast_ty.llvm_type(bx.cx).ptr_to()),\n@@ -605,15 +602,11 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     // The callee needs to own the argument memory if we pass it\n                     // by-ref, so make a local copy of non-immediate constants.\n                     match (arg, op.val) {\n-                        (&mir::Operand::Copy(_), Ref(..)) |\n-                        (&mir::Operand::Constant(_), Ref(..)) => {\n+                        (&mir::Operand::Copy(_), Ref(_, None, _)) |\n+                        (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n                             let tmp = PlaceRef::alloca(&bx, op.layout, \"const\");\n                             op.val.store(&bx, tmp);\n-                            op.val = Ref(tmp.llval, tmp.align);\n-                        }\n-                        (&mir::Operand::Copy(_), UnsizedRef(..)) |\n-                        (&mir::Operand::Constant(_), UnsizedRef(..)) => {\n-                            bug!(\"tried to pass an unsized argument by copy or constant\")\n+                            op.val = Ref(tmp.llval, None, tmp.align);\n                         }\n                         _ => {}\n                     }\n@@ -667,7 +660,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             }\n         } else if arg.is_unsized_indirect() {\n             match op.val {\n-                UnsizedRef(a, b) => {\n+                Ref(a, Some(b), _) => {\n                     llargs.push(a);\n                     llargs.push(b);\n                     return;\n@@ -690,7 +683,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     }\n                 }\n             }\n-            Ref(llval, align) => {\n+            Ref(llval, _, align) => {\n                 if arg.is_indirect() && align.abi() < arg.layout.align.abi() {\n                     // `foo(packed.large_field)`. We can't pass the (unaligned) field directly. I\n                     // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n@@ -703,8 +696,6 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     (llval, align, true)\n                 }\n             }\n-            UnsizedRef(..) =>\n-                bug!(\"codegen_argument: tried to pass unsized operand to sized argument\"),\n         };\n \n         if by_ref && !arg.is_indirect() {\n@@ -740,13 +731,13 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         let tuple = self.codegen_operand(bx, operand);\n \n         // Handle both by-ref and immediate tuples.\n-        if let Ref(llval, align) = tuple.val {\n+        if let Ref(llval, None, align) = tuple.val {\n             let tuple_ptr = PlaceRef::new_sized(llval, tuple.layout, align);\n             for i in 0..tuple.layout.fields.count() {\n                 let field_ptr = tuple_ptr.project_field(bx, i);\n                 self.codegen_argument(bx, field_ptr.load(bx), llargs, &args[i]);\n             }\n-        } else if let UnsizedRef(..) = tuple.val {\n+        } else if let Ref(_, Some(_), _) = tuple.val {\n             bug!(\"closure arguments must be sized\")\n         } else {\n             // If the tuple is immediate, the elements are as well."}, {"sha": "9537379813d522eaf08cc18f9b535c8557d8a0f3", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=c488d59addf6bc66725a2ca7314629ee0f92b4e5", "patch": "@@ -37,11 +37,9 @@ use super::place::PlaceRef;\n pub enum OperandValue<'ll> {\n     /// A reference to the actual operand. The data is guaranteed\n     /// to be valid for the operand's lifetime.\n-    Ref(&'ll Value, Align),\n-    /// A reference to the unsized operand. The data is guaranteed\n-    /// to be valid for the operand's lifetime.\n-    /// The second field is the extra.\n-    UnsizedRef(&'ll Value, &'ll Value),\n+    /// The second value, if any, is the extra data (vtable or length)\n+    /// which indicates that it refers to an unsized rvalue.\n+    Ref(&'ll Value, Option<&'ll Value>, Align),\n     /// A single LLVM value.\n     Immediate(&'ll Value),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n@@ -154,8 +152,7 @@ impl OperandRef<'ll, 'tcx> {\n         let (llptr, llextra) = match self.val {\n             OperandValue::Immediate(llptr) => (llptr, None),\n             OperandValue::Pair(llptr, llextra) => (llptr, Some(llextra)),\n-            OperandValue::Ref(..) |\n-            OperandValue::UnsizedRef(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n+            OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n         };\n         let layout = cx.layout_of(projected_ty);\n         PlaceRef {\n@@ -250,8 +247,7 @@ impl OperandRef<'ll, 'tcx> {\n                 *a = bx.bitcast(*a, field.scalar_pair_element_llvm_type(bx.cx, 0, true));\n                 *b = bx.bitcast(*b, field.scalar_pair_element_llvm_type(bx.cx, 1, true));\n             }\n-            OperandValue::Ref(..) |\n-            OperandValue::UnsizedRef(..) => bug!()\n+            OperandValue::Ref(..) => bug!()\n         }\n \n         OperandRef {\n@@ -291,11 +287,11 @@ impl OperandValue<'ll> {\n             return;\n         }\n         match self {\n-            OperandValue::Ref(r, source_align) => {\n+            OperandValue::Ref(r, None, source_align) => {\n                 base::memcpy_ty(bx, dest.llval, r, dest.layout,\n                                 source_align.min(dest.align), flags)\n             }\n-            OperandValue::UnsizedRef(..) => {\n+            OperandValue::Ref(_, Some(_), _) => {\n                 bug!(\"cannot directly store unsized values\");\n             }\n             OperandValue::Immediate(s) => {\n@@ -321,7 +317,7 @@ impl OperandValue<'ll> {\n             .unwrap_or_else(|| bug!(\"indirect_dest has non-pointer type: {:?}\", indirect_dest)).ty;\n \n         let (llptr, llextra) =\n-            if let OperandValue::UnsizedRef(llptr, llextra) = self {\n+            if let OperandValue::Ref(llptr, Some(llextra), _) = self {\n                 (llptr, llextra)\n             } else {\n                 bug!(\"store_unsized called with a sized value\")"}, {"sha": "89d41dcc8e9946029ab19d81c80cacf7aa584832", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=c488d59addf6bc66725a2ca7314629ee0f92b4e5", "patch": "@@ -132,7 +132,7 @@ impl PlaceRef<'ll, 'tcx> {\n         };\n \n         let val = if let Some(llextra) = self.llextra {\n-            OperandValue::UnsizedRef(self.llval, llextra)\n+            OperandValue::Ref(self.llval, Some(llextra), self.align)\n         } else if self.layout.is_llvm_immediate() {\n             let mut const_llval = None;\n             unsafe {\n@@ -163,7 +163,7 @@ impl PlaceRef<'ll, 'tcx> {\n             };\n             OperandValue::Pair(load(0, a), load(1, b))\n         } else {\n-            OperandValue::Ref(self.llval, self.align)\n+            OperandValue::Ref(self.llval, None, self.align)\n         };\n \n         OperandRef { val, layout: self.layout }"}, {"sha": "84427d8b40f79f70aff82a69eb5777f437dc6374", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c488d59addf6bc66725a2ca7314629ee0f92b4e5/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=c488d59addf6bc66725a2ca7314629ee0f92b4e5", "patch": "@@ -83,11 +83,11 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         base::coerce_unsized_into(&bx, scratch, dest);\n                         scratch.storage_dead(&bx);\n                     }\n-                    OperandValue::Ref(llref, align) => {\n+                    OperandValue::Ref(llref, None, align) => {\n                         let source = PlaceRef::new_sized(llref, operand.layout, align);\n                         base::coerce_unsized_into(&bx, source, dest);\n                     }\n-                    OperandValue::UnsizedRef(..) => {\n+                    OperandValue::Ref(_, Some(_), _) => {\n                         bug!(\"unsized coercion on an unsized rvalue\")\n                     }\n                 }\n@@ -268,9 +268,6 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                                 bug!(\"by-ref operand {:?} in codegen_rvalue_operand\",\n                                      operand);\n                             }\n-                            OperandValue::UnsizedRef(..) => {\n-                                bug!(\"unsized coercion on an unsized rvalue\")\n-                            }\n                         }\n                     }\n                     mir::CastKind::Misc if operand.layout.is_llvm_scalar_pair() => {"}]}