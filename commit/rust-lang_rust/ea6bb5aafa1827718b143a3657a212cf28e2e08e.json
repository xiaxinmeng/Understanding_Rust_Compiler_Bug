{"sha": "ea6bb5aafa1827718b143a3657a212cf28e2e08e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNmJiNWFhZmExODI3NzE4YjE0M2EzNjU3YTIxMmNmMjhlMmUwOGU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-16T12:07:53Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-16T12:55:17Z"}, "message": "Remove to_zero/to_revoke kludge\n\nIt is much simpler to just move by_move args into a temporary\nalloca.", "tree": {"sha": "205289f945aecd2a6c87a0ab6f05b951cae6a608", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/205289f945aecd2a6c87a0ab6f05b951cae6a608"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea6bb5aafa1827718b143a3657a212cf28e2e08e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea6bb5aafa1827718b143a3657a212cf28e2e08e", "html_url": "https://github.com/rust-lang/rust/commit/ea6bb5aafa1827718b143a3657a212cf28e2e08e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea6bb5aafa1827718b143a3657a212cf28e2e08e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "html_url": "https://github.com/rust-lang/rust/commit/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9"}], "stats": {"total": 96, "additions": 25, "deletions": 71}, "files": [{"sha": "17ecf614f1d198396ec74b7c88c8ad255258678a", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 24, "deletions": 68, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ea6bb5aafa1827718b143a3657a212cf28e2e08e/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6bb5aafa1827718b143a3657a212cf28e2e08e/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=ea6bb5aafa1827718b143a3657a212cf28e2e08e", "patch": "@@ -2731,9 +2731,7 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n }\n \n fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n-                  &to_zero: [{v: ValueRef, t: ty::t}],\n-                  &to_revoke: [{v: ValueRef, t: ty::t}], e: @ast::expr) ->\n-   result {\n+                  e: @ast::expr) -> result {\n     let ccx = bcx_ccx(cx);\n     let e_ty = expr_ty(cx, e);\n     let is_bot = ty::type_is_bot(e_ty);\n@@ -2765,19 +2763,20 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n         if arg_mode == ast::by_val && (lv.kind == owned || !imm) {\n             val = Load(bcx, val);\n         }\n-    } else if arg_mode == ast::by_copy {\n+    } else if arg_mode == ast::by_copy || arg_mode == ast::by_move {\n         let {bcx: cx, val: alloc} = alloc_ty(bcx, e_ty);\n-        let last_use = ccx.last_uses.contains_key(e.id);\n+        let move_out = arg_mode == ast::by_move ||\n+            ccx.last_uses.contains_key(e.id);\n         bcx = cx;\n         if lv.kind == temporary { revoke_clean(bcx, val); }\n         if lv.kind == owned || !ty::type_is_immediate(e_ty) {\n             bcx = memmove_ty(bcx, alloc, val, e_ty);\n-            if last_use && ty::type_needs_drop(ccx.tcx, e_ty) {\n+            if move_out && ty::type_needs_drop(ccx.tcx, e_ty) {\n                 bcx = zero_alloca(bcx, val, e_ty);\n             }\n         } else { Store(bcx, val, alloc); }\n         val = alloc;\n-        if lv.kind != temporary && !last_use {\n+        if lv.kind != temporary && !move_out {\n             bcx = take_ty(bcx, val, e_ty);\n         }\n     } else if ty::type_is_immediate(e_ty) && lv.kind != owned {\n@@ -2789,15 +2788,6 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n     if !is_bot && arg.ty != e_ty || ty::type_has_params(arg.ty) {\n         val = PointerCast(bcx, val, lldestty);\n     }\n-\n-    // Collect arg for later if it happens to be one we've moving out.\n-    if arg_mode == ast::by_move {\n-        if lv.kind == owned {\n-            // Use actual ty, not declared ty -- anything else doesn't make\n-            // sense if declared ty is a ty param\n-            to_zero += [{v: lv.val, t: e_ty}];\n-        } else { to_revoke += [{v: lv.val, t: e_ty}]; }\n-    }\n     ret rslt(bcx, val);\n }\n \n@@ -2813,15 +2803,11 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n               dest: dest)\n    -> {bcx: @block_ctxt,\n        args: [ValueRef],\n-       retslot: ValueRef,\n-       to_zero: [{v: ValueRef, t: ty::t}],\n-       to_revoke: [{v: ValueRef, t: ty::t}]} {\n+       retslot: ValueRef} {\n \n     let args = ty::ty_fn_args(fn_ty);\n     let llargs: [ValueRef] = [];\n     let lltydescs: [ValueRef] = [];\n-    let to_zero = [];\n-    let to_revoke = [];\n \n     let ccx = bcx_ccx(cx);\n     let bcx = cx;\n@@ -2899,17 +2885,14 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n     let arg_tys = type_of_explicit_args(ccx, args);\n     let i = 0u;\n     for e: @ast::expr in es {\n-        let r = trans_arg_expr(bcx, args[i], arg_tys[i], to_zero, to_revoke,\n-                               e);\n+        let r = trans_arg_expr(bcx, args[i], arg_tys[i], e);\n         bcx = r.bcx;\n         llargs += [r.val];\n         i += 1u;\n     }\n     ret {bcx: bcx,\n          args: llargs,\n-         retslot: llretslot,\n-         to_zero: to_zero,\n-         to_revoke: to_revoke};\n+         retslot: llretslot};\n }\n \n fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n@@ -2969,8 +2952,7 @@ fn trans_call_inner(in_cx: @block_ctxt, fn_expr_ty: ty::t,\n        then one or more of the args has\n        type _|_. Since that means it diverges, the code\n        for the call itself is unreachable. */\n-    bcx = invoke_full(bcx, faddr, llargs, args_res.to_zero,\n-                      args_res.to_revoke);\n+    bcx = invoke_full(bcx, faddr, llargs);\n     alt dest {\n       ignore {\n         if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n@@ -2982,8 +2964,6 @@ fn trans_call_inner(in_cx: @block_ctxt, fn_expr_ty: ty::t,\n         *cell = Load(bcx, llretslot);\n       }\n     }\n-    // Forget about anything we moved out.\n-    bcx = zero_and_revoke(bcx, args_res.to_zero, args_res.to_revoke);\n \n     bcx = trans_block_cleanups(bcx, cx);\n     let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n@@ -2994,65 +2974,43 @@ fn trans_call_inner(in_cx: @block_ctxt, fn_expr_ty: ty::t,\n     ret next_cx;\n }\n \n-fn zero_and_revoke(bcx: @block_ctxt,\n-                   to_zero: [{v: ValueRef, t: ty::t}],\n-                   to_revoke: [{v: ValueRef, t: ty::t}]) -> @block_ctxt {\n-    let bcx = bcx;\n-    for {v, t} in to_zero {\n-        bcx = zero_alloca(bcx, v, t);\n-    }\n-    for {v, _} in to_revoke { revoke_clean(bcx, v); }\n-    ret bcx;\n-}\n-\n fn invoke(bcx: @block_ctxt, llfn: ValueRef,\n           llargs: [ValueRef]) -> @block_ctxt {\n-    ret invoke_(bcx, llfn, llargs, [], [], Invoke);\n+    ret invoke_(bcx, llfn, llargs, Invoke);\n }\n \n-fn invoke_full(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef],\n-               to_zero: [{v: ValueRef, t: ty::t}],\n-               to_revoke: [{v: ValueRef, t: ty::t}]) -> @block_ctxt {\n-    ret invoke_(bcx, llfn, llargs, to_zero, to_revoke, Invoke);\n+fn invoke_full(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef])\n+    -> @block_ctxt {\n+    ret invoke_(bcx, llfn, llargs, Invoke);\n }\n \n fn invoke_(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef],\n-           to_zero: [{v: ValueRef, t: ty::t}],\n-           to_revoke: [{v: ValueRef, t: ty::t}],\n            invoker: fn(@block_ctxt, ValueRef, [ValueRef],\n                        BasicBlockRef, BasicBlockRef)) -> @block_ctxt {\n     // FIXME: May be worth turning this into a plain call when there are no\n     // cleanups to run\n     if bcx.unreachable { ret bcx; }\n     let normal_bcx = new_sub_block_ctxt(bcx, \"normal return\");\n-    invoker(bcx, llfn, llargs, normal_bcx.llbb,\n-            get_landing_pad(bcx, to_zero, to_revoke));\n+    invoker(bcx, llfn, llargs, normal_bcx.llbb, get_landing_pad(bcx));\n     ret normal_bcx;\n }\n \n-fn get_landing_pad(bcx: @block_ctxt,\n-                   to_zero: [{v: ValueRef, t: ty::t}],\n-                   to_revoke: [{v: ValueRef, t: ty::t}]\n-                  ) -> BasicBlockRef {\n-    let have_zero_or_revoke = vec::is_not_empty(to_zero)\n-        || vec::is_not_empty(to_revoke);\n-    let scope_bcx = find_scope_for_lpad(bcx, have_zero_or_revoke);\n-    if scope_bcx.lpad_dirty || have_zero_or_revoke {\n+fn get_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n+    let scope_bcx = find_scope_for_lpad(bcx);\n+    if scope_bcx.lpad_dirty {\n         let unwind_bcx = new_sub_block_ctxt(bcx, \"unwind\");\n-        trans_landing_pad(unwind_bcx, to_zero, to_revoke);\n+        trans_landing_pad(unwind_bcx);\n         scope_bcx.lpad = some(unwind_bcx.llbb);\n-        scope_bcx.lpad_dirty = have_zero_or_revoke;\n+        scope_bcx.lpad_dirty = false;\n     }\n     assert option::is_some(scope_bcx.lpad);\n     ret option::get(scope_bcx.lpad);\n \n-    fn find_scope_for_lpad(bcx: @block_ctxt,\n-                           have_zero_or_revoke: bool) -> @block_ctxt {\n+    fn find_scope_for_lpad(bcx: @block_ctxt) -> @block_ctxt {\n         let scope_bcx = bcx;\n         while true {\n             scope_bcx = find_scope_cx(scope_bcx);\n-            if vec::is_not_empty(scope_bcx.cleanups)\n-                || have_zero_or_revoke {\n+            if vec::is_not_empty(scope_bcx.cleanups) {\n                 ret scope_bcx;\n             } else {\n                 scope_bcx = alt scope_bcx.parent {\n@@ -3067,9 +3025,7 @@ fn get_landing_pad(bcx: @block_ctxt,\n     }\n }\n \n-fn trans_landing_pad(bcx: @block_ctxt,\n-                     to_zero: [{v: ValueRef, t: ty::t}],\n-                     to_revoke: [{v: ValueRef, t: ty::t}]) -> BasicBlockRef {\n+fn trans_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n@@ -3095,7 +3051,7 @@ fn trans_landing_pad(bcx: @block_ctxt,\n     // FIXME: This seems like a very naive and redundant way to generate the\n     // landing pads, as we're re-generating all in-scope cleanups for each\n     // function call. Probably good optimization opportunities here.\n-    let bcx = zero_and_revoke(bcx, to_zero, to_revoke);\n+    let bcx = bcx;\n     let scope_cx = bcx;\n     while true {\n         scope_cx = find_scope_cx(scope_cx);"}, {"sha": "1c4ff2dad848b70b574e6a8d02fd6698069cebe1", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea6bb5aafa1827718b143a3657a212cf28e2e08e/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6bb5aafa1827718b143a3657a212cf28e2e08e/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=ea6bb5aafa1827718b143a3657a212cf28e2e08e", "patch": "@@ -60,12 +60,10 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n }\n \n fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n-    let tz = [], tr = [];\n     let basety = expr_ty(bcx, base);\n     let m_by_ref = ast::expl(ast::by_ref);\n     trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n-                   T_ptr(type_of_or_i8(bcx_ccx(bcx), basety)), tz,\n-                   tr, base)\n+                   T_ptr(type_of_or_i8(bcx_ccx(bcx), basety)), base)\n }\n \n fn trans_method_callee(bcx: @block_ctxt, callee_id: ast::node_id,"}]}