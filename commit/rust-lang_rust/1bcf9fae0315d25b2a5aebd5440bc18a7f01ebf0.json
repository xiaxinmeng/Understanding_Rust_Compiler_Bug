{"sha": "1bcf9fae0315d25b2a5aebd5440bc18a7f01ebf0", "node_id": "C_kwDOAAsO6NoAKDFiY2Y5ZmFlMDMxNWQyNWIyYTVhZWJkNTQ0MGJjMThhN2YwMWViZjA", "commit": {"author": {"name": "onestacked", "email": "chrisi.schrefl@gmail.com", "date": "2022-11-04T12:43:13Z"}, "committer": {"name": "onestacked", "email": "chrisi.schrefl@gmail.com", "date": "2022-11-04T20:30:46Z"}, "message": "Made `Hash` and `Hasher` const_trait", "tree": {"sha": "5626410ba44b09aeab53a3028dbe0fa2d79b002c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5626410ba44b09aeab53a3028dbe0fa2d79b002c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bcf9fae0315d25b2a5aebd5440bc18a7f01ebf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bcf9fae0315d25b2a5aebd5440bc18a7f01ebf0", "html_url": "https://github.com/rust-lang/rust/commit/1bcf9fae0315d25b2a5aebd5440bc18a7f01ebf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bcf9fae0315d25b2a5aebd5440bc18a7f01ebf0/comments", "author": {"login": "chriss0612", "id": 18047460, "node_id": "MDQ6VXNlcjE4MDQ3NDYw", "avatar_url": "https://avatars.githubusercontent.com/u/18047460?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chriss0612", "html_url": "https://github.com/chriss0612", "followers_url": "https://api.github.com/users/chriss0612/followers", "following_url": "https://api.github.com/users/chriss0612/following{/other_user}", "gists_url": "https://api.github.com/users/chriss0612/gists{/gist_id}", "starred_url": "https://api.github.com/users/chriss0612/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chriss0612/subscriptions", "organizations_url": "https://api.github.com/users/chriss0612/orgs", "repos_url": "https://api.github.com/users/chriss0612/repos", "events_url": "https://api.github.com/users/chriss0612/events{/privacy}", "received_events_url": "https://api.github.com/users/chriss0612/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chriss0612", "id": 18047460, "node_id": "MDQ6VXNlcjE4MDQ3NDYw", "avatar_url": "https://avatars.githubusercontent.com/u/18047460?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chriss0612", "html_url": "https://github.com/chriss0612", "followers_url": "https://api.github.com/users/chriss0612/followers", "following_url": "https://api.github.com/users/chriss0612/following{/other_user}", "gists_url": "https://api.github.com/users/chriss0612/gists{/gist_id}", "starred_url": "https://api.github.com/users/chriss0612/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chriss0612/subscriptions", "organizations_url": "https://api.github.com/users/chriss0612/orgs", "repos_url": "https://api.github.com/users/chriss0612/repos", "events_url": "https://api.github.com/users/chriss0612/events{/privacy}", "received_events_url": "https://api.github.com/users/chriss0612/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2a5c3a50fc3fb6d16cd140f55f7db61cbf08a01", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2a5c3a50fc3fb6d16cd140f55f7db61cbf08a01", "html_url": "https://github.com/rust-lang/rust/commit/c2a5c3a50fc3fb6d16cd140f55f7db61cbf08a01"}], "stats": {"total": 68, "additions": 44, "deletions": 24}, "files": [{"sha": "f3a60ed1d5796e41e012081de42c6a228731bc90", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1bcf9fae0315d25b2a5aebd5440bc18a7f01ebf0/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bcf9fae0315d25b2a5aebd5440bc18a7f01ebf0/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=1bcf9fae0315d25b2a5aebd5440bc18a7f01ebf0", "patch": "@@ -183,6 +183,7 @@ mod sip;\n /// [impl]: ../../std/primitive.str.html#impl-Hash-for-str\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Hash\"]\n+#[const_trait]\n pub trait Hash {\n     /// Feeds this value into the given [`Hasher`].\n     ///\n@@ -234,12 +235,19 @@ pub trait Hash {\n     /// [`hash`]: Hash::hash\n     /// [`hash_slice`]: Hash::hash_slice\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n-    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n+    fn hash_slice<H: ~const Hasher>(data: &[Self], state: &mut H)\n     where\n         Self: Sized,\n     {\n-        for piece in data {\n-            piece.hash(state);\n+        //FIXME(const_iter_slice): Revert to for loop\n+        //for piece in data {\n+        //    piece.hash(state);\n+        //}\n+\n+        let mut i = 0;\n+        while i < data.len() {\n+            data[i].hash(state);\n+            i += 1;\n         }\n     }\n }\n@@ -313,6 +321,7 @@ pub use macros::Hash;\n /// [`write_u8`]: Hasher::write_u8\n /// [`write_u32`]: Hasher::write_u32\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[const_trait]\n pub trait Hasher {\n     /// Returns the hash value for the values written so far.\n     ///\n@@ -558,7 +567,8 @@ pub trait Hasher {\n }\n \n #[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n-impl<H: Hasher + ?Sized> Hasher for &mut H {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"none\")]\n+impl<H: ~const Hasher + ?Sized> const Hasher for &mut H {\n     fn finish(&self) -> u64 {\n         (**self).finish()\n     }\n@@ -806,14 +816,15 @@ mod impls {\n     macro_rules! impl_write {\n         ($(($ty:ident, $meth:ident),)*) => {$(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl Hash for $ty {\n+            #[rustc_const_unstable(feature = \"const_hash\", issue = \"none\")]\n+            impl const Hash for $ty {\n                 #[inline]\n-                fn hash<H: Hasher>(&self, state: &mut H) {\n+                fn hash<H: ~const Hasher>(&self, state: &mut H) {\n                     state.$meth(*self)\n                 }\n \n                 #[inline]\n-                fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n+                fn hash_slice<H: ~const Hasher>(data: &[$ty], state: &mut H) {\n                     let newlen = data.len() * mem::size_of::<$ty>();\n                     let ptr = data.as_ptr() as *const u8;\n                     // SAFETY: `ptr` is valid and aligned, as this macro is only used\n@@ -842,54 +853,60 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for bool {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"none\")]\n+    impl const Hash for bool {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_u8(*self as u8)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for char {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"none\")]\n+    impl const Hash for char {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_u32(*self as u32)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for str {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"none\")]\n+    impl const Hash for str {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_str(self);\n         }\n     }\n \n     #[stable(feature = \"never_hash\", since = \"1.29.0\")]\n-    impl Hash for ! {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"none\")]\n+    impl const Hash for ! {\n         #[inline]\n-        fn hash<H: Hasher>(&self, _: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, _: &mut H) {\n             *self\n         }\n     }\n \n     macro_rules! impl_hash_tuple {\n         () => (\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl Hash for () {\n+            #[rustc_const_unstable(feature = \"const_hash\", issue = \"none\")]\n+            impl const Hash for () {\n                 #[inline]\n-                fn hash<H: Hasher>(&self, _state: &mut H) {}\n+                fn hash<H: ~const Hasher>(&self, _state: &mut H) {}\n             }\n         );\n \n         ( $($name:ident)+) => (\n             maybe_tuple_doc! {\n                 $($name)+ @\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n+                #[rustc_const_unstable(feature = \"const_hash\", issue = \"none\")]\n+                impl<$($name: ~const Hash),+> const Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n                     #[allow(non_snake_case)]\n                     #[inline]\n-                    fn hash<S: Hasher>(&self, state: &mut S) {\n+                    fn hash<S: ~const Hasher>(&self, state: &mut S) {\n                         let ($(ref $name,)+) = *self;\n                         $($name.hash(state);)+\n                     }\n@@ -932,24 +949,27 @@ mod impls {\n     impl_hash_tuple! { T B C D E F G H I J K L }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Hash> Hash for [T] {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"none\")]\n+    impl<T: ~const Hash> const Hash for [T] {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_length_prefix(self.len());\n             Hash::hash_slice(self, state)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized + Hash> Hash for &T {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"none\")]\n+    impl<T: ?Sized + ~const Hash> const Hash for &T {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             (**self).hash(state);\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized + Hash> Hash for &mut T {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"none\")]\n+    impl<T: ?Sized + ~const Hash> const Hash for &mut T {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n             (**self).hash(state);"}]}