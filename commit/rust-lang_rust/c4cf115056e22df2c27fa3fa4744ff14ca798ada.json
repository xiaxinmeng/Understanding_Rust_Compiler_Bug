{"sha": "c4cf115056e22df2c27fa3fa4744ff14ca798ada", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0Y2YxMTUwNTZlMjJkZjJjMjdmYTNmYTQ3NDRmZjE0Y2E3OThhZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-20T18:08:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-20T18:08:12Z"}, "message": "Auto merge of #55720 - RalfJung:const-eval-raw, r=oli-obk\n\nMake const_eval_raw query return just an AllocId\n\nr? @oli-obk", "tree": {"sha": "df44f58387836e8929ac8baaece6eb99d4b11c57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df44f58387836e8929ac8baaece6eb99d4b11c57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4cf115056e22df2c27fa3fa4744ff14ca798ada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4cf115056e22df2c27fa3fa4744ff14ca798ada", "html_url": "https://github.com/rust-lang/rust/commit/c4cf115056e22df2c27fa3fa4744ff14ca798ada", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4cf115056e22df2c27fa3fa4744ff14ca798ada/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3991bfbbc212ad4825588bb18ad39344e4b600b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3991bfbbc212ad4825588bb18ad39344e4b600b7", "html_url": "https://github.com/rust-lang/rust/commit/3991bfbbc212ad4825588bb18ad39344e4b600b7"}, {"sha": "612febcc4bec60dba58472269c2cf30860315a3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/612febcc4bec60dba58472269c2cf30860315a3d", "html_url": "https://github.com/rust-lang/rust/commit/612febcc4bec60dba58472269c2cf30860315a3d"}], "stats": {"total": 247, "additions": 138, "deletions": 109}, "files": [{"sha": "679107160a6fc4a4785d6aea8639d401363cdd4a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -317,6 +317,10 @@ impl_stable_hash_for!(\n         ByRef(id, alloc, offset),\n     }\n );\n+impl_stable_hash_for!(struct ::mir::interpret::RawConst<'tcx> {\n+    alloc_id,\n+    ty,\n+});\n \n impl_stable_hash_for! {\n     impl<Tag> for struct mir::interpret::Pointer<Tag> {"}, {"sha": "f1ac4b210583e6d935b6cc9983cf4284d798f171", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -16,7 +16,7 @@ use ty::{self, Ty, layout};\n use ty::layout::{Size, Align, LayoutError};\n use rustc_target::spec::abi::Abi;\n \n-use super::{Pointer, InboundsCheck, ScalarMaybeUndef};\n+use super::{RawConst, Pointer, InboundsCheck, ScalarMaybeUndef};\n \n use backtrace::Backtrace;\n \n@@ -46,6 +46,7 @@ impl ErrorHandled {\n     }\n }\n \n+pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "9369b6e56f1d018f3992c096ccc648da1dedcc62", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -22,10 +22,10 @@ mod pointer;\n \n pub use self::error::{\n     EvalError, EvalResult, EvalErrorKind, AssertMessage, ConstEvalErr, struct_error,\n-    FrameInfo, ConstEvalResult, ErrorHandled,\n+    FrameInfo, ConstEvalRawResult, ConstEvalResult, ErrorHandled,\n };\n \n-pub use self::value::{Scalar, ConstValue, ScalarMaybeUndef};\n+pub use self::value::{Scalar, ScalarMaybeUndef, RawConst, ConstValue};\n \n pub use self::allocation::{\n     InboundsCheck, Allocation, AllocationExtra,"}, {"sha": "4bcba9d54674e3f7f610b59ab4bfaa2c26170b01", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -10,19 +10,28 @@\n \n use std::fmt;\n \n-use ty::layout::{HasDataLayout, Size};\n-use ty::subst::Substs;\n-use hir::def_id::DefId;\n+use crate::ty::{Ty, subst::Substs, layout::{HasDataLayout, Size}};\n+use crate::hir::def_id::DefId;\n \n use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n+/// Represents the result of a raw const operation, pre-validation.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n+pub struct RawConst<'tcx> {\n+    // the value lives here, at offset 0, and that allocation definitely is a `AllocType::Memory`\n+    // (so you can use `AllocMap::unwrap_memory`).\n+    pub alloc_id: AllocId,\n+    pub ty: Ty<'tcx>,\n+}\n+\n /// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n /// matches the LocalValue optimizations for easy conversions between Value and ConstValue.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n     /// Never returned from the `const_eval` query, but the HIR contains these frequently in order\n     /// to allow HIR creation to happen for everything before needing to be able to run constant\n     /// evaluation\n+    /// FIXME: The query should then return a type that does not even have this variant.\n     Unevaluated(DefId, &'tcx Substs<'tcx>),\n \n     /// Used only for types with layout::abi::Scalar ABI and ZSTs"}, {"sha": "22bd1e26ba3eea36d86e2e30da850cbd1c44b178", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -27,7 +27,7 @@ use middle::stability::{self, DeprecationEntry};\n use middle::lib_features::LibFeatures;\n use middle::lang_items::{LanguageItems, LangItem};\n use middle::exported_symbols::{SymbolExportLevel, ExportedSymbol};\n-use mir::interpret::ConstEvalResult;\n+use mir::interpret::{ConstEvalRawResult, ConstEvalResult};\n use mir::mono::CodegenUnit;\n use mir;\n use mir::interpret::GlobalId;\n@@ -309,7 +309,7 @@ define_queries! { <'tcx>\n         /// validation. Please add a comment to every use site explaining why using `const_eval`\n         /// isn't sufficient\n         [] fn const_eval_raw: const_eval_raw_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-            -> ConstEvalResult<'tcx>,\n+            -> ConstEvalRawResult<'tcx>,\n \n         /// Results of evaluating const items or constants embedded in\n         /// other items (such as enum variant explicit discriminants)."}, {"sha": "3b32fe21adf8377c051f011e91b967e25bb153da", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -31,8 +31,8 @@ use rustc::util::common::ErrorReported;\n use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n-use interpret::{self,\n-    PlaceTy, MemPlace, OpTy, Operand, Immediate, Scalar, ConstValue, Pointer,\n+use crate::interpret::{self,\n+    PlaceTy, MPlaceTy, MemPlace, OpTy, Operand, Immediate, Scalar, RawConst, ConstValue, Pointer,\n     EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n@@ -94,11 +94,12 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, OpTy<'tcx>> {\n+) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n     let mut ecx = mk_borrowck_eval_cx(tcx, cid.instance, mir, DUMMY_SP).unwrap();\n     eval_body_using_ecx(&mut ecx, cid, Some(mir), param_env)\n }\n \n+// FIXME: These two conversion functions are bad hacks.  We should just always use allocations.\n pub fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     op: OpTy<'tcx>,\n@@ -144,13 +145,20 @@ pub fn op_to_const<'tcx>(\n     };\n     Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, op.layout.ty))\n }\n+pub fn const_to_op<'tcx>(\n+    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n+    cnst: &ty::Const<'tcx>,\n+) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    let op = ecx.const_value_to_op(cnst.val)?;\n+    Ok(OpTy { op, layout: ecx.layout_of(cnst.ty)? })\n+}\n \n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, OpTy<'tcx>>, CompileTimeEvalContext<'a, 'mir, 'tcx>) {\n+) -> (EvalResult<'tcx, MPlaceTy<'tcx>>, CompileTimeEvalContext<'a, 'mir, 'tcx>) {\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n     let span = tcx.def_span(cid.instance.def_id());\n@@ -166,7 +174,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, OpTy<'tcx>> {\n+) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n     let mut mir = match mir {\n@@ -206,7 +214,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.memory.intern_static(ret.ptr.to_ptr()?.alloc_id, mutability)?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n-    Ok(ret.into())\n+    Ok(ret)\n }\n \n impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n@@ -494,7 +502,7 @@ pub fn const_field<'a, 'tcx>(\n     let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let result = (|| {\n         // get the operand again\n-        let op = ecx.const_to_op(value)?;\n+        let op = const_to_op(&ecx, value)?;\n         // downcast\n         let down = match variant {\n             None => op,\n@@ -521,7 +529,7 @@ pub fn const_variant_index<'a, 'tcx>(\n ) -> EvalResult<'tcx, VariantIdx> {\n     trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n     let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n-    let op = ecx.const_to_op(val)?;\n+    let op = const_to_op(&ecx, val)?;\n     Ok(ecx.read_discriminant(op)?.1)\n }\n \n@@ -534,15 +542,17 @@ pub fn error_to_const_error<'a, 'mir, 'tcx>(\n     ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n }\n \n-fn validate_const<'a, 'tcx>(\n+fn validate_and_turn_into_const<'a, 'tcx>(\n     tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    constant: &'tcx ty::Const<'tcx>,\n+    constant: RawConst<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     let cid = key.value;\n     let ecx = mk_eval_cx(tcx, cid.instance, key.param_env).unwrap();\n     let val = (|| {\n-        let op = ecx.const_to_op(constant)?;\n+        let op = ecx.raw_const_to_mplace(constant)?.into();\n+        // FIXME: Once the visitor infrastructure landed, change validation to\n+        // work directly on `MPlaceTy`.\n         let mut ref_tracking = RefTracking::new(op);\n         while let Some((op, path)) = ref_tracking.todo.pop() {\n             ecx.validate_operand(\n@@ -552,7 +562,10 @@ fn validate_const<'a, 'tcx>(\n                 /* const_mode */ true,\n             )?;\n         }\n-        Ok(constant)\n+        // Now that we validated, turn this into a proper constant\n+        let def_id = cid.instance.def.def_id();\n+        let normalize = tcx.is_static(def_id).is_none() && cid.promoted.is_none();\n+        op_to_const(&ecx, op, normalize)\n     })();\n \n     val.map_err(|error| {\n@@ -591,14 +604,14 @@ pub fn const_eval_provider<'a, 'tcx>(\n         }\n     }\n     tcx.const_eval_raw(key).and_then(|val| {\n-        validate_const(tcx, val, key)\n+        validate_and_turn_into_const(tcx, val, key)\n     })\n }\n \n pub fn const_eval_raw_provider<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n+) -> ::rustc::mir::interpret::ConstEvalRawResult<'tcx> {\n     // Because the constant is computed twice (once per value of `Reveal`), we are at risk of\n     // reporting the same error twice here. To resolve this, we check whether we can evaluate the\n     // constant in the more restrictive `Reveal::UserFacing`, which most likely already was\n@@ -648,16 +661,11 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n     };\n \n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n-    res.and_then(|op| {\n-        let normalize = tcx.is_static(def_id).is_none() && cid.promoted.is_none();\n-        if !normalize {\n-            // Sanity check: These must always be a MemPlace\n-            match op.op {\n-                Operand::Indirect(_) => { /* all is good */ },\n-                Operand::Immediate(_) => bug!(\"const eval gave us an Immediate\"),\n-            }\n-        }\n-        op_to_const(&ecx, op, normalize)\n+    res.and_then(|place| {\n+        Ok(RawConst {\n+            alloc_id: place.to_ptr().expect(\"we allocated this ptr!\").alloc_id,\n+            ty: place.layout.ty\n+        })\n     }).map_err(|error| {\n         let err = error_to_const_error(&ecx, error);\n         // errors in statics are always emitted as fatal errors"}, {"sha": "59083413582469f231b98054250fce80ca0fc2b7", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -588,18 +588,26 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         Ok(())\n     }\n \n-    pub fn const_eval(&self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n+    pub fn const_eval_raw(\n+        &self,\n+        gid: GlobalId<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let param_env = if self.tcx.is_static(gid.instance.def_id()).is_some() {\n             ty::ParamEnv::reveal_all()\n         } else {\n             self.param_env\n         };\n-        self.tcx.const_eval(param_env.and(gid)).map_err(|err| {\n+        // We use `const_eval_raw` here, and get an unvalidated result.  That is okay:\n+        // Our result will later be validated anyway, and there seems no good reason\n+        // to have to fail early here.  This is also more consistent with\n+        // `Memory::get_static_alloc` which has to use `const_eval_raw` to avoid cycles.\n+        let val = self.tcx.const_eval_raw(param_env.and(gid)).map_err(|err| {\n             match err {\n-                ErrorHandled::Reported => EvalErrorKind::ReferencedConstant.into(),\n-                ErrorHandled::TooGeneric => EvalErrorKind::TooGeneric.into(),\n+                ErrorHandled::Reported => EvalErrorKind::ReferencedConstant,\n+                ErrorHandled::TooGeneric => EvalErrorKind::TooGeneric,\n             }\n-        })\n+        })?;\n+        self.raw_const_to_mplace(val)\n     }\n \n     pub fn dump_place(&self, place: Place<M::PointerTag>) {"}, {"sha": "7dd42c6664968c3099af4f802e700e1dacda6ea3", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -28,7 +28,7 @@ use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax::ast::Mutability;\n \n use super::{\n-    Pointer, AllocId, Allocation, ConstValue, GlobalId, AllocationExtra, InboundsCheck,\n+    Pointer, AllocId, Allocation, GlobalId, AllocationExtra, InboundsCheck,\n     EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ScalarMaybeUndef, ErrorHandled,\n };\n@@ -374,14 +374,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 ErrorHandled::Reported => EvalErrorKind::ReferencedConstant.into(),\n                 ErrorHandled::TooGeneric => EvalErrorKind::TooGeneric.into(),\n             }\n-        }).map(|const_val| {\n-            if let ConstValue::ByRef(_, allocation, _) = const_val.val {\n-                // We got tcx memory. Let the machine figure out whether and how to\n-                // turn that into memory with the right pointer tag.\n-                M::adjust_static_allocation(allocation)\n-            } else {\n-                bug!(\"Matching on non-ByRef static\")\n-            }\n+        }).map(|raw_const| {\n+            let allocation = tcx.alloc_map.lock().unwrap_memory(raw_const.alloc_id);\n+            // We got tcx memory. Let the machine figure out whether and how to\n+            // turn that into memory with the right pointer tag.\n+            M::adjust_static_allocation(allocation)\n         })\n     }\n "}, {"sha": "5d993cfee084cc2c3aef5defcd4af0408d09c9e3", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -13,7 +13,7 @@\n \n use std::convert::TryInto;\n \n-use rustc::{mir, ty};\n+use rustc::mir;\n use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx};\n \n use rustc::mir::interpret::{\n@@ -535,19 +535,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             .collect()\n     }\n \n-    // Also used e.g. when miri runs into a constant.\n-    pub(super) fn const_value_to_op(\n+    // Used when miri runs into a constant, and by CTFE.\n+    // FIXME: CTFE should use allocations, then we can make this private (embed it into\n+    // `eval_operand`, ideally).\n+    pub(crate) fn const_value_to_op(\n         &self,\n         val: ConstValue<'tcx>,\n     ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n         trace!(\"const_value_to_op: {:?}\", val);\n         match val {\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n-                self.global_to_op(GlobalId {\n+                Ok(*OpTy::from(self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: None,\n-                })\n+                })?))\n             }\n             ConstValue::ByRef(id, alloc, offset) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n@@ -565,21 +567,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 Ok(Operand::Immediate(Immediate::Scalar(x.into())).with_default_tag()),\n         }\n     }\n-    pub fn const_to_op(\n-        &self,\n-        cnst: &ty::Const<'tcx>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let op = self.const_value_to_op(cnst.val)?;\n-        Ok(OpTy { op, layout: self.layout_of(cnst.ty)? })\n-    }\n-\n-    pub(super) fn global_to_op(\n-        &self,\n-        gid: GlobalId<'tcx>\n-    ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n-        let cv = self.const_eval(gid)?;\n-        self.const_value_to_op(cv.val)\n-    }\n \n     /// Read discriminant, return the runtime value as well as the variant index.\n     pub fn read_discriminant("}, {"sha": "9f248d46350740a4203504d32f0a96444ed5fc11", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -20,12 +20,10 @@ use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx};\n \n-use rustc::mir::interpret::{\n-    GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic\n-};\n use super::{\n+    GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic,\n     EvalContext, Machine, AllocMap, AllocationExtra,\n-    Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind\n+    RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -555,16 +553,10 @@ where\n         Ok(match *mir_place {\n             Promoted(ref promoted) => {\n                 let instance = self.frame().instance;\n-                let op = self.global_to_op(GlobalId {\n+                self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: Some(promoted.0),\n-                })?;\n-                let mplace = op.to_mem_place(); // these are always in memory\n-                let ty = self.monomorphize(promoted.1, self.substs());\n-                MPlaceTy {\n-                    mplace,\n-                    layout: self.layout_of(ty)?,\n-                }\n+                })?\n             }\n \n             Static(ref static_) => {\n@@ -981,6 +973,19 @@ where\n         Ok(OpTy { op, layout: place.layout })\n     }\n \n+    pub fn raw_const_to_mplace(\n+        &self,\n+        raw: RawConst<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        // This must be an allocation in `tcx`\n+        assert!(self.tcx.alloc_map.lock().get(raw.alloc_id).is_some());\n+        let layout = self.layout_of(raw.ty)?;\n+        Ok(MPlaceTy::from_aligned_ptr(\n+            Pointer::new(raw.alloc_id, Size::ZERO).with_default_tag(),\n+            layout,\n+        ))\n+    }\n+\n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n     /// Also return some more information so drop doesn't have to run the same code twice.\n     pub(super) fn unpack_dyn_trait(&self, mplace: MPlaceTy<'tcx, M::PointerTag>)"}, {"sha": "661ca4773b4a91939d0d3eade2d3ab2f3e9a9fa4", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -29,7 +29,9 @@ use rustc::ty::layout::{\n };\n \n use interpret::{self, EvalContext, ScalarMaybeUndef, Immediate, OpTy, MemoryKind};\n-use const_eval::{CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_borrowck_eval_cx};\n+use const_eval::{\n+    CompileTimeInterpreter, const_to_op, error_to_const_error, eval_promoted, mk_borrowck_eval_cx\n+};\n use transform::{MirPass, MirSource};\n \n pub struct ConstProp;\n@@ -262,7 +264,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match self.ecx.const_to_op(c.literal) {\n+        match const_to_op(&self.ecx, c.literal) {\n             Ok(op) => {\n                 Some((op, c.span))\n             },\n@@ -309,7 +311,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     eval_promoted(this.tcx, cid, this.mir, this.param_env)\n                 })?;\n                 trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                Some((res, source_info.span))\n+                Some((res.into(), source_info.span))\n             },\n             _ => None,\n         }"}, {"sha": "129177e9a1ae92b550c3f3e87e791797ef3a378e", "filename": "src/test/ui/consts/const-err4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -16,7 +16,7 @@ union Foo {\n \n enum Bar {\n     Boo = [unsafe { Foo { b: () }.a }; 4][3],\n-    //~^ ERROR evaluation of constant value failed\n+    //~^ ERROR it is undefined behavior to use this value\n }\n \n fn main() {"}, {"sha": "38a8f75a5c20853b75e7ecd7546c5758cb89a80e", "filename": "src/test/ui/consts/const-err4.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.stderr?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -1,8 +1,10 @@\n-error[E0080]: evaluation of constant value failed\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-err4.rs:18:11\n    |\n LL |     Boo = [unsafe { Foo { b: () }.a }; 4][3],\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected initialized plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error: aborting due to previous error\n "}, {"sha": "cc5ddb4401644b8f7ad407070d43a9b4fea07d83", "filename": "src/test/ui/consts/const-eval/const-pointer-values-in-various-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -37,7 +37,7 @@ fn main() {\n     //~^ ERROR it is undefined behavior to use this value\n \n     const I32_REF_U128_UNION: u128 = unsafe { Nonsense { int_32_ref: &3 }.uint_128 };\n-    //~^ ERROR any use of this value will cause an error\n+    //~^ ERROR it is undefined behavior to use this value\n \n     const I32_REF_I8_UNION: i8 = unsafe { Nonsense { int_32_ref: &3 }.int_8 };\n     //~^ ERROR any use of this value will cause an error\n@@ -52,7 +52,7 @@ fn main() {\n     //~^ ERROR it is undefined behavior to use this value\n \n     const I32_REF_I128_UNION: i128 = unsafe { Nonsense { int_32_ref: &3 }.int_128 };\n-    //~^ ERROR any use of this value will cause an error\n+    //~^ ERROR it is undefined behavior to use this value\n \n     const I32_REF_F32_UNION: f32 = unsafe { Nonsense { int_32_ref: &3 }.float_32 };\n     //~^ ERROR any use of this value will cause an error"}, {"sha": "786338222e3ba8c36149776b5e24251343bb88b7", "filename": "src/test/ui/consts/const-eval/const-pointer-values-in-various-types.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -40,11 +40,13 @@ LL |     const I32_REF_U64_UNION: u64 = unsafe { Nonsense { int_32_ref: &3 }.uin\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: any use of this value will cause an error\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:39:5\n    |\n LL |     const I32_REF_U128_UNION: u128 = unsafe { Nonsense { int_32_ref: &3 }.uint_128 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected initialized plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:42:5\n@@ -78,11 +80,13 @@ LL |     const I32_REF_I64_UNION: i64 = unsafe { Nonsense { int_32_ref: &3 }.int\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: any use of this value will cause an error\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:54:5\n    |\n LL |     const I32_REF_I128_UNION: i128 = unsafe { Nonsense { int_32_ref: &3 }.int_128 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected initialized plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:57:5"}, {"sha": "2bf85e25a21a1d6f7419fcb2ce683609de9e4301", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -16,12 +16,12 @@ enum Enum {\n     A = 0,\n }\n union TransmuteEnum {\n-    a: &'static u8,\n-    out: Enum,\n+    in1: &'static u8,\n+    out1: Enum,\n }\n \n // A pointer is guaranteed non-null\n-const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.out };\n+const BAD_ENUM: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n //~^ ERROR is undefined behavior\n \n // (Potentially) invalid enum discriminant\n@@ -48,8 +48,8 @@ const BAD_ENUM3: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n //~^ ERROR is undefined behavior\n \n-// Undef enum discriminant. In an arry to avoid `Scalar` layout.\n-const BAD_ENUM_UNDEF: [Enum2; 2] = [unsafe { TransmuteEnum2 { in3: () }.out1 }; 2];\n+// Undef enum discriminant.\n+const BAD_ENUM_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n //~^ ERROR is undefined behavior\n \n // Pointer value in an enum with a niche that is not just 0."}, {"sha": "509faaa46f811aa4f0d517ba6b2895120059e3b6", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -1,8 +1,8 @@\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:24:1\n    |\n-LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.out };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -33,8 +33,8 @@ LL | const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:52:1\n    |\n-LL | const BAD_ENUM_UNDEF: [Enum2; 2] = [unsafe { TransmuteEnum2 { in3: () }.out1 }; 2];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes at [0], but expected a valid enum discriminant\n+LL | const BAD_ENUM_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "2bdad3af889dcf0f3a1bb409c959dc5d1e382b33", "filename": "src/test/ui/consts/const-eval/union-const-eval-field.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -34,7 +34,8 @@ const fn read_field2() -> Field2 {\n }\n \n const fn read_field3() -> Field3 {\n-    const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR any use of this value\n+    const FIELD3: Field3 = unsafe { UNION.field3 };\n+    //~^ ERROR it is undefined behavior to use this value\n     FIELD3\n }\n "}, {"sha": "ca7cf2b028ce7e9c21e4c59a8b1d82b0dec5ad06", "filename": "src/test/ui/consts/const-eval/union-const-eval-field.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -1,10 +1,11 @@\n-error: any use of this value will cause an error\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-const-eval-field.rs:37:5\n    |\n-LL |     const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR any use of this value\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+LL |     const FIELD3: Field3 = unsafe { UNION.field3 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected initialized plain (non-pointer) bytes\n    |\n-   = note: #[deny(const_err)] on by default\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "6bd63472b212a287805c5426772825c2c8f21c70", "filename": "src/test/ui/consts/const-eval/union-ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.rs?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -20,7 +20,7 @@ union DummyUnion {\n \n const UNION: DummyUnion = DummyUnion { field1: 1065353216 };\n \n-const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR will cause an error\n+const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR it is undefined behavior to use this value\n \n const FIELD_PATH: Struct = Struct { //~ ERROR it is undefined behavior to use this value\n     a: 42,"}, {"sha": "7cadef246177a557892fee0bc3c7cf6009d3dd06", "filename": "src/test/ui/consts/const-eval/union-ice.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4cf115056e22df2c27fa3fa4744ff14ca798ada/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr?ref=c4cf115056e22df2c27fa3fa4744ff14ca798ada", "patch": "@@ -1,10 +1,10 @@\n-error: any use of this value will cause an error\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ice.rs:23:1\n    |\n-LL | const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR will cause an error\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+LL | const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR it is undefined behavior to use this value\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected initialized plain (non-pointer) bytes\n    |\n-   = note: #[deny(const_err)] on by default\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ice.rs:25:1"}]}