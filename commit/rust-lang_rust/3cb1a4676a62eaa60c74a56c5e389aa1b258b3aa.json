{"sha": "3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa", "node_id": "C_kwDOAAsO6NoAKDNjYjFhNDY3NmE2MmVhYTYwYzc0YTU2YzVlMzg5YWExYjI1OGIzYWE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-05-06T11:30:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-06T11:30:06Z"}, "message": "Rollup merge of #111279 - compiler-errors:core-item-resolve, r=cjgillot\n\nMore robust debug assertions for `Instance::resolve` on built-in traits with non-standard trait items\n\nIn #111264, a user added a new item to the `Future` trait, but the code in [`resolve_associated_item`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ty_utils/instance/fn.resolve_associated_item.html) implicitly assumes that the `Future` trait is defined with only one method (`Future::poll`) and treats the generator body as the implementation of that method.\n\nThis PR adds some debug assertions to make sure that that new methods defined on `Future`/`Generator`/etc. don't accidentally resolve to the wrong item when they are added, and adds a helpful comment guiding a compiler dev (or curious `#![no_core]` user) to what must be done to support adding new associated items to these built-in implementations.\n\nI am open to discuss whether a test should be added, but I chose against it because I opted to make these `bug!()`s instead of, e.g., diagnostics or fatal errors. Arguably it doesn't need a test because it's not a bug that can be triggered by an end user, and internal-facing misuses of core kind of touch on rust-lang/compiler-team#620 -- however, I think the assertions I added in this PR are still a very useful way to make sure this bug doesn't waste debugging resources down the line.\n\nFixes #111264", "tree": {"sha": "5e511705860d6af7a0fdec308dce5ee49ff026c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e511705860d6af7a0fdec308dce5ee49ff026c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkVjo+CRBK7hj4Ov3rIwAAHQQIAA3xq4tk9Lstt5kWCx88eYXO\nka3iND5nTbie6Yi5BkBnkznOD8j54eE1OgOPI6NtbAg14nk30xa0tK2zIPSnEc8D\nsD9RJmEJmxmq0GJdbG4C4xhF/1asxkDhb9GPsTgbFISxmVAtrRjItCqhr9XH+/zi\nHsTBvoiG4PUOJWBYJAJVXgB7B0nnVNkim6/gBHpVFogIZJeC7mOeakLu+z+zOwbi\nTqPTCh5raESmSFp+/iQkgBvgU738H8upaiaQD0nRwKftnaVkVOtBIVIYULAFZiY/\nBF1b1dc1NFiD9gad4GKJwwAVe3m1ULvUHxSd3y3Xlxbd0S7xkolwE28SF/U4jh8=\n=WA6y\n-----END PGP SIGNATURE-----\n", "payload": "tree 5e511705860d6af7a0fdec308dce5ee49ff026c2\nparent 83b29ec743924dc3944ca2a50312ecbdef153588\nparent 2a1ef34223a17dbe6192ccba13d2ec4bd57a56b9\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1683372606 +0200\ncommitter GitHub <noreply@github.com> 1683372606 +0200\n\nRollup merge of #111279 - compiler-errors:core-item-resolve, r=cjgillot\n\nMore robust debug assertions for `Instance::resolve` on built-in traits with non-standard trait items\n\nIn #111264, a user added a new item to the `Future` trait, but the code in [`resolve_associated_item`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ty_utils/instance/fn.resolve_associated_item.html) implicitly assumes that the `Future` trait is defined with only one method (`Future::poll`) and treats the generator body as the implementation of that method.\n\nThis PR adds some debug assertions to make sure that that new methods defined on `Future`/`Generator`/etc. don't accidentally resolve to the wrong item when they are added, and adds a helpful comment guiding a compiler dev (or curious `#![no_core]` user) to what must be done to support adding new associated items to these built-in implementations.\n\nI am open to discuss whether a test should be added, but I chose against it because I opted to make these `bug!()`s instead of, e.g., diagnostics or fatal errors. Arguably it doesn't need a test because it's not a bug that can be triggered by an end user, and internal-facing misuses of core kind of touch on rust-lang/compiler-team#620 -- however, I think the assertions I added in this PR are still a very useful way to make sure this bug doesn't waste debugging resources down the line.\n\nFixes #111264\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa", "html_url": "https://github.com/rust-lang/rust/commit/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83b29ec743924dc3944ca2a50312ecbdef153588", "url": "https://api.github.com/repos/rust-lang/rust/commits/83b29ec743924dc3944ca2a50312ecbdef153588", "html_url": "https://github.com/rust-lang/rust/commit/83b29ec743924dc3944ca2a50312ecbdef153588"}, {"sha": "2a1ef34223a17dbe6192ccba13d2ec4bd57a56b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a1ef34223a17dbe6192ccba13d2ec4bd57a56b9", "html_url": "https://github.com/rust-lang/rust/commit/2a1ef34223a17dbe6192ccba13d2ec4bd57a56b9"}], "stats": {"total": 87, "additions": 73, "deletions": 14}, "files": [{"sha": "6c8f4af7594349904aa07aae527ecc493b44adab", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa", "patch": "@@ -385,7 +385,7 @@ impl<'tcx> Instance<'tcx> {\n     /// couldn't complete due to errors elsewhere - this is distinct\n     /// from `Ok(None)` to avoid misleading diagnostics when an error\n     /// has already been/will be emitted, for the original cause\n-    #[instrument(level = \"debug\", skip(tcx))]\n+    #[instrument(level = \"debug\", skip(tcx), ret)]\n     pub fn resolve(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "b97ec6c684b493d4df3d6f702199b7acd5b80b2b", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa", "patch": "@@ -1207,6 +1207,7 @@ symbols! {\n         require,\n         residual,\n         result,\n+        resume,\n         return_position_impl_trait_in_trait,\n         return_type_notation,\n         rhs,"}, {"sha": "b10aaad5f2af41fdc5a5e38ce2db87c639b6c091", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 71, "deletions": 13, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa", "patch": "@@ -177,15 +177,55 @@ fn resolve_associated_item<'tcx>(\n \n             Some(ty::Instance::new(leaf_def.item.def_id, substs))\n         }\n-        traits::ImplSource::Generator(generator_data) => Some(Instance {\n-            def: ty::InstanceDef::Item(generator_data.generator_def_id),\n-            substs: generator_data.substs,\n-        }),\n-        traits::ImplSource::Future(future_data) => Some(Instance {\n-            def: ty::InstanceDef::Item(future_data.generator_def_id),\n-            substs: future_data.substs,\n-        }),\n+        traits::ImplSource::Generator(generator_data) => {\n+            if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::resume {\n+                // For compiler developers who'd like to add new items to `Generator`,\n+                // you either need to generate a shim body, or perhaps return\n+                // `InstanceDef::Item` pointing to a trait default method body if\n+                // it is given a default implementation by the trait.\n+                span_bug!(\n+                    tcx.def_span(generator_data.generator_def_id),\n+                    \"no definition for `{trait_ref}::{}` for built-in generator type\",\n+                    tcx.item_name(trait_item_id)\n+                )\n+            }\n+            Some(Instance {\n+                def: ty::InstanceDef::Item(generator_data.generator_def_id),\n+                substs: generator_data.substs,\n+            })\n+        }\n+        traits::ImplSource::Future(future_data) => {\n+            if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::poll {\n+                // For compiler developers who'd like to add new items to `Future`,\n+                // you either need to generate a shim body, or perhaps return\n+                // `InstanceDef::Item` pointing to a trait default method body if\n+                // it is given a default implementation by the trait.\n+                span_bug!(\n+                    tcx.def_span(future_data.generator_def_id),\n+                    \"no definition for `{trait_ref}::{}` for built-in async generator type\",\n+                    tcx.item_name(trait_item_id)\n+                )\n+            }\n+            Some(Instance {\n+                def: ty::InstanceDef::Item(future_data.generator_def_id),\n+                substs: future_data.substs,\n+            })\n+        }\n         traits::ImplSource::Closure(closure_data) => {\n+            if cfg!(debug_assertions)\n+                && ![sym::call, sym::call_mut, sym::call_once]\n+                    .contains(&tcx.item_name(trait_item_id))\n+            {\n+                // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n+                // you either need to generate a shim body, or perhaps return\n+                // `InstanceDef::Item` pointing to a trait default method body if\n+                // it is given a default implementation by the trait.\n+                span_bug!(\n+                    tcx.def_span(closure_data.closure_def_id),\n+                    \"no definition for `{trait_ref}::{}` for built-in closure type\",\n+                    tcx.item_name(trait_item_id)\n+                )\n+            }\n             let trait_closure_kind = tcx.fn_trait_kind_from_def_id(trait_id).unwrap();\n             Instance::resolve_closure(\n                 tcx,\n@@ -195,11 +235,29 @@ fn resolve_associated_item<'tcx>(\n             )\n         }\n         traits::ImplSource::FnPointer(ref data) => match data.fn_ty.kind() {\n-            ty::FnDef(..) | ty::FnPtr(..) => Some(Instance {\n-                def: ty::InstanceDef::FnPtrShim(trait_item_id, data.fn_ty),\n-                substs: rcvr_substs,\n-            }),\n-            _ => None,\n+            ty::FnDef(..) | ty::FnPtr(..) => {\n+                if cfg!(debug_assertions)\n+                    && ![sym::call, sym::call_mut, sym::call_once]\n+                        .contains(&tcx.item_name(trait_item_id))\n+                {\n+                    // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n+                    // you either need to generate a shim body, or perhaps return\n+                    // `InstanceDef::Item` pointing to a trait default method body if\n+                    // it is given a default implementation by the trait.\n+                    bug!(\n+                        \"no definition for `{trait_ref}::{}` for built-in fn type\",\n+                        tcx.item_name(trait_item_id)\n+                    )\n+                }\n+                Some(Instance {\n+                    def: ty::InstanceDef::FnPtrShim(trait_item_id, data.fn_ty),\n+                    substs: rcvr_substs,\n+                })\n+            }\n+            _ => bug!(\n+                \"no built-in definition for `{trait_ref}::{}` for non-fn type\",\n+                tcx.item_name(trait_item_id)\n+            ),\n         },\n         traits::ImplSource::Object(ref data) => {\n             traits::get_vtable_index_of_object_method(tcx, data, trait_item_id).map(|index| {"}]}