{"sha": "00f95468c4abd82cf71dc17004e1fd2e6cc72213", "node_id": "C_kwDOAAsO6NoAKDAwZjk1NDY4YzRhYmQ4MmNmNzFkYzE3MDA0ZTFmZDJlNmNjNzIyMTM", "commit": {"author": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-08T16:23:31Z"}, "committer": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-27T18:29:19Z"}, "message": "Migrate even more diagnostics in rustc_parse to diagnostic structs", "tree": {"sha": "518ea60c942a15af8959d6596f5758be812635cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/518ea60c942a15af8959d6596f5758be812635cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00f95468c4abd82cf71dc17004e1fd2e6cc72213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00f95468c4abd82cf71dc17004e1fd2e6cc72213", "html_url": "https://github.com/rust-lang/rust/commit/00f95468c4abd82cf71dc17004e1fd2e6cc72213", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00f95468c4abd82cf71dc17004e1fd2e6cc72213/comments", "author": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "760c4352d6c8a85bc3d692769fac6a3e14b9c053", "url": "https://api.github.com/repos/rust-lang/rust/commits/760c4352d6c8a85bc3d692769fac6a3e14b9c053", "html_url": "https://github.com/rust-lang/rust/commit/760c4352d6c8a85bc3d692769fac6a3e14b9c053"}], "stats": {"total": 608, "additions": 395, "deletions": 213}, "files": [{"sha": "e45094d72bc3cc134f065a6c8d8f61ba5ffe4313", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/00f95468c4abd82cf71dc17004e1fd2e6cc72213/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/00f95468c4abd82cf71dc17004e1fd2e6cc72213/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=00f95468c4abd82cf71dc17004e1fd2e6cc72213", "patch": "@@ -316,3 +316,56 @@ parser_expected_semi_found_str = expected `;`, found `{$token_str}`\n parser_sugg_change_this_to_semi = change this to `;`\n parser_sugg_add_semi = add `;` here\n parser_label_unexpected_token = unexpected token\n+\n+parser_unmatched_angle_brackets = {$num_extra_brackets ->\n+        [one] unmatched angle bracket\n+       *[other] unmatched angle brackets\n+    }\n+    .suggestion = {$num_extra_brackets ->\n+            [one] remove extra angle bracket\n+           *[other] remove extra angle brackets\n+        }\n+\n+parser_generic_parameters_without_angle_brackets = generic parameters without surrounding angle brackets\n+    .suggestion = surround the type parameters with angle brackets\n+\n+parser_comparison_operators_cannot_be_chained = comparison operators cannot be chained\n+    .sugg_parentheses_for_function_args = or use `(...)` if you meant to specify fn arguments\n+    .sugg_split_comparison = split the comparison into two\n+    .sugg_parenthesize = parenthesize the comparison\n+parser_sugg_turbofish_syntax = use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n+\n+parser_question_mark_in_type = invalid `?` in type\n+    .label = `?` is only allowed on expressions, not types\n+    .suggestion = if you meant to express that the type might not contain a value, use the `Option` wrapper type\n+\n+parser_unexpected_parentheses_in_for_head = unexpected parentheses surrounding `for` loop head\n+    .suggestion = remove parentheses in `for` loop\n+\n+parser_doc_comment_on_param_type = documentation comments cannot be applied to a function parameter's type\n+    .label = doc comments are not allowed here\n+\n+parser_attribute_on_param_type = attributes cannot be applied to a function parameter's type\n+    .label = attributes are not allowed here\n+\n+parser_pattern_method_param_without_body = patterns aren't allowed in methods without bodies\n+    .suggestion = give this argument a name or use an underscore to ignore it\n+\n+parser_self_param_not_first = unexpected `self` parameter in function\n+    .label = must be the first parameter of an associated function\n+\n+parser_const_generic_without_braces = expressions must be enclosed in braces to be used as const generic arguments\n+    .suggestion = enclose the `const` expression in braces\n+\n+parser_unexpected_const_param_declaration = unexpected `const` parameter declaration\n+    .label = expected a `const` expression, not a parameter declaration\n+    .suggestion = `const` parameters must be declared for the `impl`\n+\n+parser_unexpected_const_in_generic_param = expected lifetime, type, or constant, found keyword `const`\n+    .suggestion = the `const` keyword is only needed in the definition of the type\n+\n+parser_async_move_order_incorrect = the order of `move` and `async` is incorrect\n+    .suggestion = try switching the order\n+\n+parser_double_colon_in_bound = expected `:` followed by trait or lifetime\n+    .suggestion = use single colon"}, {"sha": "f10b178049b8dbe42d0e5fec32c7be0b0eba6479", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/00f95468c4abd82cf71dc17004e1fd2e6cc72213/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f95468c4abd82cf71dc17004e1fd2e6cc72213/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=00f95468c4abd82cf71dc17004e1fd2e6cc72213", "patch": "@@ -1032,3 +1032,214 @@ pub(crate) struct StructLiteralBodyWithoutPathSugg {\n     #[suggestion_part(code = \" }}\")]\n     pub after: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unmatched_angle_brackets)]\n+pub(crate) struct UnmatchedAngleBrackets {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub num_extra_brackets: usize,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::generic_parameters_without_angle_brackets)]\n+pub(crate) struct GenericParamsWithoutAngleBrackets {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: GenericParamsWithoutAngleBracketsSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct GenericParamsWithoutAngleBracketsSugg {\n+    #[suggestion_part(code = \"<\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \">\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::comparison_operators_cannot_be_chained)]\n+pub(crate) struct ComparisonOperatorsCannotBeChained {\n+    #[primary_span]\n+    pub span: Vec<Span>,\n+    #[suggestion_verbose(\n+        parser::sugg_turbofish_syntax,\n+        code = \"::\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    pub suggest_turbofish: Option<Span>,\n+    #[help(parser::sugg_turbofish_syntax)]\n+    #[help(parser::sugg_parentheses_for_function_args)]\n+    pub help_turbofish: Option<()>,\n+    #[subdiagnostic]\n+    pub chaining_sugg: Option<ComparisonOperatorsCannotBeChainedSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum ComparisonOperatorsCannotBeChainedSugg {\n+    #[suggestion_verbose(\n+        parser::sugg_split_comparison,\n+        code = \" && {middle_term}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    SplitComparison {\n+        #[primary_span]\n+        span: Span,\n+        middle_term: String,\n+    },\n+    #[multipart_suggestion(parser::sugg_parenthesize, applicability = \"maybe-incorrect\")]\n+    Parenthesize {\n+        #[suggestion_part(code = \"(\")]\n+        left: Span,\n+        #[suggestion_part(code = \")\")]\n+        right: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::question_mark_in_type)]\n+pub(crate) struct QuestionMarkInType {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: QuestionMarkInTypeSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct QuestionMarkInTypeSugg {\n+    #[suggestion_part(code = \"Option<\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \">\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unexpected_parentheses_in_for_head)]\n+pub(crate) struct ParenthesesInForHead {\n+    #[primary_span]\n+    pub span: Vec<Span>,\n+    #[subdiagnostic]\n+    pub sugg: ParenthesesInForHeadSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct ParenthesesInForHeadSugg {\n+    #[suggestion_part(code = \"\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \"\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::doc_comment_on_param_type)]\n+pub(crate) struct DocCommentOnParamType {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::attribute_on_param_type)]\n+pub(crate) struct AttributeOnParamType {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::pattern_method_param_without_body, code = \"E0642\")]\n+pub(crate) struct PatternMethodParamWithoutBody {\n+    #[primary_span]\n+    #[suggestion(code = \"_\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::self_param_not_first)]\n+pub(crate) struct SelfParamNotFirst {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::const_generic_without_braces)]\n+pub(crate) struct ConstGenericWithoutBraces {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: ConstGenericWithoutBracesSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct ConstGenericWithoutBracesSugg {\n+    #[suggestion_part(code = \"{{ \")]\n+    pub left: Span,\n+    #[suggestion_part(code = \" }}\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unexpected_const_param_declaration)]\n+pub(crate) struct UnexpectedConstParamDeclaration {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: Option<UnexpectedConstParamDeclarationSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum UnexpectedConstParamDeclarationSugg {\n+    #[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+    AddParam {\n+        #[suggestion_part(code = \"<{snippet}>\")]\n+        impl_generics: Span,\n+        #[suggestion_part(code = \"{ident}\")]\n+        incorrect_decl: Span,\n+        snippet: String,\n+        ident: String,\n+    },\n+    #[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+    AppendParam {\n+        #[suggestion_part(code = \", {snippet}\")]\n+        impl_generics_end: Span,\n+        #[suggestion_part(code = \"{ident}\")]\n+        incorrect_decl: Span,\n+        snippet: String,\n+        ident: String,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unexpected_const_in_generic_param)]\n+pub(crate) struct UnexpectedConstInGenericParam {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion_verbose(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub to_remove: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::async_move_order_incorrect)]\n+pub(crate) struct AsyncMoveOrderIncorrect {\n+    #[primary_span]\n+    #[suggestion_verbose(code = \"async move\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::double_colon_in_bound)]\n+pub(crate) struct DoubleColonInBound {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \": \", applicability = \"machine-applicable\")]\n+    pub between: Span,\n+}"}, {"sha": "ccba01630be16baf0ab54009966959a039f752b1", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 109, "deletions": 193, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/00f95468c4abd82cf71dc17004e1fd2e6cc72213/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f95468c4abd82cf71dc17004e1fd2e6cc72213/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=00f95468c4abd82cf71dc17004e1fd2e6cc72213", "patch": "@@ -4,10 +4,17 @@ use super::{\n     TokenExpectType, TokenType,\n };\n use crate::errors::{\n-    AmbiguousPlus, BadQPathStage2, BadTypePlus, BadTypePlusSub, ExpectedIdentifier, ExpectedSemi,\n-    ExpectedSemiSugg, InInTypo, IncorrectAwait, IncorrectSemicolon, IncorrectUseOfAwait,\n-    StructLiteralBodyWithoutPath, StructLiteralBodyWithoutPathSugg, SuggEscapeToUseAsIdentifier,\n-    SuggRemoveComma, UseEqInstead,\n+    AmbiguousPlus, AttributeOnParamType, BadQPathStage2, BadTypePlus, BadTypePlusSub,\n+    ComparisonOperatorsCannotBeChained, ComparisonOperatorsCannotBeChainedSugg,\n+    ConstGenericWithoutBraces, ConstGenericWithoutBracesSugg, DocCommentOnParamType,\n+    DoubleColonInBound, ExpectedIdentifier, ExpectedSemi, ExpectedSemiSugg,\n+    GenericParamsWithoutAngleBrackets, GenericParamsWithoutAngleBracketsSugg, InInTypo,\n+    IncorrectAwait, IncorrectSemicolon, IncorrectUseOfAwait, ParenthesesInForHead,\n+    ParenthesesInForHeadSugg, PatternMethodParamWithoutBody, QuestionMarkInType,\n+    QuestionMarkInTypeSugg, SelfParamNotFirst, StructLiteralBodyWithoutPath,\n+    StructLiteralBodyWithoutPathSugg, SuggEscapeToUseAsIdentifier, SuggRemoveComma,\n+    UnexpectedConstInGenericParam, UnexpectedConstParamDeclaration,\n+    UnexpectedConstParamDeclarationSugg, UnmatchedAngleBrackets, UseEqInstead,\n };\n \n use crate::lexer::UnmatchedBrace;\n@@ -22,10 +29,10 @@ use rustc_ast::{\n };\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed, IntoDiagnostic};\n use rustc_errors::{\n-    Applicability, DiagnosticBuilder, DiagnosticMessage, Handler, MultiSpan, PResult,\n+    fluent, Applicability, DiagnosticBuilder, DiagnosticMessage, Handler, MultiSpan, PResult,\n };\n+use rustc_errors::{pluralize, Diagnostic, ErrorGuaranteed, IntoDiagnostic};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, SpanSnippetError, DUMMY_SP};\n@@ -35,9 +42,6 @@ use std::mem::take;\n \n use crate::parser;\n \n-const TURBOFISH_SUGGESTION_STR: &str =\n-    \"use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\";\n-\n /// Creates a placeholder argument.\n pub(super) fn dummy_arg(ident: Ident) -> Param {\n     let pat = P(Pat {\n@@ -846,18 +850,8 @@ impl<'a> Parser<'a> {\n             self.eat_to_tokens(end);\n             let span = lo.until(self.token.span);\n \n-            let total_num_of_gt = number_of_gt + number_of_shr * 2;\n-            self.struct_span_err(\n-                span,\n-                &format!(\"unmatched angle bracket{}\", pluralize!(total_num_of_gt)),\n-            )\n-            .span_suggestion(\n-                span,\n-                &format!(\"remove extra angle bracket{}\", pluralize!(total_num_of_gt)),\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            let num_extra_brackets = number_of_gt + number_of_shr * 2;\n+            self.sess.emit_err(UnmatchedAngleBrackets { span, num_extra_brackets });\n             return true;\n         }\n         false\n@@ -886,19 +880,13 @@ impl<'a> Parser<'a> {\n                         let args = AngleBracketedArgs { args, span }.into();\n                         segment.args = args;\n \n-                        self.struct_span_err(\n+                        self.sess.emit_err(GenericParamsWithoutAngleBrackets {\n                             span,\n-                            \"generic parameters without surrounding angle brackets\",\n-                        )\n-                        .multipart_suggestion(\n-                            \"surround the type parameters with angle brackets\",\n-                            vec![\n-                                (span.shrink_to_lo(), \"<\".to_string()),\n-                                (trailing_span, \">\".to_string()),\n-                            ],\n-                            Applicability::MachineApplicable,\n-                        )\n-                        .emit();\n+                            sugg: GenericParamsWithoutAngleBracketsSugg {\n+                                left: span.shrink_to_lo(),\n+                                right: trailing_span,\n+                            },\n+                        });\n                     } else {\n                         // This doesn't look like an invalid turbofish, can't recover parse state.\n                         self.restore_snapshot(snapshot);\n@@ -935,7 +923,7 @@ impl<'a> Parser<'a> {\n                     if self.eat(&token::Gt) {\n                         e.span_suggestion_verbose(\n                             binop.span.shrink_to_lo(),\n-                            TURBOFISH_SUGGESTION_STR,\n+                            fluent::parser::sugg_turbofish_syntax,\n                             \"::\",\n                             Applicability::MaybeIncorrect,\n                         )\n@@ -967,7 +955,7 @@ impl<'a> Parser<'a> {\n     /// parenthesising the leftmost comparison.\n     fn attempt_chained_comparison_suggestion(\n         &mut self,\n-        err: &mut Diagnostic,\n+        err: &mut ComparisonOperatorsCannotBeChained,\n         inner_op: &Expr,\n         outer_op: &Spanned<AssocOp>,\n     ) -> bool /* advanced the cursor */ {\n@@ -980,16 +968,6 @@ impl<'a> Parser<'a> {\n                 // suggestion being the only one to apply is high.\n                 return false;\n             }\n-            let mut enclose = |left: Span, right: Span| {\n-                err.multipart_suggestion(\n-                    \"parenthesize the comparison\",\n-                    vec![\n-                        (left.shrink_to_lo(), \"(\".to_string()),\n-                        (right.shrink_to_hi(), \")\".to_string()),\n-                    ],\n-                    Applicability::MaybeIncorrect,\n-                );\n-            };\n             return match (op.node, &outer_op.node) {\n                 // `x == y == z`\n                 (BinOpKind::Eq, AssocOp::Equal) |\n@@ -1003,12 +981,10 @@ impl<'a> Parser<'a> {\n                         self.span_to_snippet(e.span)\n                             .unwrap_or_else(|_| pprust::expr_to_string(&e))\n                     };\n-                    err.span_suggestion_verbose(\n-                        inner_op.span.shrink_to_hi(),\n-                        \"split the comparison into two\",\n-                        format!(\" && {}\", expr_to_str(&r1)),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    err.chaining_sugg = Some(ComparisonOperatorsCannotBeChainedSugg::SplitComparison {\n+                        span: inner_op.span.shrink_to_hi(),\n+                        middle_term: expr_to_str(&r1),\n+                    });\n                     false // Keep the current parse behavior, where the AST is `(x < y) < z`.\n                 }\n                 // `x == y < z`\n@@ -1019,7 +995,10 @@ impl<'a> Parser<'a> {\n                         Ok(r2) => {\n                             // We are sure that outer-op-rhs could be consumed, the suggestion is\n                             // likely correct.\n-                            enclose(r1.span, r2.span);\n+                            err.chaining_sugg = Some(ComparisonOperatorsCannotBeChainedSugg::Parenthesize {\n+                                left: r1.span.shrink_to_lo(),\n+                                right: r2.span.shrink_to_hi(),\n+                            });\n                             true\n                         }\n                         Err(expr_err) => {\n@@ -1036,7 +1015,10 @@ impl<'a> Parser<'a> {\n                     // further checks are necessary.\n                     match self.parse_expr() {\n                         Ok(_) => {\n-                            enclose(l1.span, r1.span);\n+                            err.chaining_sugg = Some(ComparisonOperatorsCannotBeChainedSugg::Parenthesize {\n+                                left: l1.span.shrink_to_lo(),\n+                                right: r1.span.shrink_to_hi(),\n+                            });\n                             true\n                         }\n                         Err(expr_err) => {\n@@ -1085,18 +1067,11 @@ impl<'a> Parser<'a> {\n \n         match inner_op.kind {\n             ExprKind::Binary(op, ref l1, ref r1) if op.node.is_comparison() => {\n-                let mut err = self.struct_span_err(\n-                    vec![op.span, self.prev_token.span],\n-                    \"comparison operators cannot be chained\",\n-                );\n-\n-                let suggest = |err: &mut Diagnostic| {\n-                    err.span_suggestion_verbose(\n-                        op.span.shrink_to_lo(),\n-                        TURBOFISH_SUGGESTION_STR,\n-                        \"::\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                let mut err = ComparisonOperatorsCannotBeChained {\n+                    span: vec![op.span, self.prev_token.span],\n+                    suggest_turbofish: None,\n+                    help_turbofish: None,\n+                    chaining_sugg: None,\n                 };\n \n                 // Include `<` to provide this recommendation even in a case like\n@@ -1123,7 +1098,7 @@ impl<'a> Parser<'a> {\n                     return if token::ModSep == self.token.kind {\n                         // We have some certainty that this was a bad turbofish at this point.\n                         // `foo< bar >::`\n-                        suggest(&mut err);\n+                        err.suggest_turbofish = Some(op.span.shrink_to_lo());\n \n                         let snapshot = self.create_snapshot_for_diagnostic();\n                         self.bump(); // `::`\n@@ -1132,7 +1107,7 @@ impl<'a> Parser<'a> {\n                         match self.parse_expr() {\n                             Ok(_) => {\n                                 // 99% certain that the suggestion is correct, continue parsing.\n-                                err.emit();\n+                                self.sess.emit_err(err);\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n@@ -1143,18 +1118,18 @@ impl<'a> Parser<'a> {\n                                 // Not entirely sure now, but we bubble the error up with the\n                                 // suggestion.\n                                 self.restore_snapshot(snapshot);\n-                                Err(err)\n+                                Err(err.into_diagnostic(&self.sess.span_diagnostic))\n                             }\n                         }\n                     } else if token::OpenDelim(Delimiter::Parenthesis) == self.token.kind {\n                         // We have high certainty that this was a bad turbofish at this point.\n                         // `foo< bar >(`\n-                        suggest(&mut err);\n+                        err.suggest_turbofish = Some(op.span.shrink_to_lo());\n                         // Consume the fn call arguments.\n                         match self.consume_fn_args() {\n-                            Err(()) => Err(err),\n+                            Err(()) => Err(err.into_diagnostic(&self.sess.span_diagnostic)),\n                             Ok(()) => {\n-                                err.emit();\n+                                self.sess.emit_err(err);\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n@@ -1167,25 +1142,24 @@ impl<'a> Parser<'a> {\n                         {\n                             // All we know is that this is `foo < bar >` and *nothing* else. Try to\n                             // be helpful, but don't attempt to recover.\n-                            err.help(TURBOFISH_SUGGESTION_STR);\n-                            err.help(\"or use `(...)` if you meant to specify fn arguments\");\n+                            err.help_turbofish = Some(());\n                         }\n \n                         // If it looks like a genuine attempt to chain operators (as opposed to a\n                         // misformatted turbofish, for instance), suggest a correct form.\n                         if self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op)\n                         {\n-                            err.emit();\n+                            self.sess.emit_err(err);\n                             mk_err_expr(self, inner_op.span.to(self.prev_token.span))\n                         } else {\n                             // These cases cause too many knock-down errors, bail out (#61329).\n-                            Err(err)\n+                            Err(err.into_diagnostic(&self.sess.span_diagnostic))\n                         }\n                     };\n                 }\n                 let recover =\n                     self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op);\n-                err.emit();\n+                self.sess.emit_err(err);\n                 if recover {\n                     return mk_err_expr(self, inner_op.span.to(self.prev_token.span));\n                 }\n@@ -1226,17 +1200,13 @@ impl<'a> Parser<'a> {\n     pub(super) fn maybe_recover_from_question_mark(&mut self, ty: P<Ty>) -> P<Ty> {\n         if self.token == token::Question {\n             self.bump();\n-            self.struct_span_err(self.prev_token.span, \"invalid `?` in type\")\n-                .span_label(self.prev_token.span, \"`?` is only allowed on expressions, not types\")\n-                .multipart_suggestion(\n-                    \"if you meant to express that the type might not contain a value, use the `Option` wrapper type\",\n-                    vec![\n-                        (ty.span.shrink_to_lo(), \"Option<\".to_string()),\n-                        (self.prev_token.span, \">\".to_string()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(QuestionMarkInType {\n+                span: self.prev_token.span,\n+                sugg: QuestionMarkInTypeSugg {\n+                    left: ty.span.shrink_to_lo(),\n+                    right: self.prev_token.span,\n+                },\n+            });\n             self.mk_ty(ty.span.to(self.prev_token.span), TyKind::Err)\n         } else {\n             ty\n@@ -1660,19 +1630,16 @@ impl<'a> Parser<'a> {\n             (token::CloseDelim(Delimiter::Parenthesis), Some(begin_par_sp)) => {\n                 self.bump();\n \n-                self.struct_span_err(\n-                    MultiSpan::from_spans(vec![begin_par_sp, self.prev_token.span]),\n-                    \"unexpected parentheses surrounding `for` loop head\",\n-                )\n-                .multipart_suggestion(\n-                    \"remove parentheses in `for` loop\",\n-                    vec![(begin_par_sp, String::new()), (self.prev_token.span, String::new())],\n+                self.sess.emit_err(ParenthesesInForHead {\n+                    span: vec![begin_par_sp, self.prev_token.span],\n                     // With e.g. `for (x) in y)` this would replace `(x) in y)`\n                     // with `x) in y)` which is syntactically invalid.\n                     // However, this is prevented before we get here.\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+                    sugg: ParenthesesInForHeadSugg {\n+                        left: begin_par_sp,\n+                        right: self.prev_token.span,\n+                    },\n+                });\n \n                 // Unwrap `(pat)` into `pat` to avoid the `unused_parens` lint.\n                 pat.and_then(|pat| match pat.kind {\n@@ -1891,12 +1858,7 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn eat_incorrect_doc_comment_for_param_type(&mut self) {\n         if let token::DocComment(..) = self.token.kind {\n-            self.struct_span_err(\n-                self.token.span,\n-                \"documentation comments cannot be applied to a function parameter's type\",\n-            )\n-            .span_label(self.token.span, \"doc comments are not allowed here\")\n-            .emit();\n+            self.sess.emit_err(DocCommentOnParamType { span: self.token.span });\n             self.bump();\n         } else if self.token == token::Pound\n             && self.look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Bracket))\n@@ -1908,9 +1870,7 @@ impl<'a> Parser<'a> {\n             }\n             let sp = lo.to(self.token.span);\n             self.bump();\n-            self.struct_span_err(sp, \"attributes cannot be applied to a function parameter's type\")\n-                .span_label(sp, \"attributes are not allowed here\")\n-                .emit();\n+            self.sess.emit_err(AttributeOnParamType { span: sp });\n         }\n     }\n \n@@ -2031,19 +1991,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        struct_span_err!(\n-            self.diagnostic(),\n-            pat.span,\n-            E0642,\n-            \"patterns aren't allowed in methods without bodies\",\n-        )\n-        .span_suggestion_short(\n-            pat.span,\n-            \"give this argument a name or use an underscore to ignore it\",\n-            \"_\",\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+        self.sess.emit_err(PatternMethodParamWithoutBody { span: pat.span });\n \n         // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n         let pat =\n@@ -2052,11 +2000,9 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn recover_bad_self_param(&mut self, mut param: Param) -> PResult<'a, Param> {\n-        let sp = param.pat.span;\n+        let span = param.pat.span;\n         param.ty.kind = TyKind::Err;\n-        self.struct_span_err(sp, \"unexpected `self` parameter in function\")\n-            .span_label(sp, \"must be the first parameter of an associated function\")\n-            .emit();\n+        self.sess.emit_err(SelfParamNotFirst { span });\n         Ok(param)\n     }\n \n@@ -2205,20 +2151,13 @@ impl<'a> Parser<'a> {\n             err\n         })?;\n         if !self.expr_is_valid_const_arg(&expr) {\n-            self.struct_span_err(\n-                expr.span,\n-                \"expressions must be enclosed in braces to be used as const generic \\\n-                    arguments\",\n-            )\n-            .multipart_suggestion(\n-                \"enclose the `const` expression in braces\",\n-                vec![\n-                    (expr.span.shrink_to_lo(), \"{ \".to_string()),\n-                    (expr.span.shrink_to_hi(), \" }\".to_string()),\n-                ],\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.sess.emit_err(ConstGenericWithoutBraces {\n+                span: expr.span,\n+                sugg: ConstGenericWithoutBracesSugg {\n+                    left: expr.span.shrink_to_lo(),\n+                    right: expr.span.shrink_to_hi(),\n+                },\n+            });\n         }\n         Ok(expr)\n     }\n@@ -2233,24 +2172,30 @@ impl<'a> Parser<'a> {\n                 return None;\n             }\n         };\n-        let mut err =\n-            self.struct_span_err(param.span(), \"unexpected `const` parameter declaration\");\n-        err.span_label(param.span(), \"expected a `const` expression, not a parameter declaration\");\n-        if let (Some(generics), Ok(snippet)) =\n-            (ty_generics, self.sess.source_map().span_to_snippet(param.span()))\n-        {\n-            let (span, sugg) = match &generics.params[..] {\n-                [] => (generics.span, format!(\"<{snippet}>\")),\n-                [.., generic] => (generic.span().shrink_to_hi(), format!(\", {snippet}\")),\n-            };\n-            err.multipart_suggestion(\n-                \"`const` parameters must be declared for the `impl`\",\n-                vec![(span, sugg), (param.span(), param.ident.to_string())],\n-                Applicability::MachineApplicable,\n-            );\n-        }\n+\n+        let ident = param.ident.to_string();\n+        let sugg = match (ty_generics, self.sess.source_map().span_to_snippet(param.span())) {\n+            (Some(Generics { params, span: impl_generics, .. }), Ok(snippet)) => {\n+                Some(match &params[..] {\n+                    [] => UnexpectedConstParamDeclarationSugg::AddParam {\n+                        impl_generics: *impl_generics,\n+                        incorrect_decl: param.span(),\n+                        snippet,\n+                        ident,\n+                    },\n+                    [.., generic] => UnexpectedConstParamDeclarationSugg::AppendParam {\n+                        impl_generics_end: generic.span().shrink_to_hi(),\n+                        incorrect_decl: param.span(),\n+                        snippet,\n+                        ident,\n+                    },\n+                })\n+            }\n+            _ => None,\n+        };\n+        self.sess.emit_err(UnexpectedConstParamDeclaration { span: param.span(), sugg });\n+\n         let value = self.mk_expr_err(param.span());\n-        err.emit();\n         Some(GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value }))\n     }\n \n@@ -2268,20 +2213,15 @@ impl<'a> Parser<'a> {\n         self.bump(); // `const`\n \n         // Detect and recover from the old, pre-RFC2000 syntax for const generics.\n-        let mut err = self\n-            .struct_span_err(start, \"expected lifetime, type, or constant, found keyword `const`\");\n+        let mut err = UnexpectedConstInGenericParam { span: start, to_remove: None };\n         if self.check_const_arg() {\n-            err.span_suggestion_verbose(\n-                start.until(self.token.span),\n-                \"the `const` keyword is only needed in the definition of the type\",\n-                \"\",\n-                Applicability::MaybeIncorrect,\n-            );\n-            err.emit();\n+            err.to_remove = Some(start.until(self.token.span));\n+            self.sess.emit_err(err);\n             Ok(Some(GenericArg::Const(self.parse_const_arg()?)))\n         } else {\n             let after_kw_const = self.token.span;\n-            self.recover_const_arg(after_kw_const, err).map(Some)\n+            self.recover_const_arg(after_kw_const, err.into_diagnostic(&self.sess.span_diagnostic))\n+                .map(Some)\n         }\n     }\n \n@@ -2387,24 +2327,6 @@ impl<'a> Parser<'a> {\n         GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value })\n     }\n \n-    /// Get the diagnostics for the cases where `move async` is found.\n-    ///\n-    /// `move_async_span` starts at the 'm' of the move keyword and ends with the 'c' of the async keyword\n-    pub(super) fn incorrect_move_async_order_found(\n-        &self,\n-        move_async_span: Span,\n-    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let mut err =\n-            self.struct_span_err(move_async_span, \"the order of `move` and `async` is incorrect\");\n-        err.span_suggestion_verbose(\n-            move_async_span,\n-            \"try switching the order\",\n-            \"async move\",\n-            Applicability::MaybeIncorrect,\n-        );\n-        err\n-    }\n-\n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n     /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n     pub(crate) fn maybe_recover_colon_colon_in_pat_typo(\n@@ -2600,17 +2522,11 @@ impl<'a> Parser<'a> {\n                 let (a_span, b_span) = (a.span(), b.span());\n                 let between_span = a_span.shrink_to_hi().to(b_span.shrink_to_lo());\n                 if self.span_to_snippet(between_span).as_ref().map(|a| &a[..]) == Ok(\":: \") {\n-                    let mut err = self.struct_span_err(\n-                        path.span.shrink_to_hi(),\n-                        \"expected `:` followed by trait or lifetime\",\n-                    );\n-                    err.span_suggestion(\n-                        between_span,\n-                        \"use single colon\",\n-                        \": \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                    return Err(err);\n+                    return Err(DoubleColonInBound {\n+                        span: path.span.shrink_to_hi(),\n+                        between: between_span,\n+                    }\n+                    .into_diagnostic(&self.sess.span_diagnostic));\n                 }\n             }\n         }"}, {"sha": "ee9676c8054ee32cc6c0cc6955f24f5999ab7827", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/00f95468c4abd82cf71dc17004e1fd2e6cc72213/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f95468c4abd82cf71dc17004e1fd2e6cc72213/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=00f95468c4abd82cf71dc17004e1fd2e6cc72213", "patch": "@@ -6,25 +6,26 @@ use super::{\n     SemiColonMode, SeqSep, TokenExpectType, TokenType, TrailingToken,\n };\n use crate::errors::{\n-    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, BinaryFloatLiteralNotSupported,\n-    BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct, ComparisonInterpretedAsGeneric,\n-    ComparisonOrShiftInterpretedAsGenericSugg, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n-    ExpectedElseBlock, ExpectedExpressionFoundLet, FieldExpressionWithGeneric,\n-    FloatLiteralRequiresIntegerPart, FoundExprWouldBeStmt, HexadecimalFloatLiteralNotSupported,\n-    IfExpressionMissingCondition, IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub,\n-    IntLiteralTooLarge, InvalidBlockMacroSegment, InvalidComparisonOperator,\n-    InvalidComparisonOperatorSub, InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth,\n-    InvalidIntLiteralWidth, InvalidInterpolatedExpression, InvalidLiteralSuffix,\n-    InvalidLiteralSuffixOnTupleIndex, InvalidLogicalOperator, InvalidLogicalOperatorSub,\n-    InvalidNumLiteralBasePrefix, InvalidNumLiteralSuffix, LabeledLoopInBreak,\n-    LeadingPlusNotSupported, LeftArrowOperator, LifetimeInBorrowExpression,\n-    MacroInvocationWithQualifiedPath, MalformedLoopLabel, MatchArmBodyWithoutBraces,\n-    MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm, MissingInInForLoop,\n-    MissingInInForLoopSub, MissingSemicolonBeforeArray, NoFieldsForFnCall, NotAsNegationOperator,\n-    NotAsNegationOperatorSub, OctalFloatLiteralNotSupported, OuterAttributeNotAllowedOnIfElse,\n-    ParenthesesWithStructFields, RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric,\n-    StructLiteralNotAllowedHere, StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator,\n-    UnexpectedTokenAfterLabel, UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n+    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, AsyncMoveOrderIncorrect,\n+    BinaryFloatLiteralNotSupported, BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct,\n+    ComparisonInterpretedAsGeneric, ComparisonOrShiftInterpretedAsGenericSugg,\n+    DoCatchSyntaxRemoved, DotDotDot, EqFieldInit, ExpectedElseBlock, ExpectedExpressionFoundLet,\n+    FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart, FoundExprWouldBeStmt,\n+    HexadecimalFloatLiteralNotSupported, IfExpressionMissingCondition,\n+    IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub, IntLiteralTooLarge,\n+    InvalidBlockMacroSegment, InvalidComparisonOperator, InvalidComparisonOperatorSub,\n+    InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth, InvalidIntLiteralWidth,\n+    InvalidInterpolatedExpression, InvalidLiteralSuffix, InvalidLiteralSuffixOnTupleIndex,\n+    InvalidLogicalOperator, InvalidLogicalOperatorSub, InvalidNumLiteralBasePrefix,\n+    InvalidNumLiteralSuffix, LabeledLoopInBreak, LeadingPlusNotSupported, LeftArrowOperator,\n+    LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath, MalformedLoopLabel,\n+    MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm,\n+    MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray, NoFieldsForFnCall,\n+    NotAsNegationOperator, NotAsNegationOperatorSub, OctalFloatLiteralNotSupported,\n+    OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n+    RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, StructLiteralNotAllowedHere,\n+    StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedTokenAfterLabel,\n+    UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n };\n use crate::maybe_recover_from_interpolated_ty_qpath;\n \n@@ -2087,7 +2088,8 @@ impl<'a> Parser<'a> {\n             // Check for `move async` and recover\n             if self.check_keyword(kw::Async) {\n                 let move_async_span = self.token.span.with_lo(self.prev_token.span.data().lo);\n-                Err(self.incorrect_move_async_order_found(move_async_span))\n+                Err(AsyncMoveOrderIncorrect { span: move_async_span }\n+                    .into_diagnostic(&self.sess.span_diagnostic))\n             } else {\n                 Ok(CaptureBy::Value)\n             }"}]}