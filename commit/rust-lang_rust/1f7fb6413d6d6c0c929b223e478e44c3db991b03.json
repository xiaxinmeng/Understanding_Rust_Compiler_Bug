{"sha": "1f7fb6413d6d6c0c929b223e478e44c3db991b03", "node_id": "C_kwDOAAsO6NoAKDFmN2ZiNjQxM2Q2ZDZjMGM5MjliMjIzZTQ3OGU0NGMzZGI5OTFiMDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-10T21:01:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-10T21:01:13Z"}, "message": "Auto merge of #95889 - Dylan-DPC:rollup-1cmywu4, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #95566 (Avoid duplication of doc comments in `std::char` constants and functions)\n - #95784 (Suggest replacing `typeof(...)` with an actual type)\n - #95807 (Suggest adding a local for vector to fix borrowck errors)\n - #95849 (Check for git submodules in non-git source tree.)\n - #95852 (Fix missing space in lossy provenance cast lint)\n - #95857 (Allow multiple derefs to be splitted in deref_separator)\n - #95868 (rustdoc: Reduce allocations in a `html::markdown` function)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6ed96232ff4a04c9e539e89fc62993a4828b565b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ed96232ff4a04c9e539e89fc62993a4828b565b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f7fb6413d6d6c0c929b223e478e44c3db991b03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f7fb6413d6d6c0c929b223e478e44c3db991b03", "html_url": "https://github.com/rust-lang/rust/commit/1f7fb6413d6d6c0c929b223e478e44c3db991b03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f7fb6413d6d6c0c929b223e478e44c3db991b03/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "027a232755fa9728e9699337267f6675dfd0a8ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/027a232755fa9728e9699337267f6675dfd0a8ba", "html_url": "https://github.com/rust-lang/rust/commit/027a232755fa9728e9699337267f6675dfd0a8ba"}, {"sha": "fcfecab2d8144005404f4d88a840ee24503d87f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcfecab2d8144005404f4d88a840ee24503d87f3", "html_url": "https://github.com/rust-lang/rust/commit/fcfecab2d8144005404f4d88a840ee24503d87f3"}], "stats": {"total": 568, "additions": 333, "deletions": 235}, "files": [{"sha": "9e5fb674772d5f0d7c9c525c40dbe886c13e784e", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -785,13 +785,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         issued_borrow: &BorrowData<'tcx>,\n         explanation: BorrowExplanation,\n     ) {\n-        let used_in_call =\n-            matches!(explanation, BorrowExplanation::UsedLater(LaterUseKind::Call, _call_span, _));\n+        let used_in_call = matches!(\n+            explanation,\n+            BorrowExplanation::UsedLater(LaterUseKind::Call | LaterUseKind::Other, _call_span, _)\n+        );\n         if !used_in_call {\n             debug!(\"not later used in call\");\n             return;\n         }\n \n+        let use_span =\n+            if let BorrowExplanation::UsedLater(LaterUseKind::Other, use_span, _) = explanation {\n+                Some(use_span)\n+            } else {\n+                None\n+            };\n+\n         let outer_call_loc =\n             if let TwoPhaseActivation::ActivatedAt(loc) = issued_borrow.activation_location {\n                 loc\n@@ -835,7 +844,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"===> outer_call_loc = {:?}, inner_call_loc = {:?}\", outer_call_loc, inner_call_loc);\n \n         let inner_call_span = inner_call_term.source_info.span;\n-        let outer_call_span = outer_call_stmt.either(|s| s.source_info, |t| t.source_info).span;\n+        let outer_call_span = match use_span {\n+            Some(span) => span,\n+            None => outer_call_stmt.either(|s| s.source_info, |t| t.source_info).span,\n+        };\n         if outer_call_span == inner_call_span || !outer_call_span.contains(inner_call_span) {\n             // FIXME: This stops the suggestion in some cases where it should be emitted.\n             //        Fix the spans for those cases so it's emitted correctly.\n@@ -845,8 +857,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             );\n             return;\n         }\n-        err.span_help(inner_call_span, \"try adding a local storing this argument...\");\n-        err.span_help(outer_call_span, \"...and then using that local as the argument to this call\");\n+        err.span_help(\n+            inner_call_span,\n+            &format!(\n+                \"try adding a local storing this{}...\",\n+                if use_span.is_some() { \"\" } else { \" argument\" }\n+            ),\n+        );\n+        err.span_help(\n+            outer_call_span,\n+            &format!(\n+                \"...and then using that local {}\",\n+                if use_span.is_some() { \"here\" } else { \"as the argument to this call\" }\n+            ),\n+        );\n     }\n \n     fn suggest_split_at_mut_if_applicable(\n@@ -1912,10 +1936,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         } else {\n             \"cannot assign twice to immutable variable\"\n         };\n-        if span != assigned_span {\n-            if !from_arg {\n-                err.span_label(assigned_span, format!(\"first assignment to {}\", place_description));\n-            }\n+        if span != assigned_span && !from_arg {\n+            err.span_label(assigned_span, format!(\"first assignment to {}\", place_description));\n         }\n         if let Some(decl) = local_decl\n             && let Some(name) = local_name"}, {"sha": "2b1deb3430456ff737f0e5d2b1b1e7a13afedb35", "filename": "compiler/rustc_error_messages/locales/en-US/diagnostics.ftl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -62,6 +62,7 @@ typeck-functional-record-update-on-non-struct =\n \n typeck-typeof-reserved-keyword-used =\n     `typeof` is a reserved keyword but unimplemented\n+    .suggestion = consider replacing `typeof(...)` with an actual type\n     .label = reserved keyword\n \n typeck-return-stmt-outside-of-fn-body ="}, {"sha": "24b626ad96658080859d6c7e0d04c540b1b03495", "filename": "compiler/rustc_mir_transform/src/deref_separator.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -11,6 +11,8 @@ pub fn deref_finder<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         for (i, stmt) in data.statements.iter_mut().enumerate() {\n             match stmt.kind {\n                 StatementKind::Assign(box (og_place, Rvalue::Ref(region, borrow_knd, place))) => {\n+                    let mut place_local = place.local;\n+                    let mut last_len = 0;\n                     for (idx, (p_ref, p_elem)) in place.iter_projections().enumerate() {\n                         if p_elem == ProjectionElem::Deref && !p_ref.projection.is_empty() {\n                             // The type that we are derefing.\n@@ -23,15 +25,18 @@ pub fn deref_finder<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n                             patch.add_statement(loc, StatementKind::StorageLive(temp));\n \n                             // We are adding current p_ref's projections to our\n-                            // temp value.\n-                            let deref_place =\n-                                Place::from(p_ref.local).project_deeper(p_ref.projection, tcx);\n+                            // temp value, excluding projections we already covered.\n+                            let deref_place = Place::from(place_local)\n+                                .project_deeper(&p_ref.projection[last_len..], tcx);\n                             patch.add_assign(\n                                 loc,\n                                 Place::from(temp),\n                                 Rvalue::Use(Operand::Move(deref_place)),\n                             );\n \n+                            place_local = temp;\n+                            last_len = p_ref.projection.len();\n+\n                             // We are creating a place by using our temp value's location\n                             // and copying derefed values which we need to create new statement.\n                             let temp_place =\n@@ -50,11 +55,6 @@ pub fn deref_finder<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n                             // Since our job with the temp is done it should be gone\n                             let loc = Location { block: block, statement_index: i + 1 };\n                             patch.add_statement(loc, StatementKind::StorageDead(temp));\n-\n-                            // As all projections are off the base projection, if there are\n-                            // multiple derefs in the middle of projection, it might cause\n-                            // unsoundness, to not let that happen we break the loop.\n-                            break;\n                         }\n                     }\n                 }"}, {"sha": "6bae0f2eac9545b5cb1c92d4a6bf84f4526d2e9e", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -2460,8 +2460,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n             hir::TyKind::Typeof(ref e) => {\n-                tcx.sess.emit_err(TypeofReservedKeywordUsed { span: ast_ty.span });\n-                tcx.type_of(tcx.hir().local_def_id(e.hir_id))\n+                let ty = tcx.type_of(tcx.hir().local_def_id(e.hir_id));\n+                let span = ast_ty.span;\n+                tcx.sess.emit_err(TypeofReservedKeywordUsed {\n+                    span,\n+                    ty,\n+                    opt_sugg: Some((span, Applicability::MachineApplicable))\n+                        .filter(|_| ty.is_suggestable()),\n+                });\n+\n+                ty\n             }\n             hir::TyKind::Infer => {\n                 // Infer also appears as the type of arguments or return"}, {"sha": "e73b9c979eb1ab9a0243d7da560a24c85e0fa3d5", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -1012,7 +1012,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     err.help(msg);\n                 }\n                 err.help(\n-                    \"if you can't comply with strict provenance and need to expose the pointer\\\n+                    \"if you can't comply with strict provenance and need to expose the pointer \\\n                     provenance you can use `.expose_addr()` instead\"\n                 );\n "}, {"sha": "1088be5f566571d2ff7039c47a40b04012519dee", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -1,5 +1,7 @@\n //! Errors emitted by typeck.\n+use rustc_errors::Applicability;\n use rustc_macros::SessionDiagnostic;\n+use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(SessionDiagnostic)]\n@@ -127,10 +129,13 @@ pub struct FunctionalRecordUpdateOnNonStruct {\n \n #[derive(SessionDiagnostic)]\n #[error(code = \"E0516\", slug = \"typeck-typeof-reserved-keyword-used\")]\n-pub struct TypeofReservedKeywordUsed {\n+pub struct TypeofReservedKeywordUsed<'tcx> {\n+    pub ty: Ty<'tcx>,\n     #[primary_span]\n     #[label]\n     pub span: Span,\n+    #[suggestion_verbose(message = \"suggestion\", code = \"{ty}\")]\n+    pub opt_sugg: Option<(Span, Applicability)>,\n }\n \n #[derive(SessionDiagnostic)]"}, {"sha": "778f06aeb63e60f37c06546349dc6fa19120f79e", "filename": "library/core/src/char/convert.rs", "status": "modified", "additions": 7, "deletions": 132, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -6,97 +6,22 @@ use crate::fmt;\n use crate::mem::transmute;\n use crate::str::FromStr;\n \n-/// Converts a `u32` to a `char`.\n-///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n-/// `as`:\n-///\n-/// ```\n-/// let c = '\ud83d\udcaf';\n-/// let i = c as u32;\n-///\n-/// assert_eq!(128175, i);\n-/// ```\n-///\n-/// However, the reverse is not true: not all valid [`u32`]s are valid\n-/// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n-/// for a [`char`].\n-///\n-/// For an unsafe version of this function which ignores these checks, see\n-/// [`from_u32_unchecked`].\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_u32(0x2764);\n-///\n-/// assert_eq!(Some('\u2764'), c);\n-/// ```\n-///\n-/// Returning `None` when the input is not a valid [`char`]:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_u32(0x110000);\n-///\n-/// assert_eq!(None, c);\n-/// ```\n-#[doc(alias = \"chr\")]\n+/// Converts a `u32` to a `char`. See [`char::from_u32`].\n #[must_use]\n #[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n-pub const fn from_u32(i: u32) -> Option<char> {\n+pub(super) const fn from_u32(i: u32) -> Option<char> {\n     // FIXME: once Result::ok is const fn, use it here\n     match char_try_from_u32(i) {\n         Ok(c) => Some(c),\n         Err(_) => None,\n     }\n }\n \n-/// Converts a `u32` to a `char`, ignoring validity.\n-///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n-/// `as`:\n-///\n-/// ```\n-/// let c = '\ud83d\udcaf';\n-/// let i = c as u32;\n-///\n-/// assert_eq!(128175, i);\n-/// ```\n-///\n-/// However, the reverse is not true: not all valid [`u32`]s are valid\n-/// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n-/// [`char`], possibly creating an invalid one.\n-///\n-/// # Safety\n-///\n-/// This function is unsafe, as it may construct invalid `char` values.\n-///\n-/// For a safe version of this function, see the [`from_u32`] function.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = unsafe { char::from_u32_unchecked(0x2764) };\n-///\n-/// assert_eq!('\u2764', c);\n-/// ```\n+/// Converts a `u32` to a `char`, ignoring validity. See [`char::from_u32_unchecked`].\n+#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n #[inline]\n #[must_use]\n-#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n-#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n-pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n+pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {\n     // SAFETY: the caller must guarantee that `i` is a valid char value.\n     if cfg!(debug_assertions) { char::from_u32(i).unwrap() } else { unsafe { transmute(i) } }\n }\n@@ -317,60 +242,10 @@ impl fmt::Display for CharTryFromError {\n     }\n }\n \n-/// Converts a digit in the given radix to a `char`.\n-///\n-/// A 'radix' here is sometimes also called a 'base'. A radix of two\n-/// indicates a binary number, a radix of ten, decimal, and a radix of\n-/// sixteen, hexadecimal, to give some common values. Arbitrary\n-/// radices are supported.\n-///\n-/// `from_digit()` will return `None` if the input is not a digit in\n-/// the given radix.\n-///\n-/// # Panics\n-///\n-/// Panics if given a radix larger than 36.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_digit(4, 10);\n-///\n-/// assert_eq!(Some('4'), c);\n-///\n-/// // Decimal 11 is a single digit in base 16\n-/// let c = char::from_digit(11, 16);\n-///\n-/// assert_eq!(Some('b'), c);\n-/// ```\n-///\n-/// Returning `None` when the input is not a digit:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_digit(20, 10);\n-///\n-/// assert_eq!(None, c);\n-/// ```\n-///\n-/// Passing a large radix, causing a panic:\n-///\n-/// ```should_panic\n-/// use std::char;\n-///\n-/// // this panics\n-/// let c = char::from_digit(1, 37);\n-/// ```\n+/// Converts a digit in the given radix to a `char`. See [`char::from_digit`].\n #[inline]\n #[must_use]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n-pub const fn from_digit(num: u32, radix: u32) -> Option<char> {\n+pub(super) const fn from_digit(num: u32, radix: u32) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is too high (maximum 36)\");\n     }"}, {"sha": "71297acd171454d15d9be5ced4a1d78a1cdeb56b", "filename": "library/core/src/char/decode.rs", "status": "modified", "additions": 2, "deletions": 47, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/library%2Fcore%2Fsrc%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/library%2Fcore%2Fsrc%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fdecode.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -30,54 +30,9 @@ pub struct DecodeUtf16Error {\n }\n \n /// Creates an iterator over the UTF-16 encoded code points in `iter`,\n-/// returning unpaired surrogates as `Err`s.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char::decode_utf16;\n-///\n-/// // \ud834\udd1emus<invalid>ic<invalid>\n-/// let v = [\n-///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n-/// ];\n-///\n-/// assert_eq!(\n-///     decode_utf16(v.iter().cloned())\n-///         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n-///         .collect::<Vec<_>>(),\n-///     vec![\n-///         Ok('\ud834\udd1e'),\n-///         Ok('m'), Ok('u'), Ok('s'),\n-///         Err(0xDD1E),\n-///         Ok('i'), Ok('c'),\n-///         Err(0xD834)\n-///     ]\n-/// );\n-/// ```\n-///\n-/// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n-///\n-/// ```\n-/// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n-///\n-/// // \ud834\udd1emus<invalid>ic<invalid>\n-/// let v = [\n-///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n-/// ];\n-///\n-/// assert_eq!(\n-///     decode_utf16(v.iter().cloned())\n-///        .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n-///        .collect::<String>(),\n-///     \"\ud834\udd1emus\ufffdic\ufffd\"\n-/// );\n-/// ```\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+/// returning unpaired surrogates as `Err`s. See [`char::decode_utf16`].\n #[inline]\n-pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n+pub(super) fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n     DecodeUtf16 { iter: iter.into_iter(), buf: None }\n }\n "}, {"sha": "0df23e7bbe695ded0602984d2afc6c2c7ac09305", "filename": "library/core/src/char/mod.rs", "status": "modified", "additions": 45, "deletions": 24, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -23,18 +23,12 @@ mod decode;\n mod methods;\n \n // stable re-exports\n-#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n-pub use self::convert::from_u32_unchecked;\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub use self::convert::CharTryFromError;\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n pub use self::convert::ParseCharError;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::convert::{from_digit, from_u32};\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n-#[stable(feature = \"unicode_version\", since = \"1.45.0\")]\n-pub use crate::unicode::UNICODE_VERSION;\n+pub use self::decode::{DecodeUtf16, DecodeUtf16Error};\n \n // perma-unstable re-exports\n #[unstable(feature = \"char_internals\", reason = \"exposed only for libstd\", issue = \"none\")]\n@@ -89,30 +83,57 @@ const MAX_THREE_B: u32 = 0x10000;\n     Cn  Unassigned              a reserved unassigned code point or a noncharacter\n */\n \n-/// The highest valid code point a `char` can have, `'\\u{10FFFF}'`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # fn something_which_returns_char() -> char { 'a' }\n-/// let c: char = something_which_returns_char();\n-/// assert!(c <= char::MAX);\n-///\n-/// let value_at_max = char::MAX as u32;\n-/// assert_eq!(char::from_u32(value_at_max), Some('\\u{10FFFF}'));\n-/// assert_eq!(char::from_u32(value_at_max + 1), None);\n-/// ```\n+/// The highest valid code point a `char` can have, `'\\u{10FFFF}'`. Use [`char::MAX`] instead.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: char = char::MAX;\n \n /// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a\n-/// decoding error.\n-///\n-/// It can occur, for example, when giving ill-formed UTF-8 bytes to\n-/// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n+/// decoding error. Use [`char::REPLACEMENT_CHARACTER`] instead.\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n pub const REPLACEMENT_CHARACTER: char = char::REPLACEMENT_CHARACTER;\n \n+/// The version of [Unicode](https://www.unicode.org/) that the Unicode parts of\n+/// `char` and `str` methods are based on. Use [`char::UNICODE_VERSION`] instead.\n+#[stable(feature = \"unicode_version\", since = \"1.45.0\")]\n+pub const UNICODE_VERSION: (u8, u8, u8) = char::UNICODE_VERSION;\n+\n+/// Creates an iterator over the UTF-16 encoded code points in `iter`, returning\n+/// unpaired surrogates as `Err`s. Use [`char::decode_utf16`] instead.\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+#[inline]\n+pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n+    self::decode::decode_utf16(iter)\n+}\n+\n+/// Converts a `u32` to a `char`. Use [`char::from_u32`] instead.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+#[must_use]\n+#[inline]\n+pub const fn from_u32(i: u32) -> Option<char> {\n+    self::convert::from_u32(i)\n+}\n+\n+/// Converts a `u32` to a `char`, ignoring validity. Use [`char::from_u32_unchecked`].\n+/// instead.\n+#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n+#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+#[must_use]\n+#[inline]\n+pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n+    // SAFETY: the safety contract must be upheld by the caller.\n+    unsafe { self::convert::from_u32_unchecked(i) }\n+}\n+\n+/// Converts a digit in the given radix to a `char`. Use [`char::from_digit`] instead.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+#[must_use]\n+#[inline]\n+pub const fn from_digit(num: u32, radix: u32) -> Option<char> {\n+    self::convert::from_digit(num, radix)\n+}\n+\n /// Returns an iterator that yields the hexadecimal Unicode escape of a\n /// character, as `char`s.\n ///"}, {"sha": "00dc7da275a43e8d479c18151036793744c76cae", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -1097,8 +1097,19 @@ def update_submodule(self, module, checked_out, recorded_submodules):\n \n     def update_submodules(self):\n         \"\"\"Update submodules\"\"\"\n-        if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n-                self.get_toml('submodules') == \"false\":\n+        has_git = os.path.exists(os.path.join(self.rust_root, \".git\"))\n+        # This just arbitrarily checks for cargo, but any workspace member in\n+        # a submodule would work.\n+        has_submodules = os.path.exists(os.path.join(self.rust_root, \"src/tools/cargo/Cargo.toml\"))\n+        if not has_git and not has_submodules:\n+            print(\"This is not a git repository, and the requisite git submodules were not found.\")\n+            print(\"If you downloaded the source from https://github.com/rust-lang/rust/releases,\")\n+            print(\"those sources will not work. Instead, consider downloading from the source\")\n+            print(\"releases linked at\")\n+            print(\"https://forge.rust-lang.org/infra/other-installation-methods.html#source-code\")\n+            print(\"or clone the repository at https://github.com/rust-lang/rust/.\")\n+            raise SystemExit(1)\n+        if not has_git or self.get_toml('submodules') == \"false\":\n             return\n \n         default_encoding = sys.getdefaultencoding()"}, {"sha": "943c521485b18e8b1e4a9b4d5aa0a8d4134bf867", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -251,7 +251,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n             }\n         }\n         let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n-        let text = lines.collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n+        let text = lines.intersperse(\"\\n\".into()).collect::<String>();\n \n         let parse_result = match kind {\n             CodeBlockKind::Fenced(ref lang) => {\n@@ -291,15 +291,13 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n             let test = origtext\n                 .lines()\n                 .map(|l| map_line(l).for_code())\n-                .collect::<Vec<Cow<'_, str>>>()\n-                .join(\"\\n\");\n+                .intersperse(\"\\n\".into())\n+                .collect::<String>();\n             let krate = krate.as_ref().map(|s| &**s);\n             let (test, _, _) =\n                 doctest::make_test(&test, krate, false, &Default::default(), edition, None);\n             let channel = if test.contains(\"#![feature(\") { \"&amp;version=nightly\" } else { \"\" };\n \n-            let edition_string = format!(\"&amp;edition={}\", edition);\n-\n             // These characters don't need to be escaped in a URI.\n             // FIXME: use a library function for percent encoding.\n             fn dont_escape(c: u8) -> bool {\n@@ -325,8 +323,8 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                 }\n             }\n             Some(format!(\n-                r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}{}\">Run</a>\"#,\n-                url, test_escaped, channel, edition_string\n+                r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}&amp;edition={}\">Run</a>\"#,\n+                url, test_escaped, channel, edition,\n             ))\n         });\n "}, {"sha": "d465724326e463078560663f9e49530212a61d70", "filename": "src/test/mir-opt/derefer_test_multiple.main.Derefer.diff", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fmir-opt%2Fderefer_test_multiple.main.Derefer.diff", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fmir-opt%2Fderefer_test_multiple.main.Derefer.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fderefer_test_multiple.main.Derefer.diff?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -0,0 +1,100 @@\n+- // MIR for `main` before Derefer\n++ // MIR for `main` after Derefer\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/derefer_test_multiple.rs:2:12: 2:12\n+      let mut _1: (i32, i32);              // in scope 0 at $DIR/derefer_test_multiple.rs:3:9: 3:14\n+      let mut _3: &mut (i32, i32);         // in scope 0 at $DIR/derefer_test_multiple.rs:4:22: 4:28\n+      let mut _5: &mut (i32, &mut (i32, i32)); // in scope 0 at $DIR/derefer_test_multiple.rs:5:22: 5:28\n+      let mut _7: &mut (i32, &mut (i32, &mut (i32, i32))); // in scope 0 at $DIR/derefer_test_multiple.rs:6:22: 6:28\n++     let mut _10: &mut (i32, &mut (i32, &mut (i32, i32))); // in scope 0 at $DIR/derefer_test_multiple.rs:7:13: 7:30\n++     let mut _11: &mut (i32, &mut (i32, i32)); // in scope 0 at $DIR/derefer_test_multiple.rs:7:13: 7:30\n++     let mut _12: &mut (i32, i32);        // in scope 0 at $DIR/derefer_test_multiple.rs:7:13: 7:30\n++     let mut _13: &mut (i32, &mut (i32, &mut (i32, i32))); // in scope 0 at $DIR/derefer_test_multiple.rs:8:13: 8:30\n++     let mut _14: &mut (i32, &mut (i32, i32)); // in scope 0 at $DIR/derefer_test_multiple.rs:8:13: 8:30\n++     let mut _15: &mut (i32, i32);        // in scope 0 at $DIR/derefer_test_multiple.rs:8:13: 8:30\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/derefer_test_multiple.rs:3:9: 3:14\n+          let mut _2: (i32, &mut (i32, i32)); // in scope 1 at $DIR/derefer_test_multiple.rs:4:9: 4:14\n+          scope 2 {\n+              debug b => _2;               // in scope 2 at $DIR/derefer_test_multiple.rs:4:9: 4:14\n+              let mut _4: (i32, &mut (i32, &mut (i32, i32))); // in scope 2 at $DIR/derefer_test_multiple.rs:5:9: 5:14\n+              scope 3 {\n+                  debug c => _4;           // in scope 3 at $DIR/derefer_test_multiple.rs:5:9: 5:14\n+                  let mut _6: (i32, &mut (i32, &mut (i32, &mut (i32, i32)))); // in scope 3 at $DIR/derefer_test_multiple.rs:6:9: 6:14\n+                  scope 4 {\n+                      debug d => _6;       // in scope 4 at $DIR/derefer_test_multiple.rs:6:9: 6:14\n+                      let _8: &mut i32;    // in scope 4 at $DIR/derefer_test_multiple.rs:7:9: 7:10\n+                      scope 5 {\n+                          debug x => _8;   // in scope 5 at $DIR/derefer_test_multiple.rs:7:9: 7:10\n+                          let _9: &mut i32; // in scope 5 at $DIR/derefer_test_multiple.rs:8:9: 8:10\n+                          scope 6 {\n+                              debug y => _9; // in scope 6 at $DIR/derefer_test_multiple.rs:8:9: 8:10\n+                          }\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/derefer_test_multiple.rs:3:9: 3:14\n+          (_1.0: i32) = const 42_i32;      // scope 0 at $DIR/derefer_test_multiple.rs:3:17: 3:25\n+          (_1.1: i32) = const 43_i32;      // scope 0 at $DIR/derefer_test_multiple.rs:3:17: 3:25\n+          StorageLive(_2);                 // scope 1 at $DIR/derefer_test_multiple.rs:4:9: 4:14\n+          StorageLive(_3);                 // scope 1 at $DIR/derefer_test_multiple.rs:4:22: 4:28\n+          _3 = &mut _1;                    // scope 1 at $DIR/derefer_test_multiple.rs:4:22: 4:28\n+          (_2.0: i32) = const 99_i32;      // scope 1 at $DIR/derefer_test_multiple.rs:4:17: 4:29\n+          (_2.1: &mut (i32, i32)) = move _3; // scope 1 at $DIR/derefer_test_multiple.rs:4:17: 4:29\n+          StorageDead(_3);                 // scope 1 at $DIR/derefer_test_multiple.rs:4:28: 4:29\n+          StorageLive(_4);                 // scope 2 at $DIR/derefer_test_multiple.rs:5:9: 5:14\n+          StorageLive(_5);                 // scope 2 at $DIR/derefer_test_multiple.rs:5:22: 5:28\n+          _5 = &mut _2;                    // scope 2 at $DIR/derefer_test_multiple.rs:5:22: 5:28\n+          (_4.0: i32) = const 11_i32;      // scope 2 at $DIR/derefer_test_multiple.rs:5:17: 5:29\n+          (_4.1: &mut (i32, &mut (i32, i32))) = move _5; // scope 2 at $DIR/derefer_test_multiple.rs:5:17: 5:29\n+          StorageDead(_5);                 // scope 2 at $DIR/derefer_test_multiple.rs:5:28: 5:29\n+          StorageLive(_6);                 // scope 3 at $DIR/derefer_test_multiple.rs:6:9: 6:14\n+          StorageLive(_7);                 // scope 3 at $DIR/derefer_test_multiple.rs:6:22: 6:28\n+          _7 = &mut _4;                    // scope 3 at $DIR/derefer_test_multiple.rs:6:22: 6:28\n+          (_6.0: i32) = const 13_i32;      // scope 3 at $DIR/derefer_test_multiple.rs:6:17: 6:29\n+          (_6.1: &mut (i32, &mut (i32, &mut (i32, i32)))) = move _7; // scope 3 at $DIR/derefer_test_multiple.rs:6:17: 6:29\n+          StorageDead(_7);                 // scope 3 at $DIR/derefer_test_multiple.rs:6:28: 6:29\n+          StorageLive(_8);                 // scope 4 at $DIR/derefer_test_multiple.rs:7:9: 7:10\n+-         _8 = &mut ((*((*((*(_6.1: &mut (i32, &mut (i32, &mut (i32, i32))))).1: &mut (i32, &mut (i32, i32)))).1: &mut (i32, i32))).1: i32); // scope 4 at $DIR/derefer_test_multiple.rs:7:13: 7:30\n++         StorageLive(_10);                // scope 4 at $DIR/derefer_test_multiple.rs:7:13: 7:30\n++         _10 = move (_6.1: &mut (i32, &mut (i32, &mut (i32, i32)))); // scope 4 at $DIR/derefer_test_multiple.rs:7:13: 7:30\n++         StorageLive(_11);                // scope 4 at $DIR/derefer_test_multiple.rs:7:13: 7:30\n++         _11 = move ((*_10).1: &mut (i32, &mut (i32, i32))); // scope 4 at $DIR/derefer_test_multiple.rs:7:13: 7:30\n++         StorageLive(_12);                // scope 4 at $DIR/derefer_test_multiple.rs:7:13: 7:30\n++         _12 = move ((*_11).1: &mut (i32, i32)); // scope 4 at $DIR/derefer_test_multiple.rs:7:13: 7:30\n++         _8 = &mut ((*_12).1: i32);       // scope 4 at $DIR/derefer_test_multiple.rs:7:13: 7:30\n++         StorageDead(_10);                // scope 5 at $DIR/derefer_test_multiple.rs:8:9: 8:10\n++         StorageDead(_11);                // scope 5 at $DIR/derefer_test_multiple.rs:8:9: 8:10\n++         StorageDead(_12);                // scope 5 at $DIR/derefer_test_multiple.rs:8:9: 8:10\n+          StorageLive(_9);                 // scope 5 at $DIR/derefer_test_multiple.rs:8:9: 8:10\n+-         _9 = &mut ((*((*((*(_6.1: &mut (i32, &mut (i32, &mut (i32, i32))))).1: &mut (i32, &mut (i32, i32)))).1: &mut (i32, i32))).1: i32); // scope 5 at $DIR/derefer_test_multiple.rs:8:13: 8:30\n++         StorageLive(_13);                // scope 5 at $DIR/derefer_test_multiple.rs:8:13: 8:30\n++         _13 = move (_6.1: &mut (i32, &mut (i32, &mut (i32, i32)))); // scope 5 at $DIR/derefer_test_multiple.rs:8:13: 8:30\n++         StorageLive(_14);                // scope 5 at $DIR/derefer_test_multiple.rs:8:13: 8:30\n++         _14 = move ((*_13).1: &mut (i32, &mut (i32, i32))); // scope 5 at $DIR/derefer_test_multiple.rs:8:13: 8:30\n++         StorageLive(_15);                // scope 5 at $DIR/derefer_test_multiple.rs:8:13: 8:30\n++         _15 = move ((*_14).1: &mut (i32, i32)); // scope 5 at $DIR/derefer_test_multiple.rs:8:13: 8:30\n++         _9 = &mut ((*_15).1: i32);       // scope 5 at $DIR/derefer_test_multiple.rs:8:13: 8:30\n++         StorageDead(_13);                // scope 0 at $DIR/derefer_test_multiple.rs:2:12: 9:2\n++         StorageDead(_14);                // scope 0 at $DIR/derefer_test_multiple.rs:2:12: 9:2\n++         StorageDead(_15);                // scope 0 at $DIR/derefer_test_multiple.rs:2:12: 9:2\n+          _0 = const ();                   // scope 0 at $DIR/derefer_test_multiple.rs:2:12: 9:2\n+          StorageDead(_9);                 // scope 5 at $DIR/derefer_test_multiple.rs:9:1: 9:2\n+          StorageDead(_8);                 // scope 4 at $DIR/derefer_test_multiple.rs:9:1: 9:2\n+          StorageDead(_6);                 // scope 3 at $DIR/derefer_test_multiple.rs:9:1: 9:2\n+          StorageDead(_4);                 // scope 2 at $DIR/derefer_test_multiple.rs:9:1: 9:2\n+          StorageDead(_2);                 // scope 1 at $DIR/derefer_test_multiple.rs:9:1: 9:2\n+          StorageDead(_1);                 // scope 0 at $DIR/derefer_test_multiple.rs:9:1: 9:2\n+          return;                          // scope 0 at $DIR/derefer_test_multiple.rs:9:2: 9:2\n++     }\n++ \n++     bb1 (cleanup): {\n++         resume;                          // scope 0 at $DIR/derefer_test_multiple.rs:2:1: 9:2\n+      }\n+  }\n+  "}, {"sha": "a27363447fee590ebb8c287ec50cd6ce27d5aa3f", "filename": "src/test/mir-opt/derefer_test_multiple.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fmir-opt%2Fderefer_test_multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fmir-opt%2Fderefer_test_multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fderefer_test_multiple.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -0,0 +1,9 @@\n+// EMIT_MIR derefer_test_multiple.main.Derefer.diff\n+fn main () {\n+    let mut a = (42, 43);\n+    let mut b = (99, &mut a);\n+    let mut c = (11, &mut b);\n+    let mut d = (13, &mut c);\n+    let x = &mut (*d.1).1.1.1;\n+    let y = &mut (*d.1).1.1.1;\n+}"}, {"sha": "40f013f6a78a767c4b4e7df041a683907e484448", "filename": "src/test/ui/borrowck/suggest-local-var-for-vector.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-for-vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-for-vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-for-vector.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let mut vec = vec![0u32; 420];\n+    vec[vec.len() - 1] = 123; //~ ERROR cannot borrow `vec` as immutable because it is also borrowed as mutable\n+}"}, {"sha": "615fffcd578adbc763965fb09b7eadeee0bbe393", "filename": "src/test/ui/borrowck/suggest-local-var-for-vector.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-for-vector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-for-vector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-for-vector.stderr?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -0,0 +1,24 @@\n+error[E0502]: cannot borrow `vec` as immutable because it is also borrowed as mutable\n+  --> $DIR/suggest-local-var-for-vector.rs:3:9\n+   |\n+LL |     vec[vec.len() - 1] = 123;\n+   |     ----^^^^^^^^^-----\n+   |     |   |\n+   |     |   immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |     mutable borrow later used here\n+   |\n+help: try adding a local storing this...\n+  --> $DIR/suggest-local-var-for-vector.rs:3:9\n+   |\n+LL |     vec[vec.len() - 1] = 123;\n+   |         ^^^^^^^^^\n+help: ...and then using that local here\n+  --> $DIR/suggest-local-var-for-vector.rs:3:5\n+   |\n+LL |     vec[vec.len() - 1] = 123;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "40f013f6a78a767c4b4e7df041a683907e484448", "filename": "src/test/ui/borrowck/suggest-storing-local-var-for-vector.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-storing-local-var-for-vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-storing-local-var-for-vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-storing-local-var-for-vector.rs?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let mut vec = vec![0u32; 420];\n+    vec[vec.len() - 1] = 123; //~ ERROR cannot borrow `vec` as immutable because it is also borrowed as mutable\n+}"}, {"sha": "e3a16eddfd5eca533f9b4a1bf2cfba25660b873c", "filename": "src/test/ui/borrowck/suggest-storing-local-var-for-vector.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-storing-local-var-for-vector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-storing-local-var-for-vector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-storing-local-var-for-vector.stderr?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -0,0 +1,24 @@\n+error[E0502]: cannot borrow `vec` as immutable because it is also borrowed as mutable\n+  --> $DIR/suggest-storing-local-var-for-vector.rs:3:9\n+   |\n+LL |     vec[vec.len() - 1] = 123;\n+   |     ----^^^^^^^^^-----\n+   |     |   |\n+   |     |   immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |     mutable borrow later used here\n+   |\n+help: try adding a local storing this...\n+  --> $DIR/suggest-storing-local-var-for-vector.rs:3:9\n+   |\n+LL |     vec[vec.len() - 1] = 123;\n+   |         ^^^^^^^^^\n+help: ...and then using that local here\n+  --> $DIR/suggest-storing-local-var-for-vector.rs:3:5\n+   |\n+LL |     vec[vec.len() - 1] = 123;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "0f2daaf99d9145a4be74fa3297e84589fa8dcca4", "filename": "src/test/ui/borrowck/two-phase-nonrecv-autoref.nll.stderr", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-nonrecv-autoref.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-nonrecv-autoref.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-nonrecv-autoref.nll.stderr?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -54,6 +54,17 @@ LL |     i[i[3]] = 4;\n    |     | immutable borrow occurs here\n    |     mutable borrow occurs here\n    |     mutable borrow later used here\n+   |\n+help: try adding a local storing this...\n+  --> $DIR/two-phase-nonrecv-autoref.rs:138:7\n+   |\n+LL |     i[i[3]] = 4;\n+   |       ^^^^\n+help: ...and then using that local here\n+  --> $DIR/two-phase-nonrecv-autoref.rs:138:5\n+   |\n+LL |     i[i[3]] = 4;\n+   |     ^^^^^^^\n \n error[E0502]: cannot borrow `i` as immutable because it is also borrowed as mutable\n   --> $DIR/two-phase-nonrecv-autoref.rs:143:7\n@@ -64,6 +75,17 @@ LL |     i[i[3]] = i[4];\n    |     | immutable borrow occurs here\n    |     mutable borrow occurs here\n    |     mutable borrow later used here\n+   |\n+help: try adding a local storing this...\n+  --> $DIR/two-phase-nonrecv-autoref.rs:143:7\n+   |\n+LL |     i[i[3]] = i[4];\n+   |       ^^^^\n+help: ...and then using that local here\n+  --> $DIR/two-phase-nonrecv-autoref.rs:143:5\n+   |\n+LL |     i[i[3]] = i[4];\n+   |     ^^^^^^^\n \n error: aborting due to 7 previous errors\n "}, {"sha": "5243b7caf225b987181ff0d95893538e3749e0e0", "filename": "src/test/ui/error-codes/E0516.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Ferror-codes%2FE0516.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Ferror-codes%2FE0516.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0516.stderr?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -3,6 +3,11 @@ error[E0516]: `typeof` is a reserved keyword but unimplemented\n    |\n LL |     let x: typeof(92) = 92;\n    |            ^^^^^^^^^^ reserved keyword\n+   |\n+help: consider replacing `typeof(...)` with an actual type\n+   |\n+LL |     let x: i32 = 92;\n+   |            ~~~\n \n error: aborting due to previous error\n "}, {"sha": "75b6c64f2ced3f281ef36abf999697b8f5d1212a", "filename": "src/test/ui/issues/issue-29184.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fissues%2Fissue-29184.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Fissues%2Fissue-29184.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29184.stderr?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -3,6 +3,11 @@ error[E0516]: `typeof` is a reserved keyword but unimplemented\n    |\n LL |     let x: typeof(92) = 92;\n    |            ^^^^^^^^^^ reserved keyword\n+   |\n+help: consider replacing `typeof(...)` with an actual type\n+   |\n+LL |     let x: i32 = 92;\n+   |            ~~~\n \n error: aborting due to previous error\n "}, {"sha": "e7a6c1837bd5664112e39e568ddf11f54393f93e", "filename": "src/test/ui/lint/lint-strict-provenance-lossy-casts.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-lossy-casts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-lossy-casts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-lossy-casts.stderr?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -9,15 +9,15 @@ note: the lint level is defined here\n    |\n LL | #![deny(lossy_provenance_casts)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n-   = help: if you can't comply with strict provenance and need to expose the pointerprovenance you can use `.expose_addr()` instead\n+   = help: if you can't comply with strict provenance and need to expose the pointer provenance you can use `.expose_addr()` instead\n \n error: under strict provenance it is considered bad style to cast pointer `*const u8` to integer `u32`\n   --> $DIR/lint-strict-provenance-lossy-casts.rs:9:22\n    |\n LL |     let addr_32bit = &x as *const u8 as u32;\n    |                      ^^^^^^^^^^^^^^^^^^^^^^ help: use `.addr()` to obtain the address of a pointer: `(&x as *const u8).addr() as u32`\n    |\n-   = help: if you can't comply with strict provenance and need to expose the pointerprovenance you can use `.expose_addr()` instead\n+   = help: if you can't comply with strict provenance and need to expose the pointer provenance you can use `.expose_addr()` instead\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e75214cd31a6d41ea073cf570788bfd522730ee2", "filename": "src/test/ui/typeof/type_mismatch.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Ftypeof%2Ftype_mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7fb6413d6d6c0c929b223e478e44c3db991b03/src%2Ftest%2Fui%2Ftypeof%2Ftype_mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeof%2Ftype_mismatch.stderr?ref=1f7fb6413d6d6c0c929b223e478e44c3db991b03", "patch": "@@ -3,6 +3,11 @@ error[E0516]: `typeof` is a reserved keyword but unimplemented\n    |\n LL |     let b: typeof(a) = 1i8;\n    |            ^^^^^^^^^ reserved keyword\n+   |\n+help: consider replacing `typeof(...)` with an actual type\n+   |\n+LL |     let b: u8 = 1i8;\n+   |            ~~\n \n error[E0308]: mismatched types\n   --> $DIR/type_mismatch.rs:5:24"}]}