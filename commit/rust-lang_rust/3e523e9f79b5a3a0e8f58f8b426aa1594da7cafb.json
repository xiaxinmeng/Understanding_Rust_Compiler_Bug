{"sha": "3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "node_id": "C_kwDOAAsO6NoAKDNlNTIzZTlmNzliNWEzYTBlOGY1OGY4YjQyNmFhMTU5NGRhN2NhZmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-24T09:42:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-24T09:42:16Z"}, "message": "Auto merge of #2825 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "a548ef7f3ba80e39f50f9dbad4cb04b2f8f53118", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a548ef7f3ba80e39f50f9dbad4cb04b2f8f53118"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "html_url": "https://github.com/rust-lang/rust/commit/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b0f8745082a36f6408357ec8bfd6c439955cc38", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b0f8745082a36f6408357ec8bfd6c439955cc38", "html_url": "https://github.com/rust-lang/rust/commit/4b0f8745082a36f6408357ec8bfd6c439955cc38"}, {"sha": "817b75042ae7eb416f076977ab07e59cfebcf5b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/817b75042ae7eb416f076977ab07e59cfebcf5b6", "html_url": "https://github.com/rust-lang/rust/commit/817b75042ae7eb416f076977ab07e59cfebcf5b6"}], "stats": {"total": 4550, "additions": 3328, "deletions": 1222}, "files": [{"sha": "449f0c73588eb83a52de26215e0b16b5720dc753", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -4523,6 +4523,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n+ \"serde_json\",\n  \"smallvec\",\n  \"stable_deref_trait\",\n  \"stacker\",\n@@ -4826,6 +4827,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_expand\",\n+ \"rustc_fs_util\",\n  \"rustc_hir\",\n  \"rustc_hir_analysis\",\n  \"rustc_hir_typeck\",\n@@ -4950,6 +4952,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_expand\",\n  \"rustc_feature\",\n+ \"rustc_fs_util\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n@@ -5335,6 +5338,7 @@ dependencies = [\n  \"rustc_abi\",\n  \"rustc_data_structures\",\n  \"rustc_feature\",\n+ \"rustc_fs_util\",\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\","}, {"sha": "c2a426bea092910119133bb100867a7c71b04c29", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -2222,6 +2222,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             }\n                         }\n                     }\n+                    CastKind::Transmute => {\n+                        span_mirbug!(\n+                            self,\n+                            rvalue,\n+                            \"Unexpected CastKind::Transmute, which is not permitted in Analysis MIR\",\n+                        );\n+                    }\n                 }\n             }\n "}, {"sha": "2b6fcc169be067ee2a92555de44aaae52bf654bf", "filename": "compiler/rustc_builtin_macros/src/cmdline_attrs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::{self as ast, AttrItem, AttrStyle};\n use rustc_session::parse::ParseSess;\n use rustc_span::FileName;\n \n-pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -> ast::Crate {\n+pub fn inject(krate: &mut ast::Crate, parse_sess: &ParseSess, attrs: &[String]) {\n     for raw_attr in attrs {\n         let mut parser = rustc_parse::new_parser_from_source_str(\n             parse_sess,\n@@ -36,6 +36,4 @@ pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -\n             start_span.to(end_span),\n         ));\n     }\n-\n-    krate\n }"}, {"sha": "378d5f39f4ab2ecd32f266afdcc602b49be58d24", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -43,14 +43,14 @@ struct CollectProcMacros<'a> {\n }\n \n pub fn inject(\n+    krate: &mut ast::Crate,\n     sess: &Session,\n     resolver: &mut dyn ResolverExpand,\n-    mut krate: ast::Crate,\n     is_proc_macro_crate: bool,\n     has_proc_macro_decls: bool,\n     is_test_crate: bool,\n     handler: &rustc_errors::Handler,\n-) -> ast::Crate {\n+) {\n     let ecfg = ExpansionConfig::default(\"proc_macro\".to_string());\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver, None);\n \n@@ -64,22 +64,20 @@ pub fn inject(\n     };\n \n     if has_proc_macro_decls || is_proc_macro_crate {\n-        visit::walk_crate(&mut collect, &krate);\n+        visit::walk_crate(&mut collect, krate);\n     }\n     let macros = collect.macros;\n \n     if !is_proc_macro_crate {\n-        return krate;\n+        return;\n     }\n \n     if is_test_crate {\n-        return krate;\n+        return;\n     }\n \n     let decls = mk_decls(&mut cx, &macros);\n     krate.items.push(decls);\n-\n-    krate\n }\n \n impl<'a> CollectProcMacros<'a> {"}, {"sha": "6493c6f13d54138ff2dc51830fdd210d4267eacd", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -9,17 +9,19 @@ use rustc_span::DUMMY_SP;\n use thin_vec::thin_vec;\n \n pub fn inject(\n-    mut krate: ast::Crate,\n+    krate: &mut ast::Crate,\n+    pre_configured_attrs: &[ast::Attribute],\n     resolver: &mut dyn ResolverExpand,\n     sess: &Session,\n-) -> ast::Crate {\n+) -> usize {\n+    let orig_num_items = krate.items.len();\n     let edition = sess.parse_sess.edition;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[Symbol] = if attr::contains_name(&krate.attrs, sym::no_core) {\n-        return krate;\n-    } else if attr::contains_name(&krate.attrs, sym::no_std) {\n-        if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n+    let names: &[Symbol] = if attr::contains_name(pre_configured_attrs, sym::no_core) {\n+        return 0;\n+    } else if attr::contains_name(pre_configured_attrs, sym::no_std) {\n+        if attr::contains_name(pre_configured_attrs, sym::compiler_builtins) {\n             &[sym::core]\n         } else {\n             &[sym::core, sym::compiler_builtins]\n@@ -88,6 +90,5 @@ pub fn inject(\n     );\n \n     krate.items.insert(0, use_item);\n-\n-    krate\n+    krate.items.len() - orig_num_items\n }"}, {"sha": "43ab6c0442833d253b88ddc21be42d11051fcca6", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -37,7 +37,7 @@ struct TestCtxt<'a> {\n \n /// Traverse the crate, collecting all the test functions, eliding any\n /// existing main functions, and synthesizing a main test harness\n-pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast::Crate) {\n+pub fn inject(krate: &mut ast::Crate, sess: &Session, resolver: &mut dyn ResolverExpand) {\n     let span_diagnostic = sess.diagnostic();\n     let panic_strategy = sess.panic_strategy();\n     let platform_panic_strategy = sess.target.panic_strategy;"}, {"sha": "2107ae147e980dbf88e210f5a7818b80088c1d28", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -709,6 +709,10 @@ fn codegen_stmt<'tcx>(\n                     let operand = codegen_operand(fx, operand);\n                     operand.coerce_dyn_star(fx, lval);\n                 }\n+                Rvalue::Cast(CastKind::Transmute, ref operand, _to_ty) => {\n+                    let operand = codegen_operand(fx, operand);\n+                    lval.write_cvalue_transmute(fx, operand);\n+                }\n                 Rvalue::Discriminant(place) => {\n                     let place = codegen_place(fx, place);\n                     let value = place.to_cvalue(fx);"}, {"sha": "03f2a65fccad2444c5097d364b1219cad916751b", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -557,16 +557,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             fx.bcx.ins().band(ptr, mask);\n         }\n \n-        sym::transmute => {\n-            intrinsic_args!(fx, args => (from); intrinsic);\n-\n-            if ret.layout().abi.is_uninhabited() {\n-                crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", source_info);\n-                return;\n-            }\n-\n-            ret.write_cvalue_transmute(fx, from);\n-        }\n         sym::write_bytes | sym::volatile_set_memory => {\n             intrinsic_args!(fx, args => (dst, val, count); intrinsic);\n             let val = val.load_scalar(fx);"}, {"sha": "a570f2af0f0e5dda96addff18fbf11700dfd6f02", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -189,6 +189,15 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n                 path.push(lib_name);\n                 path\n             };\n+            // dlltool target architecture args from:\n+            // https://github.com/llvm/llvm-project-release-prs/blob/llvmorg-15.0.6/llvm/lib/ToolDrivers/llvm-dlltool/DlltoolDriver.cpp#L69\n+            let (dlltool_target_arch, dlltool_target_bitness) = match sess.target.arch.as_ref() {\n+                \"x86_64\" => (\"i386:x86-64\", \"--64\"),\n+                \"x86\" => (\"i386\", \"--32\"),\n+                \"aarch64\" => (\"arm64\", \"--64\"),\n+                \"arm\" => (\"arm\", \"--32\"),\n+                _ => panic!(\"unsupported arch {}\", sess.target.arch),\n+            };\n             let result = std::process::Command::new(dlltool)\n                 .args([\n                     \"-d\",\n@@ -197,6 +206,10 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n                     lib_name,\n                     \"-l\",\n                     output_path.to_str().unwrap(),\n+                    \"-m\",\n+                    dlltool_target_arch,\n+                    \"-f\",\n+                    dlltool_target_bitness,\n                     \"--no-leading-underscore\",\n                     \"--temp-prefix\",\n                     temp_prefix.to_str().unwrap(),\n@@ -422,24 +435,22 @@ fn find_binutils_dlltool(sess: &Session) -> OsString {\n         return dlltool_path.clone().into_os_string();\n     }\n \n-    let mut tool_name: OsString = if sess.host.arch != sess.target.arch {\n-        // We are cross-compiling, so we need the tool with the prefix matching our target\n-        if sess.target.arch == \"x86\" {\n-            \"i686-w64-mingw32-dlltool\"\n-        } else {\n-            \"x86_64-w64-mingw32-dlltool\"\n-        }\n+    let tool_name: OsString = if sess.host.options.is_like_windows {\n+        // If we're compiling on Windows, always use \"dlltool.exe\".\n+        \"dlltool.exe\"\n     } else {\n-        // We are not cross-compiling, so we just want `dlltool`\n-        \"dlltool\"\n+        // On other platforms, use the architecture-specific name.\n+        match sess.target.arch.as_ref() {\n+            \"x86_64\" => \"x86_64-w64-mingw32-dlltool\",\n+            \"x86\" => \"i686-w64-mingw32-dlltool\",\n+            \"aarch64\" => \"aarch64-w64-mingw32-dlltool\",\n+\n+            // For non-standard architectures (e.g., aarch32) fallback to \"dlltool\".\n+            _ => \"dlltool\",\n+        }\n     }\n     .into();\n \n-    if sess.host.options.is_like_windows {\n-        // If we're compiling on Windows, add the .exe suffix\n-        tool_name.push(\".exe\");\n-    }\n-\n     // NOTE: it's not clear how useful it is to explicitly search PATH.\n     for dir in env::split_paths(&env::var_os(\"PATH\").unwrap_or_default()) {\n         let full_path = dir.join(&tool_name);"}, {"sha": "012e25884ca99a1a99c04fcd00f201d3cbd096a8", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -378,7 +378,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 }\n             }\n \n-            _ => bug!(\"unknown intrinsic '{}'\", name),\n+            _ => bug!(\"unknown intrinsic '{}' -- should it have been lowered earlier?\", name),\n         };\n \n         if !fn_abi.ret.is_ignore() {"}, {"sha": "e5bae009ed64b9651b927d08988b406e7e54987a", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -361,12 +361,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n             .expect(\"Expected LlvmCodegenBackend's OngoingCodegen, found Box<Any>\")\n             .join(sess);\n \n-        sess.time(\"llvm_dump_timing_file\", || {\n-            if sess.opts.unstable_opts.llvm_time_trace {\n+        if sess.opts.unstable_opts.llvm_time_trace {\n+            sess.time(\"llvm_dump_timing_file\", || {\n                 let file_name = outputs.with_extension(\"llvm_timings.json\");\n                 llvm_util::time_trace_profiler_finish(&file_name);\n-            }\n-        });\n+            });\n+        }\n \n         Ok((codegen_results, work_products))\n     }"}, {"sha": "dd11768195079edafe620dd3ea7607642559d947", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -133,6 +133,9 @@ pub fn get_linker<'a>(\n         LinkerFlavor::Unix(Cc::No) if sess.target.os == \"l4re\" => {\n             Box::new(L4Bender::new(cmd, sess)) as Box<dyn Linker>\n         }\n+        LinkerFlavor::Unix(Cc::No) if sess.target.os == \"aix\" => {\n+            Box::new(AixLinker::new(cmd, sess)) as Box<dyn Linker>\n+        }\n         LinkerFlavor::WasmLld(Cc::No) => Box::new(WasmLd::new(cmd, sess)) as Box<dyn Linker>,\n         LinkerFlavor::Gnu(cc, _)\n         | LinkerFlavor::Darwin(cc, _)\n@@ -1474,6 +1477,177 @@ impl<'a> L4Bender<'a> {\n     }\n }\n \n+/// Linker for AIX.\n+pub struct AixLinker<'a> {\n+    cmd: Command,\n+    sess: &'a Session,\n+    hinted_static: bool,\n+}\n+\n+impl<'a> AixLinker<'a> {\n+    pub fn new(cmd: Command, sess: &'a Session) -> AixLinker<'a> {\n+        AixLinker { cmd: cmd, sess: sess, hinted_static: false }\n+    }\n+\n+    fn hint_static(&mut self) {\n+        if !self.hinted_static {\n+            self.cmd.arg(\"-bstatic\");\n+            self.hinted_static = true;\n+        }\n+    }\n+\n+    fn hint_dynamic(&mut self) {\n+        if self.hinted_static {\n+            self.cmd.arg(\"-bdynamic\");\n+            self.hinted_static = false;\n+        }\n+    }\n+\n+    fn build_dylib(&mut self, _out_filename: &Path) {\n+        self.cmd.arg(\"-bM:SRE\");\n+        self.cmd.arg(\"-bnoentry\");\n+        // FIXME: Use CreateExportList utility to create export list\n+        // and remove -bexpfull.\n+        self.cmd.arg(\"-bexpfull\");\n+    }\n+}\n+\n+impl<'a> Linker for AixLinker<'a> {\n+    fn link_dylib(&mut self, lib: &str, _verbatim: bool, _as_needed: bool) {\n+        self.hint_dynamic();\n+        self.cmd.arg(format!(\"-l{}\", lib));\n+    }\n+\n+    fn link_staticlib(&mut self, lib: &str, _verbatim: bool) {\n+        self.hint_static();\n+        self.cmd.arg(format!(\"-l{}\", lib));\n+    }\n+\n+    fn link_rlib(&mut self, lib: &Path) {\n+        self.hint_static();\n+        self.cmd.arg(lib);\n+    }\n+\n+    fn include_path(&mut self, path: &Path) {\n+        self.cmd.arg(\"-L\").arg(path);\n+    }\n+\n+    fn framework_path(&mut self, _: &Path) {\n+        bug!(\"frameworks are not supported on AIX\");\n+    }\n+\n+    fn output_filename(&mut self, path: &Path) {\n+        self.cmd.arg(\"-o\").arg(path);\n+    }\n+\n+    fn add_object(&mut self, path: &Path) {\n+        self.cmd.arg(path);\n+    }\n+\n+    fn full_relro(&mut self) {}\n+\n+    fn partial_relro(&mut self) {}\n+\n+    fn no_relro(&mut self) {}\n+\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n+\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicDylib => {\n+                self.hint_dynamic();\n+                self.build_dylib(out_filename);\n+            }\n+            LinkOutputKind::StaticDylib => {\n+                self.hint_static();\n+                self.build_dylib(out_filename);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn link_rust_dylib(&mut self, lib: &str, _: &Path) {\n+        self.hint_dynamic();\n+        self.cmd.arg(format!(\"-l{}\", lib));\n+    }\n+\n+    fn link_framework(&mut self, _framework: &str, _as_needed: bool) {\n+        bug!(\"frameworks not supported on AIX\");\n+    }\n+\n+    fn link_whole_staticlib(&mut self, lib: &str, verbatim: bool, search_path: &[PathBuf]) {\n+        self.hint_static();\n+        let lib = find_native_static_library(lib, verbatim, search_path, &self.sess);\n+        self.cmd.arg(format!(\"-bkeepfile:{}\", lib.to_str().unwrap()));\n+    }\n+\n+    fn link_whole_rlib(&mut self, lib: &Path) {\n+        self.hint_static();\n+        self.cmd.arg(format!(\"-bkeepfile:{}\", lib.to_str().unwrap()));\n+    }\n+\n+    fn gc_sections(&mut self, _keep_metadata: bool) {\n+        self.cmd.arg(\"-bgc\");\n+    }\n+\n+    fn no_gc_sections(&mut self) {\n+        self.cmd.arg(\"-bnogc\");\n+    }\n+\n+    fn optimize(&mut self) {}\n+\n+    fn pgo_gen(&mut self) {}\n+\n+    fn control_flow_guard(&mut self) {}\n+\n+    fn debuginfo(&mut self, strip: Strip, _: &[PathBuf]) {\n+        match strip {\n+            Strip::None => {}\n+            // FIXME: -s strips the symbol table, line number information\n+            // and relocation information.\n+            Strip::Debuginfo | Strip::Symbols => {\n+                self.cmd.arg(\"-s\");\n+            }\n+        }\n+    }\n+\n+    fn no_crt_objects(&mut self) {}\n+\n+    fn no_default_libraries(&mut self) {}\n+\n+    fn export_symbols(&mut self, tmpdir: &Path, _crate_type: CrateType, symbols: &[String]) {\n+        let path = tmpdir.join(\"list.exp\");\n+        let res: io::Result<()> = try {\n+            let mut f = BufWriter::new(File::create(&path)?);\n+            // TODO: use llvm-nm to generate export list.\n+            for symbol in symbols {\n+                debug!(\"  _{}\", symbol);\n+                writeln!(f, \"  {}\", symbol)?;\n+            }\n+        };\n+        if let Err(e) = res {\n+            self.sess.fatal(&format!(\"failed to write export file: {}\", e));\n+        }\n+        self.cmd.arg(format!(\"-bE:{}\", path.to_str().unwrap()));\n+    }\n+\n+    fn subsystem(&mut self, _subsystem: &str) {}\n+\n+    fn reset_per_library_state(&mut self) {\n+        self.hint_dynamic();\n+    }\n+\n+    fn linker_plugin_lto(&mut self) {}\n+\n+    fn add_eh_frame_header(&mut self) {}\n+\n+    fn add_no_exec(&mut self) {}\n+\n+    fn add_as_needed(&mut self) {}\n+}\n+\n fn for_each_exported_symbols_include_dep<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     crate_type: CrateType,"}, {"sha": "c3c8649dbff47b280bfb944f00d7a002f7c79041", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -786,6 +786,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             total_codegen_time,\n             start_rss.unwrap(),\n             end_rss,\n+            tcx.sess.opts.unstable_opts.time_passes_format,\n         );\n     }\n "}, {"sha": "5da0e826c56401da89df91414b4b07043ac6d691", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 84, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -16,7 +16,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, AssertKind, SwitchTargets};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, ValidityRequirement};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n-use rustc_middle::ty::{self, Instance, Ty, TypeVisitableExt};\n+use rustc_middle::ty::{self, Instance, Ty};\n use rustc_session::config::OptLevel;\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n@@ -769,23 +769,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             None => bx.fn_abi_of_fn_ptr(sig, extra_args),\n         };\n \n-        if intrinsic == Some(sym::transmute) {\n-            return if let Some(target) = target {\n-                self.codegen_transmute(bx, &args[0], destination);\n-                helper.funclet_br(self, bx, target, mergeable_succ)\n-            } else {\n-                // If we are trying to transmute to an uninhabited type,\n-                // it is likely there is no allotted destination. In fact,\n-                // transmuting to an uninhabited type is UB, which means\n-                // we can do what we like. Here, we declare that transmuting\n-                // into an uninhabited type is impossible, so anything following\n-                // it must be unreachable.\n-                assert_eq!(fn_abi.ret.layout.abi, abi::Abi::Uninhabited);\n-                bx.unreachable();\n-                MergingSucc::False\n-            };\n-        }\n-\n         if let Some(merging_succ) = self.codegen_panic_intrinsic(\n             &helper,\n             bx,\n@@ -828,7 +811,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         match intrinsic {\n             None | Some(sym::drop_in_place) => {}\n-            Some(sym::copy_nonoverlapping) => unreachable!(),\n             Some(intrinsic) => {\n                 let dest = match ret_dest {\n                     _ if fn_abi.ret.is_indirect() => llargs[0],\n@@ -1739,71 +1721,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    fn codegen_transmute(&mut self, bx: &mut Bx, src: &mir::Operand<'tcx>, dst: mir::Place<'tcx>) {\n-        if let Some(index) = dst.as_local() {\n-            match self.locals[index] {\n-                LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n-                LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),\n-                LocalRef::Operand(None) => {\n-                    let dst_layout = bx.layout_of(self.monomorphized_place_ty(dst.as_ref()));\n-                    assert!(!dst_layout.ty.has_erasable_regions());\n-                    let place = PlaceRef::alloca(bx, dst_layout);\n-                    place.storage_live(bx);\n-                    self.codegen_transmute_into(bx, src, place);\n-                    let op = bx.load_operand(place);\n-                    place.storage_dead(bx);\n-                    self.locals[index] = LocalRef::Operand(Some(op));\n-                    self.debug_introduce_local(bx, index);\n-                }\n-                LocalRef::Operand(Some(op)) => {\n-                    assert!(op.layout.is_zst(), \"assigning to initialized SSAtemp\");\n-                }\n-            }\n-        } else {\n-            let dst = self.codegen_place(bx, dst.as_ref());\n-            self.codegen_transmute_into(bx, src, dst);\n-        }\n-    }\n-\n-    fn codegen_transmute_into(\n-        &mut self,\n-        bx: &mut Bx,\n-        src: &mir::Operand<'tcx>,\n-        dst: PlaceRef<'tcx, Bx::Value>,\n-    ) {\n-        let src = self.codegen_operand(bx, src);\n-\n-        // Special-case transmutes between scalars as simple bitcasts.\n-        match (src.layout.abi, dst.layout.abi) {\n-            (abi::Abi::Scalar(src_scalar), abi::Abi::Scalar(dst_scalar)) => {\n-                // HACK(eddyb) LLVM doesn't like `bitcast`s between pointers and non-pointers.\n-                let src_is_ptr = matches!(src_scalar.primitive(), abi::Pointer(_));\n-                let dst_is_ptr = matches!(dst_scalar.primitive(), abi::Pointer(_));\n-                if src_is_ptr == dst_is_ptr {\n-                    assert_eq!(src.layout.size, dst.layout.size);\n-\n-                    // NOTE(eddyb) the `from_immediate` and `to_immediate_scalar`\n-                    // conversions allow handling `bool`s the same as `u8`s.\n-                    let src = bx.from_immediate(src.immediate());\n-                    // LLVM also doesn't like `bitcast`s between pointers in different address spaces.\n-                    let src_as_dst = if src_is_ptr {\n-                        bx.pointercast(src, bx.backend_type(dst.layout))\n-                    } else {\n-                        bx.bitcast(src, bx.backend_type(dst.layout))\n-                    };\n-                    Immediate(bx.to_immediate_scalar(src_as_dst, dst_scalar)).store(bx, dst);\n-                    return;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        let llty = bx.backend_type(src.layout);\n-        let cast_ptr = bx.pointercast(dst.llval, bx.type_ptr_to(llty));\n-        let align = src.layout.align.abi.min(dst.align);\n-        src.val.store(bx, PlaceRef::new_sized_aligned(cast_ptr, src.layout, align));\n-    }\n-\n     // Stores the return value of a function call into it's final location.\n     fn store_return(\n         &mut self,"}, {"sha": "72d41d8c32c21d9163fee7bca231b9c633e88078", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{self, VariantIdx};\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     #[instrument(level = \"trace\", skip(self, bx))]\n@@ -72,6 +72,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n \n+            mir::Rvalue::Cast(mir::CastKind::Transmute, ref operand, _ty) => {\n+                let src = self.codegen_operand(bx, operand);\n+                self.codegen_transmute(bx, src, dest);\n+            }\n+\n             mir::Rvalue::Repeat(ref elem, count) => {\n                 let cg_elem = self.codegen_operand(bx, elem);\n \n@@ -143,6 +148,52 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n+    fn codegen_transmute(\n+        &mut self,\n+        bx: &mut Bx,\n+        src: OperandRef<'tcx, Bx::Value>,\n+        dst: PlaceRef<'tcx, Bx::Value>,\n+    ) {\n+        // The MIR validator enforces no unsized transmutes.\n+        debug_assert!(src.layout.is_sized());\n+        debug_assert!(dst.layout.is_sized());\n+\n+        if src.layout.size != dst.layout.size\n+            || src.layout.abi == abi::Abi::Uninhabited\n+            || dst.layout.abi == abi::Abi::Uninhabited\n+        {\n+            // In all of these cases it's UB to run this transmute, but that's\n+            // known statically so might as well trap for it, rather than just\n+            // making it unreachable.\n+            bx.abort();\n+            return;\n+        }\n+\n+        let size_in_bytes = src.layout.size.bytes();\n+        if size_in_bytes == 0 {\n+            // Nothing to write\n+            return;\n+        }\n+\n+        match src.val {\n+            OperandValue::Ref(src_llval, meta, src_align) => {\n+                debug_assert_eq!(meta, None);\n+                // For a place-to-place transmute, call `memcpy` directly so that\n+                // both arguments get the best-available alignment information.\n+                let bytes = bx.cx().const_usize(size_in_bytes);\n+                let flags = MemFlags::empty();\n+                bx.memcpy(dst.llval, dst.align, src_llval, src_align, bytes, flags);\n+            }\n+            OperandValue::Immediate(_) | OperandValue::Pair(_, _) => {\n+                // When we have immediate(s), the alignment of the source is irrelevant,\n+                // so we can store them using the destination's alignment.\n+                let llty = bx.backend_type(src.layout);\n+                let cast_ptr = bx.pointercast(dst.llval, bx.type_ptr_to(llty));\n+                src.val.store(bx, PlaceRef::new_sized_aligned(cast_ptr, src.layout, dst.align));\n+            }\n+        }\n+    }\n+\n     pub fn codegen_rvalue_unsized(\n         &mut self,\n         bx: &mut Bx,\n@@ -344,6 +395,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         };\n                         OperandValue::Immediate(newval)\n                     }\n+                    mir::CastKind::Transmute => {\n+                        bug!(\"Transmute operand {:?} in `codegen_rvalue_operand`\", operand);\n+                    }\n                 };\n                 OperandRef { val, layout: cast }\n             }\n@@ -673,6 +727,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn rvalue_creates_operand(&self, rvalue: &mir::Rvalue<'tcx>, span: Span) -> bool {\n         match *rvalue {\n+            mir::Rvalue::Cast(mir::CastKind::Transmute, ..) =>\n+                // FIXME: Now that transmute is an Rvalue, it would be nice if\n+                // it could create `Immediate`s for scalars, where possible.\n+                false,\n             mir::Rvalue::Ref(..) |\n             mir::Rvalue::CopyForDeref(..) |\n             mir::Rvalue::AddressOf(..) |"}, {"sha": "163e3f86993224edd626bb1e3c15c365919a3635", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -133,6 +133,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     bug!()\n                 }\n             }\n+\n+            Transmute => {\n+                assert!(src.layout.is_sized());\n+                assert!(dest.layout.is_sized());\n+                if src.layout.size != dest.layout.size {\n+                    throw_ub_format!(\n+                        \"transmuting from {}-byte type to {}-byte type: `{}` -> `{}`\",\n+                        src.layout.size.bytes(),\n+                        dest.layout.size.bytes(),\n+                        src.layout.ty,\n+                        dest.layout.ty,\n+                    );\n+                }\n+\n+                self.copy_op(src, dest, /*allow_transmute*/ true)?;\n+            }\n         }\n         Ok(())\n     }"}, {"sha": "26fb041b455136bb1c1a79ae31f857dd725e817e", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -127,7 +127,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // First handle intrinsics without return place.\n         let ret = match ret {\n             None => match intrinsic_name {\n-                sym::transmute => throw_ub_format!(\"transmuting to uninhabited type\"),\n                 sym::abort => M::abort(self, \"the program aborted execution\".to_owned())?,\n                 // Unsupported diverging intrinsic.\n                 _ => return Ok(false),\n@@ -411,9 +410,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.exact_div(&val, &size, dest)?;\n             }\n \n-            sym::transmute => {\n-                self.copy_op(&args[0], dest, /*allow_transmute*/ true)?;\n-            }\n             sym::assert_inhabited\n             | sym::assert_zero_valid\n             | sym::assert_mem_uninitialized_valid => {"}, {"sha": "66fc1c07e202978be86c65fcc18996a2ac7418a2", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -621,6 +621,33 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                             );\n                         }\n                     }\n+                    CastKind::Transmute => {\n+                        if let MirPhase::Runtime(..) = self.mir_phase {\n+                            // Unlike `mem::transmute`, a MIR `Transmute` is well-formed\n+                            // for any two `Sized` types, just potentially UB to run.\n+\n+                            if !op_ty.is_sized(self.tcx, self.param_env) {\n+                                self.fail(\n+                                    location,\n+                                    format!(\"Cannot transmute from non-`Sized` type {op_ty:?}\"),\n+                                );\n+                            }\n+                            if !target_type.is_sized(self.tcx, self.param_env) {\n+                                self.fail(\n+                                    location,\n+                                    format!(\"Cannot transmute to non-`Sized` type {target_type:?}\"),\n+                                );\n+                            }\n+                        } else {\n+                            self.fail(\n+                                location,\n+                                format!(\n+                                    \"Transmute is not supported in non-runtime phase {:?}.\",\n+                                    self.mir_phase\n+                                ),\n+                            );\n+                        }\n+                    }\n                 }\n             }\n             Rvalue::Repeat(_, _)"}, {"sha": "056ee1f63be0311799a7a49c484e9454c4006347", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -21,6 +21,7 @@ rustc-hash = \"1.1.0\"\n rustc_index = { path = \"../rustc_index\", package = \"rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n+serde_json = \"1.0.59\"\n smallvec = { version = \"1.8.1\", features = [\n     \"const_generics\",\n     \"union\","}, {"sha": "513df666d0da1bf646056f43e5a701f5ff73effc", "filename": "compiler/rustc_data_structures/src/graph/scc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -56,7 +56,7 @@ fn test_three_sccs() {\n     assert_eq!(sccs.scc(1), 0);\n     assert_eq!(sccs.scc(2), 0);\n     assert_eq!(sccs.scc(3), 2);\n-    assert_eq!(sccs.successors(0), &[]);\n+    assert_eq!(sccs.successors(0), &[] as &[usize]);\n     assert_eq!(sccs.successors(1), &[0]);\n     assert_eq!(sccs.successors(2), &[0]);\n }\n@@ -113,7 +113,7 @@ fn test_find_state_2() {\n     assert_eq!(sccs.scc(2), 0);\n     assert_eq!(sccs.scc(3), 0);\n     assert_eq!(sccs.scc(4), 0);\n-    assert_eq!(sccs.successors(0), &[]);\n+    assert_eq!(sccs.successors(0), &[] as &[usize]);\n }\n \n #[test]\n@@ -138,7 +138,7 @@ fn test_find_state_3() {\n     assert_eq!(sccs.scc(3), 0);\n     assert_eq!(sccs.scc(4), 0);\n     assert_eq!(sccs.scc(5), 1);\n-    assert_eq!(sccs.successors(0), &[]);\n+    assert_eq!(sccs.successors(0), &[] as &[usize]);\n     assert_eq!(sccs.successors(1), &[0]);\n }\n "}, {"sha": "7c866da60090f9541c333c138f773396c2e4be0c", "filename": "compiler/rustc_data_structures/src/graph/vec_graph/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Ftests.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -27,11 +27,11 @@ fn successors() {\n     let graph = create_graph();\n     assert_eq!(graph.successors(0), &[1]);\n     assert_eq!(graph.successors(1), &[2, 3]);\n-    assert_eq!(graph.successors(2), &[]);\n+    assert_eq!(graph.successors(2), &[] as &[usize]);\n     assert_eq!(graph.successors(3), &[4]);\n-    assert_eq!(graph.successors(4), &[]);\n+    assert_eq!(graph.successors(4), &[] as &[usize]);\n     assert_eq!(graph.successors(5), &[1]);\n-    assert_eq!(graph.successors(6), &[]);\n+    assert_eq!(graph.successors(6), &[] as &[usize]);\n }\n \n #[test]"}, {"sha": "58a0609e29655dff934ab6f553ba6a6ed1918db3", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 58, "deletions": 14, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -97,6 +97,7 @@ use std::time::{Duration, Instant};\n pub use measureme::EventId;\n use measureme::{EventIdBuilder, Profiler, SerializableString, StringId};\n use parking_lot::RwLock;\n+use serde_json::json;\n use smallvec::SmallVec;\n \n bitflags::bitflags! {\n@@ -145,6 +146,15 @@ const EVENT_FILTERS_BY_NAME: &[(&str, EventFilter)] = &[\n /// Something that uniquely identifies a query invocation.\n pub struct QueryInvocationId(pub u32);\n \n+/// Which format to use for `-Z time-passes`\n+#[derive(Clone, Copy, PartialEq, Hash, Debug)]\n+pub enum TimePassesFormat {\n+    /// Emit human readable text\n+    Text,\n+    /// Emit structured JSON\n+    Json,\n+}\n+\n /// A reference to the SelfProfiler. It can be cloned and sent across thread\n /// boundaries at will.\n #[derive(Clone)]\n@@ -158,14 +168,14 @@ pub struct SelfProfilerRef {\n     // actually enabled.\n     event_filter_mask: EventFilter,\n \n-    // Print verbose generic activities to stderr?\n-    print_verbose_generic_activities: bool,\n+    // Print verbose generic activities to stderr.\n+    print_verbose_generic_activities: Option<TimePassesFormat>,\n }\n \n impl SelfProfilerRef {\n     pub fn new(\n         profiler: Option<Arc<SelfProfiler>>,\n-        print_verbose_generic_activities: bool,\n+        print_verbose_generic_activities: Option<TimePassesFormat>,\n     ) -> SelfProfilerRef {\n         // If there is no SelfProfiler then the filter mask is set to NONE,\n         // ensuring that nothing ever tries to actually access it.\n@@ -207,9 +217,10 @@ impl SelfProfilerRef {\n     /// a measureme event, \"verbose\" generic activities also print a timing entry to\n     /// stderr if the compiler is invoked with -Ztime-passes.\n     pub fn verbose_generic_activity(&self, event_label: &'static str) -> VerboseTimingGuard<'_> {\n-        let message = self.print_verbose_generic_activities.then(|| event_label.to_owned());\n+        let message_and_format =\n+            self.print_verbose_generic_activities.map(|format| (event_label.to_owned(), format));\n \n-        VerboseTimingGuard::start(message, self.generic_activity(event_label))\n+        VerboseTimingGuard::start(message_and_format, self.generic_activity(event_label))\n     }\n \n     /// Like `verbose_generic_activity`, but with an extra arg.\n@@ -221,11 +232,14 @@ impl SelfProfilerRef {\n     where\n         A: Borrow<str> + Into<String>,\n     {\n-        let message = self\n+        let message_and_format = self\n             .print_verbose_generic_activities\n-            .then(|| format!(\"{}({})\", event_label, event_arg.borrow()));\n+            .map(|format| (format!(\"{}({})\", event_label, event_arg.borrow()), format));\n \n-        VerboseTimingGuard::start(message, self.generic_activity_with_arg(event_label, event_arg))\n+        VerboseTimingGuard::start(\n+            message_and_format,\n+            self.generic_activity_with_arg(event_label, event_arg),\n+        )\n     }\n \n     /// Start profiling a generic activity. Profiling continues until the\n@@ -703,17 +717,32 @@ impl<'a> TimingGuard<'a> {\n     }\n }\n \n+struct VerboseInfo {\n+    start_time: Instant,\n+    start_rss: Option<usize>,\n+    message: String,\n+    format: TimePassesFormat,\n+}\n+\n #[must_use]\n pub struct VerboseTimingGuard<'a> {\n-    start_and_message: Option<(Instant, Option<usize>, String)>,\n+    info: Option<VerboseInfo>,\n     _guard: TimingGuard<'a>,\n }\n \n impl<'a> VerboseTimingGuard<'a> {\n-    pub fn start(message: Option<String>, _guard: TimingGuard<'a>) -> Self {\n+    pub fn start(\n+        message_and_format: Option<(String, TimePassesFormat)>,\n+        _guard: TimingGuard<'a>,\n+    ) -> Self {\n         VerboseTimingGuard {\n             _guard,\n-            start_and_message: message.map(|msg| (Instant::now(), get_resident_set_size(), msg)),\n+            info: message_and_format.map(|(message, format)| VerboseInfo {\n+                start_time: Instant::now(),\n+                start_rss: get_resident_set_size(),\n+                message,\n+                format,\n+            }),\n         }\n     }\n \n@@ -726,10 +755,10 @@ impl<'a> VerboseTimingGuard<'a> {\n \n impl Drop for VerboseTimingGuard<'_> {\n     fn drop(&mut self) {\n-        if let Some((start_time, start_rss, ref message)) = self.start_and_message {\n+        if let Some(info) = &self.info {\n             let end_rss = get_resident_set_size();\n-            let dur = start_time.elapsed();\n-            print_time_passes_entry(message, dur, start_rss, end_rss);\n+            let dur = info.start_time.elapsed();\n+            print_time_passes_entry(&info.message, dur, info.start_rss, end_rss, info.format);\n         }\n     }\n }\n@@ -739,7 +768,22 @@ pub fn print_time_passes_entry(\n     dur: Duration,\n     start_rss: Option<usize>,\n     end_rss: Option<usize>,\n+    format: TimePassesFormat,\n ) {\n+    match format {\n+        TimePassesFormat::Json => {\n+            let json = json!({\n+                \"pass\": what,\n+                \"time\": dur.as_secs_f64(),\n+                \"rss_start\": start_rss,\n+                \"rss_end\": end_rss,\n+            });\n+            eprintln!(\"time: {}\", json.to_string());\n+            return;\n+        }\n+        TimePassesFormat::Text => (),\n+    }\n+\n     // Print the pass if its duration is greater than 5 ms, or it changed the\n     // measured RSS.\n     let is_notable = || {"}, {"sha": "1e835f6065a6379d3d6493b16f477837f1d4e852", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -20,7 +20,9 @@ pub extern crate rustc_plugin_impl as plugin;\n \n use rustc_ast as ast;\n use rustc_codegen_ssa::{traits::CodegenBackend, CodegenErrors, CodegenResults};\n-use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n+use rustc_data_structures::profiling::{\n+    get_resident_set_size, print_time_passes_entry, TimePassesFormat,\n+};\n use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{\n@@ -161,7 +163,7 @@ pub trait Callbacks {\n \n #[derive(Default)]\n pub struct TimePassesCallbacks {\n-    time_passes: bool,\n+    time_passes: Option<TimePassesFormat>,\n }\n \n impl Callbacks for TimePassesCallbacks {\n@@ -171,7 +173,8 @@ impl Callbacks for TimePassesCallbacks {\n         // If a --print=... option has been given, we don't print the \"total\"\n         // time because it will mess up the --print output. See #64339.\n         //\n-        self.time_passes = config.opts.prints.is_empty() && config.opts.unstable_opts.time_passes;\n+        self.time_passes = (config.opts.prints.is_empty() && config.opts.unstable_opts.time_passes)\n+            .then(|| config.opts.unstable_opts.time_passes_format);\n         config.opts.trimmed_def_paths = TrimmedDefPaths::GoodPath;\n     }\n }\n@@ -353,7 +356,7 @@ fn run_compiler(\n \n             {\n                 let plugins = queries.register_plugins()?;\n-                let (_, lint_store) = &*plugins.borrow();\n+                let (.., lint_store) = &*plugins.borrow();\n \n                 // Lint plugins are registered; now we can process command line flags.\n                 if sess.opts.describe_lints {\n@@ -1354,9 +1357,9 @@ pub fn main() -> ! {\n         RunCompiler::new(&args, &mut callbacks).run()\n     });\n \n-    if callbacks.time_passes {\n+    if let Some(format) = callbacks.time_passes {\n         let end_rss = get_resident_set_size();\n-        print_time_passes_entry(\"total\", start_time.elapsed(), start_rss, end_rss);\n+        print_time_passes_entry(\"total\", start_time.elapsed(), start_rss, end_rss, format);\n     }\n \n     process::exit(exit_code)"}, {"sha": "d32af10914e59c049716249c061f24b1ffa64472", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1002,6 +1002,7 @@ pub struct ExpansionData {\n pub struct ExtCtxt<'a> {\n     pub sess: &'a Session,\n     pub ecfg: expand::ExpansionConfig<'a>,\n+    pub num_standard_library_imports: usize,\n     pub reduced_recursion_limit: Option<Limit>,\n     pub root_path: PathBuf,\n     pub resolver: &'a mut dyn ResolverExpand,\n@@ -1030,6 +1031,7 @@ impl<'a> ExtCtxt<'a> {\n         ExtCtxt {\n             sess,\n             ecfg,\n+            num_standard_library_imports: 0,\n             reduced_recursion_limit: None,\n             resolver,\n             lint_store,"}, {"sha": "a78dc0678d5da50c126078ac4d24545ce50be249", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 22, "deletions": 47, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -24,7 +24,6 @@ use rustc_session::Session;\n use rustc_span::edition::{Edition, ALL_EDITIONS};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n-use thin_vec::ThinVec;\n \n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n@@ -37,7 +36,7 @@ pub struct StripUnconfigured<'a> {\n     pub lint_node_id: NodeId,\n }\n \n-fn get_features(sess: &Session, krate_attrs: &[ast::Attribute]) -> Features {\n+pub fn features(sess: &Session, krate_attrs: &[Attribute]) -> Features {\n     fn feature_removed(sess: &Session, span: Span, reason: Option<&str>) {\n         sess.emit_err(FeatureRemoved {\n             span,\n@@ -191,39 +190,16 @@ fn get_features(sess: &Session, krate_attrs: &[ast::Attribute]) -> Features {\n     features\n }\n \n-/// `cfg_attr`-process the crate's attributes and compute the crate's features.\n-pub fn features(\n-    sess: &Session,\n-    mut krate: ast::Crate,\n-    lint_node_id: NodeId,\n-) -> (ast::Crate, Features) {\n-    let mut strip_unconfigured =\n-        StripUnconfigured { sess, features: None, config_tokens: false, lint_node_id };\n-\n-    let unconfigured_attrs = krate.attrs.clone();\n-    let diag = &sess.parse_sess.span_diagnostic;\n-    let err_count = diag.err_count();\n-    let features = match strip_unconfigured.configure_krate_attrs(krate.attrs) {\n-        None => {\n-            // The entire crate is unconfigured.\n-            krate.attrs = ast::AttrVec::new();\n-            krate.items = ThinVec::new();\n-            Features::default()\n-        }\n-        Some(attrs) => {\n-            krate.attrs = attrs;\n-            let features = get_features(sess, &krate.attrs);\n-            if err_count == diag.err_count() {\n-                // Avoid reconfiguring malformed `cfg_attr`s.\n-                strip_unconfigured.features = Some(&features);\n-                // Run configuration again, this time with features available\n-                // so that we can perform feature-gating.\n-                strip_unconfigured.configure_krate_attrs(unconfigured_attrs);\n-            }\n-            features\n-        }\n+pub fn pre_configure_attrs(sess: &Session, attrs: &[Attribute]) -> ast::AttrVec {\n+    let strip_unconfigured = StripUnconfigured {\n+        sess,\n+        features: None,\n+        config_tokens: false,\n+        lint_node_id: ast::CRATE_NODE_ID,\n     };\n-    (krate, features)\n+    let attrs: ast::AttrVec =\n+        attrs.iter().flat_map(|attr| strip_unconfigured.process_cfg_attr(attr)).collect();\n+    if strip_unconfigured.in_cfg(&attrs) { attrs } else { ast::AttrVec::new() }\n }\n \n #[macro_export]\n@@ -254,11 +230,6 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn configure_krate_attrs(&self, mut attrs: ast::AttrVec) -> Option<ast::AttrVec> {\n-        attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n-        self.in_cfg(&attrs).then_some(attrs)\n-    }\n-\n     /// Performs cfg-expansion on `stream`, producing a new `AttrTokenStream`.\n     /// This is only used during the invocation of `derive` proc-macros,\n     /// which require that we cfg-expand their entire input.\n@@ -281,7 +252,7 @@ impl<'a> StripUnconfigured<'a> {\n             .iter()\n             .flat_map(|tree| match tree.clone() {\n                 AttrTokenTree::Attributes(mut data) => {\n-                    data.attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n+                    data.attrs.flat_map_in_place(|attr| self.process_cfg_attr(&attr));\n \n                     if self.in_cfg(&data.attrs) {\n                         data.tokens = LazyAttrTokenStream::new(\n@@ -319,12 +290,16 @@ impl<'a> StripUnconfigured<'a> {\n     /// the syntax of any `cfg_attr` is incorrect.\n     fn process_cfg_attrs<T: HasAttrs>(&self, node: &mut T) {\n         node.visit_attrs(|attrs| {\n-            attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n+            attrs.flat_map_in_place(|attr| self.process_cfg_attr(&attr));\n         });\n     }\n \n-    fn process_cfg_attr(&self, attr: Attribute) -> Vec<Attribute> {\n-        if attr.has_name(sym::cfg_attr) { self.expand_cfg_attr(attr, true) } else { vec![attr] }\n+    fn process_cfg_attr(&self, attr: &Attribute) -> Vec<Attribute> {\n+        if attr.has_name(sym::cfg_attr) {\n+            self.expand_cfg_attr(attr, true)\n+        } else {\n+            vec![attr.clone()]\n+        }\n     }\n \n     /// Parse and expand a single `cfg_attr` attribute into a list of attributes\n@@ -334,9 +309,9 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives a compiler warning when the `cfg_attr` contains no attributes and\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n-    pub(crate) fn expand_cfg_attr(&self, attr: Attribute, recursive: bool) -> Vec<Attribute> {\n+    pub(crate) fn expand_cfg_attr(&self, attr: &Attribute, recursive: bool) -> Vec<Attribute> {\n         let Some((cfg_predicate, expanded_attrs)) =\n-            rustc_parse::parse_cfg_attr(&attr, &self.sess.parse_sess) else {\n+            rustc_parse::parse_cfg_attr(attr, &self.sess.parse_sess) else {\n                 return vec![];\n             };\n \n@@ -365,10 +340,10 @@ impl<'a> StripUnconfigured<'a> {\n             //  `#[cfg_attr(false, cfg_attr(true, some_attr))]`.\n             expanded_attrs\n                 .into_iter()\n-                .flat_map(|item| self.process_cfg_attr(self.expand_cfg_attr_item(&attr, item)))\n+                .flat_map(|item| self.process_cfg_attr(&self.expand_cfg_attr_item(attr, item)))\n                 .collect()\n         } else {\n-            expanded_attrs.into_iter().map(|item| self.expand_cfg_attr_item(&attr, item)).collect()\n+            expanded_attrs.into_iter().map(|item| self.expand_cfg_attr_item(attr, item)).collect()\n         }\n     }\n "}, {"sha": "ec40911545f500fab659171ad0be4897e06ba010", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1038,6 +1038,9 @@ trait InvocationCollectorNode: HasAttrs + HasNodeId + Sized {\n     ) -> Result<Self::OutputTy, Self> {\n         Ok(noop_flat_map(node, collector))\n     }\n+    fn expand_cfg_false(&mut self, collector: &mut InvocationCollector<'_, '_>, span: Span) {\n+        collector.cx.emit_err(RemoveNodeNotSupported { span, descr: Self::descr() });\n+    }\n }\n \n impl InvocationCollectorNode for P<ast::Item> {\n@@ -1378,6 +1381,11 @@ impl InvocationCollectorNode for ast::Crate {\n     fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n         noop_visit_crate(self, visitor)\n     }\n+    fn expand_cfg_false(&mut self, collector: &mut InvocationCollector<'_, '_>, _span: Span) {\n+        self.attrs.clear();\n+        // Standard prelude imports are left in the crate for backward compatibility.\n+        self.items.truncate(collector.cx.num_standard_library_imports);\n+    }\n }\n \n impl InvocationCollectorNode for P<ast::Ty> {\n@@ -1688,7 +1696,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         res\n     }\n \n-    fn expand_cfg_attr(&self, node: &mut impl HasAttrs, attr: ast::Attribute, pos: usize) {\n+    fn expand_cfg_attr(&self, node: &mut impl HasAttrs, attr: &ast::Attribute, pos: usize) {\n         node.visit_attrs(|attrs| {\n             // Repeated `insert` calls is inefficient, but the number of\n             // insertions is almost always 0 or 1 in practice.\n@@ -1712,7 +1720,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                         Default::default()\n                     }\n                     sym::cfg_attr => {\n-                        self.expand_cfg_attr(&mut node, attr, pos);\n+                        self.expand_cfg_attr(&mut node, &attr, pos);\n                         continue;\n                     }\n                     _ => {\n@@ -1756,11 +1764,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                             continue;\n                         }\n \n-                        self.cx.emit_err(RemoveNodeNotSupported { span, descr: Node::descr() });\n+                        node.expand_cfg_false(self, span);\n                         continue;\n                     }\n                     sym::cfg_attr => {\n-                        self.expand_cfg_attr(node, attr, pos);\n+                        self.expand_cfg_attr(node, &attr, pos);\n                         continue;\n                     }\n                     _ => visit_clobber(node, |node| {"}, {"sha": "b7d280b8751c91f76f9de918a433da78695dea11", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -160,6 +160,8 @@ declare_features! (\n     (active, intrinsics, \"1.0.0\", None, None),\n     /// Allows using `#[lang = \"..\"]` attribute for linking items to special compiler logic.\n     (active, lang_items, \"1.0.0\", None, None),\n+    /// Allows `#[link(..., cfg(..))]`; perma-unstable per #37406\n+    (active, link_cfg, \"1.14.0\", None, None),\n     /// Allows the `multiple_supertrait_upcastable` lint.\n     (active, multiple_supertrait_upcastable, \"1.69.0\", None, None),\n     /// Allows using `#[omit_gdb_pretty_printer_section]`.\n@@ -432,8 +434,6 @@ declare_features! (\n     (active, large_assignments, \"1.52.0\", Some(83518), None),\n     /// Allows `if/while p && let q = r && ...` chains.\n     (active, let_chains, \"1.37.0\", Some(53667), None),\n-    /// Allows `#[link(..., cfg(..))]`.\n-    (active, link_cfg, \"1.14.0\", Some(37406), None),\n     /// Allows using `reason` in lint attributes and the `#[expect(lint)]` lint check.\n     (active, lint_reasons, \"1.31.0\", Some(54503), None),\n     /// Give access to additional metadata about declarative macro meta-variables."}, {"sha": "81d6333814544b84fd8e8a10f85bb3a394d437b2", "filename": "compiler/rustc_fs_util/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,10 +1,11 @@\n+#![feature(absolute_path)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n use std::ffi::CString;\n use std::fs;\n use std::io;\n-use std::path::{Path, PathBuf};\n+use std::path::{absolute, Path, PathBuf};\n \n // Unfortunately, on windows, it looks like msvcrt.dll is silently translating\n // verbatim paths under the hood to non-verbatim paths! This manifests itself as\n@@ -91,3 +92,8 @@ pub fn path_to_c_string(p: &Path) -> CString {\n pub fn path_to_c_string(p: &Path) -> CString {\n     CString::new(p.to_str().unwrap()).unwrap()\n }\n+\n+#[inline]\n+pub fn try_canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n+    fs::canonicalize(&path).or_else(|_| absolute(&path))\n+}"}, {"sha": "6d9dfe9697c0c2d5a2ddda6c971056555bee940a", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1336,7 +1336,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ty::Clause::RegionOutlives(_) | ty::Clause::ConstArgHasType(..) => bug!(),\n                 },\n                 ty::PredicateKind::WellFormed(_)\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::ObjectSafe(_)\n                 | ty::PredicateKind::ClosureKind(_, _, _)\n                 | ty::PredicateKind::Subtype(_)"}, {"sha": "3d37e0ce0c69badada2cf2cabd3884a83cc22974", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -11,7 +11,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams, TreatProjections};\n+use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n \n@@ -97,12 +97,7 @@ impl<'tcx> InherentCollect<'tcx> {\n                 }\n             }\n \n-            if let Some(simp) = simplify_type(\n-                self.tcx,\n-                self_ty,\n-                TreatParams::AsCandidateKey,\n-                TreatProjections::AsCandidateKey,\n-            ) {\n+            if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsCandidateKey) {\n                 self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n             } else {\n                 bug!(\"unexpected self type: {:?}\", self_ty);\n@@ -162,12 +157,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             }\n         }\n \n-        if let Some(simp) = simplify_type(\n-            self.tcx,\n-            ty,\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        ) {\n+        if let Some(simp) = simplify_type(self.tcx, ty, TreatParams::AsCandidateKey) {\n             self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n         } else {\n             bug!(\"unexpected primitive type: {:?}\", ty);"}, {"sha": "465e787c92ae618ee3a0503534af3f3bf104a883", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -133,8 +133,8 @@ fn coherent_trait(tcx: TyCtxt<'_>, def_id: DefId) {\n         check_impl(tcx, impl_def_id, trait_ref);\n         check_object_overlap(tcx, impl_def_id, trait_ref);\n \n-        tcx.sess.time(\"unsafety_checking\", || unsafety::check_item(tcx, impl_def_id));\n-        tcx.sess.time(\"orphan_checking\", || tcx.ensure().orphan_check_impl(impl_def_id));\n+        unsafety::check_item(tcx, impl_def_id);\n+        tcx.ensure().orphan_check_impl(impl_def_id);\n     }\n \n     builtin::check_trait(tcx, def_id);"}, {"sha": "7f1e4ccc9647b79de5f0dde67540ba25d40583d3", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -528,7 +528,7 @@ fn trait_predicate_kind<'tcx>(\n         | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_))\n         | ty::PredicateKind::Clause(ty::Clause::Projection(_))\n         | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-        | ty::PredicateKind::AliasEq(..)\n+        | ty::PredicateKind::AliasRelate(..)\n         | ty::PredicateKind::WellFormed(_)\n         | ty::PredicateKind::Subtype(_)\n         | ty::PredicateKind::Coerce(_)"}, {"sha": "357deb07b8f31ef930c3d74f2c9a1214cfa0f998", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                     | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                     | ty::PredicateKind::WellFormed(..)\n-                    | ty::PredicateKind::AliasEq(..)\n+                    | ty::PredicateKind::AliasRelate(..)\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ClosureKind(..)\n                     | ty::PredicateKind::Subtype(..)"}, {"sha": "3def97bca4789c95020cad0d09656461c777be2e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -666,7 +666,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n                 | ty::PredicateKind::WellFormed(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 // N.B., this predicate is created by breaking down a"}, {"sha": "e0ddb90c33b990f0e075f24b71cfaa56830d649d", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::def::Res;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n-use rustc_span::{self, Span};\n+use rustc_span::{self, symbol::kw, Span};\n use rustc_trait_selection::traits;\n \n use std::ops::ControlFlow;\n@@ -25,17 +25,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let generics = self.tcx.generics_of(def_id);\n         let predicate_substs = match unsubstituted_pred.kind().skip_binder() {\n-            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => pred.trait_ref.substs,\n-            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => pred.projection_ty.substs,\n-            _ => ty::List::empty(),\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => pred.trait_ref.substs.to_vec(),\n+            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n+                pred.projection_ty.substs.to_vec()\n+            }\n+            ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(arg, ty)) => {\n+                vec![ty.into(), arg.into()]\n+            }\n+            ty::PredicateKind::ConstEvaluatable(e) => vec![e.into()],\n+            _ => return false,\n         };\n \n-        let find_param_matching = |matches: &dyn Fn(&ty::ParamTy) -> bool| {\n-            predicate_substs.types().find_map(|ty| {\n-                ty.walk().find_map(|arg| {\n+        let find_param_matching = |matches: &dyn Fn(ty::ParamTerm) -> bool| {\n+            predicate_substs.iter().find_map(|arg| {\n+                arg.walk().find_map(|arg| {\n                     if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                        && let ty::Param(param_ty) = ty.kind()\n-                        && matches(param_ty)\n+                        && let ty::Param(param_ty) = *ty.kind()\n+                        && matches(ty::ParamTerm::Ty(param_ty))\n+                    {\n+                        Some(arg)\n+                    } else if let ty::GenericArgKind::Const(ct) = arg.unpack()\n+                        && let ty::ConstKind::Param(param_ct) = ct.kind()\n+                        && matches(ty::ParamTerm::Const(param_ct))\n                     {\n                         Some(arg)\n                     } else {\n@@ -47,21 +58,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Prefer generics that are local to the fn item, since these are likely\n         // to be the cause of the unsatisfied predicate.\n-        let mut param_to_point_at = find_param_matching(&|param_ty| {\n-            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) == def_id\n+        let mut param_to_point_at = find_param_matching(&|param_term| {\n+            self.tcx.parent(generics.param_at(param_term.index(), self.tcx).def_id) == def_id\n         });\n         // Fall back to generic that isn't local to the fn item. This will come\n         // from a trait or impl, for example.\n-        let mut fallback_param_to_point_at = find_param_matching(&|param_ty| {\n-            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) != def_id\n-                && param_ty.name != rustc_span::symbol::kw::SelfUpper\n+        let mut fallback_param_to_point_at = find_param_matching(&|param_term| {\n+            self.tcx.parent(generics.param_at(param_term.index(), self.tcx).def_id) != def_id\n+                && !matches!(param_term, ty::ParamTerm::Ty(ty) if ty.name == kw::SelfUpper)\n         });\n         // Finally, the `Self` parameter is possibly the reason that the predicate\n         // is unsatisfied. This is less likely to be true for methods, because\n         // method probe means that we already kinda check that the predicates due\n         // to the `Self` type are true.\n-        let mut self_param_to_point_at =\n-            find_param_matching(&|param_ty| param_ty.name == rustc_span::symbol::kw::SelfUpper);\n+        let mut self_param_to_point_at = find_param_matching(\n+            &|param_term| matches!(param_term, ty::ParamTerm::Ty(ty) if ty.name == kw::SelfUpper),\n+        );\n \n         // Finally, for ambiguity-related errors, we actually want to look\n         // for a parameter that is the source of the inference type left\n@@ -225,14 +237,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .own_substs(ty::InternalSubsts::identity_for_item(self.tcx, def_id));\n         let Some((index, _)) = own_substs\n             .iter()\n-            .filter(|arg| matches!(arg.unpack(), ty::GenericArgKind::Type(_)))\n             .enumerate()\n             .find(|(_, arg)| **arg == param_to_point_at) else { return false };\n         let Some(arg) = segment\n             .args()\n             .args\n             .iter()\n-            .filter(|arg| matches!(arg, hir::GenericArg::Type(_)))\n             .nth(index) else { return false; };\n         error.obligation.cause.span = arg\n             .span()"}, {"sha": "dab709e17f0501163cf98c2aac1403ff40247128", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -16,7 +16,6 @@ use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::AssocItem;\n use rustc_middle::ty::GenericParamDefKind;\n@@ -701,7 +700,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_for_incoherent_ty(&mut self, self_ty: Ty<'tcx>) {\n-        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsCandidateKey, TreatProjections::AsCandidateKey) else {\n+        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsCandidateKey) else {\n             bug!(\"unexpected incoherent type: {:?}\", self_ty)\n         };\n         for &impl_def_id in self.tcx.incoherent_impls(simp) {\n@@ -838,7 +837,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             }\n         });"}, {"sha": "55f684599e7cc7bb256fadf8067adc4cc314d724", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -25,7 +25,6 @@ use rustc_infer::infer::{\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n-use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n use rustc_middle::ty::{self, GenericArgKind, Ty, TyCtxt, TypeVisitableExt};\n@@ -1524,7 +1523,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .into_iter()\n             .any(|info| self.associated_value(info.def_id, item_name).is_some());\n         let found_assoc = |ty: Ty<'tcx>| {\n-            simplify_type(tcx, ty, TreatParams::AsCandidateKey, TreatProjections::AsCandidateKey)\n+            simplify_type(tcx, ty, TreatParams::AsCandidateKey)\n                 .and_then(|simp| {\n                     tcx.incoherent_impls(simp)\n                         .iter()\n@@ -2653,12 +2652,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // FIXME: Even though negative bounds are not implemented, we could maybe handle\n                 // cases where a positive bound implies a negative impl.\n                 (candidates, Vec::new())\n-            } else if let Some(simp_rcvr_ty) = simplify_type(\n-                self.tcx,\n-                rcvr_ty,\n-                TreatParams::ForLookup,\n-                TreatProjections::ForLookup,\n-            ) {\n+            } else if let Some(simp_rcvr_ty) =\n+                simplify_type(self.tcx, rcvr_ty, TreatParams::ForLookup)\n+            {\n                 let mut potential_candidates = Vec::new();\n                 let mut explicitly_negative = Vec::new();\n                 for candidate in candidates {\n@@ -2671,12 +2667,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         })\n                         .any(|imp_did| {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap().subst_identity();\n-                            let imp_simp = simplify_type(\n-                                self.tcx,\n-                                imp.self_ty(),\n-                                TreatParams::ForLookup,\n-                                TreatProjections::ForLookup,\n-                            );\n+                            let imp_simp =\n+                                simplify_type(self.tcx, imp.self_ty(), TreatParams::ForLookup);\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n                         })\n                     {"}, {"sha": "d6f83838a041783d5d0278573acefd3770e0cd07", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -108,7 +108,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::{base_n, flock};\n use rustc_errors::ErrorGuaranteed;\n-use rustc_fs_util::{link_or_copy, LinkOrCopy};\n+use rustc_fs_util::{link_or_copy, try_canonicalize, LinkOrCopy};\n use rustc_session::{Session, StableCrateId};\n use rustc_span::Symbol;\n \n@@ -223,7 +223,7 @@ pub fn prepare_session_directory(\n     // because, on windows, long paths can cause problems;\n     // canonicalization inserts this weird prefix that makes windows\n     // tolerate long paths.\n-    let crate_dir = match crate_dir.canonicalize() {\n+    let crate_dir = match try_canonicalize(&crate_dir) {\n         Ok(v) => v,\n         Err(err) => {\n             return Err(sess.emit_err(errors::CanonicalizePath { path: crate_dir, err }));\n@@ -867,7 +867,7 @@ fn all_except_most_recent(\n /// before passing it to std::fs::remove_dir_all(). This will convert the path\n /// into the '\\\\?\\' format, which supports much longer paths.\n fn safe_remove_dir_all(p: &Path) -> io::Result<()> {\n-    let canonicalized = match std_fs::canonicalize(p) {\n+    let canonicalized = match try_canonicalize(p) {\n         Ok(canonicalized) => canonicalized,\n         Err(err) if err.kind() == io::ErrorKind::NotFound => return Ok(()),\n         Err(err) => return Err(err),\n@@ -877,7 +877,7 @@ fn safe_remove_dir_all(p: &Path) -> io::Result<()> {\n }\n \n fn safe_remove_file(p: &Path) -> io::Result<()> {\n-    let canonicalized = match std_fs::canonicalize(p) {\n+    let canonicalized = match try_canonicalize(p) {\n         Ok(canonicalized) => canonicalized,\n         Err(err) if err.kind() == io::ErrorKind::NotFound => return Ok(()),\n         Err(err) => return Err(err),"}, {"sha": "88a28e26005d62f54ecb2120364ab94b96cbae75", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             (_, ty::Alias(AliasKind::Projection, _)) | (ty::Alias(AliasKind::Projection, _), _)\n                 if self.tcx.trait_solver_next() =>\n             {\n-                relation.register_type_equate_obligation(a, b);\n+                relation.register_type_relate_obligation(a, b);\n                 Ok(a)\n             }\n \n@@ -842,23 +842,25 @@ pub trait ObligationEmittingRelation<'tcx>: TypeRelation<'tcx> {\n         let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n \n         self.register_predicates([ty::Binder::dummy(if self.tcx().trait_solver_next() {\n-            ty::PredicateKind::AliasEq(a.into(), b.into())\n+            ty::PredicateKind::AliasRelate(a.into(), b.into(), ty::AliasRelationDirection::Equate)\n         } else {\n             ty::PredicateKind::ConstEquate(a, b)\n         })]);\n     }\n \n-    /// Register an obligation that both types must be equal to each other.\n-    ///\n-    /// If they aren't equal then the relation doesn't hold.\n-    fn register_type_equate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n-        let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n-\n-        self.register_predicates([ty::Binder::dummy(ty::PredicateKind::AliasEq(\n+    /// Register an obligation that both types must be related to each other according to\n+    /// the [`ty::AliasRelationDirection`] given by [`ObligationEmittingRelation::alias_relate_direction`]\n+    fn register_type_relate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n+        self.register_predicates([ty::Binder::dummy(ty::PredicateKind::AliasRelate(\n             a.into(),\n             b.into(),\n+            self.alias_relate_direction(),\n         ))]);\n     }\n+\n+    /// Relation direction emitted for `AliasRelate` predicates, corresponding to the direction\n+    /// of the relation.\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection;\n }\n \n fn int_unification_error<'tcx>("}, {"sha": "38002357cde35cbe948c221d95792c4935228e56", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -210,4 +210,8 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Equate<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        ty::AliasRelationDirection::Equate\n+    }\n }"}, {"sha": "6395c4d4b20781f86ec5dd01dfe1d3f559a83a74", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -155,4 +155,9 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Glb<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        // FIXME(deferred_projection_equality): This isn't right, I think?\n+        ty::AliasRelationDirection::Equate\n+    }\n }"}, {"sha": "98cbd4c561c52d0b6d6703c170ff2bd7db914ffc", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -155,4 +155,9 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Lub<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations)\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        // FIXME(deferred_projection_equality): This isn't right, I think?\n+        ty::AliasRelationDirection::Equate\n+    }\n }"}, {"sha": "f5d20cb7ebfeba81e2e531031eecf20b1ab2bec6", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -711,6 +711,34 @@ where\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.delegate.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        unreachable!(\"manually overridden to handle ty::Variance::Contravariant ambient variance\")\n+    }\n+\n+    fn register_type_relate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n+        self.register_predicates([ty::Binder::dummy(match self.ambient_variance {\n+            ty::Variance::Covariant => ty::PredicateKind::AliasRelate(\n+                a.into(),\n+                b.into(),\n+                ty::AliasRelationDirection::Subtype,\n+            ),\n+            // a :> b is b <: a\n+            ty::Variance::Contravariant => ty::PredicateKind::AliasRelate(\n+                b.into(),\n+                a.into(),\n+                ty::AliasRelationDirection::Subtype,\n+            ),\n+            ty::Variance::Invariant => ty::PredicateKind::AliasRelate(\n+                a.into(),\n+                b.into(),\n+                ty::AliasRelationDirection::Equate,\n+            ),\n+            // FIXME(deferred_projection_equality): Implement this when we trigger it.\n+            // Probably just need to do nothing here.\n+            ty::Variance::Bivariant => unreachable!(),\n+        })]);\n+    }\n }\n \n /// When we encounter a binder like `for<..> fn(..)`, we actually have"}, {"sha": "048dad3a48bc2a8c623bc893c095829957b2fe87", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -22,7 +22,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n             ty::PredicateKind::Clause(ty::Clause::Projection(..))\n             | ty::PredicateKind::Clause(ty::Clause::Trait(..))\n             | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-            | ty::PredicateKind::AliasEq(..)\n+            | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::WellFormed(..)"}, {"sha": "fa6529dfa93ec886216f9961857f28798105a9fb", "filename": "compiler/rustc_infer/src/infer/projection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -26,7 +26,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             // completely change the normalization routine with the new solver.\n             //\n             // The new solver correctly handles projection equality so this hack\n-            // is not necessary. if re-enabled it should emit `PredicateKind::AliasEq`\n+            // is not necessary. if re-enabled it should emit `PredicateKind::AliasRelate`\n             // not `PredicateKind::Clause(Clause::Projection(..))` as in the new solver\n             // `Projection` is used as `normalizes-to` which will fail for `<T as Trait>::Assoc eq ?0`.\n             return projection_ty.to_ty(self.tcx);"}, {"sha": "fc73ca7606d238213c3edbc74b7dc4045c4ac9c4", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -236,4 +236,8 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Sub<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        ty::AliasRelationDirection::Subtype\n+    }\n }"}, {"sha": "0d2faeba5fc0fe73021a29f9edc5ca59f308984f", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -293,7 +293,7 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Nothing to elaborate\n             }\n             ty::PredicateKind::Ambiguous => {}\n-            ty::PredicateKind::AliasEq(..) => {\n+            ty::PredicateKind::AliasRelate(..) => {\n                 // No\n             }\n             ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => {"}, {"sha": "96d6a1cb062ee4e3d0705e84e7e5c4a7fbe3d2a8", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -16,6 +16,7 @@ rustc_attr = { path = \"../rustc_attr\" }\n rustc_borrowck = { path = \"../rustc_borrowck\" }\n rustc_builtin_macros = { path = \"../rustc_builtin_macros\" }\n rustc_expand = { path = \"../rustc_expand\" }\n+rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "413b40ab808e445998b425300374f82867800a1b", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -3,7 +3,6 @@ use crate::interface::{Compiler, Result};\n use crate::proc_macro_decls;\n use crate::util;\n \n-use ast::CRATE_NODE_ID;\n use rustc_ast::{self as ast, visit};\n use rustc_borrowck as mir_borrowck;\n use rustc_codegen_ssa::traits::CodegenBackend;\n@@ -12,6 +11,7 @@ use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::PResult;\n use rustc_expand::base::{ExtCtxt, LintStoreExpand};\n+use rustc_fs_util::try_canonicalize;\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n use rustc_lint::{unerased_lint_store, BufferedEarlyLint, EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n@@ -76,22 +76,14 @@ pub fn register_plugins<'a>(\n     sess: &'a Session,\n     metadata_loader: &'a dyn MetadataLoader,\n     register_lints: impl Fn(&Session, &mut LintStore),\n-    mut krate: ast::Crate,\n+    pre_configured_attrs: &[ast::Attribute],\n     crate_name: Symbol,\n-) -> Result<(ast::Crate, LintStore)> {\n-    krate = sess.time(\"attributes_injection\", || {\n-        rustc_builtin_macros::cmdline_attrs::inject(\n-            krate,\n-            &sess.parse_sess,\n-            &sess.opts.unstable_opts.crate_attr,\n-        )\n-    });\n-\n-    let (krate, features) = rustc_expand::config::features(sess, krate, CRATE_NODE_ID);\n+) -> Result<LintStore> {\n     // these need to be set \"early\" so that expansion sees `quote` if enabled.\n+    let features = rustc_expand::config::features(sess, pre_configured_attrs);\n     sess.init_features(features);\n \n-    let crate_types = util::collect_crate_types(sess, &krate.attrs);\n+    let crate_types = util::collect_crate_types(sess, pre_configured_attrs);\n     sess.init_crate_types(crate_types);\n \n     let stable_crate_id = StableCrateId::new(\n@@ -117,16 +109,17 @@ pub fn register_plugins<'a>(\n     let mut lint_store = rustc_lint::new_lint_store(sess.enable_internal_lints());\n     register_lints(sess, &mut lint_store);\n \n-    let registrars =\n-        sess.time(\"plugin_loading\", || plugin::load::load_plugins(sess, metadata_loader, &krate));\n+    let registrars = sess.time(\"plugin_loading\", || {\n+        plugin::load::load_plugins(sess, metadata_loader, pre_configured_attrs)\n+    });\n     sess.time(\"plugin_registration\", || {\n         let mut registry = plugin::Registry { lint_store: &mut lint_store };\n         for registrar in registrars {\n             registrar(&mut registry);\n         }\n     });\n \n-    Ok((krate, lint_store))\n+    Ok(lint_store)\n }\n \n fn pre_expansion_lint<'a>(\n@@ -173,19 +166,29 @@ impl LintStoreExpand for LintStoreExpandImpl<'_> {\n /// harness if one is to be provided, injection of a dependency on the\n /// standard library and prelude, and name resolution.\n #[instrument(level = \"trace\", skip(krate, resolver))]\n-fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>) -> ast::Crate {\n+fn configure_and_expand(\n+    mut krate: ast::Crate,\n+    pre_configured_attrs: &[ast::Attribute],\n+    resolver: &mut Resolver<'_, '_>,\n+) -> ast::Crate {\n     let tcx = resolver.tcx();\n     let sess = tcx.sess;\n     let lint_store = unerased_lint_store(tcx);\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n-    pre_expansion_lint(sess, lint_store, tcx.registered_tools(()), &krate, crate_name);\n+    let lint_check_node = (&krate, pre_configured_attrs);\n+    pre_expansion_lint(sess, lint_store, tcx.registered_tools(()), lint_check_node, crate_name);\n     rustc_builtin_macros::register_builtin_macros(resolver);\n \n-    krate = sess.time(\"crate_injection\", || {\n-        rustc_builtin_macros::standard_library_imports::inject(krate, resolver, sess)\n+    let num_standard_library_imports = sess.time(\"crate_injection\", || {\n+        rustc_builtin_macros::standard_library_imports::inject(\n+            &mut krate,\n+            pre_configured_attrs,\n+            resolver,\n+            sess,\n+        )\n     });\n \n-    util::check_attr_crate_type(sess, &krate.attrs, &mut resolver.lint_buffer());\n+    util::check_attr_crate_type(sess, pre_configured_attrs, &mut resolver.lint_buffer());\n \n     // Expand all macros\n     krate = sess.time(\"macro_expand_crate\", || {\n@@ -222,7 +225,7 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n \n         // Create the config for macro expansion\n         let features = sess.features_untracked();\n-        let recursion_limit = get_recursion_limit(&krate.attrs, sess);\n+        let recursion_limit = get_recursion_limit(pre_configured_attrs, sess);\n         let cfg = rustc_expand::expand::ExpansionConfig {\n             features: Some(features),\n             recursion_limit,\n@@ -235,6 +238,7 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n \n         let lint_store = LintStoreExpandImpl(lint_store);\n         let mut ecx = ExtCtxt::new(sess, cfg, resolver, Some(&lint_store));\n+        ecx.num_standard_library_imports = num_standard_library_imports;\n         // Expand macros now!\n         let krate = sess.time(\"expand_crate\", || ecx.monotonic_expander().expand_crate(krate));\n \n@@ -263,7 +267,7 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n     });\n \n     sess.time(\"maybe_building_test_harness\", || {\n-        rustc_builtin_macros::test_harness::inject(sess, resolver, &mut krate)\n+        rustc_builtin_macros::test_harness::inject(&mut krate, sess, resolver)\n     });\n \n     let has_proc_macro_decls = sess.time(\"AST_validation\", || {\n@@ -287,12 +291,12 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n         sess.emit_warning(errors::ProcMacroCratePanicAbort);\n     }\n \n-    krate = sess.time(\"maybe_create_a_macro_crate\", || {\n+    sess.time(\"maybe_create_a_macro_crate\", || {\n         let is_test_crate = sess.opts.test;\n         rustc_builtin_macros::proc_macro_harness::inject(\n+            &mut krate,\n             sess,\n             resolver,\n-            krate,\n             is_proc_macro_crate,\n             has_proc_macro_decls,\n             is_test_crate,\n@@ -356,7 +360,7 @@ fn early_lint_checks(tcx: TyCtxt<'_>, (): ()) {\n         tcx.registered_tools(()),\n         Some(lint_buffer),\n         rustc_lint::BuiltinCombinedEarlyLintPass::new(),\n-        &**krate,\n+        (&**krate, &*krate.attrs),\n     )\n }\n \n@@ -405,12 +409,12 @@ where\n }\n \n fn output_contains_path(output_paths: &[PathBuf], input_path: &Path) -> bool {\n-    let input_path = input_path.canonicalize().ok();\n+    let input_path = try_canonicalize(input_path).ok();\n     if input_path.is_none() {\n         return false;\n     }\n     let check = |output_path: &PathBuf| {\n-        if output_path.canonicalize().ok() == input_path { Some(()) } else { None }\n+        if try_canonicalize(output_path).ok() == input_path { Some(()) } else { None }\n     };\n     check_output(output_paths, check).is_some()\n }\n@@ -557,9 +561,9 @@ fn resolver_for_lowering<'tcx>(\n ) -> &'tcx Steal<(ty::ResolverAstLowering, Lrc<ast::Crate>)> {\n     let arenas = Resolver::arenas();\n     let _ = tcx.registered_tools(()); // Uses `crate_for_resolver`.\n-    let krate = tcx.crate_for_resolver(()).steal();\n-    let mut resolver = Resolver::new(tcx, &krate, &arenas);\n-    let krate = configure_and_expand(krate, &mut resolver);\n+    let (krate, pre_configured_attrs) = tcx.crate_for_resolver(()).steal();\n+    let mut resolver = Resolver::new(tcx, &pre_configured_attrs, krate.spans.inner_span, &arenas);\n+    let krate = configure_and_expand(krate, &pre_configured_attrs, &mut resolver);\n \n     // Make sure we don't mutate the cstore from here on.\n     tcx.untracked().cstore.leak();"}, {"sha": "d2293780836d559ece0df9734940d5a0d2c83a67", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -88,8 +88,9 @@ pub struct Queries<'tcx> {\n \n     dep_graph_future: Query<Option<DepGraphFuture>>,\n     parse: Query<ast::Crate>,\n+    pre_configure: Query<(ast::Crate, ast::AttrVec)>,\n     crate_name: Query<Symbol>,\n-    register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n+    register_plugins: Query<(ast::Crate, ast::AttrVec, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n     // This just points to what's in `gcx_cell`.\n     gcx: Query<&'tcx GlobalCtxt<'tcx>>,\n@@ -106,6 +107,7 @@ impl<'tcx> Queries<'tcx> {\n             hir_arena: WorkerLocal::new(|_| rustc_hir::Arena::default()),\n             dep_graph_future: Default::default(),\n             parse: Default::default(),\n+            pre_configure: Default::default(),\n             crate_name: Default::default(),\n             register_plugins: Default::default(),\n             dep_graph: Default::default(),\n@@ -133,17 +135,36 @@ impl<'tcx> Queries<'tcx> {\n             .compute(|| passes::parse(self.session()).map_err(|mut parse_error| parse_error.emit()))\n     }\n \n-    pub fn register_plugins(&self) -> Result<QueryResult<'_, (ast::Crate, Lrc<LintStore>)>> {\n+    pub fn pre_configure(&self) -> Result<QueryResult<'_, (ast::Crate, ast::AttrVec)>> {\n+        self.pre_configure.compute(|| {\n+            let mut krate = self.parse()?.steal();\n+\n+            let sess = self.session();\n+            rustc_builtin_macros::cmdline_attrs::inject(\n+                &mut krate,\n+                &sess.parse_sess,\n+                &sess.opts.unstable_opts.crate_attr,\n+            );\n+\n+            let pre_configured_attrs =\n+                rustc_expand::config::pre_configure_attrs(sess, &krate.attrs);\n+            Ok((krate, pre_configured_attrs))\n+        })\n+    }\n+\n+    pub fn register_plugins(\n+        &self,\n+    ) -> Result<QueryResult<'_, (ast::Crate, ast::AttrVec, Lrc<LintStore>)>> {\n         self.register_plugins.compute(|| {\n             let crate_name = *self.crate_name()?.borrow();\n-            let krate = self.parse()?.steal();\n+            let (krate, pre_configured_attrs) = self.pre_configure()?.steal();\n \n             let empty: &(dyn Fn(&Session, &mut LintStore) + Sync + Send) = &|_, _| {};\n-            let (krate, lint_store) = passes::register_plugins(\n+            let lint_store = passes::register_plugins(\n                 self.session(),\n                 &*self.codegen_backend().metadata_loader(),\n                 self.compiler.register_lints.as_deref().unwrap_or_else(|| empty),\n-                krate,\n+                &pre_configured_attrs,\n                 crate_name,\n             )?;\n \n@@ -154,17 +175,17 @@ impl<'tcx> Queries<'tcx> {\n             // called, which happens within passes::register_plugins().\n             self.dep_graph_future().ok();\n \n-            Ok((krate, Lrc::new(lint_store)))\n+            Ok((krate, pre_configured_attrs, Lrc::new(lint_store)))\n         })\n     }\n \n     fn crate_name(&self) -> Result<QueryResult<'_, Symbol>> {\n         self.crate_name.compute(|| {\n             Ok({\n-                let parse_result = self.parse()?;\n-                let krate = parse_result.borrow();\n+                let pre_configure_result = self.pre_configure()?;\n+                let (_, pre_configured_attrs) = &*pre_configure_result.borrow();\n                 // parse `#[crate_name]` even if `--crate-name` was passed, to make sure it matches.\n-                find_crate_name(self.session(), &krate.attrs)\n+                find_crate_name(self.session(), pre_configured_attrs)\n             })\n         })\n     }\n@@ -188,7 +209,7 @@ impl<'tcx> Queries<'tcx> {\n     pub fn global_ctxt(&'tcx self) -> Result<QueryResult<'_, &'tcx GlobalCtxt<'tcx>>> {\n         self.gcx.compute(|| {\n             let crate_name = *self.crate_name()?.borrow();\n-            let (krate, lint_store) = self.register_plugins()?.steal();\n+            let (krate, pre_configured_attrs, lint_store) = self.register_plugins()?.steal();\n \n             let sess = self.session();\n \n@@ -215,7 +236,7 @@ impl<'tcx> Queries<'tcx> {\n                 feed.crate_name(crate_name);\n \n                 let feed = tcx.feed_unit_query();\n-                feed.crate_for_resolver(tcx.arena.alloc(Steal::new(krate)));\n+                feed.crate_for_resolver(tcx.arena.alloc(Steal::new((krate, pre_configured_attrs))));\n                 feed.metadata_loader(\n                     tcx.arena.alloc(Steal::new(self.codegen_backend().metadata_loader())),\n                 );"}, {"sha": "eb5990507fb6dc1eb93ff3bc9c22af025141e724", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -2,6 +2,7 @@\n use crate::interface::parse_cfgspecs;\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::profiling::TimePassesFormat;\n use rustc_errors::{emitter::HumanReadableErrorType, registry, ColorConfig};\n use rustc_session::config::rustc_optgroups;\n use rustc_session::config::Input;\n@@ -699,6 +700,7 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(threads, 99);\n     untracked!(time_llvm_passes, true);\n     untracked!(time_passes, true);\n+    untracked!(time_passes_format, TimePassesFormat::Json);\n     untracked!(trace_macros, true);\n     untracked!(track_diagnostics, true);\n     untracked!(trim_diagnostic_paths, false);"}, {"sha": "68e62c9789aed9fda1e5a0118d1642cd4f8c6f95", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -508,6 +508,3 @@ lint_opaque_hidden_inferred_bound = opaque type `{$ty}` does not satisfy its ass\n     .specifically = this associated type bound is unsatisfied for `{$proj_ty}`\n \n lint_opaque_hidden_inferred_bound_sugg = add this bound\n-\n-lint_useless_anonymous_reexport = useless anonymous re-export\n-    .note = only anonymous re-exports of traits are useful, this is {$article} `{$desc}`"}, {"sha": "64c3ef451374efc12a89794b7b8e004432ccfcef", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1600,7 +1600,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     // Ignore projections, as they can only be global\n                     // if the trait bound is global\n                     Clause(Clause::Projection(..)) |\n-                    AliasEq(..) |\n+                    AliasRelate(..) |\n                     // Ignore bounds that a user can't type\n                     WellFormed(..) |\n                     ObjectSafe(..) |"}, {"sha": "626c09fea07ac46a6ad04969a2780d865eb1267b", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -910,6 +910,10 @@ pub trait LintContext: Sized {\n                         Applicability::MachineApplicable,\n                     );\n                 }\n+                BuiltinLintDiagnostics::AmbiguousGlobReexports { name, namespace, first_reexport_span, duplicate_reexport_span } => {\n+                    db.span_label(first_reexport_span, format!(\"the name `{}` in the {} namespace is first re-exported here\", name, namespace));\n+                    db.span_label(duplicate_reexport_span, format!(\"but the name `{}` in the {} namespace is also re-exported here\", name, namespace));\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(db)"}, {"sha": "65607d71805c38204b9eb363feb940662094bfe0", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -340,23 +340,23 @@ pub trait EarlyCheckNode<'a>: Copy {\n         'a: 'b;\n }\n \n-impl<'a> EarlyCheckNode<'a> for &'a ast::Crate {\n+impl<'a> EarlyCheckNode<'a> for (&'a ast::Crate, &'a [ast::Attribute]) {\n     fn id(self) -> ast::NodeId {\n         ast::CRATE_NODE_ID\n     }\n     fn attrs<'b>(self) -> &'b [ast::Attribute]\n     where\n         'a: 'b,\n     {\n-        &self.attrs\n+        &self.1\n     }\n     fn check<'b, T: EarlyLintPass>(self, cx: &mut EarlyContextAndPass<'b, T>)\n     where\n         'a: 'b,\n     {\n-        lint_callback!(cx, check_crate, self);\n-        ast_visit::walk_crate(cx, self);\n-        lint_callback!(cx, check_crate_post, self);\n+        lint_callback!(cx, check_crate, self.0);\n+        ast_visit::walk_crate(cx, self.0);\n+        lint_callback!(cx, check_crate_post, self.0);\n     }\n }\n "}, {"sha": "b3578540516d000b98495ca9044220d37720318d", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -74,7 +74,6 @@ mod opaque_hidden_inferred_bound;\n mod pass_by_value;\n mod passes;\n mod redundant_semicolon;\n-mod reexports;\n mod traits;\n mod types;\n mod unused;\n@@ -112,7 +111,6 @@ use noop_method_call::*;\n use opaque_hidden_inferred_bound::*;\n use pass_by_value::*;\n use redundant_semicolon::*;\n-use reexports::*;\n use traits::*;\n use types::*;\n use unused::*;\n@@ -244,7 +242,6 @@ late_lint_methods!(\n             OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n             MultipleSupertraitUpcastable: MultipleSupertraitUpcastable,\n             MapUnitFn: MapUnitFn,\n-            UselessAnonymousReexport: UselessAnonymousReexport,\n         ]\n     ]\n );"}, {"sha": "308c02929ca42b2e469d5c01caf5a3ff55b3c086", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1528,11 +1528,3 @@ pub struct UnusedAllocationDiag;\n #[derive(LintDiagnostic)]\n #[diag(lint_unused_allocation_mut)]\n pub struct UnusedAllocationMutDiag;\n-\n-#[derive(LintDiagnostic)]\n-#[diag(lint_useless_anonymous_reexport)]\n-#[note]\n-pub struct UselessAnonymousReexportDiag {\n-    pub article: &'static str,\n-    pub desc: &'static str,\n-}"}, {"sha": "f9d43fe220036e70c527e792ea10944d027e9f5d", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -27,6 +27,8 @@ declare_lint! {\n     /// ### Example\n     ///\n     /// ```rust\n+    /// #![feature(type_alias_impl_trait)]\n+    ///\n     /// trait Duh {}\n     ///\n     /// impl Duh for i32 {}\n@@ -41,7 +43,9 @@ declare_lint! {\n     ///     type Assoc = F;\n     /// }\n     ///\n-    /// fn test() -> impl Trait<Assoc = impl Sized> {\n+    /// type Tait = impl Sized;\n+    ///\n+    /// fn test() -> impl Trait<Assoc = Tait> {\n     ///     42\n     /// }\n     /// ```\n@@ -54,7 +58,7 @@ declare_lint! {\n     ///\n     /// Although the hidden type, `i32` does satisfy this bound, we do not\n     /// consider the return type to be well-formed with this lint. It can be\n-    /// fixed by changing `impl Sized` into `impl Sized + Send`.\n+    /// fixed by changing `Tait = impl Sized` into `Tait = impl Sized + Send`.\n     pub OPAQUE_HIDDEN_INFERRED_BOUND,\n     Warn,\n     \"detects the use of nested `impl Trait` types in associated type bounds that are not general enough\"\n@@ -64,7 +68,7 @@ declare_lint_pass!(OpaqueHiddenInferredBound => [OPAQUE_HIDDEN_INFERRED_BOUND]);\n \n impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-        let hir::ItemKind::OpaqueTy(_) = &item.kind else { return; };\n+        let hir::ItemKind::OpaqueTy(opaque) = &item.kind else { return; };\n         let def_id = item.owner_id.def_id.to_def_id();\n         let infcx = &cx.tcx.infer_ctxt().build();\n         // For every projection predicate in the opaque type's explicit bounds,\n@@ -81,6 +85,17 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n             // have opaques in them anyways.\n             let Some(proj_term) = proj.term.ty() else { continue };\n \n+            // HACK: `impl Trait<Assoc = impl Trait2>` from an RPIT is \"ok\"...\n+            if let ty::Alias(ty::Opaque, opaque_ty) = *proj_term.kind()\n+                && cx.tcx.parent(opaque_ty.def_id) == def_id\n+                && matches!(\n+                    opaque.origin,\n+                    hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_)\n+                )\n+            {\n+                continue;\n+            }\n+\n             let proj_ty =\n                 cx.tcx.mk_projection(proj.projection_ty.def_id, proj.projection_ty.substs);\n             // For every instance of the projection type in the bounds,"}, {"sha": "8737a57ea0264cddb1476d51411acbed456d027f", "filename": "compiler/rustc_lint/src/reexports.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4b0f8745082a36f6408357ec8bfd6c439955cc38/compiler%2Frustc_lint%2Fsrc%2Freexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0f8745082a36f6408357ec8bfd6c439955cc38/compiler%2Frustc_lint%2Fsrc%2Freexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Freexports.rs?ref=4b0f8745082a36f6408357ec8bfd6c439955cc38", "patch": "@@ -1,82 +0,0 @@\n-use crate::lints::UselessAnonymousReexportDiag;\n-use crate::{LateContext, LateLintPass, LintContext};\n-use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::{Item, ItemKind, UseKind};\n-use rustc_middle::ty::Visibility;\n-use rustc_span::symbol::kw;\n-use rustc_span::Span;\n-\n-declare_lint! {\n-    /// The `useless_anonymous_reexport` lint checks if anonymous re-exports\n-    /// are re-exports of traits.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust,compile_fail\n-    /// #![deny(useless_anonymous_reexport)]\n-    ///\n-    /// mod sub {\n-    ///     pub struct Bar;\n-    /// }\n-    ///\n-    /// pub use self::sub::Bar as _;\n-    /// # fn main() {}\n-    /// ```\n-    ///\n-    /// {{produces}}\n-    ///\n-    /// ### Explanation\n-    ///\n-    /// Anonymous re-exports are only useful if it's a re-export of a trait\n-    /// in case you want to give access to it. If you re-export any other kind,\n-    /// you won't be able to use it since its name won't be accessible.\n-    pub USELESS_ANONYMOUS_REEXPORT,\n-    Warn,\n-    \"useless anonymous re-export\"\n-}\n-\n-declare_lint_pass!(UselessAnonymousReexport => [USELESS_ANONYMOUS_REEXPORT]);\n-\n-fn emit_err(cx: &LateContext<'_>, span: Span, def_id: DefId) {\n-    let article = cx.tcx.def_descr_article(def_id);\n-    let desc = cx.tcx.def_descr(def_id);\n-    cx.emit_spanned_lint(\n-        USELESS_ANONYMOUS_REEXPORT,\n-        span,\n-        UselessAnonymousReexportDiag { article, desc },\n-    );\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for UselessAnonymousReexport {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n-        if let ItemKind::Use(path, kind) = item.kind &&\n-            !matches!(kind, UseKind::Glob) &&\n-            item.ident.name == kw::Underscore &&\n-            // We only want re-exports. If it's just a `use X;`, then we ignore it.\n-            match cx.tcx.local_visibility(item.owner_id.def_id) {\n-                Visibility::Public => true,\n-                Visibility::Restricted(level) => {\n-                    level != cx.tcx.parent_module_from_def_id(item.owner_id.def_id)\n-                }\n-            }\n-        {\n-            for def_id in path.res.iter().filter_map(|r| r.opt_def_id()) {\n-                match cx.tcx.def_kind(def_id) {\n-                    DefKind::Trait | DefKind::TraitAlias => {}\n-                    DefKind::TyAlias => {\n-                        let ty = cx.tcx.type_of(def_id);\n-                        if !ty.0.is_trait() {\n-                            emit_err(cx, item.span, def_id);\n-                            break;\n-                        }\n-                    }\n-                    _ => {\n-                        emit_err(cx, item.span, def_id);\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "9d6ab0b75df177bc86ddf6c2802eb5626e87f6da", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -3230,6 +3230,45 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `ambiguous_glob_reexports` lint detects cases where names re-exported via globs\n+    /// collide. Downstream users trying to use the same name re-exported from multiple globs\n+    /// will receive a warning pointing out redefinition of the same name.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(ambiguous_glob_reexports)]\n+    /// pub mod foo {\n+    ///     pub type X = u8;\n+    /// }\n+    ///\n+    /// pub mod bar {\n+    ///     pub type Y = u8;\n+    ///     pub type X = u8;\n+    /// }\n+    ///\n+    /// pub use foo::*;\n+    /// pub use bar::*;\n+    ///\n+    ///\n+    /// pub fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This was previously accepted but it could silently break a crate's downstream users code.\n+    /// For example, if `foo::*` and `bar::*` were re-exported before `bar::X` was added to the\n+    /// re-exports, down stream users could use `this_crate::X` without problems. However, adding\n+    /// `bar::X` would cause compilation errors in downstream crates because `X` is defined\n+    /// multiple times in the same namespace of `this_crate`.\n+    pub AMBIGUOUS_GLOB_REEXPORTS,\n+    Warn,\n+    \"ambiguous glob re-exports\",\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -3337,6 +3376,7 @@ declare_lint_pass! {\n         NAMED_ARGUMENTS_USED_POSITIONALLY,\n         IMPLIED_BOUNDS_ENTAILMENT,\n         BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n+        AMBIGUOUS_GLOB_REEXPORTS,\n     ]\n }\n \n@@ -3968,14 +4008,9 @@ declare_lint! {\n     ///\n     /// ### Example\n     ///\n-    /// ```rust,ignore (need FFI)\n-    /// #![feature(ffi_unwind_calls)]\n+    /// ```rust\n     /// #![feature(c_unwind)]\n-    ///\n-    /// # mod impl {\n-    /// #     #[no_mangle]\n-    /// #     pub fn \"C-unwind\" fn foo() {}\n-    /// # }\n+    /// #![warn(ffi_unwind_calls)]\n     ///\n     /// extern \"C-unwind\" {\n     ///     fn foo();"}, {"sha": "69a8b691ab21625147ff4048fc54d31c4c05deb6", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -529,6 +529,16 @@ pub enum BuiltinLintDiagnostics {\n         vis_span: Span,\n         ident_span: Span,\n     },\n+    AmbiguousGlobReexports {\n+        /// The name for which collision(s) have occurred.\n+        name: String,\n+        /// The name space for whihc the collision(s) occurred in.\n+        namespace: String,\n+        /// Span where the name is first re-exported.\n+        first_reexport_span: Span,\n+        /// Span where the same name is also re-exported.\n+        duplicate_reexport_span: Span,\n+    },\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "4d7c133e09bc4f1e19291b2b71153933884bdc48", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -18,6 +18,7 @@ rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_feature = { path = \"../rustc_feature\" }\n+rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "79c42a128e795a39c345e77e219b7fd502704ca0", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -222,6 +222,7 @@ use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_errors::{DiagnosticArgValue, FatalError, IntoDiagnosticArg};\n+use rustc_fs_util::try_canonicalize;\n use rustc_session::config::{self, CrateType};\n use rustc_session::cstore::{CrateSource, MetadataLoader};\n use rustc_session::filesearch::FileSearch;\n@@ -236,7 +237,7 @@ use snap::read::FrameDecoder;\n use std::borrow::Cow;\n use std::io::{Read, Result as IoResult, Write};\n use std::path::{Path, PathBuf};\n-use std::{cmp, fmt, fs};\n+use std::{cmp, fmt};\n \n #[derive(Clone)]\n pub(crate) struct CrateLocator<'a> {\n@@ -441,7 +442,7 @@ impl<'a> CrateLocator<'a> {\n                 info!(\"lib candidate: {}\", spf.path.display());\n \n                 let (rlibs, rmetas, dylibs) = candidates.entry(hash.to_string()).or_default();\n-                let path = fs::canonicalize(&spf.path).unwrap_or_else(|_| spf.path.clone());\n+                let path = try_canonicalize(&spf.path).unwrap_or_else(|_| spf.path.clone());\n                 if seen_paths.contains(&path) {\n                     continue;\n                 };\n@@ -636,7 +637,7 @@ impl<'a> CrateLocator<'a> {\n             // as well.\n             if let Some((prev, _)) = &ret {\n                 let sysroot = self.sysroot;\n-                let sysroot = sysroot.canonicalize().unwrap_or_else(|_| sysroot.to_path_buf());\n+                let sysroot = try_canonicalize(sysroot).unwrap_or_else(|_| sysroot.to_path_buf());\n                 if prev.starts_with(&sysroot) {\n                     continue;\n                 }"}, {"sha": "06a64f0db0e3232da08399f4b21785f34479d217", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -925,10 +925,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         tcx.mk_adt_def(did, adt_kind, variants, repr)\n     }\n \n-    fn get_generics(self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n-        self.root.tables.generics_of.get(self, item_id).unwrap().decode((self, sess))\n-    }\n-\n     fn get_visibility(self, id: DefIndex) -> Visibility<DefId> {\n         self.root\n             .tables\n@@ -1045,13 +1041,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.root.tables.optimized_mir.get(self, id).is_some()\n     }\n \n-    fn module_expansion(self, id: DefIndex, sess: &Session) -> ExpnId {\n-        match self.def_kind(id) {\n-            DefKind::Mod | DefKind::Enum | DefKind::Trait => self.get_expn_that_defined(id, sess),\n-            _ => panic!(\"Expected module, found {:?}\", self.local_def_id(id)),\n-        }\n-    }\n-\n     fn get_fn_has_self_parameter(self, id: DefIndex, sess: &'a Session) -> bool {\n         self.root\n             .tables"}, {"sha": "3a50d7c93635c58b9aa675084b9029c58c50469d", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -490,6 +490,9 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n                 .alloc_slice(&CStore::from_tcx(tcx).crate_dependencies_in_postorder(LOCAL_CRATE))\n         },\n         crates: |tcx, ()| {\n+            // The list of loaded crates is now frozen in query cache,\n+            // so make sure cstore is not mutably accessed from here on.\n+            tcx.untracked().cstore.leak();\n             tcx.arena.alloc_from_iter(CStore::from_tcx(tcx).iter_crate_data().map(|(cnum, _)| cnum))\n         },\n         ..*providers\n@@ -537,20 +540,16 @@ impl CStore {\n         )\n     }\n \n-    pub fn get_span_untracked(&self, def_id: DefId, sess: &Session) -> Span {\n+    pub fn def_span_untracked(&self, def_id: DefId, sess: &Session) -> Span {\n         self.get_crate_data(def_id.krate).get_span(def_id.index, sess)\n     }\n \n-    pub fn def_kind(&self, def: DefId) -> DefKind {\n+    pub fn def_kind_untracked(&self, def: DefId) -> DefKind {\n         self.get_crate_data(def.krate).def_kind(def.index)\n     }\n \n-    pub fn item_generics_num_lifetimes(&self, def_id: DefId, sess: &Session) -> usize {\n-        self.get_crate_data(def_id.krate).get_generics(def_id.index, sess).own_counts().lifetimes\n-    }\n-\n-    pub fn module_expansion_untracked(&self, def_id: DefId, sess: &Session) -> ExpnId {\n-        self.get_crate_data(def_id.krate).module_expansion(def_id.index, sess)\n+    pub fn expn_that_defined_untracked(&self, def_id: DefId, sess: &Session) -> ExpnId {\n+        self.get_crate_data(def_id.krate).get_expn_that_defined(def_id.index, sess)\n     }\n \n     /// Only public-facing way to traverse all the definitions in a non-local crate.\n@@ -560,14 +559,6 @@ impl CStore {\n         self.get_crate_data(cnum).num_def_ids()\n     }\n \n-    pub fn item_attrs_untracked<'a>(\n-        &'a self,\n-        def_id: DefId,\n-        sess: &'a Session,\n-    ) -> impl Iterator<Item = ast::Attribute> + 'a {\n-        self.get_crate_data(def_id.krate).get_item_attrs(def_id.index, sess)\n-    }\n-\n     pub fn get_proc_macro_quoted_span_untracked(\n         &self,\n         cnum: CrateNum,"}, {"sha": "2652a4280d37391da594aab264c9d60a02b83b0b", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::mir::interpret;\n use rustc_middle::query::LocalCrate;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_middle::util::common::to_readable_str;\n@@ -1881,7 +1881,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         self.tcx,\n                         trait_ref.self_ty(),\n                         TreatParams::AsCandidateKey,\n-                        TreatProjections::AsCandidateKey,\n                     );\n \n                     fx_hash_map"}, {"sha": "9f16ecbdaa9334373dbddfc7eace93d48b490a5d", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -36,7 +36,7 @@ macro_rules! arena_types {\n             )>,\n             [] output_filenames: std::sync::Arc<rustc_session::config::OutputFilenames>,\n             [] metadata_loader: rustc_data_structures::steal::Steal<Box<rustc_session::cstore::MetadataLoaderDyn>>,\n-            [] crate_for_resolver: rustc_data_structures::steal::Steal<rustc_ast::ast::Crate>,\n+            [] crate_for_resolver: rustc_data_structures::steal::Steal<(rustc_ast::Crate, rustc_ast::AttrVec)>,\n             [] resolutions: rustc_middle::ty::ResolverGlobalCtxt,\n             [decode] unsafety_check_result: rustc_middle::mir::UnsafetyCheckResult,\n             [decode] code_region: rustc_middle::mir::coverage::CodeRegion,"}, {"sha": "9c575f6eb9fd0f04759d35c9a2d7dfdda1c1484e", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1967,7 +1967,8 @@ impl<'tcx> Rvalue<'tcx> {\n                 | CastKind::PtrToPtr\n                 | CastKind::Pointer(_)\n                 | CastKind::PointerFromExposedAddress\n-                | CastKind::DynStar,\n+                | CastKind::DynStar\n+                | CastKind::Transmute,\n                 _,\n                 _,\n             )"}, {"sha": "bbd913d071d48783b9213cfc52b8fbc5b76288b2", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1156,6 +1156,13 @@ pub enum CastKind {\n     IntToFloat,\n     PtrToPtr,\n     FnPtrToPtr,\n+    /// Reinterpret the bits of the input as a different type.\n+    ///\n+    /// MIR is well-formed if the input and output types have different sizes,\n+    /// but running a transmute between differently-sized types is UB.\n+    ///\n+    /// Allowed only in [`MirPhase::Runtime`]; Earlier it's a [`TerminatorKind::Call`].\n+    Transmute,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]"}, {"sha": "9203dd59a7e6382f78413c853605cbbd227af3a8", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -2116,7 +2116,7 @@ rustc_queries! {\n         desc { \"raw operations for metadata file access\" }\n     }\n \n-    query crate_for_resolver((): ()) -> &'tcx Steal<rustc_ast::ast::Crate> {\n+    query crate_for_resolver((): ()) -> &'tcx Steal<(rustc_ast::Crate, rustc_ast::AttrVec)> {\n         feedable\n         no_hash\n         desc { \"the ast before macro expansion and name resolution\" }"}, {"sha": "669d50a7fda6705f6ec93814278767b33ed4ad74", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -56,21 +56,22 @@ pub enum TreatParams {\n     AsCandidateKey,\n     /// Treat parameters as placeholders in the given environment. This is the\n     /// correct mode for *lookup*, as during candidate selection.\n+    ///\n+    /// This also treats projections with inference variables as infer vars\n+    /// since they could be further normalized.\n     ForLookup,\n+    /// Treat parameters as placeholders in the given environment. This is the\n+    /// correct mode for *lookup*, as during candidate selection.\n+    ///\n+    /// N.B. during deep rejection, this acts identically to `ForLookup`.\n+    NextSolverLookup,\n }\n \n /// During fast-rejection, we have the choice of treating projection types\n /// as either simplifyable or not, depending on whether we expect the projection\n /// to be normalized/rigid.\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n pub enum TreatProjections {\n-    /// In candidates, we may be able to normalize the projection\n-    /// after instantiating the candidate and equating it with a goal.\n-    ///\n-    /// We must assume that the `impl<T> Trait<T> for <T as Id>::This`\n-    /// can apply to all self types so we don't return a simplified type\n-    /// for `<T as Id>::This`.\n-    AsCandidateKey,\n     /// In the old solver we don't try to normalize projections\n     /// when looking up impls and only access them by using the\n     /// current self type. This means that if the self type is\n@@ -107,7 +108,6 @@ pub fn simplify_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     treat_params: TreatParams,\n-    treat_projections: TreatProjections,\n ) -> Option<SimplifiedType> {\n     match *ty.kind() {\n         ty::Bool => Some(BoolSimplifiedType),\n@@ -136,13 +136,20 @@ pub fn simplify_type<'tcx>(\n         ty::FnPtr(f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n         ty::Placeholder(..) => Some(PlaceholderSimplifiedType),\n         ty::Param(_) => match treat_params {\n-            TreatParams::ForLookup => Some(PlaceholderSimplifiedType),\n+            TreatParams::ForLookup | TreatParams::NextSolverLookup => {\n+                Some(PlaceholderSimplifiedType)\n+            }\n             TreatParams::AsCandidateKey => None,\n         },\n-        ty::Alias(..) => match treat_projections {\n-            TreatProjections::ForLookup if !ty.needs_infer() => Some(PlaceholderSimplifiedType),\n-            TreatProjections::NextSolverLookup => Some(PlaceholderSimplifiedType),\n-            TreatProjections::AsCandidateKey | TreatProjections::ForLookup => None,\n+        ty::Alias(..) => match treat_params {\n+            // When treating `ty::Param` as a placeholder, projections also\n+            // don't unify with anything else as long as they are fully normalized.\n+            //\n+            // We will have to be careful with lazy normalization here.\n+            // FIXME(lazy_normalization): This is probably not right...\n+            TreatParams::ForLookup if !ty.has_non_region_infer() => Some(PlaceholderSimplifiedType),\n+            TreatParams::NextSolverLookup => Some(PlaceholderSimplifiedType),\n+            TreatParams::ForLookup | TreatParams::AsCandidateKey => None,\n         },\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n         ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n@@ -310,7 +317,7 @@ impl DeepRejectCtxt {\n             // Depending on the value of `treat_obligation_params`, we either\n             // treat generic parameters like placeholders or like inference variables.\n             ty::Param(_) => match self.treat_obligation_params {\n-                TreatParams::ForLookup => false,\n+                TreatParams::ForLookup | TreatParams::NextSolverLookup => false,\n                 TreatParams::AsCandidateKey => true,\n             },\n \n@@ -348,7 +355,7 @@ impl DeepRejectCtxt {\n         let k = impl_ct.kind();\n         match obligation_ct.kind() {\n             ty::ConstKind::Param(_) => match self.treat_obligation_params {\n-                TreatParams::ForLookup => false,\n+                TreatParams::ForLookup | TreatParams::NextSolverLookup => false,\n                 TreatParams::AsCandidateKey => true,\n             },\n "}, {"sha": "5a6ee1238112cb14dc2207cf463a1d1bbca256f5", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -288,7 +288,7 @@ impl FlagComputation {\n                 self.add_ty(ty);\n             }\n             ty::PredicateKind::Ambiguous => {}\n-            ty::PredicateKind::AliasEq(t1, t2) => {\n+            ty::PredicateKind::AliasRelate(t1, t2, _) => {\n                 self.add_term(t1);\n                 self.add_term(t2);\n             }"}, {"sha": "e3cd5cca785aacf4bc6a1adf8b1db48f1b492df4", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -543,7 +543,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::Clause(Clause::TypeOutlives(_))\n             | PredicateKind::Clause(Clause::Projection(_))\n             | PredicateKind::Clause(Clause::ConstArgHasType(..))\n-            | PredicateKind::AliasEq(..)\n+            | PredicateKind::AliasRelate(..)\n             | PredicateKind::ObjectSafe(_)\n             | PredicateKind::ClosureKind(_, _, _)\n             | PredicateKind::Subtype(_)\n@@ -640,7 +640,23 @@ pub enum PredicateKind<'tcx> {\n     /// This predicate requires two terms to be equal to eachother.\n     ///\n     /// Only used for new solver\n-    AliasEq(Term<'tcx>, Term<'tcx>),\n+    AliasRelate(Term<'tcx>, Term<'tcx>, AliasRelationDirection),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n+#[derive(HashStable, Debug)]\n+pub enum AliasRelationDirection {\n+    Equate,\n+    Subtype,\n+}\n+\n+impl std::fmt::Display for AliasRelationDirection {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            AliasRelationDirection::Equate => write!(f, \" == \"),\n+            AliasRelationDirection::Subtype => write!(f, \" <: \"),\n+        }\n+    }\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -976,11 +992,11 @@ impl<'tcx> Term<'tcx> {\n         }\n     }\n \n-    /// This function returns `None` for `AliasKind::Opaque`.\n+    /// This function returns the inner `AliasTy` if this term is a projection.\n     ///\n     /// FIXME: rename `AliasTy` to `AliasTerm` and make sure we correctly\n     /// deal with constants.\n-    pub fn to_alias_term_no_opaque(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n+    pub fn to_projection_term(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n         match self.unpack() {\n             TermKind::Ty(ty) => match ty.kind() {\n                 ty::Alias(kind, alias_ty) => match kind {\n@@ -1035,6 +1051,21 @@ impl<'tcx> TermKind<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum ParamTerm {\n+    Ty(ParamTy),\n+    Const(ParamConst),\n+}\n+\n+impl ParamTerm {\n+    pub fn index(self) -> usize {\n+        match self {\n+            ParamTerm::Ty(ty) => ty.index as usize,\n+            ParamTerm::Const(ct) => ct.index as usize,\n+        }\n+    }\n+}\n+\n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n ///\n@@ -1206,7 +1237,7 @@ impl<'tcx> Predicate<'tcx> {\n             PredicateKind::Clause(Clause::Trait(t)) => Some(predicate.rebind(t)),\n             PredicateKind::Clause(Clause::Projection(..))\n             | PredicateKind::Clause(Clause::ConstArgHasType(..))\n-            | PredicateKind::AliasEq(..)\n+            | PredicateKind::AliasRelate(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))\n@@ -1227,7 +1258,7 @@ impl<'tcx> Predicate<'tcx> {\n             PredicateKind::Clause(Clause::Projection(t)) => Some(predicate.rebind(t)),\n             PredicateKind::Clause(Clause::Trait(..))\n             | PredicateKind::Clause(Clause::ConstArgHasType(..))\n-            | PredicateKind::AliasEq(..)\n+            | PredicateKind::AliasRelate(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))\n@@ -1249,7 +1280,7 @@ impl<'tcx> Predicate<'tcx> {\n             PredicateKind::Clause(Clause::Trait(..))\n             | PredicateKind::Clause(Clause::ConstArgHasType(..))\n             | PredicateKind::Clause(Clause::Projection(..))\n-            | PredicateKind::AliasEq(..)\n+            | PredicateKind::AliasRelate(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))"}, {"sha": "de4c703107e1405f8aa05594e2d5733e6ec06943", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -704,7 +704,11 @@ pub trait PrettyPrinter<'tcx>:\n                 ty::BoundTyKind::Anon(bv) => {\n                     self.pretty_print_bound_var(debruijn, ty::BoundVar::from_u32(bv))?\n                 }\n-                ty::BoundTyKind::Param(_, s) => p!(write(\"{}\", s)),\n+                ty::BoundTyKind::Param(_, s) => match self.should_print_verbose() {\n+                    true if debruijn == ty::INNERMOST => p!(write(\"^{}\", s)),\n+                    true => p!(write(\"^{}_{}\", debruijn.index(), s)),\n+                    false => p!(write(\"{}\", s)),\n+                },\n             },\n             ty::Adt(def, substs) => {\n                 p!(print_def_path(def.did(), substs));\n@@ -2847,7 +2851,7 @@ define_print_and_forward_display! {\n                 p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n             ty::PredicateKind::Ambiguous => p!(\"ambiguous\"),\n-            ty::PredicateKind::AliasEq(t1, t2) => p!(print(t1), \" == \", print(t2)),\n+            ty::PredicateKind::AliasRelate(t1, t2, dir) => p!(print(t1), write(\" {} \", dir), print(t2)),\n         }\n     }\n "}, {"sha": "c6bb8146795869ef95866a097556ea79766fae97", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -177,7 +177,9 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n                 write!(f, \"TypeWellFormedFromEnv({:?})\", ty)\n             }\n             ty::PredicateKind::Ambiguous => write!(f, \"Ambiguous\"),\n-            ty::PredicateKind::AliasEq(t1, t2) => write!(f, \"AliasEq({t1:?}, {t2:?})\"),\n+            ty::PredicateKind::AliasRelate(t1, t2, dir) => {\n+                write!(f, \"AliasRelate({t1:?}, {dir:?}, {t2:?})\")\n+            }\n         }\n     }\n }\n@@ -250,6 +252,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::AssocItem,\n     crate::ty::AssocKind,\n     crate::ty::AliasKind,\n+    crate::ty::AliasRelationDirection,\n     crate::ty::Placeholder<crate::ty::BoundRegionKind>,\n     crate::ty::Placeholder<crate::ty::BoundTyKind>,\n     crate::ty::ClosureKind,"}, {"sha": "6747da7abd3af571fdfb5aa362da403c44d77816", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -153,12 +153,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n     ) -> impl Iterator<Item = DefId> + 'tcx {\n         let impls = self.trait_impls_of(trait_def_id);\n-        if let Some(simp) = fast_reject::simplify_type(\n-            self,\n-            self_ty,\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        ) {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsCandidateKey) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 return impls.iter().copied();\n             }\n@@ -191,13 +186,17 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n+        // Note that we're using `TreatParams::ForLookup` to query `non_blanket_impls` while using\n+        // `TreatParams::AsCandidateKey` while actually adding them.\n+        let treat_params = match treat_projections {\n+            TreatProjections::NextSolverLookup => TreatParams::NextSolverLookup,\n+            TreatProjections::ForLookup => TreatParams::ForLookup,\n+        };\n         // This way, when searching for some impl for `T: Trait`, we do not look at any impls\n         // whose outer level is not a parameter or projection. Especially for things like\n         // `T: Clone` this is incredibly useful as we would otherwise look at all the impls\n         // of `Clone` for `Option<T>`, `Vec<T>`, `ConcreteType` and so on.\n-        if let Some(simp) =\n-            fast_reject::simplify_type(self, self_ty, TreatParams::ForLookup, treat_projections)\n-        {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, treat_params) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n                     if let result @ Some(_) = f(impl_def_id) {\n@@ -258,12 +257,9 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n             continue;\n         }\n \n-        if let Some(simplified_self_ty) = fast_reject::simplify_type(\n-            tcx,\n-            impl_self_ty,\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        ) {\n+        if let Some(simplified_self_ty) =\n+            fast_reject::simplify_type(tcx, impl_self_ty, TreatParams::AsCandidateKey)\n+        {\n             impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n         } else {\n             impls.blanket_impls.push(impl_def_id);"}, {"sha": "bf58b3090fb8ec8a75f62e46d3ec8474e54545e3", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -137,6 +137,10 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n         parse_by_kind!(self, expr_id, expr, \"rvalue\",\n             @call(\"mir_discriminant\", args) => self.parse_place(args[0]).map(Rvalue::Discriminant),\n+            @call(\"mir_cast_transmute\", args) => {\n+                let source = self.parse_operand(args[0])?;\n+                Ok(Rvalue::Cast(CastKind::Transmute, source, expr.ty))\n+            },\n             @call(\"mir_checked\", args) => {\n                 parse_by_kind!(self, args[0], _, \"binary op\",\n                     ExprKind::Binary { op, lhs, rhs } => Ok(Rvalue::CheckedBinaryOp("}, {"sha": "3b775f590a4c1fa8427ebd66e6a33f6d6c88a177", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -566,41 +566,51 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Rvalue::Use(Operand::Move(val))\n             }\n             BinOp::Shl | BinOp::Shr if self.check_overflow && ty.is_integral() => {\n-                // Consider that the shift overflows if `rhs < 0` or `rhs >= bits`.\n-                // This can be encoded as a single operation as `(rhs & -bits) != 0`.\n-                let (size, _) = ty.int_size_and_signed(self.tcx);\n-                let bits = size.bits();\n-                debug_assert!(bits.is_power_of_two());\n-                let mask = !((bits - 1) as u128);\n-\n+                // For an unsigned RHS, the shift is in-range for `rhs < bits`.\n+                // For a signed RHS, `IntToInt` cast to the equivalent unsigned\n+                // type and do that same comparison.  Because the type is the\n+                // same size, there's no negative shift amount that ends up\n+                // overlapping with valid ones, thus it catches negatives too.\n+                let (lhs_size, _) = ty.int_size_and_signed(self.tcx);\n                 let rhs_ty = rhs.ty(&self.local_decls, self.tcx);\n                 let (rhs_size, _) = rhs_ty.int_size_and_signed(self.tcx);\n-                let mask = Operand::const_from_scalar(\n+\n+                let (unsigned_rhs, unsigned_ty) = match rhs_ty.kind() {\n+                    ty::Uint(_) => (rhs.to_copy(), rhs_ty),\n+                    ty::Int(int_width) => {\n+                        let uint_ty = self.tcx.mk_mach_uint(int_width.to_unsigned());\n+                        let rhs_temp = self.temp(uint_ty, span);\n+                        self.cfg.push_assign(\n+                            block,\n+                            source_info,\n+                            rhs_temp,\n+                            Rvalue::Cast(CastKind::IntToInt, rhs.to_copy(), uint_ty),\n+                        );\n+                        (Operand::Move(rhs_temp), uint_ty)\n+                    }\n+                    _ => unreachable!(\"only integers are shiftable\"),\n+                };\n+\n+                // This can't overflow because the largest shiftable types are 128-bit,\n+                // which fits in `u8`, the smallest possible `unsigned_ty`.\n+                // (And `from_uint` will `bug!` if that's ever no longer true.)\n+                let lhs_bits = Operand::const_from_scalar(\n                     self.tcx,\n-                    rhs_ty,\n-                    Scalar::from_uint(rhs_size.truncate(mask), rhs_size),\n+                    unsigned_ty,\n+                    Scalar::from_uint(lhs_size.bits(), rhs_size),\n                     span,\n                 );\n \n-                let outer_bits = self.temp(rhs_ty, span);\n-                self.cfg.push_assign(\n-                    block,\n-                    source_info,\n-                    outer_bits,\n-                    Rvalue::BinaryOp(BinOp::BitAnd, Box::new((rhs.to_copy(), mask))),\n-                );\n-\n-                let overflows = self.temp(bool_ty, span);\n-                let zero = self.zero_literal(span, rhs_ty);\n+                let inbounds = self.temp(bool_ty, span);\n                 self.cfg.push_assign(\n                     block,\n                     source_info,\n-                    overflows,\n-                    Rvalue::BinaryOp(BinOp::Ne, Box::new((Operand::Move(outer_bits), zero))),\n+                    inbounds,\n+                    Rvalue::BinaryOp(BinOp::Lt, Box::new((unsigned_rhs, lhs_bits))),\n                 );\n \n                 let overflow_err = AssertKind::Overflow(op, lhs.to_copy(), rhs.to_copy());\n-                block = self.assert(block, Operand::Move(overflows), false, overflow_err, span);\n+                block = self.assert(block, Operand::Move(inbounds), true, overflow_err, span);\n                 Rvalue::BinaryOp(op, Box::new((lhs, rhs)))\n             }\n             BinOp::Div | BinOp::Rem if ty.is_integral() => {"}, {"sha": "c1cf6ee0f9ec12d3ed10efce7f520f87be1edb79", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -504,6 +504,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n                 return None;\n             }\n+            // Do not try creating references, nor any types with potentially-complex\n+            // invariants. This avoids an issue where checking validity would do a\n+            // bunch of work generating a nice message about the invariant violation,\n+            // only to not show it to anyone (since this isn't the lint).\n+            Rvalue::Cast(CastKind::Transmute, op, dst_ty) if !dst_ty.is_primitive() => {\n+                trace!(\"skipping Transmute of {:?} to {:?}\", op, dst_ty);\n+\n+                return None;\n+            }\n \n             // There's no other checking to do at this time.\n             Rvalue::Aggregate(..)"}, {"sha": "6a7ceb8fef73ff75ecdd82261d41a980f6bf4a30", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -221,6 +221,32 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             terminator.kind = TerminatorKind::Goto { target };\n                         }\n                     }\n+                    sym::transmute => {\n+                        let dst_ty = destination.ty(local_decls, tcx).ty;\n+                        let Ok([arg]) = <[_; 1]>::try_from(std::mem::take(args)) else {\n+                            span_bug!(\n+                                terminator.source_info.span,\n+                                \"Wrong number of arguments for transmute intrinsic\",\n+                            );\n+                        };\n+\n+                        // Always emit the cast, even if we transmute to an uninhabited type,\n+                        // because that lets CTFE and codegen generate better error messages\n+                        // when such a transmute actually ends up reachable.\n+                        block.statements.push(Statement {\n+                            source_info: terminator.source_info,\n+                            kind: StatementKind::Assign(Box::new((\n+                                *destination,\n+                                Rvalue::Cast(CastKind::Transmute, arg, dst_ty),\n+                            ))),\n+                        });\n+\n+                        if let Some(target) = *target {\n+                            terminator.kind = TerminatorKind::Goto { target };\n+                        } else {\n+                            terminator.kind = TerminatorKind::Unreachable;\n+                        }\n+                    }\n                     _ if intrinsic_name.as_str().starts_with(\"simd_shuffle\") => {\n                         validate_simd_shuffle(tcx, args, terminator.source_info.span);\n                     }"}, {"sha": "27e5cb9f0d014fbb4b1146bb24d9e12f57262730", "filename": "compiler/rustc_plugin_impl/src/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -3,7 +3,7 @@\n use crate::errors::{LoadPluginError, MalformedPluginAttribute};\n use crate::Registry;\n use libloading::Library;\n-use rustc_ast::Crate;\n+use rustc_ast::Attribute;\n use rustc_metadata::locator;\n use rustc_session::cstore::MetadataLoader;\n use rustc_session::Session;\n@@ -20,11 +20,11 @@ type PluginRegistrarFn = fn(&mut Registry<'_>);\n pub fn load_plugins(\n     sess: &Session,\n     metadata_loader: &dyn MetadataLoader,\n-    krate: &Crate,\n+    attrs: &[Attribute],\n ) -> Vec<PluginRegistrarFn> {\n     let mut plugins = Vec::new();\n \n-    for attr in &krate.attrs {\n+    for attr in attrs {\n         if !attr.has_name(sym::plugin) {\n             continue;\n         }"}, {"sha": "3be0160d56173d40a6e8878a44ec161220334fb6", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -180,7 +180,7 @@ where\n             | ty::PredicateKind::ConstEquate(_, _)\n             | ty::PredicateKind::TypeWellFormedFromEnv(_)\n             | ty::PredicateKind::Ambiguous\n-            | ty::PredicateKind::AliasEq(_, _) => bug!(\"unexpected predicate: {:?}\", predicate),\n+            | ty::PredicateKind::AliasRelate(..) => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }\n "}, {"sha": "19ccb3a6484af217e1c9b4309c9987dcbd180267", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -27,7 +27,6 @@ use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_metadata::creader::LoadedMacro;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::{bug, ty};\n-use rustc_session::cstore::CrateStore;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -115,34 +114,28 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         if !def_id.is_local() {\n-            let def_kind = self.cstore().def_kind(def_id);\n-            match def_kind {\n-                DefKind::Mod | DefKind::Enum | DefKind::Trait => {\n-                    let def_key = self.cstore().def_key(def_id);\n-                    let parent = def_key.parent.map(|index| {\n-                        self.get_nearest_non_block_module(DefId { index, krate: def_id.krate })\n-                    });\n-                    let name = if let Some(cnum) = def_id.as_crate_root() {\n-                        self.cstore().crate_name(cnum)\n-                    } else {\n-                        def_key.disambiguated_data.data.get_opt_name().expect(\"module without name\")\n-                    };\n-\n-                    let expn_id = self.cstore().module_expansion_untracked(def_id, &self.tcx.sess);\n-                    Some(self.new_module(\n-                        parent,\n-                        ModuleKind::Def(def_kind, def_id, name),\n-                        expn_id,\n-                        self.def_span(def_id),\n-                        // FIXME: Account for `#[no_implicit_prelude]` attributes.\n-                        parent.map_or(false, |module| module.no_implicit_prelude),\n-                    ))\n-                }\n-                _ => None,\n+            // Query `def_kind` is not used because query system overhead is too expensive here.\n+            let def_kind = self.cstore().def_kind_untracked(def_id);\n+            if let DefKind::Mod | DefKind::Enum | DefKind::Trait = def_kind {\n+                let parent = self\n+                    .tcx\n+                    .opt_parent(def_id)\n+                    .map(|parent_id| self.get_nearest_non_block_module(parent_id));\n+                // Query `expn_that_defined` is not used because\n+                // hashing spans in its result is expensive.\n+                let expn_id = self.cstore().expn_that_defined_untracked(def_id, &self.tcx.sess);\n+                return Some(self.new_module(\n+                    parent,\n+                    ModuleKind::Def(def_kind, def_id, self.tcx.item_name(def_id)),\n+                    expn_id,\n+                    self.def_span(def_id),\n+                    // FIXME: Account for `#[no_implicit_prelude]` attributes.\n+                    parent.map_or(false, |module| module.no_implicit_prelude),\n+                ));\n             }\n-        } else {\n-            None\n         }\n+\n+        None\n     }\n \n     pub(crate) fn expn_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n@@ -204,6 +197,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     pub(crate) fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n+        // Query `module_children` is not used because hashing spans in its result is expensive.\n         let children =\n             Vec::from_iter(self.cstore().module_children_untracked(module.def_id(), self.tcx.sess));\n         for child in children {"}, {"sha": "dbf6cec788b5a15aebe0e8dd0c25a8180348845c", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -32,9 +32,10 @@ use rustc_ast::visit::{self, Visitor};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{pluralize, MultiSpan};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_session::lint::builtin::{MACRO_USE_EXTERN_CRATE, UNUSED_EXTERN_CRATES, UNUSED_IMPORTS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n-use rustc_span::symbol::Ident;\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::{Span, DUMMY_SP};\n \n struct UnusedImport<'a> {\n@@ -58,6 +59,7 @@ struct UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     base_use_tree: Option<&'a ast::UseTree>,\n     base_id: ast::NodeId,\n     item_span: Span,\n+    base_use_is_pub: bool,\n }\n \n struct ExternCrateToLint {\n@@ -110,6 +112,35 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n             unused: Default::default(),\n         })\n     }\n+\n+    fn check_import_as_underscore(&mut self, item: &ast::UseTree, id: ast::NodeId) {\n+        match item.kind {\n+            ast::UseTreeKind::Simple(Some(ident)) => {\n+                if ident.name == kw::Underscore\n+                    && !self\n+                        .r\n+                        .import_res_map\n+                        .get(&id)\n+                        .map(|per_ns| {\n+                            per_ns.iter().filter_map(|res| res.as_ref()).any(|res| {\n+                                matches!(res, Res::Def(DefKind::Trait | DefKind::TraitAlias, _))\n+                            })\n+                        })\n+                        .unwrap_or(false)\n+                {\n+                    self.unused_import(self.base_id).add(id);\n+                }\n+            }\n+            ast::UseTreeKind::Nested(ref items) => self.check_imports_as_underscore(items),\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_imports_as_underscore(&mut self, items: &[(ast::UseTree, ast::NodeId)]) {\n+        for (item, id) in items {\n+            self.check_import_as_underscore(item, *id);\n+        }\n+    }\n }\n \n impl<'a, 'b, 'tcx> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n@@ -119,7 +150,8 @@ impl<'a, 'b, 'tcx> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n             // whether they're used or not. Also ignore imports with a dummy span\n             // because this means that they were generated in some fashion by the\n             // compiler and we don't need to consider them.\n-            ast::ItemKind::Use(..) if item.vis.kind.is_pub() || item.span.is_dummy() => return,\n+            ast::ItemKind::Use(..) if item.span.is_dummy() => return,\n+            ast::ItemKind::Use(..) => self.base_use_is_pub = item.vis.kind.is_pub(),\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 self.extern_crate_items.push(ExternCrateToLint {\n                     id: item.id,\n@@ -146,6 +178,11 @@ impl<'a, 'b, 'tcx> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n             self.base_use_tree = Some(use_tree);\n         }\n \n+        if self.base_use_is_pub {\n+            self.check_import_as_underscore(use_tree, id);\n+            return;\n+        }\n+\n         if let ast::UseTreeKind::Nested(ref items) = use_tree.kind {\n             if items.is_empty() {\n                 self.unused_import(self.base_id).add(id);\n@@ -300,6 +337,7 @@ impl Resolver<'_, '_> {\n             base_use_tree: None,\n             base_id: ast::DUMMY_NODE_ID,\n             item_span: DUMMY_SP,\n+            base_use_is_pub: false,\n         };\n         visit::walk_crate(&mut visitor, krate);\n "}, {"sha": "a1ae9b8a52181c9ba52788fcb181a220ebfa8c30", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -4,6 +4,7 @@ use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n use rustc_ast::Crate;\n use rustc_ast::EnumDef;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n@@ -70,11 +71,11 @@ impl Resolver<'_, '_> {\n impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n     /// Fills the `Resolver::effective_visibilities` table with public & exported items\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n-    /// need access to a TyCtxt for that.\n+    /// need access to a TyCtxt for that. Returns the set of ambiguous re-exports.\n     pub(crate) fn compute_effective_visibilities<'c>(\n         r: &'r mut Resolver<'a, 'tcx>,\n         krate: &'c Crate,\n-    ) {\n+    ) -> FxHashSet<Interned<'a, NameBinding<'a>>> {\n         let mut visitor = EffectiveVisibilitiesVisitor {\n             r,\n             def_effective_visibilities: Default::default(),\n@@ -93,18 +94,26 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         }\n         visitor.r.effective_visibilities = visitor.def_effective_visibilities;\n \n+        let mut exported_ambiguities = FxHashSet::default();\n+\n         // Update visibilities for import def ids. These are not used during the\n         // `EffectiveVisibilitiesVisitor` pass, because we have more detailed binding-based\n         // information, but are used by later passes. Effective visibility of an import def id\n         // is the maximum value among visibilities of bindings corresponding to that def id.\n         for (binding, eff_vis) in visitor.import_effective_visibilities.iter() {\n             let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n-            if let Some(node_id) = import.id() {\n-                r.effective_visibilities.update_eff_vis(r.local_def_id(node_id), eff_vis, r.tcx)\n+            if !binding.is_ambiguity() {\n+                if let Some(node_id) = import.id() {\n+                    r.effective_visibilities.update_eff_vis(r.local_def_id(node_id), eff_vis, r.tcx)\n+                }\n+            } else if binding.ambiguity.is_some() && eff_vis.is_public_at_level(Level::Reexported) {\n+                exported_ambiguities.insert(*binding);\n             }\n         }\n \n         info!(\"resolve::effective_visibilities: {:#?}\", r.effective_visibilities);\n+\n+        exported_ambiguities\n     }\n \n     /// Update effective visibilities of bindings in the given module,\n@@ -115,21 +124,44 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         let resolutions = self.r.resolutions(module);\n \n         for (_, name_resolution) in resolutions.borrow().iter() {\n-            if let Some(mut binding) = name_resolution.borrow().binding() && !binding.is_ambiguity() {\n-                // Set the given effective visibility level to `Level::Direct` and\n-                // sets the rest of the `use` chain to `Level::Reexported` until\n-                // we hit the actual exported item.\n-                let mut parent_id = ParentId::Def(module_id);\n-                while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind {\n-                    let binding_id = ImportId::new_unchecked(binding);\n-                    self.update_import(binding_id, parent_id);\n-\n-                    parent_id = ParentId::Import(binding_id);\n-                    binding = nested_binding;\n-                }\n+            if let Some(mut binding) = name_resolution.borrow().binding() {\n+                if !binding.is_ambiguity() {\n+                    // Set the given effective visibility level to `Level::Direct` and\n+                    // sets the rest of the `use` chain to `Level::Reexported` until\n+                    // we hit the actual exported item.\n+                    let mut parent_id = ParentId::Def(module_id);\n+                    while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind\n+                    {\n+                        let binding_id = ImportId::new_unchecked(binding);\n+                        self.update_import(binding_id, parent_id);\n+\n+                        parent_id = ParentId::Import(binding_id);\n+                        binding = nested_binding;\n+                    }\n+\n+                    if let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n+                        self.update_def(def_id, binding.vis.expect_local(), parent_id);\n+                    }\n+                } else {\n+                    // Put the root ambiguity binding and all reexports leading to it into the\n+                    // table. They are used by the `ambiguous_glob_reexports` lint. For all\n+                    // bindings added to the table here `is_ambiguity` returns true.\n+                    let mut parent_id = ParentId::Def(module_id);\n+                    while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind\n+                    {\n+                        let binding_id = ImportId::new_unchecked(binding);\n+                        self.update_import(binding_id, parent_id);\n \n-                if let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n-                    self.update_def(def_id, binding.vis.expect_local(), parent_id);\n+                        if binding.ambiguity.is_some() {\n+                            // Stop at the root ambiguity, further bindings in the chain should not\n+                            // be reexported because the root ambiguity blocks any access to them.\n+                            // (Those further bindings are most likely not ambiguities themselves.)\n+                            break;\n+                        }\n+\n+                        parent_id = ParentId::Import(binding_id);\n+                        binding = nested_binding;\n+                    }\n                 }\n             }\n         }"}, {"sha": "bc17ce571a7c03cdd3f67a7b880f234ed3c559e3", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -19,7 +19,9 @@ use rustc_hir::def::{self, DefKind, PartialRes};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::span_bug;\n use rustc_middle::ty;\n-use rustc_session::lint::builtin::{PUB_USE_OF_PRIVATE_EXTERN_CRATE, UNUSED_IMPORTS};\n+use rustc_session::lint::builtin::{\n+    AMBIGUOUS_GLOB_REEXPORTS, PUB_USE_OF_PRIVATE_EXTERN_CRATE, UNUSED_IMPORTS,\n+};\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::LocalExpnId;\n@@ -510,6 +512,34 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n+    pub(crate) fn check_reexport_ambiguities(\n+        &mut self,\n+        exported_ambiguities: FxHashSet<Interned<'a, NameBinding<'a>>>,\n+    ) {\n+        for module in self.arenas.local_modules().iter() {\n+            module.for_each_child(self, |this, ident, ns, binding| {\n+                if let NameBindingKind::Import { import, .. } = binding.kind\n+                && let Some((amb_binding, _)) = binding.ambiguity\n+                && binding.res() != Res::Err\n+                && exported_ambiguities.contains(&Interned::new_unchecked(binding))\n+                {\n+                    this.lint_buffer.buffer_lint_with_diagnostic(\n+                        AMBIGUOUS_GLOB_REEXPORTS,\n+                        import.root_id,\n+                        import.root_span,\n+                        \"ambiguous glob re-exports\",\n+                        BuiltinLintDiagnostics::AmbiguousGlobReexports {\n+                            name: ident.to_string(),\n+                            namespace: ns.descr().to_string(),\n+                            first_reexport_span: import.root_span,\n+                            duplicate_reexport_span: amb_binding.span,\n+                        },\n+                    );\n+                }\n+            });\n+        }\n+    }\n+\n     fn throw_unresolved_import_error(&self, errors: Vec<(&Import<'_>, UnresolvedImportError)>) {\n         if errors.is_empty() {\n             return;"}, {"sha": "0e84432a5b4bf85ff23fe93ffb824d2d0a81a220", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1168,7 +1168,7 @@ impl<'tcx> Resolver<'_, 'tcx> {\n         if let Some(def_id) = def_id.as_local() {\n             self.item_generics_num_lifetimes[&def_id]\n         } else {\n-            self.cstore().item_generics_num_lifetimes(def_id, self.tcx.sess)\n+            self.tcx.generics_of(def_id).own_counts().lifetimes\n         }\n     }\n \n@@ -1180,7 +1180,8 @@ impl<'tcx> Resolver<'_, 'tcx> {\n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     pub fn new(\n         tcx: TyCtxt<'tcx>,\n-        krate: &Crate,\n+        attrs: &[ast::Attribute],\n+        crate_span: Span,\n         arenas: &'a ResolverArenas<'a>,\n     ) -> Resolver<'a, 'tcx> {\n         let root_def_id = CRATE_DEF_ID.to_def_id();\n@@ -1189,8 +1190,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             None,\n             ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty),\n             ExpnId::root(),\n-            krate.spans.inner_span,\n-            attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n+            crate_span,\n+            attr::contains_name(attrs, sym::no_implicit_prelude),\n             &mut module_map,\n         );\n         let empty_module = arenas.new_module(\n@@ -1222,9 +1223,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             .map(|(name, _)| (Ident::from_str(name), Default::default()))\n             .collect();\n \n-        if !attr::contains_name(&krate.attrs, sym::no_core) {\n+        if !attr::contains_name(attrs, sym::no_core) {\n             extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n-            if !attr::contains_name(&krate.attrs, sym::no_std) {\n+            if !attr::contains_name(attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n             }\n         }\n@@ -1474,9 +1475,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         self.tcx.sess.time(\"resolve_crate\", || {\n             self.tcx.sess.time(\"finalize_imports\", || self.finalize_imports());\n-            self.tcx.sess.time(\"compute_effective_visibilities\", || {\n+            let exported_ambiguities = self.tcx.sess.time(\"compute_effective_visibilities\", || {\n                 EffectiveVisibilitiesVisitor::compute_effective_visibilities(self, krate)\n             });\n+            self.tcx.sess.time(\"check_reexport_ambiguities\", || {\n+                self.check_reexport_ambiguities(exported_ambiguities)\n+            });\n             self.tcx.sess.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n             self.tcx.sess.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));\n             self.tcx.sess.time(\"resolve_main\", || self.resolve_main());\n@@ -1871,7 +1875,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn def_span(&self, def_id: DefId) -> Span {\n         match def_id.as_local() {\n             Some(def_id) => self.tcx.source_span(def_id),\n-            None => self.cstore().get_span_untracked(def_id, self.tcx.sess),\n+            // Query `def_span` is not used because hashing its result span is expensive.\n+            None => self.cstore().def_span_untracked(def_id, self.tcx.sess),\n         }\n     }\n \n@@ -1906,10 +1911,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     return v.clone();\n                 }\n \n-                let attr = self\n-                    .cstore()\n-                    .item_attrs_untracked(def_id, self.tcx.sess)\n-                    .find(|a| a.has_name(sym::rustc_legacy_const_generics))?;\n+                let attr = self.tcx.get_attr(def_id, sym::rustc_legacy_const_generics)?;\n                 let mut ret = Vec::new();\n                 for meta in attr.meta_item_list()? {\n                     match meta.lit()?.kind {"}, {"sha": "48707d37a101cd38971673889d9b1577b38a9476", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -112,8 +112,8 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n \n pub(crate) fn registered_tools(tcx: TyCtxt<'_>, (): ()) -> RegisteredTools {\n     let mut registered_tools = RegisteredTools::default();\n-    let krate = tcx.crate_for_resolver(()).borrow();\n-    for attr in attr::filter_by_name(&krate.attrs, sym::register_tool) {\n+    let (_, pre_configured_attrs) = &*tcx.crate_for_resolver(()).borrow();\n+    for attr in attr::filter_by_name(pre_configured_attrs, sym::register_tool) {\n         for nested_meta in attr.meta_item_list().unwrap_or_default() {\n             match nested_meta.ident() {\n                 Some(ident) => {"}, {"sha": "2404928b254d6da2de8d6086d8bff53fa8579768", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,5 +1,6 @@\n //! A module for searching for libraries\n \n+use rustc_fs_util::try_canonicalize;\n use smallvec::{smallvec, SmallVec};\n use std::env;\n use std::fs;\n@@ -125,7 +126,7 @@ pub fn sysroot_candidates() -> SmallVec<[PathBuf; 2]> {\n     let target = crate::config::host_triple();\n     let mut sysroot_candidates: SmallVec<[PathBuf; 2]> =\n         smallvec![get_or_default_sysroot().expect(\"Failed finding sysroot\")];\n-    let path = current_dll_path().and_then(|s| s.canonicalize().map_err(|e| e.to_string()));\n+    let path = current_dll_path().and_then(|s| try_canonicalize(s).map_err(|e| e.to_string()));\n     if let Ok(dll) = path {\n         // use `parent` twice to chop off the file name and then also the\n         // directory containing the dll which should be either `lib` or `bin`.\n@@ -160,7 +161,7 @@ pub fn sysroot_candidates() -> SmallVec<[PathBuf; 2]> {\n pub fn get_or_default_sysroot() -> Result<PathBuf, String> {\n     // Follow symlinks. If the resolved path is relative, make it absolute.\n     fn canonicalize(path: PathBuf) -> PathBuf {\n-        let path = fs::canonicalize(&path).unwrap_or(path);\n+        let path = try_canonicalize(&path).unwrap_or(path);\n         // See comments on this target function, but the gist is that\n         // gcc chokes on verbatim paths which fs::canonicalize generates\n         // so we try to avoid those kinds of paths."}, {"sha": "c75af48e80af47e79797f05c773ea84869e7dfc2", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -4,6 +4,7 @@ use crate::early_error;\n use crate::lint;\n use crate::search_paths::SearchPath;\n use crate::utils::NativeLib;\n+use rustc_data_structures::profiling::TimePassesFormat;\n use rustc_errors::{LanguageIdentifier, TerminalUrl};\n use rustc_target::spec::{CodeModel, LinkerFlavorCli, MergeFunctions, PanicStrategy, SanitizerSet};\n use rustc_target::spec::{\n@@ -365,6 +366,7 @@ mod desc {\n     pub const parse_number: &str = \"a number\";\n     pub const parse_opt_number: &str = parse_number;\n     pub const parse_threads: &str = parse_number;\n+    pub const parse_time_passes_format: &str = \"`text` (default) or `json`\";\n     pub const parse_passes: &str = \"a space-separated list of passes, or `all`\";\n     pub const parse_panic_strategy: &str = \"either `unwind` or `abort`\";\n     pub const parse_opt_panic_strategy: &str = parse_panic_strategy;\n@@ -829,6 +831,21 @@ mod parse {\n         true\n     }\n \n+    pub(crate) fn parse_time_passes_format(slot: &mut TimePassesFormat, v: Option<&str>) -> bool {\n+        match v {\n+            None => true,\n+            Some(\"json\") => {\n+                *slot = TimePassesFormat::Json;\n+                true\n+            }\n+            Some(\"text\") => {\n+                *slot = TimePassesFormat::Text;\n+                true\n+            }\n+            Some(_) => false,\n+        }\n+    }\n+\n     pub(crate) fn parse_dump_mono_stats(slot: &mut DumpMonoStatsFormat, v: Option<&str>) -> bool {\n         match v {\n             None => true,\n@@ -1709,6 +1726,8 @@ options! {\n         \"measure time of each LLVM pass (default: no)\"),\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass (default: no)\"),\n+    time_passes_format: TimePassesFormat = (TimePassesFormat::Text, parse_time_passes_format, [UNTRACKED],\n+        \"the format to use for -Z time-passes (`text` (default) or `json`)\"),\n     tiny_const_eval_limit: bool = (false, parse_bool, [TRACKED],\n         \"sets a tiny, non-configurable limit for const eval; useful for compiler tests\"),\n     #[rustc_lint_opt_deny_field_access(\"use `Session::tls_model` instead of this field\")]"}, {"sha": "5730df9d5c6b9663b05c99ab2e4cfbead3331589", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1453,7 +1453,10 @@ pub fn build_session(\n         CguReuseTracker::new_disabled()\n     };\n \n-    let prof = SelfProfilerRef::new(self_profiler, sopts.unstable_opts.time_passes);\n+    let prof = SelfProfilerRef::new(\n+        self_profiler,\n+        sopts.unstable_opts.time_passes.then(|| sopts.unstable_opts.time_passes_format),\n+    );\n \n     let ctfe_backtrace = Lock::new(match env::var(\"RUSTC_CTFE_BACKTRACE\") {\n         Ok(ref val) if val == \"immediate\" => CtfeBacktrace::Immediate,"}, {"sha": "1d15e2c28d837ab158ad33fed369400dd55a02d8", "filename": "compiler/rustc_session/src/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_session%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_session%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Futils.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,5 +1,6 @@\n use crate::session::Session;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n+use rustc_fs_util::try_canonicalize;\n use std::path::{Path, PathBuf};\n \n impl Session {\n@@ -98,7 +99,7 @@ pub struct CanonicalizedPath {\n \n impl CanonicalizedPath {\n     pub fn new(path: &Path) -> Self {\n-        Self { original: path.to_owned(), canonicalized: std::fs::canonicalize(path).ok() }\n+        Self { original: path.to_owned(), canonicalized: try_canonicalize(path).ok() }\n     }\n \n     pub fn canonicalized(&self) -> &PathBuf {"}, {"sha": "4e7a8d166ae69fbbf38b8b40aa6cbed8d3231f77", "filename": "compiler/rustc_target/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_target%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_target%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2FCargo.toml?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -7,6 +7,7 @@ edition = \"2021\"\n bitflags = \"1.2.1\"\n tracing = \"0.1\"\n serde_json = \"1.0.59\"\n+rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_abi = { path = \"../rustc_abi\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_feature = { path = \"../rustc_feature\" }"}, {"sha": "2553b11d8789b95c2cf4534b569be9c883378d03", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -40,6 +40,7 @@ use crate::json::{Json, ToJson};\n use crate::spec::abi::{lookup as lookup_abi, Abi};\n use crate::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_fs_util::try_canonicalize;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::symbol::{sym, Symbol};\n use serde_json::Value;\n@@ -2949,7 +2950,7 @@ impl TargetTriple {\n \n     /// Creates a target triple from the passed target path.\n     pub fn from_path(path: &Path) -> Result<Self, io::Error> {\n-        let canonicalized_path = path.canonicalize()?;\n+        let canonicalized_path = try_canonicalize(path)?;\n         let contents = std::fs::read_to_string(&canonicalized_path).map_err(|err| {\n             io::Error::new(\n                 io::ErrorKind::InvalidInput,"}, {"sha": "efecaf33ef987a9579ab622f09c4d821760952aa", "filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -99,20 +99,20 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         original_values: Vec<ty::GenericArg<'tcx>>,\n         response: CanonicalResponse<'tcx>,\n-    ) -> Result<Certainty, NoSolution> {\n+    ) -> Result<(Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution> {\n         let substitution = self.compute_query_response_substitution(&original_values, &response);\n \n         let Response { var_values, external_constraints, certainty } =\n             response.substitute(self.tcx(), &substitution);\n \n-        self.unify_query_var_values(param_env, &original_values, var_values)?;\n+        let nested_goals = self.unify_query_var_values(param_env, &original_values, var_values)?;\n \n         // FIXME: implement external constraints.\n         let ExternalConstraintsData { region_constraints, opaque_types: _ } =\n             external_constraints.deref();\n         self.register_region_constraints(region_constraints);\n \n-        Ok(certainty)\n+        Ok((certainty, nested_goals))\n     }\n \n     /// This returns the substitutions to instantiate the bound variables of\n@@ -205,21 +205,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         original_values: &[ty::GenericArg<'tcx>],\n         var_values: CanonicalVarValues<'tcx>,\n-    ) -> Result<(), NoSolution> {\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n         assert_eq!(original_values.len(), var_values.len());\n+\n+        let mut nested_goals = vec![];\n         for (&orig, response) in iter::zip(original_values, var_values.var_values) {\n-            // This can fail due to the occurs check, see\n-            // `tests/ui/typeck/lazy-norm/equating-projection-cyclically.rs` for an example\n-            // where that can happen.\n-            //\n-            // FIXME: To deal with #105787 I also expect us to emit nested obligations here at\n-            // some point. We can figure out how to deal with this once we actually have\n-            // an ICE.\n-            let nested_goals = self.eq_and_get_goals(param_env, orig, response)?;\n-            assert!(nested_goals.is_empty(), \"{nested_goals:?}\");\n+            nested_goals.extend(self.eq_and_get_goals(param_env, orig, response)?);\n         }\n \n-        Ok(())\n+        Ok(nested_goals)\n     }\n \n     fn register_region_constraints(&mut self, region_constraints: &QueryRegionConstraints<'tcx>) {"}, {"sha": "e47b5ae21b5afafcc5e155c74bb05c84224193b7", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -70,17 +70,16 @@ pub trait InferCtxtEvalExt<'tcx> {\n     fn evaluate_root_goal(\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution>;\n+    ) -> Result<(bool, Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution>;\n }\n \n impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn evaluate_root_goal(\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n+    ) -> Result<(bool, Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution> {\n         let mode = if self.intercrate { SolverMode::Coherence } else { SolverMode::Normal };\n-\n         let mut search_graph = search_graph::SearchGraph::new(self.tcx, mode);\n \n         let mut ecx = EvalCtxt {\n@@ -152,13 +151,13 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         &mut self,\n         is_normalizes_to_hack: IsNormalizesToHack,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n+    ) -> Result<(bool, Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution> {\n         let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n \n         let has_changed = !canonical_response.value.var_values.is_identity();\n-        let certainty = self.instantiate_and_apply_query_response(\n+        let (certainty, nested_goals) = self.instantiate_and_apply_query_response(\n             goal.param_env,\n             orig_values,\n             canonical_response,\n@@ -186,7 +185,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             assert_eq!(certainty, canonical_response.value.certainty);\n         }\n \n-        Ok((has_changed, certainty))\n+        Ok((has_changed, certainty, nested_goals))\n     }\n \n     fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n@@ -236,9 +235,11 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n-                ty::PredicateKind::AliasEq(lhs, rhs) => {\n-                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n-                }\n+                ty::PredicateKind::AliasRelate(lhs, rhs, direction) => self\n+                    .compute_alias_relate_goal(Goal {\n+                        param_env,\n+                        predicate: (lhs, rhs, direction),\n+                    }),\n             }\n         } else {\n             let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n@@ -261,13 +262,14 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 let mut has_changed = Err(Certainty::Yes);\n \n                 if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n-                    let (_, certainty) = match this.evaluate_goal(\n+                    let (_, certainty, nested_goals) = match this.evaluate_goal(\n                         IsNormalizesToHack::Yes,\n                         goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n                     ) {\n                         Ok(r) => r,\n                         Err(NoSolution) => return Some(Err(NoSolution)),\n                     };\n+                    new_goals.goals.extend(nested_goals);\n \n                     if goal.predicate.projection_ty\n                         != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n@@ -306,11 +308,12 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 }\n \n                 for nested_goal in goals.goals.drain(..) {\n-                    let (changed, certainty) =\n+                    let (changed, certainty, nested_goals) =\n                         match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n                             Ok(result) => result,\n                             Err(NoSolution) => return Some(Err(NoSolution)),\n                         };\n+                    new_goals.goals.extend(nested_goals);\n \n                     if changed {\n                         has_changed = Ok(());\n@@ -470,6 +473,25 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             })\n     }\n \n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    pub(super) fn sub<T: ToTrace<'tcx>>(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        sub: T,\n+        sup: T,\n+    ) -> Result<(), NoSolution> {\n+        self.infcx\n+            .at(&ObligationCause::dummy(), param_env)\n+            .sub(DefineOpaqueTypes::No, sub, sup)\n+            .map(|InferOk { value: (), obligations }| {\n+                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to subtype\");\n+                NoSolution\n+            })\n+    }\n+\n     /// Equates two values returning the nested goals without adding them\n     /// to the nested goals of the `EvalCtxt`.\n     ///"}, {"sha": "76a2a5879114dc9377d15c8d03464bbf5a3657b4", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,6 +1,7 @@\n use std::mem;\n \n use rustc_infer::infer::InferCtxt;\n+use rustc_infer::traits::Obligation;\n use rustc_infer::traits::{\n     query::NoSolution, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n     PredicateObligation, SelectionError, TraitEngine,\n@@ -61,7 +62,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n             let mut has_changed = false;\n             for obligation in mem::take(&mut self.obligations) {\n                 let goal = obligation.clone().into();\n-                let (changed, certainty) = match infcx.evaluate_root_goal(goal) {\n+                let (changed, certainty, nested_goals) = match infcx.evaluate_root_goal(goal) {\n                     Ok(result) => result,\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {\n@@ -73,7 +74,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                         MismatchedProjectionTypes { err: TypeError::Mismatch },\n                                     )\n                                 }\n-                                ty::PredicateKind::AliasEq(_, _) => {\n+                                ty::PredicateKind::AliasRelate(_, _, _) => {\n                                     FulfillmentErrorCode::CodeProjectionError(\n                                         MismatchedProjectionTypes { err: TypeError::Mismatch },\n                                     )\n@@ -125,7 +126,16 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                         continue;\n                     }\n                 };\n-\n+                // Push any nested goals that we get from unifying our canonical response\n+                // with our obligation onto the fulfillment context.\n+                self.obligations.extend(nested_goals.into_iter().map(|goal| {\n+                    Obligation::new(\n+                        infcx.tcx,\n+                        obligation.cause.clone(),\n+                        goal.param_env,\n+                        goal.predicate,\n+                    )\n+                }));\n                 has_changed |= changed;\n                 match certainty {\n                     Certainty::Yes => {}"}, {"sha": "6a64dfdedd42fe6c40a3f6256b2997f895dbf0a4", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 77, "deletions": 43, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -13,7 +13,6 @@\n \n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n@@ -110,11 +109,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             // That won't actually reflect in the query response, so it seems moot.\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n         } else {\n-            let InferOk { value: (), obligations } = self\n-                .infcx\n-                .at(&ObligationCause::dummy(), goal.param_env)\n-                .sub(DefineOpaqueTypes::No, goal.predicate.a, goal.predicate.b)?;\n-            self.add_goals(obligations.into_iter().map(|pred| pred.into()));\n+            self.sub(goal.param_env, goal.predicate.a, goal.predicate.b)?;\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }\n@@ -165,55 +160,94 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(level = \"debug\", skip(self), ret)]\n-    fn compute_alias_eq_goal(\n+    fn compute_alias_relate_goal(\n         &mut self,\n-        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>)>,\n+        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>, ty::AliasRelationDirection)>,\n     ) -> QueryResult<'tcx> {\n         let tcx = self.tcx();\n+        // We may need to invert the alias relation direction if dealing an alias on the RHS.\n+        enum Invert {\n+            No,\n+            Yes,\n+        }\n+        let evaluate_normalizes_to =\n+            |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other, direction, invert| {\n+                debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n+                let result = ecx.probe(|ecx| {\n+                    let other = match direction {\n+                        // This is purely an optimization.\n+                        ty::AliasRelationDirection::Equate => other,\n+\n+                        ty::AliasRelationDirection::Subtype => {\n+                            let fresh = ecx.next_term_infer_of_kind(other);\n+                            let (sub, sup) = match invert {\n+                                Invert::No => (fresh, other),\n+                                Invert::Yes => (other, fresh),\n+                            };\n+                            ecx.sub(goal.param_env, sub, sup)?;\n+                            fresh\n+                        }\n+                    };\n+                    ecx.add_goal(goal.with(\n+                        tcx,\n+                        ty::Binder::dummy(ty::ProjectionPredicate {\n+                            projection_ty: alias,\n+                            term: other,\n+                        }),\n+                    ));\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                });\n+                debug!(\"evaluate_normalizes_to({alias}, {other}, {direction:?}) -> {result:?}\");\n+                result\n+            };\n \n-        let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other| {\n-            debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n-            let r = ecx.probe(|ecx| {\n-                ecx.add_goal(goal.with(\n-                    tcx,\n-                    ty::Binder::dummy(ty::ProjectionPredicate {\n-                        projection_ty: alias,\n-                        term: other,\n-                    }),\n-                ));\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            });\n-            debug!(\"evaluate_normalizes_to(..) -> {:?}\", r);\n-            r\n-        };\n+        let (lhs, rhs, direction) = goal.predicate;\n \n-        if goal.predicate.0.is_infer() || goal.predicate.1.is_infer() {\n+        if lhs.is_infer() || rhs.is_infer() {\n             bug!(\n-                \"`AliasEq` goal with an infer var on lhs or rhs which should have been instantiated\"\n+                \"`AliasRelate` goal with an infer var on lhs or rhs which should have been instantiated\"\n             );\n         }\n \n-        match (\n-            goal.predicate.0.to_alias_term_no_opaque(tcx),\n-            goal.predicate.1.to_alias_term_no_opaque(tcx),\n-        ) {\n-            (None, None) => bug!(\"`AliasEq` goal without an alias on either lhs or rhs\"),\n-            (Some(alias), None) => evaluate_normalizes_to(self, alias, goal.predicate.1),\n-            (None, Some(alias)) => evaluate_normalizes_to(self, alias, goal.predicate.0),\n-            (Some(alias_lhs), Some(alias_rhs)) => {\n-                debug!(\"compute_alias_eq_goal: both sides are aliases\");\n+        match (lhs.to_projection_term(tcx), rhs.to_projection_term(tcx)) {\n+            (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n \n-                let mut candidates = Vec::with_capacity(3);\n+            // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n+            (Some(alias_lhs), None) => {\n+                evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No)\n+            }\n \n-                // Evaluate all 3 potential candidates for the alias' being equal\n-                candidates.push(evaluate_normalizes_to(self, alias_lhs, goal.predicate.1));\n-                candidates.push(evaluate_normalizes_to(self, alias_rhs, goal.predicate.0));\n-                candidates.push(self.probe(|ecx| {\n-                    debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n-                    ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                }));\n+            // LHS is not a projection, only way this is true is if RHS normalizes-to LHS\n+            (None, Some(alias_rhs)) => {\n+                evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes)\n+            }\n \n+            (Some(alias_lhs), Some(alias_rhs)) => {\n+                debug!(\"compute_alias_relate_goal: both sides are aliases\");\n+\n+                let candidates = vec![\n+                    // LHS normalizes-to RHS\n+                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No),\n+                    // RHS normalizes-to RHS\n+                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes),\n+                    // Relate via substs\n+                    self.probe(|ecx| {\n+                        debug!(\n+                            \"compute_alias_relate_goal: alias defids are equal, equating substs\"\n+                        );\n+\n+                        match direction {\n+                            ty::AliasRelationDirection::Equate => {\n+                                ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                            }\n+                            ty::AliasRelationDirection::Subtype => {\n+                                ecx.sub(goal.param_env, alias_lhs, alias_rhs)?;\n+                            }\n+                        }\n+\n+                        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                    }),\n+                ];\n                 debug!(?candidates);\n \n                 self.try_merge_responses(candidates.into_iter())"}, {"sha": "6b3a59b1ed545f4e5926530c8cdd68387b0ae9f5", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -832,7 +832,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 // the `ParamEnv`.\n                 ty::PredicateKind::WellFormed(..)\n                 | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)"}, {"sha": "13607b9079a75d120a712ca7da44a1a40b5158d7", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/method_chain.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -92,6 +92,11 @@ impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n }\n \n impl<'tcx> ObligationEmittingRelation<'tcx> for CollectAllMismatches<'_, 'tcx> {\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        // FIXME(deferred_projection_equality): We really should get rid of this relation.\n+        ty::AliasRelationDirection::Equate\n+    }\n+\n     fn register_obligations(&mut self, _obligations: PredicateObligations<'tcx>) {\n         // FIXME(deferred_projection_equality)\n     }"}, {"sha": "296fd1ed5248f56a114db55a165d0b2a648d39d0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1276,16 +1276,26 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         \"TypeWellFormedFromEnv predicate should only exist in the environment\"\n                     ),\n \n-                    ty::PredicateKind::AliasEq(..) => span_bug!(\n+                    ty::PredicateKind::AliasRelate(..) => span_bug!(\n                         span,\n-                        \"AliasEq predicate should never be the predicate cause of a SelectionError\"\n+                        \"AliasRelate predicate should never be the predicate cause of a SelectionError\"\n                     ),\n \n                     ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n-                        self.tcx.sess.struct_span_err(\n+                        let mut diag = self.tcx.sess.struct_span_err(\n                             span,\n                             &format!(\"the constant `{}` is not of type `{}`\", ct, ty),\n-                        )\n+                        );\n+                        self.note_type_err(\n+                            &mut diag,\n+                            &obligation.cause,\n+                            None,\n+                            None,\n+                            TypeError::Sorts(ty::error::ExpectedFound::new(true, ty, ct.ty())),\n+                            false,\n+                            false,\n+                        );\n+                        diag\n                     }\n                 }\n             }"}, {"sha": "be0817472ea414499ad52455d2063779db20bfd5", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1356,6 +1356,31 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else {\n+                        let is_mut = mut_ref_self_ty_satisfies_pred || ref_inner_ty_mut;\n+                        let sugg_prefix = format!(\"&{}\", if is_mut { \"mut \" } else { \"\" });\n+                        let sugg_msg = &format!(\n+                            \"consider{} borrowing here\",\n+                            if is_mut { \" mutably\" } else { \"\" }\n+                        );\n+\n+                        // Issue #109436, we need to add parentheses properly for method calls\n+                        // for example, `foo.into()` should be `(&foo).into()`\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(\n+                            self.tcx.sess.source_map().span_look_ahead(span, Some(\".\"), Some(50)),\n+                        ) {\n+                            if snippet == \".\" {\n+                                err.multipart_suggestion_verbose(\n+                                    sugg_msg,\n+                                    vec![\n+                                        (span.shrink_to_lo(), format!(\"({}\", sugg_prefix)),\n+                                        (span.shrink_to_hi(), \")\".to_string()),\n+                                    ],\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                return true;\n+                            }\n+                        }\n+\n                         // Issue #104961, we need to add parentheses properly for compond expressions\n                         // for example, `x.starts_with(\"hi\".to_string() + \"you\")`\n                         // should be `x.starts_with(&(\"hi\".to_string() + \"you\"))`\n@@ -1372,14 +1397,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             _ => false,\n                         };\n \n-                        let is_mut = mut_ref_self_ty_satisfies_pred || ref_inner_ty_mut;\n                         let span = if needs_parens { span } else { span.shrink_to_lo() };\n-                        let sugg_prefix = format!(\"&{}\", if is_mut { \"mut \" } else { \"\" });\n-                        let sugg_msg = &format!(\n-                            \"consider{} borrowing here\",\n-                            if is_mut { \" mutably\" } else { \"\" }\n-                        );\n-\n                         let suggestions = if !needs_parens {\n                             vec![(span.shrink_to_lo(), format!(\"{}\", sugg_prefix))]\n                         } else {"}, {"sha": "07e31e87bfb4646bea05120ab4403b5603d67f27", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -361,8 +361,8 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n-                ty::PredicateKind::AliasEq(..) => {\n-                    bug!(\"AliasEq is only used for new solver\")\n+                ty::PredicateKind::AliasRelate(..) => {\n+                    bug!(\"AliasRelate is only used for new solver\")\n                 }\n             },\n             Some(pred) => match pred {\n@@ -630,8 +630,8 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n-                ty::PredicateKind::AliasEq(..) => {\n-                    bug!(\"AliasEq is only used for new solver\")\n+                ty::PredicateKind::AliasRelate(..) => {\n+                    bug!(\"AliasRelate is only used for new solver\")\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n                     match self.selcx.infcx.at(&obligation.cause, obligation.param_env).eq("}, {"sha": "5d2af5ff33c8fbf292f4d5897bbcd8b7cfa11e3d", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -335,7 +335,7 @@ fn predicate_references_self<'tcx>(\n             has_self_ty(&ty.into()).then_some(sp)\n         }\n \n-        ty::PredicateKind::AliasEq(..) => bug!(\"`AliasEq` not allowed as assumption\"),\n+        ty::PredicateKind::AliasRelate(..) => bug!(\"`AliasRelate` not allowed as assumption\"),\n \n         ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)\n@@ -395,7 +395,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::AliasEq(..)\n+            | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n         }"}, {"sha": "edbe2de8105e6a2378284dc31b1e71610ed0c85b", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,9 +1,8 @@\n-use rustc_middle::traits::solve::{Certainty, Goal, MaybeCause};\n+use rustc_infer::traits::{TraitEngine, TraitEngineExt};\n use rustc_middle::ty;\n \n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferCtxt;\n-use crate::solve::InferCtxtEvalExt;\n use crate::traits::{EvaluationResult, OverflowError, PredicateObligation, SelectionContext};\n \n pub trait InferCtxtExt<'tcx> {\n@@ -81,27 +80,20 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n \n         if self.tcx.trait_solver_next() {\n             self.probe(|snapshot| {\n-                if let Ok((_, certainty)) =\n-                    self.evaluate_root_goal(Goal::new(self.tcx, param_env, obligation.predicate))\n-                {\n-                    match certainty {\n-                        Certainty::Yes => {\n-                            if self.opaque_types_added_in_snapshot(snapshot) {\n-                                Ok(EvaluationResult::EvaluatedToOkModuloOpaqueTypes)\n-                            } else if self.region_constraints_added_in_snapshot(snapshot).is_some()\n-                            {\n-                                Ok(EvaluationResult::EvaluatedToOkModuloRegions)\n-                            } else {\n-                                Ok(EvaluationResult::EvaluatedToOk)\n-                            }\n-                        }\n-                        Certainty::Maybe(MaybeCause::Ambiguity) => {\n-                            Ok(EvaluationResult::EvaluatedToAmbig)\n-                        }\n-                        Certainty::Maybe(MaybeCause::Overflow) => Err(OverflowError::Canonical),\n-                    }\n-                } else {\n+                let mut fulfill_cx = crate::solve::FulfillmentCtxt::new();\n+                fulfill_cx.register_predicate_obligation(self, obligation.clone());\n+                // True errors\n+                // FIXME(-Ztrait-solver=next): Overflows are reported as ambig here, is that OK?\n+                if !fulfill_cx.select_where_possible(self).is_empty() {\n                     Ok(EvaluationResult::EvaluatedToErr)\n+                } else if !fulfill_cx.select_all_or_error(self).is_empty() {\n+                    Ok(EvaluationResult::EvaluatedToAmbig)\n+                } else if self.opaque_types_added_in_snapshot(snapshot) {\n+                    Ok(EvaluationResult::EvaluatedToOkModuloOpaqueTypes)\n+                } else if self.region_constraints_added_in_snapshot(snapshot).is_some() {\n+                    Ok(EvaluationResult::EvaluatedToOkModuloRegions)\n+                } else {\n+                    Ok(EvaluationResult::EvaluatedToOk)\n                 }\n             })\n         } else {"}, {"sha": "4f429f018edf74943edbdf1428bd88768a5eec9f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -618,6 +618,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let mut fulfill_cx = crate::solve::FulfillmentCtxt::new();\n         fulfill_cx.register_predicate_obligations(self.infcx, predicates);\n         // True errors\n+        // FIXME(-Ztrait-solver=next): Overflows are reported as ambig here, is that OK?\n         if !fulfill_cx.select_where_possible(self.infcx).is_empty() {\n             return Ok(EvaluatedToErr);\n         }\n@@ -977,8 +978,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n                 }\n-                ty::PredicateKind::AliasEq(..) => {\n-                    bug!(\"AliasEq is only used for new solver\")\n+                ty::PredicateKind::AliasRelate(..) => {\n+                    bug!(\"AliasRelate is only used for new solver\")\n                 }\n                 ty::PredicateKind::Ambiguous => Ok(EvaluatedToAmbig),\n                 ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {"}, {"sha": "11eb968a4152e695d8e6013c18b286ff3b0d87a9", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -3,7 +3,7 @@ use super::OverlapError;\n use crate::traits;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, TyCtxt, TypeVisitableExt};\n \n pub use rustc_middle::traits::specialization_graph::*;\n@@ -49,12 +49,9 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n-        if let Some(st) = fast_reject::simplify_type(\n-            tcx,\n-            trait_ref.self_ty(),\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        ) {\n+        if let Some(st) =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsCandidateKey)\n+        {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             self.non_blanket_impls.entry(st).or_default().push(impl_def_id)\n         } else {\n@@ -69,12 +66,9 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n         let vec: &mut Vec<DefId>;\n-        if let Some(st) = fast_reject::simplify_type(\n-            tcx,\n-            trait_ref.self_ty(),\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        ) {\n+        if let Some(st) =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsCandidateKey)\n+        {\n             debug!(\"remove_existing: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             vec = self.non_blanket_impls.get_mut(&st).unwrap();\n         } else {\n@@ -310,12 +304,8 @@ impl<'tcx> GraphExt<'tcx> for Graph {\n \n         let mut parent = trait_def_id;\n         let mut last_lint = None;\n-        let simplified = fast_reject::simplify_type(\n-            tcx,\n-            trait_ref.self_ty(),\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        );\n+        let simplified =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsCandidateKey);\n \n         // Descend the specialization tree, where `parent` is the current parent node.\n         loop {"}, {"sha": "ec5bd982a3c987c2df50fa916cbb62bd98955f6c", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -191,8 +191,8 @@ pub fn predicate_obligations<'tcx>(\n         ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n             bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n         }\n-        ty::PredicateKind::AliasEq(..) => {\n-            bug!(\"We should only wf check where clauses and `AliasEq` is not a `Clause`\")\n+        ty::PredicateKind::AliasRelate(..) => {\n+            bug!(\"We should only wf check where clauses and `AliasRelate` is not a `Clause`\")\n         }\n     }\n \n@@ -936,7 +936,7 @@ pub(crate) fn required_region_bounds<'tcx>(\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                 ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n                     ref t,"}, {"sha": "0e9bccba8d4c56b727dad49edcce15fbb08e87f9", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -119,7 +119,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 },\n                 ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n@@ -215,7 +215,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             // some of these in terms of chalk operations.\n             ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-            | ty::PredicateKind::AliasEq(..)\n+            | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::Ambiguous\n@@ -652,7 +652,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n             ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::AliasEq(..)\n+            | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n@@ -787,7 +787,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n             ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n             ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n-            | ty::PredicateKind::AliasEq(..)\n+            | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)"}, {"sha": "f5bba14d2fb9cb6b1f866ec87e8722be3680f61e", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -86,7 +86,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n             if obligation.predicate.has_non_region_infer() {\n                 match obligation.predicate.kind().skip_binder() {\n                     ty::PredicateKind::Clause(ty::Clause::Projection(..))\n-                    | ty::PredicateKind::AliasEq(..) => {\n+                    | ty::PredicateKind::AliasRelate(..) => {\n                         ocx.register_obligation(obligation.clone());\n                     }\n                     _ => {}\n@@ -110,7 +110,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n \n                 // We need to search through *all* WellFormed predicates"}, {"sha": "126a494f34fd6870773e704e97a5e357ecdcd91f", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -61,7 +61,7 @@ fn not_outlives_predicate(p: ty::Predicate<'_>) -> bool {\n         ty::PredicateKind::Clause(ty::Clause::Trait(..))\n         | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n         | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-        | ty::PredicateKind::AliasEq(..)\n+        | ty::PredicateKind::AliasRelate(..)\n         | ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)"}, {"sha": "8b23fbc75833cf357a86786d8a29b88bc53759e3", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -432,6 +432,17 @@ impl IntTy {\n             _ => *self,\n         }\n     }\n+\n+    pub fn to_unsigned(self) -> UintTy {\n+        match self {\n+            IntTy::Isize => UintTy::Usize,\n+            IntTy::I8 => UintTy::U8,\n+            IntTy::I16 => UintTy::U16,\n+            IntTy::I32 => UintTy::U32,\n+            IntTy::I64 => UintTy::U64,\n+            IntTy::I128 => UintTy::U128,\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n@@ -479,6 +490,17 @@ impl UintTy {\n             _ => *self,\n         }\n     }\n+\n+    pub fn to_signed(self) -> IntTy {\n+        match self {\n+            UintTy::Usize => IntTy::Isize,\n+            UintTy::U8 => IntTy::I8,\n+            UintTy::U16 => IntTy::I16,\n+            UintTy::U32 => IntTy::I32,\n+            UintTy::U64 => IntTy::I64,\n+            UintTy::U128 => IntTy::I128,\n+        }\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]"}, {"sha": "1e9cf404f77ea10af86cfaeaff32fb2db1417d2f", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -692,10 +692,10 @@ impl<T> Rc<T> {\n     /// it is guaranteed that exactly one of the calls returns the inner value.\n     /// This means in particular that the inner value is not dropped.\n     ///\n-    /// This is equivalent to `Rc::try_unwrap(...).ok()`. (Note that these are not equivalent for\n-    /// `Arc`, due to race conditions that do not apply to `Rc`.)\n+    /// This is equivalent to `Rc::try_unwrap(this).ok()`. (Note that these are not equivalent for\n+    /// [`Arc`](crate::sync::Arc), due to race conditions that do not apply to `Rc`.)\n     #[inline]\n-    #[unstable(feature = \"rc_into_inner\", issue = \"106894\")]\n+    #[stable(feature = \"rc_into_inner\", since = \"CURRENT_RUSTC_VERSION\")]\n     pub fn into_inner(this: Self) -> Option<T> {\n         Rc::try_unwrap(this).ok()\n     }"}, {"sha": "150924851d21d9cbf63f670ef3d543bf0ca70fea", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -662,20 +662,17 @@ impl<T> Arc<T> {\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n-    // FIXME: when `Arc::into_inner` is stabilized, add this paragraph:\n-    /*\n     /// It is strongly recommended to use [`Arc::into_inner`] instead if you don't\n     /// want to keep the `Arc` in the [`Err`] case.\n     /// Immediately dropping the [`Err`] payload, like in the expression\n     /// `Arc::try_unwrap(this).ok()`, can still cause the strong count to\n     /// drop to zero and the inner value of the `Arc` to be dropped:\n-    /// For instance if two threads execute this expression in parallel, then\n+    /// For instance if two threads each execute this expression in parallel, then\n     /// there is a race condition. The threads could first both check whether they\n     /// have the last clone of their `Arc` via `Arc::try_unwrap`, and then\n     /// both drop their `Arc` in the call to [`ok`][`Result::ok`],\n     /// taking the strong count from two down to zero.\n     ///\n-     */\n     /// # Examples\n     ///\n     /// ```\n@@ -719,20 +716,13 @@ impl<T> Arc<T> {\n     /// This means in particular that the inner value is not dropped.\n     ///\n     /// The similar expression `Arc::try_unwrap(this).ok()` does not\n-    /// offer such a guarantee. See the last example below.\n-    //\n-    // FIXME: when `Arc::into_inner` is stabilized, add this to end\n-    // of the previous sentence:\n-    /*\n+    /// offer such a guarantee. See the last example below\n     /// and the documentation of [`Arc::try_unwrap`].\n-     */\n     ///\n     /// # Examples\n     ///\n     /// Minimal example demonstrating the guarantee that `Arc::into_inner` gives.\n     /// ```\n-    /// #![feature(arc_into_inner)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// let x = Arc::new(3);\n@@ -756,8 +746,6 @@ impl<T> Arc<T> {\n     ///\n     /// A more practical example demonstrating the need for `Arc::into_inner`:\n     /// ```\n-    /// #![feature(arc_into_inner)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// // Definition of a simple singly linked list using `Arc`:\n@@ -807,13 +795,8 @@ impl<T> Arc<T> {\n     /// x_thread.join().unwrap();\n     /// y_thread.join().unwrap();\n     /// ```\n-\n-    // FIXME: when `Arc::into_inner` is stabilized, adjust above documentation\n-    // and the documentation of `Arc::try_unwrap` according to the `FIXME`s. Also\n-    // open an issue on rust-lang/rust-clippy, asking for a lint against\n-    // `Arc::try_unwrap(...).ok()`.\n     #[inline]\n-    #[unstable(feature = \"arc_into_inner\", issue = \"106894\")]\n+    #[stable(feature = \"arc_into_inner\", since = \"CURRENT_RUSTC_VERSION\")]\n     pub fn into_inner(this: Self) -> Option<T> {\n         // Make sure that the ordinary `Drop` implementation isn\u2019t called as well\n         let mut this = mem::ManuallyDrop::new(this);"}, {"sha": "6690c1a76d5f03ba084de29667091ce9bf0c845f", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -343,6 +343,14 @@ define!(\n     /// See [`Field`] for documentation.\n     fn Variant<T>(place: T, index: u32) -> ()\n );\n+define!(\n+    \"mir_cast_transmute\",\n+    /// Emits a `CastKind::Transmute` cast.\n+    ///\n+    /// Needed to test the UB when `sizeof(T) != sizeof(U)`, which can't be\n+    /// generated via the normal `mem::transmute`.\n+    fn CastTransmute<T, U>(operand: T) -> U\n+);\n define!(\n     \"mir_make_place\",\n     #[doc(hidden)]"}, {"sha": "35da9151b6f72c5d197615ab0d087e96e028be7b", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -29,6 +29,9 @@\n use crate::fmt;\n use crate::panic::{Location, PanicInfo};\n \n+#[cfg(feature = \"panic_immediate_abort\")]\n+const _: () = assert!(cfg!(panic = \"abort\"), \"panic_immediate_abort requires -C panic=abort\");\n+\n // First we define the two main entry points that all panics go through.\n // In the end both are just convenience wrappers around `panic_impl`.\n "}, {"sha": "1cedd6eedfaf90397a0d8476dd60cdac036dfedf", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -370,7 +370,7 @@ pub enum ErrorKind {\n \n     // \"Unusual\" error kinds which do not correspond simply to (sets\n     // of) OS error codes, should be added just above this comment.\n-    // `Other` and `Uncategorised` should remain at the end:\n+    // `Other` and `Uncategorized` should remain at the end:\n     //\n     /// A custom error that does not fall under any other I/O error kind.\n     ///\n@@ -882,6 +882,13 @@ impl Error {\n \n     /// Returns the corresponding [`ErrorKind`] for this error.\n     ///\n+    /// This may be a value set by Rust code constructing custom `io::Error`s,\n+    /// or if this `io::Error` was sourced from the operating system,\n+    /// it will be a value inferred from the system's error encoding.\n+    /// See [`last_os_error`] for more details.\n+    ///\n+    /// [`last_os_error`]: Error::last_os_error\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -892,7 +899,8 @@ impl Error {\n     /// }\n     ///\n     /// fn main() {\n-    ///     // Will print \"Uncategorized\".\n+    ///     // As no error has (visibly) occurred, this may print anything!\n+    ///     // It likely prints a placeholder for unidentified (non-)errors.\n     ///     print_error(Error::last_os_error());\n     ///     // Will print \"AddrInUse\".\n     ///     print_error(Error::new(ErrorKind::AddrInUse, \"oh no!\"));"}, {"sha": "b8fec6902a08c2cda716ee04d3c273ecb8f23ece", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -107,8 +107,8 @@ use crate::sys::locks as sys;\n /// *guard += 1;\n /// ```\n ///\n-/// It is sometimes necessary to manually drop the mutex guard to unlock it\n-/// sooner than the end of the enclosing scope.\n+/// To unlock a mutex guard sooner than the end of the enclosing scope,\n+/// either create an inner scope or drop the guard manually.\n ///\n /// ```\n /// use std::sync::{Arc, Mutex};\n@@ -125,11 +125,18 @@ use crate::sys::locks as sys;\n ///     let res_mutex_clone = Arc::clone(&res_mutex);\n ///\n ///     threads.push(thread::spawn(move || {\n-///         let mut data = data_mutex_clone.lock().unwrap();\n-///         // This is the result of some important and long-ish work.\n-///         let result = data.iter().fold(0, |acc, x| acc + x * 2);\n-///         data.push(result);\n-///         drop(data);\n+///         // Here we use a block to limit the lifetime of the lock guard.\n+///         let result = {\n+///             let mut data = data_mutex_clone.lock().unwrap();\n+///             // This is the result of some important and long-ish work.\n+///             let result = data.iter().fold(0, |acc, x| acc + x * 2);\n+///             data.push(result);\n+///             result\n+///             // The mutex guard gets dropped here, together with any other values\n+///             // created in the critical section.\n+///         };\n+///         // The guard created here is a temporary dropped at the end of the statement, i.e.\n+///         // the lock would not remain being held even if the thread did some additional work.\n ///         *res_mutex_clone.lock().unwrap() += result;\n ///     }));\n /// });\n@@ -146,6 +153,8 @@ use crate::sys::locks as sys;\n /// // It's even more important here than in the threads because we `.join` the\n /// // threads after that. If we had not dropped the mutex guard, a thread could\n /// // be waiting forever for it, causing a deadlock.\n+/// // As in the threads, a block could have been used instead of calling the\n+/// // `drop` function.\n /// drop(data);\n /// // Here the mutex guard is not assigned to a variable and so, even if the\n /// // scope does not end after this line, the mutex is still released: there is\n@@ -160,6 +169,7 @@ use crate::sys::locks as sys;\n ///\n /// assert_eq!(*res_mutex.lock().unwrap(), 800);\n /// ```\n+///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Mutex\")]\n pub struct Mutex<T: ?Sized> {"}, {"sha": "cf0b271761febf0cc139099d7742f86c30f810ca", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -202,7 +202,7 @@ impl OpenOptions {\n             create: false,\n             create_new: false,\n             // system-specific\n-            mode: 0x777,\n+            mode: 0o777,\n         }\n     }\n "}, {"sha": "b5abf6564a6334a51938fc083b8fc1c5574cf01e", "filename": "src/ci/docker/host-x86_64/i686-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -16,6 +16,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   zlib1g-dev \\\n   lib32z1-dev \\\n   xz-utils \\\n+  mingw-w64 \\\n   && rm -rf /var/lib/apt/lists/*\n \n "}, {"sha": "21dcf29b4a9f9e9a039a127b3540e8c517340dfd", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-14-stage1/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14-stage1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14-stage1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14-stage1%2FDockerfile?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -22,6 +22,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   zlib1g-dev \\\n   xz-utils \\\n   nodejs \\\n+  mingw-w64 \\\n   && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/sccache.sh /scripts/"}, {"sha": "cfb638e8b07aa5b5d8b21166c9232626fb97eb50", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-14/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -23,6 +23,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   zlib1g-dev \\\n   xz-utils \\\n   nodejs \\\n+  mingw-w64 \\\n   && rm -rf /var/lib/apt/lists/*\n \n # Install powershell (universal package) so we can test x.ps1 on Linux"}, {"sha": "fb5037e3b973d95521a66c775c024fbf72e94e02", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-15/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-15%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-15%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-15%2FDockerfile?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -25,6 +25,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   zlib1g-dev \\\n   xz-utils \\\n   nodejs \\\n+  mingw-w64 \\\n   && rm -rf /var/lib/apt/lists/*\n \n # Install powershell (universal package) so we can test x.ps1 on Linux"}, {"sha": "fbec368c9ee55ec7fad9387577f610f7898cba57", "filename": "src/ci/docker/host-x86_64/x86_64-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -16,6 +16,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   pkg-config \\\n   xz-utils \\\n+  mingw-w64 \\\n   && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/sccache.sh /scripts/"}, {"sha": "2957916d56ccb1c5cd00d5e5ad86fb103807f48d", "filename": "src/doc/rustdoc/src/how-to-read-rustdoc.md", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-read-rustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-read-rustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-read-rustdoc.md?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -80,13 +80,20 @@ functions, and \"In Return Types\" shows matches in the return types of functions.\n Both are very useful when looking for a function whose name you can't quite\n bring to mind when you know the type you have or want.\n \n-When typing in the search bar, you can prefix your search term with a type\n-followed by a colon (such as `mod:`) to restrict the results to just that\n-kind of item. (The available items are listed in the help popup.)\n-\n-Searching for `println!` will search for a macro named `println`, just like\n+Names in the search interface can be prefixed with an item type followed by a\n+colon (such as `mod:`) to restrict the results to just that kind of item. Also,\n+searching for `println!` will search for a macro named `println`, just like\n searching for `macro:println` does.\n \n+Function signature searches can query generics, wrapped in angle brackets, and\n+traits are normalized like types in the search engine. For example, a function\n+with the signature `fn my_function<I: Iterator<Item=u32>>(input: I) -> usize`\n+can be matched with the following queries:\n+\n+* `Iterator<u32> -> usize`\n+* `trait:Iterator<primitive:u32> -> primitive:usize`\n+* `Iterator -> usize`\n+\n ### Changing displayed theme\n \n You can change the displayed theme by opening the settings menu (the gear"}, {"sha": "c00fa5994bfce661a6ee669100206f745fb206b1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -324,7 +324,7 @@ pub(crate) fn clean_predicate<'tcx>(\n         ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n         ty::PredicateKind::Subtype(..)\n-        | ty::PredicateKind::AliasEq(..)\n+        | ty::PredicateKind::AliasRelate(..)\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)"}, {"sha": "a21a91a0ce85a3a208c0c8e075c62edf18d40e17", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -482,10 +482,12 @@ impl Item {\n     pub(crate) fn links(&self, cx: &Context<'_>) -> Vec<RenderedLink> {\n         use crate::html::format::{href, link_tooltip};\n \n-        cx.cache()\n+        let Some(links) = cx.cache()\n             .intra_doc_links\n-            .get(&self.item_id)\n-            .map_or(&[][..], |v| v.as_slice())\n+            .get(&self.item_id) else {\n+                return vec![]\n+            };\n+        links\n             .iter()\n             .filter_map(|ItemLink { link: s, link_text, page_id: id, ref fragment }| {\n                 debug!(?id);\n@@ -513,10 +515,12 @@ impl Item {\n     /// the link text, but does need to know which `[]`-bracketed names\n     /// are actually links.\n     pub(crate) fn link_names(&self, cache: &Cache) -> Vec<RenderedLink> {\n-        cache\n+        let Some(links) = cache\n             .intra_doc_links\n-            .get(&self.item_id)\n-            .map_or(&[][..], |v| v.as_slice())\n+            .get(&self.item_id) else {\n+                return vec![];\n+            };\n+        links\n             .iter()\n             .map(|ItemLink { link: s, link_text, .. }| RenderedLink {\n                 original_text: s.clone(),\n@@ -1014,7 +1018,7 @@ pub(crate) fn collapse_doc_fragments(doc_strings: &[DocFragment]) -> String {\n /// A link that has not yet been rendered.\n ///\n /// This link will be turned into a rendered link by [`Item::links`].\n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub(crate) struct ItemLink {\n     /// The original link written in the markdown\n     pub(crate) link: Box<str>,"}, {"sha": "c0329182032acb2e73275c48b0feeb4d97ab58c5", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Symbol;\n@@ -118,7 +118,7 @@ pub(crate) struct Cache {\n     /// All intra-doc links resolved so far.\n     ///\n     /// Links are indexed by the DefId of the item they document.\n-    pub(crate) intra_doc_links: FxHashMap<ItemId, Vec<clean::ItemLink>>,\n+    pub(crate) intra_doc_links: FxHashMap<ItemId, FxIndexSet<clean::ItemLink>>,\n     /// Cfg that have been hidden via #![doc(cfg_hide(...))]\n     pub(crate) hidden_cfg: FxHashSet<clean::cfg::Cfg>,\n }"}, {"sha": "840ed8e1080b7a37ba0522ad9f33a85436008d17", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 111, "deletions": 53, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -354,12 +354,15 @@ function initSearch(rawSearchIndex) {\n         if (isInGenerics) {\n             parserState.genericsElems += 1;\n         }\n+        const typeFilter = parserState.typeFilter;\n+        parserState.typeFilter = null;\n         return {\n             name: name,\n             fullPath: pathSegments,\n             pathWithoutLast: pathSegments.slice(0, pathSegments.length - 1),\n             pathLast: pathSegments[pathSegments.length - 1],\n             generics: generics,\n+            typeFilter,\n         };\n     }\n \n@@ -495,6 +498,11 @@ function initSearch(rawSearchIndex) {\n      */\n     function getItemsBefore(query, parserState, elems, endChar) {\n         let foundStopChar = true;\n+        let start = parserState.pos;\n+\n+        // If this is a generic, keep the outer item's type filter around.\n+        const oldTypeFilter = parserState.typeFilter;\n+        parserState.typeFilter = null;\n \n         while (parserState.pos < parserState.length) {\n             const c = parserState.userQuery[parserState.pos];\n@@ -506,7 +514,25 @@ function initSearch(rawSearchIndex) {\n                 continue;\n             } else if (c === \":\" && isPathStart(parserState)) {\n                 throw [\"Unexpected \", \"::\", \": paths cannot start with \", \"::\"];\n-            } else if (c === \":\" || isEndCharacter(c)) {\n+            }  else if (c === \":\") {\n+                if (parserState.typeFilter !== null) {\n+                    throw [\"Unexpected \", \":\"];\n+                }\n+                if (elems.length === 0) {\n+                    throw [\"Expected type filter before \", \":\"];\n+                } else if (query.literalSearch) {\n+                    throw [\"You cannot use quotes on type filter\"];\n+                }\n+                // The type filter doesn't count as an element since it's a modifier.\n+                const typeFilterElem = elems.pop();\n+                checkExtraTypeFilterCharacters(start, parserState);\n+                parserState.typeFilter = typeFilterElem.name;\n+                parserState.pos += 1;\n+                parserState.totalElems -= 1;\n+                query.literalSearch = false;\n+                foundStopChar = true;\n+                continue;\n+            } else if (isEndCharacter(c)) {\n                 let extra = \"\";\n                 if (endChar === \">\") {\n                     extra = \"<\";\n@@ -540,15 +566,10 @@ function initSearch(rawSearchIndex) {\n                 ];\n             }\n             const posBefore = parserState.pos;\n+            start = parserState.pos;\n             getNextElem(query, parserState, elems, endChar === \">\");\n-            if (endChar !== \"\") {\n-                if (parserState.pos >= parserState.length) {\n-                    throw [\"Unclosed \", \"<\"];\n-                }\n-                const c2 = parserState.userQuery[parserState.pos];\n-                if (!isSeparatorCharacter(c2) && c2 !== endChar) {\n-                    throw [\"Expected \", endChar, \", found \", c2];\n-                }\n+            if (endChar !== \"\" && parserState.pos >= parserState.length) {\n+                throw [\"Unclosed \", \"<\"];\n             }\n             // This case can be encountered if `getNextElem` encountered a \"stop character\" right\n             // from the start. For example if you have `,,` or `<>`. In this case, we simply move up\n@@ -564,6 +585,8 @@ function initSearch(rawSearchIndex) {\n         // We are either at the end of the string or on the `endChar` character, let's move forward\n         // in any case.\n         parserState.pos += 1;\n+\n+        parserState.typeFilter = oldTypeFilter;\n     }\n \n     /**\n@@ -572,10 +595,10 @@ function initSearch(rawSearchIndex) {\n      *\n      * @param {ParserState} parserState\n      */\n-    function checkExtraTypeFilterCharacters(parserState) {\n+    function checkExtraTypeFilterCharacters(start, parserState) {\n         const query = parserState.userQuery;\n \n-        for (let pos = 0; pos < parserState.pos; ++pos) {\n+        for (let pos = start; pos < parserState.pos; ++pos) {\n             if (!isIdentCharacter(query[pos]) && !isWhitespaceCharacter(query[pos])) {\n                 throw [\"Unexpected \", query[pos], \" in type filter\"];\n             }\n@@ -591,6 +614,7 @@ function initSearch(rawSearchIndex) {\n      */\n     function parseInput(query, parserState) {\n         let foundStopChar = true;\n+        let start = parserState.pos;\n \n         while (parserState.pos < parserState.length) {\n             const c = parserState.userQuery[parserState.pos];\n@@ -612,16 +636,15 @@ function initSearch(rawSearchIndex) {\n                 }\n                 if (query.elems.length === 0) {\n                     throw [\"Expected type filter before \", \":\"];\n-                } else if (query.elems.length !== 1 || parserState.totalElems !== 1) {\n-                    throw [\"Unexpected \", \":\"];\n                 } else if (query.literalSearch) {\n                     throw [\"You cannot use quotes on type filter\"];\n                 }\n-                checkExtraTypeFilterCharacters(parserState);\n                 // The type filter doesn't count as an element since it's a modifier.\n-                parserState.typeFilter = query.elems.pop().name;\n+                const typeFilterElem = query.elems.pop();\n+                checkExtraTypeFilterCharacters(start, parserState);\n+                parserState.typeFilter = typeFilterElem.name;\n                 parserState.pos += 1;\n-                parserState.totalElems = 0;\n+                parserState.totalElems -= 1;\n                 query.literalSearch = false;\n                 foundStopChar = true;\n                 continue;\n@@ -653,13 +676,17 @@ function initSearch(rawSearchIndex) {\n                 ];\n             }\n             const before = query.elems.length;\n+            start = parserState.pos;\n             getNextElem(query, parserState, query.elems, false);\n             if (query.elems.length === before) {\n                 // Nothing was added, weird... Let's increase the position to not remain stuck.\n                 parserState.pos += 1;\n             }\n             foundStopChar = false;\n         }\n+        if (parserState.typeFilter !== null) {\n+            throw [\"Unexpected \", \":\", \" (expected path after type filter)\"];\n+        }\n         while (parserState.pos < parserState.length) {\n             if (isReturnArrow(parserState)) {\n                 parserState.pos += 2;\n@@ -687,7 +714,6 @@ function initSearch(rawSearchIndex) {\n         return {\n             original: userQuery,\n             userQuery: userQuery.toLowerCase(),\n-            typeFilter: NO_TYPE_FILTER,\n             elems: [],\n             returned: [],\n             // Total number of \"top\" elements (does not include generics).\n@@ -738,8 +764,8 @@ function initSearch(rawSearchIndex) {\n      *\n      * ident = *(ALPHA / DIGIT / \"_\")\n      * path = ident *(DOUBLE-COLON ident) [!]\n-     * arg = path [generics]\n-     * arg-without-generic = path\n+     * arg = [type-filter *WS COLON *WS] path [generics]\n+     * arg-without-generic = [type-filter *WS COLON *WS] path\n      * type-sep = COMMA/WS *(COMMA/WS)\n      * nonempty-arg-list = *(type-sep) arg *(type-sep arg) *(type-sep)\n      * nonempty-arg-list-without-generics = *(type-sep) arg-without-generic\n@@ -749,7 +775,7 @@ function initSearch(rawSearchIndex) {\n      * return-args = RETURN-ARROW *(type-sep) nonempty-arg-list\n      *\n      * exact-search = [type-filter *WS COLON] [ RETURN-ARROW ] *WS QUOTE ident QUOTE [ generics ]\n-     * type-search = [type-filter *WS COLON] [ nonempty-arg-list ] [ return-args ]\n+     * type-search = [ nonempty-arg-list ] [ return-args ]\n      *\n      * query = *WS (exact-search / type-search) *WS\n      *\n@@ -798,6 +824,20 @@ function initSearch(rawSearchIndex) {\n      * @return {ParsedQuery}    - The parsed query\n      */\n     function parseQuery(userQuery) {\n+        function convertTypeFilterOnElem(elem) {\n+            if (elem.typeFilter !== null) {\n+                let typeFilter = elem.typeFilter;\n+                if (typeFilter === \"const\") {\n+                    typeFilter = \"constant\";\n+                }\n+                elem.typeFilter = itemTypeFromName(typeFilter);\n+            } else {\n+                elem.typeFilter = NO_TYPE_FILTER;\n+            }\n+            for (const elem2 of elem.generics) {\n+                convertTypeFilterOnElem(elem2);\n+            }\n+        }\n         userQuery = userQuery.trim();\n         const parserState = {\n             length: userQuery.length,\n@@ -812,17 +852,15 @@ function initSearch(rawSearchIndex) {\n \n         try {\n             parseInput(query, parserState);\n-            if (parserState.typeFilter !== null) {\n-                let typeFilter = parserState.typeFilter;\n-                if (typeFilter === \"const\") {\n-                    typeFilter = \"constant\";\n-                }\n-                query.typeFilter = itemTypeFromName(typeFilter);\n+            for (const elem of query.elems) {\n+                convertTypeFilterOnElem(elem);\n+            }\n+            for (const elem of query.returned) {\n+                convertTypeFilterOnElem(elem);\n             }\n         } catch (err) {\n             query = newParsedQuery(userQuery);\n             query.error = err;\n-            query.typeFilter = -1;\n             return query;\n         }\n \n@@ -1057,32 +1095,30 @@ function initSearch(rawSearchIndex) {\n             }\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n-            let elem_name;\n             if (elem.generics.length > 0 && row.generics.length >= elem.generics.length) {\n                 const elems = Object.create(null);\n                 for (const entry of row.generics) {\n-                    elem_name = entry.name;\n-                    if (elem_name === \"\") {\n+                    if (entry.name === \"\") {\n                         // Pure generic, needs to check into it.\n                         if (checkGenerics(entry, elem, maxEditDistance + 1, maxEditDistance)\n                             !== 0) {\n                             return maxEditDistance + 1;\n                         }\n                         continue;\n                     }\n-                    if (elems[elem_name] === undefined) {\n-                        elems[elem_name] = 0;\n+                    if (elems[entry.name] === undefined) {\n+                        elems[entry.name] = [];\n                     }\n-                    elems[elem_name] += 1;\n+                    elems[entry.name].push(entry.ty);\n                 }\n                 // We need to find the type that matches the most to remove it in order\n                 // to move forward.\n-                for (const generic of elem.generics) {\n+                const handleGeneric = generic => {\n                     let match = null;\n                     if (elems[generic.name]) {\n                         match = generic.name;\n                     } else {\n-                        for (elem_name in elems) {\n+                        for (const elem_name in elems) {\n                             if (!hasOwnPropertyRustdoc(elems, elem_name)) {\n                                 continue;\n                             }\n@@ -1093,12 +1129,32 @@ function initSearch(rawSearchIndex) {\n                         }\n                     }\n                     if (match === null) {\n-                        return maxEditDistance + 1;\n+                        return false;\n                     }\n-                    elems[match] -= 1;\n-                    if (elems[match] === 0) {\n+                    const matchIdx = elems[match].findIndex(tmp_elem =>\n+                        typePassesFilter(generic.typeFilter, tmp_elem));\n+                    if (matchIdx === -1) {\n+                        return false;\n+                    }\n+                    elems[match].splice(matchIdx, 1);\n+                    if (elems[match].length === 0) {\n                         delete elems[match];\n                     }\n+                    return true;\n+                };\n+                // To do the right thing with type filters, we first process generics\n+                // that have them, removing matching ones from the \"bag,\" then do the\n+                // ones with no type filter, which can match any entry regardless of its\n+                // own type.\n+                for (const generic of elem.generics) {\n+                    if (generic.typeFilter !== -1 && !handleGeneric(generic)) {\n+                        return maxEditDistance + 1;\n+                    }\n+                }\n+                for (const generic of elem.generics) {\n+                    if (generic.typeFilter === -1 && !handleGeneric(generic)) {\n+                        return maxEditDistance + 1;\n+                    }\n                 }\n                 return 0;\n             }\n@@ -1145,14 +1201,20 @@ function initSearch(rawSearchIndex) {\n                 return maxEditDistance + 1;\n             }\n \n-            let dist = editDistance(row.name, elem.name, maxEditDistance);\n+            let dist;\n+            if (typePassesFilter(elem.typeFilter, row.ty)) {\n+                dist = editDistance(row.name, elem.name, maxEditDistance);\n+            } else {\n+                dist = maxEditDistance + 1;\n+            }\n             if (literalSearch) {\n                 if (dist !== 0) {\n                     // The name didn't match, let's try to check if the generics do.\n                     if (elem.generics.length === 0) {\n                         const checkGeneric = row.generics.length > 0;\n                         if (checkGeneric && row.generics\n-                            .findIndex(tmp_elem => tmp_elem.name === elem.name) !== -1) {\n+                            .findIndex(tmp_elem => tmp_elem.name === elem.name &&\n+                                typePassesFilter(elem.typeFilter, tmp_elem.ty)) !== -1) {\n                             return 0;\n                         }\n                     }\n@@ -1201,22 +1263,21 @@ function initSearch(rawSearchIndex) {\n          *\n          * @param {Row} row\n          * @param {QueryElement} elem    - The element from the parsed query.\n-         * @param {integer} typeFilter\n+         * @param {integer} maxEditDistance\n          * @param {Array<integer>} skipPositions - Do not return one of these positions.\n          *\n          * @return {dist: integer, position: integer} - Returns an edit distance to the best match.\n          *                                              If there is no match, returns\n          *                                              `maxEditDistance + 1` and position: -1.\n          */\n-        function findArg(row, elem, typeFilter, maxEditDistance, skipPositions) {\n+        function findArg(row, elem, maxEditDistance, skipPositions) {\n             let dist = maxEditDistance + 1;\n             let position = -1;\n \n             if (row && row.type && row.type.inputs && row.type.inputs.length > 0) {\n                 let i = 0;\n                 for (const input of row.type.inputs) {\n-                    if (!typePassesFilter(typeFilter, input.ty) ||\n-                        skipPositions.indexOf(i) !== -1) {\n+                    if (skipPositions.indexOf(i) !== -1) {\n                         i += 1;\n                         continue;\n                     }\n@@ -1245,23 +1306,22 @@ function initSearch(rawSearchIndex) {\n          *\n          * @param {Row} row\n          * @param {QueryElement} elem   - The element from the parsed query.\n-         * @param {integer} typeFilter\n+         * @param {integer} maxEditDistance\n          * @param {Array<integer>} skipPositions - Do not return one of these positions.\n          *\n          * @return {dist: integer, position: integer} - Returns an edit distance to the best match.\n          *                                              If there is no match, returns\n          *                                              `maxEditDistance + 1` and position: -1.\n          */\n-        function checkReturned(row, elem, typeFilter, maxEditDistance, skipPositions) {\n+        function checkReturned(row, elem, maxEditDistance, skipPositions) {\n             let dist = maxEditDistance + 1;\n             let position = -1;\n \n             if (row && row.type && row.type.output.length > 0) {\n                 const ret = row.type.output;\n                 let i = 0;\n                 for (const ret_ty of ret) {\n-                    if (!typePassesFilter(typeFilter, ret_ty.ty) ||\n-                        skipPositions.indexOf(i) !== -1) {\n+                    if (skipPositions.indexOf(i) !== -1) {\n                         i += 1;\n                         continue;\n                     }\n@@ -1483,15 +1543,15 @@ function initSearch(rawSearchIndex) {\n             const fullId = row.id;\n             const searchWord = searchWords[pos];\n \n-            const in_args = findArg(row, elem, parsedQuery.typeFilter, maxEditDistance, []);\n-            const returned = checkReturned(row, elem, parsedQuery.typeFilter, maxEditDistance, []);\n+            const in_args = findArg(row, elem, maxEditDistance, []);\n+            const returned = checkReturned(row, elem, maxEditDistance, []);\n \n             // path_dist is 0 because no parent path information is currently stored\n             // in the search index\n             addIntoResults(results_in_args, fullId, pos, -1, in_args.dist, 0, maxEditDistance);\n             addIntoResults(results_returned, fullId, pos, -1, returned.dist, 0, maxEditDistance);\n \n-            if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n+            if (!typePassesFilter(elem.typeFilter, row.ty)) {\n                 return;\n             }\n \n@@ -1568,7 +1628,6 @@ function initSearch(rawSearchIndex) {\n                     const { dist, position } = callback(\n                         row,\n                         elem,\n-                        NO_TYPE_FILTER,\n                         maxEditDistance,\n                         skipPositions\n                     );\n@@ -1632,7 +1691,6 @@ function initSearch(rawSearchIndex) {\n                         in_returned = checkReturned(\n                             row,\n                             elem,\n-                            parsedQuery.typeFilter,\n                             maxEditDistance,\n                             []\n                         );"}, {"sha": "32a523f312378c1149b109fb6756b326e29dbae9", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -969,7 +969,7 @@ impl LinkCollector<'_, '_> {\n             for md_link in preprocessed_markdown_links(&doc) {\n                 let link = self.resolve_link(item, item_id, module_id, &doc, &md_link);\n                 if let Some(link) = link {\n-                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n+                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().insert(link);\n                 }\n             }\n         }"}, {"sha": "9f6adf3e3fab77338531845a9c02a083ce8f196e", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -37,7 +37,7 @@ pub fn is_min_const_fn<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, msrv: &Msrv)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n-                ty::PredicateKind::AliasEq(..) => panic!(\"alias eq predicate on function: {predicate:#?}\"),\n+                ty::PredicateKind::AliasRelate(..) => panic!(\"alias relate predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {predicate:#?}\"),\n@@ -176,6 +176,9 @@ fn check_rvalue<'tcx>(\n             // FIXME(dyn-star)\n             unimplemented!()\n         },\n+        Rvalue::Cast(CastKind::Transmute, _, _) => {\n+            Err((span, \"transmute can attempt to turn pointers into integers, so is unstable in const fn\".into()))\n+        },\n         // binops are fine on integers\n         Rvalue::BinaryOp(_, box (lhs, rhs)) | Rvalue::CheckedBinaryOp(_, box (lhs, rhs)) => {\n             check_operand(tcx, lhs, span, body)?;"}, {"sha": "5bc9d9afcb9d172baea4195e9c8bd7d1bfe20f1d", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -964,6 +964,19 @@ pub fn make_test_description<R: Read>(\n         .join(if config.host.contains(\"windows\") { \"rust-lld.exe\" } else { \"rust-lld\" })\n         .exists();\n \n+    fn is_on_path(file: &'static str) -> impl Fn() -> bool {\n+        move || env::split_paths(&env::var_os(\"PATH\").unwrap()).any(|dir| dir.join(file).is_file())\n+    }\n+\n+    // On Windows, dlltool.exe is used for all architectures.\n+    #[cfg(windows)]\n+    let (has_i686_dlltool, has_x86_64_dlltool) =\n+        (is_on_path(\"dlltool.exe\"), is_on_path(\"dlltool.exe\"));\n+    // For non-Windows, there are architecture specific dlltool binaries.\n+    #[cfg(not(windows))]\n+    let (has_i686_dlltool, has_x86_64_dlltool) =\n+        (is_on_path(\"i686-w64-mingw32-dlltool\"), is_on_path(\"x86_64-w64-mingw32-dlltool\"));\n+\n     iter_header(path, src, &mut |revision, ln| {\n         if revision.is_some() && revision != cfg {\n             return;\n@@ -1031,6 +1044,8 @@ pub fn make_test_description<R: Read>(\n         reason!(config.debugger == Some(Debugger::Gdb) && ignore_gdb(config, ln));\n         reason!(config.debugger == Some(Debugger::Lldb) && ignore_lldb(config, ln));\n         reason!(!has_rust_lld && config.parse_name_directive(ln, \"needs-rust-lld\"));\n+        reason!(config.parse_name_directive(ln, \"needs-i686-dlltool\") && !has_i686_dlltool());\n+        reason!(config.parse_name_directive(ln, \"needs-x86_64-dlltool\") && !has_x86_64_dlltool());\n         should_fail |= config.parse_name_directive(ln, \"should-fail\");\n     });\n "}, {"sha": "034c6aa0708ec2522a2a389ff32a77d4f76298c6", "filename": "src/tools/lint-docs/src/lib.rs", "status": "modified", "additions": 62, "deletions": 33, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -45,6 +45,36 @@ impl Lint {\n     fn check_style(&self) -> Result<(), Box<dyn Error>> {\n         for &expected in &[\"### Example\", \"### Explanation\", \"{{produces}}\"] {\n             if expected == \"{{produces}}\" && self.is_ignored() {\n+                if self.doc_contains(\"{{produces}}\") {\n+                    return Err(format!(\n+                        \"the lint example has `ignore`, but also contains the {{{{produces}}}} marker\\n\\\n+                        \\n\\\n+                        The documentation generator cannot generate the example output when the \\\n+                        example is ignored.\\n\\\n+                        Manually include the sample output below the example. For example:\\n\\\n+                        \\n\\\n+                        /// ```rust,ignore (needs command line option)\\n\\\n+                        /// #[cfg(widnows)]\\n\\\n+                        /// fn foo() {{}}\\n\\\n+                        /// ```\\n\\\n+                        ///\\n\\\n+                        /// This will produce:\\n\\\n+                        /// \\n\\\n+                        /// ```text\\n\\\n+                        /// warning: unknown condition name used\\n\\\n+                        ///  --> lint_example.rs:1:7\\n\\\n+                        ///   |\\n\\\n+                        /// 1 | #[cfg(widnows)]\\n\\\n+                        ///   |       ^^^^^^^\\n\\\n+                        ///   |\\n\\\n+                        ///   = note: `#[warn(unexpected_cfgs)]` on by default\\n\\\n+                        /// ```\\n\\\n+                        \\n\\\n+                        Replacing the output with the text of the example you \\\n+                        compiled manually yourself.\\n\\\n+                        \"\n+                    ).into());\n+                }\n                 continue;\n             }\n             if !self.doc_contains(expected) {\n@@ -317,10 +347,10 @@ impl<'a> LintExtractor<'a> {\n                             ..,\n                             &format!(\n                                 \"This will produce:\\n\\\n-                            \\n\\\n-                            ```text\\n\\\n-                            {}\\\n-                            ```\",\n+                                \\n\\\n+                                ```text\\n\\\n+                                {}\\\n+                                ```\",\n                                 output\n                             ),\n                         );\n@@ -392,37 +422,36 @@ impl<'a> LintExtractor<'a> {\n             .filter(|line| line.starts_with('{'))\n             .map(serde_json::from_str)\n             .collect::<Result<Vec<serde_json::Value>, _>>()?;\n-        match msgs\n+        // First try to find the messages with the `code` field set to our lint.\n+        let matches: Vec<_> = msgs\n             .iter()\n-            .find(|msg| matches!(&msg[\"code\"][\"code\"], serde_json::Value::String(s) if s==name))\n-        {\n-            Some(msg) => {\n-                let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n-                Ok(rendered.to_string())\n-            }\n-            None => {\n-                match msgs.iter().find(\n-                    |msg| matches!(&msg[\"rendered\"], serde_json::Value::String(s) if s.contains(name)),\n-                ) {\n-                    Some(msg) => {\n-                        let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n-                        Ok(rendered.to_string())\n-                    }\n-                    None => {\n-                        let rendered: Vec<&str> =\n-                            msgs.iter().filter_map(|msg| msg[\"rendered\"].as_str()).collect();\n-                        let non_json: Vec<&str> =\n-                            stderr.lines().filter(|line| !line.starts_with('{')).collect();\n-                        Err(format!(\n-                            \"did not find lint `{}` in output of example, got:\\n{}\\n{}\",\n-                            name,\n-                            non_json.join(\"\\n\"),\n-                            rendered.join(\"\\n\")\n-                        )\n-                        .into())\n-                    }\n-                }\n+            .filter(|msg| matches!(&msg[\"code\"][\"code\"], serde_json::Value::String(s) if s==name))\n+            .map(|msg| msg[\"rendered\"].as_str().expect(\"rendered field should exist\").to_string())\n+            .collect();\n+        if matches.is_empty() {\n+            // Some lints override their code to something else (E0566).\n+            // Try to find something that looks like it could be our lint.\n+            let matches: Vec<_> = msgs.iter().filter(|msg|\n+                matches!(&msg[\"rendered\"], serde_json::Value::String(s) if s.contains(name)))\n+                .map(|msg| msg[\"rendered\"].as_str().expect(\"rendered field should exist\").to_string())\n+                .collect();\n+            if matches.is_empty() {\n+                let rendered: Vec<&str> =\n+                    msgs.iter().filter_map(|msg| msg[\"rendered\"].as_str()).collect();\n+                let non_json: Vec<&str> =\n+                    stderr.lines().filter(|line| !line.starts_with('{')).collect();\n+                Err(format!(\n+                    \"did not find lint `{}` in output of example, got:\\n{}\\n{}\",\n+                    name,\n+                    non_json.join(\"\\n\"),\n+                    rendered.join(\"\\n\")\n+                )\n+                .into())\n+            } else {\n+                Ok(matches.join(\"\\n\"))\n             }\n+        } else {\n+            Ok(matches.join(\"\\n\"))\n         }\n     }\n "}, {"sha": "8842e939d677fa993dcfb4906a196387203fe8e5", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1 +1 @@\n-cf811810fe8dc92b3ff25e7dd29fb3178c91d409\n+c763eceae349c1d827d9cfbf5df21ca40b21c861"}, {"sha": "cba3cc0ccf17b0c5a6953c27d578e9bd43956f30", "filename": "src/tools/miri/tests/fail/never_transmute_humans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fnever_transmute_humans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fnever_transmute_humans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fnever_transmute_humans.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -7,6 +7,6 @@ struct Human;\n \n fn main() {\n     let _x: ! = unsafe {\n-        std::mem::transmute::<Human, !>(Human) //~ ERROR: transmuting to uninhabited\n+        std::mem::transmute::<Human, !>(Human) //~ ERROR: entering unreachable code\n     };\n }"}, {"sha": "a51ca7fe7e767ccfadf77667d3cf246b048649f5", "filename": "src/tools/miri/tests/fail/never_transmute_humans.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fnever_transmute_humans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fnever_transmute_humans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fnever_transmute_humans.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: transmuting to uninhabited type\n+error: Undefined Behavior: entering unreachable code\n   --> $DIR/never_transmute_humans.rs:LL:CC\n    |\n LL |         std::mem::transmute::<Human, !>(Human)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ entering unreachable code\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "ad67b4446165c0b9b2f04e41e5d9c971268db17d", "filename": "src/tools/miri/tests/fail/never_transmute_void.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fnever_transmute_void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fnever_transmute_void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fnever_transmute_void.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -10,11 +10,13 @@ mod m {\n     pub struct Void(VoidI);\n \n     pub fn f(v: Void) -> ! {\n-        match v.0 {} //~ ERROR: entering unreachable code\n+        match v.0 {}\n+        //~^ ERROR: entering unreachable code\n     }\n }\n \n fn main() {\n     let v = unsafe { std::mem::transmute::<(), m::Void>(()) };\n-    m::f(v); //~ NOTE: inside `main`\n+    m::f(v);\n+    //~^ NOTE: inside `main`\n }"}, {"sha": "6b9a9b66a7d9e759fb7d5e131fd44357cc4e7ed8", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -79,11 +79,18 @@ function checkNeededFields(fullPath, expected, error_text, queryName, position)\n             \"foundElems\",\n             \"original\",\n             \"returned\",\n-            \"typeFilter\",\n             \"userQuery\",\n             \"error\",\n         ];\n-    } else if (fullPath.endsWith(\"elems\") || fullPath.endsWith(\"generics\")) {\n+    } else if (fullPath.endsWith(\"elems\") || fullPath.endsWith(\"returned\")) {\n+        fieldsToCheck = [\n+            \"name\",\n+            \"fullPath\",\n+            \"pathWithoutLast\",\n+            \"pathLast\",\n+            \"generics\",\n+        ];\n+    } else if (fullPath.endsWith(\"generics\")) {\n         fieldsToCheck = [\n             \"name\",\n             \"fullPath\","}, {"sha": "148d11ee4d68748305d2003434b80fcbd82bd4d7", "filename": "tests/assembly/is_aligned.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fis_aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fis_aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Fis_aligned.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,6 +1,7 @@\n // assembly-output: emit-asm\n // min-llvm-version: 15.0\n // only-x86_64\n+// ignore-sgx\n // revisions: opt-speed opt-size\n // [opt-speed] compile-flags: -Copt-level=1\n // [opt-size] compile-flags: -Copt-level=s"}, {"sha": "24a7c6b5bf101523d71e6d55b669ef76ad0cd78a", "filename": "tests/assembly/strict_provenance.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fstrict_provenance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fstrict_provenance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Fstrict_provenance.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,6 +1,7 @@\n // assembly-output: emit-asm\n // compile-flags: -Copt-level=1\n // only-x86_64\n+// ignore-sgx\n // min-llvm-version: 15.0\n #![crate_type = \"rlib\"]\n "}, {"sha": "0bc6baad47919c5bc78d805d115e0308f1c76cd4", "filename": "tests/assembly/x86_64-floating-point-clamp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fx86_64-floating-point-clamp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fx86_64-floating-point-clamp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Fx86_64-floating-point-clamp.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -4,6 +4,7 @@\n // assembly-output: emit-asm\n // compile-flags: --crate-type=lib -O -C llvm-args=-x86-asm-syntax=intel\n // only-x86_64\n+// ignore-sgx\n \n // CHECK-LABEL: clamp_demo:\n #[no_mangle]"}, {"sha": "7eb3c6948ac57aa51bd621d1f665521604be1a4d", "filename": "tests/assembly/x86_64-fortanix-unknown-sgx-lvi-generic-load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fx86_64-fortanix-unknown-sgx-lvi-generic-load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fx86_64-fortanix-unknown-sgx-lvi-generic-load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Fx86_64-fortanix-unknown-sgx-lvi-generic-load.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -11,7 +11,7 @@ pub extern fn plus_one(r: &mut u64) {\n \n // CHECK: plus_one\n // CHECK: lfence\n-// CHECK-NEXT: addq\n+// CHECK-NEXT: incq\n // CHECK: popq [[REGISTER:%[a-z]+]]\n // CHECK-NEXT: lfence\n // CHECK-NEXT: jmpq *[[REGISTER]]"}, {"sha": "4745ebc4fcd44a9aa6f77513e0b85e3279d0bb86", "filename": "tests/assembly/x86_64-fortanix-unknown-sgx-lvi-inline-assembly.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fx86_64-fortanix-unknown-sgx-lvi-inline-assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fx86_64-fortanix-unknown-sgx-lvi-inline-assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Fx86_64-fortanix-unknown-sgx-lvi-inline-assembly.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -10,34 +10,25 @@ use std::arch::asm;\n pub extern \"C\" fn get(ptr: *const u64) -> u64 {\n     let value: u64;\n     unsafe {\n-        asm!(\".start_inline_asm:\",\n-            \"mov {}, [{}]\",\n-            \".end_inline_asm:\",\n+        asm!(\"mov {}, [{}]\",\n             out(reg) value,\n             in(reg) ptr);\n     }\n     value\n }\n \n // CHECK: get\n-// CHECK: .start_inline_asm\n-// CHECK-NEXT: movq\n+// CHECK: movq\n // CHECK-NEXT: lfence\n-// CHECK-NEXT: .end_inline_asm\n \n #[no_mangle]\n pub extern \"C\" fn myret() {\n     unsafe {\n-        asm!(\n-            \".start_myret_inline_asm:\",\n-            \"ret\",\n-            \".end_myret_inline_asm:\",\n-        );\n+        asm!(\"ret\");\n     }\n }\n \n // CHECK: myret\n-// CHECK: .start_myret_inline_asm\n-// CHECK-NEXT: shlq $0, (%rsp)\n+// CHECK: shlq $0, (%rsp)\n // CHECK-NEXT: lfence\n // CHECK-NEXT: retq"}, {"sha": "edf4adaad41aa5a95eda9f1e383bf519ee7383c3", "filename": "tests/assembly/x86_64-no-jump-tables.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fx86_64-no-jump-tables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fassembly%2Fx86_64-no-jump-tables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Fx86_64-no-jump-tables.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -6,6 +6,7 @@\n // compile-flags: -O\n // [set] compile-flags: -Zno-jump-tables\n // only-x86_64\n+// ignore-sgx\n \n #![crate_type = \"lib\"]\n "}, {"sha": "cefcf9ed9caae64595890a73b6c478d8ac27345d", "filename": "tests/codegen/intrinsics/transmute.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,196 @@\n+// compile-flags: -O -C no-prepopulate-passes\n+// only-64bit (so I don't need to worry about usize)\n+// min-llvm-version: 15.0 # this test assumes `ptr`s\n+\n+#![crate_type = \"lib\"]\n+#![feature(core_intrinsics)]\n+#![feature(custom_mir)]\n+#![feature(inline_const)]\n+\n+use std::mem::transmute;\n+\n+// Some of the cases here are statically rejected by `mem::transmute`, so\n+// we need to generate custom MIR for those cases to get to codegen.\n+use std::intrinsics::mir::*;\n+\n+enum Never {}\n+\n+#[repr(align(2))]\n+pub struct BigNever(Never, u16, Never);\n+\n+#[repr(align(8))]\n+pub struct Scalar64(i64);\n+\n+#[repr(C, align(4))]\n+pub struct Aggregate64(u16, u8, i8, f32);\n+\n+// CHECK-LABEL: @check_bigger_size(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+pub unsafe fn check_bigger_size(x: u16) -> u32 {\n+    // CHECK: call void @llvm.trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_smaller_size(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+pub unsafe fn check_smaller_size(x: u32) -> u16 {\n+    // CHECK: call void @llvm.trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_to_uninhabited(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n+    // CHECK: call void @llvm.trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_from_uninhabited(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+pub unsafe fn check_from_uninhabited(x: BigNever) -> u16 {\n+    // CHECK: call void @llvm.trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_to_newtype(\n+#[no_mangle]\n+pub unsafe fn check_to_newtype(x: u64) -> Scalar64 {\n+    // CHECK: %0 = alloca i64\n+    // CHECK: store i64 %x, ptr %0\n+    // CHECK: %1 = load i64, ptr %0\n+    // CHECK: ret i64 %1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_newtype(\n+#[no_mangle]\n+pub unsafe fn check_from_newtype(x: Scalar64) -> u64 {\n+    // CHECK: %0 = alloca i64\n+    // CHECK: store i64 %x, ptr %0\n+    // CHECK: %1 = load i64, ptr %0\n+    // CHECK: ret i64 %1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_to_pair(\n+#[no_mangle]\n+pub unsafe fn check_to_pair(x: u64) -> Option<i32> {\n+    // CHECK: %0 = alloca { i32, i32 }, align 4\n+    // CHECK: store i64 %x, ptr %0, align 4\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_pair(\n+#[no_mangle]\n+pub unsafe fn check_from_pair(x: Option<i32>) -> u64 {\n+    // The two arguments are of types that are only 4-aligned, but they're\n+    // immediates so we can write using the destination alloca's alignment.\n+    const { assert!(std::mem::align_of::<Option<i32>>() == 4) };\n+\n+    // CHECK: %0 = alloca i64, align 8\n+    // CHECK: store i32 %x.0, ptr %1, align 8\n+    // CHECK: store i32 %x.1, ptr %2, align 4\n+    // CHECK: %3 = load i64, ptr %0, align 8\n+    // CHECK: ret i64 %3\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_to_float(\n+#[no_mangle]\n+pub unsafe fn check_to_float(x: u32) -> f32 {\n+    // CHECK: %0 = alloca float\n+    // CHECK: store i32 %x, ptr %0\n+    // CHECK: %1 = load float, ptr %0\n+    // CHECK: ret float %1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_float(\n+#[no_mangle]\n+pub unsafe fn check_from_float(x: f32) -> u32 {\n+    // CHECK: %0 = alloca i32\n+    // CHECK: store float %x, ptr %0\n+    // CHECK: %1 = load i32, ptr %0\n+    // CHECK: ret i32 %1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_to_bytes(\n+#[no_mangle]\n+pub unsafe fn check_to_bytes(x: u32) -> [u8; 4] {\n+    // CHECK: %0 = alloca [4 x i8], align 1\n+    // CHECK: store i32 %x, ptr %0, align 1\n+    // CHECK: %1 = load i32, ptr %0, align 1\n+    // CHECK: ret i32 %1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_bytes(\n+#[no_mangle]\n+pub unsafe fn check_from_bytes(x: [u8; 4]) -> u32 {\n+    // CHECK: %1 = alloca i32, align 4\n+    // CHECK: %x = alloca [4 x i8], align 1\n+    // CHECK: call void @llvm.memcpy.p0.p0.i64(ptr align 4 %1, ptr align 1 %x, i64 4, i1 false)\n+    // CHECK: %3 = load i32, ptr %1, align 4\n+    // CHECK: ret i32 %3\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_to_aggregate(\n+#[no_mangle]\n+pub unsafe fn check_to_aggregate(x: u64) -> Aggregate64 {\n+    // CHECK: %0 = alloca %Aggregate64, align 4\n+    // CHECK: store i64 %x, ptr %0, align 4\n+    // CHECK: %1 = load i64, ptr %0, align 4\n+    // CHECK: ret i64 %1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_aggregate(\n+#[no_mangle]\n+pub unsafe fn check_from_aggregate(x: Aggregate64) -> u64 {\n+    // CHECK: call void @llvm.memcpy.p0.p0.i64(ptr align 8 %{{[0-9]+}}, ptr align 4 %x, i64 8, i1 false)\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_long_array_less_aligned(\n+#[no_mangle]\n+pub unsafe fn check_long_array_less_aligned(x: [u64; 100]) -> [u16; 400] {\n+    // CHECK-NEXT: start\n+    // CHECK-NEXT: call void @llvm.memcpy.p0.p0.i64(ptr align 2 %0, ptr align 8 %x, i64 800, i1 false)\n+    // CHECK-NEXT: ret void\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_long_array_more_aligned(\n+#[no_mangle]\n+pub unsafe fn check_long_array_more_aligned(x: [u8; 100]) -> [u32; 25] {\n+    // CHECK-NEXT: start\n+    // CHECK-NEXT: call void @llvm.memcpy.p0.p0.i64(ptr align 4 %0, ptr align 1 %x, i64 100, i1 false)\n+    // CHECK-NEXT: ret void\n+    transmute(x)\n+}"}, {"sha": "4d7a80bfbe5cce834af4079b18a6d18950968f6d", "filename": "tests/codegen/transmute-scalar.rs", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fcodegen%2Ftransmute-scalar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fcodegen%2Ftransmute-scalar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ftransmute-scalar.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,13 +1,19 @@\n // compile-flags: -O -C no-prepopulate-passes\n+// min-llvm-version: 15.0 # this test assumes `ptr`s and thus no `pointercast`s\n \n #![crate_type = \"lib\"]\n \n-// FIXME(eddyb) all of these tests show memory stores and loads, even after a\n-// scalar `bitcast`, more special-casing is required to remove `alloca` usage.\n+// With opaque ptrs in LLVM, `transmute` can load/store any `alloca` as any type,\n+// without needing to pointercast, and SRoA will turn that into a `bitcast`.\n+// As such, there's no longer special-casing in `transmute` to attempt to\n+// generate `bitcast` ourselves, as that just made the IR longer.\n+\n+// FIXME: That said, `bitcast`s could still be a valuable addition if they could\n+// be done in `rvalue_creates_operand`, and thus avoid the `alloca`s entirely.\n \n // CHECK-LABEL: define{{.*}}i32 @f32_to_bits(float noundef %x)\n-// CHECK: store i32 %{{.*}}, {{.*}} %0\n-// CHECK-NEXT: %[[RES:.*]] = load i32, {{.*}} %0\n+// CHECK: store float %{{.*}}, ptr %0\n+// CHECK-NEXT: %[[RES:.*]] = load i32, ptr %0\n // CHECK: ret i32 %[[RES]]\n #[no_mangle]\n pub fn f32_to_bits(x: f32) -> u32 {\n@@ -25,12 +31,10 @@ pub fn bool_to_byte(b: bool) -> u8 {\n }\n \n // CHECK-LABEL: define{{.*}}noundef zeroext i1 @byte_to_bool(i8 noundef %byte)\n-// CHECK: %1 = trunc i8 %byte to i1\n-// CHECK-NEXT: %2 = zext i1 %1 to i8\n-// CHECK-NEXT: store i8 %2, {{.*}} %0\n-// CHECK-NEXT: %3 = load i8, {{.*}} %0\n-// CHECK-NEXT: %4 = trunc i8 %3 to i1\n-// CHECK: ret i1 %4\n+// CHECK: store i8 %byte, ptr %0\n+// CHECK-NEXT: %1 = load i8, {{.*}} %0\n+// CHECK-NEXT: %2 = trunc i8 %1 to i1\n+// CHECK: ret i1 %2\n #[no_mangle]\n pub unsafe fn byte_to_bool(byte: u8) -> bool {\n     std::mem::transmute(byte)\n@@ -45,20 +49,8 @@ pub fn ptr_to_ptr(p: *mut u16) -> *mut u8 {\n     unsafe { std::mem::transmute(p) }\n }\n \n-// HACK(eddyb) scalar `transmute`s between pointers and non-pointers are\n-// currently not special-cased like other scalar `transmute`s, because\n-// LLVM requires specifically `ptrtoint`/`inttoptr` instead of `bitcast`.\n-//\n-// Tests below show the non-special-cased behavior (with the possible\n-// future special-cased instructions in the \"NOTE(eddyb)\" comments).\n-\n // CHECK: define{{.*}}[[USIZE:i[0-9]+]] @ptr_to_int({{i16\\*|ptr}} noundef %p)\n-\n-// NOTE(eddyb) see above, the following two CHECK lines should ideally be this:\n-//        %2 = ptrtoint i16* %p to [[USIZE]]\n-//             store [[USIZE]] %2, [[USIZE]]* %0\n // CHECK: store {{i16\\*|ptr}} %p, {{.*}}\n-\n // CHECK-NEXT: %[[RES:.*]] = load [[USIZE]], {{.*}} %0\n // CHECK: ret [[USIZE]] %[[RES]]\n #[no_mangle]\n@@ -67,12 +59,7 @@ pub fn ptr_to_int(p: *mut u16) -> usize {\n }\n \n // CHECK: define{{.*}}{{i16\\*|ptr}} @int_to_ptr([[USIZE]] noundef %i)\n-\n-// NOTE(eddyb) see above, the following two CHECK lines should ideally be this:\n-//        %2 = inttoptr [[USIZE]] %i to i16*\n-//             store i16* %2, i16** %0\n // CHECK: store [[USIZE]] %i, {{.*}}\n-\n // CHECK-NEXT: %[[RES:.*]] = load {{i16\\*|ptr}}, {{.*}} %0\n // CHECK: ret {{i16\\*|ptr}} %[[RES]]\n #[no_mangle]"}, {"sha": "4b63a00a304dc80b7df45071d42a444c24a3d3de", "filename": "tests/mir-opt/building/shifts.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fbuilding%2Fshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fbuilding%2Fshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fshifts.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -C debug-assertions=yes\n+\n+// EMIT_MIR shifts.shift_signed.built.after.mir\n+fn shift_signed(small: i8, big: u128, a: i8, b: i32, c: i128) -> ([i8; 3], [u128; 3]) {\n+    (\n+        [small >> a, small >> b, small >> c],\n+        [big << a, big << b, big << c],\n+    )\n+}\n+\n+// EMIT_MIR shifts.shift_unsigned.built.after.mir\n+fn shift_unsigned(small: u8, big: i128, a: u8, b: u32, c: u128) -> ([u8; 3], [i128; 3]) {\n+    (\n+        [small >> a, small >> b, small >> c],\n+        [big << a, big << b, big << c],\n+    )\n+}\n+\n+fn main() {\n+}"}, {"sha": "028777cefdd10a932dbf552153d8ba3f85dbdca1", "filename": "tests/mir-opt/building/shifts.shift_signed.built.after.mir", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_signed.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_signed.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_signed.built.after.mir?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,147 @@\n+// MIR for `shift_signed` after built\n+\n+fn shift_signed(_1: i8, _2: u128, _3: i8, _4: i32, _5: i128) -> ([i8; 3], [u128; 3]) {\n+    debug small => _1;                   // in scope 0 at $DIR/shifts.rs:+0:17: +0:22\n+    debug big => _2;                     // in scope 0 at $DIR/shifts.rs:+0:28: +0:31\n+    debug a => _3;                       // in scope 0 at $DIR/shifts.rs:+0:39: +0:40\n+    debug b => _4;                       // in scope 0 at $DIR/shifts.rs:+0:46: +0:47\n+    debug c => _5;                       // in scope 0 at $DIR/shifts.rs:+0:54: +0:55\n+    let mut _0: ([i8; 3], [u128; 3]);    // return place in scope 0 at $DIR/shifts.rs:+0:66: +0:86\n+    let mut _6: [i8; 3];                 // in scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+    let mut _7: i8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _8: i8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+    let mut _9: i8;                      // in scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+    let mut _10: u8;                     // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _11: bool;                   // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _12: i8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _13: i8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+    let mut _14: i32;                    // in scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+    let mut _15: u32;                    // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _16: bool;                   // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _17: i8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _18: i8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+    let mut _19: i128;                   // in scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+    let mut _20: u128;                   // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _21: bool;                   // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _22: [u128; 3];              // in scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+    let mut _23: u128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _24: u128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+    let mut _25: i8;                     // in scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+    let mut _26: u8;                     // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _27: bool;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _28: u128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _29: u128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+    let mut _30: i32;                    // in scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+    let mut _31: u32;                    // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _32: bool;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _33: u128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    let mut _34: u128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+    let mut _35: i128;                   // in scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+    let mut _36: u128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    let mut _37: bool;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+\n+    bb0: {\n+        StorageLive(_6);                 // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageLive(_7);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageLive(_8);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        _8 = _1;                         // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        StorageLive(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _9 = _3;                         // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _10 = _9 as u8 (IntToInt);       // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        _11 = Lt(move _10, const 8_u8);  // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        assert(move _11, \"attempt to shift right by `{}`, which would overflow\", _9) -> [success: bb1, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    }\n+\n+    bb1: {\n+        _7 = Shr(move _8, move _9);      // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageDead(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageDead(_8);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageLive(_12);                // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageLive(_13);                // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        _13 = _1;                        // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        StorageLive(_14);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _14 = _4;                        // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _15 = _14 as u32 (IntToInt);     // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        _16 = Lt(move _15, const 8_u32); // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        assert(move _16, \"attempt to shift right by `{}`, which would overflow\", _14) -> [success: bb2, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    }\n+\n+    bb2: {\n+        _12 = Shr(move _13, move _14);   // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageDead(_14);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageDead(_13);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageLive(_17);                // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageLive(_18);                // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        _18 = _1;                        // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        StorageLive(_19);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _19 = _5;                        // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _20 = _19 as u128 (IntToInt);    // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        _21 = Lt(move _20, const 8_u128); // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        assert(move _21, \"attempt to shift right by `{}`, which would overflow\", _19) -> [success: bb3, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    }\n+\n+    bb3: {\n+        _17 = Shr(move _18, move _19);   // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageDead(_19);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        StorageDead(_18);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _6 = [move _7, move _12, move _17]; // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageDead(_17);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_12);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_7);                 // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageLive(_22);                // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageLive(_23);                // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageLive(_24);                // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        _24 = _2;                        // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        StorageLive(_25);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _25 = _3;                        // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _26 = _25 as u8 (IntToInt);      // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        _27 = Lt(move _26, const 128_u8); // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        assert(move _27, \"attempt to shift left by `{}`, which would overflow\", _25) -> [success: bb4, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    }\n+\n+    bb4: {\n+        _23 = Shl(move _24, move _25);   // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageDead(_25);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageDead(_24);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageLive(_28);                // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageLive(_29);                // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        _29 = _2;                        // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        StorageLive(_30);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _30 = _4;                        // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _31 = _30 as u32 (IntToInt);     // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        _32 = Lt(move _31, const 128_u32); // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        assert(move _32, \"attempt to shift left by `{}`, which would overflow\", _30) -> [success: bb5, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    }\n+\n+    bb5: {\n+        _28 = Shl(move _29, move _30);   // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageDead(_30);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageDead(_29);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageLive(_33);                // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageLive(_34);                // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        _34 = _2;                        // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        StorageLive(_35);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _35 = _5;                        // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _36 = _35 as u128 (IntToInt);    // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        _37 = Lt(move _36, const 128_u128); // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        assert(move _37, \"attempt to shift left by `{}`, which would overflow\", _35) -> [success: bb6, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    }\n+\n+    bb6: {\n+        _33 = Shl(move _34, move _35);   // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageDead(_35);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        StorageDead(_34);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _22 = [move _23, move _28, move _33]; // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageDead(_33);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_28);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_23);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        _0 = (move _6, move _22);        // scope 0 at $DIR/shifts.rs:+1:5: +4:6\n+        StorageDead(_22);                // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        StorageDead(_6);                 // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        return;                          // scope 0 at $DIR/shifts.rs:+5:2: +5:2\n+    }\n+\n+    bb7 (cleanup): {\n+        resume;                          // scope 0 at $DIR/shifts.rs:+0:1: +5:2\n+    }\n+}"}, {"sha": "04da2d20d242fab460c7537a2c28532c207635d0", "filename": "tests/mir-opt/building/shifts.shift_unsigned.built.after.mir", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_unsigned.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_unsigned.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_unsigned.built.after.mir?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,135 @@\n+// MIR for `shift_unsigned` after built\n+\n+fn shift_unsigned(_1: u8, _2: i128, _3: u8, _4: u32, _5: u128) -> ([u8; 3], [i128; 3]) {\n+    debug small => _1;                   // in scope 0 at $DIR/shifts.rs:+0:19: +0:24\n+    debug big => _2;                     // in scope 0 at $DIR/shifts.rs:+0:30: +0:33\n+    debug a => _3;                       // in scope 0 at $DIR/shifts.rs:+0:41: +0:42\n+    debug b => _4;                       // in scope 0 at $DIR/shifts.rs:+0:48: +0:49\n+    debug c => _5;                       // in scope 0 at $DIR/shifts.rs:+0:56: +0:57\n+    let mut _0: ([u8; 3], [i128; 3]);    // return place in scope 0 at $DIR/shifts.rs:+0:68: +0:88\n+    let mut _6: [u8; 3];                 // in scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+    let mut _7: u8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _8: u8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+    let mut _9: u8;                      // in scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+    let mut _10: bool;                   // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _11: u8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _12: u8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+    let mut _13: u32;                    // in scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+    let mut _14: bool;                   // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _15: u8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _16: u8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+    let mut _17: u128;                   // in scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+    let mut _18: bool;                   // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _19: [i128; 3];              // in scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+    let mut _20: i128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _21: i128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+    let mut _22: u8;                     // in scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+    let mut _23: bool;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _24: i128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _25: i128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+    let mut _26: u32;                    // in scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+    let mut _27: bool;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _28: i128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    let mut _29: i128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+    let mut _30: u128;                   // in scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+    let mut _31: bool;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+\n+    bb0: {\n+        StorageLive(_6);                 // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageLive(_7);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageLive(_8);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        _8 = _1;                         // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        StorageLive(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _9 = _3;                         // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _10 = Lt(_9, const 8_u8);        // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        assert(move _10, \"attempt to shift right by `{}`, which would overflow\", _9) -> [success: bb1, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    }\n+\n+    bb1: {\n+        _7 = Shr(move _8, move _9);      // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageDead(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageDead(_8);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageLive(_11);                // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageLive(_12);                // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        _12 = _1;                        // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        StorageLive(_13);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _13 = _4;                        // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _14 = Lt(_13, const 8_u32);      // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        assert(move _14, \"attempt to shift right by `{}`, which would overflow\", _13) -> [success: bb2, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    }\n+\n+    bb2: {\n+        _11 = Shr(move _12, move _13);   // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageDead(_13);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageDead(_12);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageLive(_15);                // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageLive(_16);                // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        _16 = _1;                        // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        StorageLive(_17);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _17 = _5;                        // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _18 = Lt(_17, const 8_u128);     // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        assert(move _18, \"attempt to shift right by `{}`, which would overflow\", _17) -> [success: bb3, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    }\n+\n+    bb3: {\n+        _15 = Shr(move _16, move _17);   // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageDead(_17);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        StorageDead(_16);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _6 = [move _7, move _11, move _15]; // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageDead(_15);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_11);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_7);                 // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageLive(_19);                // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageLive(_20);                // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageLive(_21);                // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        _21 = _2;                        // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        StorageLive(_22);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _22 = _3;                        // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _23 = Lt(_22, const 128_u8);     // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        assert(move _23, \"attempt to shift left by `{}`, which would overflow\", _22) -> [success: bb4, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    }\n+\n+    bb4: {\n+        _20 = Shl(move _21, move _22);   // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageDead(_22);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageDead(_21);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageLive(_24);                // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageLive(_25);                // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        _25 = _2;                        // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        StorageLive(_26);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _26 = _4;                        // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _27 = Lt(_26, const 128_u32);    // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        assert(move _27, \"attempt to shift left by `{}`, which would overflow\", _26) -> [success: bb5, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    }\n+\n+    bb5: {\n+        _24 = Shl(move _25, move _26);   // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageDead(_26);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageDead(_25);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageLive(_28);                // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageLive(_29);                // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        _29 = _2;                        // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        StorageLive(_30);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _30 = _5;                        // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _31 = Lt(_30, const 128_u128);   // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        assert(move _31, \"attempt to shift left by `{}`, which would overflow\", _30) -> [success: bb6, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    }\n+\n+    bb6: {\n+        _28 = Shl(move _29, move _30);   // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageDead(_30);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        StorageDead(_29);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _19 = [move _20, move _24, move _28]; // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageDead(_28);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_24);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_20);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        _0 = (move _6, move _19);        // scope 0 at $DIR/shifts.rs:+1:5: +4:6\n+        StorageDead(_19);                // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        StorageDead(_6);                 // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        return;                          // scope 0 at $DIR/shifts.rs:+5:2: +5:2\n+    }\n+\n+    bb7 (cleanup): {\n+        resume;                          // scope 0 at $DIR/shifts.rs:+0:1: +5:2\n+    }\n+}"}, {"sha": "933dfbb5166d28ffec0c7ac7a99ec5d06a1b1cbb", "filename": "tests/mir-opt/const_prop/transmute.from_char.ConstProp.diff", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.from_char.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.from_char.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.from_char.ConstProp.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,15 @@\n+- // MIR for `from_char` before ConstProp\n++ // MIR for `from_char` after ConstProp\n+  \n+  fn from_char() -> i32 {\n+      let mut _0: i32;                     // return place in scope 0 at $DIR/transmute.rs:+0:23: +0:26\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+-         _0 = const 'R' as i32 (Transmute); // scope 1 at $DIR/transmute.rs:+1:14: +1:28\n++         _0 = const 82_i32;               // scope 1 at $DIR/transmute.rs:+1:14: +1:28\n+          return;                          // scope 0 at $DIR/transmute.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "f3474855f027da2dda9d9631cf546fa2d63b53bf", "filename": "tests/mir-opt/const_prop/transmute.invalid_bool.ConstProp.diff", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.invalid_bool.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.invalid_bool.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.invalid_bool.ConstProp.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,14 @@\n+- // MIR for `invalid_bool` before ConstProp\n++ // MIR for `invalid_bool` after ConstProp\n+  \n+  fn invalid_bool() -> bool {\n+      let mut _0: bool;                    // return place in scope 0 at $DIR/transmute.rs:+0:33: +0:37\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          _0 = const -1_i8 as bool (Transmute); // scope 1 at $DIR/transmute.rs:+1:14: +1:30\n+          return;                          // scope 0 at $DIR/transmute.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "ba087e226c9c468ac8190125031edd98c47828da", "filename": "tests/mir-opt/const_prop/transmute.invalid_char.ConstProp.diff", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.invalid_char.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.invalid_char.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.invalid_char.ConstProp.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,14 @@\n+- // MIR for `invalid_char` before ConstProp\n++ // MIR for `invalid_char` after ConstProp\n+  \n+  fn invalid_char() -> char {\n+      let mut _0: char;                    // return place in scope 0 at $DIR/transmute.rs:+0:33: +0:37\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          _0 = const _ as char (Transmute); // scope 1 at $DIR/transmute.rs:+1:14: +1:33\n+          return;                          // scope 0 at $DIR/transmute.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "76d464789c191d33025a08571f7448c7b9607e44", "filename": "tests/mir-opt/const_prop/transmute.less_as_i8.ConstProp.diff", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.less_as_i8.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.less_as_i8.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.less_as_i8.ConstProp.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,23 @@\n+- // MIR for `less_as_i8` before ConstProp\n++ // MIR for `less_as_i8` after ConstProp\n+  \n+  fn less_as_i8() -> i8 {\n+      let mut _0: i8;                      // return place in scope 0 at $DIR/transmute.rs:+0:24: +0:26\n+      let mut _1: std::cmp::Ordering;      // in scope 0 at $DIR/transmute.rs:+1:24: +1:48\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 1 at $DIR/transmute.rs:+1:24: +1:48\n+-         _1 = Less;                       // scope 1 at $DIR/transmute.rs:+1:24: +1:48\n+-         _0 = move _1 as i8 (Transmute);  // scope 1 at $DIR/transmute.rs:+1:14: +1:49\n++         _1 = const Less;                 // scope 1 at $DIR/transmute.rs:+1:24: +1:48\n++                                          // mir::Constant\n++                                          // + span: no-location\n++                                          // + literal: Const { ty: std::cmp::Ordering, val: Value(Scalar(0xff)) }\n++         _0 = const -1_i8;                // scope 1 at $DIR/transmute.rs:+1:14: +1:49\n+          StorageDead(_1);                 // scope 1 at $DIR/transmute.rs:+1:48: +1:49\n+          return;                          // scope 0 at $DIR/transmute.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "b753cdccd606f63ed33a4d2947798019f45ed360", "filename": "tests/mir-opt/const_prop/transmute.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,61 @@\n+// unit-test: ConstProp\n+// compile-flags: -O --crate-type=lib\n+\n+use std::mem::transmute;\n+\n+// EMIT_MIR transmute.less_as_i8.ConstProp.diff\n+pub fn less_as_i8() -> i8 {\n+    unsafe { transmute(std::cmp::Ordering::Less) }\n+}\n+\n+// EMIT_MIR transmute.from_char.ConstProp.diff\n+pub fn from_char() -> i32 {\n+    unsafe { transmute('R') }\n+}\n+\n+// EMIT_MIR transmute.valid_char.ConstProp.diff\n+pub fn valid_char() -> char {\n+    unsafe { transmute(0x52_u32) }\n+}\n+\n+// EMIT_MIR transmute.invalid_char.ConstProp.diff\n+pub unsafe fn invalid_char() -> char {\n+    unsafe { transmute(i32::MAX) }\n+}\n+\n+// EMIT_MIR transmute.invalid_bool.ConstProp.diff\n+pub unsafe fn invalid_bool() -> bool {\n+    unsafe { transmute(-1_i8) }\n+}\n+\n+// EMIT_MIR transmute.undef_union_as_integer.ConstProp.diff\n+pub unsafe fn undef_union_as_integer() -> u32 {\n+    union Union32 { value: u32, unit: () }\n+    unsafe { transmute(Union32 { unit: () }) }\n+}\n+\n+// EMIT_MIR transmute.unreachable_direct.ConstProp.diff\n+pub unsafe fn unreachable_direct() -> ! {\n+    let x: Never = unsafe { transmute(()) };\n+    match x {}\n+}\n+\n+// EMIT_MIR transmute.unreachable_ref.ConstProp.diff\n+pub unsafe fn unreachable_ref() -> ! {\n+    let x: &Never = unsafe { transmute(1_usize) };\n+    match *x {}\n+}\n+\n+// EMIT_MIR transmute.unreachable_mut.ConstProp.diff\n+pub unsafe fn unreachable_mut() -> ! {\n+    let x: &mut Never = unsafe { transmute(1_usize) };\n+    match *x {}\n+}\n+\n+// EMIT_MIR transmute.unreachable_box.ConstProp.diff\n+pub unsafe fn unreachable_box() -> ! {\n+    let x: Box<Never> = unsafe { transmute(1_usize) };\n+    match *x {}\n+}\n+\n+enum Never {}"}, {"sha": "538b1f26e4c9bc444b9e18475b0e06a1f7841b8e", "filename": "tests/mir-opt/const_prop/transmute.undef_union_as_integer.ConstProp.diff", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.undef_union_as_integer.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.undef_union_as_integer.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.undef_union_as_integer.ConstProp.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,22 @@\n+- // MIR for `undef_union_as_integer` before ConstProp\n++ // MIR for `undef_union_as_integer` after ConstProp\n+  \n+  fn undef_union_as_integer() -> u32 {\n+      let mut _0: u32;                     // return place in scope 0 at $DIR/transmute.rs:+0:43: +0:46\n+      let mut _1: undef_union_as_integer::Union32; // in scope 0 at $DIR/transmute.rs:+2:24: +2:44\n+      let mut _2: ();                      // in scope 0 at $DIR/transmute.rs:+2:40: +2:42\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 1 at $DIR/transmute.rs:+2:24: +2:44\n+          StorageLive(_2);                 // scope 1 at $DIR/transmute.rs:+2:40: +2:42\n+          _2 = ();                         // scope 1 at $DIR/transmute.rs:+2:40: +2:42\n+          _1 = Union32 { value: move _2 }; // scope 1 at $DIR/transmute.rs:+2:24: +2:44\n+          StorageDead(_2);                 // scope 1 at $DIR/transmute.rs:+2:43: +2:44\n+          _0 = move _1 as u32 (Transmute); // scope 1 at $DIR/transmute.rs:+2:14: +2:45\n+          StorageDead(_1);                 // scope 1 at $DIR/transmute.rs:+2:44: +2:45\n+          return;                          // scope 0 at $DIR/transmute.rs:+3:2: +3:2\n+      }\n+  }\n+  "}, {"sha": "8bf97996a678f3d5034c7de7b8104b723e526fd3", "filename": "tests/mir-opt/const_prop/transmute.unreachable_box.ConstProp.diff", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_box.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_box.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_box.ConstProp.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,23 @@\n+- // MIR for `unreachable_box` before ConstProp\n++ // MIR for `unreachable_box` after ConstProp\n+  \n+  fn unreachable_box() -> ! {\n+      let mut _0: !;                       // return place in scope 0 at $DIR/transmute.rs:+0:36: +0:37\n+      let mut _1: !;                       // in scope 0 at $DIR/transmute.rs:+0:38: +3:2\n+      let _2: std::boxed::Box<Never>;      // in scope 0 at $DIR/transmute.rs:+1:9: +1:10\n+      let mut _3: !;                       // in scope 0 at $DIR/transmute.rs:+2:5: +2:16\n+      scope 1 {\n+          debug x => _2;                   // in scope 1 at $DIR/transmute.rs:+1:9: +1:10\n+      }\n+      scope 2 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/transmute.rs:+0:38: +3:2\n+          StorageLive(_2);                 // scope 0 at $DIR/transmute.rs:+1:9: +1:10\n+          _2 = const 1_usize as std::boxed::Box<Never> (Transmute); // scope 2 at $DIR/transmute.rs:+1:34: +1:52\n+          StorageLive(_3);                 // scope 1 at $DIR/transmute.rs:+2:5: +2:16\n+          unreachable;                     // scope 1 at $DIR/transmute.rs:+2:11: +2:13\n+      }\n+  }\n+  "}, {"sha": "81b7b36899309f1c2460385f221b01dd94452893", "filename": "tests/mir-opt/const_prop/transmute.unreachable_direct.ConstProp.diff", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_direct.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_direct.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_direct.ConstProp.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,25 @@\n+- // MIR for `unreachable_direct` before ConstProp\n++ // MIR for `unreachable_direct` after ConstProp\n+  \n+  fn unreachable_direct() -> ! {\n+      let mut _0: !;                       // return place in scope 0 at $DIR/transmute.rs:+0:39: +0:40\n+      let mut _1: !;                       // in scope 0 at $DIR/transmute.rs:+0:41: +3:2\n+      let _2: Never;                       // in scope 0 at $DIR/transmute.rs:+1:9: +1:10\n+      let mut _3: ();                      // in scope 0 at $DIR/transmute.rs:+1:39: +1:41\n+      let mut _4: !;                       // in scope 0 at $DIR/transmute.rs:+2:5: +2:15\n+      scope 1 {\n+          debug x => _2;                   // in scope 1 at $DIR/transmute.rs:+1:9: +1:10\n+      }\n+      scope 2 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/transmute.rs:+0:41: +3:2\n+          StorageLive(_2);                 // scope 0 at $DIR/transmute.rs:+1:9: +1:10\n+          StorageLive(_3);                 // scope 2 at $DIR/transmute.rs:+1:39: +1:41\n+          _3 = ();                         // scope 2 at $DIR/transmute.rs:+1:39: +1:41\n+          _2 = move _3 as Never (Transmute); // scope 2 at $DIR/transmute.rs:+1:29: +1:42\n+          unreachable;                     // scope 2 at $DIR/transmute.rs:+1:29: +1:42\n+      }\n+  }\n+  "}, {"sha": "34f7aea8ed26c67515197515d6690f6db3e551fd", "filename": "tests/mir-opt/const_prop/transmute.unreachable_mut.ConstProp.diff", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_mut.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_mut.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_mut.ConstProp.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,27 @@\n+- // MIR for `unreachable_mut` before ConstProp\n++ // MIR for `unreachable_mut` after ConstProp\n+  \n+  fn unreachable_mut() -> ! {\n+      let mut _0: !;                       // return place in scope 0 at $DIR/transmute.rs:+0:36: +0:37\n+      let mut _1: !;                       // in scope 0 at $DIR/transmute.rs:+0:38: +3:2\n+      let _2: &mut Never;                  // in scope 0 at $DIR/transmute.rs:+1:9: +1:10\n+      let mut _3: &mut Never;              // in scope 0 at $DIR/transmute.rs:+1:34: +1:52\n+      let mut _4: !;                       // in scope 0 at $DIR/transmute.rs:+2:5: +2:16\n+      scope 1 {\n+          debug x => _2;                   // in scope 1 at $DIR/transmute.rs:+1:9: +1:10\n+      }\n+      scope 2 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/transmute.rs:+0:38: +3:2\n+          StorageLive(_2);                 // scope 0 at $DIR/transmute.rs:+1:9: +1:10\n+          StorageLive(_3);                 // scope 0 at $DIR/transmute.rs:+1:34: +1:52\n+          _3 = const 1_usize as &mut Never (Transmute); // scope 2 at $DIR/transmute.rs:+1:34: +1:52\n+          _2 = &mut (*_3);                 // scope 0 at $DIR/transmute.rs:+1:34: +1:52\n+          StorageDead(_3);                 // scope 0 at $DIR/transmute.rs:+1:54: +1:55\n+          StorageLive(_4);                 // scope 1 at $DIR/transmute.rs:+2:5: +2:16\n+          unreachable;                     // scope 1 at $DIR/transmute.rs:+2:11: +2:13\n+      }\n+  }\n+  "}, {"sha": "ff95f2a0b943c7aa3199e75807e2f402b33b1769", "filename": "tests/mir-opt/const_prop/transmute.unreachable_ref.ConstProp.diff", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_ref.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_ref.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.unreachable_ref.ConstProp.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,23 @@\n+- // MIR for `unreachable_ref` before ConstProp\n++ // MIR for `unreachable_ref` after ConstProp\n+  \n+  fn unreachable_ref() -> ! {\n+      let mut _0: !;                       // return place in scope 0 at $DIR/transmute.rs:+0:36: +0:37\n+      let mut _1: !;                       // in scope 0 at $DIR/transmute.rs:+0:38: +3:2\n+      let _2: &Never;                      // in scope 0 at $DIR/transmute.rs:+1:9: +1:10\n+      let mut _3: !;                       // in scope 0 at $DIR/transmute.rs:+2:5: +2:16\n+      scope 1 {\n+          debug x => _2;                   // in scope 1 at $DIR/transmute.rs:+1:9: +1:10\n+      }\n+      scope 2 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/transmute.rs:+0:38: +3:2\n+          StorageLive(_2);                 // scope 0 at $DIR/transmute.rs:+1:9: +1:10\n+          _2 = const 1_usize as &Never (Transmute); // scope 2 at $DIR/transmute.rs:+1:30: +1:48\n+          StorageLive(_3);                 // scope 1 at $DIR/transmute.rs:+2:5: +2:16\n+          unreachable;                     // scope 1 at $DIR/transmute.rs:+2:11: +2:13\n+      }\n+  }\n+  "}, {"sha": "eac33b730034864ee0bac7a4f0204e71d76cfa0e", "filename": "tests/mir-opt/const_prop/transmute.valid_char.ConstProp.diff", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.valid_char.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.valid_char.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftransmute.valid_char.ConstProp.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,15 @@\n+- // MIR for `valid_char` before ConstProp\n++ // MIR for `valid_char` after ConstProp\n+  \n+  fn valid_char() -> char {\n+      let mut _0: char;                    // return place in scope 0 at $DIR/transmute.rs:+0:24: +0:28\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+-         _0 = const 82_u32 as char (Transmute); // scope 1 at $DIR/transmute.rs:+1:14: +1:33\n++         _0 = const 'R';                  // scope 1 at $DIR/transmute.rs:+1:14: +1:33\n+          return;                          // scope 0 at $DIR/transmute.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "b377a65b96418f7af20a4f182832246a640e7c73", "filename": "tests/mir-opt/issue_101973.inner.ConstProp.diff", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -12,9 +12,9 @@\n       let mut _7: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n       let mut _8: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       let mut _9: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:33: +1:39\n-      let mut _10: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+      let mut _10: u32;                    // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       let mut _11: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-      let mut _12: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+      let mut _12: u32;                    // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       let mut _13: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       scope 1 (inlined imm8) {             // at $DIR/issue_101973.rs:14:5: 14:17\n           debug x => _1;                   // in scope 1 at $DIR/issue_101973.rs:5:13: 5:14\n@@ -43,24 +43,24 @@\n           StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n           StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n--         _10 = BitAnd(const 8_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n--         _11 = Ne(move _10, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n--         assert(!move _11, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-+         _10 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-+         _11 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-+         assert(!const false, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _10 = const 8_i32 as u32 (IntToInt); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _11 = Lt(move _10, const 32_u32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         assert(move _11, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _10 = const 8_u32;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _11 = const true;                // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         assert(const true, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       }\n   \n       bb1: {\n           _8 = Shr(_1, const 8_i32);       // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n           _7 = BitAnd(move _8, const 15_u32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageDead(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:51: +1:52\n--         _12 = BitAnd(const 1_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n--         _13 = Ne(move _12, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n--         assert(!move _13, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-+         _12 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-+         _13 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-+         assert(!const false, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _12 = const 1_i32 as u32 (IntToInt); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _13 = Lt(move _12, const 32_u32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         assert(move _13, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _12 = const 1_u32;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _13 = const true;                // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         assert(const true, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       }\n   \n       bb2: {"}, {"sha": "8e6e6fc0ec2a3f72054446471d62084769ec9a27", "filename": "tests/mir-opt/issues/issue_75439.foo.MatchBranchSimplification.diff", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -24,61 +24,49 @@\n           StorageLive(_2);                 // scope 0 at $DIR/issue_75439.rs:+2:9: +2:15\n           StorageLive(_3);                 // scope 2 at $DIR/issue_75439.rs:+2:47: +2:52\n           _3 = _1;                         // scope 2 at $DIR/issue_75439.rs:+2:47: +2:52\n-          _2 = transmute::<[u8; 16], [u32; 4]>(move _3) -> bb1; // scope 2 at $DIR/issue_75439.rs:+2:37: +2:53\n-                                           // mir::Constant\n-                                           // + span: $DIR/issue_75439.rs:8:37: 8:46\n-                                           // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn([u8; 16]) -> [u32; 4] {transmute::<[u8; 16], [u32; 4]>}, val: Value(<ZST>) }\n+          _2 = move _3 as [u32; 4] (Transmute); // scope 2 at $DIR/issue_75439.rs:+2:37: +2:53\n+          StorageDead(_3);                 // scope 2 at $DIR/issue_75439.rs:+2:52: +2:53\n+          switchInt(_2[0 of 4]) -> [0: bb1, otherwise: bb6]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n       }\n   \n       bb1: {\n-          StorageDead(_3);                 // scope 2 at $DIR/issue_75439.rs:+2:52: +2:53\n-          switchInt(_2[0 of 4]) -> [0: bb2, otherwise: bb8]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n+          switchInt(_2[1 of 4]) -> [0: bb2, otherwise: bb6]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n       }\n   \n       bb2: {\n-          switchInt(_2[1 of 4]) -> [0: bb3, otherwise: bb8]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n+          switchInt(_2[2 of 4]) -> [0: bb4, 4294901760: bb5, otherwise: bb6]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n       }\n   \n       bb3: {\n-          switchInt(_2[2 of 4]) -> [0: bb5, 4294901760: bb6, otherwise: bb8]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n-      }\n-  \n-      bb4: {\n           StorageLive(_5);                 // scope 3 at $DIR/issue_75439.rs:+5:14: +5:38\n           StorageLive(_6);                 // scope 4 at $DIR/issue_75439.rs:+5:33: +5:35\n           _6 = _4;                         // scope 4 at $DIR/issue_75439.rs:+5:33: +5:35\n-          _5 = transmute::<u32, [u8; 4]>(move _6) -> bb7; // scope 4 at $DIR/issue_75439.rs:+5:23: +5:36\n-                                           // mir::Constant\n-                                           // + span: $DIR/issue_75439.rs:11:23: 11:32\n-                                           // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) -> [u8; 4] {transmute::<u32, [u8; 4]>}, val: Value(<ZST>) }\n+          _5 = move _6 as [u8; 4] (Transmute); // scope 4 at $DIR/issue_75439.rs:+5:23: +5:36\n+          StorageDead(_6);                 // scope 4 at $DIR/issue_75439.rs:+5:35: +5:36\n+          _0 = Option::<[u8; 4]>::Some(move _5); // scope 3 at $DIR/issue_75439.rs:+5:9: +5:39\n+          StorageDead(_5);                 // scope 3 at $DIR/issue_75439.rs:+5:38: +5:39\n+          StorageDead(_4);                 // scope 1 at $DIR/issue_75439.rs:+6:5: +6:6\n+          goto -> bb7;                     // scope 1 at $DIR/issue_75439.rs:+4:5: +8:6\n       }\n   \n-      bb5: {\n+      bb4: {\n           StorageLive(_4);                 // scope 3 at $DIR/issue_75439.rs:+4:27: +4:29\n           _4 = _2[3 of 4];                 // scope 3 at $DIR/issue_75439.rs:+4:27: +4:29\n-          goto -> bb4;                     // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n+          goto -> bb3;                     // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n       }\n   \n-      bb6: {\n+      bb5: {\n           StorageLive(_4);                 // scope 3 at $DIR/issue_75439.rs:+4:27: +4:29\n           _4 = _2[3 of 4];                 // scope 3 at $DIR/issue_75439.rs:+4:27: +4:29\n-          goto -> bb4;                     // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n+          goto -> bb3;                     // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n       }\n   \n-      bb7: {\n-          StorageDead(_6);                 // scope 4 at $DIR/issue_75439.rs:+5:35: +5:36\n-          _0 = Option::<[u8; 4]>::Some(move _5); // scope 3 at $DIR/issue_75439.rs:+5:9: +5:39\n-          StorageDead(_5);                 // scope 3 at $DIR/issue_75439.rs:+5:38: +5:39\n-          StorageDead(_4);                 // scope 1 at $DIR/issue_75439.rs:+6:5: +6:6\n-          goto -> bb9;                     // scope 1 at $DIR/issue_75439.rs:+4:5: +8:6\n-      }\n-  \n-      bb8: {\n+      bb6: {\n           _0 = Option::<[u8; 4]>::None;    // scope 1 at $DIR/issue_75439.rs:+7:9: +7:13\n-          goto -> bb9;                     // scope 1 at $DIR/issue_75439.rs:+4:5: +8:6\n+          goto -> bb7;                     // scope 1 at $DIR/issue_75439.rs:+4:5: +8:6\n       }\n   \n-      bb9: {\n+      bb7: {\n           StorageDead(_2);                 // scope 0 at $DIR/issue_75439.rs:+9:1: +9:2\n           return;                          // scope 0 at $DIR/issue_75439.rs:+9:2: +9:2\n       }"}, {"sha": "5c5a9e90a9da2eb9773dbcb4e10684165e46a3b8", "filename": "tests/mir-opt/lower_intrinsics.assume.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.assume.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.assume.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.assume.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -11,7 +11,7 @@\n           StorageLive(_1);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38\n -         _1 = std::intrinsics::assume(const true) -> bb1; // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:72:9: 72:32\n+-                                          // + span: $DIR/lower_intrinsics.rs:105:9: 105:32\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(bool) {std::intrinsics::assume}, val: Value(<ZST>) }\n +         assume(const true);              // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38\n +         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38"}, {"sha": "87960521bb454f56246a7262ef90a214509ff8fd", "filename": "tests/mir-opt/lower_intrinsics.discriminant.LowerIntrinsics.diff", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.discriminant.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.discriminant.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.discriminant.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -31,7 +31,7 @@\n           _3 = &(*_4);                     // scope 0 at $DIR/lower_intrinsics.rs:+1:42: +1:44\n -         _2 = discriminant_value::<T>(move _3) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:+1:5: +1:45\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:49:5: 49:41\n+-                                          // + span: $DIR/lower_intrinsics.rs:82:5: 82:41\n -                                          // + literal: Const { ty: for<'a> extern \"rust-intrinsic\" fn(&'a T) -> <T as DiscriminantKind>::Discriminant {discriminant_value::<T>}, val: Value(<ZST>) }\n +         _2 = discriminant((*_3));        // scope 0 at $DIR/lower_intrinsics.rs:+1:5: +1:45\n +         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:5: +1:45\n@@ -46,13 +46,13 @@\n           StorageLive(_7);                 // scope 0 at $DIR/lower_intrinsics.rs:+2:42: +2:44\n           _19 = const _;                   // scope 0 at $DIR/lower_intrinsics.rs:+2:42: +2:44\n                                            // mir::Constant\n-                                           // + span: $DIR/lower_intrinsics.rs:50:42: 50:44\n+                                           // + span: $DIR/lower_intrinsics.rs:83:42: 83:44\n                                            // + literal: Const { ty: &i32, val: Unevaluated(discriminant, [T], Some(promoted[2])) }\n           _7 = &(*_19);                    // scope 0 at $DIR/lower_intrinsics.rs:+2:42: +2:44\n           _6 = &(*_7);                     // scope 0 at $DIR/lower_intrinsics.rs:+2:42: +2:44\n -         _5 = discriminant_value::<i32>(move _6) -> bb2; // scope 0 at $DIR/lower_intrinsics.rs:+2:5: +2:45\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:50:5: 50:41\n+-                                          // + span: $DIR/lower_intrinsics.rs:83:5: 83:41\n -                                          // + literal: Const { ty: for<'a> extern \"rust-intrinsic\" fn(&'a i32) -> <i32 as DiscriminantKind>::Discriminant {discriminant_value::<i32>}, val: Value(<ZST>) }\n +         _5 = discriminant((*_6));        // scope 0 at $DIR/lower_intrinsics.rs:+2:5: +2:45\n +         goto -> bb2;                     // scope 0 at $DIR/lower_intrinsics.rs:+2:5: +2:45\n@@ -67,13 +67,13 @@\n           StorageLive(_11);                // scope 0 at $DIR/lower_intrinsics.rs:+3:42: +3:45\n           _18 = const _;                   // scope 0 at $DIR/lower_intrinsics.rs:+3:42: +3:45\n                                            // mir::Constant\n-                                           // + span: $DIR/lower_intrinsics.rs:51:42: 51:45\n+                                           // + span: $DIR/lower_intrinsics.rs:84:42: 84:45\n                                            // + literal: Const { ty: &(), val: Unevaluated(discriminant, [T], Some(promoted[1])) }\n           _11 = &(*_18);                   // scope 0 at $DIR/lower_intrinsics.rs:+3:42: +3:45\n           _10 = &(*_11);                   // scope 0 at $DIR/lower_intrinsics.rs:+3:42: +3:45\n -         _9 = discriminant_value::<()>(move _10) -> bb3; // scope 0 at $DIR/lower_intrinsics.rs:+3:5: +3:46\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:51:5: 51:41\n+-                                          // + span: $DIR/lower_intrinsics.rs:84:5: 84:41\n -                                          // + literal: Const { ty: for<'a> extern \"rust-intrinsic\" fn(&'a ()) -> <() as DiscriminantKind>::Discriminant {discriminant_value::<()>}, val: Value(<ZST>) }\n +         _9 = discriminant((*_10));       // scope 0 at $DIR/lower_intrinsics.rs:+3:5: +3:46\n +         goto -> bb3;                     // scope 0 at $DIR/lower_intrinsics.rs:+3:5: +3:46\n@@ -88,13 +88,13 @@\n           StorageLive(_15);                // scope 0 at $DIR/lower_intrinsics.rs:+4:42: +4:47\n           _17 = const _;                   // scope 0 at $DIR/lower_intrinsics.rs:+4:42: +4:47\n                                            // mir::Constant\n-                                           // + span: $DIR/lower_intrinsics.rs:52:42: 52:47\n+                                           // + span: $DIR/lower_intrinsics.rs:85:42: 85:47\n                                            // + literal: Const { ty: &E, val: Unevaluated(discriminant, [T], Some(promoted[0])) }\n           _15 = &(*_17);                   // scope 0 at $DIR/lower_intrinsics.rs:+4:42: +4:47\n           _14 = &(*_15);                   // scope 0 at $DIR/lower_intrinsics.rs:+4:42: +4:47\n -         _13 = discriminant_value::<E>(move _14) -> bb4; // scope 0 at $DIR/lower_intrinsics.rs:+4:5: +4:48\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:52:5: 52:41\n+-                                          // + span: $DIR/lower_intrinsics.rs:85:5: 85:41\n -                                          // + literal: Const { ty: for<'a> extern \"rust-intrinsic\" fn(&'a E) -> <E as DiscriminantKind>::Discriminant {discriminant_value::<E>}, val: Value(<ZST>) }\n +         _13 = discriminant((*_14));      // scope 0 at $DIR/lower_intrinsics.rs:+4:5: +4:48\n +         goto -> bb4;                     // scope 0 at $DIR/lower_intrinsics.rs:+4:5: +4:48"}, {"sha": "15cce7f4a2c010411eb97f92e5df9e69d8676fdd", "filename": "tests/mir-opt/lower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -49,7 +49,7 @@\n           StorageDead(_9);                 // scope 3 at $DIR/lower_intrinsics.rs:+4:90: +4:91\n -         _3 = copy_nonoverlapping::<i32>(move _4, move _8, const 0_usize) -> bb1; // scope 3 at $DIR/lower_intrinsics.rs:+4:9: +4:95\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:65:9: 65:28\n+-                                          // + span: $DIR/lower_intrinsics.rs:98:9: 98:28\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const i32, *mut i32, usize) {copy_nonoverlapping::<i32>}, val: Value(<ZST>) }\n +         copy_nonoverlapping(dst = move _8, src = move _4, count = const 0_usize); // scope 3 at $DIR/lower_intrinsics.rs:+4:9: +4:95\n +         goto -> bb1;                     // scope 3 at $DIR/lower_intrinsics.rs:+4:9: +4:95"}, {"sha": "c563703b250d4174f1b2f94281cf0da159ab88be", "filename": "tests/mir-opt/lower_intrinsics.option_payload.LowerIntrinsics.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -24,7 +24,7 @@\n           _4 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n -         _3 = option_payload_ptr::<usize>(move _4) -> bb1; // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:99:18: 99:54\n+-                                          // + span: $DIR/lower_intrinsics.rs:132:18: 132:54\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<usize>) -> *const usize {option_payload_ptr::<usize>}, val: Value(<ZST>) }\n +         _3 = &raw const (((*_4) as Some).0: usize); // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n +         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n@@ -37,7 +37,7 @@\n           _6 = &raw const (*_2);           // scope 2 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n -         _5 = option_payload_ptr::<String>(move _6) -> bb2; // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:100:18: 100:54\n+-                                          // + span: $DIR/lower_intrinsics.rs:133:18: 133:54\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<String>) -> *const String {option_payload_ptr::<String>}, val: Value(<ZST>) }\n +         _5 = &raw const (((*_6) as Some).0: std::string::String); // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n +         goto -> bb2;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57"}, {"sha": "f2f676843b2c8857ec82dd55649da376d8c28563", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -13,7 +13,7 @@\n           _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n -         _0 = read_via_copy::<i32>(move _2) -> bb1; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:85:14: 85:45\n+-                                          // + span: $DIR/lower_intrinsics.rs:118:14: 118:45\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const i32) -> i32 {read_via_copy::<i32>}, val: Value(<ZST>) }\n +         _0 = (*_2);                      // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n +         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48"}, {"sha": "3ad21283fa47e9b833a1d0f63f2cf9d4ea248cc1", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -13,7 +13,7 @@\n           _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n -         _0 = read_via_copy::<Never>(move _2); // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:90:14: 90:45\n+-                                          // + span: $DIR/lower_intrinsics.rs:123:14: 123:45\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Never) -> Never {read_via_copy::<Never>}, val: Value(<ZST>) }\n +         unreachable;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n       }"}, {"sha": "ec215c9a66461b5be927dd1dce10ce943aa8adeb", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -38,6 +38,39 @@ pub fn non_const<T>() -> usize {\n     size_of_t()\n }\n \n+// EMIT_MIR lower_intrinsics.transmute_inhabited.LowerIntrinsics.diff\n+pub fn transmute_inhabited(c: std::cmp::Ordering) -> i8 {\n+    unsafe { std::mem::transmute(c) }\n+}\n+\n+// EMIT_MIR lower_intrinsics.transmute_uninhabited.LowerIntrinsics.diff\n+pub unsafe fn transmute_uninhabited(u: ()) -> Never {\n+    unsafe { std::mem::transmute::<(), Never>(u) }\n+}\n+\n+// EMIT_MIR lower_intrinsics.transmute_ref_dst.LowerIntrinsics.diff\n+pub unsafe fn transmute_ref_dst<T: ?Sized>(u: &T) -> *const T {\n+    unsafe { std::mem::transmute(u) }\n+}\n+\n+// EMIT_MIR lower_intrinsics.transmute_to_ref_uninhabited.LowerIntrinsics.diff\n+pub unsafe fn transmute_to_ref_uninhabited() -> ! {\n+    let x: &Never = std::mem::transmute(1usize);\n+    match *x {}\n+}\n+\n+// EMIT_MIR lower_intrinsics.transmute_to_mut_uninhabited.LowerIntrinsics.diff\n+pub unsafe fn transmute_to_mut_uninhabited() -> ! {\n+    let x: &mut Never = std::mem::transmute(1usize);\n+    match *x {}\n+}\n+\n+// EMIT_MIR lower_intrinsics.transmute_to_box_uninhabited.LowerIntrinsics.diff\n+pub unsafe fn transmute_to_box_uninhabited() -> ! {\n+    let x: Box<Never> = std::mem::transmute(1usize);\n+    match *x {}\n+}\n+\n pub enum E {\n     A,\n     B,"}, {"sha": "814368ec021e7bad625587f716a4d6019a94d97b", "filename": "tests/mir-opt/lower_intrinsics.transmute_inhabited.LowerIntrinsics.diff", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_inhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_inhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.transmute_inhabited.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,27 @@\n+- // MIR for `transmute_inhabited` before LowerIntrinsics\n++ // MIR for `transmute_inhabited` after LowerIntrinsics\n+  \n+  fn transmute_inhabited(_1: std::cmp::Ordering) -> i8 {\n+      debug c => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:28: +0:29\n+      let mut _0: i8;                      // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:54: +0:56\n+      let mut _2: std::cmp::Ordering;      // in scope 0 at $DIR/lower_intrinsics.rs:+1:34: +1:35\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:34: +1:35\n+          _2 = _1;                         // scope 1 at $DIR/lower_intrinsics.rs:+1:34: +1:35\n+-         _0 = transmute::<std::cmp::Ordering, i8>(move _2) -> bb1; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:36\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:43:14: 43:33\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(std::cmp::Ordering) -> i8 {transmute::<std::cmp::Ordering, i8>}, val: Value(<ZST>) }\n++         _0 = move _2 as i8 (Transmute);  // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:36\n++         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:36\n+      }\n+  \n+      bb1: {\n+          StorageDead(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:35: +1:36\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "5440c7a4c8ec591056ab2f70f57b113ac09354d8", "filename": "tests/mir-opt/lower_intrinsics.transmute_ref_dst.LowerIntrinsics.diff", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_ref_dst.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_ref_dst.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.transmute_ref_dst.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,27 @@\n+- // MIR for `transmute_ref_dst` before LowerIntrinsics\n++ // MIR for `transmute_ref_dst` after LowerIntrinsics\n+  \n+  fn transmute_ref_dst(_1: &T) -> *const T {\n+      debug u => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:44: +0:45\n+      let mut _0: *const T;                // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:54: +0:62\n+      let mut _2: &T;                      // in scope 0 at $DIR/lower_intrinsics.rs:+1:34: +1:35\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:34: +1:35\n+          _2 = _1;                         // scope 1 at $DIR/lower_intrinsics.rs:+1:34: +1:35\n+-         _0 = transmute::<&T, *const T>(move _2) -> bb1; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:36\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:53:14: 53:33\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(&T) -> *const T {transmute::<&T, *const T>}, val: Value(<ZST>) }\n++         _0 = move _2 as *const T (Transmute); // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:36\n++         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:36\n+      }\n+  \n+      bb1: {\n+          StorageDead(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:35: +1:36\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "43ddccc1ef7db8bcb427a50521842820097b7fdc", "filename": "tests/mir-opt/lower_intrinsics.transmute_to_box_uninhabited.LowerIntrinsics.diff", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_to_box_uninhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_to_box_uninhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.transmute_to_box_uninhabited.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,29 @@\n+- // MIR for `transmute_to_box_uninhabited` before LowerIntrinsics\n++ // MIR for `transmute_to_box_uninhabited` after LowerIntrinsics\n+  \n+  fn transmute_to_box_uninhabited() -> ! {\n+      let mut _0: !;                       // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:49: +0:50\n+      let mut _1: !;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:51: +3:2\n+      let _2: std::boxed::Box<Never>;      // in scope 0 at $DIR/lower_intrinsics.rs:+1:9: +1:10\n+      let mut _3: !;                       // in scope 0 at $DIR/lower_intrinsics.rs:+2:5: +2:16\n+      scope 1 {\n+          debug x => _2;                   // in scope 1 at $DIR/lower_intrinsics.rs:+1:9: +1:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/lower_intrinsics.rs:+0:51: +3:2\n+          StorageLive(_2);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:9: +1:10\n+-         _2 = transmute::<usize, Box<Never>>(const 1_usize) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:+1:25: +1:52\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:70:25: 70:44\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(usize) -> Box<Never> {transmute::<usize, Box<Never>>}, val: Value(<ZST>) }\n++         _2 = const 1_usize as std::boxed::Box<Never> (Transmute); // scope 0 at $DIR/lower_intrinsics.rs:+1:25: +1:52\n++         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:25: +1:52\n+      }\n+  \n+      bb1: {\n+          StorageLive(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:5: +2:16\n+          unreachable;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:11: +2:13\n+      }\n+  }\n+  "}, {"sha": "bf529a9ca678829d33198159b7d78603fae59046", "filename": "tests/mir-opt/lower_intrinsics.transmute_to_mut_uninhabited.LowerIntrinsics.diff", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_to_mut_uninhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_to_mut_uninhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.transmute_to_mut_uninhabited.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,29 @@\n+- // MIR for `transmute_to_mut_uninhabited` before LowerIntrinsics\n++ // MIR for `transmute_to_mut_uninhabited` after LowerIntrinsics\n+  \n+  fn transmute_to_mut_uninhabited() -> ! {\n+      let mut _0: !;                       // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:49: +0:50\n+      let mut _1: !;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:51: +3:2\n+      let _2: &mut Never;                  // in scope 0 at $DIR/lower_intrinsics.rs:+1:9: +1:10\n+      let mut _3: !;                       // in scope 0 at $DIR/lower_intrinsics.rs:+2:5: +2:16\n+      scope 1 {\n+          debug x => _2;                   // in scope 1 at $DIR/lower_intrinsics.rs:+1:9: +1:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/lower_intrinsics.rs:+0:51: +3:2\n+          StorageLive(_2);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:9: +1:10\n+-         _2 = transmute::<usize, &mut Never>(const 1_usize) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:+1:25: +1:52\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:64:25: 64:44\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(usize) -> &mut Never {transmute::<usize, &mut Never>}, val: Value(<ZST>) }\n++         _2 = const 1_usize as &mut Never (Transmute); // scope 0 at $DIR/lower_intrinsics.rs:+1:25: +1:52\n++         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:25: +1:52\n+      }\n+  \n+      bb1: {\n+          StorageLive(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:5: +2:16\n+          unreachable;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:11: +2:13\n+      }\n+  }\n+  "}, {"sha": "4940a99021f40d9fe3e04bd2323b7708b51b1d31", "filename": "tests/mir-opt/lower_intrinsics.transmute_to_ref_uninhabited.LowerIntrinsics.diff", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_to_ref_uninhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_to_ref_uninhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.transmute_to_ref_uninhabited.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,29 @@\n+- // MIR for `transmute_to_ref_uninhabited` before LowerIntrinsics\n++ // MIR for `transmute_to_ref_uninhabited` after LowerIntrinsics\n+  \n+  fn transmute_to_ref_uninhabited() -> ! {\n+      let mut _0: !;                       // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:49: +0:50\n+      let mut _1: !;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:51: +3:2\n+      let _2: &Never;                      // in scope 0 at $DIR/lower_intrinsics.rs:+1:9: +1:10\n+      let mut _3: !;                       // in scope 0 at $DIR/lower_intrinsics.rs:+2:5: +2:16\n+      scope 1 {\n+          debug x => _2;                   // in scope 1 at $DIR/lower_intrinsics.rs:+1:9: +1:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/lower_intrinsics.rs:+0:51: +3:2\n+          StorageLive(_2);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:9: +1:10\n+-         _2 = transmute::<usize, &Never>(const 1_usize) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:+1:21: +1:48\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:58:21: 58:40\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(usize) -> &Never {transmute::<usize, &Never>}, val: Value(<ZST>) }\n++         _2 = const 1_usize as &Never (Transmute); // scope 0 at $DIR/lower_intrinsics.rs:+1:21: +1:48\n++         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:21: +1:48\n+      }\n+  \n+      bb1: {\n+          StorageLive(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:5: +2:16\n+          unreachable;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:11: +2:13\n+      }\n+  }\n+  "}, {"sha": "f3a12b9ba5f27b8315bd5731f97b123c77d72f4e", "filename": "tests/mir-opt/lower_intrinsics.transmute_uninhabited.LowerIntrinsics.diff", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_uninhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.transmute_uninhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.transmute_uninhabited.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,22 @@\n+- // MIR for `transmute_uninhabited` before LowerIntrinsics\n++ // MIR for `transmute_uninhabited` after LowerIntrinsics\n+  \n+  fn transmute_uninhabited(_1: ()) -> Never {\n+      debug u => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:37: +0:38\n+      let mut _0: Never;                   // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:47: +0:52\n+      let mut _2: ();                      // in scope 0 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+          _2 = _1;                         // scope 1 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+-         _0 = transmute::<(), Never>(move _2); // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:49\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:48:14: 48:46\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(()) -> Never {transmute::<(), Never>}, val: Value(<ZST>) }\n++         _0 = move _2 as Never (Transmute); // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:49\n++         unreachable;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:49\n+      }\n+  }\n+  "}, {"sha": "3b9a41249a4becd416eb94d2304c1fe9d0153b09", "filename": "tests/mir-opt/lower_intrinsics.with_overflow.LowerIntrinsics.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -32,7 +32,7 @@\n           _5 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:53: +1:54\n -         _3 = add_with_overflow::<i32>(move _4, move _5) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:78:14: 78:49\n+-                                          // + span: $DIR/lower_intrinsics.rs:111:14: 111:49\n -                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {add_with_overflow::<i32>}, val: Value(<ZST>) }\n +         _3 = CheckedAdd(move _4, move _5); // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n +         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n@@ -48,7 +48,7 @@\n           _8 = _2;                         // scope 1 at $DIR/lower_intrinsics.rs:+2:53: +2:54\n -         _6 = sub_with_overflow::<i32>(move _7, move _8) -> bb2; // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:79:14: 79:49\n+-                                          // + span: $DIR/lower_intrinsics.rs:112:14: 112:49\n -                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {sub_with_overflow::<i32>}, val: Value(<ZST>) }\n +         _6 = CheckedSub(move _7, move _8); // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n +         goto -> bb2;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n@@ -64,7 +64,7 @@\n           _11 = _2;                        // scope 2 at $DIR/lower_intrinsics.rs:+3:53: +3:54\n -         _9 = mul_with_overflow::<i32>(move _10, move _11) -> bb3; // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:80:14: 80:49\n+-                                          // + span: $DIR/lower_intrinsics.rs:113:14: 113:49\n -                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {mul_with_overflow::<i32>}, val: Value(<ZST>) }\n +         _9 = CheckedMul(move _10, move _11); // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n +         goto -> bb3;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55"}, {"sha": "c6b71f5fbd49fd7f87c2b2f8e8986e65ee2f4216", "filename": "tests/run-make/issue-36710/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fissue-36710%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fissue-36710%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-36710%2FMakefile?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -4,6 +4,7 @@\n # ignore-nvptx64-nvidia-cuda FIXME: can't find crate for `std`\n # ignore-musl FIXME: this makefile needs teaching how to use a musl toolchain\n #                    (see dist-i586-gnu-i586-i686-musl Dockerfile)\n+# ignore-sgx\n \n include ../../run-make-fulldeps/tools.mk\n "}, {"sha": "2a714f3a11fea1da4cd281568b24d7f565c507cd", "filename": "tests/run-make/raw-dylib-cross-compilation/Makefile", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fraw-dylib-cross-compilation%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fraw-dylib-cross-compilation%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fraw-dylib-cross-compilation%2FMakefile?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,22 @@\n+# Tests that raw-dylib cross compilation works correctly\n+\n+# only-gnu\n+# needs-i686-dlltool\n+# needs-x86_64-dlltool\n+\n+# i686 dlltool.exe can't product x64 binaries.\n+# ignore-i686-pc-windows-gnu\n+\n+include ../../run-make-fulldeps/tools.mk\n+\n+all:\n+\t# Build as x86 and make sure that we have x86 objects only.\n+\t$(RUSTC) --crate-type lib --crate-name i686_raw_dylib_test --target i686-pc-windows-gnu lib.rs\n+\t\"$(LLVM_BIN_DIR)\"/llvm-objdump -a $(TMPDIR)/libi686_raw_dylib_test.rlib > $(TMPDIR)/i686.objdump.txt\n+\t$(CGREP) \"file format coff-i386\" < $(TMPDIR)/i686.objdump.txt\n+\t$(CGREP) -v \"file format coff-x86-64\" < $(TMPDIR)/i686.objdump.txt\n+\t# Build as x64 and make sure that we have x64 objects only.\n+\t$(RUSTC) --crate-type lib --crate-name x64_raw_dylib_test --target x86_64-pc-windows-gnu lib.rs\n+\t\"$(LLVM_BIN_DIR)\"/llvm-objdump -a $(TMPDIR)/libx64_raw_dylib_test.rlib > $(TMPDIR)/x64.objdump.txt\n+\t$(CGREP) \"file format coff-x86-64\" < $(TMPDIR)/x64.objdump.txt\n+\t$(CGREP) -v \"file format coff-i386\" < $(TMPDIR)/x64.objdump.txt"}, {"sha": "51bf2ec6b6e11423c92edfd00606835fdcb96005", "filename": "tests/run-make/raw-dylib-cross-compilation/lib.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fraw-dylib-cross-compilation%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fraw-dylib-cross-compilation%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fraw-dylib-cross-compilation%2Flib.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,20 @@\n+#![feature(raw_dylib)]\n+#![feature(no_core, lang_items)]\n+#![no_std]\n+#![no_core]\n+#![crate_type = \"lib\"]\n+\n+// This is needed because of #![no_core]:\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+#[link(name = \"extern_1\", kind = \"raw-dylib\")]\n+extern {\n+    fn extern_fn();\n+}\n+\n+pub fn extern_fn_caller() {\n+    unsafe {\n+        extern_fn();\n+    }\n+}"}, {"sha": "af9bc8c1d62eeab231297d6e222b87c3ce9b9dfc", "filename": "tests/run-make/x86_64-fortanix-unknown-sgx-lvi/cc_plus_one_asm.checks", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fcc_plus_one_asm.checks", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fcc_plus_one_asm.checks", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fcc_plus_one_asm.checks?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,8 +1,7 @@\n CHECK: cc_plus_one_asm\n CHECK-NEXT: movl\n CHECK-NEXT: lfence\n-CHECK-NEXT: inc\n-CHECK-NEXT: notq (%rsp)\n-CHECK-NEXT: notq (%rsp)\n+CHECK-NEXT: incl\n+CHECK-NEXT: shlq $0, (%rsp)\n CHECK-NEXT: lfence\n CHECK-NEXT: retq"}, {"sha": "885bf461bf3d540ba25ab9f65ef8a0ecf81c39cf", "filename": "tests/run-make/x86_64-fortanix-unknown-sgx-lvi/jumpto.checks", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fjumpto.checks", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fjumpto.checks", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fjumpto.checks?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,8 +1,24 @@\n-CHECK: libunwind::Registers_x86_64::jumpto\n+CHECK: __libunwind_Registers_x86_64_jumpto\n CHECK:      lfence\n CHECK:      lfence\n CHECK:      lfence\n CHECK:      lfence\n-CHECK:      shlq    $0, (%rsp)\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK:      lfence\n+CHECK-NEXT: popq [[REGISTER:%[a-z]+]]\n+CHECK-NEXT: lfence\n+CHECK-NEXT: popq [[REGISTER:%[a-z]+]]\n CHECK-NEXT: lfence\n-CHECK-NEXT: retq\n+CHECK-NEXT: jmpq *[[REGISTER]]"}, {"sha": "8a5493650a72097abfdcc9337c5f70eb6fcf3a27", "filename": "tests/run-make/x86_64-fortanix-unknown-sgx-lvi/print.checks", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fprint.checks", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fprint.checks", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fprint.checks?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -2,6 +2,5 @@ CHECK: print\n CHECK:      lfence\n CHECK:      lfence\n CHECK:      lfence\n-CHECK:      popq\n CHECK:      callq 0x{{[[:xdigit:]]*}} <_Unwind_Resume>\n CHECK-NEXT: ud2"}, {"sha": "235bb603b842bd91b50b86d7fbaebe2f62c17959", "filename": "tests/run-make/x86_64-fortanix-unknown-sgx-lvi/script.sh", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fscript.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fscript.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fscript.sh?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -20,39 +20,38 @@ function build {\n }\n \n function check {\n-    local func=$1\n+    local func_re=\"$1\"\n     local checks=\"${TEST_DIR}/$2\"\n     local asm=$(mktemp)\n-    local objdump=\"${BUILD_DIR}/x86_64-unknown-linux-gnu/llvm/build/bin/llvm-objdump\"\n-    local filecheck=\"${BUILD_DIR}/x86_64-unknown-linux-gnu/llvm/build/bin/FileCheck\"\n-\n-    ${objdump} --disassemble-symbols=${func} --demangle \\\n-      ${WORK_DIR}/enclave/target/x86_64-fortanix-unknown-sgx/debug/enclave > ${asm}\n+    local objdump=\"${LLVM_BIN_DIR}/llvm-objdump\"\n+    local filecheck=\"${LLVM_BIN_DIR}/FileCheck\"\n+    local enclave=${WORK_DIR}/enclave/target/x86_64-fortanix-unknown-sgx/debug/enclave\n+\n+    func=\"$(${objdump} --syms --demangle ${enclave} | \\\n+            grep --only-matching -E \"[[:blank:]]+${func_re}\\$\" | \\\n+            sed -e 's/^[[:space:]]*//' )\"\n+    ${objdump} --disassemble-symbols=\"${func}\" --demangle \\\n+      ${enclave} > ${asm}\n     ${filecheck} --input-file ${asm} ${checks}\n }\n \n build\n \n-check unw_getcontext unw_getcontext.checks\n-check \"libunwind::Registers_x86_64::jumpto()\" jumpto.checks\n-check \"std::io::stdio::_print::h87f0c238421c45bc\" print.checks\n-check rust_plus_one_global_asm rust_plus_one_global_asm.checks \\\n-  || echo \"warning: module level assembly currently not hardened\"\n+check \"unw_getcontext\" unw_getcontext.checks\n+check \"__libunwind_Registers_x86_64_jumpto\" jumpto.checks\n+check 'std::io::stdio::_print::[[:alnum:]]+' print.checks\n+check rust_plus_one_global_asm rust_plus_one_global_asm.checks\n \n check cc_plus_one_c cc_plus_one_c.checks\n check cc_plus_one_c_asm cc_plus_one_c_asm.checks\n check cc_plus_one_cxx cc_plus_one_cxx.checks\n check cc_plus_one_cxx_asm cc_plus_one_cxx_asm.checks\n-check cc_plus_one_asm cc_plus_one_asm.checks \\\n-  || echo \"warning: the cc crate forwards assembly files to the CC compiler.\" \\\n-           \"Clang uses its own integrated assembler, which does not include the LVI passes.\"\n+check cc_plus_one_asm cc_plus_one_asm.checks\n \n check cmake_plus_one_c cmake_plus_one_c.checks\n check cmake_plus_one_c_asm cmake_plus_one_c_asm.checks\n-check cmake_plus_one_c_global_asm cmake_plus_one_c_global_asm.checks \\\n-  || echo \"warning: module level assembly currently not hardened\"\n+check cmake_plus_one_c_global_asm cmake_plus_one_c_global_asm.checks\n check cmake_plus_one_cxx cmake_plus_one_cxx.checks\n check cmake_plus_one_cxx_asm cmake_plus_one_cxx_asm.checks\n-check cmake_plus_one_cxx_global_asm cmake_plus_one_cxx_global_asm.checks \\\n-  || echo \"warning: module level assembly currently not hardened\"\n+check cmake_plus_one_cxx_global_asm cmake_plus_one_cxx_global_asm.checks\n check cmake_plus_one_asm cmake_plus_one_asm.checks"}, {"sha": "d1aa840ab08a27e98d0d582506f44b9f1637df65", "filename": "tests/rustdoc-js-std/parser-errors.js", "status": "modified", "additions": 13, "deletions": 45, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-errors.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-errors.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-errors.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -17,6 +17,7 @@ const QUERY = [\n     \"a b:\",\n     \"a (b:\",\n     \"_:\",\n+    \"_:a\",\n     \"a-bb\",\n     \"a>bb\",\n     \"ab'\",\n@@ -48,7 +49,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"<P>\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"<p>\",\n         error: \"Found generics without a path\",\n     },\n@@ -57,7 +57,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"-> <P>\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"-> <p>\",\n         error: \"Found generics without a path\",\n     },\n@@ -66,7 +65,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a<\\\"P\\\">\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a<\\\"p\\\">\",\n         error: \"Unexpected `\\\"` in generics\",\n     },\n@@ -75,7 +73,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"\\\"P\\\" \\\"P\\\"\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"\\\"p\\\" \\\"p\\\"\",\n         error: \"Cannot have more than one literal search element\",\n     },\n@@ -84,7 +81,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"P \\\"P\\\"\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"p \\\"p\\\"\",\n         error: \"Cannot use literal search when there is more than one element\",\n     },\n@@ -93,7 +89,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"\\\"p\\\" p\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"\\\"p\\\" p\",\n         error: \"You cannot have more than one element if you use quotes\",\n     },\n@@ -102,7 +97,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"\\\"const\\\": p\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"\\\"const\\\": p\",\n         error: \"You cannot use quotes on type filter\",\n     },\n@@ -111,16 +105,14 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a<:a>\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a<:a>\",\n-        error: \"Unexpected `:` after `<`\",\n+        error: \"Expected type filter before `:`\",\n     },\n     {\n         elems: [],\n         foundElems: 0,\n         original: \"a<::a>\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a<::a>\",\n         error: \"Unexpected `::`: paths cannot start with `::`\",\n     },\n@@ -129,7 +121,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"((a))\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"((a))\",\n         error: \"Unexpected `(`\",\n     },\n@@ -138,7 +129,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"(p -> p\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"(p -> p\",\n         error: \"Unexpected `(`\",\n     },\n@@ -147,7 +137,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"::a::b\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"::a::b\",\n         error: \"Paths cannot start with `::`\",\n     },\n@@ -156,7 +145,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a::::b\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a::::b\",\n         error: \"Unexpected `::::`\",\n     },\n@@ -165,7 +153,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a::b::\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a::b::\",\n         error: \"Paths cannot end with `::`\",\n     },\n@@ -174,7 +161,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \":a\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \":a\",\n         error: \"Expected type filter before `:`\",\n     },\n@@ -183,16 +169,14 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a b:\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a b:\",\n-        error: \"Unexpected `:`\",\n+        error: \"Unexpected `:` (expected path after type filter)\",\n     },\n     {\n         elems: [],\n         foundElems: 0,\n         original: \"a (b:\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a (b:\",\n         error: \"Unexpected `(`\",\n     },\n@@ -201,16 +185,22 @@ const PARSED = [\n         foundElems: 0,\n         original: \"_:\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"_:\",\n+        error: \"Unexpected `:` (expected path after type filter)\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"_:a\",\n+        returned: [],\n+        userQuery: \"_:a\",\n         error: \"Unknown type filter `_`\",\n     },\n     {\n         elems: [],\n         foundElems: 0,\n         original: \"a-bb\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a-bb\",\n         error: \"Unexpected `-` (did you mean `->`?)\",\n     },\n@@ -219,7 +209,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a>bb\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a>bb\",\n         error: \"Unexpected `>` (did you mean `->`?)\",\n     },\n@@ -228,7 +217,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"ab'\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"ab'\",\n         error: \"Unexpected `'`\",\n     },\n@@ -237,7 +225,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a->\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a->\",\n         error: \"Expected at least one item after `->`\",\n     },\n@@ -246,7 +233,6 @@ const PARSED = [\n         foundElems: 0,\n         original: '\"p\" <a>',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: '\"p\" <a>',\n         error: \"Found generics without a path\",\n     },\n@@ -255,7 +241,6 @@ const PARSED = [\n         foundElems: 0,\n         original: '\"p\" a<a>',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: '\"p\" a<a>',\n         error: \"You cannot have more than one element if you use quotes\",\n     },\n@@ -264,7 +249,6 @@ const PARSED = [\n         foundElems: 0,\n         original: 'a,<',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: 'a,<',\n         error: 'Found generics without a path',\n     },\n@@ -273,7 +257,6 @@ const PARSED = [\n         foundElems: 0,\n         original: 'aaaaa<>b',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: 'aaaaa<>b',\n         error: 'Expected `,`, ` `, `:` or `->`, found `b`',\n     },\n@@ -282,16 +265,14 @@ const PARSED = [\n         foundElems: 0,\n         original: 'fn:aaaaa<>b',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: 'fn:aaaaa<>b',\n-        error: 'Expected `,`, ` ` or `->`, found `b`',\n+        error: 'Expected `,`, ` `, `:` or `->`, found `b`',\n     },\n     {\n         elems: [],\n         foundElems: 0,\n         original: '->a<>b',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: '->a<>b',\n         error: 'Expected `,` or ` `, found `b`',\n     },\n@@ -300,7 +281,6 @@ const PARSED = [\n         foundElems: 0,\n         original: 'a<->',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: 'a<->',\n         error: 'Unexpected `-` after `<`',\n     },\n@@ -309,7 +289,6 @@ const PARSED = [\n         foundElems: 0,\n         original: 'a:: a',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: 'a:: a',\n         error: 'Paths cannot end with `::`',\n     },\n@@ -318,7 +297,6 @@ const PARSED = [\n         foundElems: 0,\n         original: 'a ::a',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: 'a ::a',\n         error: 'Paths cannot start with `::`',\n     },\n@@ -327,16 +305,14 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a<a>:\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a<a>:\",\n-        error: 'Unexpected `:`',\n+        error: 'Unexpected `<` in type filter',\n     },\n     {\n         elems: [],\n         foundElems: 0,\n         original: \"a<>:\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a<>:\",\n         error: 'Unexpected `<` in type filter',\n     },\n@@ -345,7 +321,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a,:\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a,:\",\n         error: 'Unexpected `,` in type filter',\n     },\n@@ -354,7 +329,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a<>  :\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a<>  :\",\n         error: 'Unexpected `<` in type filter',\n     },\n@@ -363,7 +337,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"mod : :\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"mod : :\",\n         error: 'Unexpected `:`',\n     },\n@@ -372,7 +345,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a!a\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a!a\",\n         error: 'Unexpected `!`: it can only be at the end of an ident',\n     },\n@@ -381,7 +353,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a!!\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a!!\",\n         error: 'Cannot have more than one `!` in an ident',\n     },\n@@ -390,7 +361,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"mod:a!\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"mod:a!\",\n         error: 'Invalid search type: macro `!` and `mod` both specified',\n     },\n@@ -399,7 +369,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a!::a\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a!::a\",\n         error: 'Cannot have associated items in macros',\n     },\n@@ -408,7 +377,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a<\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a<\",\n         error: \"Unclosed `<`\",\n     },"}, {"sha": "e23447ab75dc4006c1cfd4b6197036d905e793ce", "filename": "tests/rustdoc-js-std/parser-filter.js", "status": "modified", "additions": 88, "deletions": 8, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-filter.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-filter.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-filter.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,4 +1,14 @@\n-const QUERY = ['fn:foo', 'enum : foo', 'macro<f>:foo', 'macro!', 'macro:mac!', 'a::mac!'];\n+const QUERY = [\n+    'fn:foo',\n+    'enum : foo',\n+    'macro<f>:foo',\n+    'macro!',\n+    'macro:mac!',\n+    'a::mac!',\n+    '-> fn:foo',\n+    '-> fn:foo<fn:bar>',\n+    '-> fn:foo<fn:bar, enum : baz::fuzz>',\n+];\n \n const PARSED = [\n     {\n@@ -8,11 +18,11 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"foo\",\n             generics: [],\n+            typeFilter: 5,\n         }],\n         foundElems: 1,\n         original: \"fn:foo\",\n         returned: [],\n-        typeFilter: 5,\n         userQuery: \"fn:foo\",\n         error: null,\n     },\n@@ -23,11 +33,11 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"foo\",\n             generics: [],\n+            typeFilter: 4,\n         }],\n         foundElems: 1,\n         original: \"enum : foo\",\n         returned: [],\n-        typeFilter: 4,\n         userQuery: \"enum : foo\",\n         error: null,\n     },\n@@ -36,9 +46,8 @@ const PARSED = [\n         foundElems: 0,\n         original: \"macro<f>:foo\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"macro<f>:foo\",\n-        error: \"Unexpected `:`\",\n+        error: \"Unexpected `<` in type filter\",\n     },\n     {\n         elems: [{\n@@ -47,11 +56,11 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"macro\",\n             generics: [],\n+            typeFilter: 14,\n         }],\n         foundElems: 1,\n         original: \"macro!\",\n         returned: [],\n-        typeFilter: 14,\n         userQuery: \"macro!\",\n         error: null,\n     },\n@@ -62,11 +71,11 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"mac\",\n             generics: [],\n+            typeFilter: 14,\n         }],\n         foundElems: 1,\n         original: \"macro:mac!\",\n         returned: [],\n-        typeFilter: 14,\n         userQuery: \"macro:mac!\",\n         error: null,\n     },\n@@ -77,12 +86,83 @@ const PARSED = [\n             pathWithoutLast: [\"a\"],\n             pathLast: \"mac\",\n             generics: [],\n+            typeFilter: 14,\n         }],\n         foundElems: 1,\n         original: \"a::mac!\",\n         returned: [],\n-        typeFilter: 14,\n         userQuery: \"a::mac!\",\n         error: null,\n     },\n+    {\n+        elems: [],\n+        foundElems: 1,\n+        original: \"-> fn:foo\",\n+        returned: [{\n+            name: \"foo\",\n+            fullPath: [\"foo\"],\n+            pathWithoutLast: [],\n+            pathLast: \"foo\",\n+            generics: [],\n+            typeFilter: 5,\n+        }],\n+        userQuery: \"-> fn:foo\",\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 1,\n+        original: \"-> fn:foo<fn:bar>\",\n+        returned: [{\n+            name: \"foo\",\n+            fullPath: [\"foo\"],\n+            pathWithoutLast: [],\n+            pathLast: \"foo\",\n+            generics: [\n+                {\n+                    name: \"bar\",\n+                    fullPath: [\"bar\"],\n+                    pathWithoutLast: [],\n+                    pathLast: \"bar\",\n+                    generics: [],\n+                    typeFilter: 5,\n+                }\n+            ],\n+            typeFilter: 5,\n+        }],\n+        userQuery: \"-> fn:foo<fn:bar>\",\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 1,\n+        original: \"-> fn:foo<fn:bar, enum : baz::fuzz>\",\n+        returned: [{\n+            name: \"foo\",\n+            fullPath: [\"foo\"],\n+            pathWithoutLast: [],\n+            pathLast: \"foo\",\n+            generics: [\n+                {\n+                    name: \"bar\",\n+                    fullPath: [\"bar\"],\n+                    pathWithoutLast: [],\n+                    pathLast: \"bar\",\n+                    generics: [],\n+                    typeFilter: 5,\n+                },\n+                {\n+                    name: \"baz::fuzz\",\n+                    fullPath: [\"baz\", \"fuzz\"],\n+                    pathWithoutLast: [\"baz\"],\n+                    pathLast: \"fuzz\",\n+                    generics: [],\n+                    typeFilter: 4,\n+                },\n+            ],\n+            typeFilter: 5,\n+        }],\n+        userQuery: \"-> fn:foo<fn:bar, enum : baz::fuzz>\",\n+        error: null,\n+    },\n ];"}, {"sha": "c448d845acbdc1b9329bb05f70c9d375e18c7343", "filename": "tests/rustdoc-js-std/parser-generics.js", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-generics.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-generics.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-generics.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -6,7 +6,6 @@ const PARSED = [\n         foundElems: 0,\n         original: 'A<B<C<D>,  E>',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: 'a<b<c<d>,  e>',\n         error: 'Unexpected `<` after `<`',\n     },\n@@ -18,19 +17,20 @@ const PARSED = [\n                 pathWithoutLast: [],\n                 pathLast: \"p\",\n                 generics: [],\n+                typeFilter: -1,\n             },\n             {\n                 name: \"u8\",\n                 fullPath: [\"u8\"],\n                 pathWithoutLast: [],\n                 pathLast: \"u8\",\n                 generics: [],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 2,\n         original: \"p<> u8\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"p<> u8\",\n         error: null,\n     },\n@@ -50,12 +50,12 @@ const PARSED = [\n                         generics: [],\n                     },\n                 ],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 1,\n         original: '\"p\"<a>',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: '\"p\"<a>',\n         error: null,\n     },"}, {"sha": "be42b7aa4630714fc82344fd244cc7e13d73795f", "filename": "tests/rustdoc-js-std/parser-ident.js", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-ident.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-ident.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-ident.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -23,11 +23,11 @@ const PARSED = [\n                     generics: [],\n                 },\n             ],\n+            typeFilter: -1,\n         }],\n         foundElems: 1,\n         original: \"R<!>\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"r<!>\",\n         error: null,\n     },\n@@ -38,11 +38,11 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"!\",\n             generics: [],\n+            typeFilter: -1,\n         }],\n         foundElems: 1,\n         original: \"!\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"!\",\n         error: null,\n     },\n@@ -53,11 +53,11 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"a\",\n             generics: [],\n+            typeFilter: 14,\n         }],\n         foundElems: 1,\n         original: \"a!\",\n         returned: [],\n-        typeFilter: 14,\n         userQuery: \"a!\",\n         error: null,\n     },\n@@ -66,7 +66,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a!::b\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a!::b\",\n         error: \"Cannot have associated items in macros\",\n     },\n@@ -77,11 +76,11 @@ const PARSED = [\n             pathWithoutLast: [\"!\"],\n             pathLast: \"b\",\n             generics: [],\n+            typeFilter: -1,\n         }],\n         foundElems: 1,\n         original: \"!::b\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"!::b\",\n         error: null,\n     },\n@@ -90,7 +89,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a!::b!\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a!::b!\",\n         error: \"Cannot have associated items in macros\",\n     },"}, {"sha": "3a31d1bddfff5e3cc8ca2d056408b91ba93a6735", "filename": "tests/rustdoc-js-std/parser-literal.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-literal.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-literal.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-literal.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -16,11 +16,11 @@ const PARSED = [\n                     generics: [],\n                 },\n             ],\n+            typeFilter: -1,\n         }],\n         foundElems: 1,\n         original: \"R<P>\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"r<p>\",\n         error: null,\n     }"}, {"sha": "f3e421f5ffa50a3d6601814561d1106a34ca97cd", "filename": "tests/rustdoc-js-std/parser-paths.js", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-paths.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-paths.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-paths.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -8,11 +8,11 @@ const PARSED = [\n             pathWithoutLast: [\"a\"],\n             pathLast: \"b\",\n             generics: [],\n+            typeFilter: -1,\n         }],\n         foundElems: 1,\n         original: \"A::B\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a::b\",\n         error: null,\n     },\n@@ -24,19 +24,20 @@ const PARSED = [\n                 pathWithoutLast: [\"a\"],\n                 pathLast: \"b\",\n                 generics: [],\n+                typeFilter: -1,\n             },\n             {\n                 name: \"c\",\n                 fullPath: [\"c\"],\n                 pathWithoutLast: [],\n                 pathLast: \"c\",\n                 generics: [],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 2,\n         original: 'A::B,C',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: 'a::b,c',\n         error: null,\n     },\n@@ -56,19 +57,20 @@ const PARSED = [\n                         generics: [],\n                     },\n                 ],\n+                typeFilter: -1,\n             },\n             {\n                 name: \"c\",\n                 fullPath: [\"c\"],\n                 pathWithoutLast: [],\n                 pathLast: \"c\",\n                 generics: [],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 2,\n         original: 'A::B<f>,C',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: 'a::b<f>,c',\n         error: null,\n     },\n@@ -79,11 +81,11 @@ const PARSED = [\n             pathWithoutLast: [\"mod\"],\n             pathLast: \"a\",\n             generics: [],\n+            typeFilter: -1,\n         }],\n         foundElems: 1,\n         original: \"mod::a\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"mod::a\",\n         error: null,\n     },"}, {"sha": "d5d67cac892f595fcd8a66c3cacfdcc7d09c514b", "filename": "tests/rustdoc-js-std/parser-quote.js", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-quote.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-quote.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-quote.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -19,8 +19,8 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"p\",\n             generics: [],\n+            typeFilter: -1,\n         }],\n-        typeFilter: -1,\n         userQuery: '-> \"p\"',\n         error: null,\n     },\n@@ -31,11 +31,11 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"p\",\n             generics: [],\n+            typeFilter: -1,\n         }],\n         foundElems: 1,\n         original: '\"p\",',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: '\"p\",',\n         error: null,\n     },\n@@ -44,7 +44,6 @@ const PARSED = [\n         foundElems: 0,\n         original: '\"p\" -> a',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: '\"p\" -> a',\n         error: \"You cannot have more than one element if you use quotes\",\n     },\n@@ -53,7 +52,6 @@ const PARSED = [\n         foundElems: 0,\n         original: '\"a\" -> \"p\"',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: '\"a\" -> \"p\"',\n         error: \"Cannot have more than one literal search element\",\n     },\n@@ -62,7 +60,6 @@ const PARSED = [\n         foundElems: 0,\n         original: '->\"-\"',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: '->\"-\"',\n         error: 'Unexpected `-` in a string element',\n     },\n@@ -71,7 +68,6 @@ const PARSED = [\n         foundElems: 0,\n         original: '\"a',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: '\"a',\n         error: 'Unclosed `\"`',\n     },\n@@ -80,7 +76,6 @@ const PARSED = [\n         foundElems: 0,\n         original: '\"\"',\n         returned: [],\n-        typeFilter: -1,\n         userQuery: '\"\"',\n         error: 'Cannot have empty string element',\n     },"}, {"sha": "c2981319055db02a8c10f2017ab1a38a8cefa4e1", "filename": "tests/rustdoc-js-std/parser-returned.js", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-returned.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-returned.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-returned.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -25,8 +25,8 @@ const PARSED = [\n                     generics: [],\n                 },\n             ],\n+            typeFilter: -1,\n         }],\n-        typeFilter: -1,\n         userQuery: \"-> f<p>\",\n         error: null,\n     },\n@@ -40,8 +40,8 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"p\",\n             generics: [],\n+            typeFilter: -1,\n         }],\n-        typeFilter: -1,\n         userQuery: \"-> p\",\n         error: null,\n     },\n@@ -55,8 +55,8 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"a\",\n             generics: [],\n+            typeFilter: -1,\n         }],\n-        typeFilter: -1,\n         userQuery: \"->,a\",\n         error: null,\n     },\n@@ -67,6 +67,7 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"aaaaa\",\n             generics: [],\n+            typeFilter: -1,\n         }],\n         foundElems: 2,\n         original: \"aaaaa->a\",\n@@ -76,8 +77,8 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"a\",\n             generics: [],\n+            typeFilter: -1,\n         }],\n-        typeFilter: -1,\n         userQuery: \"aaaaa->a\",\n         error: null,\n     },\n@@ -91,8 +92,8 @@ const PARSED = [\n             pathWithoutLast: [],\n             pathLast: \"!\",\n             generics: [],\n+            typeFilter: -1,\n         }],\n-        typeFilter: -1,\n         userQuery: \"-> !\",\n         error: null,\n     },"}, {"sha": "fc8c5114c4e963ab3657d007065a5608cf75377d", "filename": "tests/rustdoc-js-std/parser-separators.js", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-separators.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-separators.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-separators.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -19,19 +19,20 @@ const PARSED = [\n                 pathWithoutLast: [],\n                 pathLast: 'aaaaaa',\n                 generics: [],\n+                typeFilter: -1,\n             },\n             {\n                 name: 'b',\n                 fullPath: ['b'],\n                 pathWithoutLast: [],\n                 pathLast: 'b',\n                 generics: [],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 2,\n         original: \"aaaaaa\tb\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"aaaaaa\tb\",\n         error: null,\n     },\n@@ -43,19 +44,20 @@ const PARSED = [\n                 pathWithoutLast: [],\n                 pathLast: 'a',\n                 generics: [],\n+                typeFilter: -1,\n             },\n             {\n                 name: 'b',\n                 fullPath: ['b'],\n                 pathWithoutLast: [],\n                 pathLast: 'b',\n                 generics: [],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 2,\n         original: \"a b\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a b\",\n         error: null,\n     },\n@@ -67,19 +69,20 @@ const PARSED = [\n                 pathWithoutLast: [],\n                 pathLast: 'a',\n                 generics: [],\n+                typeFilter: -1,\n             },\n             {\n                 name: 'b',\n                 fullPath: ['b'],\n                 pathWithoutLast: [],\n                 pathLast: 'b',\n                 generics: [],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 2,\n         original: \"a,b\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a,b\",\n         error: null,\n     },\n@@ -91,19 +94,20 @@ const PARSED = [\n                 pathWithoutLast: [],\n                 pathLast: 'a',\n                 generics: [],\n+                typeFilter: -1,\n             },\n             {\n                 name: 'b',\n                 fullPath: ['b'],\n                 pathWithoutLast: [],\n                 pathLast: 'b',\n                 generics: [],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 2,\n         original: \"a\\tb\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a\\tb\",\n         error: null,\n     },\n@@ -130,12 +134,12 @@ const PARSED = [\n                         generics: [],\n                     },\n                 ],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 1,\n         original: \"a<b c>\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a<b c>\",\n         error: null,\n     },\n@@ -162,12 +166,12 @@ const PARSED = [\n                         generics: [],\n                     },\n                 ],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 1,\n         original: \"a<b,c>\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a<b,c>\",\n         error: null,\n     },\n@@ -194,12 +198,12 @@ const PARSED = [\n                         generics: [],\n                     },\n                 ],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 1,\n         original: \"a<b\\tc>\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a<b\\tc>\",\n         error: null,\n     },"}, {"sha": "dc1049a70bc3882b20a89356f75d0489cc3bc98b", "filename": "tests/rustdoc-js-std/parser-weird-queries.js", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-weird-queries.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js-std%2Fparser-weird-queries.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-weird-queries.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -20,19 +20,20 @@ const PARSED = [\n                 pathWithoutLast: [],\n                 pathLast: \"a\",\n                 generics: [],\n+                typeFilter: -1,\n             },\n             {\n                 name: \"b\",\n                 fullPath: [\"b\"],\n                 pathWithoutLast: [],\n                 pathLast: \"b\",\n                 generics: [],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 2,\n         original: \"a b\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a b\",\n         error: null,\n     },\n@@ -44,19 +45,20 @@ const PARSED = [\n                 pathWithoutLast: [],\n                 pathLast: \"a\",\n                 generics: [],\n+                typeFilter: -1,\n             },\n             {\n                 name: \"b\",\n                 fullPath: [\"b\"],\n                 pathWithoutLast: [],\n                 pathLast: \"b\",\n                 generics: [],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 2,\n         original: \"a   b\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a   b\",\n         error: null,\n     },\n@@ -65,7 +67,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \"a,b(c)\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"a,b(c)\",\n         error: \"Unexpected `(`\",\n     },\n@@ -77,19 +78,20 @@ const PARSED = [\n                 pathWithoutLast: [],\n                 pathLast: \"aaa\",\n                 generics: [],\n+                typeFilter: -1,\n             },\n             {\n                 name: \"a\",\n                 fullPath: [\"a\"],\n                 pathWithoutLast: [],\n                 pathLast: \"a\",\n                 generics: [],\n+                typeFilter: -1,\n             },\n         ],\n         foundElems: 2,\n         original: \"aaa,a\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \"aaa,a\",\n         error: null,\n     },\n@@ -98,7 +100,6 @@ const PARSED = [\n         foundElems: 0,\n         original: \",,,,\",\n         returned: [],\n-        typeFilter: -1,\n         userQuery: \",,,,\",\n         error: null,\n     },\n@@ -107,17 +108,15 @@ const PARSED = [\n         foundElems: 0,\n         original: 'mod    :',\n         returned: [],\n-        typeFilter: 0,\n         userQuery: 'mod    :',\n-        error: null,\n+        error: \"Unexpected `:` (expected path after type filter)\",\n     },\n     {\n         elems: [],\n         foundElems: 0,\n         original: 'mod\\t:',\n         returned: [],\n-        typeFilter: 0,\n         userQuery: 'mod\\t:',\n-        error: null,\n+        error: \"Unexpected `:` (expected path after type filter)\",\n     },\n ];"}, {"sha": "5051743bda2d1bada1ad1c593487ffa247ae7667", "filename": "tests/rustdoc-js/generics-impl.js", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js%2Fgenerics-impl.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js%2Fgenerics-impl.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fgenerics-impl.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -5,6 +5,8 @@ const QUERY = [\n     'Aaaaaaa -> bool',\n     'Aaaaaaa -> usize',\n     'Read -> u64',\n+    'trait:Read -> u64',\n+    'struct:Read -> u64',\n     'bool -> u64',\n     'Ddddddd -> u64',\n     '-> Ddddddd'\n@@ -36,6 +38,17 @@ const EXPECTED = [\n             { 'path': 'generics_impl::Ddddddd', 'name': 'ggggggg' },\n         ],\n     },\n+    {\n+        // trait:Read -> u64\n+        'others': [\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'eeeeeee' },\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'ggggggg' },\n+        ],\n+    },\n+    {\n+        // struct:Read -> u64\n+        'others': [],\n+    },\n     {\n         // bool -> u64\n         'others': ["}, {"sha": "f79c709ad6cf0abb1b811afcdf311424743569f1", "filename": "tests/rustdoc-js/generics.js", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js%2Fgenerics.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js%2Fgenerics.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fgenerics.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -2,6 +2,8 @@\n \n const QUERY = [\n     'R<P>',\n+    'R<struct:P>',\n+    'R<enum:P>',\n     '\"P\"',\n     'P',\n     'ExtraCreditStructMulti<ExtraCreditInnerMulti, ExtraCreditInnerMulti>',\n@@ -20,6 +22,20 @@ const EXPECTED = [\n             { 'path': 'generics', 'name': 'alpha' },\n         ],\n     },\n+    {\n+        // R<struct:P>\n+        'returned': [\n+            { 'path': 'generics', 'name': 'alef' },\n+        ],\n+        'in_args': [\n+            { 'path': 'generics', 'name': 'alpha' },\n+        ],\n+    },\n+    {\n+        // R<enum:P>\n+        'returned': [],\n+        'in_args': [],\n+    },\n     {\n         // \"P\"\n         'others': ["}, {"sha": "4aec98c34037962586af3848bbaa3ab583629d59", "filename": "tests/rustdoc-js/primitive.js", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js%2Fprimitive.js", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-js%2Fprimitive.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fprimitive.js?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -3,6 +3,8 @@\n const QUERY = [\n     \"i32\",\n     \"str\",\n+    \"primitive:str\",\n+    \"struct:str\",\n     \"TotoIsSomewhere\",\n ];\n \n@@ -17,6 +19,14 @@ const EXPECTED = [\n             { 'path': 'primitive', 'name': 'foo' },\n         ],\n     },\n+    {\n+        'returned': [\n+            { 'path': 'primitive', 'name': 'foo' },\n+        ],\n+    },\n+    {\n+        'returned': [],\n+    },\n     {\n         'others': [],\n         'in_args': [],"}, {"sha": "72f5f933d8db4ad7c1f48f1c360b0d0cafb4916a", "filename": "tests/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fz-help.stdout?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -183,6 +183,7 @@\n     -Z                               threads=val -- use a thread pool with N threads\n     -Z                      time-llvm-passes=val -- measure time of each LLVM pass (default: no)\n     -Z                           time-passes=val -- measure time of each rustc pass (default: no)\n+    -Z                    time-passes-format=val -- the format to use for -Z time-passes (`text` (default) or `json`)\n     -Z                 tiny-const-eval-limit=val -- sets a tiny, non-configurable limit for const eval; useful for compiler tests\n     -Z                             tls-model=val -- choose the TLS model to use (`rustc --print tls-models` for details)\n     -Z                          trace-macros=val -- for every macro invocation, print its name and arguments (default: no)"}, {"sha": "3c011d72b02c510f7dfb4b5946c88b1b4b1742b6", "filename": "tests/ui/cfg/auxiliary/cfg_false_lib.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fcfg%2Fauxiliary%2Fcfg_false_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fcfg%2Fauxiliary%2Fcfg_false_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fauxiliary%2Fcfg_false_lib.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,6 @@\n+// It is unclear whether a fully unconfigured crate should link to standard library,\n+// or what its `no_std`/`no_core`/`compiler_builtins` status, more precisely.\n+// Currently the usual standard library prelude is added to such crates,\n+// and therefore they link to libstd.\n+\n+#![cfg(FALSE)]"}, {"sha": "21ea3ec79b4d61b92df102a11904e05389e1d6fe", "filename": "tests/ui/cfg/cfg-false-feature.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fcfg%2Fcfg-false-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fcfg%2Fcfg-false-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fcfg-false-feature.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,20 @@\n+// It is unclear which features should be in effect in a fully unconfigured crate (issue #104633).\n+// Currently none on the features are in effect, so we get the feature gates reported.\n+\n+// check-pass\n+// compile-flags: --crate-type lib\n+\n+#![feature(decl_macro)]\n+#![cfg(FALSE)]\n+#![feature(box_syntax)]\n+\n+macro mac() {} //~ WARN `macro` is experimental\n+               //~| WARN unstable syntax can change at any point in the future\n+\n+trait A = Clone; //~ WARN trait aliases are experimental\n+                 //~| WARN unstable syntax can change at any point in the future\n+\n+fn main() {\n+    let box _ = Box::new(0); //~ WARN box pattern syntax is experimental\n+                             //~| WARN unstable syntax can change at any point in the future\n+}"}, {"sha": "14673fbdb14447e437eda43707ee9671bc222445", "filename": "tests/ui/cfg/cfg-false-feature.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fcfg%2Fcfg-false-feature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fcfg%2Fcfg-false-feature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fcfg-false-feature.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,35 @@\n+warning: trait aliases are experimental\n+  --> $DIR/cfg-false-feature.rs:14:1\n+   |\n+LL | trait A = Clone;\n+   | ^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #41517 <https://github.com/rust-lang/rust/issues/41517> for more information\n+   = help: add `#![feature(trait_alias)]` to the crate attributes to enable\n+   = warning: unstable syntax can change at any point in the future, causing a hard error!\n+   = note: for more information, see issue #65860 <https://github.com/rust-lang/rust/issues/65860>\n+\n+warning: `macro` is experimental\n+  --> $DIR/cfg-false-feature.rs:11:1\n+   |\n+LL | macro mac() {}\n+   | ^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #39412 <https://github.com/rust-lang/rust/issues/39412> for more information\n+   = help: add `#![feature(decl_macro)]` to the crate attributes to enable\n+   = warning: unstable syntax can change at any point in the future, causing a hard error!\n+   = note: for more information, see issue #65860 <https://github.com/rust-lang/rust/issues/65860>\n+\n+warning: box pattern syntax is experimental\n+  --> $DIR/cfg-false-feature.rs:18:9\n+   |\n+LL |     let box _ = Box::new(0);\n+   |         ^^^^^\n+   |\n+   = note: see issue #29641 <https://github.com/rust-lang/rust/issues/29641> for more information\n+   = help: add `#![feature(box_patterns)]` to the crate attributes to enable\n+   = warning: unstable syntax can change at any point in the future, causing a hard error!\n+   = note: for more information, see issue #65860 <https://github.com/rust-lang/rust/issues/65860>\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "319ea078187c2d7bf8416ac152c1cb6d6fb24708", "filename": "tests/ui/cfg/cfg_false_no_std.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fcfg%2Fcfg_false_no_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fcfg%2Fcfg_false_no_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fcfg_false_no_std.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,11 @@\n+// Currently no error because the panic handler is supplied by libstd linked though the empty\n+// library, but the desirable behavior is unclear (see comments in cfg_false_lib.rs).\n+\n+// check-pass\n+// aux-build: cfg_false_lib.rs\n+\n+#![no_std]\n+\n+extern crate cfg_false_lib as _;\n+\n+fn main() {}"}, {"sha": "6b3396a25cf97d6ce679d99b110aa8e0a6bdd974", "filename": "tests/ui/const-generics/generic_const_exprs/cross_crate_predicate.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fcross_crate_predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fcross_crate_predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fcross_crate_predicate.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,8 +1,8 @@\n error: unconstrained generic constant\n-  --> $DIR/cross_crate_predicate.rs:7:13\n+  --> $DIR/cross_crate_predicate.rs:7:44\n    |\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                            ^\n    |\n    = help: try adding a `where` bound using this expression: `where [(); std::mem::size_of::<T>() - 1]:`\n note: required by a bound in `test1`\n@@ -12,10 +12,10 @@ LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `test1`\n \n error: unconstrained generic constant\n-  --> $DIR/cross_crate_predicate.rs:7:13\n+  --> $DIR/cross_crate_predicate.rs:7:44\n    |\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                            ^\n    |\n    = help: try adding a `where` bound using this expression: `where [(); std::mem::size_of::<T>() - 1]:`\n note: required by a bound in `test1`"}, {"sha": "64317b9d39aae4d99ea034982337a7821b3a61f4", "filename": "tests/ui/const-generics/generic_const_exprs/typeid-equality-by-subtyping.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,52 @@\n+// check-pass\n+// known-bug: #97156\n+\n+#![feature(const_type_id, generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+use std::any::TypeId;\n+// `One` and `Two` are currently considered equal types, as both\n+// `One <: Two` and `One :> Two` holds.\n+type One = for<'a> fn(&'a (), &'a ());\n+type Two = for<'a, 'b> fn(&'a (), &'b ());\n+trait AssocCt {\n+    const ASSOC: usize;\n+}\n+const fn to_usize<T: 'static>() -> usize {\n+    const WHAT_A_TYPE: TypeId = TypeId::of::<One>();\n+    match TypeId::of::<T>() {\n+        WHAT_A_TYPE => 0,\n+        _ => 1000,\n+    } \n+}\n+impl<T: 'static> AssocCt for T {\n+    const ASSOC: usize = to_usize::<T>();\n+}\n+\n+trait WithAssoc<U> {\n+    type Assoc;\n+}\n+impl<T: 'static> WithAssoc<()> for T where [(); <T as AssocCt>::ASSOC]: {\n+    type Assoc = [u8; <T as AssocCt>::ASSOC];\n+}\n+\n+fn generic<T: 'static, U>(x: <T as WithAssoc<U>>::Assoc) -> <T as WithAssoc<U>>::Assoc\n+where\n+    [(); <T as AssocCt>::ASSOC]:,\n+    T: WithAssoc<U>,\n+{\n+    x\n+}\n+\n+\n+fn unsound<T>(x: <One as WithAssoc<T>>::Assoc) -> <Two as WithAssoc<T>>::Assoc\n+where\n+    One: WithAssoc<T>,\n+{\n+    let x: <Two as WithAssoc<T>>::Assoc = generic::<One, T>(x);\n+    x\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", unsound::<()>([]));\n+}"}, {"sha": "394dd44d40d3308536ae1da482aa767dad78fce7", "filename": "tests/ui/const-generics/type_mismatch.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconst-generics%2Ftype_mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconst-generics%2Ftype_mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftype_mismatch.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,8 +1,8 @@\n error: the constant `N` is not of type `u8`\n-  --> $DIR/type_mismatch.rs:2:5\n+  --> $DIR/type_mismatch.rs:2:11\n    |\n LL |     bar::<N>()\n-   |     ^^^^^^^^\n+   |           ^ expected `u8`, found `usize`\n    |\n note: required by a bound in `bar`\n   --> $DIR/type_mismatch.rs:6:8"}, {"sha": "1abe708d19eb29b9584a5598b78679895d5ed85f", "filename": "tests/ui/consts/const-eval/panic-assoc-never-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -11,5 +11,5 @@ impl PrintName {\n }\n \n fn main() {\n-    let _ = PrintName::VOID; //~ constant\n+    let _ = PrintName::VOID; //~ erroneous constant used\n }"}, {"sha": "2410baea28c3adf6606454f7dc08c499b267592a", "filename": "tests/ui/consts/const-eval/transmute-size-mismatch.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-size-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-size-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-size-mismatch.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,24 @@\n+#![feature(core_intrinsics)]\n+#![feature(custom_mir)]\n+\n+// These cases are statically rejected by `mem::transmute`, so we need custom\n+// MIR to be able to get to constant evaluation.\n+use std::intrinsics::mir::*;\n+\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+const unsafe fn mir_transmute<T, U>(x: T) -> U {\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            //~^ ERROR evaluation of constant value failed\n+            //~| ERROR evaluation of constant value failed\n+            Return()\n+        }\n+    }\n+}\n+\n+const FROM_BIGGER: u16 = unsafe { mir_transmute(123_i32) };\n+\n+const FROM_SMALLER: u32 = unsafe { mir_transmute(123_i16) };\n+\n+fn main() {}"}, {"sha": "e051491d3430f3bb9cb0b5655812bf860a2de603", "filename": "tests/ui/consts/const-eval/transmute-size-mismatch.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-size-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-size-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-size-mismatch.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,37 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/transmute-size-mismatch.rs:12:13\n+   |\n+LL |             RET = CastTransmute(x);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ transmuting from 4-byte type to 2-byte type: `i32` -> `u16`\n+   |\n+note: inside `mir_transmute::<i32, u16>`\n+  --> $DIR/transmute-size-mismatch.rs:12:13\n+   |\n+LL |             RET = CastTransmute(x);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `FROM_BIGGER`\n+  --> $DIR/transmute-size-mismatch.rs:20:35\n+   |\n+LL | const FROM_BIGGER: u16 = unsafe { mir_transmute(123_i32) };\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/transmute-size-mismatch.rs:12:13\n+   |\n+LL |             RET = CastTransmute(x);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ transmuting from 2-byte type to 4-byte type: `i16` -> `u32`\n+   |\n+note: inside `mir_transmute::<i16, u32>`\n+  --> $DIR/transmute-size-mismatch.rs:12:13\n+   |\n+LL |             RET = CastTransmute(x);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `FROM_SMALLER`\n+  --> $DIR/transmute-size-mismatch.rs:22:36\n+   |\n+LL | const FROM_SMALLER: u32 = unsafe { mir_transmute(123_i16) };\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "3ad1ac974c8066f683008d656f0635a63b728778", "filename": "tests/ui/consts/const-eval/ub-enum.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -108,13 +108,13 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:96:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n-   |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type Never\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:98:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n-   |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of the never type `!`\n \n error: aborting due to 13 previous errors\n "}, {"sha": "a66706d1af9b8edf7939fb68d24d2548b27c3535", "filename": "tests/ui/consts/const-eval/ub-enum.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -108,13 +108,13 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:96:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n-   |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type Never\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:98:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n-   |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of the never type `!`\n \n error: aborting due to 13 previous errors\n "}, {"sha": "74bc6317c808e101fbf7daf82aa162eeaa0766c4", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -11,7 +11,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/validate_uninhabited_zsts.rs:4:14\n    |\n LL |     unsafe { std::mem::transmute(()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of the never type `!`\n    |\n note: inside `foo`\n   --> $DIR/validate_uninhabited_zsts.rs:4:14"}, {"sha": "74bc6317c808e101fbf7daf82aa162eeaa0766c4", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -11,7 +11,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/validate_uninhabited_zsts.rs:4:14\n    |\n LL |     unsafe { std::mem::transmute(()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of the never type `!`\n    |\n note: inside `foo`\n   --> $DIR/validate_uninhabited_zsts.rs:4:14"}, {"sha": "97b6cbca41240233d39012b13e2a1274fa46877f", "filename": "tests/ui/feature-gates/feature-gate-link_cfg.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Ffeature-gates%2Ffeature-gate-link_cfg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Ffeature-gates%2Ffeature-gate-link_cfg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-link_cfg.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -4,7 +4,6 @@ error[E0658]: link cfg is unstable\n LL | #[link(name = \"foo\", cfg(foo))]\n    |                      ^^^^^^^^\n    |\n-   = note: see issue #37406 <https://github.com/rust-lang/rust/issues/37406> for more information\n    = help: add `#![feature(link_cfg)]` to the crate attributes to enable\n \n error: aborting due to previous error"}, {"sha": "e1d5511379e7a9f2875dd1b1405637a8ea7a8937", "filename": "tests/ui/impl-trait/nested-return-type2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -26,7 +26,6 @@ impl<R: Duh, F: FnMut() -> R> Trait for F {\n // Lazy TAIT would error out, but we inserted a hack to make it work again,\n // keeping backwards compatibility.\n fn foo() -> impl Trait<Assoc = impl Send> {\n-    //~^ WARN opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n     || 42\n }\n "}, {"sha": "09ad3bd05c1b3dda20e4842d09f3186cde6d8249", "filename": "tests/ui/impl-trait/nested-return-type2.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4b0f8745082a36f6408357ec8bfd6c439955cc38/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b0f8745082a36f6408357ec8bfd6c439955cc38/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr?ref=4b0f8745082a36f6408357ec8bfd6c439955cc38", "patch": "@@ -1,17 +0,0 @@\n-warning: opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n-  --> $DIR/nested-return-type2.rs:28:24\n-   |\n-LL |     type Assoc: Duh;\n-   |                 --- this associated type bound is unsatisfied for `impl Send`\n-...\n-LL | fn foo() -> impl Trait<Assoc = impl Send> {\n-   |                        ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n-help: add this bound\n-   |\n-LL | fn foo() -> impl Trait<Assoc = impl Send + Duh> {\n-   |                                          +++++\n-\n-warning: 1 warning emitted\n-"}, {"sha": "74b4dae22ebfd32a5ee845c1ec3d8834f4bc447e", "filename": "tests/ui/impl-trait/nested-return-type3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -13,7 +13,6 @@ impl<F: Duh> Trait for F {\n }\n \n fn foo() -> impl Trait<Assoc = impl Send> {\n-    //~^ WARN opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n     42\n }\n "}, {"sha": "632de71aa4c880246ad942242eae3b6ab01f4beb", "filename": "tests/ui/impl-trait/nested-return-type3.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4b0f8745082a36f6408357ec8bfd6c439955cc38/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b0f8745082a36f6408357ec8bfd6c439955cc38/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.stderr?ref=4b0f8745082a36f6408357ec8bfd6c439955cc38", "patch": "@@ -1,17 +0,0 @@\n-warning: opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n-  --> $DIR/nested-return-type3.rs:15:24\n-   |\n-LL |     type Assoc: Duh;\n-   |                 --- this associated type bound is unsatisfied for `impl Send`\n-...\n-LL | fn foo() -> impl Trait<Assoc = impl Send> {\n-   |                        ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n-help: add this bound\n-   |\n-LL | fn foo() -> impl Trait<Assoc = impl Send + Duh> {\n-   |                                          +++++\n-\n-warning: 1 warning emitted\n-"}, {"sha": "8a146378b439581b0c1b7b3894eebac534f0fbfc", "filename": "tests/ui/imports/auxiliary/glob-conflict.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Fauxiliary%2Fglob-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Fauxiliary%2Fglob-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fauxiliary%2Fglob-conflict.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,3 +1,5 @@\n+#![allow(ambiguous_glob_reexports)]\n+\n mod m1 {\n     pub fn f() {}\n }"}, {"sha": "0e60c73b67a44e274dfc886d4d33e1b26f9262bb", "filename": "tests/ui/imports/issue-99695-b.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Fissue-99695-b.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Fissue-99695-b.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695-b.fixed?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n+#![allow(unused, nonstandard_style)]\n mod m {\n \n     mod p {"}, {"sha": "031443a1f5df892f2bd5300112d66866cdae0d59", "filename": "tests/ui/imports/issue-99695-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Fissue-99695-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Fissue-99695-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695-b.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n+#![allow(unused, nonstandard_style)]\n mod m {\n \n     mod p {"}, {"sha": "6bf228b23aad221d8fbf1a798186f38fb3ebd061", "filename": "tests/ui/imports/issue-99695.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Fissue-99695.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Fissue-99695.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695.fixed?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n+#![allow(unused, nonstandard_style)]\n mod m {\n     #[macro_export]\n     macro_rules! nu {"}, {"sha": "f7199f1497ab0877b12d9d9e8bb6520dc09fa75d", "filename": "tests/ui/imports/issue-99695.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Fissue-99695.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Fissue-99695.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n+#![allow(unused, nonstandard_style)]\n mod m {\n     #[macro_export]\n     macro_rules! nu {"}, {"sha": "ce700ae0de9b12e42c8308a72280acc04f1c5018", "filename": "tests/ui/imports/local-modularized-tricky-fail-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,4 +1,5 @@\n #![feature(decl_macro)]\n+#![allow(ambiguous_glob_reexports)]\n \n macro_rules! define_exported { () => {\n     #[macro_export]"}, {"sha": "52a01e8bcdfe36549db5118ecdc9d3351e882959", "filename": "tests/ui/imports/local-modularized-tricky-fail-1.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,12 +1,12 @@\n error[E0659]: `exported` is ambiguous\n-  --> $DIR/local-modularized-tricky-fail-1.rs:28:1\n+  --> $DIR/local-modularized-tricky-fail-1.rs:29:1\n    |\n LL | exported!();\n    | ^^^^^^^^ ambiguous name\n    |\n    = note: ambiguous because of a conflict between a name from a glob import and a macro-expanded name in the same module during import or macro resolution\n note: `exported` could refer to the macro defined here\n-  --> $DIR/local-modularized-tricky-fail-1.rs:5:5\n+  --> $DIR/local-modularized-tricky-fail-1.rs:6:5\n    |\n LL | /     macro_rules! exported {\n LL | |         () => ()\n@@ -16,23 +16,23 @@ LL | |     }\n LL |       define_exported!();\n    |       ------------------ in this macro invocation\n note: `exported` could also refer to the macro imported here\n-  --> $DIR/local-modularized-tricky-fail-1.rs:22:5\n+  --> $DIR/local-modularized-tricky-fail-1.rs:23:5\n    |\n LL | use inner1::*;\n    |     ^^^^^^^^^\n    = help: consider adding an explicit import of `exported` to disambiguate\n    = note: this error originates in the macro `define_exported` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0659]: `panic` is ambiguous\n-  --> $DIR/local-modularized-tricky-fail-1.rs:35:5\n+  --> $DIR/local-modularized-tricky-fail-1.rs:36:5\n    |\n LL |     panic!();\n    |     ^^^^^ ambiguous name\n    |\n    = note: ambiguous because of a conflict between a macro-expanded name and a less macro-expanded name from outer scope during import or macro resolution\n    = note: `panic` could refer to a macro from prelude\n note: `panic` could also refer to the macro defined here\n-  --> $DIR/local-modularized-tricky-fail-1.rs:11:5\n+  --> $DIR/local-modularized-tricky-fail-1.rs:12:5\n    |\n LL | /     macro_rules! panic {\n LL | |         () => ()\n@@ -45,15 +45,15 @@ LL |       define_panic!();\n    = note: this error originates in the macro `define_panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0659]: `include` is ambiguous\n-  --> $DIR/local-modularized-tricky-fail-1.rs:46:1\n+  --> $DIR/local-modularized-tricky-fail-1.rs:47:1\n    |\n LL | include!();\n    | ^^^^^^^ ambiguous name\n    |\n    = note: ambiguous because of a conflict between a macro-expanded name and a less macro-expanded name from outer scope during import or macro resolution\n    = note: `include` could refer to a macro from prelude\n note: `include` could also refer to the macro defined here\n-  --> $DIR/local-modularized-tricky-fail-1.rs:17:5\n+  --> $DIR/local-modularized-tricky-fail-1.rs:18:5\n    |\n LL | /     macro_rules! include {\n LL | |         () => ()"}, {"sha": "11ac5d07140ba41aff8f1f08cf893641a0d9e33f", "filename": "tests/ui/lint/anonymous-reexport.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Flint%2Fanonymous-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Flint%2Fanonymous-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fanonymous-reexport.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,4 +1,4 @@\n-#![deny(useless_anonymous_reexport)]\n+#![deny(unused_imports)]\n #![crate_type = \"rlib\"]\n \n mod my_mod {\n@@ -9,13 +9,11 @@ mod my_mod {\n }\n \n pub use self::my_mod::Foo as _;\n-pub use self::my_mod::TyFoo as _;\n-pub use self::my_mod::Bar as _; //~ ERROR\n-pub use self::my_mod::TyBar as _; //~ ERROR\n-pub use self::my_mod::{Bar as _}; //~ ERROR\n-pub use self::my_mod::{Bar as _, Foo as _}; //~ ERROR\n-pub use self::my_mod::{Bar as _, TyBar as _};\n-//~^ ERROR\n-//~| ERROR\n+pub use self::my_mod::TyFoo as _; //~ ERROR unused import\n+pub use self::my_mod::Bar as _; //~ ERROR unused import\n+pub use self::my_mod::TyBar as _; //~ ERROR unused import\n+pub use self::my_mod::{Bar as _}; //~ ERROR unused import\n+pub use self::my_mod::{Bar as _, Foo as _}; //~ ERROR unused import\n+pub use self::my_mod::{Bar as _, TyBar as _}; //~ ERROR unused imports\n #[allow(unused_imports)]\n use self::my_mod::TyBar as _;"}, {"sha": "e3854a5459ec0b3210d85abd1d362f23649954f3", "filename": "tests/ui/lint/anonymous-reexport.stderr", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Flint%2Fanonymous-reexport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Flint%2Fanonymous-reexport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fanonymous-reexport.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -1,55 +1,44 @@\n-error: useless anonymous re-export\n-  --> $DIR/anonymous-reexport.rs:13:1\n+error: unused import: `self::my_mod::TyFoo as _`\n+  --> $DIR/anonymous-reexport.rs:12:9\n    |\n-LL | pub use self::my_mod::Bar as _;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | pub use self::my_mod::TyFoo as _;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only anonymous re-exports of traits are useful, this is a `struct`\n note: the lint level is defined here\n   --> $DIR/anonymous-reexport.rs:1:9\n    |\n-LL | #![deny(useless_anonymous_reexport)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(unused_imports)]\n+   |         ^^^^^^^^^^^^^^\n \n-error: useless anonymous re-export\n-  --> $DIR/anonymous-reexport.rs:14:1\n+error: unused import: `self::my_mod::Bar as _`\n+  --> $DIR/anonymous-reexport.rs:13:9\n    |\n-LL | pub use self::my_mod::TyBar as _;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | pub use self::my_mod::Bar as _;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unused import: `self::my_mod::TyBar as _`\n+  --> $DIR/anonymous-reexport.rs:14:9\n    |\n-   = note: only anonymous re-exports of traits are useful, this is a `type alias`\n+LL | pub use self::my_mod::TyBar as _;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: useless anonymous re-export\n+error: unused import: `Bar as _`\n   --> $DIR/anonymous-reexport.rs:15:24\n    |\n LL | pub use self::my_mod::{Bar as _};\n    |                        ^^^^^^^^\n-   |\n-   = note: only anonymous re-exports of traits are useful, this is a `struct`\n \n-error: useless anonymous re-export\n+error: unused import: `Bar as _`\n   --> $DIR/anonymous-reexport.rs:16:24\n    |\n LL | pub use self::my_mod::{Bar as _, Foo as _};\n    |                        ^^^^^^^^\n-   |\n-   = note: only anonymous re-exports of traits are useful, this is a `struct`\n \n-error: useless anonymous re-export\n+error: unused imports: `Bar as _`, `TyBar as _`\n   --> $DIR/anonymous-reexport.rs:17:24\n    |\n LL | pub use self::my_mod::{Bar as _, TyBar as _};\n-   |                        ^^^^^^^^\n-   |\n-   = note: only anonymous re-exports of traits are useful, this is a `struct`\n-\n-error: useless anonymous re-export\n-  --> $DIR/anonymous-reexport.rs:17:34\n-   |\n-LL | pub use self::my_mod::{Bar as _, TyBar as _};\n-   |                                  ^^^^^^^^^^\n-   |\n-   = note: only anonymous re-exports of traits are useful, this is a `type alias`\n+   |                        ^^^^^^^^  ^^^^^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "431213e25e462e4ec449ab3a08198cde500c217d", "filename": "tests/ui/resolve/issue-107563-ambiguous-glob-reexports.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fresolve%2Fissue-107563-ambiguous-glob-reexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fresolve%2Fissue-107563-ambiguous-glob-reexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fissue-107563-ambiguous-glob-reexports.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,33 @@\n+#![deny(ambiguous_glob_reexports)]\n+\n+pub mod foo {\n+    pub type X = u8;\n+}\n+\n+pub mod bar {\n+    pub type X = u8;\n+    pub type Y = u8;\n+}\n+\n+pub use foo::*;\n+//~^ ERROR ambiguous glob re-exports\n+pub use bar::*;\n+\n+mod ambiguous {\n+    mod m1 { pub type A = u8; }\n+    mod m2 { pub type A = u8; }\n+    pub use self::m1::*;\n+    //~^ ERROR ambiguous glob re-exports\n+    pub use self::m2::*;\n+}\n+\n+pub mod single {\n+    pub use ambiguous::A;\n+    //~^ ERROR `A` is ambiguous\n+}\n+\n+pub mod glob {\n+    pub use ambiguous::*;\n+}\n+\n+pub fn main() {}"}, {"sha": "07e61dd8643d45b44f2574713c1dcb1f3a6e4ebe", "filename": "tests/ui/resolve/issue-107563-ambiguous-glob-reexports.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fresolve%2Fissue-107563-ambiguous-glob-reexports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fresolve%2Fissue-107563-ambiguous-glob-reexports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fissue-107563-ambiguous-glob-reexports.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,47 @@\n+error[E0659]: `A` is ambiguous\n+  --> $DIR/issue-107563-ambiguous-glob-reexports.rs:25:24\n+   |\n+LL |     pub use ambiguous::A;\n+   |                        ^ ambiguous name\n+   |\n+   = note: ambiguous because of multiple glob imports of a name in the same module\n+note: `A` could refer to the type alias imported here\n+  --> $DIR/issue-107563-ambiguous-glob-reexports.rs:19:13\n+   |\n+LL |     pub use self::m1::*;\n+   |             ^^^^^^^^^^^\n+   = help: consider adding an explicit import of `A` to disambiguate\n+note: `A` could also refer to the type alias imported here\n+  --> $DIR/issue-107563-ambiguous-glob-reexports.rs:21:13\n+   |\n+LL |     pub use self::m2::*;\n+   |             ^^^^^^^^^^^\n+   = help: consider adding an explicit import of `A` to disambiguate\n+\n+error: ambiguous glob re-exports\n+  --> $DIR/issue-107563-ambiguous-glob-reexports.rs:12:9\n+   |\n+LL | pub use foo::*;\n+   |         ^^^^^^ the name `X` in the type namespace is first re-exported here\n+LL |\n+LL | pub use bar::*;\n+   |         ------ but the name `X` in the type namespace is also re-exported here\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-107563-ambiguous-glob-reexports.rs:1:9\n+   |\n+LL | #![deny(ambiguous_glob_reexports)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: ambiguous glob re-exports\n+  --> $DIR/issue-107563-ambiguous-glob-reexports.rs:19:13\n+   |\n+LL |     pub use self::m1::*;\n+   |             ^^^^^^^^^^^ the name `A` in the type namespace is first re-exported here\n+LL |\n+LL |     pub use self::m2::*;\n+   |             ----------- but the name `A` in the type namespace is also re-exported here\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "83f311efd39d7017ba191b1474e5d121480f06b2", "filename": "tests/ui/specialization/min_specialization/bad-const-wf-doesnt-specialize.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -2,7 +2,7 @@ error: the constant `N` is not of type `usize`\n   --> $DIR/bad-const-wf-doesnt-specialize.rs:8:29\n    |\n LL | impl<const N: i32> Copy for S<N> {}\n-   |                             ^^^^\n+   |                             ^^^^ expected `usize`, found `i32`\n    |\n note: required by a bound in `S`\n   --> $DIR/bad-const-wf-doesnt-specialize.rs:6:10"}, {"sha": "35fdcae6a598a8e65e339dca7338cbdc6e0458a1", "filename": "tests/ui/statics/uninhabited-static.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fstatics%2Funinhabited-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fstatics%2Funinhabited-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstatics%2Funinhabited-static.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -47,7 +47,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/uninhabited-static.rs:12:31\n    |\n LL | static VOID2: Void = unsafe { std::mem::transmute(()) };\n-   |                               ^^^^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Void\n \n warning: the type `Void` does not permit zero-initialization\n   --> $DIR/uninhabited-static.rs:12:31\n@@ -66,7 +66,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/uninhabited-static.rs:16:32\n    |\n LL | static NEVER2: Void = unsafe { std::mem::transmute(()) };\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Void\n \n warning: the type `Void` does not permit zero-initialization\n   --> $DIR/uninhabited-static.rs:16:32"}, {"sha": "e45ee5991db288c02b12b959b8b4fb3872cc3e3e", "filename": "tests/ui/suggestions/issue-109436.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fsuggestions%2Fissue-109436.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fsuggestions%2Fissue-109436.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-109436.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,13 @@\n+struct Foo;\n+struct Bar;\n+\n+impl From<&Foo> for Bar {\n+    fn from(foo: &Foo) -> Bar {\n+        Bar\n+    }\n+}\n+\n+fn main() {\n+    let foo = Foo;\n+    let b: Bar = foo.into(); //~ ERROR E0277\n+}"}, {"sha": "48518b33d12ac36c36afbe8c8cd7459db83a760a", "filename": "tests/ui/suggestions/issue-109436.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fsuggestions%2Fissue-109436.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Fsuggestions%2Fissue-109436.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-109436.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `Foo: Into<_>` is not satisfied\n+  --> $DIR/issue-109436.rs:12:22\n+   |\n+LL |     let b: Bar = foo.into();\n+   |                      ^^^^ the trait `~const Into<_>` is not implemented for `Foo`\n+   |\n+   = note: required for `Foo` to implement `Into<Bar>`\n+help: consider borrowing here\n+   |\n+LL |     let b: Bar = (&foo).into();\n+   |                  ++   +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4bfb6323a53662b32f8db005a7eb4a8ca5024e94", "filename": "tests/ui/traits/new-solver/alias-eq-in-canonical-response.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-eq-in-canonical-response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-eq-in-canonical-response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-eq-in-canonical-response.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,40 @@\n+// check-pass\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Foo {\n+    type Gat<'a>\n+    where\n+        Self: 'a;\n+    fn bar(&self) -> Self::Gat<'_>;\n+}\n+\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+\n+impl<T> Option<T> {\n+    fn as_ref(&self) -> Option<&T> {\n+        match self {\n+            Option::Some(t) => Option::Some(t),\n+            Option::None => Option::None,\n+        }\n+    }\n+\n+    fn map<U>(self, f: impl FnOnce(T) -> U) -> Option<U> {\n+        match self {\n+            Option::Some(t) => Option::Some(f(t)),\n+            Option::None => Option::None,\n+        }\n+    }\n+}\n+\n+impl<T: Foo + 'static> Foo for Option<T> {\n+    type Gat<'a> = Option<<T as Foo>::Gat<'a>> where Self: 'a;\n+\n+    fn bar(&self) -> Self::Gat<'_> {\n+        self.as_ref().map(Foo::bar)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "30c1981a92eceed582a7460fb904ec75ad431dbc", "filename": "tests/ui/traits/new-solver/alias-sub.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-sub.rs?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -0,0 +1,34 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Trait {\n+    type Assoc: Sized;\n+}\n+\n+impl Trait for &'static str {\n+    type Assoc = &'static str;\n+}\n+\n+// Wrapper is just here to get around stupid `Sized` obligations in mir typeck\n+struct Wrapper<T: ?Sized>(std::marker::PhantomData<T>);\n+fn mk<T: Trait>(x: T) -> Wrapper<<T as Trait>::Assoc> { todo!() }\n+\n+\n+trait IsStaticStr {}\n+impl IsStaticStr for (&'static str,) {}\n+fn define<T: IsStaticStr>(_: T) {}\n+\n+fn foo<'a, T: Trait>() {\n+    let y = Default::default();\n+\n+    // `<?0 as Trait>::Assoc <: &'a str`\n+    // In the old solver, this would *equate* the LHS and RHS.\n+    let _: Wrapper<&'a str> = mk(y);\n+\n+    // ... then later on, we constrain `?0 = &'static str`\n+    // but that should not mean that `'a = 'static`, because\n+    // we should use *sub* above.\n+    define((y,));\n+}\n+\n+fn main() {}"}, {"sha": "bf947d0ea4a6cfd44fc3f0ccec08c136181c22c5", "filename": "tests/ui/transmutability/issue-101739-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Ftransmutability%2Fissue-101739-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb/tests%2Fui%2Ftransmutability%2Fissue-101739-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fissue-101739-1.stderr?ref=3e523e9f79b5a3a0e8f58f8b426aa1594da7cafb", "patch": "@@ -8,7 +8,7 @@ error: the constant `ASSUME_ALIGNMENT` is not of type `Assume`\n   --> $DIR/issue-101739-1.rs:8:14\n    |\n LL |         Dst: BikeshedIntrinsicFrom<Src, Context, ASSUME_ALIGNMENT>,\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Assume`, found `bool`\n    |\n note: required by a bound in `BikeshedIntrinsicFrom`\n   --> $SRC_DIR/core/src/mem/transmutability.rs:LL:COL"}]}