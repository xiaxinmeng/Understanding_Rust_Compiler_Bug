{"sha": "b0814a3fd88fcacf28eceb2174b0ac35facfccf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwODE0YTNmZDg4ZmNhY2YyOGVjZWIyMTc0YjBhYzM1ZmFjZmNjZjQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-28T11:41:03Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-31T14:56:28Z"}, "message": "Check for cross-ebb temporal overlap between loads and stores", "tree": {"sha": "d2727f227baeb93b7d3c09788985052162971628", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2727f227baeb93b7d3c09788985052162971628"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0814a3fd88fcacf28eceb2174b0ac35facfccf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0814a3fd88fcacf28eceb2174b0ac35facfccf4", "html_url": "https://github.com/rust-lang/rust/commit/b0814a3fd88fcacf28eceb2174b0ac35facfccf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0814a3fd88fcacf28eceb2174b0ac35facfccf4/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5f42aef1d7a7c0e4097fc0e8f76fff47b8d32b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5f42aef1d7a7c0e4097fc0e8f76fff47b8d32b8", "html_url": "https://github.com/rust-lang/rust/commit/c5f42aef1d7a7c0e4097fc0e8f76fff47b8d32b8"}], "stats": {"total": 81, "additions": 54, "deletions": 27}, "files": [{"sha": "0adca5bee8b11d5baf43fe04675a590fbe1a0ef5", "filename": "src/base.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0814a3fd88fcacf28eceb2174b0ac35facfccf4/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0814a3fd88fcacf28eceb2174b0ac35facfccf4/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=b0814a3fd88fcacf28eceb2174b0ac35facfccf4", "patch": "@@ -76,11 +76,13 @@ pub fn trans_fn<'clif, 'tcx, B: Backend + 'static>(\n     // Verify function\n     verify_func(tcx, &clif_comments, &func);\n \n-    crate::optimize::optimize_function(cx.tcx, instance, &mut func, &mut clif_comments);\n-\n-    // Define function\n     let context = &mut cx.caches.context;\n     context.func = func;\n+\n+    // Perform rust specific optimizations\n+    crate::optimize::optimize_function(cx.tcx, instance, context, &mut clif_comments);\n+\n+    // Define function\n     cx.module.define_function(func_id, context).unwrap();\n \n     // Write optimized function to file for debugging"}, {"sha": "64400e8886a0f4aadd3d943797a9b0d74a08d43b", "filename": "src/optimize/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0814a3fd88fcacf28eceb2174b0ac35facfccf4/src%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0814a3fd88fcacf28eceb2174b0ac35facfccf4/src%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fmod.rs?ref=b0814a3fd88fcacf28eceb2174b0ac35facfccf4", "patch": "@@ -5,11 +5,11 @@ mod stack2reg;\n pub fn optimize_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n-    func: &mut Function,\n+    ctx: &mut Context,\n     clif_comments: &mut crate::pretty_clif::CommentWriter,\n ) {\n-    self::stack2reg::optimize_function(func, clif_comments, format!(\"{:?}\", instance));\n+    self::stack2reg::optimize_function(ctx, clif_comments, format!(\"{:?}\", instance));\n     #[cfg(debug_assertions)]\n-    crate::pretty_clif::write_clif_file(tcx, \"stack2reg\", instance, &*func, &*clif_comments, None);\n-    crate::base::verify_func(tcx, &*clif_comments, &*func);\n+    crate::pretty_clif::write_clif_file(tcx, \"stack2reg\", instance, &ctx.func, &*clif_comments, None);\n+    crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n }"}, {"sha": "26d74c70bdab4b86d054326ff817bf77cc9eea8c", "filename": "src/optimize/stack2reg.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b0814a3fd88fcacf28eceb2174b0ac35facfccf4/src%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0814a3fd88fcacf28eceb2174b0ac35facfccf4/src%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fstack2reg.rs?ref=b0814a3fd88fcacf28eceb2174b0ac35facfccf4", "patch": "@@ -2,6 +2,7 @@ use std::collections::{BTreeMap, HashSet};\n use std::ops::Not;\n \n use cranelift_codegen::cursor::{Cursor, FuncCursor};\n+use cranelift_codegen::entity::EntitySet;\n use cranelift_codegen::ir::{InstructionData, Opcode, ProgramOrder, ValueDef};\n use cranelift_codegen::ir::immediates::Offset32;\n \n@@ -31,16 +32,18 @@ struct StackSlotUsage {\n }\n \n pub(super) fn optimize_function(\n-    func: &mut Function,\n+    ctx: &mut Context,\n     clif_comments: &mut crate::pretty_clif::CommentWriter,\n     name: String, // FIXME remove\n ) {\n-    combine_stack_addr_with_load_store(func);\n+    ctx.flowgraph(); // Compute cfg and domtree.\n+\n+    combine_stack_addr_with_load_store(&mut ctx.func);\n \n     // Record all stack_addr, stack_load and stack_store instructions.\n     let mut stack_slot_usage_map = BTreeMap::<OrdStackSlot, StackSlotUsage>::new();\n \n-    let mut cursor = FuncCursor::new(func);\n+    let mut cursor = FuncCursor::new(&mut ctx.func);\n     while let Some(_ebb) = cursor.next_ebb() {\n         while let Some(inst) = cursor.next_inst() {\n             match cursor.func.dfg[inst] {\n@@ -73,7 +76,7 @@ pub(super) fn optimize_function(\n \n     println!(\"{}:\\nstack slot usage: {:?}\", name, stack_slot_usage_map);\n \n-    remove_unused_stack_addr_and_stack_load(func, &mut stack_slot_usage_map);\n+    remove_unused_stack_addr_and_stack_load(&mut ctx.func, &mut stack_slot_usage_map);\n \n     println!(\"stack slot usage (after): {:?}\", stack_slot_usage_map);\n \n@@ -85,36 +88,58 @@ pub(super) fn optimize_function(\n         }\n \n         for load in users.stack_load.clone().drain() {\n-            let load_ebb = func.layout.inst_ebb(load).unwrap();\n-            let loaded_value = func.dfg.inst_results(load)[0];\n-            let loaded_type = func.dfg.value_type(loaded_value);\n+            let load_ebb = ctx.func.layout.inst_ebb(load).unwrap();\n+            let loaded_value = ctx.func.dfg.inst_results(load)[0];\n+            let loaded_type = ctx.func.dfg.value_type(loaded_value);\n \n             let potential_stores = users.stack_store.iter().cloned().filter(|&store| {\n-                match spatial_overlap(func, load, store) {\n+                // Check if the store modified some memory accessed by the load.\n+\n+                match spatial_overlap(&ctx.func, load, store) {\n                     SpatialOverlap::No => false, // Can never be the source of the loaded value.\n                     SpatialOverlap::Partial | SpatialOverlap::Full => true,\n                 }\n             }).filter(|&store| {\n-                if load_ebb == func.layout.inst_ebb(store).unwrap() {\n-                    func.layout.cmp(store, load) == std::cmp::Ordering::Less\n+                // Check if the store may have happened before the load.\n+\n+                let store_ebb = ctx.func.layout.inst_ebb(store).unwrap();\n+                if load_ebb == store_ebb {\n+                    ctx.func.layout.cmp(store, load) == std::cmp::Ordering::Less\n                 } else {\n-                    true // FIXME\n+                    // FIXME O(stack_load count * ebb count)\n+                    // FIXME reuse memory allocations\n+                    let mut visited = EntitySet::new();\n+                    let mut todo = EntitySet::new();\n+                    todo.insert(load_ebb);\n+                    while let Some(ebb) = todo.pop() {\n+                        if visited.contains(ebb) {\n+                            continue;\n+                        }\n+                        visited.insert(ebb);\n+                        if ebb == store_ebb {\n+                            return true;\n+                        }\n+                        for bb in ctx.cfg.pred_iter(ebb) {\n+                            todo.insert(bb.ebb);\n+                        }\n+                    }\n+                    false\n                 }\n             }).collect::<Vec<Inst>>();\n             for &store in &potential_stores {\n-                println!(\"Potential store -> load forwarding {} -> {} ({:?})\", func.dfg.display_inst(store, None), func.dfg.display_inst(load, None), spatial_overlap(func, load, store));\n+                println!(\"Potential store -> load forwarding {} -> {} ({:?})\", ctx.func.dfg.display_inst(store, None), ctx.func.dfg.display_inst(load, None), spatial_overlap(func, load, store));\n             }\n             match *potential_stores {\n                 [] => println!(\"[{}] [BUG?] Reading uninitialized memory\", name),\n-                [store] if spatial_overlap(func, load, store) == SpatialOverlap::Full => {\n-                    let store_ebb = func.layout.inst_ebb(store).unwrap();\n-                    let stored_value = func.dfg.inst_args(store)[0];\n-                    let stored_type = func.dfg.value_type(stored_value);\n+                [store] if spatial_overlap(&ctx.func, load, store) == SpatialOverlap::Full => {\n+                    let store_ebb = ctx.func.layout.inst_ebb(store).unwrap();\n+                    let stored_value = ctx.func.dfg.inst_args(store)[0];\n+                    let stored_type = ctx.func.dfg.value_type(stored_value);\n                     if stored_type == loaded_type && store_ebb == load_ebb {\n                         println!(\"Store to load forward {} -> {}\", store, load);\n-                        func.dfg.detach_results(load);\n-                        func.dfg.replace(load).nop();\n-                        func.dfg.change_to_alias(loaded_value, stored_value);\n+                        ctx.func.dfg.detach_results(load);\n+                        ctx.func.dfg.replace(load).nop();\n+                        ctx.func.dfg.change_to_alias(loaded_value, stored_value);\n                         users.stack_load.remove(&load);\n                     }\n                 }\n@@ -126,7 +151,7 @@ pub(super) fn optimize_function(\n             // Never loaded; can safely remove all stores and the stack slot.\n             for user in users.stack_store.drain() {\n                 println!(\"[{}] Remove dead stack store {} of {}\", name, user, stack_slot.0);\n-                func.dfg.replace(user).nop();\n+                ctx.func.dfg.replace(user).nop();\n             }\n         }\n "}]}