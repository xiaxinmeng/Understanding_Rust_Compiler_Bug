{"sha": "3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MTBhZWRkYmU2M2JjOTMxYjUwMjEwZWI1YzBjOGM3MGViZDlhYTE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-23T01:57:04Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-04-06T18:55:50Z"}, "message": "ty: switch `Ty::walk` from `Ty` to `GenericArg`.", "tree": {"sha": "bba6be173de7cba63227ab8f9749fb250b99ecd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bba6be173de7cba63227ab8f9749fb250b99ecd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "html_url": "https://github.com/rust-lang/rust/commit/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26199f0cbc947a09d21044aacaa1ae12af465e65", "url": "https://api.github.com/repos/rust-lang/rust/commits/26199f0cbc947a09d21044aacaa1ae12af465e65", "html_url": "https://github.com/rust-lang/rust/commit/26199f0cbc947a09d21044aacaa1ae12af465e65"}], "stats": {"total": 533, "additions": 301, "deletions": 232}, "files": [{"sha": "bb6e5700ccad4944bb7885e286d87a3b8787b9ec", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -7,52 +7,59 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Body, Expr, ExprKind, FnRetTy, HirId, Local, Pat};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::print::Print;\n-use rustc_middle::ty::{self, DefIdTree, Infer, Ty, TyVar};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n+use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n use std::borrow::Cow;\n \n-struct FindLocalByTypeVisitor<'a, 'tcx> {\n+struct FindHirNodeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    target_ty: Ty<'tcx>,\n-    hir_map: Map<'tcx>,\n+    target: GenericArg<'tcx>,\n+    found_node_ty: Option<Ty<'tcx>>,\n     found_local_pattern: Option<&'tcx Pat<'tcx>>,\n     found_arg_pattern: Option<&'tcx Pat<'tcx>>,\n-    found_ty: Option<Ty<'tcx>>,\n-    found_closure: Option<&'tcx ExprKind<'tcx>>,\n+    found_closure: Option<&'tcx Expr<'tcx>>,\n     found_method_call: Option<&'tcx Expr<'tcx>>,\n }\n \n-impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target_ty: Ty<'tcx>, hir_map: Map<'tcx>) -> Self {\n+impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n+    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target: GenericArg<'tcx>) -> Self {\n         Self {\n             infcx,\n-            target_ty,\n-            hir_map,\n+            target,\n+            found_node_ty: None,\n             found_local_pattern: None,\n             found_arg_pattern: None,\n-            found_ty: None,\n             found_closure: None,\n             found_method_call: None,\n         }\n     }\n \n-    fn node_matches_type(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n+    fn node_ty_contains_target(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n         let ty_opt =\n             self.infcx.in_progress_tables.and_then(|tables| tables.borrow().node_type_opt(hir_id));\n         match ty_opt {\n             Some(ty) => {\n                 let ty = self.infcx.resolve_vars_if_possible(&ty);\n-                if ty.walk().any(|inner_ty| {\n-                    inner_ty == self.target_ty\n-                        || match (&inner_ty.kind, &self.target_ty.kind) {\n-                            (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => self\n-                                .infcx\n-                                .inner\n-                                .borrow_mut()\n-                                .type_variables\n-                                .sub_unified(a_vid, b_vid),\n+                if ty.walk().any(|inner| {\n+                    inner == self.target\n+                        || match (inner.unpack(), self.target.unpack()) {\n+                            (GenericArgKind::Type(inner_ty), GenericArgKind::Type(target_ty)) => {\n+                                match (&inner_ty.kind, &target_ty.kind) {\n+                                    (\n+                                        &ty::Infer(ty::TyVar(a_vid)),\n+                                        &ty::Infer(ty::TyVar(b_vid)),\n+                                    ) => self\n+                                        .infcx\n+                                        .inner\n+                                        .borrow_mut()\n+                                        .type_variables\n+                                        .sub_unified(a_vid, b_vid),\n+                                    _ => false,\n+                                }\n+                            }\n                             _ => false,\n                         }\n                 }) {\n@@ -66,36 +73,39 @@ impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.hir_map)\n+        NestedVisitorMap::OnlyBodies(self.infcx.tcx.hir())\n     }\n \n     fn visit_local(&mut self, local: &'tcx Local<'tcx>) {\n-        if let (None, Some(ty)) = (self.found_local_pattern, self.node_matches_type(local.hir_id)) {\n+        if let (None, Some(ty)) =\n+            (self.found_local_pattern, self.node_ty_contains_target(local.hir_id))\n+        {\n             self.found_local_pattern = Some(&*local.pat);\n-            self.found_ty = Some(ty);\n+            self.found_node_ty = Some(ty);\n         }\n         intravisit::walk_local(self, local);\n     }\n \n     fn visit_body(&mut self, body: &'tcx Body<'tcx>) {\n         for param in body.params {\n-            if let (None, Some(ty)) = (self.found_arg_pattern, self.node_matches_type(param.hir_id))\n+            if let (None, Some(ty)) =\n+                (self.found_arg_pattern, self.node_ty_contains_target(param.hir_id))\n             {\n                 self.found_arg_pattern = Some(&*param.pat);\n-                self.found_ty = Some(ty);\n+                self.found_node_ty = Some(ty);\n             }\n         }\n         intravisit::walk_body(self, body);\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if self.node_matches_type(expr.hir_id).is_some() {\n+        if self.node_ty_contains_target(expr.hir_id).is_some() {\n             match expr.kind {\n-                ExprKind::Closure(..) => self.found_closure = Some(&expr.kind),\n+                ExprKind::Closure(..) => self.found_closure = Some(&expr),\n                 ExprKind::MethodCall(..) => self.found_method_call = Some(&expr),\n                 _ => {}\n             }\n@@ -213,6 +223,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         (s, None, ty.prefix_string(), None, None)\n     }\n \n+    // FIXME(eddyb) generalize all of this to handle `ty::Const` inference variables as well.\n     pub fn need_type_info_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n@@ -223,7 +234,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let (name, name_sp, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n \n-        let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, self.tcx.hir());\n+        let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -276,7 +287,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings)\n         };\n \n-        let ty_msg = match local_visitor.found_ty {\n+        let ty_msg = match local_visitor.found_node_ty {\n             Some(ty::TyS { kind: ty::Closure(_, substs), .. }) => {\n                 let fn_sig = substs.as_closure().sig();\n                 let args = closure_args(&fn_sig);\n@@ -310,28 +321,32 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             error_code,\n         );\n \n-        let suffix = match local_visitor.found_ty {\n+        let suffix = match local_visitor.found_node_ty {\n             Some(ty::TyS { kind: ty::Closure(_, substs), .. }) => {\n                 let fn_sig = substs.as_closure().sig();\n                 let ret = fn_sig.output().skip_binder().to_string();\n \n-                if let Some(ExprKind::Closure(_, decl, body_id, ..)) = local_visitor.found_closure {\n-                    if let Some(body) = self.tcx.hir().krate().bodies.get(body_id) {\n-                        closure_return_type_suggestion(\n-                            span,\n-                            &mut err,\n-                            &decl.output,\n-                            &body,\n-                            &descr,\n-                            &name,\n-                            &ret,\n-                            parent_name,\n-                            parent_descr,\n-                        );\n-                        // We don't want to give the other suggestions when the problem is the\n-                        // closure return type.\n-                        return err;\n-                    }\n+                let closure_decl_and_body_id =\n+                    local_visitor.found_closure.and_then(|closure| match &closure.kind {\n+                        ExprKind::Closure(_, decl, body_id, ..) => Some((decl, *body_id)),\n+                        _ => None,\n+                    });\n+\n+                if let Some((decl, body_id)) = closure_decl_and_body_id {\n+                    closure_return_type_suggestion(\n+                        span,\n+                        &mut err,\n+                        &decl.output,\n+                        self.tcx.hir().body(body_id),\n+                        &descr,\n+                        &name,\n+                        &ret,\n+                        parent_name,\n+                        parent_descr,\n+                    );\n+                    // We don't want to give the other suggestions when the problem is the\n+                    // closure return type.\n+                    return err;\n                 }\n \n                 // This shouldn't be reachable, but just in case we leave a reasonable fallback."}, {"sha": "84cf2258ac223a51ec0eb1f5494aaf59705ac477", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -36,6 +36,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{GenericParamKind, PatKind};\n use rustc_hir::{HirIdSet, Node};\n use rustc_middle::lint::LintDiagnosticBuilder;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::edition::Edition;\n@@ -104,11 +105,13 @@ declare_lint_pass!(BoxPointers => [BOX_POINTERS]);\n \n impl BoxPointers {\n     fn check_heap_type(&self, cx: &LateContext<'_, '_>, span: Span, ty: Ty<'_>) {\n-        for leaf_ty in ty.walk() {\n-            if leaf_ty.is_box() {\n-                cx.struct_span_lint(BOX_POINTERS, span, |lint| {\n-                    lint.build(&format!(\"type uses owned (Box type) pointers: {}\", ty)).emit()\n-                });\n+        for leaf in ty.walk() {\n+            if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n+                if leaf_ty.is_box() {\n+                    cx.struct_span_lint(BOX_POINTERS, span, |lint| {\n+                        lint.build(&format!(\"type uses owned (Box type) pointers: {}\", ty)).emit()\n+                    });\n+                }\n             }\n         }\n     }"}, {"sha": "79fa13b0b4a1d3645be188dc598ebc9074079c11", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -19,7 +19,6 @@ use crate::traits::{self, Reveal};\n use crate::ty;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::{Discr, IntTypeExt};\n-use crate::ty::walk::TypeWalker;\n use rustc_ast::ast::{self, Ident, Name};\n use rustc_ast::node_id::{NodeId, NodeMap, NodeSet};\n use rustc_attr as attr;\n@@ -2686,39 +2685,6 @@ impl<'tcx> ClosureKind {\n     }\n }\n \n-impl<'tcx> TyS<'tcx> {\n-    /// Iterator that walks `self` and any types reachable from\n-    /// `self`, in depth-first order. Note that just walks the types\n-    /// that appear in `self`, it does not descend into the fields of\n-    /// structs or variants. For example:\n-    ///\n-    /// ```notrust\n-    /// isize => { isize }\n-    /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n-    /// [isize] => { [isize], isize }\n-    /// ```\n-    pub fn walk(&'tcx self) -> TypeWalker<'tcx> {\n-        TypeWalker::new(self.into())\n-    }\n-\n-    /// Walks `ty` and any types appearing within `ty`, invoking the\n-    /// callback `f` on each type. If the callback returns `false`, then the\n-    /// children of the current type are ignored.\n-    ///\n-    /// Note: prefer `ty.walk()` where possible.\n-    pub fn maybe_walk<F>(&'tcx self, mut f: F)\n-    where\n-        F: FnMut(Ty<'tcx>) -> bool,\n-    {\n-        let mut walker = self.walk();\n-        while let Some(ty) = walker.next() {\n-            if !f(ty) {\n-                walker.skip_current_subtree();\n-            }\n-        }\n-    }\n-}\n-\n impl BorrowKind {\n     pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n         match m {"}, {"sha": "c7a317f39ad71a7f0db83246871ec77681950e6f", "filename": "src/librustc_middle/ty/walk.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fwalk.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -1,8 +1,8 @@\n //! An iterator over the type substructure.\n //! WARNING: this does not keep track of the region depth.\n \n+use crate::ty;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n-use crate::ty::{self, Ty};\n use smallvec::{self, SmallVec};\n \n // The TypeWalker's stack is hot enough that it's worth going to some effort to\n@@ -37,27 +37,33 @@ impl<'tcx> TypeWalker<'tcx> {\n }\n \n impl<'tcx> Iterator for TypeWalker<'tcx> {\n-    type Item = Ty<'tcx>;\n+    type Item = GenericArg<'tcx>;\n \n-    fn next(&mut self) -> Option<Ty<'tcx>> {\n+    fn next(&mut self) -> Option<GenericArg<'tcx>> {\n         debug!(\"next(): stack={:?}\", self.stack);\n-        while let Some(next) = self.stack.pop() {\n-            self.last_subtree = self.stack.len();\n-            push_inner(&mut self.stack, next);\n-            debug!(\"next: stack={:?}\", self.stack);\n-\n-            // FIXME(eddyb) remove this filter and expose all `GenericArg`s.\n-            match next.unpack() {\n-                GenericArgKind::Type(ty) => return Some(ty),\n-                GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => {}\n-            }\n-        }\n-\n-        None\n+        let next = self.stack.pop()?;\n+        self.last_subtree = self.stack.len();\n+        push_inner(&mut self.stack, next);\n+        debug!(\"next: stack={:?}\", self.stack);\n+        Some(next)\n     }\n }\n \n impl GenericArg<'tcx> {\n+    /// Iterator that walks `self` and any types reachable from\n+    /// `self`, in depth-first order. Note that just walks the types\n+    /// that appear in `self`, it does not descend into the fields of\n+    /// structs or variants. For example:\n+    ///\n+    /// ```notrust\n+    /// isize => { isize }\n+    /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n+    /// [isize] => { [isize], isize }\n+    /// ```\n+    pub fn walk(self) -> TypeWalker<'tcx> {\n+        TypeWalker::new(self)\n+    }\n+\n     /// Iterator that walks the immediate children of `self`. Hence\n     /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n     /// (but not `i32`, like `walk`).\n@@ -68,6 +74,22 @@ impl GenericArg<'tcx> {\n     }\n }\n \n+impl<'tcx> super::TyS<'tcx> {\n+    /// Iterator that walks `self` and any types reachable from\n+    /// `self`, in depth-first order. Note that just walks the types\n+    /// that appear in `self`, it does not descend into the fields of\n+    /// structs or variants. For example:\n+    ///\n+    /// ```notrust\n+    /// isize => { isize }\n+    /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n+    /// [isize] => { [isize], isize }\n+    /// ```\n+    pub fn walk(&'tcx self) -> TypeWalker<'tcx> {\n+        TypeWalker::new(self.into())\n+    }\n+}\n+\n // We push `GenericArg`s on the stack in reverse order so as to\n // maintain a pre-order traversal. As of the time of this\n // writing, the fact that the traversal is pre-order is not"}, {"sha": "d8ceda96a25e1d4984188e94f38ea13870000b03", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -191,7 +191,7 @@ use rustc_middle::mir::visit::Visitor as MirVisitor;\n use rustc_middle::mir::{self, Local, Location};\n use rustc_middle::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc_middle::ty::print::obsolete::DefPathBasedNames;\n-use rustc_middle::ty::subst::InternalSubsts;\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable};\n use rustc_session::config::EntryFnType;\n use smallvec::SmallVec;\n@@ -442,9 +442,16 @@ fn check_recursion_limit<'tcx>(\n }\n \n fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n-    let type_length = instance.substs.types().flat_map(|ty| ty.walk()).count();\n-    let const_length = instance.substs.consts().flat_map(|ct| ct.ty.walk()).count();\n-    debug!(\" => type length={}, const length={}\", type_length, const_length);\n+    let type_length = instance\n+        .substs\n+        .iter()\n+        .flat_map(|&arg| arg.walk())\n+        .filter(|arg| match arg.unpack() {\n+            GenericArgKind::Type(_) | GenericArgKind::Const(_) => true,\n+            GenericArgKind::Lifetime(_) => false,\n+        })\n+        .count();\n+    debug!(\" => type length={}\", type_length);\n \n     // Rust code can easily create exponentially-long types using only a\n     // polynomial recursion depth. Even with the default recursion\n@@ -453,11 +460,7 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     //\n     // Bail out in these cases to avoid that bad user experience.\n     let type_length_limit = *tcx.sess.type_length_limit.get();\n-    // We include the const length in the type length, as it's better\n-    // to be overly conservative.\n-    // FIXME(const_generics): we should instead uniformly walk through `substs`,\n-    // ignoring lifetimes.\n-    if type_length + const_length > type_length_limit {\n+    if type_length > type_length_limit {\n         // The instance name is already known to be too long for rustc.\n         // Show only the first and last 32 characters to avoid blasting\n         // the user's terminal with thousands of lines of type-name."}, {"sha": "8f7a1b948e3fd8f5a48ffc84c57ac1351937dd12", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -2,6 +2,7 @@ use rustc_attr as attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, adjustment::PointerCast, Predicate, Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n@@ -92,7 +93,15 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n }\n \n fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n-    for ty in ty.walk() {\n+    for arg in ty.walk() {\n+        let ty = match arg.unpack() {\n+            GenericArgKind::Type(ty) => ty,\n+\n+            // No constraints on lifetimes or constants, except potentially\n+            // constants' types, but `walk` will get to them as well.\n+            GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => continue,\n+        };\n+\n         match ty.kind {\n             ty::Ref(_, _, hir::Mutability::Mut) => {\n                 if !feature_allowed(tcx, fn_def_id, sym::const_mut_refs) {"}, {"sha": "49a4b96f8b7a1ca9563630214548b0899dd51992", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -536,18 +536,17 @@ fn trait_ref_type_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> Vec<TyOrConstInferVar<'tcx>> {\n-    trait_ref\n+    selcx\n+        .infcx()\n+        .resolve_vars_if_possible(&trait_ref)\n         .skip_binder() // ok b/c this check doesn't care about regions\n-        // FIXME(eddyb) walk over `GenericArg` to support const infer vars.\n-        .input_types()\n-        .map(|ty| selcx.infcx().resolve_vars_if_possible(&ty))\n-        // FIXME(eddyb) try using `maybe_walk` to skip *all* subtrees that\n-        // don't contain inference variables, not just the outermost level.\n-        // FIXME(eddyb) use `has_infer_types_or_const`.\n-        .filter(|ty| ty.has_infer_types())\n-        .flat_map(|ty| ty.walk())\n-        // FIXME(eddyb) use `TyOrConstInferVar::maybe_from_generic_arg`.\n-        .filter_map(TyOrConstInferVar::maybe_from_ty)\n+        .substs\n+        .iter()\n+        // FIXME(eddyb) try using `skip_current_subtree` to skip everything that\n+        // doesn't contain inference variables, not just the outermost level.\n+        .filter(|arg| arg.has_infer_types_or_consts())\n+        .flat_map(|arg| arg.walk())\n+        .filter_map(TyOrConstInferVar::maybe_from_generic_arg)\n         .collect()\n }\n "}, {"sha": "fc2e984e34dd8ca494474bb9ac70d5018c1702f8", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -16,7 +16,7 @@ use crate::traits::{self, Obligation, ObligationCause};\n use rustc_errors::{Applicability, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n use rustc_span::symbol::Symbol;\n@@ -234,7 +234,7 @@ fn predicates_reference_self(\n         tcx.predicates_of(trait_def_id)\n     };\n     let self_ty = tcx.types.self_param;\n-    let has_self_ty = |t: Ty<'_>| t.walk().any(|t| t == self_ty);\n+    let has_self_ty = |t: Ty<'_>| t.walk().any(|arg| arg == self_ty.into());\n     predicates\n         .predicates\n         .iter()\n@@ -725,19 +725,17 @@ fn contains_illegal_self_type_reference<'tcx>(\n     // without knowing what `Self` is.\n \n     let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n-    let mut error = false;\n     let self_ty = tcx.types.self_param;\n-    ty.maybe_walk(|ty| {\n-        match ty.kind {\n-            ty::Param(_) => {\n-                if ty == self_ty {\n-                    error = true;\n-                }\n \n-                false // no contained types to walk\n-            }\n+    let mut walker = ty.walk();\n+    while let Some(arg) = walker.next() {\n+        if arg == self_ty.into() {\n+            return true;\n+        }\n \n-            ty::Projection(ref data) => {\n+        // Special-case projections (everything else is walked normally).\n+        if let GenericArgKind::Type(ty) = arg.unpack() {\n+            if let ty::Projection(ref data) = ty.kind {\n                 // This is a projected type `<Foo as SomeTrait>::X`.\n \n                 // Compute supertraits of current trait lazily.\n@@ -759,17 +757,18 @@ fn contains_illegal_self_type_reference<'tcx>(\n                     supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n \n                 if is_supertrait_of_current_trait {\n-                    false // do not walk contained types, do not report error, do collect $200\n-                } else {\n-                    true // DO walk contained types, POSSIBLY reporting an error\n+                    // Do not walk contained types, do not report error, do collect $200.\n+                    walker.skip_current_subtree();\n                 }\n-            }\n \n-            _ => true, // walk contained types, if any\n+                // DO walk contained types, POSSIBLY reporting an error.\n+            }\n         }\n-    });\n \n-    error\n+        // Walk contained types, if any.\n+    }\n+\n+    false\n }\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {"}, {"sha": "ed547cac5828f8f7189d4ac6a27df85842577b9c", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 48, "deletions": 39, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -44,7 +44,7 @@ use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n use rustc_middle::ty::{\n     self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n@@ -1242,9 +1242,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         result: &SelectionResult<'tcx, SelectionCandidate<'tcx>>,\n     ) -> bool {\n         match result {\n-            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => {\n-                !trait_ref.skip_binder().input_types().any(|t| t.walk().any(|t_| t_.is_ty_infer()))\n-            }\n+            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => !trait_ref.has_local_value(),\n             _ => true,\n         }\n     }\n@@ -3048,68 +3046,79 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             // `Struct<T>` -> `Struct<U>`\n             (&ty::Adt(def, substs_a), &ty::Adt(_, substs_b)) => {\n-                let fields =\n-                    def.all_fields().map(|field| tcx.type_of(field.did)).collect::<Vec<_>>();\n-\n-                // The last field of the structure has to exist and contain type parameters.\n-                let field = if let Some(&field) = fields.last() {\n-                    field\n-                } else {\n-                    return Err(Unimplemented);\n+                let maybe_unsizing_param_idx = |arg: GenericArg<'tcx>| match arg.unpack() {\n+                    GenericArgKind::Type(ty) => match ty.kind {\n+                        ty::Param(p) => Some(p.index),\n+                        _ => None,\n+                    },\n+\n+                    // Lifetimes aren't allowed to change during unsizing.\n+                    GenericArgKind::Lifetime(_) => None,\n+\n+                    GenericArgKind::Const(ct) => match ct.val {\n+                        ty::ConstKind::Param(p) => Some(p.index),\n+                        _ => None,\n+                    },\n                 };\n-                let mut ty_params = GrowableBitSet::new_empty();\n+\n+                // The last field of the structure has to exist and contain type/const parameters.\n+                let (tail_field, prefix_fields) =\n+                    def.non_enum_variant().fields.split_last().ok_or(Unimplemented)?;\n+                let tail_field_ty = tcx.type_of(tail_field.did);\n+\n+                let mut unsizing_params = GrowableBitSet::new_empty();\n                 let mut found = false;\n-                for ty in field.walk() {\n-                    if let ty::Param(p) = ty.kind {\n-                        ty_params.insert(p.index as usize);\n+                for arg in tail_field_ty.walk() {\n+                    if let Some(i) = maybe_unsizing_param_idx(arg) {\n+                        unsizing_params.insert(i);\n                         found = true;\n                     }\n                 }\n                 if !found {\n                     return Err(Unimplemented);\n                 }\n \n-                // Replace type parameters used in unsizing with\n-                // Error and ensure they do not affect any other fields.\n-                // This could be checked after type collection for any struct\n-                // with a potentially unsized trailing field.\n-                let params = substs_a\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, &k)| if ty_params.contains(i) { tcx.types.err.into() } else { k });\n-                let substs = tcx.mk_substs(params);\n-                for &ty in fields.split_last().unwrap().1 {\n-                    if ty.subst(tcx, substs).references_error() {\n-                        return Err(Unimplemented);\n+                // Ensure none of the other fields mention the parameters used\n+                // in unsizing.\n+                // FIXME(eddyb) cache this (including computing `unsizing_params`)\n+                // by putting it in a query; it would only need the `DefId` as it\n+                // looks at declared field types, not anything substituted.\n+                for field in prefix_fields {\n+                    for arg in tcx.type_of(field.did).walk() {\n+                        if let Some(i) = maybe_unsizing_param_idx(arg) {\n+                            if unsizing_params.contains(i) {\n+                                return Err(Unimplemented);\n+                            }\n+                        }\n                     }\n                 }\n \n-                // Extract `Field<T>` and `Field<U>` from `Struct<T>` and `Struct<U>`.\n-                let inner_source = field.subst(tcx, substs_a);\n-                let inner_target = field.subst(tcx, substs_b);\n+                // Extract `TailField<T>` and `TailField<U>` from `Struct<T>` and `Struct<U>`.\n+                let source_tail = tail_field_ty.subst(tcx, substs_a);\n+                let target_tail = tail_field_ty.subst(tcx, substs_b);\n \n                 // Check that the source struct with the target's\n-                // unsized parameters is equal to the target.\n-                let params = substs_a.iter().enumerate().map(|(i, &k)| {\n-                    if ty_params.contains(i) { substs_b.type_at(i).into() } else { k }\n-                });\n-                let new_struct = tcx.mk_adt(def, tcx.mk_substs(params));\n+                // unsizing parameters is equal to the target.\n+                let substs = tcx.mk_substs(substs_a.iter().enumerate().map(|(i, &k)| {\n+                    if unsizing_params.contains(i as u32) { substs_b[i] } else { k }\n+                }));\n+                let new_struct = tcx.mk_adt(def, substs);\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n                     .eq(target, new_struct)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n-                // Construct the nested `Field<T>: Unsize<Field<U>>` predicate.\n+                // Construct the nested `TailField<T>: Unsize<TailField<U>>` predicate.\n                 nested.push(predicate_for_trait_def(\n                     tcx,\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),\n                     obligation.recursion_depth + 1,\n-                    inner_source,\n-                    &[inner_target.into()],\n+                    source_tail,\n+                    &[target_tail.into()],\n                 ));\n             }\n "}, {"sha": "6b38749e1e70ab4afb7d5a3f344401849a5d7240", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -4,7 +4,7 @@ use crate::traits::{self, AssocTypeBoundData};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items;\n-use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n@@ -391,9 +391,21 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     /// is WF. Returns false if `ty0` is an unresolved type variable,\n     /// in which case we are not able to simplify at all.\n     fn compute(&mut self, ty0: Ty<'tcx>) -> bool {\n-        let mut subtys = ty0.walk();\n+        let mut walker = ty0.walk();\n         let param_env = self.param_env;\n-        while let Some(ty) = subtys.next() {\n+        while let Some(arg) = walker.next() {\n+            let ty = match arg.unpack() {\n+                GenericArgKind::Type(ty) => ty,\n+\n+                // No WF constraints for lifetimes being present, any outlives\n+                // obligations are handled by the parent (e.g. `ty::Ref`).\n+                GenericArgKind::Lifetime(_) => continue,\n+\n+                // FIXME(eddyb) this is wrong and needs to be replaced\n+                // (see https://github.com/rust-lang/rust/pull/70107).\n+                GenericArgKind::Const(_) => continue,\n+            };\n+\n             match ty.kind {\n                 ty::Bool\n                 | ty::Char\n@@ -417,6 +429,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n                 ty::Array(subty, len) => {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n+                    // FIXME(eddyb) handle `GenericArgKind::Const` above instead.\n                     self.compute_array_len(*len);\n                 }\n \n@@ -433,7 +446,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 }\n \n                 ty::Projection(data) => {\n-                    subtys.skip_current_subtree(); // subtree handled by compute_projection\n+                    walker.skip_current_subtree(); // subtree handled by compute_projection\n                     self.compute_projection(data);\n                 }\n \n@@ -504,7 +517,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // are not directly inspecting closure types\n                     // anyway, except via auto trait matching (which\n                     // only inspects the upvar types).\n-                    subtys.skip_current_subtree(); // subtree handled by compute_projection\n+                    walker.skip_current_subtree(); // subtree handled by compute_projection\n                     for upvar_ty in substs.as_closure().upvar_tys() {\n                         self.compute(upvar_ty);\n                     }"}, {"sha": "612ab9b70ebc9d061735a80ab8b2e70121b459bc", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -3,6 +3,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::traits::{\n     Clause, Clauses, DomainGoal, Environment, FromEnv, ProgramClause, ProgramClauseCategory,\n };\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n struct ClauseVisitor<'a, 'tcx> {\n@@ -210,22 +211,23 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n         _ => NodeKind::Other,\n     };\n \n-    let mut input_tys = FxHashSet::default();\n+    // FIXME(eddyb) isn't the unordered nature of this a hazard?\n+    let mut inputs = FxHashSet::default();\n \n     match node_kind {\n         // In a trait impl, we assume that the header trait ref and all its\n         // constituents are well-formed.\n         NodeKind::TraitImpl => {\n             let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n \n-            input_tys.extend(trait_ref.input_types().flat_map(|ty| ty.walk()));\n+            inputs.extend(trait_ref.substs.iter().flat_map(|&arg| arg.walk()));\n         }\n \n         // In an inherent impl, we assume that the receiver type and all its\n         // constituents are well-formed.\n         NodeKind::InherentImpl => {\n             let self_ty = tcx.type_of(def_id);\n-            input_tys.extend(self_ty.walk());\n+            inputs.extend(self_ty.walk());\n         }\n \n         // In an fn, we assume that the arguments and all their constituents are\n@@ -234,16 +236,27 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n             let fn_sig = tcx.fn_sig(def_id);\n             let fn_sig = tcx.liberate_late_bound_regions(def_id, &fn_sig);\n \n-            input_tys.extend(fn_sig.inputs().iter().flat_map(|ty| ty.walk()));\n+            inputs.extend(fn_sig.inputs().iter().flat_map(|ty| ty.walk()));\n         }\n \n         NodeKind::Other => (),\n     }\n \n     let clauses = clauses.chain(\n-        input_tys\n+        inputs\n             .into_iter()\n-            .map(|ty| DomainGoal::FromEnv(FromEnv::Ty(ty)))\n+            .filter_map(|arg| {\n+                match arg.unpack() {\n+                    GenericArgKind::Type(ty) => Some(FromEnv::Ty(ty)),\n+\n+                    // FIXME(eddyb) no WF conditions from lifetimes?\n+                    GenericArgKind::Lifetime(_) => None,\n+\n+                    // FIXME(eddyb) support const generics in Chalk\n+                    GenericArgKind::Const(_) => None,\n+                }\n+            })\n+            .map(DomainGoal::FromEnv)\n             .map(|domain_goal| domain_goal.into_program_clause())\n             .map(Clause::Implies),\n     );"}, {"sha": "ed7ec1c3b10da39e99e72279d0e68aa86fd02265", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -737,8 +737,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let default_needs_object_self = |param: &ty::GenericParamDef| {\n             if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n                 if is_object && has_default {\n+                    let default_ty = tcx.at(span).type_of(param.def_id);\n                     let self_param = tcx.types.self_param;\n-                    if tcx.at(span).type_of(param.def_id).walk().any(|ty| ty == self_param) {\n+                    if default_ty.walk().any(|arg| arg == self_param.into()) {\n                         // There is no suitable inference default for a type parameter\n                         // that references self, in an object type.\n                         return true;\n@@ -1617,7 +1618,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ty::Predicate::Projection(pred) => {\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n-                        let references_self = pred.skip_binder().ty.walk().any(|t| t == dummy_self);\n+                        let references_self =\n+                            pred.skip_binder().ty.walk().any(|arg| arg == dummy_self.into());\n \n                         // If the projection output contains `Self`, force the user to\n                         // elaborate it explicitly to avoid a lot of complexity."}, {"sha": "eebc34d3db8eac479cb53d146339214d8c6aceb0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -102,6 +102,7 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items;\n use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, QPath};\n+use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n@@ -1767,7 +1768,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n             let pty_ty = tcx.type_of(def_id);\n             let generics = tcx.generics_of(def_id);\n-            check_bounds_are_used(tcx, &generics, pty_ty);\n+            check_type_params_are_used(tcx, &generics, pty_ty);\n         }\n         hir::ItemKind::ForeignMod(ref m) => {\n             check_abi(tcx, it.span, m.abi);\n@@ -4139,20 +4140,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // `FulfillmentError`.\n                 let mut referenced_in = final_arg_types\n                     .iter()\n-                    .map(|(i, checked_ty, _)| (i, checked_ty))\n-                    .chain(final_arg_types.iter().map(|(i, _, coerced_ty)| (i, coerced_ty)))\n+                    .map(|&(i, checked_ty, _)| (i, checked_ty))\n+                    .chain(final_arg_types.iter().map(|&(i, _, coerced_ty)| (i, coerced_ty)))\n                     .flat_map(|(i, ty)| {\n-                        let ty = self.resolve_vars_if_possible(ty);\n+                        let ty = self.resolve_vars_if_possible(&ty);\n                         // We walk the argument type because the argument's type could have\n                         // been `Option<T>`, but the `FulfillmentError` references `T`.\n-                        ty.walk()\n-                            .filter(|&ty| ty == predicate.skip_binder().self_ty())\n-                            .map(move |_| *i)\n+                        if ty.walk().any(|arg| arg == predicate.skip_binder().self_ty().into()) {\n+                            Some(i)\n+                        } else {\n+                            None\n+                        }\n                     })\n                     .collect::<Vec<_>>();\n \n                 // Both checked and coerced types could have matched, thus we need to remove\n                 // duplicates.\n+                referenced_in.sort();\n                 referenced_in.dedup();\n \n                 if let (Some(ref_in), None) = (referenced_in.pop(), referenced_in.pop()) {\n@@ -5744,43 +5748,47 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_bounds_are_used<'tcx>(tcx: TyCtxt<'tcx>, generics: &ty::Generics, ty: Ty<'tcx>) {\n-    let own_counts = generics.own_counts();\n-    debug!(\n-        \"check_bounds_are_used(n_tys={}, n_cts={}, ty={:?})\",\n-        own_counts.types, own_counts.consts, ty\n-    );\n+fn check_type_params_are_used<'tcx>(tcx: TyCtxt<'tcx>, generics: &ty::Generics, ty: Ty<'tcx>) {\n+    debug!(\"check_type_params_are_used(generics={:?}, ty={:?})\", generics, ty);\n+\n+    assert_eq!(generics.parent, None);\n \n-    if own_counts.types == 0 {\n+    if generics.own_counts().types == 0 {\n         return;\n     }\n \n-    // Make a vector of booleans initially `false`; set to `true` when used.\n-    let mut types_used = vec![false; own_counts.types];\n+    let mut params_used = BitSet::new_empty(generics.params.len());\n \n-    for leaf_ty in ty.walk() {\n-        if let ty::Param(ty::ParamTy { index, .. }) = leaf_ty.kind {\n-            debug!(\"found use of ty param num {}\", index);\n-            types_used[index as usize - own_counts.lifetimes] = true;\n-        } else if let ty::Error = leaf_ty.kind {\n-            // If there is already another error, do not emit\n-            // an error for not using a type parameter.\n-            assert!(tcx.sess.has_errors());\n-            return;\n+    if ty.references_error() {\n+        // If there is already another error, do not emit\n+        // an error for not using a type parameter.\n+        assert!(tcx.sess.has_errors());\n+        return;\n+    }\n+\n+    for leaf in ty.walk() {\n+        if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n+            if let ty::Param(param) = leaf_ty.kind {\n+                debug!(\"found use of ty param {:?}\", param);\n+                params_used.insert(param.index);\n+            }\n         }\n     }\n \n-    let types = generics.params.iter().filter(|param| match param.kind {\n-        ty::GenericParamDefKind::Type { .. } => true,\n-        _ => false,\n-    });\n-    for (&used, param) in types_used.iter().zip(types) {\n-        if !used {\n-            let id = tcx.hir().as_local_hir_id(param.def_id).unwrap();\n-            let span = tcx.hir().span(id);\n-            struct_span_err!(tcx.sess, span, E0091, \"type parameter `{}` is unused\", param.name)\n+    for param in &generics.params {\n+        if !params_used.contains(param.index) {\n+            if let ty::GenericParamDefKind::Type { .. } = param.kind {\n+                let span = tcx.def_span(param.def_id);\n+                struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0091,\n+                    \"type parameter `{}` is unused\",\n+                    param.name,\n+                )\n                 .span_label(span, \"unused type parameter\")\n                 .emit();\n+            }\n         }\n     }\n }"}, {"sha": "2abca30246905ebd28504c4da8f8092db519072b", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "patch": "@@ -119,7 +119,15 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n ) {\n-    for ty in field_ty.walk() {\n+    for arg in field_ty.walk() {\n+        let ty = match arg.unpack() {\n+            GenericArgKind::Type(ty) => ty,\n+\n+            // No predicates from lifetimes or constants, except potentially\n+            // constants' types, but `walk` will get to them as well.\n+            GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => continue,\n+        };\n+\n         match ty.kind {\n             // The field is of type &'a T which means that we will have\n             // a predicate requirement of T: 'a (T outlives 'a).\n@@ -303,7 +311,7 @@ pub fn check_explicit_predicates<'tcx>(\n         // 'b`.\n         if let Some(self_ty) = ignored_self_ty {\n             if let GenericArgKind::Type(ty) = outlives_predicate.0.unpack() {\n-                if ty.walk().any(|ty| ty == self_ty) {\n+                if ty.walk().any(|arg| arg == self_ty.into()) {\n                     debug!(\"skipping self ty = {:?}\", &ty);\n                     continue;\n                 }"}]}