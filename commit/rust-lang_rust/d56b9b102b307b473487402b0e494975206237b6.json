{"sha": "d56b9b102b307b473487402b0e494975206237b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NmI5YjEwMmIzMDdiNDczNDg3NDAyYjBlNDk0OTc1MjA2MjM3YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-21T01:51:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-21T01:51:55Z"}, "message": "auto merge of #8656 : toddaaro/rust/idle-opt+cleaning, r=brson\n\nFixed a memory leak caused by the singleton idle callback failing to close correctly. The problem was that the close function requires running inside a callback in the event loop, but we were trying to close the idle watcher after the loop returned from run. The fix was to just call run again to process this callback. There is an additional tweak to move the initialization logic fully into bootstrap, so tasks that do not ever call run do not have problems destructing.", "tree": {"sha": "85e3a24ee890729a3f7194bc39575343b6edc89b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85e3a24ee890729a3f7194bc39575343b6edc89b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d56b9b102b307b473487402b0e494975206237b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d56b9b102b307b473487402b0e494975206237b6", "html_url": "https://github.com/rust-lang/rust/commit/d56b9b102b307b473487402b0e494975206237b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d56b9b102b307b473487402b0e494975206237b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bc1ca404539102065ee0757944ce2288db4cb32", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bc1ca404539102065ee0757944ce2288db4cb32", "html_url": "https://github.com/rust-lang/rust/commit/0bc1ca404539102065ee0757944ce2288db4cb32"}, {"sha": "352ac2efdf825864335cd31e56fdda7352bb6a1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/352ac2efdf825864335cd31e56fdda7352bb6a1a", "html_url": "https://github.com/rust-lang/rust/commit/352ac2efdf825864335cd31e56fdda7352bb6a1a"}], "stats": {"total": 31, "additions": 17, "deletions": 14}, "files": [{"sha": "5ec2df32c48caaf6982d03d65a16ef2c97b56eac", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d56b9b102b307b473487402b0e494975206237b6/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56b9b102b307b473487402b0e494975206237b6/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=d56b9b102b307b473487402b0e494975206237b6", "patch": "@@ -80,7 +80,7 @@ pub struct Scheduler {\n     /// A fast XorShift rng for scheduler use\n     rng: XorShiftRng,\n     /// A toggleable idle callback\n-    idle_callback: ~PausibleIdleCallback\n+    idle_callback: Option<~PausibleIdleCallback>\n }\n \n impl Scheduler {\n@@ -107,9 +107,6 @@ impl Scheduler {\n                        friend: Option<SchedHandle>)\n         -> Scheduler {\n \n-        let mut event_loop = event_loop;\n-        let idle_callback = event_loop.pausible_idle_callback();\n-\n         Scheduler {\n             sleeper_list: sleeper_list,\n             message_queue: MessageQueue::new(),\n@@ -125,7 +122,7 @@ impl Scheduler {\n             run_anything: run_anything,\n             friend_handle: friend,\n             rng: XorShiftRng::new(),\n-            idle_callback: idle_callback\n+            idle_callback: None\n         }\n     }\n \n@@ -140,6 +137,9 @@ impl Scheduler {\n \n         let mut this = self;\n \n+        // Build an Idle callback.\n+        this.idle_callback = Some(this.event_loop.pausible_idle_callback());\n+\n         // Initialize the TLS key.\n         local_ptr::init_tls_key();\n \n@@ -153,7 +153,7 @@ impl Scheduler {\n         // Before starting our first task, make sure the idle callback\n         // is active. As we do not start in the sleep state this is\n         // important.\n-        this.idle_callback.start(Scheduler::run_sched_once);\n+        this.idle_callback.get_mut_ref().start(Scheduler::run_sched_once);\n \n         // Now, as far as all the scheduler state is concerned, we are\n         // inside the \"scheduler\" context. So we can act like the\n@@ -169,6 +169,12 @@ impl Scheduler {\n         rtdebug!(\"starting scheduler %u\", sched.sched_id());\n         sched.run();\n \n+        // Close the idle callback.\n+        let mut sched = Local::take::<Scheduler>();\n+        sched.idle_callback.get_mut_ref().close();\n+        // Make one go through the loop to run the close callback.\n+        sched.run();\n+\n         // Now that we are done with the scheduler, clean up the\n         // scheduler task. Do so by removing it from TLS and manually\n         // cleaning up the memory it uses. As we didn't actually call\n@@ -182,9 +188,6 @@ impl Scheduler {\n         let message = stask.sched.get_mut_ref().message_queue.pop();\n         assert!(message.is_none());\n \n-        // Close the idle callback.\n-        stask.sched.get_mut_ref().idle_callback.close();\n-\n         stask.destroyed = true;\n     }\n \n@@ -230,7 +233,7 @@ impl Scheduler {\n \n         // Assume that we need to continue idling unless we reach the\n         // end of this function without performing an action.\n-        sched.idle_callback.resume();\n+        sched.idle_callback.get_mut_ref().resume();\n \n         // First we check for scheduler messages, these are higher\n         // priority than regular tasks.\n@@ -257,12 +260,12 @@ impl Scheduler {\n             let handle = sched.make_handle();\n             sched.sleeper_list.push(handle);\n             // Since we are sleeping, deactivate the idle callback.\n-            sched.idle_callback.pause();\n+            sched.idle_callback.get_mut_ref().pause();\n         } else {\n             rtdebug!(\"not sleeping, already doing so or no_sleep set\");\n             // We may not be sleeping, but we still need to deactivate\n             // the idle callback.\n-            sched.idle_callback.pause();\n+            sched.idle_callback.get_mut_ref().pause();\n         }\n \n         // Finished a cycle without using the Scheduler. Place it back\n@@ -461,7 +464,7 @@ impl Scheduler {\n \n         // We push the task onto our local queue clone.\n         this.work_queue.push(task);\n-        this.idle_callback.resume();\n+        this.idle_callback.get_mut_ref().resume();\n \n         // We've made work available. Notify a\n         // sleeping scheduler."}, {"sha": "6920e776a09e536b0b620a56df035bcbfcd998e5", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d56b9b102b307b473487402b0e494975206237b6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56b9b102b307b473487402b0e494975206237b6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=d56b9b102b307b473487402b0e494975206237b6", "patch": "@@ -219,7 +219,7 @@ impl UvPausibleIdleCallback {\n         self.pause();\n         if !self.closed {\n             self.closed = true;\n-            self.watcher.close(||());\n+            self.watcher.close(||{});\n         }\n     }\n }"}]}