{"sha": "9e0c59614143abae80b155ca835758e27f286d14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMGM1OTYxNDE0M2FiYWU4MGIxNTVjYTgzNTc1OGUyN2YyODZkMTQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-03T00:03:35Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-03T00:11:57Z"}, "message": "rustc: Eliminate the necessity of having an expr in order to call lookup_vtables(). rs=#rust\n\nAutomatically-generated derived methods don't have exprs and need to call this function.", "tree": {"sha": "0a6959fe190779ba2ff7334957151c21798fc45b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a6959fe190779ba2ff7334957151c21798fc45b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e0c59614143abae80b155ca835758e27f286d14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e0c59614143abae80b155ca835758e27f286d14", "html_url": "https://github.com/rust-lang/rust/commit/9e0c59614143abae80b155ca835758e27f286d14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e0c59614143abae80b155ca835758e27f286d14/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2f33e6883fcce83d33aa5375e5ea018759b245a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2f33e6883fcce83d33aa5375e5ea018759b245a", "html_url": "https://github.com/rust-lang/rust/commit/e2f33e6883fcce83d33aa5375e5ea018759b245a"}], "stats": {"total": 124, "additions": 80, "deletions": 44}, "files": [{"sha": "4d49da93a9d2b43ea3f6647ca5669b6164f99de3", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e0c59614143abae80b155ca835758e27f286d14/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e0c59614143abae80b155ca835758e27f286d14/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=9e0c59614143abae80b155ca835758e27f286d14", "patch": "@@ -78,6 +78,7 @@ use typeck::infer::{resolve_type, force_tvar};\n use result::{Result, Ok, Err};\n use syntax::print::pprust;\n use syntax::parse::token::special_idents;\n+use vtable::LocationInfo;\n \n use std::map::HashMap;\n \n@@ -865,7 +866,8 @@ fn check_expr(fcx: @fn_ctxt, expr: @ast::expr,\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n fn impl_self_ty(fcx: @fn_ctxt,\n-                expr: @ast::expr, // (potential) receiver for this impl\n+                location_info: &LocationInfo, // (potential) receiver for\n+                                              // this impl\n                 did: ast::def_id) -> ty_param_substs_and_ty {\n     let tcx = fcx.ccx.tcx;\n \n@@ -902,7 +904,8 @@ fn impl_self_ty(fcx: @fn_ctxt,\n     };\n \n     let self_r = if region_param.is_some() {\n-        Some(fcx.infcx().next_region_var(expr.span, expr.id))\n+        Some(fcx.infcx().next_region_var(location_info.span,\n+                                         location_info.id))\n     } else {\n         None\n     };"}, {"sha": "b4cc65def483c133c59e15ca43b9148dea8c129d", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e0c59614143abae80b155ca835758e27f286d14/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e0c59614143abae80b155ca835758e27f286d14/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=9e0c59614143abae80b155ca835758e27f286d14", "patch": "@@ -491,8 +491,9 @@ impl LookupContext {\n \n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n+        let location_info = &vtable::location_info_for_expr(self.self_expr);\n         let {substs: impl_substs, ty: impl_ty} =\n-            impl_self_ty(self.fcx, self.self_expr, impl_info.did);\n+            impl_self_ty(self.fcx, location_info, impl_info.did);\n \n         let (impl_ty, impl_substs) =\n             self.create_rcvr_ty_and_substs_for_method("}, {"sha": "ae7b180f7949854dc31c90de436307c13db58903", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 73, "deletions": 41, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/9e0c59614143abae80b155ca835758e27f286d14/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e0c59614143abae80b155ca835758e27f286d14/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9e0c59614143abae80b155ca835758e27f286d14", "patch": "@@ -1,6 +1,7 @@\n use check::{fn_ctxt, impl_self_ty};\n use infer::{resolve_type, resolve_and_force_all_but_regions,\n                fixup_err_to_str};\n+use syntax::codemap::span;\n use syntax::print::pprust;\n use result::{Result, Ok, Err};\n use util::common::indenter;\n@@ -21,6 +22,14 @@ use util::common::indenter;\n // would require much more care, and this seems to work decently in\n // practice.)\n \n+/// Location info records the span and ID of the expression or item that is\n+/// responsible for this vtable instantiation. (This may not be an expression\n+/// if the vtable instantiation is being performed as part of \"deriving\".)\n+struct LocationInfo {\n+    span: span,\n+    id: ast::node_id\n+}\n+\n fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     vec::any(tps, |bs| {\n         bs.any(|b| {\n@@ -30,16 +39,16 @@ fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n }\n \n fn lookup_vtables(fcx: @fn_ctxt,\n-                  expr: @ast::expr,\n+                  location_info: &LocationInfo,\n                   bounds: @~[ty::param_bounds],\n                   substs: &ty::substs,\n                   allow_unsafe: bool,\n                   is_early: bool) -> vtable_res\n {\n-    debug!(\"lookup_vtables(expr=%?/%s, \\\n+    debug!(\"lookup_vtables(location_info=%?,\n             # bounds=%?, \\\n             substs=%s\",\n-           expr.id, fcx.expr_to_str(expr),\n+           location_info,\n            bounds.len(),\n            ty::substs_to_str(fcx.tcx(), substs));\n     let _i = indenter();\n@@ -51,12 +60,12 @@ fn lookup_vtables(fcx: @fn_ctxt,\n             match *bound {\n               ty::bound_trait(i_ty) => {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n-                match lookup_vtable_covariant(fcx, expr, *ty, i_ty,\n+                match lookup_vtable_covariant(fcx, location_info, *ty, i_ty,\n                                               allow_unsafe, is_early) {\n                     Some(vtable) => result.push(vtable),\n                     None => {\n                         fcx.tcx().sess.span_fatal(\n-                            expr.span,\n+                            location_info.span,\n                             fmt!(\"failed to find an implementation of trait \\\n                                   %s for %s\",\n                                  ty_to_str(fcx.tcx(), i_ty),\n@@ -72,29 +81,29 @@ fn lookup_vtables(fcx: @fn_ctxt,\n     @result\n }\n \n-fn fixup_substs(fcx: @fn_ctxt, expr: @ast::expr,\n+fn fixup_substs(fcx: @fn_ctxt, location_info: &LocationInfo,\n                 id: ast::def_id, substs: ty::substs,\n                 is_early: bool) -> Option<ty::substs> {\n     let tcx = fcx.ccx.tcx;\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx, id, substs, ty::vstore_slice(ty::re_static));\n-    do fixup_ty(fcx, expr, t, is_early).map |t_f| {\n+    do fixup_ty(fcx, location_info, t, is_early).map |t_f| {\n         match ty::get(*t_f).sty {\n           ty::ty_trait(_, substs_f, _) => substs_f,\n           _ => fail ~\"t_f should be a trait\"\n         }\n     }\n }\n \n-fn relate_trait_tys(fcx: @fn_ctxt, expr: @ast::expr,\n+fn relate_trait_tys(fcx: @fn_ctxt, location_info: &LocationInfo,\n                     exp_trait_ty: ty::t, act_trait_ty: ty::t) {\n-    demand::suptype(fcx, expr.span, exp_trait_ty, act_trait_ty)\n+    demand::suptype(fcx, location_info.span, exp_trait_ty, act_trait_ty)\n }\n \n // Look up the vtable to use when treating an item of type `t` as if it has\n // type `trait_ty`. This does allow subtraits.\n fn lookup_vtable_covariant(fcx: @fn_ctxt,\n-                           expr: @ast::expr,\n+                           location_info: &LocationInfo,\n                            ty: ty::t,\n                            trait_ty: ty::t,\n                            allow_unsafe: bool,\n@@ -108,7 +117,7 @@ fn lookup_vtable_covariant(fcx: @fn_ctxt,\n     worklist.push(trait_ty);\n     while worklist.len() > 0 {\n         let trait_ty = worklist.pop();\n-        let result = lookup_vtable_invariant(fcx, expr, ty, trait_ty,\n+        let result = lookup_vtable_invariant(fcx, location_info, ty, trait_ty,\n                                              allow_unsafe, is_early);\n         if result.is_some() {\n             return result;\n@@ -136,7 +145,7 @@ fn lookup_vtable_covariant(fcx: @fn_ctxt,\n                 }\n             }\n             _ => {\n-                fcx.ccx.tcx.sess.impossible_case(expr.span,\n+                fcx.ccx.tcx.sess.impossible_case(location_info.span,\n                                                  \"lookup_vtable_covariant: \\\n                                                   non-trait in worklist\");\n             }\n@@ -149,7 +158,7 @@ fn lookup_vtable_covariant(fcx: @fn_ctxt,\n // Look up the vtable to use when treating an item of type `t` as if it has\n // type `trait_ty`. This does not allow subtraits.\n fn lookup_vtable_invariant(fcx: @fn_ctxt,\n-                           expr: @ast::expr,\n+                           location_info: &LocationInfo,\n                            ty: ty::t,\n                            trait_ty: ty::t,\n                            allow_unsafe: bool,\n@@ -162,11 +171,11 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n     let tcx = fcx.ccx.tcx;\n     let (trait_id, trait_substs, trait_vstore) = match ty::get(trait_ty).sty {\n         ty::ty_trait(did, substs, vstore) => (did, substs, vstore),\n-        _ => tcx.sess.impossible_case(expr.span,\n+        _ => tcx.sess.impossible_case(location_info.span,\n                                       \"lookup_vtable_invariant: \\\n                                        don't know how to handle a non-trait\")\n     };\n-    let ty = match fixup_ty(fcx, expr, ty, is_early) {\n+    let ty = match fixup_ty(fcx, location_info, ty, is_early) {\n         Some(ty) => ty,\n         None => {\n             // fixup_ty can only fail if this is early resolution\n@@ -194,13 +203,13 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                                     debug!(\"(checking vtable) @0 relating \\\n                                             ty to trait ty with did %?\",\n                                            idid);\n-                                    relate_trait_tys(fcx, expr,\n+                                    relate_trait_tys(fcx, location_info,\n                                                      trait_ty, ity);\n                                     return Some(vtable_param(n, n_bound));\n                                 }\n                             }\n                             _ => tcx.sess.impossible_case(\n-                                expr.span,\n+                                location_info.span,\n                                 \"lookup_vtable_invariant: in loop, \\\n                                  don't know how to handle a non-trait ity\")\n                         }\n@@ -214,17 +223,17 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n             debug!(\"(checking vtable) @1 relating ty to trait ty with did %?\",\n                    did);\n \n-            relate_trait_tys(fcx, expr, trait_ty, ty);\n+            relate_trait_tys(fcx, location_info, trait_ty, ty);\n             if !allow_unsafe && !is_early {\n                 for vec::each(*ty::trait_methods(tcx, did)) |m| {\n                     if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n                         tcx.sess.span_err(\n-                            expr.span,\n+                            location_info.span,\n                             ~\"a boxed trait with self types may not be \\\n                               passed as a bounded type\");\n                     } else if (*m.tps).len() > 0u {\n                         tcx.sess.span_err(\n-                            expr.span,\n+                            location_info.span,\n                             ~\"a boxed trait with generic methods may not \\\n                               be passed as a bounded type\");\n \n@@ -300,10 +309,11 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                             // to some_trait.  If not, then we try the next\n                             // impl.\n                             let {substs: substs, ty: for_ty} =\n-                                impl_self_ty(fcx, expr, im.did);\n+                                impl_self_ty(fcx, location_info, im.did);\n                             let im_bs = ty::lookup_item_type(tcx,\n                                                              im.did).bounds;\n-                            match fcx.mk_subty(false, expr.span, ty, for_ty) {\n+                            match fcx.mk_subty(false, location_info.span, ty,\n+                                               for_ty) {\n                                 result::Err(_) => loop,\n                                 result::Ok(()) => ()\n                             }\n@@ -334,7 +344,8 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                                    fcx.infcx().ty_to_str(trait_ty),\n                                    fcx.infcx().ty_to_str(*of_ty));\n                             let of_ty = ty::subst(tcx, &substs, *of_ty);\n-                            relate_trait_tys(fcx, expr, trait_ty, of_ty);\n+                            relate_trait_tys(fcx, location_info, trait_ty,\n+                                             of_ty);\n \n                             // Recall that trait_ty -- the trait type\n                             // we're casting to -- is the trait with\n@@ -357,7 +368,7 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                             // resolve them.\n \n                             let substs_f = match fixup_substs(fcx,\n-                                                              expr,\n+                                                              location_info,\n                                                               trait_id,\n                                                               substs,\n                                                               is_early) {\n@@ -382,11 +393,14 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                             // to. connect_trait_tps requires these\n                             // lists of types to unify pairwise.\n \n-                            connect_trait_tps(fcx, expr, substs_f.tps,\n-                                              trait_tps, im.did,\n+                            connect_trait_tps(fcx,\n+                                              location_info,\n+                                              substs_f.tps,\n+                                              trait_tps,\n+                                              im.did,\n                                               trait_vstore);\n                             let subres = lookup_vtables(\n-                                fcx, expr, im_bs, &substs_f,\n+                                fcx, location_info, im_bs, &substs_f,\n                                 false, is_early);\n \n                             // Finally, we register that we found a\n@@ -408,7 +422,7 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                 _ => {\n                     if !is_early {\n                         fcx.ccx.tcx.sess.span_err(\n-                            expr.span,\n+                            location_info.span,\n                             ~\"multiple applicable methods in scope\");\n                     }\n                     return Some(found[0]);\n@@ -421,7 +435,7 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n }\n \n fn fixup_ty(fcx: @fn_ctxt,\n-            expr: @ast::expr,\n+            location_info: &LocationInfo,\n             ty: ty::t,\n             is_early: bool) -> Option<ty::t>\n {\n@@ -430,7 +444,7 @@ fn fixup_ty(fcx: @fn_ctxt,\n         Ok(new_type) => Some(new_type),\n         Err(e) if !is_early => {\n             tcx.sess.span_fatal(\n-                expr.span,\n+                location_info.span,\n                 fmt!(\"cannot determine a type \\\n                       for this bounded type parameter: %s\",\n                      fixup_err_to_str(e)))\n@@ -441,8 +455,11 @@ fn fixup_ty(fcx: @fn_ctxt,\n     }\n }\n \n-fn connect_trait_tps(fcx: @fn_ctxt, expr: @ast::expr, impl_tys: ~[ty::t],\n-                     trait_tys: ~[ty::t], impl_did: ast::def_id,\n+fn connect_trait_tps(fcx: @fn_ctxt,\n+                     location_info: &LocationInfo,\n+                     impl_tys: ~[ty::t],\n+                     trait_tys: ~[ty::t],\n+                     impl_did: ast::def_id,\n                      vstore: ty::vstore) {\n     let tcx = fcx.ccx.tcx;\n \n@@ -454,10 +471,10 @@ fn connect_trait_tps(fcx: @fn_ctxt, expr: @ast::expr, impl_tys: ~[ty::t],\n     match ty::get(trait_ty).sty {\n      ty::ty_trait(_, substs, _) => {\n          for vec::each2(substs.tps, trait_tys) |a, b| {\n-             demand::suptype(fcx, expr.span, *a, *b)\n+             demand::suptype(fcx, location_info.span, *a, *b)\n          }\n       }\n-     _ => tcx.sess.impossible_case(expr.span, \"connect_trait_tps: \\\n+     _ => tcx.sess.impossible_case(location_info.span, \"connect_trait_tps: \\\n             don't know how to handle a non-trait ty\")\n     }\n }\n@@ -469,6 +486,13 @@ fn insert_vtables(ccx: @crate_ctxt, callee_id: ast::node_id,\n     ccx.vtable_map.insert(callee_id, vtables);\n }\n \n+fn location_info_for_expr(expr: @ast::expr) -> LocationInfo {\n+    LocationInfo {\n+        span: expr.span,\n+        id: expr.id\n+    }\n+}\n+\n fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id %? (early: %b): %s\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n@@ -489,8 +513,9 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                             %s\",\n                            ty::param_bounds_to_str(fcx.tcx(), *bounds));\n                 }\n-                let vtbls = lookup_vtables(fcx, ex, item_ty.bounds,\n-                                           substs, false, is_early);\n+                let vtbls = lookup_vtables(fcx, &location_info_for_expr(ex),\n+                                           item_ty.bounds, substs, false,\n+                                           is_early);\n                 if !is_early { cx.vtable_map.insert(ex.id, vtbls); }\n             }\n           }\n@@ -514,8 +539,8 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                   _ => ex.callee_id\n                 };\n                 let substs = fcx.node_ty_substs(callee_id);\n-                let vtbls = lookup_vtables(fcx, ex, bounds,\n-                                           &substs, false, is_early);\n+                let vtbls = lookup_vtables(fcx, &location_info_for_expr(ex),\n+                                           bounds, &substs, false, is_early);\n                 if !is_early {\n                     insert_vtables(cx, callee_id, vtbls);\n                 }\n@@ -534,8 +559,13 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n             // XXX: This is invariant and shouldn't be. --pcw\n \n             let ty = fcx.expr_ty(src);\n-            let vtable_opt = lookup_vtable_invariant(fcx, ex, ty, target_ty,\n-                                                     true, is_early);\n+            let vtable_opt =\n+                lookup_vtable_invariant(fcx,\n+                                        &location_info_for_expr(ex),\n+                                        ty,\n+                                        target_ty,\n+                                        true,\n+                                        is_early);\n             match vtable_opt {\n                 None => {\n                     // Try the new-style boxed trait; \"@int as @Trait\".\n@@ -553,9 +583,11 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                                 (ty::ty_box(_), ty::vstore_box) |\n                                 (ty::ty_uniq(_), ty::vstore_uniq) |\n                                 (ty::ty_rptr(*), ty::vstore_slice(*)) => {\n+                                    let location_info =\n+                                        &location_info_for_expr(ex);\n                                     let vtable_opt =\n                                         lookup_vtable_invariant(fcx,\n-                                                                ex,\n+                                                                location_info,\n                                                                 mt.ty,\n                                                                 target_ty,\n                                                                 true,"}]}