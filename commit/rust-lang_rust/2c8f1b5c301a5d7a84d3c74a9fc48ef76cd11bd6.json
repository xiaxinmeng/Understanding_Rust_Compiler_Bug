{"sha": "2c8f1b5c301a5d7a84d3c74a9fc48ef76cd11bd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjOGYxYjVjMzAxYTVkN2E4NGQzYzc0YTlmYzQ4ZWY3NmNkMTFiZDY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-20T15:36:36Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-20T15:36:42Z"}, "message": "Rewrite extract_struct_from_enum_variant assist", "tree": {"sha": "46471ebd33a826073ab75abf4caf19a6f1375193", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46471ebd33a826073ab75abf4caf19a6f1375193"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c8f1b5c301a5d7a84d3c74a9fc48ef76cd11bd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c8f1b5c301a5d7a84d3c74a9fc48ef76cd11bd6", "html_url": "https://github.com/rust-lang/rust/commit/2c8f1b5c301a5d7a84d3c74a9fc48ef76cd11bd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c8f1b5c301a5d7a84d3c74a9fc48ef76cd11bd6/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa20a5064be85349d2d05abcd66f5662d3aecb0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa20a5064be85349d2d05abcd66f5662d3aecb0c", "html_url": "https://github.com/rust-lang/rust/commit/fa20a5064be85349d2d05abcd66f5662d3aecb0c"}], "stats": {"total": 176, "additions": 91, "deletions": 85}, "files": [{"sha": "1f800f82b3cb08b35b346cba675a846c7eceeed3", "filename": "crates/ide_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 91, "deletions": 85, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/2c8f1b5c301a5d7a84d3c74a9fc48ef76cd11bd6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8f1b5c301a5d7a84d3c74a9fc48ef76cd11bd6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=2c8f1b5c301a5d7a84d3c74a9fc48ef76cd11bd6", "patch": "@@ -15,7 +15,7 @@ use rustc_hash::FxHashSet;\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, make, AstNode, NameOwner, VisibilityOwner},\n-    ted, SourceFile, SyntaxElement, SyntaxNode, T,\n+    ted, SyntaxNode, T,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -62,6 +62,7 @@ pub(crate) fn extract_struct_from_enum_variant(\n             let mut visited_modules_set = FxHashSet::default();\n             let current_module = enum_hir.module(ctx.db());\n             visited_modules_set.insert(current_module);\n+            // record file references of the file the def resides in, we only want to swap to the edited file in the builder once\n             let mut def_file_references = None;\n             for (file_id, references) in usages {\n                 if file_id == ctx.frange.file_id {\n@@ -70,36 +71,57 @@ pub(crate) fn extract_struct_from_enum_variant(\n                 }\n                 builder.edit_file(file_id);\n                 let source_file = builder.make_ast_mut(ctx.sema.parse(file_id));\n-                for reference in references {\n-                    update_reference(\n-                        ctx,\n-                        reference,\n-                        &source_file,\n-                        &enum_module_def,\n-                        &variant_hir_name,\n-                        &mut visited_modules_set,\n+                let processed = process_references(\n+                    ctx,\n+                    &mut visited_modules_set,\n+                    source_file.syntax(),\n+                    &enum_module_def,\n+                    &variant_hir_name,\n+                    references,\n+                );\n+                processed.into_iter().for_each(|(segment, node, import)| {\n+                    if let Some((scope, path)) = import {\n+                        insert_use(&scope, mod_path_to_ast(&path), ctx.config.insert_use);\n+                    }\n+                    ted::insert_raw(\n+                        ted::Position::before(segment.syntax()),\n+                        make::path_from_text(&format!(\"{}\", segment)).clone_for_update().syntax(),\n                     );\n-                }\n+                    ted::insert_raw(ted::Position::before(segment.syntax()), make::token(T!['(']));\n+                    ted::insert_raw(ted::Position::after(&node), make::token(T![')']));\n+                });\n             }\n             builder.edit_file(ctx.frange.file_id);\n-            let variant = builder.make_ast_mut(variant.clone());\n             let source_file = builder.make_ast_mut(ctx.sema.parse(ctx.frange.file_id));\n-            for reference in def_file_references.into_iter().flatten() {\n-                update_reference(\n+            let variant = builder.make_ast_mut(variant.clone());\n+            if let Some(references) = def_file_references {\n+                let processed = process_references(\n                     ctx,\n-                    reference,\n-                    &source_file,\n+                    &mut visited_modules_set,\n+                    source_file.syntax(),\n                     &enum_module_def,\n                     &variant_hir_name,\n-                    &mut visited_modules_set,\n+                    references,\n                 );\n+                processed.into_iter().for_each(|(segment, node, import)| {\n+                    if let Some((scope, path)) = import {\n+                        insert_use(&scope, mod_path_to_ast(&path), ctx.config.insert_use);\n+                    }\n+                    ted::insert_raw(\n+                        ted::Position::before(segment.syntax()),\n+                        make::path_from_text(&format!(\"{}\", segment)).clone_for_update().syntax(),\n+                    );\n+                    ted::insert_raw(ted::Position::before(segment.syntax()), make::token(T!['(']));\n+                    ted::insert_raw(ted::Position::after(&node), make::token(T![')']));\n+                });\n             }\n-            extract_struct_def(\n-                variant_name.clone(),\n-                &field_list,\n-                &variant.parent_enum().syntax().clone().into(),\n-                enum_ast.visibility(),\n-            );\n+\n+            let def = create_struct_def(variant_name.clone(), &field_list, enum_ast.visibility())\n+                .unwrap();\n+            let start_offset = &variant.parent_enum().syntax().clone();\n+            ted::insert_raw(ted::Position::before(start_offset), def.syntax());\n+            ted::insert_raw(ted::Position::before(start_offset), &make::tokens::blank_line());\n+\n             update_variant(&variant);\n         },\n     )\n@@ -141,31 +163,11 @@ fn existing_definition(db: &RootDatabase, variant_name: &ast::Name, variant: &Va\n         .any(|(name, _)| name.to_string() == variant_name.to_string())\n }\n \n-fn insert_import(\n-    ctx: &AssistContext,\n-    scope_node: &SyntaxNode,\n-    module: &Module,\n-    enum_module_def: &ModuleDef,\n-    variant_hir_name: &Name,\n-) -> Option<()> {\n-    let db = ctx.db();\n-    let mod_path =\n-        module.find_use_path_prefixed(db, *enum_module_def, ctx.config.insert_use.prefix_kind);\n-    if let Some(mut mod_path) = mod_path {\n-        mod_path.pop_segment();\n-        mod_path.push_segment(variant_hir_name.clone());\n-        let scope = ImportScope::find_insert_use_container(scope_node, &ctx.sema)?;\n-        insert_use(&scope, mod_path_to_ast(&mod_path), ctx.config.insert_use);\n-    }\n-    Some(())\n-}\n-\n-fn extract_struct_def(\n+fn create_struct_def(\n     variant_name: ast::Name,\n     field_list: &Either<ast::RecordFieldList, ast::TupleFieldList>,\n-    start_offset: &SyntaxElement,\n     visibility: Option<ast::Visibility>,\n-) -> Option<()> {\n+) -> Option<ast::Struct> {\n     let pub_vis = Some(make::visibility_pub());\n     let field_list = match field_list {\n         Either::Left(field_list) => {\n@@ -182,18 +184,7 @@ fn extract_struct_def(\n         .into(),\n     };\n \n-    ted::insert_raw(\n-        ted::Position::before(start_offset),\n-        make::struct_(visibility, variant_name, None, field_list).clone_for_update().syntax(),\n-    );\n-    ted::insert_raw(ted::Position::before(start_offset), &make::tokens::blank_line());\n-\n-    // if let indent_level @ 1..=usize::MAX = IndentLevel::from_node(enum_.syntax()).0 as usize {\n-    //     ted::insert(ted::Position::before(start_offset), &make::tokens::blank_line());\n-    //     rewriter\n-    //         .insert_before(start_offset, &make::tokens::whitespace(&\" \".repeat(4 * indent_level)));\n-    // }\n-    Some(())\n+    Some(make::struct_(visibility, variant_name, None, field_list).clone_for_update())\n }\n \n fn update_variant(variant: &ast::Variant) -> Option<()> {\n@@ -208,42 +199,57 @@ fn update_variant(variant: &ast::Variant) -> Option<()> {\n     Some(())\n }\n \n-fn update_reference(\n+fn process_references(\n     ctx: &AssistContext,\n-    reference: FileReference,\n-    source_file: &SourceFile,\n+    visited_modules: &mut FxHashSet<Module>,\n+    source_file: &SyntaxNode,\n     enum_module_def: &ModuleDef,\n     variant_hir_name: &Name,\n-    visited_modules_set: &mut FxHashSet<Module>,\n-) -> Option<()> {\n+    refs: Vec<FileReference>,\n+) -> Vec<(ast::PathSegment, SyntaxNode, Option<(ImportScope, hir::ModPath)>)> {\n+    refs.into_iter()\n+        .flat_map(|reference| {\n+            let (segment, scope_node, module) =\n+                reference_to_node(&ctx.sema, source_file, reference)?;\n+            if !visited_modules.contains(&module) {\n+                let mod_path = module.find_use_path_prefixed(\n+                    ctx.sema.db,\n+                    *enum_module_def,\n+                    ctx.config.insert_use.prefix_kind,\n+                );\n+                if let Some(mut mod_path) = mod_path {\n+                    mod_path.pop_segment();\n+                    mod_path.push_segment(variant_hir_name.clone());\n+                    // uuuh this wont properly work, find_insert_use_container ascends macros so we might a get new syntax node???\n+                    let scope = ImportScope::find_insert_use_container(&scope_node, &ctx.sema)?;\n+                    visited_modules.insert(module);\n+                    return Some((segment, scope_node, Some((scope, mod_path))));\n+                }\n+            }\n+            Some((segment, scope_node, None))\n+        })\n+        .collect()\n+}\n+\n+fn reference_to_node(\n+    sema: &hir::Semantics<RootDatabase>,\n+    source_file: &SyntaxNode,\n+    reference: FileReference,\n+) -> Option<(ast::PathSegment, SyntaxNode, hir::Module)> {\n     let offset = reference.range.start();\n-    let (segment, expr) = if let Some(path_expr) =\n-        find_node_at_offset::<ast::PathExpr>(source_file.syntax(), offset)\n-    {\n+    if let Some(path_expr) = find_node_at_offset::<ast::PathExpr>(source_file, offset) {\n         // tuple variant\n-        (path_expr.path()?.segment()?, path_expr.syntax().parent()?)\n-    } else if let Some(record_expr) =\n-        find_node_at_offset::<ast::RecordExpr>(source_file.syntax(), offset)\n-    {\n+        Some((path_expr.path()?.segment()?, path_expr.syntax().parent()?))\n+    } else if let Some(record_expr) = find_node_at_offset::<ast::RecordExpr>(source_file, offset) {\n         // record variant\n-        (record_expr.path()?.segment()?, record_expr.syntax().clone())\n+        Some((record_expr.path()?.segment()?, record_expr.syntax().clone()))\n     } else {\n-        return None;\n-    };\n-\n-    let module = ctx.sema.scope(&expr).module()?;\n-    if !visited_modules_set.contains(&module) {\n-        if insert_import(ctx, &expr, &module, enum_module_def, variant_hir_name).is_some() {\n-            visited_modules_set.insert(module);\n-        }\n+        None\n     }\n-    ted::insert_raw(\n-        ted::Position::before(segment.syntax()),\n-        make::path_from_text(&format!(\"{}\", segment)).clone_for_update().syntax(),\n-    );\n-    ted::insert_raw(ted::Position::before(segment.syntax()), make::token(T!['(']));\n-    ted::insert_raw(ted::Position::after(&expr), make::token(T![')']));\n-    Some(())\n+    .and_then(|(segment, expr)| {\n+        let module = sema.scope(&expr).module()?;\n+        Some((segment, expr, module))\n+    })\n }\n \n #[cfg(test)]\n@@ -350,7 +356,7 @@ mod my_mod {\n \n         pub struct MyField(pub u8, pub u8);\n \n-        pub enum MyEnum {\n+pub enum MyEnum {\n             MyField(MyField),\n         }\n     }"}]}