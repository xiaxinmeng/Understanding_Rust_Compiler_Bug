{"sha": "725199ce6512cc946d5b16c4ef3a845a2926cb09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNTE5OWNlNjUxMmNjOTQ2ZDViMTZjNGVmM2E4NDVhMjkyNmNiMDk=", "commit": {"author": {"name": "LooMaclin", "email": "loo.maclin@protonmail.com", "date": "2019-04-02T02:58:25Z"}, "committer": {"name": "LooMaclin", "email": "loo.maclin@protonmail.com", "date": "2019-04-02T02:58:25Z"}, "message": "Improve miri's error reporting in check_in_alloc", "tree": {"sha": "330cab5b458cde38105c9e5ac9c1420ef8433eee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/330cab5b458cde38105c9e5ac9c1420ef8433eee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/725199ce6512cc946d5b16c4ef3a845a2926cb09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/725199ce6512cc946d5b16c4ef3a845a2926cb09", "html_url": "https://github.com/rust-lang/rust/commit/725199ce6512cc946d5b16c4ef3a845a2926cb09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/725199ce6512cc946d5b16c4ef3a845a2926cb09/comments", "author": {"login": "LooMaclin", "id": 10957765, "node_id": "MDQ6VXNlcjEwOTU3NzY1", "avatar_url": "https://avatars.githubusercontent.com/u/10957765?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LooMaclin", "html_url": "https://github.com/LooMaclin", "followers_url": "https://api.github.com/users/LooMaclin/followers", "following_url": "https://api.github.com/users/LooMaclin/following{/other_user}", "gists_url": "https://api.github.com/users/LooMaclin/gists{/gist_id}", "starred_url": "https://api.github.com/users/LooMaclin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LooMaclin/subscriptions", "organizations_url": "https://api.github.com/users/LooMaclin/orgs", "repos_url": "https://api.github.com/users/LooMaclin/repos", "events_url": "https://api.github.com/users/LooMaclin/events{/privacy}", "received_events_url": "https://api.github.com/users/LooMaclin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LooMaclin", "id": 10957765, "node_id": "MDQ6VXNlcjEwOTU3NzY1", "avatar_url": "https://avatars.githubusercontent.com/u/10957765?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LooMaclin", "html_url": "https://github.com/LooMaclin", "followers_url": "https://api.github.com/users/LooMaclin/followers", "following_url": "https://api.github.com/users/LooMaclin/following{/other_user}", "gists_url": "https://api.github.com/users/LooMaclin/gists{/gist_id}", "starred_url": "https://api.github.com/users/LooMaclin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LooMaclin/subscriptions", "organizations_url": "https://api.github.com/users/LooMaclin/orgs", "repos_url": "https://api.github.com/users/LooMaclin/repos", "events_url": "https://api.github.com/users/LooMaclin/events{/privacy}", "received_events_url": "https://api.github.com/users/LooMaclin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ebf47851a357faa4cd97f4b1dc7835f6376e639", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ebf47851a357faa4cd97f4b1dc7835f6376e639", "html_url": "https://github.com/rust-lang/rust/commit/9ebf47851a357faa4cd97f4b1dc7835f6376e639"}], "stats": {"total": 124, "additions": 82, "deletions": 42}, "files": [{"sha": "f00da804e9535b23c923d99b95fcff7d5c51aa18", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=725199ce6512cc946d5b16c4ef3a845a2926cb09", "patch": "@@ -7,7 +7,7 @@ use super::{\n \n use crate::ty::layout::{Size, Align};\n use syntax::ast::Mutability;\n-use std::iter;\n+use std::{iter, fmt::{self, Display}};\n use crate::mir;\n use std::ops::{Deref, DerefMut};\n use rustc_data_structures::sorted_map::SortedMap;\n@@ -22,6 +22,44 @@ pub enum InboundsCheck {\n     MaybeDead,\n }\n \n+/// Used by `check_in_alloc` to indicate whether the pointer needs to be just inbounds\n+/// or also inbounds of a *live* allocation.\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum CheckInAllocMsg {\n+    ReadCStr,\n+    CheckBytes,\n+    WriteBytes,\n+    WriteRepeat,\n+    ReadScalar,\n+    WriteScalar,\n+    SlicePatCoveredByConst,\n+    ReadDiscriminant,\n+    CheckAlign,\n+    ReadBytes,\n+    CopyRepeatedly,\n+    CheckBounds,\n+}\n+\n+impl Display for CheckInAllocMsg {\n+\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", match *self {\n+            CheckInAllocMsg::ReadCStr => \"read C str\",\n+            CheckInAllocMsg::CheckBytes => \"check bytes\",\n+            CheckInAllocMsg::WriteBytes => \"write bytes\",\n+            CheckInAllocMsg::WriteRepeat => \"write repeat\",\n+            CheckInAllocMsg::ReadScalar => \"read scalar\",\n+            CheckInAllocMsg::WriteScalar => \"write scalar\",\n+            CheckInAllocMsg::SlicePatCoveredByConst => \"slice pat covered by const\",\n+            CheckInAllocMsg::ReadDiscriminant => \"read discriminant\",\n+            CheckInAllocMsg::CheckAlign => \"check align\",\n+            CheckInAllocMsg::ReadBytes => \"read bytes\",\n+            CheckInAllocMsg::CopyRepeatedly => \"copy repeatedly\",\n+            CheckInAllocMsg::CheckBounds => \"check bounds\",\n+        })\n+    }\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Allocation<Tag=(),Extra=()> {\n     /// The actual bytes of the allocation.\n@@ -140,9 +178,10 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     fn check_bounds_ptr(\n         &self,\n         ptr: Pointer<Tag>,\n+        msg: CheckInAllocMsg,\n     ) -> EvalResult<'tcx> {\n         let allocation_size = self.bytes.len() as u64;\n-        ptr.check_in_alloc(Size::from_bytes(allocation_size), InboundsCheck::Live)\n+        ptr.check_in_alloc(Size::from_bytes(allocation_size), msg)\n     }\n \n     /// Checks if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n@@ -152,9 +191,10 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n+        msg: CheckInAllocMsg,\n     ) -> EvalResult<'tcx> {\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds_ptr(ptr.offset(size, cx)?)\n+        self.check_bounds_ptr(ptr.offset(size, cx)?, msg)\n     }\n }\n \n@@ -173,11 +213,12 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         ptr: Pointer<Tag>,\n         size: Size,\n         check_defined_and_ptr: bool,\n+        msg: CheckInAllocMsg,\n     ) -> EvalResult<'tcx, &[u8]>\n         // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n-        self.check_bounds(cx, ptr, size)?;\n+        self.check_bounds(cx, ptr, size, msg)?;\n \n         if check_defined_and_ptr {\n             self.check_defined(ptr, size)?;\n@@ -201,11 +242,12 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n+        msg: CheckInAllocMsg,\n     ) -> EvalResult<'tcx, &[u8]>\n         // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n-        self.get_bytes_internal(cx, ptr, size, true)\n+        self.get_bytes_internal(cx, ptr, size, true, msg)\n     }\n \n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n@@ -216,11 +258,12 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n+        msg: CheckInAllocMsg,\n     ) -> EvalResult<'tcx, &[u8]>\n         // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n-        self.get_bytes_internal(cx, ptr, size, false)\n+        self.get_bytes_internal(cx, ptr, size, false, msg)\n     }\n \n     /// Just calling this already marks everything as defined and removes relocations,\n@@ -230,12 +273,13 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n+        msg: CheckInAllocMsg,\n     ) -> EvalResult<'tcx, &mut [u8]>\n         // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n-        self.check_bounds(cx, ptr, size)?;\n+        self.check_bounds(cx, ptr, size, msg)?;\n \n         self.mark_definedness(ptr, size, true)?;\n         self.clear_relocations(cx, ptr, size)?;\n@@ -269,7 +313,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n                 // Go through `get_bytes` for checks and AllocationExtra hooks.\n                 // We read the null, so we include it in the request, but we want it removed\n                 // from the result!\n-                Ok(&self.get_bytes(cx, ptr, size_with_null)?[..size])\n+                Ok(&self.get_bytes(cx, ptr, size_with_null, CheckInAllocMsg::ReadCStr)?[..size])\n             }\n             None => err!(UnterminatedCString(ptr.erase_tag())),\n         }\n@@ -289,7 +333,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         // Check bounds and relocations on the edges\n-        self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n+        self.get_bytes_with_undef_and_ptr(cx, ptr, size, CheckInAllocMsg::CheckBytes)?;\n         // Check undef and ptr\n         if !allow_ptr_and_undef {\n             self.check_defined(ptr, size)?;\n@@ -310,7 +354,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n-        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n+        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64), CheckInAllocMsg::WriteBytes)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n@@ -326,7 +370,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n-        let bytes = self.get_bytes_mut(cx, ptr, count)?;\n+        let bytes = self.get_bytes_mut(cx, ptr, count, CheckInAllocMsg::WriteRepeat)?;\n         for b in bytes {\n             *b = val;\n         }\n@@ -351,7 +395,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         // get_bytes_unchecked tests relocation edges\n-        let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n+        let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size, CheckInAllocMsg::ReadScalar)?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n@@ -428,7 +472,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         };\n \n         let endian = cx.data_layout().endian;\n-        let dst = self.get_bytes_mut(cx, ptr, type_size)?;\n+        let dst = self.get_bytes_mut(cx, ptr, type_size, CheckInAllocMsg::WriteScalar)?;\n         write_target_uint(endian, dst, bytes).unwrap();\n \n         // See if we have to also write a relocation"}, {"sha": "a3acc03fb6318b12def7df8cf5c11fd863f91c30", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=725199ce6512cc946d5b16c4ef3a845a2926cb09", "patch": "@@ -8,7 +8,7 @@ use crate::ty::layout::{Size, Align, LayoutError};\n use rustc_target::spec::abi::Abi;\n use rustc_macros::HashStable;\n \n-use super::{RawConst, Pointer, InboundsCheck, ScalarMaybeUndef};\n+use super::{RawConst, Pointer, CheckInAllocMsg, ScalarMaybeUndef};\n \n use backtrace::Backtrace;\n \n@@ -243,7 +243,7 @@ pub enum EvalErrorKind<'tcx, O> {\n     InvalidDiscriminant(ScalarMaybeUndef),\n     PointerOutOfBounds {\n         ptr: Pointer,\n-        check: InboundsCheck,\n+        msg: CheckInAllocMsg,\n         allocation_size: Size,\n     },\n     InvalidNullPointerUsage,\n@@ -460,13 +460,9 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::EvalErrorKind::*;\n         match *self {\n-            PointerOutOfBounds { ptr, check, allocation_size } => {\n+            PointerOutOfBounds { ptr, msg, allocation_size } => {\n                 write!(f, \"Pointer must be in-bounds{} at offset {}, but is outside bounds of \\\n-                           allocation {} which has size {}\",\n-                       match check {\n-                           InboundsCheck::Live => \" and live\",\n-                           InboundsCheck::MaybeDead => \"\",\n-                       },\n+                           allocation {} which has size {}\", msg,\n                        ptr.offset.bytes(), ptr.alloc_id, allocation_size.bytes())\n             },\n             ValidationFailure(ref err) => {"}, {"sha": "c6881cfa99f3fe9122a705c341e98eb8317dd09d", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=725199ce6512cc946d5b16c4ef3a845a2926cb09", "patch": "@@ -19,7 +19,7 @@ pub use self::value::{Scalar, ScalarMaybeUndef, RawConst, ConstValue};\n \n pub use self::allocation::{\n     InboundsCheck, Allocation, AllocationExtra,\n-    Relocations, UndefMask,\n+    Relocations, UndefMask, CheckInAllocMsg,\n };\n \n pub use self::pointer::{Pointer, PointerArithmetic};"}, {"sha": "bf9694693aa177444fabd77623b8d8726c3c585e", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=725199ce6512cc946d5b16c4ef3a845a2926cb09", "patch": "@@ -3,7 +3,7 @@ use crate::ty::layout::{self, HasDataLayout, Size};\n use rustc_macros::HashStable;\n \n use super::{\n-    AllocId, EvalResult, InboundsCheck,\n+    AllocId, EvalResult, CheckInAllocMsg\n };\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -157,12 +157,12 @@ impl<'tcx, Tag> Pointer<Tag> {\n     pub fn check_in_alloc(\n         self,\n         allocation_size: Size,\n-        check: InboundsCheck,\n+        msg: CheckInAllocMsg,\n     ) -> EvalResult<'tcx, ()> {\n         if self.offset > allocation_size {\n             err!(PointerOutOfBounds {\n                 ptr: self.erase_tag(),\n-                check,\n+                msg,\n                 allocation_size,\n             })\n         } else {"}, {"sha": "014c5ced37b25e110be7179a8615d2c49ec0db5d", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=725199ce6512cc946d5b16c4ef3a845a2926cb09", "patch": "@@ -172,7 +172,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n-use rustc::mir::interpret::{ConstValue, Scalar, truncate};\n+use rustc::mir::interpret::{ConstValue, Scalar, truncate, CheckInAllocMsg};\n use rustc::util::common::ErrorReported;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -1418,7 +1418,7 @@ fn slice_pat_covered_by_const<'tcx>(\n                 return Ok(false);\n             }\n             let n = n.assert_usize(tcx).unwrap();\n-            alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n+            alloc.get_bytes(&tcx, ptr, Size::from_bytes(n), CheckInAllocMsg::SlicePatCoveredByConst).unwrap()\n         },\n         // a slice fat pointer to a zero length slice\n         (ConstValue::Slice(Scalar::Bits { .. }, 0), ty::Slice(t)) => {\n@@ -1443,7 +1443,7 @@ fn slice_pat_covered_by_const<'tcx>(\n             tcx.alloc_map\n                 .lock()\n                 .unwrap_memory(ptr.alloc_id)\n-                .get_bytes(&tcx, ptr, Size::from_bytes(n))\n+                .get_bytes(&tcx, ptr, Size::from_bytes(n), CheckInAllocMsg::SlicePatCoveredByConst)\n                 .unwrap()\n         },\n         _ => bug!("}, {"sha": "302bc84e65c4ab2ccb46daf8c0639cc9fde5160c", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=725199ce6512cc946d5b16c4ef3a845a2926cb09", "patch": "@@ -20,7 +20,7 @@ use syntax::ast::Mutability;\n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n     EvalResult, Scalar, EvalErrorKind, AllocKind, PointerArithmetic,\n-    Machine, AllocMap, MayLeak, ErrorHandled, InboundsCheck,\n+    Machine, AllocMap, MayLeak, ErrorHandled, InboundsCheck, CheckInAllocMsg,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -252,7 +252,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             Scalar::Ptr(ptr) => {\n                 // check this is not NULL -- which we can ensure only if this is in-bounds\n                 // of some (potentially dead) allocation.\n-                let align = self.check_bounds_ptr(ptr, InboundsCheck::MaybeDead)?;\n+                let align = self.check_bounds_ptr(ptr, CheckInAllocMsg::CheckAlign)?;\n                 (ptr.offset.bytes(), align)\n             }\n             Scalar::Bits { bits, size } => {\n@@ -292,10 +292,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn check_bounds_ptr(\n         &self,\n         ptr: Pointer<M::PointerTag>,\n-        liveness: InboundsCheck,\n+        msg: CheckInAllocMsg,\n     ) -> EvalResult<'tcx, Align> {\n-        let (allocation_size, align) = self.get_size_and_align(ptr.alloc_id, liveness)?;\n-        ptr.check_in_alloc(allocation_size, liveness)?;\n+        let (allocation_size, align) = self.get_size_and_align(ptr.alloc_id, msg)?;\n+        ptr.check_in_alloc(allocation_size, msg)?;\n         Ok(align)\n     }\n }\n@@ -423,7 +423,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn get_size_and_align(\n         &self,\n         id: AllocId,\n-        liveness: InboundsCheck,\n+        msg: CheckInAllocMsg,\n     ) -> EvalResult<'static, (Size, Align)> {\n         if let Ok(alloc) = self.get(id) {\n             return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n@@ -439,7 +439,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n                 Ok((layout.size, layout.align.abi))\n             }\n-            _ => match liveness {\n+            _ => match msg {\n                 InboundsCheck::MaybeDead => {\n                     // Must be a deallocated pointer\n                     Ok(*self.dead_alloc_map.get(&id).expect(\n@@ -604,7 +604,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             Ok(&[])\n         } else {\n             let ptr = ptr.to_ptr()?;\n-            self.get(ptr.alloc_id)?.get_bytes(self, ptr, size)\n+            self.get(ptr.alloc_id)?.get_bytes(self, ptr, size, CheckInAllocMsg::ReadBytes)\n         }\n     }\n }\n@@ -729,10 +729,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         // This checks relocation edges on the src.\n         let src_bytes = self.get(src.alloc_id)?\n-            .get_bytes_with_undef_and_ptr(&tcx, src, size)?\n+            .get_bytes_with_undef_and_ptr(&tcx, src, size, CheckInAllocMsg::CopyRepeatedly)?\n             .as_ptr();\n         let dest_bytes = self.get_mut(dest.alloc_id)?\n-            .get_bytes_mut(&tcx, dest, size * length)?\n+            .get_bytes_mut(&tcx, dest, size * length, CheckInAllocMsg::CopyRepeatedly)?\n             .as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes"}, {"sha": "b90ec42de7ef0bd8a00f2630d10d16836ba533be", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=725199ce6512cc946d5b16c4ef3a845a2926cb09", "patch": "@@ -7,7 +7,7 @@ use rustc::{mir, ty};\n use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx};\n \n use rustc::mir::interpret::{\n-    GlobalId, AllocId, InboundsCheck,\n+    GlobalId, AllocId, CheckInAllocMsg,\n     ConstValue, Pointer, Scalar,\n     EvalResult, EvalErrorKind,\n     sign_extend, truncate,\n@@ -667,7 +667,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n-                            self.memory.check_bounds_ptr(ptr, InboundsCheck::MaybeDead).is_ok();\n+                            self.memory.check_bounds_ptr(ptr, CheckInAllocMsg::ReadDiscriminant).is_ok();\n                         if !ptr_valid {\n                             return err!(InvalidDiscriminant(raw_discr.erase_tag()));\n                         }"}, {"sha": "23c1681cbd8797f7b1ae912e64877b326753ec80", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/725199ce6512cc946d5b16c4ef3a845a2926cb09/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=725199ce6512cc946d5b16c4ef3a845a2926cb09", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, AllocKind, EvalResult, EvalErrorKind,\n+    Scalar, AllocKind, EvalResult, EvalErrorKind, CheckInAllocMsg,\n };\n \n use super::{\n@@ -394,7 +394,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                         try_validation!(\n                             self.ecx.memory\n                                 .get(ptr.alloc_id)?\n-                                .check_bounds(self.ecx, ptr, size),\n+                                .check_bounds(self.ecx, ptr, size, CheckInAllocMsg::CheckBounds),\n                             \"dangling (not entirely in bounds) reference\", self.path);\n                     }\n                     // Check if we have encountered this pointer+layout combination"}]}