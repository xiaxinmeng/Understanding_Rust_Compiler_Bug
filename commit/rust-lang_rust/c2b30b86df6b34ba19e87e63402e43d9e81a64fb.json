{"sha": "c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYjMwYjg2ZGY2YjM0YmExOWU4N2U2MzQwMmU0M2Q5ZTgxYTY0ZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T19:11:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T19:11:44Z"}, "message": "Auto merge of #25340 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #24996, #25220, #25221, #25267, #25322, #25327, #25329, #25330, #25331, #25335\n- Failed merges: #25334", "tree": {"sha": "72ea5b1f96b971b89f30dc992dc77e66b0502951", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72ea5b1f96b971b89f30dc992dc77e66b0502951"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "html_url": "https://github.com/rust-lang/rust/commit/c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ca008dcf12283247122f25928630f2a484ff768", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ca008dcf12283247122f25928630f2a484ff768", "html_url": "https://github.com/rust-lang/rust/commit/3ca008dcf12283247122f25928630f2a484ff768"}, {"sha": "25815655c01e0ec9624c0fae39f6691c3a90a776", "url": "https://api.github.com/repos/rust-lang/rust/commits/25815655c01e0ec9624c0fae39f6691c3a90a776", "html_url": "https://github.com/rust-lang/rust/commit/25815655c01e0ec9624c0fae39f6691c3a90a776"}], "stats": {"total": 532, "additions": 443, "deletions": 89}, "files": [{"sha": "c4725c26e46bd14fd634dafb8ac5aeb8c627d808", "filename": "src/doc/index.md", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -5,15 +5,14 @@ to jump to any particular section.\n \n # Getting Started\n \n-If you haven't seen Rust at all yet, the first thing you should read is the [30\n-minute intro](intro.html). It will give you an overview of the basic ideas of Rust\n-at a high level.\n+If you haven't seen Rust at all yet, the first thing you should read is the\n+introduction to [The Rust Programming Language](book/index.html). It'll give\n+you a good idea of what Rust is like.\n \n-Once you know you really want to learn Rust, the next step is reading [The\n-Rust Programming Language](book/index.html). It is a lengthy explanation of\n-Rust, its syntax, and its concepts. Upon completing the book, you'll be an\n-intermediate Rust developer, and will have a good grasp of the fundamental\n-ideas behind Rust.\n+The book provides a lengthy explanation of Rust, its syntax, and its\n+concepts. Upon completing the book, you'll be an intermediate Rust\n+developer, and will have a good grasp of the fundamental ideas behind\n+Rust.\n \n [Rust By Example][rbe] was originally a community resource, but was then\n donated to the Rust project. As the name implies, it teaches you Rust through a\n@@ -24,7 +23,7 @@ series of small examples.\n # Community & Getting Help\n \n If you need help with something, or just want to talk about Rust with others,\n-there's a few places you can do that:\n+there are a few places you can do that:\n \n The Rust IRC channels on [irc.mozilla.org](http://irc.mozilla.org/) are the\n fastest way to get help.\n@@ -59,7 +58,7 @@ the language in as much detail as possible is in [the reference](reference.html)\n \n # Tools\n \n-Rust's still a young language, so there isn't a ton of tooling yet, but the\n+Rust is still a young language, so there isn't a ton of tooling yet, but the\n tools we have are really nice.\n \n [Cargo](http://crates.io) is Rust's package manager, and its website contains\n@@ -69,16 +68,21 @@ lots of good documentation.\n \n # FAQs\n \n-There are questions that are asked quite often, and so we've made FAQs for them:\n+There are questions that are asked quite often, so we've made FAQs for them:\n \n * [Language Design FAQ](complement-design-faq.html)\n * [Language FAQ](complement-lang-faq.html)\n * [Project FAQ](complement-project-faq.html)\n * [How to submit a bug report](https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports)\n \n-# The standard library\n+# The Standard Library\n \n We have [API documentation for the entire standard\n library](std/index.html). There's a list of crates on the left with more\n specific sections, or you can use the search bar at the top to search for\n something if you know its name.\n+\n+# The Error Index\n+\n+If you encounter an error while compiling your code you may be able to look it\n+up in the [Rust Compiler Error Index](error-index.html)."}, {"sha": "2ddec9ba424f2009cdebbb755fc048ff84006735", "filename": "src/doc/reference.md", "status": "modified", "additions": 151, "deletions": 52, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -426,12 +426,12 @@ x;\n x::y::z;\n ```\n \n-Path components are usually [identifiers](#identifiers), but the trailing\n-component of a path may be an angle-bracket-enclosed list of type arguments. In\n-[expression](#expressions) context, the type argument list is given after a\n-final (`::`) namespace qualifier in order to disambiguate it from a relational\n-expression involving the less-than symbol (`<`). In type expression context,\n-the final namespace qualifier is omitted.\n+Path components are usually [identifiers](#identifiers), but they may\n+also include angle-bracket-enclosed lists of type arguments. In\n+[expression](#expressions) context, the type argument list is given\n+after a `::` namespace qualifier in order to disambiguate it from a\n+relational expression involving the less-than symbol (`<`). In type\n+expression context, the final namespace qualifier is omitted.\n \n Two examples of paths with type arguments:\n \n@@ -497,8 +497,9 @@ names, and invoked through a consistent syntax: `some_extension!(...)`.\n \n Users of `rustc` can define new syntax extensions in two ways:\n \n-* [Compiler plugins][plugin] can include arbitrary\n-  Rust code that manipulates syntax trees at compile time.\n+* [Compiler plugins][plugin] can include arbitrary Rust code that\n+  manipulates syntax trees at compile time. Note that the interface\n+  for compiler plugins is considered highly unstable.\n \n * [Macros](book/macros.html) define new syntax in a higher-level,\n   declarative way.\n@@ -560,14 +561,18 @@ Nested repetitions are allowed.\n The parser used by the macro system is reasonably powerful, but the parsing of\n Rust syntax is restricted in two ways:\n \n-1. The parser will always parse as much as possible. If it attempts to match\n-   `$i:expr [ , ]` against `8 [ , ]`, it will attempt to parse `i` as an array\n-   index operation and fail. Adding a separator can solve this problem.\n+1. Macro definitions are required to include suitable separators after parsing\n+   expressions and other bits of the Rust grammar. This implies that\n+   a macro definition like `$i:expr [ , ]` is not legal, because `[` could be part\n+   of an expression. A macro definition like `$i:expr,` or `$i:expr;` would be legal,\n+   however, because `,` and `;` are legal separators. See [RFC 550] for more information.\n 2. The parser must have eliminated all ambiguity by the time it reaches a `$`\n    _name_ `:` _designator_. This requirement most often affects name-designator\n    pairs when they occur at the beginning of, or immediately after, a `$(...)*`;\n    requiring a distinctive token in front can solve the problem.\n \n+[RFC 550]: https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md\n+\n # Crates and source files\n \n Although Rust, like any other language, can be implemented by an interpreter as\n@@ -686,7 +691,8 @@ type arguments as a list of comma-separated types enclosed within angle\n brackets, in order to refer to the type-parameterized item. In practice, the\n type-inference system can usually infer such argument types from context. There\n are no general type-parametric types, only type-parametric items. That is, Rust\n-has no notion of type abstraction: there are no first-class \"forall\" types.\n+has no notion of type abstraction: there are no higher-ranked (or \"forall\") types\n+abstracted over other types, though higher-ranked types do exist for lifetimes.\n \n ### Modules\n \n@@ -732,6 +738,7 @@ mod vec;\n \n mod thread {\n     // Load the `local_data` module from `thread/local_data.rs`\n+    // or `thread/local_data/mod.rs`.\n     mod local_data;\n }\n ```\n@@ -1004,7 +1011,8 @@ the guarantee that these issues are never caused by safe code.\n * `&mut` and `&` follow LLVM\u2019s scoped [noalias] model, except if the `&T`\n   contains an `UnsafeCell<U>`. Unsafe code must not violate these aliasing\n   guarantees.\n-* Mutating an immutable value/reference without `UnsafeCell<U>`\n+* Mutating non-mutable data (that is, data reached through a shared reference or\n+  data owned by a `let` binding), unless that data is contained within an `UnsafeCell<U>`.\n * Invoking undefined behavior via compiler intrinsics:\n   * Indexing outside of the bounds of an object with `std::ptr::offset`\n     (`offset` intrinsic), with\n@@ -1034,9 +1042,13 @@ be undesired.\n * Exiting without calling destructors\n * Sending signals\n * Accessing/modifying the file system\n-* Unsigned integer overflow (well-defined as wrapping)\n-* Signed integer overflow (well-defined as two\u2019s complement representation\n-  wrapping)\n+* Integer overflow\n+  - Overflow is considered \"unexpected\" behavior and is always user-error,\n+    unless the `wrapping` primitives are used. In non-optimized builds, the compiler\n+    will insert debug checks that panic on overflow, but in optimized builds overflow\n+    instead results in wrapped values. See [RFC 560] for the rationale and more details.\n+\n+[RFC 560]: https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md\n \n #### Diverging functions\n \n@@ -1310,11 +1322,26 @@ type of the value is not required to ascribe to `Sync`.\n \n ### Traits\n \n-A _trait_ describes a set of method types.\n+A _trait_ describes an abstract interface that types can\n+implement. This interface consists of associated items, which come in\n+three varieties:\n+\n+- functions\n+- constants\n+- types\n+\n+Associated functions whose first parameter is named `self` are called\n+methods and may be invoked using `.` notation (e.g., `x.foo()`).\n+\n+All traits define an implicit type parameter `Self` that refers to\n+\"the type that is implementing this interface\". Traits may also\n+contain additional type parameters. These type parameters (including\n+`Self`) may be constrained by other traits and so forth as usual.\n \n-Traits can include default implementations of methods, written in terms of some\n-unknown [`self` type](#self-types); the `self` type may either be completely\n-unspecified, or constrained by some other trait.\n+Trait bounds on `Self` are considered \"supertraits\". These are\n+required to be acyclic.  Supertraits are somewhat different from other\n+constraints in that they affect what methods are available in the\n+vtable when the trait is used as a [trait object](#trait-objects).\n \n Traits are implemented for specific types through separate\n [implementations](#implementations).\n@@ -1359,15 +1386,18 @@ fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n }\n ```\n \n-Traits also define an [trait object](#trait-objects) with the same name as the\n-trait. Values of this type are created by [casting](#type-cast-expressions)\n-pointer values (pointing to a type for which an implementation of the given\n-trait is in scope) to pointers to the trait name, used as a type.\n+Traits also define an [trait object](#trait-objects) with the same\n+name as the trait. Values of this type are created by coercing from a\n+pointer of some specific type to a pointer of trait type. For example,\n+`&T` could be coerced to `&Shape` if `T: Shape` holds (and similarly\n+for `Box<T>`). This coercion can either be implicit or\n+[explicit](#type-cast-expressions). Here is an example of an explicit\n+coercion:\n \n ```\n-# trait Shape { fn dummy(&self) { } }\n-# impl Shape for i32 { }\n-# let mycircle = 0i32;\n+trait Shape { }\n+impl Shape for i32 { }\n+let mycircle = 0i32;\n let myshape: Box<Shape> = Box::new(mycircle) as Box<Shape>;\n ```\n \n@@ -2041,7 +2071,8 @@ The name `str_eq` has a special meaning to the Rust compiler, and the presence\n of this definition means that it will use this definition when generating calls\n to the string equality function.\n \n-A complete list of the built-in language items will be added in the future.\n+The set of language items is currently considered unstable. A complete\n+list of the built-in language items will be added in the future.\n \n ### Inline attributes\n \n@@ -2053,11 +2084,6 @@ The compiler automatically inlines functions based on internal heuristics.\n Incorrectly inlining functions can actually make the program slower, so it\n should be used with care.\n \n-Immutable statics are always considered inlineable unless marked with\n-`#[inline(never)]`. It is undefined whether two different inlineable statics\n-have the same memory address. In other words, the compiler is free to collapse\n-duplicate inlineable statics together.\n-\n `#[inline]` and `#[inline(always)]` always cause the function to be serialized\n into the crate metadata to allow cross-crate inlining.\n \n@@ -2259,10 +2285,6 @@ The currently implemented features of the reference compiler are:\n * `unboxed_closures` - Rust's new closure design, which is currently a work in\n                        progress feature with many known bugs.\n \n-* `unsafe_destructor` - Allows use of the `#[unsafe_destructor]` attribute,\n-                        which is considered wildly unsafe and will be\n-                        obsoleted by language improvements.\n-\n * `unsafe_no_drop_flag` - Allows use of the `#[unsafe_no_drop_flag]` attribute,\n                           which removes hidden flag added to a type that\n                           implements the `Drop` trait. The design for the\n@@ -2382,18 +2404,54 @@ expressions](#index-expressions) (`expr[expr]`), and [field\n references](#field-expressions) (`expr.f`). All other expressions are rvalues.\n \n The left operand of an [assignment](#assignment-expressions) or\n-[compound-assignment](#compound-assignment-expressions) expression is an lvalue\n-context, as is the single operand of a unary\n-[borrow](#unary-operator-expressions). All other expression contexts are\n-rvalue contexts.\n+[compound-assignment](#compound-assignment-expressions) expression is\n+an lvalue context, as is the single operand of a unary\n+[borrow](#unary-operator-expressions). The discriminant or subject of\n+a [match expression](#match-expressions) may be an lvalue context, if\n+ref bindings are made, but is otherwise an rvalue context. All other\n+expression contexts are rvalue contexts.\n \n When an lvalue is evaluated in an _lvalue context_, it denotes a memory\n location; when evaluated in an _rvalue context_, it denotes the value held _in_\n that memory location.\n \n-When an rvalue is used in an lvalue context, a temporary un-named lvalue is\n-created and used instead. A temporary's lifetime equals the largest lifetime\n-of any reference that points to it.\n+##### Temporary lifetimes\n+\n+When an rvalue is used in an lvalue context, a temporary un-named\n+lvalue is created and used instead. The lifetime of temporary values\n+is typically the innermost enclosing statement; the tail expression of\n+a block is considered part of the statement that encloses the block.\n+\n+When a temporary rvalue is being created that is assigned into a `let`\n+declaration, however, the temporary is created with the lifetime of\n+the enclosing block instead, as using the enclosing statement (the\n+`let` declaration) would be a guaranteed error (since a pointer to the\n+temporary would be stored into a variable, but the temporary would be\n+freed before the variable could be used). The compiler uses simple\n+syntactic rules to decide which values are being assigned into a `let`\n+binding, and therefore deserve a longer temporary lifetime.\n+\n+Here are some examples:\n+\n+- `let x = foo(&temp())`. The expression `temp()` is an rvalue. As it\n+  is being borrowed, a temporary is created which will be freed after\n+  the innermost enclosing statement (the `let` declaration, in this case).\n+- `let x = temp().foo()`. This is the same as the previous example,\n+  except that the value of `temp()` is being borrowed via autoref on a\n+  method-call. Here we are assuming that `foo()` is an `&self` method\n+  defined in some trait, say `Foo`. In other words, the expression\n+  `temp().foo()` is equivalent to `Foo::foo(&temp())`.\n+- `let x = &temp()`. Here, the same temporary is being assigned into\n+  `x`, rather than being passed as a parameter, and hence the\n+  temporary's lifetime is considered to be the enclosing block.\n+- `let x = SomeStruct { foo: &temp() }`. As in the previous case, the\n+  temporary is assigned into a struct which is then assigned into a\n+  binding, and hence it is given the lifetime of the enclosing block.\n+- `let x = [ &temp() ]`. As in the previous case, the\n+  temporary is assigned into an array which is then assigned into a\n+  binding, and hence it is given the lifetime of the enclosing block.\n+- `let ref x = temp()`. In this case, the temporary is created using a ref binding,\n+  but the result is the same: the lifetime is extended to the enclosing block.\n \n #### Moved and copied types\n \n@@ -2535,8 +2593,10 @@ A field access is an [lvalue](#lvalues,-rvalues-and-temporaries) referring to\n the value of that field. When the type providing the field inherits mutability,\n it can be [assigned](#assignment-expressions) to.\n \n-Also, if the type of the expression to the left of the dot is a pointer, it is\n-automatically dereferenced to make the field access possible.\n+Also, if the type of the expression to the left of the dot is a\n+pointer, it is automatically dereferenced as many times as necessary\n+to make the field access possible. In cases of ambiguity, we prefer\n+fewer autoderefs to more.\n \n ### Array expressions\n \n@@ -2577,6 +2637,11 @@ let arr = [\"a\", \"b\"];\n arr[10]; // panics\n ```\n \n+Also, if the type of the expression to the left of the brackets is a\n+pointer, it is automatically dereferenced as many times as necessary\n+to make the indexing possible. In cases of ambiguity, we prefer fewer\n+autoderefs to more.\n+\n ### Range expressions\n \n The `..` operator will construct an object of one of the `std::ops::Range` variants.\n@@ -2599,7 +2664,7 @@ assert_eq!(x,y);\n \n ### Unary operator expressions\n \n-Rust defines three unary operators. They are all written as prefix operators,\n+Rust defines the following unary operators. They are all written as prefix operators,\n before the expression they apply to.\n \n * `-`\n@@ -2613,11 +2678,20 @@ before the expression they apply to.\n     implemented by the type and required for an outer expression that will or\n     could mutate the dereference), and produces the result of dereferencing the\n     `&` or `&mut` borrowed pointer returned from the overload method.\n-\n * `!`\n   : Logical negation. On the boolean type, this flips between `true` and\n     `false`. On integer types, this inverts the individual bits in the\n     two's complement representation of the value.\n+* `&` and `&mut`\n+  : Borrowing. When applied to an lvalue, these operators produce a\n+    reference (pointer) to the lvalue. The lvalue is also placed into\n+    a borrowed state for the duration of the reference. For a shared\n+    borrow (`&`), this implies that the lvalue may not be mutated, but\n+    it may be read or shared again. For a mutable borrow (`&mut`), the\n+    lvalue may not be accessed in any way until the borrow expires.\n+    If the `&` or `&mut` operators are applied to an rvalue, a\n+    temporary value is created; the lifetime of this temporary value\n+    is defined by [syntactic rules](#temporary-lifetimes).\n \n ### Binary operator expressions\n \n@@ -2727,6 +2801,13 @@ fn avg(v: &[f64]) -> f64 {\n }\n ```\n \n+Some of the conversions which can be done through the `as` operator\n+can also be done implicitly at various points in the program, such as\n+argument passing and assignment to a `let` binding with an explicit\n+type. Implicit conversions are limited to \"harmless\" conversions that\n+do not lose information and which have minimal or no risk of\n+surprising side-effects on the dynamic execution semantics.\n+\n #### Assignment expressions\n \n An _assignment expression_ consists of an\n@@ -3348,6 +3429,22 @@ let bo: Binop = add;\n x = bo(5,7);\n ```\n \n+#### Function types for specific items\n+\n+Internally to the compiler, there are also function types that are specific to a particular\n+function item. In the following snippet, for example, the internal types of the functions\n+`foo` and `bar` are different, despite the fact that they have the same signature:\n+\n+```\n+fn foo() { }\n+fn bar() { }\n+```\n+\n+The types of `foo` and `bar` can both be implicitly coerced to the fn\n+pointer type `fn()`. There is currently no syntax for unique fn types,\n+though the compiler will emit a type like `fn() {foo}` in error\n+messages to indicate \"the unique fn type for the function `foo`\".\n+\n ### Closure types\n \n A [lambda expression](#lambda-expressions) produces a closure value with\n@@ -3432,8 +3529,9 @@ has type `Vec<A>`, a vector with element type `A`.\n \n ### Self types\n \n-The special type `self` has a meaning within methods inside an impl item. It\n-refers to the type of the implicit `self` argument. For example, in:\n+The special type `Self` has a meaning within traits and impls. In a trait definition, it refers\n+to an implicit type parameter representing the \"implementing\" type. In an impl,\n+it is an alias for the implementing type. For example, in:\n \n ```\n trait Printable {\n@@ -3447,8 +3545,9 @@ impl Printable for String {\n }\n ```\n \n-`self` refers to the value of type `String` that is the receiver for a call to\n-the method `make_string`.\n+The notation `&self` is a shorthand for `self: &Self`. In this case,\n+in the impl, `Self` refers to the value of type `String` that is the\n+receiver for a call to the method `make_string`.\n \n # Special traits\n "}, {"sha": "3f97928a56e3f067af823d1939ea8d85cf779aef", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -15,6 +15,7 @@\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n     * [FFI](ffi.md)\n+    * [Borrow and AsRef](borrow-and-asref.md)\n * [Syntax and Semantics](syntax-and-semantics.md)\n     * [Variable Bindings](variable-bindings.md)\n     * [Functions](functions.md)"}, {"sha": "f5f314f1c21d6ee9d3bc719134a7ad013b23698f", "filename": "src/doc/trpl/borrow-and-asref.md", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -0,0 +1,93 @@\n+% Borrow and AsRef\n+\n+The [`Borrow`][borrow] and [`AsRef`][asref] traits are very similar, but\n+different. Here\u2019s a quick refresher on what these two traits mean.\n+\n+[borrow]: ../std/borrow/trait.Borrow.html\n+[asref]: ../std/convert/trait.AsRef.html\n+\n+# Borrow\n+\n+The `Borrow` trait is used when you\u2019re writing a datastructure, and you want to\n+use either an owned or borrowed type as synonymous for some purpose.\n+\n+For example, [`HashMap`][hashmap] has a [`get` method][get] which uses `Borrow`:\n+\n+```rust,ignore\n+fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n+    where K: Borrow<Q>,\n+          Q: Hash + Eq\n+```\n+\n+[hashmap]: ../std/collections/struct.HashMap.html\n+[get]: ../std/collections/struct.HashMap.html#method.get\n+\n+This signature is pretty complicated. The `K` parameter is what we\u2019re interested\n+in here. It refers to a parameter of the `HashMap` itself:\n+\n+```rust,ignore\n+struct HashMap<K, V, S = RandomState> {\n+```\n+\n+The `K` parameter is the type of _key_ the `HashMap` uses. So, looking at\n+the signature of `get()` again, we can use `get()` when the key implements\n+`Borrow<Q>`. That way, we can make a `HashMap` which uses `String` keys,\n+but use `&str`s when we\u2019re searching:\n+\n+```rust\n+use std::collections::HashMap;\n+\n+let mut map = HashMap::new();\n+map.insert(\"Foo\".to_string(), 42);\n+\n+assert_eq!(map.get(\"Foo\"), Some(&42));\n+```\n+\n+This is because the standard library has `impl Borrow<str> for String`.\n+\n+For most types, when you want to take an owned or borrowed type, a `&T` is\n+enough. But one area where `Borrow` is effective is when there\u2019s more than one\n+kind of borrowed value. Slices are an area where this is especially true: you\n+can have both an `&[T]` or a `&mut [T]`. If we wanted to accept both of these\n+types, `Borrow` is up for it:\n+\n+```\n+use std::borrow::Borrow;\n+use std::fmt::Display;\n+\n+fn foo<T: Borrow<i32> + Display>(a: T) {\n+    println!(\"a is borrowed: {}\", a);\n+}\n+\n+let mut i = 5;\n+\n+foo(&i);\n+foo(&mut i);\n+```\n+\n+This will print out `a is borrowed: 5` twice.\n+\n+# AsRef\n+\n+The `AsRef` trait is a conversion trait. It\u2019s used for converting some value to\n+a reference in generic code. Like this:\n+\n+```rust\n+let s = \"Hello\".to_string();\n+\n+fn foo<T: AsRef<str>>(s: T) {\n+    let slice = s.as_ref();\n+}\n+```\n+\n+# Which should I use?\n+\n+We can see how they\u2019re kind of the same: they both deal with owned and borrowed\n+versions of some type. However, they\u2019re a bit different.\n+\n+Choose `Borrow` when you want to abstract over different kinds of borrowing, or\n+when you\u2019re building a datastructure that treats owned and borrowed values in\n+equivalent ways, such as hashing and comparison.\n+\n+Choose `AsRef` when you want to convert something to a reference directly, and\n+you\u2019re writing generic code."}, {"sha": "25d5122b4e49e31d167f8dde9b7340c05952fa58", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -5,7 +5,7 @@ Rust\u2019s most unique and compelling features, with which Rust developers should\n become quite acquainted. Ownership is how Rust achieves its largest goal,\n memory safety. There are a few distinct concepts, each with its own chapter:\n \n-* [ownership][ownership], ownership, the key concept\n+* [ownership][ownership], the key concept\n * [borrowing][borrowing], and their associated feature \u2018references\u2019\n * lifetimes, which you\u2019re reading now\n "}, {"sha": "b210f1c643f438dce8edd6c65c16aada12803186", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -6,7 +6,7 @@ become quite acquainted. Ownership is how Rust achieves its largest goal,\n memory safety. There are a few distinct concepts, each with its own\n chapter:\n \n-* ownership, which you\u2019re reading now.\n+* ownership, which you\u2019re reading now\n * [borrowing][borrowing], and their associated feature \u2018references\u2019\n * [lifetimes][lifetimes], an advanced concept of borrowing\n \n@@ -23,7 +23,7 @@ Before we get to the details, two important notes about the ownership system.\n Rust has a focus on safety and speed. It accomplishes these goals through many\n \u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n as possible in order to make them work. The ownership system is a prime example\n-of a zero cost abstraction. All of the analysis we\u2019ll talk about in this guide\n+of a zero-cost abstraction. All of the analysis we\u2019ll talk about in this guide\n is _done at compile time_. You do not pay any run-time cost for any of these\n features.\n \n@@ -41,7 +41,7 @@ With that in mind, let\u2019s learn about ownership.\n \n # Ownership\n \n-[`Variable bindings`][bindings] have a property in Rust: they \u2018have ownership\u2019\n+[Variable bindings][bindings] have a property in Rust: they \u2018have ownership\u2019\n of what they\u2019re bound to. This means that when a binding goes out of scope, the\n resource that they\u2019re bound to are freed. For example:\n \n@@ -106,8 +106,8 @@ take(v);\n println!(\"v[0] is: {}\", v[0]);\n ```\n \n-Same error: \u201cuse of moved value.\u201d When we transfer ownership to something else,\n-we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need some sort of\n+Same error: \u2018use of moved value\u2019. When we transfer ownership to something else,\n+we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need any sort of\n special annotation here, it\u2019s the default thing that Rust does.\n \n ## The details\n@@ -121,19 +121,19 @@ let v = vec![1, 2, 3];\n let v2 = v;\n ```\n \n-The first line creates some data for the vector on the [stack][sh], `v`. The\n-vector\u2019s data, however, is stored on the [heap][sh], and so it contains a\n-pointer to that data. When we move `v` to `v2`, it creates a copy of that pointer,\n-for `v2`. Which would mean two pointers to the contents of the vector on the\n-heap. That would be a problem: it would violate Rust\u2019s safety guarantees by\n-introducing a data race. Therefore, Rust forbids using `v` after we\u2019ve done the\n-move.\n+The first line allocates memory for the vector object, `v`, and for the data it\n+contains. The vector object is stored on the [stack][sh] and contains a pointer\n+to the content (`[1, 2, 3]`) stored on the [heap][sh]. When we move `v` to `v2`,\n+it creates a copy of that pointer, for `v2`. Which means that there would be two\n+pointers to the content of the vector on the heap. It would violate Rust\u2019s\n+safety guarantees by introducing a data race. Therefore, Rust forbids using `v`\n+after we\u2019ve done the move.\n \n [sh]: the-stack-and-the-heap.html\n \n It\u2019s also important to note that optimizations may remove the actual copy of\n-the bytes, depending on circumstances. So it may not be as inefficient as it\n-initially seems.\n+the bytes on the stack, depending on circumstances. So it may not be as\n+inefficient as it initially seems.\n \n ## `Copy` types\n "}, {"sha": "22483816769c3a47b67b98144917f12ac396b336", "filename": "src/doc/trpl/primitive-types.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -15,7 +15,7 @@ let x = true;\n let y: bool = false;\n ```\n \n-A common use of booleans is in [`if` statements][if].\n+A common use of booleans is in [`if` conditionals][if].\n \n [if]: if.html\n "}, {"sha": "e71d2033f49ed2f404e68baf56080bad695d18d4", "filename": "src/doc/trpl/while-loops.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -1,4 +1,4 @@\n-% while loops\n+% while Loops\n \n Rust also has a `while` loop. It looks like this:\n "}, {"sha": "a86a4b4215f23ff2b927b944fee0201a696a8f2d", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -37,6 +37,11 @@ use self::Cow::*;\n /// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n /// type can be borrowed as multiple different types. In particular, `Vec<T>:\n /// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n+///\n+/// `Borrow` is very similar to, but different than, `AsRef`. See\n+/// [the book][book] for more.\n+///\n+/// [book]: ../../book/borrow-and-asref.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value."}, {"sha": "f6987c1966493843c25c768fad1a9d5aaf8f1f7e", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -24,6 +24,11 @@ use marker::Sized;\n \n /// A cheap, reference-to-reference conversion.\n ///\n+/// `AsRef` is very similar to, but different than, `Borrow`. See\n+/// [the book][book] for more.\n+///\n+/// [book]: ../../book/borrow-and-asref.html\n+///\n /// # Examples\n ///\n /// Both `String` and `&str` implement `AsRef<str>`:"}, {"sha": "69ab34fee5a1f9b0e6cdb2762414baaccd3f9b5c", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -5722,6 +5722,9 @@ pub mod funcs {\n                 pub fn tcgetpgrp(fd: c_int) -> pid_t;\n                 pub fn ttyname(fd: c_int) -> *mut c_char;\n                 pub fn unlink(c: *const c_char) -> c_int;\n+                pub fn wait(status: *const c_int) -> pid_t;\n+                pub fn waitpid(pid: pid_t, status: *const c_int, options: c_int)\n+                               -> pid_t;\n                 pub fn write(fd: c_int, buf: *const c_void, count: size_t)\n                              -> ssize_t;\n                 pub fn pread(fd: c_int, buf: *mut c_void, count: size_t,\n@@ -5773,6 +5776,9 @@ pub mod funcs {\n                 pub fn sysconf(name: c_int) -> c_long;\n                 pub fn ttyname(fd: c_int) -> *mut c_char;\n                 pub fn unlink(c: *const c_char) -> c_int;\n+                pub fn wait(status: *const c_int) -> pid_t;\n+                pub fn waitpid(pid: pid_t, status: *const c_int, options: c_int)\n+                               -> pid_t;\n                 pub fn write(fd: c_int, buf: *const c_void, count: size_t)\n                              -> ssize_t;\n                 pub fn pread(fd: c_int, buf: *mut c_void, count: size_t,"}, {"sha": "6690e6831afee2a7572a8f828a6688820f9e3cfa", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -273,8 +273,8 @@ See also http://doc.rust-lang.org/book/unsafe.html\n \n E0137: r##\"\n This error indicates that the compiler found multiple functions with the\n-#[main] attribute. This is an error because there must be a unique entry point\n-into a Rust program.\n+`#[main]` attribute. This is an error because there must be a unique entry\n+point into a Rust program.\n \"##,\n \n E0152: r##\""}, {"sha": "7e7af8006805d1354ce61e05af3adecdabd4b39f", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 104, "deletions": 4, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -10,8 +10,111 @@\n \n #![allow(non_snake_case)]\n \n+// Error messages for EXXXX errors.\n+// Each message should start and end with a new line, and be wrapped to 80 characters.\n+// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n+register_long_diagnostics! {\n+\n+E0154: r##\"\n+Imports (`use` statements) are not allowed after non-item statements, such as\n+variable declarations and expression statements.\n+\n+Here is an example that demonstrates the error:\n+```\n+fn f() {\n+    // Variable declaration before import\n+    let x = 0;\n+    use std::io::Read;\n+    ...\n+}\n+```\n+\n+The solution is to declare the imports at the top of the block, function, or\n+file.\n+\n+Here is the previous example again, with the correct order:\n+```\n+fn f() {\n+    use std::io::Read;\n+    let x = 0;\n+    ...\n+}\n+```\n+\n+See the Declaration Statements section of the reference for more information\n+about what constitutes an Item declaration and what does not:\n+\n+http://doc.rust-lang.org/reference.html#statements\n+\"##,\n+\n+E0259: r##\"\n+The name chosen for an external crate conflicts with another external crate that\n+has been imported into the current module.\n+\n+Wrong example:\n+```\n+extern crate a;\n+extern crate crate_a as a;\n+```\n+\n+The solution is to choose a different name that doesn't conflict with any\n+external crate imported into the current module.\n+\n+Correct example:\n+```\n+extern crate a;\n+extern crate crate_a as other_name;\n+```\n+\"##,\n+\n+E0260: r##\"\n+The name for an item declaration conflicts with an external crate's name.\n+\n+For instance,\n+```\n+extern crate abc;\n+\n+struct abc;\n+```\n+\n+There are two possible solutions:\n+\n+Solution #1: Rename the item.\n+\n+```\n+extern crate abc;\n+\n+struct xyz;\n+```\n+\n+Solution #2: Import the crate with a different name.\n+\n+```\n+extern crate abc as xyz;\n+\n+struct abc;\n+```\n+\n+See the Declaration Statements section of the reference for more information\n+about what constitutes an Item declaration and what does not:\n+\n+http://doc.rust-lang.org/reference.html#statements\n+\"##,\n+\n+E0317: r##\"\n+User-defined types or type parameters cannot shadow the primitive types.\n+This error indicates you tried to define a type, struct or enum with the same\n+name as an existing primitive type.\n+\n+See the Types section of the reference for more information about the primitive\n+types:\n+\n+http://doc.rust-lang.org/reference.html#types\n+\"##\n+\n+}\n+\n register_diagnostics! {\n-    E0154,\n     E0157,\n     E0153,\n     E0251, // a named type or value has already been imported in this module\n@@ -22,9 +125,6 @@ register_diagnostics! {\n     E0256, // import conflicts with type in this module\n     E0257, // inherent implementations are only allowed on types defined in the current module\n     E0258, // import conflicts with existing submodule\n-    E0259, // an extern crate has already been imported into this module\n-    E0260, // name conflicts with an external crate that has been imported into this module\n-    E0317, // user-defined types or type parameters cannot shadow the primitive types\n     E0364, // item is private\n     E0365  // item is private\n }"}, {"sha": "f9565d528e89a266fd2228d6f2eb143744752e78", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -186,7 +186,7 @@ struct Foo<'a> {\n ```\n \n This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n-differs from the behavior for `&T`, which is `Copy` when `T` is `Copy`).\n+differs from the behavior for `&T`, which is always `Copy`).\n \"##,\n \n E0205: r##\"\n@@ -216,7 +216,7 @@ enum Foo<'a> {\n ```\n \n This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n-differs from the behavior for `&T`, which is `Copy` when `T` is `Copy`).\n+differs from the behavior for `&T`, which is always `Copy`).\n \"##,\n \n E0206: r##\""}, {"sha": "a48c03aa178c35df84fbe42ea31e8de47bfef79f", "filename": "src/test/compile-fail/issue-20413.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Ftest%2Fcompile-fail%2Fissue-20413.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Ftest%2Fcompile-fail%2Fissue-20413.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20413.rs?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+  fn answer(self);\n+}\n+\n+struct NoData<T>;\n+//~^ ERROR: parameter `T` is never used\n+\n+impl<T> Foo for T where NoData<T>: Foo {\n+//~^ ERROR: overflow evaluating the requirement\n+  fn answer(self) {\n+    let val: NoData<T> = NoData;\n+  }\n+}\n+\n+fn main() {}"}, {"sha": "5f07ba2235fd539ab24d03ba3a66ac8179ff2024", "filename": "src/test/run-pass/issue-18075.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Ftest%2Frun-pass%2Fissue-18075.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Ftest%2Frun-pass%2Fissue-18075.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18075.rs?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// exec-env:RUST_LOG=rustc::middle=debug\n+\n+fn main() {\n+    let b = 1isize;\n+    println!(\"{}\", b);\n+}"}]}