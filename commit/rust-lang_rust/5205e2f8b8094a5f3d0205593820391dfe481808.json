{"sha": "5205e2f8b8094a5f3d0205593820391dfe481808", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMDVlMmY4YjgwOTRhNWYzZDAyMDU1OTM4MjAzOTFkZmU0ODE4MDg=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertaylorj@gmail.com", "date": "2017-02-15T22:52:27Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertaylorj@gmail.com", "date": "2017-02-18T02:58:32Z"}, "message": "Normalize labeled and unlabeled breaks", "tree": {"sha": "7844b5d1ccc0cfdc57237259ff0dd042f39b5e21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7844b5d1ccc0cfdc57237259ff0dd042f39b5e21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5205e2f8b8094a5f3d0205593820391dfe481808", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5205e2f8b8094a5f3d0205593820391dfe481808", "html_url": "https://github.com/rust-lang/rust/commit/5205e2f8b8094a5f3d0205593820391dfe481808", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5205e2f8b8094a5f3d0205593820391dfe481808/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48bc08247a7b4a5579437df54ca3f4a3fb25ce8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/48bc08247a7b4a5579437df54ca3f4a3fb25ce8d", "html_url": "https://github.com/rust-lang/rust/commit/48bc08247a7b4a5579437df54ca3f4a3fb25ce8d"}], "stats": {"total": 277, "additions": 138, "deletions": 139}, "files": [{"sha": "bc3da13ccf82d52823843d8cb8742398bc27dd58", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -579,17 +579,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn find_scope(&self,\n                   expr: &hir::Expr,\n-                  label: Option<hir::Label>) -> LoopScope {\n-        match label {\n-            None => *self.loop_scopes.last().unwrap(),\n-            Some(label) => {\n-                for l in &self.loop_scopes {\n-                    if l.loop_id == label.loop_id {\n-                        return *l;\n-                    }\n-                }\n-                span_bug!(expr.span, \"no loop scope for id {}\", label.loop_id);\n+                  label: hir::Label) -> LoopScope {\n+        for l in &self.loop_scopes {\n+            if l.loop_id == label.loop_id {\n+                return *l;\n             }\n         }\n+        span_bug!(expr.span, \"no loop scope for id {}\", label.loop_id);\n     }\n }"}, {"sha": "03b59aaf319c674b69520f4b4f929af6f71b166d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -1006,18 +1006,18 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprPath(ref qpath) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n         }\n-        ExprBreak(None, ref opt_expr) => {\n+        ExprBreak(label, ref opt_expr) => {\n+            label.ident.map(|ident| {\n+                visitor.visit_def_mention(Def::Label(label.loop_id));\n+                visitor.visit_name(ident.span, ident.node.name);\n+            });\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprBreak(Some(label), ref opt_expr) => {\n-            visitor.visit_def_mention(Def::Label(label.loop_id));\n-            visitor.visit_name(label.span, label.name);\n-            walk_list!(visitor, visit_expr, opt_expr);\n-        }\n-        ExprAgain(None) => {}\n-        ExprAgain(Some(label)) => {\n-            visitor.visit_def_mention(Def::Label(label.loop_id));\n-            visitor.visit_name(label.span, label.name);\n+        ExprAgain(label) => {\n+            label.ident.map(|ident| {\n+                visitor.visit_def_mention(Def::Label(label.loop_id));\n+                visitor.visit_name(ident.span, ident.node.name);\n+            });\n         }\n         ExprRet(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}, {"sha": "d6f99327d4fa2bbb242b6c920169e3562b71c9a9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 81, "deletions": 34, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -50,6 +50,7 @@ use util::nodemap::{DefIdMap, NodeMap, FxHashMap};\n \n use std::collections::BTreeMap;\n use std::iter;\n+use std::mem;\n \n use syntax::attr;\n use syntax::ast::*;\n@@ -79,6 +80,8 @@ pub struct LoweringContext<'a> {\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n     bodies: FxHashMap<hir::BodyId, hir::Body>,\n \n+    loop_scopes: Vec<NodeId>,\n+\n     type_def_lifetime_params: DefIdMap<usize>,\n }\n \n@@ -112,6 +115,7 @@ pub fn lower_crate(sess: &Session,\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n         bodies: FxHashMap(),\n+        loop_scopes: Vec::new(),\n         type_def_lifetime_params: DefIdMap(),\n     }.lower_crate(krate)\n }\n@@ -244,6 +248,27 @@ impl<'a> LoweringContext<'a> {\n         span\n     }\n \n+    fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let len = self.loop_scopes.len();\n+        self.loop_scopes.push(loop_id);\n+        let result = f(self);\n+        assert_eq!(len + 1, self.loop_scopes.len(),\n+            \"Loop scopes should be added and removed in stack order\");\n+        self.loop_scopes.pop().unwrap();\n+        result\n+    }\n+\n+    fn with_new_loop_scopes<T, F>(&mut self, f: F) -> T\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let loop_scopes = mem::replace(&mut self.loop_scopes, Vec::new());\n+        let result = f(self);\n+        mem::replace(&mut self.loop_scopes, loop_scopes);\n+        result\n+    }\n+\n     fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n@@ -271,17 +296,23 @@ impl<'a> LoweringContext<'a> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n \n-    fn lower_label(&mut self, id: NodeId, label: Option<Spanned<Ident>>) -> Option<hir::Label> {\n-        label.map(|sp_ident| {\n-            hir::Label {\n-                span: sp_ident.span,\n-                name: sp_ident.node.name,\n+    fn lower_label(&mut self, label: Option<(NodeId, Spanned<Ident>)>) -> hir::Label {\n+        match label {\n+            Some((id, label_ident)) => hir::Label {\n+                ident: Some(label_ident),\n                 loop_id: match self.expect_full_def(id) {\n                     Def::Label(loop_id) => loop_id,\n                     _ => DUMMY_NODE_ID\n                 }\n+            },\n+            None => hir::Label {\n+                ident: None,\n+                loop_id: match self.loop_scopes.last() {\n+                    Some(innermost_loop_id) => *innermost_loop_id,\n+                    _ => DUMMY_NODE_ID\n+                }\n             }\n-        })\n+        }\n     }\n \n     fn lower_attrs(&mut self, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n@@ -992,15 +1023,17 @@ impl<'a> LoweringContext<'a> {\n                                self.record_body(value, None))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n-                let body = self.lower_block(body);\n-                let body = self.expr_block(body, ThinVec::new());\n-                let body_id = self.record_body(body, Some(decl));\n-                hir::ItemFn(self.lower_fn_decl(decl),\n-                            self.lower_unsafety(unsafety),\n-                            self.lower_constness(constness),\n-                            abi,\n-                            self.lower_generics(generics),\n-                            body_id)\n+                self.with_new_loop_scopes(|this| {\n+                    let body = this.lower_block(body);\n+                    let body = this.expr_block(body, ThinVec::new());\n+                    let body_id = this.record_body(body, Some(decl));\n+                    hir::ItemFn(this.lower_fn_decl(decl),\n+                                              this.lower_unsafety(unsafety),\n+                                              this.lower_constness(constness),\n+                                              abi,\n+                                              this.lower_generics(generics),\n+                                              body_id)\n+                })\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n@@ -1562,26 +1595,32 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprIf(P(self.lower_expr(cond)), self.lower_block(blk), else_opt)\n                 }\n                 ExprKind::While(ref cond, ref body, opt_ident) => {\n-                    hir::ExprWhile(P(self.lower_expr(cond)), self.lower_block(body),\n-                                   self.lower_opt_sp_ident(opt_ident))\n+                    self.with_loop_scope(e.id, |this|\n+                        hir::ExprWhile(\n+                            P(this.lower_expr(cond)),\n+                            this.lower_block(body),\n+                            this.lower_opt_sp_ident(opt_ident)))\n                 }\n                 ExprKind::Loop(ref body, opt_ident) => {\n-                    hir::ExprLoop(self.lower_block(body),\n-                                  self.lower_opt_sp_ident(opt_ident),\n-                                  hir::LoopSource::Loop)\n+                    self.with_loop_scope(e.id, |this|\n+                        hir::ExprLoop(this.lower_block(body),\n+                                      this.lower_opt_sp_ident(opt_ident),\n+                                      hir::LoopSource::Loop))\n                 }\n                 ExprKind::Match(ref expr, ref arms) => {\n                     hir::ExprMatch(P(self.lower_expr(expr)),\n                                    arms.iter().map(|x| self.lower_arm(x)).collect(),\n                                    hir::MatchSource::Normal)\n                 }\n                 ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n-                    self.with_parent_def(e.id, |this| {\n-                        let expr = this.lower_expr(body);\n-                        hir::ExprClosure(this.lower_capture_clause(capture_clause),\n-                                         this.lower_fn_decl(decl),\n-                                         this.record_body(expr, Some(decl)),\n-                                         fn_decl_span)\n+                    self.with_new_loop_scopes(|this| {\n+                        this.with_parent_def(e.id, |this| {\n+                            let expr = this.lower_expr(body);\n+                            hir::ExprClosure(this.lower_capture_clause(capture_clause),\n+                                             this.lower_fn_decl(decl),\n+                                             this.record_body(expr, Some(decl)),\n+                                             fn_decl_span)\n+                        })\n                     })\n                 }\n                 ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk)),\n@@ -1660,10 +1699,13 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional))\n                 }\n                 ExprKind::Break(opt_ident, ref opt_expr) => {\n-                    hir::ExprBreak(self.lower_label(e.id, opt_ident),\n+                    hir::ExprBreak(\n+                        self.lower_label(opt_ident.map(|ident| (e.id, ident))),\n                                    opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n-                ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_label(e.id, opt_ident)),\n+                ExprKind::Continue(opt_ident) =>\n+                    hir::ExprAgain(\n+                        self.lower_label(opt_ident.map(|ident| (e.id, ident)))),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n                 ExprKind::InlineAsm(ref asm) => {\n                     let hir_asm = hir::InlineAsm {\n@@ -1804,9 +1846,14 @@ impl<'a> LoweringContext<'a> {\n                     //     }\n                     //   }\n \n+                    let (body, break_expr, sub_expr) = self.with_loop_scope(e.id, |this| (\n+                        this.lower_block(body),\n+                        this.expr_break(e.span, ThinVec::new()),\n+                        P(this.lower_expr(sub_expr)),\n+                    ));\n+\n                     // `<pat> => <body>`\n                     let pat_arm = {\n-                        let body = self.lower_block(body);\n                         let body_expr = P(self.expr_block(body, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n@@ -1815,13 +1862,11 @@ impl<'a> LoweringContext<'a> {\n                     // `_ => break`\n                     let break_arm = {\n                         let pat_under = self.pat_wild(e.span);\n-                        let break_expr = self.expr_break(e.span, ThinVec::new());\n                         self.arm(hir_vec![pat_under], break_expr)\n                     };\n \n                     // `match <sub_expr> { ... }`\n                     let arms = hir_vec![pat_arm, break_arm];\n-                    let sub_expr = P(self.lower_expr(sub_expr));\n                     let match_expr = self.expr(e.span,\n                                                hir::ExprMatch(sub_expr,\n                                                               arms,\n@@ -1863,7 +1908,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `::std::option::Option::Some(<pat>) => <body>`\n                     let pat_arm = {\n-                        let body_block = self.lower_block(body);\n+                        let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body));\n                         let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         let some_pat = self.pat_some(e.span, pat);\n@@ -1873,7 +1918,8 @@ impl<'a> LoweringContext<'a> {\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n-                        let break_expr = self.expr_break(e.span, ThinVec::new());\n+                        let break_expr = self.with_loop_scope(e.id, |this|\n+                            this.expr_break(e.span, ThinVec::new()));\n                         let pat = self.pat_none(e.span);\n                         self.arm(hir_vec![pat], break_expr)\n                     };\n@@ -2151,7 +2197,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        P(self.expr(span, hir::ExprBreak(None, None), attrs))\n+        let expr_break = hir::ExprBreak(self.lower_label(None), None);\n+        P(self.expr(span, expr_break, attrs))\n     }\n \n     fn expr_call(&mut self, span: Span, e: P<hir::Expr>, args: hir::HirVec<hir::Expr>)"}, {"sha": "fc5282d1af2f228e8382107fb67332f28cb0634e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -36,7 +36,7 @@ use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n use syntax_pos::{Span, ExpnId, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n-use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n+use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n@@ -959,9 +959,9 @@ pub enum Expr_ {\n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<Label>, Option<P<Expr>>),\n+    ExprBreak(Label, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Option<Label>),\n+    ExprAgain(Label),\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n@@ -1033,8 +1033,7 @@ pub enum LoopSource {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct Label {\n-    pub span: Span,\n-    pub name: Name,\n+    pub ident: Option<Spanned<Ident>>,\n     pub loop_id: NodeId\n }\n "}, {"sha": "3411de9bb5df11356b753f08bb2c49c5946c74f4", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -1354,23 +1354,23 @@ impl<'a> State<'a> {\n             hir::ExprPath(ref qpath) => {\n                 self.print_qpath(qpath, true)?\n             }\n-            hir::ExprBreak(opt_label, ref opt_expr) => {\n+            hir::ExprBreak(label, ref opt_expr) => {\n                 word(&mut self.s, \"break\")?;\n                 space(&mut self.s)?;\n-                if let Some(label) = opt_label {\n-                    self.print_name(label.name)?;\n+                if let Some(label_ident) = label.ident {\n+                    self.print_name(label_ident.node.name)?;\n                     space(&mut self.s)?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr(expr)?;\n                     space(&mut self.s)?;\n                 }\n             }\n-            hir::ExprAgain(opt_label) => {\n+            hir::ExprAgain(label) => {\n                 word(&mut self.s, \"continue\")?;\n                 space(&mut self.s)?;\n-                if let Some(label) = opt_label {\n-                    self.print_name(label.name)?;\n+                if let Some(label_ident) = label.ident {\n+                    self.print_name(label_ident.node.name)?;\n                     space(&mut self.s)?\n                 }\n             }"}, {"sha": "60d2a213ecef68e81f4537343597b323e3b0c41f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -675,23 +675,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn find_loop_scope(&self,\n-                       opt_label: Option<hir::Label>,\n-                       sp: Span)\n-                       -> NodeId {\n-        match opt_label {\n-            Some(label) => label.loop_id,\n-            None => {\n-                // Vanilla 'break' or 'continue', so use the enclosing\n-                // loop scope\n-                if self.loop_scope.is_empty() {\n-                    span_bug!(sp, \"break outside loop\");\n-                } else {\n-                    *self.loop_scope.last().unwrap()\n-                }\n-            }\n-        }\n-    }\n \n     #[allow(unused_must_use)]\n     fn ln_str(&self, ln: LiveNode) -> String {\n@@ -1018,9 +1001,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n-          hir::ExprBreak(opt_label, ref opt_expr) => {\n+          hir::ExprBreak(label, ref opt_expr) => {\n               // Find which label this break jumps to\n-              let sc = self.find_loop_scope(opt_label, expr.span);\n+              let sc = label.loop_id;\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n@@ -1031,9 +1014,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          hir::ExprAgain(opt_label) => {\n+          hir::ExprAgain(label) => {\n               // Find which label this expr continues to\n-              let sc = self.find_loop_scope(opt_label, expr.span);\n+              let sc = label.loop_id;\n \n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table"}, {"sha": "62bbb86e7dad5be4e10b41dc72bee1da773487dd", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -338,8 +338,10 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprIndex(..)            => (SawExprIndex, true),\n         ExprPath(_)              => (SawExprPath, false),\n         ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n-        ExprBreak(label, _)      => (SawExprBreak(label.map(|l| l.name.as_str())), false),\n-        ExprAgain(label)         => (SawExprAgain(label.map(|l| l.name.as_str())), false),\n+        ExprBreak(label, _)      => (SawExprBreak(label.ident.map(|i|\n+                                                    i.node.name.as_str())), false),\n+        ExprAgain(label)         => (SawExprAgain(label.ident.map(|i|\n+                                                    i.node.name.as_str())), false),\n         ExprRet(..)              => (SawExprRet, false),\n         ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(StableInlineAsm(a)), false),\n         ExprStruct(..)           => (SawExprStruct, false),"}, {"sha": "695564fa85bc0416052dd3d5da99b948dcf72d2f", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -385,22 +385,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// resolving `break` and `continue`.\n     pub fn find_loop_scope(&mut self,\n                            span: Span,\n-                           label: Option<CodeExtent>)\n+                           label: CodeExtent)\n                            -> &mut LoopScope<'tcx> {\n-        let loop_scopes = &mut self.loop_scopes;\n-        match label {\n-            None => {\n-                // no label? return the innermost loop scope\n-                loop_scopes.iter_mut().rev().next()\n-            }\n-            Some(label) => {\n-                // otherwise, find the loop-scope with the correct id\n-                loop_scopes.iter_mut()\n-                           .rev()\n-                           .filter(|loop_scope| loop_scope.extent == label)\n-                           .next()\n-            }\n-        }.unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n+        // find the loop-scope with the correct id\n+        self.loop_scopes.iter_mut()\n+                   .rev()\n+                   .filter(|loop_scope| loop_scope.extent == label)\n+                   .next()\n+            .unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n     }\n \n     /// Given a span and the current visibility scope, make a SourceInfo."}, {"sha": "80ba93f0bbfcadb8fb1b48f02216a0605d695afc", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -606,13 +606,13 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n         hir::ExprBreak(label, ref value) => {\n             ExprKind::Break {\n-                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+                label: cx.tcx.region_maps.node_extent(label.loop_id),\n                 value: value.to_ref(),\n             }\n         }\n         hir::ExprAgain(label) => {\n             ExprKind::Continue {\n-                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+                label: cx.tcx.region_maps.node_extent(label.loop_id),\n             }\n         }\n         hir::ExprMatch(ref discr, ref arms, _) => {"}, {"sha": "3068258f6c24f185bb5cf09154de4d7e542a1a4a", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -205,11 +205,11 @@ pub enum ExprKind<'tcx> {\n         arg: ExprRef<'tcx>,\n     },\n     Break {\n-        label: Option<CodeExtent>,\n+        label: CodeExtent,\n         value: Option<ExprRef<'tcx>>,\n     },\n     Continue {\n-        label: Option<CodeExtent>,\n+        label: CodeExtent,\n     },\n     Return {\n         value: Option<ExprRef<'tcx>>,"}, {"sha": "5f9acc0430a817b099f0c120eaf4d61d08b21f98", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -88,22 +88,15 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n                 if opt_expr.is_some() {\n-                    let loop_kind = if let Some(label) = label {\n-                        if label.loop_id == ast::DUMMY_NODE_ID {\n-                            None\n-                        } else {\n-                            Some(match self.hir_map.expect_expr(label.loop_id).node {\n-                                hir::ExprWhile(..) => LoopKind::WhileLoop,\n-                                hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n-                                ref r => span_bug!(e.span,\n-                                                   \"break label resolved to a non-loop: {:?}\", r),\n-                            })\n-                        }\n-                    } else if let Loop(kind) = self.cx {\n-                        Some(kind)\n-                    } else {\n-                        // `break` outside a loop - caught below\n+                    let loop_kind = if label.loop_id == ast::DUMMY_NODE_ID {\n                         None\n+                    } else {\n+                        Some(match self.hir_map.expect_expr(label.loop_id).node {\n+                            hir::ExprWhile(..) => LoopKind::WhileLoop,\n+                            hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n+                            ref r => span_bug!(e.span,\n+                                               \"break label resolved to a non-loop: {:?}\", r),\n+                        })\n                     };\n                     match loop_kind {\n                         None | Some(LoopKind::Loop(hir::LoopSource::Loop)) => (),"}, {"sha": "e9c9a63d79be9a60a3a9ca214887e3b405634086", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -425,15 +425,11 @@ pub struct EnclosingLoops<'gcx, 'tcx> {\n }\n \n impl<'gcx, 'tcx> EnclosingLoops<'gcx, 'tcx> {\n-    fn find_loop(&mut self, id: Option<ast::NodeId>) -> Option<&mut LoopCtxt<'gcx, 'tcx>> {\n-        if let Some(id) = id {\n-            if let Some(ix) = self.by_id.get(&id).cloned() {\n-                Some(&mut self.stack[ix])\n-            } else {\n-                None\n-            }\n+    fn find_loop(&mut self, id: ast::NodeId) -> Option<&mut LoopCtxt<'gcx, 'tcx>> {\n+        if let Some(ix) = self.by_id.get(&id).cloned() {\n+            Some(&mut self.stack[ix])\n         } else {\n-            self.stack.last_mut()\n+            None\n         }\n     }\n }\n@@ -3596,7 +3592,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               tcx.mk_nil()\n           }\n           hir::ExprBreak(label, ref expr_opt) => {\n-            let loop_id = label.map(|l| l.loop_id);\n+            let loop_id = label.loop_id;\n             let coerce_to = {\n                 let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n                 enclosing_loops.find_loop(loop_id).map(|ctxt| ctxt.coerce_to)"}, {"sha": "10ff8dbf18e5e1cb4090e838509d7fbe46bf87e2", "filename": "src/test/run-pass/loop-break-value.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5205e2f8b8094a5f3d0205593820391dfe481808/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-break-value.rs?ref=5205e2f8b8094a5f3d0205593820391dfe481808", "patch": "@@ -122,12 +122,4 @@ pub fn main() {\n         panic!();\n     };\n     assert_eq!(nested_break_value, \"hello\");\n-\n-    let break_from_while_cond = loop {\n-        while break {\n-            panic!();\n-        }\n-        break 123;\n-    };\n-    assert_eq!(break_from_while_cond, 123);\n }"}]}