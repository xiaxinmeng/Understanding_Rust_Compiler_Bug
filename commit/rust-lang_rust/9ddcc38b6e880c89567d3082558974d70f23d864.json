{"sha": "9ddcc38b6e880c89567d3082558974d70f23d864", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZGNjMzhiNmU4ODBjODk1NjdkMzA4MjU1ODk3NGQ3MGYyM2Q4NjQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-20T20:37:01Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-21T01:17:46Z"}, "message": "Refocus unsafe code chapter on unsafe itself.", "tree": {"sha": "f21a1a73533f5c9ebc85c4c3a08d00aaca15cd7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f21a1a73533f5c9ebc85c4c3a08d00aaca15cd7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ddcc38b6e880c89567d3082558974d70f23d864", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ddcc38b6e880c89567d3082558974d70f23d864", "html_url": "https://github.com/rust-lang/rust/commit/9ddcc38b6e880c89567d3082558974d70f23d864", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ddcc38b6e880c89567d3082558974d70f23d864/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "550c8d87a7ad6b9a4a8bea56136f40844436cc08", "url": "https://api.github.com/repos/rust-lang/rust/commits/550c8d87a7ad6b9a4a8bea56136f40844436cc08", "html_url": "https://github.com/rust-lang/rust/commit/550c8d87a7ad6b9a4a8bea56136f40844436cc08"}], "stats": {"total": 198, "additions": 121, "deletions": 77}, "files": [{"sha": "ab5e8ed16ad2328e25d908046a48f60930ceb408", "filename": "src/doc/trpl/unsafe-code.md", "status": "modified", "additions": 121, "deletions": 77, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/9ddcc38b6e880c89567d3082558974d70f23d864/src%2Fdoc%2Ftrpl%2Funsafe-code.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ddcc38b6e880c89567d3082558974d70f23d864/src%2Fdoc%2Ftrpl%2Funsafe-code.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe-code.md?ref=9ddcc38b6e880c89567d3082558974d70f23d864", "patch": "@@ -1,84 +1,128 @@\n-% Raw Pointers\n-\n-Rust offers two additional pointer types (*raw pointers*), written as\n-`*const T` and `*mut T`. They're an approximation of C's `const T*` and `T*`\n-respectively; indeed, one of their most common uses is for FFI,\n-interfacing with external C libraries.\n-\n-Raw pointers have much fewer guarantees than other pointer types\n-offered by the Rust language and libraries. For example, they\n-\n-- are not guaranteed to point to valid memory and are not even\n-  guaranteed to be non-null (unlike both `Box` and `&`);\n-- do not have any automatic clean-up, unlike `Box`, and so require\n-  manual resource management;\n-- are plain-old-data, that is, they don't move ownership, again unlike\n-  `Box`, hence the Rust compiler cannot protect against bugs like\n-  use-after-free;\n-- lack any form of lifetimes, unlike `&`, and so the compiler cannot\n-  reason about dangling pointers; and\n-- have no guarantees about aliasing or mutability other than mutation\n-  not being allowed directly through a `*const T`.\n-\n-Fortunately, they come with a redeeming feature: the weaker guarantees\n-mean weaker restrictions. The missing restrictions make raw pointers\n-appropriate as a building block for implementing things like smart\n-pointers and vectors inside libraries. For example, `*` pointers are\n-allowed to alias, allowing them to be used to write shared-ownership\n-types like reference counted and garbage collected pointers, and even\n-thread-safe shared memory types (`Rc` and the `Arc` types are both\n-implemented entirely in Rust).\n-\n-There are two things that you are required to be careful about\n-(i.e. require an `unsafe { ... }` block) with raw pointers:\n-\n-- dereferencing: they can have any value: so possible results include\n-  a crash, a read of uninitialised memory, a use-after-free, or\n-  reading data as normal.\n-- pointer arithmetic via the `offset` [intrinsic](#intrinsics) (or\n-  `.offset` method): this intrinsic uses so-called \"in-bounds\"\n-  arithmetic, that is, it is only defined behaviour if the result is\n-  inside (or one-byte-past-the-end) of the object from which the\n-  original pointer came.\n-\n-The latter assumption allows the compiler to optimize more\n-effectively. As can be seen, actually *creating* a raw pointer is not\n-unsafe, and neither is converting to an integer.\n-\n-### References and raw pointers\n-\n-At runtime, a raw pointer `*` and a reference pointing to the same\n-piece of data have an identical representation. In fact, an `&T`\n-reference will implicitly coerce to an `*const T` raw pointer in safe code\n-and similarly for the `mut` variants (both coercions can be performed\n-explicitly with, respectively, `value as *const T` and `value as *mut T`).\n-\n-Going the opposite direction, from `*const` to a reference `&`, is not\n-safe. A `&T` is always valid, and so, at a minimum, the raw pointer\n-`*const T` has to point to a valid instance of type `T`. Furthermore,\n-the resulting pointer must satisfy the aliasing and mutability laws of\n-references. The compiler assumes these properties are true for any\n-references, no matter how they are created, and so any conversion from\n-raw pointers is asserting that they hold. The programmer *must*\n-guarantee this.\n-\n-The recommended method for the conversion is\n+% Unsafe Code\n \n+Rust\u2019s main draw is its powerful static guarantees about behavior. But safety\n+checks are conservative by nature: there are some programs that are actually\n+safe, but the compiler is not able to verify this is true. To write these kinds\n+of programs, we need to tell the compiler to relax its restrictions a bit. For\n+this, Rust has a keyword, `unsafe`. Code using `unsafe` has less restrictions\n+than normal code does.\n+\n+Let\u2019s go over the syntax, and then we\u2019ll talk semantics. `unsafe` is used in\n+two contexts. The first one is to mark a function as unsafe:\n+\n+```rust\n+unsafe fn danger_will_robinson() {\n+    // scary stuff \n+}\n ```\n-let i: u32 = 1;\n-// explicit cast\n-let p_imm: *const u32 = &i as *const u32;\n-let mut m: u32 = 2;\n-// implicit coercion\n-let p_mut: *mut u32 = &mut m;\n \n+All functions called from [FFI][ffi] must be marked as `unsafe`, for example.\n+The second use of `unsafe` is an unsafe block:\n+\n+[ffi]: ffi.html\n+\n+```rust\n unsafe {\n-    let ref_imm: &u32 = &*p_imm;\n-    let ref_mut: &mut u32 = &mut *p_mut;\n+    // scary stuff\n }\n ```\n \n-The `&*x` dereferencing style is preferred to using a `transmute`.\n-The latter is far more powerful than necessary, and the more\n-restricted operation is harder to use incorrectly; for example, it\n-requires that `x` is a pointer (unlike `transmute`).\n+It\u2019s important to be able to explicitly delineate code that may have bugs that\n+cause big problems. If a Rust program segfaults, you can be sure it\u2019s somewhere\n+in the sections marked `unsafe`.\n+\n+# What does \u2018safe\u2019 mean?\n+\n+Safe, in the context of Rust, means \u201cdoesn\u2019t do anything unsafe.\u201d Easy!\n+\n+Okay, let\u2019s try again: what is not safe to do? Here\u2019s a list:\n+\n+* Data races\n+* Dereferencing a null/dangling raw pointer\n+* Reads of [undef][undef] (uninitialized) memory\n+* Breaking the [pointer aliasing rules][aliasing] with raw pointers.\n+* `&mut T` and `&T` follow LLVM\u2019s scoped [noalias][noalias] model, except if\n+  the `&T` contains an `UnsafeCell<U>`. Unsafe code must not violate these\n+  aliasing guarantees.\n+* Mutating an immutable value/reference without `UnsafeCell<U>`\n+* Invoking undefined behavior via compiler intrinsics:\n+  * Indexing outside of the bounds of an object with `std::ptr::offset`\n+    (`offset` intrinsic), with\n+    the exception of one byte past the end which is permitted.\n+  * Using `std::ptr::copy_nonoverlapping_memory` (`memcpy32`/`memcpy64`\n+    intrinsics) on overlapping buffers\n+* Invalid values in primitive types, even in private fields/locals:\n+  * Null/dangling references or boxes\n+  * A value other than `false` (0) or `true` (1) in a `bool`\n+  * A discriminant in an `enum` not included in its type definition\n+  * A value in a `char` which is a surrogate or above `char::MAX`\n+  * Non-UTF-8 byte sequences in a `str`\n+* Unwinding into Rust from foreign code or unwinding from Rust into foreign\n+  code.\n+\n+[noalias]: http://llvm.org/docs/LangRef.html#noalias\n+[undef]: http://llvm.org/docs/LangRef.html#undefined-values\n+[aliasing]: http://llvm.org/docs/LangRef.html#pointer-aliasing-rules\n+\n+Whew! That\u2019s a bunch of stuff. It\u2019s also important to notice all kinds of\n+behaviors that are certainly bad, but are expressly _not_ unsafe:\n+\n+* Deadlocks\n+* Reading data from private fields\n+* Leaks due to reference count cycles\n+* Exiting without calling destructors\n+* Sending signals\n+* Accessing/modifying the file system\n+* Integer overflow\n+\n+Rust cannot prevent all kinds of software problems. Buggy code can and will be\n+written in Rust. These things arne\u2019t great, but they don\u2019t qualify as `unsafe`\n+specifically.\n+\n+# Unsafe Superpowers\n+\n+In both unsafe functions and unsafe blocks, Rust will let you do three things\n+that you normally can not do. Just three. Here they are:\n+\n+1. Access or update a [static mutable variable][static].\n+2. Dereference a raw pointer.\n+3. Call unsafe functions. This is the most powerful ability.\n+\n+That\u2019s it. It\u2019s important that `unsafe` does not, for example, \u2018turn off the\n+borrow checker\u2019. Adding `unsafe` to some random Rust code doesn\u2019t change its\n+semantics, it won\u2019t just start accepting anything.\n+\n+But it will let you write things that _do_ break some of the rules. Let\u2019s go\n+over these three abilities in order.\n+\n+## Access or update a `static mut`\n+\n+Rust has a feature called \u2018`static mut`\u2019 which allows for mutable global state.\n+Doing so can cause a data race, and as such is inherently not safe. For more\n+details, see the [static][static] section of the book.\n+\n+[static]: static.html\n+\n+## Dereference a raw pointer\n+\n+Raw pointers let you do arbitrary pointer arithmetic, and can cause a number of\n+different memory safety and security issues. In some senses, the ability to\n+dereference an arbitrary pointer is one of the most dangerous things you can\n+do. For more on raw pointers, see [their section of the book][rawpointers].\n+\n+[rawpointers]: raw-pointers.html\n+\n+## Call unsafe functions\n+\n+This last ability works with both aspects of `unsafe`: you can only call\n+functions marked `unsafe` from inside an unsafe block.\n+\n+This ability is powerful and varied. Rust exposes some [compiler\n+intrinsics][intrinsics] as unsafe functions, and some unsafe functions bypass\n+safety checks, trading safety for speed.\n+\n+I\u2019ll repeat again: even though you _can_ do arbitrary things in unsafe blocks\n+and functions doesn\u2019t mean you should. The compiler will act as though you\u2019re\n+upholding its invariants, so be careful!\n+\n+[intrinsics]: intrinsics.html"}]}