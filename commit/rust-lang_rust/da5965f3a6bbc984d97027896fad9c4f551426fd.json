{"sha": "da5965f3a6bbc984d97027896fad9c4f551426fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNTk2NWYzYTZiYmM5ODRkOTcwMjc4OTZmYWQ5YzRmNTUxNDI2ZmQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-28T18:21:12Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-28T18:21:12Z"}, "message": "proc_macro: consolidate bridge::client::run_expand{1,2} into one helper.", "tree": {"sha": "8611aa5a621466dcc6e97023671711e28a6cf1b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8611aa5a621466dcc6e97023671711e28a6cf1b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da5965f3a6bbc984d97027896fad9c4f551426fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da5965f3a6bbc984d97027896fad9c4f551426fd", "html_url": "https://github.com/rust-lang/rust/commit/da5965f3a6bbc984d97027896fad9c4f551426fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da5965f3a6bbc984d97027896fad9c4f551426fd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3f64946f9d89833c1f05bd010c464f54c3fb6b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3f64946f9d89833c1f05bd010c464f54c3fb6b5", "html_url": "https://github.com/rust-lang/rust/commit/b3f64946f9d89833c1f05bd010c464f54c3fb6b5"}], "stats": {"total": 71, "additions": 23, "deletions": 48}, "files": [{"sha": "b17359a4c8cf746171963d9e7be7fc1e257e6f64", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 23, "deletions": 48, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/da5965f3a6bbc984d97027896fad9c4f551426fd/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5965f3a6bbc984d97027896fad9c4f551426fd/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=da5965f3a6bbc984d97027896fad9c4f551426fd", "patch": "@@ -341,22 +341,25 @@ pub struct Client<F> {\n     pub(super) f: F,\n }\n \n-extern \"C\" fn run_expand1(\n+/// Client-side helper for handling client panics, entering the bridge,\n+/// deserializing input and serializing output.\n+// FIXME(eddyb) maybe replace `Bridge::enter` with this?\n+fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n     mut bridge: Bridge<'_>,\n-    f: fn(crate::TokenStream) -> crate::TokenStream,\n+    f: impl FnOnce(A) -> R,\n ) -> Buffer<u8> {\n     // The initial `cached_buffer` contains the input.\n     let mut b = bridge.cached_buffer.take();\n \n     panic::catch_unwind(panic::AssertUnwindSafe(|| {\n         bridge.enter(|| {\n             let reader = &mut &b[..];\n-            let input = TokenStream::decode(reader, &mut ());\n+            let input = A::decode(reader, &mut ());\n \n             // Put the `cached_buffer` back in the `Bridge`, for requests.\n             Bridge::with(|bridge| bridge.cached_buffer = b.take());\n \n-            let output = f(crate::TokenStream(input)).0;\n+            let output = f(input);\n \n             // Take the `cached_buffer` back out, for the output value.\n             b = Bridge::with(|bridge| bridge.cached_buffer.take());\n@@ -384,63 +387,35 @@ extern \"C\" fn run_expand1(\n \n impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n     pub const fn expand1(f: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n+        extern \"C\" fn run(\n+            bridge: Bridge<'_>,\n+            f: fn(crate::TokenStream) -> crate::TokenStream,\n+        ) -> Buffer<u8> {\n+            run_client(bridge, |input| f(crate::TokenStream(input)).0)\n+        }\n         Client {\n             get_handle_counters: HandleCounters::get,\n-            run: run_expand1,\n+            run,\n             f,\n         }\n     }\n }\n \n-extern \"C\" fn run_expand2(\n-    mut bridge: Bridge<'_>,\n-    f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n-) -> Buffer<u8> {\n-    // The initial `cached_buffer` contains the input.\n-    let mut b = bridge.cached_buffer.take();\n-\n-    panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        bridge.enter(|| {\n-            let reader = &mut &b[..];\n-            let input = TokenStream::decode(reader, &mut ());\n-            let input2 = TokenStream::decode(reader, &mut ());\n-\n-            // Put the `cached_buffer` back in the `Bridge`, for requests.\n-            Bridge::with(|bridge| bridge.cached_buffer = b.take());\n-\n-            let output = f(crate::TokenStream(input), crate::TokenStream(input2)).0;\n-\n-            // Take the `cached_buffer` back out, for the output value.\n-            b = Bridge::with(|bridge| bridge.cached_buffer.take());\n-\n-            // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n-            // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n-            // having handles outside the `bridge.enter(|| ...)` scope, and\n-            // to catch panics that could happen while encoding the success.\n-            //\n-            // Note that panics should be impossible beyond this point, but\n-            // this is defensively trying to avoid any accidental panicking\n-            // reaching the `extern \"C\"` (which should `abort` but may not\n-            // at the moment, so this is also potentially preventing UB).\n-            b.clear();\n-            Ok::<_, ()>(output).encode(&mut b, &mut ());\n-        })\n-    }))\n-    .map_err(PanicMessage::from)\n-    .unwrap_or_else(|e| {\n-        b.clear();\n-        Err::<(), _>(e).encode(&mut b, &mut ());\n-    });\n-    b\n-}\n-\n impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n     pub const fn expand2(\n         f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream\n     ) -> Self {\n+        extern \"C\" fn run(\n+            bridge: Bridge<'_>,\n+            f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n+        ) -> Buffer<u8> {\n+            run_client(bridge, |(input, input2)| {\n+                f(crate::TokenStream(input), crate::TokenStream(input2)).0\n+            })\n+        }\n         Client {\n             get_handle_counters: HandleCounters::get,\n-            run: run_expand2,\n+            run,\n             f,\n         }\n     }"}]}