{"sha": "67512f717e7592d347fc825d2917b786a19b78bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NTEyZjcxN2U3NTkyZDM0N2ZjODI1ZDI5MTdiNzg2YTE5Yjc4YmQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-20T07:40:27Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-24T19:48:10Z"}, "message": "Implement a wrapper macro around fprintf -- ifmtf", "tree": {"sha": "88dde23415934d316d1a4f58a35c811407c82ca7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88dde23415934d316d1a4f58a35c811407c82ca7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67512f717e7592d347fc825d2917b786a19b78bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67512f717e7592d347fc825d2917b786a19b78bd", "html_url": "https://github.com/rust-lang/rust/commit/67512f717e7592d347fc825d2917b786a19b78bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67512f717e7592d347fc825d2917b786a19b78bd/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39207a358bdbaf3d4ba921c2b7cce786cf2c7cef", "url": "https://api.github.com/repos/rust-lang/rust/commits/39207a358bdbaf3d4ba921c2b7cce786cf2c7cef", "html_url": "https://github.com/rust-lang/rust/commit/39207a358bdbaf3d4ba921c2b7cce786cf2c7cef"}], "stats": {"total": 94, "additions": 71, "deletions": 23}, "files": [{"sha": "560cb26d09a03ea45f0fc9003d494aca863fd4f2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67512f717e7592d347fc825d2917b786a19b78bd/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67512f717e7592d347fc825d2917b786a19b78bd/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=67512f717e7592d347fc825d2917b786a19b78bd", "patch": "@@ -140,7 +140,9 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n     syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"ifmt\"),\n-                            builtin_normal_tt(ext::ifmt::expand_syntax_ext));\n+                            builtin_normal_tt(ext::ifmt::expand_sprintf));\n+    syntax_expanders.insert(intern(&\"ifmtf\"),\n+                            builtin_normal_tt(ext::ifmt::expand_fprintf));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));"}, {"sha": "ae098735e5b392b458b2fcd64c1c4807c37beb33", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 47, "deletions": 21, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/67512f717e7592d347fc825d2917b786a19b78bd/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67512f717e7592d347fc825d2917b786a19b78bd/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=67512f717e7592d347fc825d2917b786a19b78bd", "patch": "@@ -54,20 +54,32 @@ impl Context {\n     /// Parses the arguments from the given list of tokens, returning None if\n     /// there's a parse error so we can continue parsing other fmt! expressions.\n     fn parse_args(&mut self, sp: span,\n-                  tts: &[ast::token_tree]) -> Option<@ast::expr> {\n+                  leading_expr: bool,\n+                  tts: &[ast::token_tree]) -> (Option<@ast::expr>,\n+                                               Option<@ast::expr>) {\n         let p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n                                              self.ecx.cfg(),\n                                              tts.to_owned());\n+        // If we want a leading expression (for ifmtf), parse it here\n+        let extra = if leading_expr {\n+            let e = Some(p.parse_expr());\n+            if !p.eat(&token::COMMA) {\n+                self.ecx.span_err(sp, \"expected token: `,`\");\n+                return (e, None);\n+            }\n+            e\n+        } else { None };\n+\n         if *p.token == token::EOF {\n-            self.ecx.span_err(sp, \"ifmt! expects at least one argument\");\n-            return None;\n+            self.ecx.span_err(sp, \"requires at least a format string argument\");\n+            return (extra, None);\n         }\n         let fmtstr = p.parse_expr();\n         let mut named = false;\n         while *p.token != token::EOF {\n             if !p.eat(&token::COMMA) {\n                 self.ecx.span_err(sp, \"expected token: `,`\");\n-                return None;\n+                return (extra, None);\n             }\n             if named || (token::is_ident(p.token) &&\n                          p.look_ahead(1, |t| *t == token::EQ)) {\n@@ -81,14 +93,14 @@ impl Context {\n                         self.ecx.span_err(*p.span,\n                                           \"expected ident, positional arguments \\\n                                            cannot follow named arguments\");\n-                        return None;\n+                        return (extra, None);\n                     }\n                     _ => {\n                         self.ecx.span_err(*p.span,\n                                           fmt!(\"expected ident for named \\\n                                                 argument, but found `%s`\",\n                                                p.this_token_to_str()));\n-                        return None;\n+                        return (extra, None);\n                     }\n                 };\n                 let name = self.ecx.str_of(ident);\n@@ -110,7 +122,7 @@ impl Context {\n                 self.arg_types.push(None);\n             }\n         }\n-        return Some(fmtstr);\n+        return (extra, Some(fmtstr));\n     }\n \n     /// Verifies one piece of a parse string. All errors are not emitted as\n@@ -530,7 +542,7 @@ impl Context {\n \n     /// Actually builds the expression which the ifmt! block will be expanded\n     /// to\n-    fn to_expr(&self) -> @ast::expr {\n+    fn to_expr(&self, extra: Option<@ast::expr>, f: &str) -> @ast::expr {\n         let mut lets = ~[];\n         let mut locals = ~[];\n         let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n@@ -596,15 +608,18 @@ impl Context {\n         let args = names.move_iter().map(|a| a.unwrap());\n         let mut args = locals.move_iter().chain(args);\n \n-        // Next, build up the actual call to the sprintf function.\n+        let mut fmt_args = match extra {\n+            Some(e) => ~[e], None => ~[]\n+        };\n+        fmt_args.push(self.ecx.expr_ident(self.fmtsp, static_name));\n+        fmt_args.push(self.ecx.expr_vec(self.fmtsp, args.collect()));\n+\n+        // Next, build up the actual call to the {s,f}printf function.\n         let result = self.ecx.expr_call_global(self.fmtsp, ~[\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(\"sprintf\"),\n-            ], ~[\n-                self.ecx.expr_ident(self.fmtsp, static_name),\n-                self.ecx.expr_vec(self.fmtsp, args.collect()),\n-            ]);\n+                self.ecx.ident_of(f),\n+            ], fmt_args);\n \n         // sprintf is unsafe, but we just went through a lot of work to\n         // validate that our call is save, so inject the unsafe block for the\n@@ -682,8 +697,19 @@ impl Context {\n     }\n }\n \n-pub fn expand_syntax_ext(ecx: @ExtCtxt, sp: span,\n-                         tts: &[ast::token_tree]) -> base::MacResult {\n+pub fn expand_sprintf(ecx: @ExtCtxt, sp: span,\n+                      tts: &[ast::token_tree]) -> base::MacResult {\n+    expand_ifmt(ecx, sp, tts, false, \"sprintf\")\n+}\n+\n+pub fn expand_fprintf(ecx: @ExtCtxt, sp: span,\n+                      tts: &[ast::token_tree]) -> base::MacResult {\n+    expand_ifmt(ecx, sp, tts, true, \"fprintf\")\n+}\n+\n+\n+fn expand_ifmt(ecx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n+               leading_arg: bool, function: &str) -> base::MacResult {\n     let mut cx = Context {\n         ecx: ecx,\n         args: ~[],\n@@ -697,13 +723,13 @@ pub fn expand_syntax_ext(ecx: @ExtCtxt, sp: span,\n         method_statics: ~[],\n         fmtsp: sp,\n     };\n-    let efmt = match cx.parse_args(sp, tts) {\n-        Some(e) => e,\n-        None => { return MRExpr(ecx.expr_uint(sp, 2)); }\n+    let (extra, efmt) = match cx.parse_args(sp, leading_arg, tts) {\n+        (extra, Some(e)) => (extra, e),\n+        (_, None) => { return MRExpr(ecx.expr_uint(sp, 2)); }\n     };\n     cx.fmtsp = efmt.span;\n     let fmt = expr_to_str(ecx, efmt,\n-                          \"first argument to ifmt! must be a string literal.\");\n+                          \"format argument must be a string literal.\");\n \n     let mut err = false;\n     do parse::parse_error::cond.trap(|m| {\n@@ -734,5 +760,5 @@ pub fn expand_syntax_ext(ecx: @ExtCtxt, sp: span,\n         }\n     }\n \n-    MRExpr(cx.to_expr())\n+    MRExpr(cx.to_expr(extra, function))\n }"}, {"sha": "b5341ca80c553173c4f9b2198d6ddd2237b231d9", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/67512f717e7592d347fc825d2917b786a19b78bd/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67512f717e7592d347fc825d2917b786a19b78bd/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=67512f717e7592d347fc825d2917b786a19b78bd", "patch": "@@ -21,8 +21,9 @@ impl fmt::Signed for B {\n     fn fmt(_: &B, f: &mut fmt::Formatter) { f.buf.write(\"adios\".as_bytes()); }\n }\n \n+macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n+\n pub fn main() {\n-    macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n \n     // Make sure there's a poly formatter that takes anything\n     t!(ifmt!(\"{:?}\", 1), \"1\");\n@@ -209,5 +210,24 @@ pub fn main() {\n     t!(ifmt!(\"{:10.3f}\", 1.0f),   \"     1.000\");\n     t!(ifmt!(\"{:+10.3f}\", 1.0f),  \"    +1.000\");\n     t!(ifmt!(\"{:+10.3f}\", -1.0f), \"    -1.000\");\n+\n+    test_ifmtf();\n }\n \n+fn test_ifmtf() {\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n+    use std::rt::io;\n+    use std::str;\n+\n+    let mut buf = MemWriter::new();\n+    ifmtf!(&mut buf as &mut io::Writer, \"{}\", 3);\n+    {\n+        let w = &mut buf as &mut io::Writer;\n+        ifmtf!(w, \"{foo}\", foo=4);\n+        ifmtf!(w, \"{:s}\", \"hello\");\n+    }\n+\n+    let s = str::from_bytes_owned(buf.inner());\n+    t!(s, \"34hello\");\n+}"}]}