{"sha": "c622413bc72ea56d5f62a16788d897cb61eca948", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MjI0MTNiYzcyZWE1NmQ1ZjYyYTE2Nzg4ZDg5N2NiNjFlY2E5NDg=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-14T22:20:27Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-14T22:20:27Z"}, "message": "Merge branch 'master' of https://github.com/rust-analyzer/rust-analyzer into feature/themes", "tree": {"sha": "9de3dbe8b5c935ed168efac4e70770e54fbe0714", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9de3dbe8b5c935ed168efac4e70770e54fbe0714"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c622413bc72ea56d5f62a16788d897cb61eca948", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c622413bc72ea56d5f62a16788d897cb61eca948", "html_url": "https://github.com/rust-lang/rust/commit/c622413bc72ea56d5f62a16788d897cb61eca948", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c622413bc72ea56d5f62a16788d897cb61eca948/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0525778a3ad590492b51cc11085d815f9bb8f92b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0525778a3ad590492b51cc11085d815f9bb8f92b", "html_url": "https://github.com/rust-lang/rust/commit/0525778a3ad590492b51cc11085d815f9bb8f92b"}, {"sha": "bbb022d3999b3038549ec6c309efb065231c896a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb022d3999b3038549ec6c309efb065231c896a", "html_url": "https://github.com/rust-lang/rust/commit/bbb022d3999b3038549ec6c309efb065231c896a"}], "stats": {"total": 1678, "additions": 904, "deletions": 774}, "files": [{"sha": "1dedf9772106e1e6f335e354f600aa7568f8e79f", "filename": "Cargo.lock", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -8,6 +8,11 @@ dependencies = [\n  \"memchr 2.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"anyhow\"\n+version = \"1.0.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"arrayvec\"\n version = \"0.5.1\"\n@@ -122,7 +127,7 @@ source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b95\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -187,7 +192,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-integer 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -310,7 +315,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -348,7 +353,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.7\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -465,7 +470,7 @@ name = \"heck\"\n version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"unicode-segmentation 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-segmentation 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -748,7 +753,7 @@ version = \"4.0.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fsevent 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fsevent-sys 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"inotify 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -766,20 +771,20 @@ version = \"0.1.41\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"num-traits\"\n-version = \"0.2.8\"\n+version = \"0.2.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"num_cpus\"\n-version = \"1.11.0\"\n+version = \"1.11.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"hermit-abi 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -842,7 +847,7 @@ dependencies = [\n  \"proc-macro-hack 0.5.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -876,7 +881,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -896,7 +901,7 @@ dependencies = [\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1091,7 +1096,7 @@ dependencies = [\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"superslice 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n- \"unicase 2.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicase 2.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1383,7 +1388,7 @@ dependencies = [\n  \"crossbeam-queue 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crossbeam-utils 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num_cpus 1.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.11.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1506,7 +1511,7 @@ dependencies = [\n  \"heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1551,7 +1556,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1571,7 +1576,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1625,7 +1630,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.7\"\n+version = \"1.0.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1681,7 +1686,7 @@ name = \"threadpool\"\n version = \"1.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"num_cpus 1.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.11.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1696,10 +1701,10 @@ dependencies = [\n \n [[package]]\n name = \"unicase\"\n-version = \"2.5.1\"\n+version = \"2.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"version_check 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1720,7 +1725,7 @@ dependencies = [\n \n [[package]]\n name = \"unicode-segmentation\"\n-version = \"1.5.0\"\n+version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1755,7 +1760,7 @@ dependencies = [\n \n [[package]]\n name = \"version_check\"\n-version = \"0.1.5\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1823,6 +1828,7 @@ dependencies = [\n name = \"xtask\"\n version = \"0.1.0\"\n dependencies = [\n+ \"anyhow 1.0.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pico-args 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1846,6 +1852,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n \"checksum aho-corasick 0.7.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"58fb5e95d83b38284460a5fda7d6470aa0b8844d283a0b614b8535e880800d2d\"\n+\"checksum anyhow 1.0.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"57114fc2a6cc374bce195d3482057c846e706d252ff3604363449695684d7a0d\"\n \"checksum arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cff77d8686867eceff3105329d4698d96c2391c176d5d03adc90c7389162b5b8\"\n \"checksum atty 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1803c647a3ec87095e7ae7acfca019e98de5ec9a7d01343f611cf3152ed71a90\"\n \"checksum autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2\"\n@@ -1886,7 +1893,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum either 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb1f6b1ce1c140482ea30ddd3335fc0024ac7ee112895426e0a629a6c20adfe3\"\n \"checksum ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8944dc8fa28ce4a38f778bd46bf7d923fe73eed5a439398507246c8e017e6f36\"\n \"checksum encode_unicode 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f\"\n-\"checksum filetime 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6bd7380b54ced79dda72ecc35cc4fbbd1da6bba54afaa37e96fd1c2a308cd469\"\n+\"checksum filetime 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1ff6d4dab0aa0c8e6346d46052e93b13a16cf847b54ed357087c35011048cc7d\"\n \"checksum fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n \"checksum flexi_logger 0.14.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a13ea6b8a4debecf47bf3966d56db0e21366bc3a3649ba159e1a9e6fdd36a4f4\"\n \"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n@@ -1937,8 +1944,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)\" = \"42550d9fb7b6684a6d404d9fa7250c2eb2646df731d1c06afc06dcee9e1bcf88\"\n \"checksum notify 4.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"199628fc33b21bc767baa057490b00b382ecbae030803a7b36292422d15b778b\"\n \"checksum num-integer 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b85e541ef8255f6cf42bbfe4ef361305c6c135d10919ecc26126c4e5ae94bc09\"\n-\"checksum num-traits 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ba9a427cfca2be13aa6f6403b0b7e7368fe982bfa16fccc450ce74c46cd9b32\"\n-\"checksum num_cpus 1.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"155394f924cdddf08149da25bfb932d226b4a593ca7468b08191ff6335941af5\"\n+\"checksum num-traits 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"443c53b3c3531dfcbfa499d8893944db78474ad7a1d87fa2d94d1a2231693ac6\"\n+\"checksum num_cpus 1.11.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76dac5ed2a876980778b8b85f75a71b6cbf0db0b1232ee12f826bccb00d09d72\"\n \"checksum number_prefix 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"17b02fc0ff9a9e4b35b3342880f48e896ebf69f2967921fe8646bf5b7125956a\"\n \"checksum once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"891f486f630e5c5a4916c7e16c4b24a53e78c860b646e9f8e005e4f16847bfed\"\n \"checksum ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n@@ -2003,22 +2010,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum smol_str 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"34836c9a295c62c2ce3514471117c5cb269891e8421b2aafdd910050576c4d8b\"\n \"checksum stacker 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d96fc4f13a0ac088e9a3cd9af1cc8c5cc1ab5deb2145cef661267dfc9c542f8a\"\n \"checksum superslice 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n-\"checksum syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e7bedb3320d0f3035594b0b723c8a28d7d336a3eda3881db79e61d676fb644c\"\n+\"checksum syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"661641ea2aa15845cddeb97dad000d22070bb5c1fb456b96c1cba883ec691e92\"\n \"checksum tempfile 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n \"checksum termios 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72b620c5ea021d75a735c943269bb07d30c9b77d6ac6b236bc8b5c496ef05625\"\n \"checksum text_unit 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e08bbcb7a3adbda0eb23431206b653bdad3d8dea311e72d36bf2215e27a42579\"\n \"checksum thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b\"\n \"checksum threadpool 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2f0c90a5f3459330ac8bc0d2f879c693bb7a2f59689c1083fc4ef83834da865\"\n \"checksum time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db8dcfca086c1143c9270ac42a2bbd8a7ee477b78ac8e45b19abfb0cbede4b6f\"\n-\"checksum unicase 2.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e2e6bd1e59e56598518beb94fd6db628ded570326f0a98c679a304bd9f00150\"\n+\"checksum unicase 2.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"50f37be617794602aabbeee0be4f259dc1778fabe05e2d67ee8f79326d5cb4f6\"\n \"checksum unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49f2bd0c6468a8230e1db229cff8029217cf623c767ea5d60bfbd42729ea54d5\"\n \"checksum unicode-normalization 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09c8070a9942f5e7cfccd93f490fdebd230ee3c3c9f107cb25bad5351ef671cf\"\n-\"checksum unicode-segmentation 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49f5526225fd8b77342d5986ab5f6055552e9c0776193b5b63fd53b46debfad7\"\n+\"checksum unicode-segmentation 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e83e153d1053cbb5a118eeff7fd5be06ed99153f00dbcd8ae310c5fb2b22edc0\"\n \"checksum unicode-width 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7007dbd421b92cc6e28410fe7362e2e0a2503394908f417b68ec8d1c364c4e20\"\n \"checksum unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\"\n \"checksum url 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"75b414f6c464c879d7f9babf951f23bc3743fb7313c081b2e6ca719067ea9d61\"\n \"checksum uuid 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9fde2f6a4bea1d6e007c4ad38c6839fa71cbb63b6dbf5b595aa38dc9b1093c11\"\n-\"checksum version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd\"\n+\"checksum version_check 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"078775d0255232fb988e6fccf26ddc9d1ac274299aaedcedce21c6f72cc533ce\"\n \"checksum walkdir 2.2.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9658c94fa8b940eab2250bd5a457f9c48b748420d71293b165c8cdbe2f55f71e\"\n \"checksum wasi 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\""}, {"sha": "26441252662b97c015386bf040f7ebbf4d102918", "filename": "crates/ra_assists/src/assists/early_return.rs", "status": "modified", "additions": 88, "deletions": 40, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -1,4 +1,4 @@\n-use std::ops::RangeInclusive;\n+use std::{iter::once, ops::RangeInclusive};\n \n use hir::db::HirDatabase;\n use ra_syntax::{\n@@ -38,27 +38,30 @@ use crate::{\n // ```\n pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n+    if if_expr.else_branch().is_some() {\n+        return None;\n+    }\n+\n     let cond = if_expr.condition()?;\n-    let mut if_let_ident: Option<String> = None;\n \n     // Check if there is an IfLet that we can handle.\n-    match cond.pat() {\n-        None => {} // No IfLet, supported.\n-        Some(TupleStructPat(ref pat)) if pat.args().count() == 1usize => match &pat.path() {\n-            Some(p) => match p.qualifier() {\n-                None => if_let_ident = Some(p.syntax().text().to_string()),\n-                _ => return None,\n-            },\n-            _ => return None,\n-        },\n-        _ => return None, // Unsupported IfLet.\n+    let if_let_pat = match cond.pat() {\n+        None => None, // No IfLet, supported.\n+        Some(TupleStructPat(pat)) if pat.args().count() == 1 => {\n+            let path = pat.path()?;\n+            match path.qualifier() {\n+                None => {\n+                    let bound_ident = pat.args().next().unwrap();\n+                    Some((path, bound_ident))\n+                }\n+                Some(_) => return None,\n+            }\n+        }\n+        Some(_) => return None, // Unsupported IfLet.\n     };\n \n-    let expr = cond.expr()?;\n+    let cond_expr = cond.expr()?;\n     let then_block = if_expr.then_branch()?.block()?;\n-    if if_expr.else_branch().is_some() {\n-        return None;\n-    }\n \n     let parent_block = if_expr.syntax().parent()?.ancestors().find_map(ast::Block::cast)?;\n \n@@ -79,11 +82,11 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n     let parent_container = parent_block.syntax().parent()?.parent()?;\n \n-    let early_expression = match parent_container.kind() {\n-        WHILE_EXPR | LOOP_EXPR => Some(\"continue\"),\n-        FN_DEF => Some(\"return\"),\n-        _ => None,\n-    }?;\n+    let early_expression: ast::Expr = match parent_container.kind() {\n+        WHILE_EXPR | LOOP_EXPR => make::expr_continue().into(),\n+        FN_DEF => make::expr_return().into(),\n+        _ => return None,\n+    };\n \n     if then_block.syntax().first_child_or_token().map(|t| t.kind() == L_CURLY).is_none() {\n         return None;\n@@ -94,30 +97,51 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n     ctx.add_assist(AssistId(\"convert_to_guarded_return\"), \"convert to guarded return\", |edit| {\n         let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n-        let new_block = match if_let_ident {\n+        let new_block = match if_let_pat {\n             None => {\n                 // If.\n-                let early_expression = &(early_expression.to_owned() + \";\");\n-                let new_expr =\n-                    if_indent_level.increase_indent(make::if_expression(&expr, early_expression));\n-                replace(new_expr, &then_block, &parent_block, &if_expr)\n+                let early_expression = &(early_expression.syntax().to_string() + \";\");\n+                let new_expr = if_indent_level\n+                    .increase_indent(make::if_expression(&cond_expr, early_expression));\n+                replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n             }\n-            Some(if_let_ident) => {\n+            Some((path, bound_ident)) => {\n                 // If-let.\n-                let new_expr = if_indent_level.increase_indent(make::let_match_early(\n-                    expr,\n-                    &if_let_ident,\n-                    early_expression,\n-                ));\n-                replace(new_expr, &then_block, &parent_block, &if_expr)\n+                let match_expr = {\n+                    let happy_arm = make::match_arm(\n+                        once(\n+                            make::tuple_struct_pat(\n+                                path,\n+                                once(make::bind_pat(make::name(\"it\")).into()),\n+                            )\n+                            .into(),\n+                        ),\n+                        make::expr_path(make::path_from_name_ref(make::name_ref(\"it\"))).into(),\n+                    );\n+\n+                    let sad_arm = make::match_arm(\n+                        // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n+                        once(make::placeholder_pat().into()),\n+                        early_expression.into(),\n+                    );\n+\n+                    make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n+                };\n+\n+                let let_stmt = make::let_stmt(\n+                    make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n+                    Some(match_expr.into()),\n+                );\n+                let let_stmt = if_indent_level.increase_indent(let_stmt);\n+                replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n             }\n         };\n         edit.target(if_expr.syntax().text_range());\n         edit.replace_ast(parent_block, ast::Block::cast(new_block).unwrap());\n         edit.set_cursor(cursor_position);\n \n         fn replace(\n-            new_expr: impl AstNode,\n+            new_expr: &SyntaxNode,\n             then_block: &Block,\n             parent_block: &Block,\n             if_expr: &ast::IfExpr,\n@@ -130,7 +154,7 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n                 } else {\n                     end_of_then\n                 };\n-            let mut then_statements = new_expr.syntax().children_with_tokens().chain(\n+            let mut then_statements = new_expr.children_with_tokens().chain(\n                 then_block_items\n                     .syntax()\n                     .children_with_tokens()\n@@ -151,9 +175,10 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use crate::helpers::{check_assist, check_assist_not_applicable};\n \n+    use super::*;\n+\n     #[test]\n     fn convert_inside_fn() {\n         check_assist(\n@@ -204,7 +229,7 @@ mod tests {\n                 bar();\n                 le<|>t n = match n {\n                     Some(it) => it,\n-                    None => return,\n+                    _ => return,\n                 };\n                 foo(n);\n \n@@ -215,6 +240,29 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_if_let_result() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main() {\n+                if<|> let Ok(x) = Err(92) {\n+                    foo(x);\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                le<|>t x = match Err(92) {\n+                    Ok(it) => it,\n+                    _ => return,\n+                };\n+                foo(x);\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn convert_let_ok_inside_fn() {\n         check_assist(\n@@ -235,7 +283,7 @@ mod tests {\n                 bar();\n                 le<|>t n = match n {\n                     Ok(it) => it,\n-                    None => return,\n+                    _ => return,\n                 };\n                 foo(n);\n \n@@ -293,7 +341,7 @@ mod tests {\n                 while true {\n                     le<|>t n = match n {\n                         Some(it) => it,\n-                        None => continue,\n+                        _ => continue,\n                     };\n                     foo(n);\n                     bar();\n@@ -350,7 +398,7 @@ mod tests {\n                 loop {\n                     le<|>t n = match n {\n                         Some(it) => it,\n-                        None => continue,\n+                        _ => continue,\n                     };\n                     foo(n);\n                     bar();"}, {"sha": "962d5a8c15fbe824f30040b6e54599ba3c8c566b", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -8,6 +8,7 @@ use std::sync::Arc;\n \n use hir_def::{\n     adt::VariantData,\n+    body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n     type_ref::{Mutability, TypeRef},\n     CrateModuleId, LocalEnumVariantId, LocalStructFieldId, ModuleId, UnionId,\n@@ -539,6 +540,7 @@ pub trait HasBody: Copy {\n     fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult>;\n     fn body(self, db: &impl HirDatabase) -> Arc<Body>;\n     fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap>;\n+    fn expr_scopes(self, db: &impl HirDatabase) -> Arc<ExprScopes>;\n }\n \n impl<T> HasBody for T\n@@ -550,11 +552,15 @@ where\n     }\n \n     fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body(self.into())\n+        self.into().body(db)\n     }\n \n     fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map(self.into()).1\n+        self.into().body_source_map(db)\n+    }\n+\n+    fn expr_scopes(self, db: &impl HirDatabase) -> Arc<ExprScopes> {\n+        self.into().expr_scopes(db)\n     }\n }\n \n@@ -564,11 +570,15 @@ impl HasBody for DefWithBody {\n     }\n \n     fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body(self)\n+        db.body(self.into())\n     }\n \n     fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map(self).1\n+        db.body_with_source_map(self.into()).1\n+    }\n+\n+    fn expr_scopes(self, db: &impl HirDatabase) -> Arc<ExprScopes> {\n+        db.expr_scopes(self.into())\n     }\n }\n \n@@ -662,11 +672,11 @@ impl Function {\n     }\n \n     pub(crate) fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map(self.into()).1\n+        db.body_with_source_map(self.id.into()).1\n     }\n \n     pub fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body(self.into())\n+        db.body(self.id.into())\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n@@ -1079,7 +1089,7 @@ pub struct Local {\n \n impl Local {\n     pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n-        let body = db.body(self.parent);\n+        let body = self.parent.body(db);\n         match &body[self.pat_id] {\n             Pat::Bind { name, .. } => Some(name.clone()),\n             _ => None,\n@@ -1091,7 +1101,7 @@ impl Local {\n     }\n \n     pub fn is_mut(self, db: &impl HirDatabase) -> bool {\n-        let body = db.body(self.parent);\n+        let body = self.parent.body(db);\n         match &body[self.pat_id] {\n             Pat::Bind { mode, .. } => match mode {\n                 BindingAnnotation::Mutable | BindingAnnotation::RefMut => true,\n@@ -1115,7 +1125,7 @@ impl Local {\n     }\n \n     pub fn source(self, db: &impl HirDatabase) -> Source<Either<ast::BindPat, ast::SelfParam>> {\n-        let (_body, source_map) = db.body_with_source_map(self.parent);\n+        let source_map = self.parent.body_source_map(db);\n         let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n         let root = src.file_syntax(db);\n         src.map(|ast| ast.map(|it| it.cast().unwrap().to_node(&root), |it| it.to_node(&root)))"}, {"sha": "c60029c0188f009fd9f4749e8e41e25e40f9fdca", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -8,7 +8,6 @@ use ra_syntax::SmolStr;\n \n use crate::{\n     debug::HirDebugDatabase,\n-    expr::{Body, BodySourceMap},\n     generics::{GenericDef, GenericParams},\n     ids,\n     impl_block::{ImplBlock, ImplSourceMap, ModuleImplBlocks},\n@@ -19,13 +18,14 @@ use crate::{\n         InferenceResult, Namespace, Substs, Ty, TypableDef, TypeCtor,\n     },\n     type_alias::TypeAliasData,\n-    Const, ConstData, Crate, DefWithBody, ExprScopes, FnData, Function, Module, Static,\n-    StructField, Trait, TypeAlias,\n+    Const, ConstData, Crate, DefWithBody, FnData, Function, Module, Static, StructField, Trait,\n+    TypeAlias,\n };\n \n pub use hir_def::db::{\n-    CrateDefMapQuery, DefDatabase2, DefDatabase2Storage, EnumDataQuery, InternDatabase,\n-    InternDatabaseStorage, RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n+    BodyQuery, BodyWithSourceMapQuery, CrateDefMapQuery, DefDatabase2, DefDatabase2Storage,\n+    EnumDataQuery, ExprScopesQuery, InternDatabase, InternDatabaseStorage, RawItemsQuery,\n+    RawItemsWithSourceMapQuery, StructDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n@@ -85,9 +85,6 @@ pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n #[salsa::query_group(HirDatabaseStorage)]\n #[salsa::requires(salsa::Database)]\n pub trait HirDatabase: DefDatabase + AstDatabase {\n-    #[salsa::invoke(ExprScopes::expr_scopes_query)]\n-    fn expr_scopes(&self, def: DefWithBody) -> Arc<ExprScopes>;\n-\n     #[salsa::invoke(crate::ty::infer_query)]\n     fn infer(&self, def: DefWithBody) -> Arc<InferenceResult>;\n \n@@ -113,12 +110,6 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::invoke(crate::ty::generic_defaults_query)]\n     fn generic_defaults(&self, def: GenericDef) -> Substs;\n \n-    #[salsa::invoke(crate::expr::body_with_source_map_query)]\n-    fn body_with_source_map(&self, def: DefWithBody) -> (Arc<Body>, Arc<BodySourceMap>);\n-\n-    #[salsa::invoke(crate::expr::body_query)]\n-    fn body(&self, def: DefWithBody) -> Arc<Body>;\n-\n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n "}, {"sha": "9262325f2348577a043a11b76468318b53a473e5", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 198, "deletions": 39, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -1,74 +1,233 @@\n //! FIXME: write short doc here\n \n-pub(crate) mod scope;\n pub(crate) mod validation;\n \n use std::sync::Arc;\n \n-use ra_syntax::{ast, AstPtr};\n+use ra_syntax::AstPtr;\n \n-use crate::{db::HirDatabase, DefWithBody, HasSource, Resolver};\n-\n-pub use self::scope::ExprScopes;\n+use crate::{db::HirDatabase, DefWithBody, HasBody, Resolver};\n \n pub use hir_def::{\n-    body::{Body, BodySourceMap, ExprPtr, ExprSource, PatPtr, PatSource},\n+    body::{\n+        scope::{ExprScopes, ScopeEntry, ScopeId},\n+        Body, BodySourceMap, ExprPtr, ExprSource, PatPtr, PatSource,\n+    },\n     expr::{\n         ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n         MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement, UnaryOp,\n     },\n };\n \n-pub(crate) fn body_with_source_map_query(\n-    db: &impl HirDatabase,\n-    def: DefWithBody,\n-) -> (Arc<Body>, Arc<BodySourceMap>) {\n-    let mut params = None;\n-\n-    let (file_id, body) = match def {\n-        DefWithBody::Function(f) => {\n-            let src = f.source(db);\n-            params = src.ast.param_list();\n-            (src.file_id, src.ast.body().map(ast::Expr::from))\n-        }\n-        DefWithBody::Const(c) => {\n-            let src = c.source(db);\n-            (src.file_id, src.ast.body())\n-        }\n-        DefWithBody::Static(s) => {\n-            let src = s.source(db);\n-            (src.file_id, src.ast.body())\n-        }\n-    };\n-    let resolver = hir_def::body::MacroResolver::new(db, def.module(db).id);\n-    let (body, source_map) = Body::new(db, resolver, file_id, params, body);\n-    (Arc::new(body), Arc::new(source_map))\n-}\n-\n-pub(crate) fn body_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<Body> {\n-    db.body_with_source_map(def).0\n-}\n-\n // needs arbitrary_self_types to be a method... or maybe move to the def?\n pub(crate) fn resolver_for_expr(\n     db: &impl HirDatabase,\n     owner: DefWithBody,\n     expr_id: ExprId,\n ) -> Resolver {\n-    let scopes = db.expr_scopes(owner);\n+    let scopes = owner.expr_scopes(db);\n     resolver_for_scope(db, owner, scopes.scope_for(expr_id))\n }\n \n pub(crate) fn resolver_for_scope(\n     db: &impl HirDatabase,\n     owner: DefWithBody,\n-    scope_id: Option<scope::ScopeId>,\n+    scope_id: Option<ScopeId>,\n ) -> Resolver {\n     let mut r = owner.resolver(db);\n-    let scopes = db.expr_scopes(owner);\n+    let scopes = owner.expr_scopes(db);\n     let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n     for scope in scope_chain.into_iter().rev() {\n         r = r.push_expr_scope(Arc::clone(&scopes), scope);\n     }\n     r\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use hir_expand::Source;\n+    use ra_db::{fixture::WithFixture, SourceDatabase};\n+    use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n+    use test_utils::{assert_eq_text, extract_offset};\n+\n+    use crate::{source_binder::SourceAnalyzer, test_db::TestDB};\n+\n+    fn do_check(code: &str, expected: &[&str]) {\n+        let (off, code) = extract_offset(code);\n+        let code = {\n+            let mut buf = String::new();\n+            let off = u32::from(off) as usize;\n+            buf.push_str(&code[..off]);\n+            buf.push_str(\"marker\");\n+            buf.push_str(&code[off..]);\n+            buf\n+        };\n+\n+        let (db, file_id) = TestDB::with_single_file(&code);\n+\n+        let file = db.parse(file_id).ok().unwrap();\n+        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n+        let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n+\n+        let scopes = analyzer.scopes();\n+        let expr_id = analyzer\n+            .body_source_map()\n+            .node_expr(Source { file_id: file_id.into(), ast: &marker.into() })\n+            .unwrap();\n+        let scope = scopes.scope_for(expr_id);\n+\n+        let actual = scopes\n+            .scope_chain(scope)\n+            .flat_map(|scope| scopes.entries(scope))\n+            .map(|it| it.name().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        let expected = expected.join(\"\\n\");\n+        assert_eq_text!(&expected, &actual);\n+    }\n+\n+    #[test]\n+    fn test_lambda_scope() {\n+        do_check(\n+            r\"\n+            fn quux(foo: i32) {\n+                let f = |bar, baz: i32| {\n+                    <|>\n+                };\n+            }\",\n+            &[\"bar\", \"baz\", \"foo\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_method_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                z.f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_loop_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                loop {\n+                    let x = ();\n+                    <|>\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_match() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                match () {\n+                    Some(x) => {\n+                        <|>\n+                    }\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_shadow_variable() {\n+        do_check(\n+            r\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    fn do_check_local_name(code: &str, expected_offset: u32) {\n+        let (off, code) = extract_offset(code);\n+\n+        let (db, file_id) = TestDB::with_single_file(&code);\n+        let file = db.parse(file_id).ok().unwrap();\n+        let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n+            .expect(\"failed to find a name at the target offset\");\n+        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let analyzer = SourceAnalyzer::new(&db, file_id, name_ref.syntax(), None);\n+\n+        let local_name_entry = analyzer.resolve_local_name(&name_ref).unwrap();\n+        let local_name =\n+            local_name_entry.ptr().either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n+        assert_eq!(local_name.range(), expected_name.syntax().text_range());\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: i32, y: u32) {\n+                {\n+                    let z = x * 2;\n+                }\n+                {\n+                    let t = x<|> * 3;\n+                }\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_declaration() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_shadow() {\n+        do_check_local_name(\n+            r\"\n+            fn foo(x: String) {\n+                let x : &str = &x;\n+                x<|>\n+            }\n+            \",\n+            53,\n+        );\n+    }\n+\n+    #[test]\n+    fn ref_patterns_contribute_bindings() {\n+        do_check_local_name(\n+            r\"\n+            fn foo() {\n+                if let Some(&from) = bar() {\n+                    from<|>;\n+                }\n+            }\n+            \",\n+            53,\n+        );\n+    }\n+}"}, {"sha": "0e49a28d6c32be51534e89997c1e27441932e02a", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "removed", "additions": 0, "deletions": 354, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -1,354 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use std::sync::Arc;\n-\n-use ra_arena::{impl_arena_id, Arena, RawId};\n-use rustc_hash::FxHashMap;\n-\n-use crate::{\n-    db::HirDatabase,\n-    expr::{Body, Expr, ExprId, Pat, PatId, Statement},\n-    DefWithBody, Name,\n-};\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ScopeId(RawId);\n-impl_arena_id!(ScopeId);\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct ExprScopes {\n-    pub(crate) body: Arc<Body>,\n-    scopes: Arena<ScopeId, ScopeData>,\n-    scope_by_expr: FxHashMap<ExprId, ScopeId>,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ScopeEntry {\n-    name: Name,\n-    pat: PatId,\n-}\n-\n-impl ScopeEntry {\n-    pub(crate) fn name(&self) -> &Name {\n-        &self.name\n-    }\n-\n-    pub(crate) fn pat(&self) -> PatId {\n-        self.pat\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ScopeData {\n-    parent: Option<ScopeId>,\n-    entries: Vec<ScopeEntry>,\n-}\n-\n-impl ExprScopes {\n-    pub(crate) fn expr_scopes_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<ExprScopes> {\n-        let body = db.body(def);\n-        let res = ExprScopes::new(body);\n-        Arc::new(res)\n-    }\n-\n-    fn new(body: Arc<Body>) -> ExprScopes {\n-        let mut scopes = ExprScopes {\n-            body: body.clone(),\n-            scopes: Arena::default(),\n-            scope_by_expr: FxHashMap::default(),\n-        };\n-        let root = scopes.root_scope();\n-        scopes.add_params_bindings(root, body.params());\n-        compute_expr_scopes(body.body_expr(), &body, &mut scopes, root);\n-        scopes\n-    }\n-\n-    pub(crate) fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n-        &self.scopes[scope].entries\n-    }\n-\n-    pub(crate) fn scope_chain(&self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + '_ {\n-        std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n-    }\n-\n-    pub(crate) fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n-        self.scope_by_expr.get(&expr).copied()\n-    }\n-\n-    pub(crate) fn scope_by_expr(&self) -> &FxHashMap<ExprId, ScopeId> {\n-        &self.scope_by_expr\n-    }\n-\n-    fn root_scope(&mut self) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: None, entries: vec![] })\n-    }\n-\n-    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: Some(parent), entries: vec![] })\n-    }\n-\n-    fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n-        match &body[pat] {\n-            Pat::Bind { name, .. } => {\n-                // bind can have a sub pattern, but it's actually not allowed\n-                // to bind to things in there\n-                let entry = ScopeEntry { name: name.clone(), pat };\n-                self.scopes[scope].entries.push(entry)\n-            }\n-            p => p.walk_child_pats(|pat| self.add_bindings(body, scope, pat)),\n-        }\n-    }\n-\n-    fn add_params_bindings(&mut self, scope: ScopeId, params: &[PatId]) {\n-        let body = Arc::clone(&self.body);\n-        params.iter().for_each(|pat| self.add_bindings(&body, scope, *pat));\n-    }\n-\n-    fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n-        self.scope_by_expr.insert(node, scope);\n-    }\n-}\n-\n-fn compute_block_scopes(\n-    statements: &[Statement],\n-    tail: Option<ExprId>,\n-    body: &Body,\n-    scopes: &mut ExprScopes,\n-    mut scope: ScopeId,\n-) {\n-    for stmt in statements {\n-        match stmt {\n-            Statement::Let { pat, initializer, .. } => {\n-                if let Some(expr) = initializer {\n-                    scopes.set_scope(*expr, scope);\n-                    compute_expr_scopes(*expr, body, scopes, scope);\n-                }\n-                scope = scopes.new_scope(scope);\n-                scopes.add_bindings(body, scope, *pat);\n-            }\n-            Statement::Expr(expr) => {\n-                scopes.set_scope(*expr, scope);\n-                compute_expr_scopes(*expr, body, scopes, scope);\n-            }\n-        }\n-    }\n-    if let Some(expr) = tail {\n-        compute_expr_scopes(expr, body, scopes, scope);\n-    }\n-}\n-\n-fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: ScopeId) {\n-    scopes.set_scope(expr, scope);\n-    match &body[expr] {\n-        Expr::Block { statements, tail } => {\n-            compute_block_scopes(&statements, *tail, body, scopes, scope);\n-        }\n-        Expr::For { iterable, pat, body: body_expr } => {\n-            compute_expr_scopes(*iterable, body, scopes, scope);\n-            let scope = scopes.new_scope(scope);\n-            scopes.add_bindings(body, scope, *pat);\n-            compute_expr_scopes(*body_expr, body, scopes, scope);\n-        }\n-        Expr::Lambda { args, body: body_expr, .. } => {\n-            let scope = scopes.new_scope(scope);\n-            scopes.add_params_bindings(scope, &args);\n-            compute_expr_scopes(*body_expr, body, scopes, scope);\n-        }\n-        Expr::Match { expr, arms } => {\n-            compute_expr_scopes(*expr, body, scopes, scope);\n-            for arm in arms {\n-                let scope = scopes.new_scope(scope);\n-                for pat in &arm.pats {\n-                    scopes.add_bindings(body, scope, *pat);\n-                }\n-                scopes.set_scope(arm.expr, scope);\n-                compute_expr_scopes(arm.expr, body, scopes, scope);\n-            }\n-        }\n-        e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n-    };\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ra_db::{fixture::WithFixture, SourceDatabase};\n-    use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n-    use test_utils::{assert_eq_text, extract_offset};\n-\n-    use crate::{source_binder::SourceAnalyzer, test_db::TestDB};\n-\n-    fn do_check(code: &str, expected: &[&str]) {\n-        let (off, code) = extract_offset(code);\n-        let code = {\n-            let mut buf = String::new();\n-            let off = u32::from(off) as usize;\n-            buf.push_str(&code[..off]);\n-            buf.push_str(\"marker\");\n-            buf.push_str(&code[off..]);\n-            buf\n-        };\n-\n-        let (db, file_id) = TestDB::with_single_file(&code);\n-        let file = db.parse(file_id).ok().unwrap();\n-        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n-        let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n-\n-        let scopes = analyzer.scopes();\n-        let expr_id = analyzer.body_source_map().node_expr(&marker.into()).unwrap();\n-        let scope = scopes.scope_for(expr_id);\n-\n-        let actual = scopes\n-            .scope_chain(scope)\n-            .flat_map(|scope| scopes.entries(scope))\n-            .map(|it| it.name().to_string())\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\");\n-        let expected = expected.join(\"\\n\");\n-        assert_eq_text!(&expected, &actual);\n-    }\n-\n-    #[test]\n-    fn test_lambda_scope() {\n-        do_check(\n-            r\"\n-            fn quux(foo: i32) {\n-                let f = |bar, baz: i32| {\n-                    <|>\n-                };\n-            }\",\n-            &[\"bar\", \"baz\", \"foo\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_method_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                z.f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_loop_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                loop {\n-                    let x = ();\n-                    <|>\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_match() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                match () {\n-                    Some(x) => {\n-                        <|>\n-                    }\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_shadow_variable() {\n-        do_check(\n-            r\"\n-            fn foo(x: String) {\n-                let x : &str = &x<|>;\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    fn do_check_local_name(code: &str, expected_offset: u32) {\n-        let (off, code) = extract_offset(code);\n-\n-        let (db, file_id) = TestDB::with_single_file(&code);\n-        let file = db.parse(file_id).ok().unwrap();\n-        let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n-            .expect(\"failed to find a name at the target offset\");\n-        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let analyzer = SourceAnalyzer::new(&db, file_id, name_ref.syntax(), None);\n-\n-        let local_name_entry = analyzer.resolve_local_name(&name_ref).unwrap();\n-        let local_name =\n-            local_name_entry.ptr().either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n-        assert_eq!(local_name.range(), expected_name.syntax().text_range());\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name() {\n-        do_check_local_name(\n-            r#\"\n-            fn foo(x: i32, y: u32) {\n-                {\n-                    let z = x * 2;\n-                }\n-                {\n-                    let t = x<|> * 3;\n-                }\n-            }\"#,\n-            21,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name_declaration() {\n-        do_check_local_name(\n-            r#\"\n-            fn foo(x: String) {\n-                let x : &str = &x<|>;\n-            }\"#,\n-            21,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name_shadow() {\n-        do_check_local_name(\n-            r\"\n-            fn foo(x: String) {\n-                let x : &str = &x;\n-                x<|>\n-            }\n-            \",\n-            53,\n-        );\n-    }\n-\n-    #[test]\n-    fn ref_patterns_contribute_bindings() {\n-        do_check_local_name(\n-            r\"\n-            fn foo() {\n-                if let Some(&from) = bar() {\n-                    from<|>;\n-                }\n-            }\n-            \",\n-            53,\n-        );\n-    }\n-}"}, {"sha": "9633ef5861b866d949e05529f74587221a6f27dd", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -3,9 +3,9 @@\n //! It's unclear if we need this long-term, but it's definitelly useful while we\n //! are splitting the hir.\n \n-use hir_def::{AdtId, EnumVariantId, ModuleDefId};\n+use hir_def::{AdtId, DefWithBodyId, EnumVariantId, ModuleDefId};\n \n-use crate::{Adt, EnumVariant, ModuleDef};\n+use crate::{Adt, DefWithBody, EnumVariant, ModuleDef};\n \n macro_rules! from_id {\n     ($(($id:path, $ty:path)),*) => {$(\n@@ -61,3 +61,13 @@ impl From<ModuleDefId> for ModuleDef {\n         }\n     }\n }\n+\n+impl From<DefWithBody> for DefWithBodyId {\n+    fn from(def: DefWithBody) -> Self {\n+        match def {\n+            DefWithBody::Function(it) => DefWithBodyId::FunctionId(it.id),\n+            DefWithBody::Static(it) => DefWithBodyId::StaticId(it.id),\n+            DefWithBody::Const(it) => DefWithBodyId::ConstId(it.id),\n+        }\n+    }\n+}"}, {"sha": "9793af8587554f15f92e3bfa7ce4f6c7f38b0a54", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -10,7 +10,7 @@ use ra_syntax::{\n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::{AstItemDef, LocationCtx},\n-    AstId, Const, Crate, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasSource,\n+    AstId, Const, Crate, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasBody, HasSource,\n     ImplBlock, Local, Module, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias,\n     Union, VariantDef,\n };\n@@ -144,8 +144,9 @@ impl Local {\n             };\n             Some(res)\n         })?;\n-        let (_body, source_map) = db.body_with_source_map(parent);\n-        let pat_id = source_map.node_pat(&src.ast.into())?;\n+        let source_map = parent.body_source_map(db);\n+        let src = src.map(ast::Pat::from);\n+        let pat_id = source_map.node_pat(src.as_ref())?;\n         Some(Local { parent, pat_id })\n     }\n }"}, {"sha": "5ba847d3515934e2167f3a684258e798f16bc64a", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -77,9 +77,7 @@ pub use crate::{\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     ty::{\n         display::HirDisplay,\n-        primitive::{\n-            FloatBitness, FloatTy, IntBitness, IntTy, Signedness, UncertainFloatTy, UncertainIntTy,\n-        },\n+        primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain},\n         ApplicationTy, CallableDef, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n     },\n };"}, {"sha": "2f3e12eb83dd933070b83bbb9aedaa7938d84055", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -13,10 +13,7 @@ use rustc_hash::FxHashSet;\n use crate::{\n     code_model::Crate,\n     db::{DefDatabase, HirDatabase},\n-    expr::{\n-        scope::{ExprScopes, ScopeId},\n-        PatId,\n-    },\n+    expr::{ExprScopes, PatId, ScopeId},\n     generics::GenericParams,\n     impl_block::ImplBlock,\n     Adt, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, PerNs, Static, Struct, Trait,"}, {"sha": "ca40e3b5448bd6d03bc3cd04c609b96b97d8d2b3", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -7,8 +7,11 @@\n //! purely for \"IDE needs\".\n use std::sync::Arc;\n \n-use hir_def::path::known;\n-use hir_expand::name::AsName;\n+use hir_def::{\n+    expr::{ExprId, PatId},\n+    path::known,\n+};\n+use hir_expand::{name::AsName, Source};\n use ra_db::FileId;\n use ra_syntax::{\n     ast::{self, AstNode},\n@@ -20,11 +23,7 @@ use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n-    expr::{\n-        self,\n-        scope::{ExprScopes, ScopeId},\n-        BodySourceMap,\n-    },\n+    expr::{self, BodySourceMap, ExprScopes, ScopeId},\n     ids::LocationCtx,\n     resolve::{ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::{self, implements_trait},\n@@ -93,6 +92,8 @@ fn def_with_body_from_child_node(\n /// original source files. It should not be used inside the HIR itself.\n #[derive(Debug)]\n pub struct SourceAnalyzer {\n+    // FIXME: this doesn't handle macros at all\n+    file_id: FileId,\n     resolver: Resolver,\n     body_owner: Option<DefWithBody>,\n     body_source_map: Option<Arc<BodySourceMap>>,\n@@ -145,9 +146,9 @@ impl SourceAnalyzer {\n         let def_with_body = def_with_body_from_child_node(db, file_id, node);\n         if let Some(def) = def_with_body {\n             let source_map = def.body_source_map(db);\n-            let scopes = db.expr_scopes(def);\n+            let scopes = def.expr_scopes(db);\n             let scope = match offset {\n-                None => scope_for(&scopes, &source_map, &node),\n+                None => scope_for(&scopes, &source_map, file_id.into(), &node),\n                 Some(offset) => scope_for_offset(&scopes, &source_map, file_id.into(), offset),\n             };\n             let resolver = expr::resolver_for_scope(db, def, scope);\n@@ -157,6 +158,7 @@ impl SourceAnalyzer {\n                 body_source_map: Some(source_map),\n                 infer: Some(def.infer(db)),\n                 scopes: Some(scopes),\n+                file_id,\n             }\n         } else {\n             SourceAnalyzer {\n@@ -168,17 +170,28 @@ impl SourceAnalyzer {\n                 body_source_map: None,\n                 infer: None,\n                 scopes: None,\n+                file_id,\n             }\n         }\n     }\n \n+    fn expr_id(&self, expr: &ast::Expr) -> Option<ExprId> {\n+        let src = Source { file_id: self.file_id.into(), ast: expr };\n+        self.body_source_map.as_ref()?.node_expr(src)\n+    }\n+\n+    fn pat_id(&self, pat: &ast::Pat) -> Option<PatId> {\n+        let src = Source { file_id: self.file_id.into(), ast: pat };\n+        self.body_source_map.as_ref()?.node_pat(src)\n+    }\n+\n     pub fn type_of(&self, _db: &impl HirDatabase, expr: &ast::Expr) -> Option<crate::Ty> {\n-        let expr_id = self.body_source_map.as_ref()?.node_expr(expr)?;\n+        let expr_id = self.expr_id(expr)?;\n         Some(self.infer.as_ref()?[expr_id].clone())\n     }\n \n     pub fn type_of_pat(&self, _db: &impl HirDatabase, pat: &ast::Pat) -> Option<crate::Ty> {\n-        let pat_id = self.body_source_map.as_ref()?.node_pat(pat)?;\n+        let pat_id = self.pat_id(pat)?;\n         Some(self.infer.as_ref()?[pat_id].clone())\n     }\n \n@@ -191,22 +204,22 @@ impl SourceAnalyzer {\n     }\n \n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n-        let expr_id = self.body_source_map.as_ref()?.node_expr(&call.clone().into())?;\n+        let expr_id = self.expr_id(&call.clone().into())?;\n         self.infer.as_ref()?.method_resolution(expr_id)\n     }\n \n     pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<crate::StructField> {\n-        let expr_id = self.body_source_map.as_ref()?.node_expr(&field.clone().into())?;\n+        let expr_id = self.expr_id(&field.clone().into())?;\n         self.infer.as_ref()?.field_resolution(expr_id)\n     }\n \n     pub fn resolve_record_literal(&self, record_lit: &ast::RecordLit) -> Option<crate::VariantDef> {\n-        let expr_id = self.body_source_map.as_ref()?.node_expr(&record_lit.clone().into())?;\n+        let expr_id = self.expr_id(&record_lit.clone().into())?;\n         self.infer.as_ref()?.variant_resolution_for_expr(expr_id)\n     }\n \n     pub fn resolve_record_pattern(&self, record_pat: &ast::RecordPat) -> Option<crate::VariantDef> {\n-        let pat_id = self.body_source_map.as_ref()?.node_pat(&record_pat.clone().into())?;\n+        let pat_id = self.pat_id(&record_pat.clone().into())?;\n         self.infer.as_ref()?.variant_resolution_for_pat(pat_id)\n     }\n \n@@ -264,13 +277,13 @@ impl SourceAnalyzer {\n \n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &ast::Path) -> Option<PathResolution> {\n         if let Some(path_expr) = path.syntax().parent().and_then(ast::PathExpr::cast) {\n-            let expr_id = self.body_source_map.as_ref()?.node_expr(&path_expr.into())?;\n+            let expr_id = self.expr_id(&path_expr.into())?;\n             if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_expr(expr_id) {\n                 return Some(PathResolution::AssocItem(assoc));\n             }\n         }\n         if let Some(path_pat) = path.syntax().parent().and_then(ast::PathPat::cast) {\n-            let pat_id = self.body_source_map.as_ref()?.node_pat(&path_pat.into())?;\n+            let pat_id = self.pat_id(&path_pat.into())?;\n             if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_pat(pat_id) {\n                 return Some(PathResolution::AssocItem(assoc));\n             }\n@@ -285,7 +298,7 @@ impl SourceAnalyzer {\n         let name = name_ref.as_name();\n         let source_map = self.body_source_map.as_ref()?;\n         let scopes = self.scopes.as_ref()?;\n-        let scope = scope_for(scopes, source_map, name_ref.syntax());\n+        let scope = scope_for(scopes, source_map, self.file_id.into(), name_ref.syntax());\n         let ret = scopes\n             .scope_chain(scope)\n             .flat_map(|scope| scopes.entries(scope).iter())\n@@ -418,11 +431,12 @@ impl SourceAnalyzer {\n fn scope_for(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n+    file_id: HirFileId,\n     node: &SyntaxNode,\n ) -> Option<ScopeId> {\n     node.ancestors()\n         .filter_map(ast::Expr::cast)\n-        .filter_map(|it| source_map.node_expr(&it))\n+        .filter_map(|it| source_map.node_expr(Source { file_id, ast: &it }))\n         .find_map(|it| scopes.scope_for(it))\n }\n "}, {"sha": "ff6030ac42647bfe97b4135f1092b2c222e24850", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -21,7 +21,7 @@ use crate::{\n     expr::ExprId,\n     generics::{GenericParams, HasGenericParams},\n     util::make_mut_slice,\n-    Adt, Crate, DefWithBody, Mutability, Name, Trait, TypeAlias,\n+    Adt, Crate, DefWithBody, FloatTy, IntTy, Mutability, Name, Trait, TypeAlias, Uncertain,\n };\n use display::{HirDisplay, HirFormatter};\n \n@@ -47,10 +47,10 @@ pub enum TypeCtor {\n     Char,\n \n     /// A primitive integer type. For example, `i32`.\n-    Int(primitive::UncertainIntTy),\n+    Int(Uncertain<IntTy>),\n \n     /// A primitive floating-point type. For example, `f64`.\n-    Float(primitive::UncertainFloatTy),\n+    Float(Uncertain<FloatTy>),\n \n     /// Structures, enumerations and unions.\n     Adt(Adt),"}, {"sha": "c35378cc413dde6b38a403d216d4e26d0cab8f1c", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -31,10 +31,10 @@ use ra_prof::profile;\n use test_utils::tested_by;\n \n use super::{\n-    lower, primitive,\n+    lower,\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n     ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypableDef,\n-    TypeCtor, TypeWalk,\n+    TypeCtor, TypeWalk, Uncertain,\n };\n use crate::{\n     adt::VariantDef,\n@@ -43,7 +43,8 @@ use crate::{\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n     resolve::{Resolver, TypeNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n-    Adt, AssocItem, ConstData, DefWithBody, FnData, Function, Path, StructField,\n+    Adt, AssocItem, ConstData, DefWithBody, FloatTy, FnData, Function, HasBody, IntTy, Path,\n+    StructField,\n };\n \n macro_rules! ty_app {\n@@ -214,7 +215,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             coerce_unsized_map: Self::init_coerce_unsized_map(db, &resolver),\n             db,\n             owner,\n-            body: db.body(owner),\n+            body: owner.body(db),\n             resolver,\n         }\n     }\n@@ -358,14 +359,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty {\n             Ty::Unknown => self.new_type_var(),\n-            Ty::Apply(ApplicationTy {\n-                ctor: TypeCtor::Int(primitive::UncertainIntTy::Unknown),\n-                ..\n-            }) => self.new_integer_var(),\n-            Ty::Apply(ApplicationTy {\n-                ctor: TypeCtor::Float(primitive::UncertainFloatTy::Unknown),\n-                ..\n-            }) => self.new_float_var(),\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Int(Uncertain::Unknown), .. }) => {\n+                self.new_integer_var()\n+            }\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Float(Uncertain::Unknown), .. }) => {\n+                self.new_float_var()\n+            }\n             _ => ty,\n         }\n     }\n@@ -684,12 +683,8 @@ impl InferTy {\n     fn fallback_value(self) -> Ty {\n         match self {\n             InferTy::TypeVar(..) => Ty::Unknown,\n-            InferTy::IntVar(..) => {\n-                Ty::simple(TypeCtor::Int(primitive::UncertainIntTy::Known(primitive::IntTy::i32())))\n-            }\n-            InferTy::FloatVar(..) => Ty::simple(TypeCtor::Float(\n-                primitive::UncertainFloatTy::Known(primitive::FloatTy::f64()),\n-            )),\n+            InferTy::IntVar(..) => Ty::simple(TypeCtor::Int(Uncertain::Known(IntTy::i32()))),\n+            InferTy::FloatVar(..) => Ty::simple(TypeCtor::Float(Uncertain::Known(FloatTy::f64()))),\n             InferTy::MaybeNeverTypeVar(..) => Ty::simple(TypeCtor::Never),\n         }\n     }"}, {"sha": "5e68a1678f44275ba18e37fd46e733d7affbaf0a", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -3,7 +3,10 @@\n use std::iter::{repeat, repeat_with};\n use std::sync::Arc;\n \n-use hir_def::path::{GenericArg, GenericArgs};\n+use hir_def::{\n+    builtin_type::Signedness,\n+    path::{GenericArg, GenericArgs},\n+};\n use hir_expand::name;\n \n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n@@ -12,8 +15,9 @@ use crate::{\n     expr::{self, Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     generics::{GenericParams, HasGenericParams},\n     ty::{\n-        autoderef, method_resolution, op, primitive, CallableDef, InferTy, Mutability, Namespace,\n+        autoderef, method_resolution, op, CallableDef, InferTy, IntTy, Mutability, Namespace,\n         Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n+        Uncertain,\n     },\n     Adt, Name,\n };\n@@ -337,13 +341,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     UnaryOp::Neg => {\n                         match &inner_ty {\n                             Ty::Apply(a_ty) => match a_ty.ctor {\n-                                TypeCtor::Int(primitive::UncertainIntTy::Unknown)\n-                                | TypeCtor::Int(primitive::UncertainIntTy::Known(\n-                                    primitive::IntTy {\n-                                        signedness: primitive::Signedness::Signed,\n-                                        ..\n-                                    },\n-                                ))\n+                                TypeCtor::Int(Uncertain::Unknown)\n+                                | TypeCtor::Int(Uncertain::Known(IntTy {\n+                                    signedness: Signedness::Signed,\n+                                    ..\n+                                }))\n                                 | TypeCtor::Float(..) => inner_ty,\n                                 _ => Ty::Unknown,\n                             },\n@@ -428,9 +430,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         );\n                         self.infer_expr(\n                             *repeat,\n-                            &Expectation::has_type(Ty::simple(TypeCtor::Int(\n-                                primitive::UncertainIntTy::Known(primitive::IntTy::usize()),\n-                            ))),\n+                            &Expectation::has_type(Ty::simple(TypeCtor::Int(Uncertain::Known(\n+                                IntTy::usize(),\n+                            )))),\n                         );\n                     }\n                 }\n@@ -443,9 +445,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     Ty::apply_one(TypeCtor::Ref(Mutability::Shared), Ty::simple(TypeCtor::Str))\n                 }\n                 Literal::ByteString(..) => {\n-                    let byte_type = Ty::simple(TypeCtor::Int(primitive::UncertainIntTy::Known(\n-                        primitive::IntTy::u8(),\n-                    )));\n+                    let byte_type = Ty::simple(TypeCtor::Int(Uncertain::Known(IntTy::u8())));\n                     let slice_type = Ty::apply_one(TypeCtor::Slice, byte_type);\n                     Ty::apply_one(TypeCtor::Ref(Mutability::Shared), slice_type)\n                 }"}, {"sha": "de3c56097bd119930fb991910a07fbe2d868ed82", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -25,7 +25,7 @@ use crate::{\n     generics::{GenericDef, WherePredicate},\n     resolve::{Resolver, TypeNs},\n     ty::{\n-        primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n+        primitive::{FloatTy, IntTy, Uncertain},\n         Adt,\n     },\n     util::make_mut_slice,\n@@ -674,20 +674,20 @@ impl From<BuiltinFloat> for FloatTy {\n     }\n }\n \n-impl From<Option<BuiltinInt>> for UncertainIntTy {\n+impl From<Option<BuiltinInt>> for Uncertain<IntTy> {\n     fn from(t: Option<BuiltinInt>) -> Self {\n         match t {\n-            None => UncertainIntTy::Unknown,\n-            Some(t) => UncertainIntTy::Known(t.into()),\n+            None => Uncertain::Unknown,\n+            Some(t) => Uncertain::Known(t.into()),\n         }\n     }\n }\n \n-impl From<Option<BuiltinFloat>> for UncertainFloatTy {\n+impl From<Option<BuiltinFloat>> for Uncertain<FloatTy> {\n     fn from(t: Option<BuiltinFloat>) -> Self {\n         match t {\n-            None => UncertainFloatTy::Unknown,\n-            Some(t) => UncertainFloatTy::Known(t.into()),\n+            None => Uncertain::Unknown,\n+            Some(t) => Uncertain::Known(t.into()),\n         }\n     }\n }"}, {"sha": "eb5ca6769a1d286e98334be0b9f662fdab8634a6", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -8,16 +8,17 @@ use arrayvec::ArrayVec;\n use hir_def::CrateModuleId;\n use rustc_hash::FxHashMap;\n \n-use super::{autoderef, lower, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n use crate::{\n     db::HirDatabase,\n     impl_block::{ImplBlock, ImplId},\n     resolve::Resolver,\n-    ty::primitive::{FloatBitness, UncertainFloatTy, UncertainIntTy},\n+    ty::primitive::{FloatBitness, Uncertain},\n     ty::{Ty, TypeCtor},\n     AssocItem, Crate, Function, Module, Mutability, Name, Trait,\n };\n \n+use super::{autoderef, lower, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n+\n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum TyFingerprint {\n@@ -140,14 +141,12 @@ fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayV\n             TypeCtor::Adt(def_id) => Some(std::iter::once(def_id.krate(db)?).collect()),\n             TypeCtor::Bool => lang_item_crate!(db, cur_crate, \"bool\"),\n             TypeCtor::Char => lang_item_crate!(db, cur_crate, \"char\"),\n-            TypeCtor::Float(UncertainFloatTy::Known(f)) => match f.bitness {\n+            TypeCtor::Float(Uncertain::Known(f)) => match f.bitness {\n                 // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n                 FloatBitness::X32 => lang_item_crate!(db, cur_crate, \"f32\", \"f32_runtime\"),\n                 FloatBitness::X64 => lang_item_crate!(db, cur_crate, \"f64\", \"f64_runtime\"),\n             },\n-            TypeCtor::Int(UncertainIntTy::Known(i)) => {\n-                lang_item_crate!(db, cur_crate, i.ty_to_string())\n-            }\n+            TypeCtor::Int(Uncertain::Known(i)) => lang_item_crate!(db, cur_crate, i.ty_to_string()),\n             TypeCtor::Str => lang_item_crate!(db, cur_crate, \"str_alloc\", \"str\"),\n             TypeCtor::Slice => lang_item_crate!(db, cur_crate, \"slice_alloc\", \"slice\"),\n             TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(db, cur_crate, \"const_ptr\"),"}, {"sha": "47789db8775c1eb298f6f8fa24b64a6a33f49742", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -4,44 +4,38 @@ use std::fmt;\n \n pub use hir_def::builtin_type::{FloatBitness, IntBitness, Signedness};\n \n-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n-pub enum UncertainIntTy {\n+#[derive(Clone, Copy, Eq, PartialEq, Hash, Debug)]\n+pub enum Uncertain<T> {\n     Unknown,\n-    Known(IntTy),\n+    Known(T),\n }\n \n-impl From<IntTy> for UncertainIntTy {\n+impl From<IntTy> for Uncertain<IntTy> {\n     fn from(ty: IntTy) -> Self {\n-        UncertainIntTy::Known(ty)\n+        Uncertain::Known(ty)\n     }\n }\n \n-impl fmt::Display for UncertainIntTy {\n+impl fmt::Display for Uncertain<IntTy> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            UncertainIntTy::Unknown => write!(f, \"{{integer}}\"),\n-            UncertainIntTy::Known(ty) => write!(f, \"{}\", ty),\n+            Uncertain::Unknown => write!(f, \"{{integer}}\"),\n+            Uncertain::Known(ty) => write!(f, \"{}\", ty),\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n-pub enum UncertainFloatTy {\n-    Unknown,\n-    Known(FloatTy),\n-}\n-\n-impl From<FloatTy> for UncertainFloatTy {\n+impl From<FloatTy> for Uncertain<FloatTy> {\n     fn from(ty: FloatTy) -> Self {\n-        UncertainFloatTy::Known(ty)\n+        Uncertain::Known(ty)\n     }\n }\n \n-impl fmt::Display for UncertainFloatTy {\n+impl fmt::Display for Uncertain<FloatTy> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            UncertainFloatTy::Unknown => write!(f, \"{{float}}\"),\n-            UncertainFloatTy::Known(ty) => write!(f, \"{}\", ty),\n+            Uncertain::Unknown => write!(f, \"{{float}}\"),\n+            Uncertain::Known(ty) => write!(f, \"{}\", ty),\n         }\n     }\n }"}, {"sha": "75351c17d51eaec1684dc7edbd54ad7f17b8fd80", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -22,7 +22,7 @@ use crate::{\n         ApplicationTy, GenericPredicate, Namespace, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n         TypeWalk,\n     },\n-    AssocItem, Crate, ImplBlock, Trait, TypeAlias,\n+    AssocItem, Crate, HasBody, ImplBlock, Trait, TypeAlias,\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -714,7 +714,7 @@ fn closure_fn_trait_impl_datum(\n     let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n     let trait_ = get_fn_trait(db, krate, data.fn_trait)?; // get corresponding fn trait\n \n-    let num_args: u16 = match &db.body(data.def)[data.expr] {\n+    let num_args: u16 = match &data.def.body(db)[data.expr] {\n         crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n         _ => {\n             log::warn!(\"closure for closure type {:?} not found\", data);"}, {"sha": "85dc4feb0a3f6375d17cedd8e4ed5ac89c537e23", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 115, "deletions": 21, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -1,40 +1,103 @@\n //! FIXME: write short doc here\n mod lower;\n+pub mod scope;\n \n use std::{ops::Index, sync::Arc};\n \n-use hir_expand::{either::Either, HirFileId, MacroDefId, Source};\n+use hir_expand::{\n+    either::Either, hygiene::Hygiene, AstId, HirFileId, MacroCallLoc, MacroDefId, MacroFileKind,\n+    Source,\n+};\n use ra_arena::{map::ArenaMap, Arena};\n-use ra_syntax::{ast, AstPtr};\n+use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n \n use crate::{\n     db::DefDatabase2,\n     expr::{Expr, ExprId, Pat, PatId},\n     nameres::CrateDefMap,\n     path::Path,\n-    ModuleId,\n+    AstItemDef, DefWithBodyId, ModuleId,\n };\n \n-pub struct MacroResolver {\n+pub struct Expander {\n     crate_def_map: Arc<CrateDefMap>,\n+    current_file_id: HirFileId,\n+    hygiene: Hygiene,\n     module: ModuleId,\n }\n \n-impl MacroResolver {\n-    pub fn new(db: &impl DefDatabase2, module: ModuleId) -> MacroResolver {\n-        MacroResolver { crate_def_map: db.crate_def_map(module.krate), module }\n+impl Expander {\n+    pub fn new(db: &impl DefDatabase2, current_file_id: HirFileId, module: ModuleId) -> Expander {\n+        let crate_def_map = db.crate_def_map(module.krate);\n+        let hygiene = Hygiene::new(db, current_file_id);\n+        Expander { crate_def_map, current_file_id, hygiene, module }\n     }\n \n-    pub(crate) fn resolve_path_as_macro(\n-        &self,\n+    fn enter_expand(\n+        &mut self,\n         db: &impl DefDatabase2,\n-        path: &Path,\n-    ) -> Option<MacroDefId> {\n+        macro_call: ast::MacroCall,\n+    ) -> Option<(Mark, ast::Expr)> {\n+        let ast_id = AstId::new(\n+            self.current_file_id,\n+            db.ast_id_map(self.current_file_id).ast_id(&macro_call),\n+        );\n+\n+        if let Some(path) = macro_call.path().and_then(|path| self.parse_path(path)) {\n+            if let Some(def) = self.resolve_path_as_macro(db, &path) {\n+                let call_id = db.intern_macro(MacroCallLoc { def, ast_id });\n+                let file_id = call_id.as_file(MacroFileKind::Expr);\n+                if let Some(node) = db.parse_or_expand(file_id) {\n+                    if let Some(expr) = ast::Expr::cast(node) {\n+                        log::debug!(\"macro expansion {:#?}\", expr.syntax());\n+\n+                        let mark = Mark { file_id: self.current_file_id };\n+                        self.hygiene = Hygiene::new(db, file_id);\n+                        self.current_file_id = file_id;\n+\n+                        return Some((mark, expr));\n+                    }\n+                }\n+            }\n+        }\n+\n+        // FIXME: Instead of just dropping the error from expansion\n+        // report it\n+        None\n+    }\n+\n+    fn exit(&mut self, db: &impl DefDatabase2, mark: Mark) {\n+        self.hygiene = Hygiene::new(db, mark.file_id);\n+        self.current_file_id = mark.file_id;\n+        std::mem::forget(mark);\n+    }\n+\n+    fn to_source<T>(&self, ast: T) -> Source<T> {\n+        Source { file_id: self.current_file_id, ast }\n+    }\n+\n+    fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n+        Path::from_src(path, &self.hygiene)\n+    }\n+\n+    fn resolve_path_as_macro(&self, db: &impl DefDatabase2, path: &Path) -> Option<MacroDefId> {\n         self.crate_def_map.resolve_path(db, self.module.module_id, path).0.get_macros()\n     }\n }\n \n+struct Mark {\n+    file_id: HirFileId,\n+}\n+\n+impl Drop for Mark {\n+    fn drop(&mut self) {\n+        if !std::thread::panicking() {\n+            panic!(\"dropped mark\")\n+        }\n+    }\n+}\n+\n /// The body of an item (function, const etc.).\n #[derive(Debug, Eq, PartialEq)]\n pub struct Body {\n@@ -70,22 +133,51 @@ pub type PatSource = Source<PatPtr>;\n /// this properly for macros.\n #[derive(Default, Debug, Eq, PartialEq)]\n pub struct BodySourceMap {\n-    expr_map: FxHashMap<ExprPtr, ExprId>,\n+    expr_map: FxHashMap<ExprSource, ExprId>,\n     expr_map_back: ArenaMap<ExprId, ExprSource>,\n-    pat_map: FxHashMap<PatPtr, PatId>,\n+    pat_map: FxHashMap<PatSource, PatId>,\n     pat_map_back: ArenaMap<PatId, PatSource>,\n     field_map: FxHashMap<(ExprId, usize), AstPtr<ast::RecordField>>,\n }\n \n impl Body {\n-    pub fn new(\n+    pub(crate) fn body_with_source_map_query(\n+        db: &impl DefDatabase2,\n+        def: DefWithBodyId,\n+    ) -> (Arc<Body>, Arc<BodySourceMap>) {\n+        let mut params = None;\n+\n+        let (file_id, module, body) = match def {\n+            DefWithBodyId::FunctionId(f) => {\n+                let src = f.source(db);\n+                params = src.ast.param_list();\n+                (src.file_id, f.module(db), src.ast.body().map(ast::Expr::from))\n+            }\n+            DefWithBodyId::ConstId(c) => {\n+                let src = c.source(db);\n+                (src.file_id, c.module(db), src.ast.body())\n+            }\n+            DefWithBodyId::StaticId(s) => {\n+                let src = s.source(db);\n+                (src.file_id, s.module(db), src.ast.body())\n+            }\n+        };\n+        let expander = Expander::new(db, file_id, module);\n+        let (body, source_map) = Body::new(db, expander, params, body);\n+        (Arc::new(body), Arc::new(source_map))\n+    }\n+\n+    pub(crate) fn body_query(db: &impl DefDatabase2, def: DefWithBodyId) -> Arc<Body> {\n+        db.body_with_source_map(def).0\n+    }\n+\n+    fn new(\n         db: &impl DefDatabase2,\n-        resolver: MacroResolver,\n-        file_id: HirFileId,\n+        expander: Expander,\n         params: Option<ast::ParamList>,\n         body: Option<ast::Expr>,\n     ) -> (Body, BodySourceMap) {\n-        lower::lower(db, resolver, file_id, params, body)\n+        lower::lower(db, expander, params, body)\n     }\n \n     pub fn params(&self) -> &[PatId] {\n@@ -126,16 +218,18 @@ impl BodySourceMap {\n         self.expr_map_back.get(expr).copied()\n     }\n \n-    pub fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n-        self.expr_map.get(&Either::A(AstPtr::new(node))).cloned()\n+    pub fn node_expr(&self, node: Source<&ast::Expr>) -> Option<ExprId> {\n+        let src = node.map(|it| Either::A(AstPtr::new(it)));\n+        self.expr_map.get(&src).cloned()\n     }\n \n     pub fn pat_syntax(&self, pat: PatId) -> Option<PatSource> {\n         self.pat_map_back.get(pat).copied()\n     }\n \n-    pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n-        self.pat_map.get(&Either::A(AstPtr::new(node))).cloned()\n+    pub fn node_pat(&self, node: Source<&ast::Pat>) -> Option<PatId> {\n+        let src = node.map(|it| Either::A(AstPtr::new(it)));\n+        self.pat_map.get(&src).cloned()\n     }\n \n     pub fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::RecordField> {"}, {"sha": "a5bb60e8576e81af94a1446f764c179e7552dc33", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 27, "deletions": 63, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -2,9 +2,7 @@\n \n use hir_expand::{\n     either::Either,\n-    hygiene::Hygiene,\n     name::{self, AsName, Name},\n-    AstId, HirFileId, MacroCallLoc, MacroFileKind, Source,\n };\n use ra_arena::Arena;\n use ra_syntax::{\n@@ -16,7 +14,7 @@ use ra_syntax::{\n };\n \n use crate::{\n-    body::{Body, BodySourceMap, MacroResolver, PatPtr},\n+    body::{Body, BodySourceMap, Expander, PatPtr},\n     builtin_type::{BuiltinFloat, BuiltinInt},\n     db::DefDatabase2,\n     expr::{\n@@ -30,16 +28,13 @@ use crate::{\n \n pub(super) fn lower(\n     db: &impl DefDatabase2,\n-    resolver: MacroResolver,\n-    file_id: HirFileId,\n+    expander: Expander,\n     params: Option<ast::ParamList>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n     ExprCollector {\n-        resolver,\n+        expander,\n         db,\n-        original_file_id: file_id,\n-        current_file_id: file_id,\n         source_map: BodySourceMap::default(),\n         body: Body {\n             exprs: Arena::default(),\n@@ -53,9 +48,7 @@ pub(super) fn lower(\n \n struct ExprCollector<DB> {\n     db: DB,\n-    resolver: MacroResolver,\n-    original_file_id: HirFileId,\n-    current_file_id: HirFileId,\n+    expander: Expander,\n \n     body: Body,\n     source_map: BodySourceMap,\n@@ -101,12 +94,9 @@ where\n     fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n         let ptr = Either::A(ptr);\n         let id = self.body.exprs.alloc(expr);\n-        if self.current_file_id == self.original_file_id {\n-            self.source_map.expr_map.insert(ptr, id);\n-        }\n-        self.source_map\n-            .expr_map_back\n-            .insert(id, Source { file_id: self.current_file_id, ast: ptr });\n+        let src = self.expander.to_source(ptr);\n+        self.source_map.expr_map.insert(src, id);\n+        self.source_map.expr_map_back.insert(id, src);\n         id\n     }\n     // desugared exprs don't have ptr, that's wrong and should be fixed\n@@ -117,20 +107,16 @@ where\n     fn alloc_expr_field_shorthand(&mut self, expr: Expr, ptr: AstPtr<ast::RecordField>) -> ExprId {\n         let ptr = Either::B(ptr);\n         let id = self.body.exprs.alloc(expr);\n-        if self.current_file_id == self.original_file_id {\n-            self.source_map.expr_map.insert(ptr, id);\n-        }\n-        self.source_map\n-            .expr_map_back\n-            .insert(id, Source { file_id: self.current_file_id, ast: ptr });\n+        let src = self.expander.to_source(ptr);\n+        self.source_map.expr_map.insert(src, id);\n+        self.source_map.expr_map_back.insert(id, src);\n         id\n     }\n     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n         let id = self.body.pats.alloc(pat);\n-        if self.current_file_id == self.original_file_id {\n-            self.source_map.pat_map.insert(ptr, id);\n-        }\n-        self.source_map.pat_map_back.insert(id, Source { file_id: self.current_file_id, ast: ptr });\n+        let src = self.expander.to_source(ptr);\n+        self.source_map.pat_map.insert(src, id);\n+        self.source_map.pat_map_back.insert(id, src);\n         id\n     }\n \n@@ -272,7 +258,7 @@ where\n             ast::Expr::PathExpr(e) => {\n                 let path = e\n                     .path()\n-                    .and_then(|path| self.parse_path(path))\n+                    .and_then(|path| self.expander.parse_path(path))\n                     .map(Expr::Path)\n                     .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n@@ -288,15 +274,16 @@ where\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n                 // make the paren expr point to the inner expression as well\n-                self.source_map.expr_map.insert(Either::A(syntax_ptr), inner);\n+                let src = self.expander.to_source(Either::A(syntax_ptr));\n+                self.source_map.expr_map.insert(src, inner);\n                 inner\n             }\n             ast::Expr::ReturnExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::Expr::RecordLit(e) => {\n-                let path = e.path().and_then(|path| self.parse_path(path));\n+                let path = e.path().and_then(|path| self.expander.parse_path(path));\n                 let mut field_ptrs = Vec::new();\n                 let record_lit = if let Some(nfl) = e.record_field_list() {\n                     let fields = nfl\n@@ -443,32 +430,14 @@ where\n             // FIXME implement HIR for these:\n             ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::MacroCall(e) => {\n-                let ast_id = AstId::new(\n-                    self.current_file_id,\n-                    self.db.ast_id_map(self.current_file_id).ast_id(&e),\n-                );\n-\n-                if let Some(path) = e.path().and_then(|path| self.parse_path(path)) {\n-                    if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n-                        let call_id = self.db.intern_macro(MacroCallLoc { def, ast_id });\n-                        let file_id = call_id.as_file(MacroFileKind::Expr);\n-                        if let Some(node) = self.db.parse_or_expand(file_id) {\n-                            if let Some(expr) = ast::Expr::cast(node) {\n-                                log::debug!(\"macro expansion {:#?}\", expr.syntax());\n-                                let old_file_id =\n-                                    std::mem::replace(&mut self.current_file_id, file_id);\n-                                let id = self.collect_expr(expr);\n-                                self.current_file_id = old_file_id;\n-                                return id;\n-                            }\n-                        }\n-                    }\n+            ast::Expr::MacroCall(e) => match self.expander.enter_expand(self.db, e) {\n+                Some((mark, expansion)) => {\n+                    let id = self.collect_expr(expansion);\n+                    self.expander.exit(self.db, mark);\n+                    id\n                 }\n-                // FIXME: Instead of just dropping the error from expansion\n-                // report it\n-                self.alloc_expr(Expr::Missing, syntax_ptr)\n-            }\n+                None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            },\n         }\n     }\n \n@@ -519,7 +488,7 @@ where\n                 Pat::Bind { name, mode: annotation, subpat }\n             }\n             ast::Pat::TupleStructPat(p) => {\n-                let path = p.path().and_then(|path| self.parse_path(path));\n+                let path = p.path().and_then(|path| self.expander.parse_path(path));\n                 let args = p.args().map(|p| self.collect_pat(p)).collect();\n                 Pat::TupleStruct { path, args }\n             }\n@@ -529,7 +498,7 @@ where\n                 Pat::Ref { pat, mutability }\n             }\n             ast::Pat::PathPat(p) => {\n-                let path = p.path().and_then(|path| self.parse_path(path));\n+                let path = p.path().and_then(|path| self.expander.parse_path(path));\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n             ast::Pat::TuplePat(p) => {\n@@ -538,7 +507,7 @@ where\n             }\n             ast::Pat::PlaceholderPat(_) => Pat::Wild,\n             ast::Pat::RecordPat(p) => {\n-                let path = p.path().and_then(|path| self.parse_path(path));\n+                let path = p.path().and_then(|path| self.expander.parse_path(path));\n                 let record_field_pat_list =\n                     p.record_field_pat_list().expect(\"every struct should have a field list\");\n                 let mut fields: Vec<_> = record_field_pat_list\n@@ -579,11 +548,6 @@ where\n             self.missing_pat()\n         }\n     }\n-\n-    fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n-        let hygiene = Hygiene::new(self.db, self.current_file_id);\n-        Path::from_src(path, &hygiene)\n-    }\n }\n \n impl From<ast::BinOp> for BinaryOp {"}, {"sha": "09a39e721e63aaced3edd469ec9c2e9de302f4f2", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -0,0 +1,165 @@\n+//! FIXME: write short doc here\n+use std::sync::Arc;\n+\n+use hir_expand::name::Name;\n+use ra_arena::{impl_arena_id, Arena, RawId};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{\n+    body::Body,\n+    db::DefDatabase2,\n+    expr::{Expr, ExprId, Pat, PatId, Statement},\n+    DefWithBodyId,\n+};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ScopeId(RawId);\n+impl_arena_id!(ScopeId);\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ExprScopes {\n+    scopes: Arena<ScopeId, ScopeData>,\n+    scope_by_expr: FxHashMap<ExprId, ScopeId>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ScopeEntry {\n+    name: Name,\n+    pat: PatId,\n+}\n+\n+impl ScopeEntry {\n+    pub fn name(&self) -> &Name {\n+        &self.name\n+    }\n+\n+    pub fn pat(&self) -> PatId {\n+        self.pat\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ScopeData {\n+    parent: Option<ScopeId>,\n+    entries: Vec<ScopeEntry>,\n+}\n+\n+impl ExprScopes {\n+    pub(crate) fn expr_scopes_query(db: &impl DefDatabase2, def: DefWithBodyId) -> Arc<ExprScopes> {\n+        let body = db.body(def);\n+        Arc::new(ExprScopes::new(&*body))\n+    }\n+\n+    fn new(body: &Body) -> ExprScopes {\n+        let mut scopes =\n+            ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n+        let root = scopes.root_scope();\n+        scopes.add_params_bindings(body, root, body.params());\n+        compute_expr_scopes(body.body_expr(), body, &mut scopes, root);\n+        scopes\n+    }\n+\n+    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+        &self.scopes[scope].entries\n+    }\n+\n+    pub fn scope_chain(&self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + '_ {\n+        std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n+    }\n+\n+    pub fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n+        self.scope_by_expr.get(&expr).copied()\n+    }\n+\n+    pub fn scope_by_expr(&self) -> &FxHashMap<ExprId, ScopeId> {\n+        &self.scope_by_expr\n+    }\n+\n+    fn root_scope(&mut self) -> ScopeId {\n+        self.scopes.alloc(ScopeData { parent: None, entries: vec![] })\n+    }\n+\n+    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n+        self.scopes.alloc(ScopeData { parent: Some(parent), entries: vec![] })\n+    }\n+\n+    fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n+        match &body[pat] {\n+            Pat::Bind { name, .. } => {\n+                // bind can have a sub pattern, but it's actually not allowed\n+                // to bind to things in there\n+                let entry = ScopeEntry { name: name.clone(), pat };\n+                self.scopes[scope].entries.push(entry)\n+            }\n+            p => p.walk_child_pats(|pat| self.add_bindings(body, scope, pat)),\n+        }\n+    }\n+\n+    fn add_params_bindings(&mut self, body: &Body, scope: ScopeId, params: &[PatId]) {\n+        params.iter().for_each(|pat| self.add_bindings(body, scope, *pat));\n+    }\n+\n+    fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n+        self.scope_by_expr.insert(node, scope);\n+    }\n+}\n+\n+fn compute_block_scopes(\n+    statements: &[Statement],\n+    tail: Option<ExprId>,\n+    body: &Body,\n+    scopes: &mut ExprScopes,\n+    mut scope: ScopeId,\n+) {\n+    for stmt in statements {\n+        match stmt {\n+            Statement::Let { pat, initializer, .. } => {\n+                if let Some(expr) = initializer {\n+                    scopes.set_scope(*expr, scope);\n+                    compute_expr_scopes(*expr, body, scopes, scope);\n+                }\n+                scope = scopes.new_scope(scope);\n+                scopes.add_bindings(body, scope, *pat);\n+            }\n+            Statement::Expr(expr) => {\n+                scopes.set_scope(*expr, scope);\n+                compute_expr_scopes(*expr, body, scopes, scope);\n+            }\n+        }\n+    }\n+    if let Some(expr) = tail {\n+        compute_expr_scopes(expr, body, scopes, scope);\n+    }\n+}\n+\n+fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: ScopeId) {\n+    scopes.set_scope(expr, scope);\n+    match &body[expr] {\n+        Expr::Block { statements, tail } => {\n+            compute_block_scopes(&statements, *tail, body, scopes, scope);\n+        }\n+        Expr::For { iterable, pat, body: body_expr } => {\n+            compute_expr_scopes(*iterable, body, scopes, scope);\n+            let scope = scopes.new_scope(scope);\n+            scopes.add_bindings(body, scope, *pat);\n+            compute_expr_scopes(*body_expr, body, scopes, scope);\n+        }\n+        Expr::Lambda { args, body: body_expr, .. } => {\n+            let scope = scopes.new_scope(scope);\n+            scopes.add_params_bindings(body, scope, &args);\n+            compute_expr_scopes(*body_expr, body, scopes, scope);\n+        }\n+        Expr::Match { expr, arms } => {\n+            compute_expr_scopes(*expr, body, scopes, scope);\n+            for arm in arms {\n+                let scope = scopes.new_scope(scope);\n+                for pat in &arm.pats {\n+                    scopes.add_bindings(body, scope, *pat);\n+                }\n+                scopes.set_scope(arm.expr, scope);\n+                compute_expr_scopes(arm.expr, body, scopes, scope);\n+            }\n+        }\n+        e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n+    };\n+}"}, {"sha": "40b5920d9bf833ba9733e3dd3ff104eb76a64820", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -7,11 +7,12 @@ use ra_syntax::ast;\n \n use crate::{\n     adt::{EnumData, StructData},\n+    body::{scope::ExprScopes, Body, BodySourceMap},\n     nameres::{\n         raw::{ImportSourceMap, RawItems},\n         CrateDefMap,\n     },\n-    EnumId, StructOrUnionId,\n+    DefWithBodyId, EnumId, StructOrUnionId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n@@ -52,4 +53,13 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n \n     #[salsa::invoke(EnumData::enum_data_query)]\n     fn enum_data(&self, e: EnumId) -> Arc<EnumData>;\n+\n+    #[salsa::invoke(Body::body_with_source_map_query)]\n+    fn body_with_source_map(&self, def: DefWithBodyId) -> (Arc<Body>, Arc<BodySourceMap>);\n+\n+    #[salsa::invoke(Body::body_query)]\n+    fn body(&self, def: DefWithBodyId) -> Arc<Body>;\n+\n+    #[salsa::invoke(ExprScopes::expr_scopes_query)]\n+    fn expr_scopes(&self, def: DefWithBodyId) -> Arc<ExprScopes>;\n }"}, {"sha": "3fab7965ca611bc66b4c5c22d2de948dce147cfd", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -374,3 +374,13 @@ impl_froms!(\n     TypeAliasId,\n     BuiltinType\n );\n+\n+/// The defs which have a body.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum DefWithBodyId {\n+    FunctionId(FunctionId),\n+    StaticId(StaticId),\n+    ConstId(ConstId),\n+}\n+\n+impl_froms!(DefWithBodyId: FunctionId, ConstId, StaticId);"}, {"sha": "930789b0fe2a5bc6ab42b9978c332dffbceecbc9", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -223,7 +223,7 @@ impl<N: AstNode> AstId<N> {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]\n pub struct Source<T> {\n     pub file_id: HirFileId,\n     pub ast: T,\n@@ -233,6 +233,9 @@ impl<T> Source<T> {\n     pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n         Source { file_id: self.file_id, ast: f(self.ast) }\n     }\n+    pub fn as_ref(&self) -> Source<&T> {\n+        Source { file_id: self.file_id, ast: &self.ast }\n+    }\n     pub fn file_syntax(&self, db: &impl db::AstDatabase) -> SyntaxNode {\n         db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n     }"}, {"sha": "f06191963f02805e59ed1505d125e4bcafd70b4d", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -40,24 +40,24 @@ pub(crate) fn literal(p: &mut Parser) -> Option<CompletedMarker> {\n // E.g. for after the break in `if break {}`, this should not match\n pub(super) const ATOM_EXPR_FIRST: TokenSet =\n     LITERAL_FIRST.union(paths::PATH_FIRST).union(token_set![\n-        L_PAREN,\n-        L_CURLY,\n-        L_BRACK,\n-        PIPE,\n-        MOVE_KW,\n-        BOX_KW,\n-        IF_KW,\n-        WHILE_KW,\n-        MATCH_KW,\n-        UNSAFE_KW,\n-        RETURN_KW,\n-        BREAK_KW,\n-        CONTINUE_KW,\n+        T!['('],\n+        T!['{'],\n+        T!['['],\n+        T![|],\n+        T![move],\n+        T![box],\n+        T![if],\n+        T![while],\n+        T![match],\n+        T![unsafe],\n+        T![return],\n+        T![break],\n+        T![continue],\n+        T![async],\n+        T![try],\n+        T![loop],\n+        T![for],\n         LIFETIME,\n-        ASYNC_KW,\n-        TRY_KW,\n-        LOOP_KW,\n-        FOR_KW,\n     ]);\n \n const EXPR_RECOVERY_SET: TokenSet = token_set![LET_KW];"}, {"sha": "2a6952c013ac8bc27d082ff6732c64bb0e9f65c9", "filename": "crates/ra_parser/src/token_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_parser%2Fsrc%2Ftoken_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_parser%2Fsrc%2Ftoken_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Ftoken_set.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -30,8 +30,8 @@ const fn mask(kind: SyntaxKind) -> u128 {\n \n #[macro_export]\n macro_rules! token_set {\n-    ($($t:ident),*) => { TokenSet::empty()$(.union(TokenSet::singleton($t)))* };\n-    ($($t:ident),* ,) => { token_set!($($t),*) };\n+    ($($t:expr),*) => { TokenSet::empty()$(.union(TokenSet::singleton($t)))* };\n+    ($($t:expr),* ,) => { token_set!($($t),*) };\n }\n \n #[test]"}, {"sha": "bb241258cfcc110b4156ba9703317877558154d1", "filename": "crates/ra_prof/Cargo.toml", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_prof%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_prof%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2FCargo.toml?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -1,17 +1,19 @@\n-[package]\n-edition = \"2018\"\n-name = \"ra_prof\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n-publish = false\n-\n-[dependencies]\n-once_cell = \"1.0.1\"\n-itertools = \"0.8.0\"\n-backtrace = \"0.3.28\"\n-jemallocator = { version = \"0.3.2\", optional = true }\n-jemalloc-ctl = { version = \"0.3.2\", optional = true }\n-\n-[features]\n-jemalloc = [ \"jemallocator\", \"jemalloc-ctl\" ]\n-cpu_profiler = []\n+[package]\r\n+edition = \"2018\"\r\n+name = \"ra_prof\"\r\n+version = \"0.1.0\"\r\n+authors = [\"rust-analyzer developers\"]\r\n+publish = false\r\n+\r\n+[dependencies]\r\n+once_cell = \"1.0.1\"\r\n+itertools = \"0.8.0\"\r\n+backtrace = \"0.3.28\"\r\n+\r\n+[target.'cfg(not(target_env = \"msvc\"))'.dependencies]\r\n+jemallocator = { version = \"0.3.2\", optional = true }\r\n+jemalloc-ctl = { version = \"0.3.2\", optional = true }\r\n+\r\n+[features]\r\n+jemalloc = [ \"jemallocator\", \"jemalloc-ctl\" ]\r\n+cpu_profiler = []\r"}, {"sha": "845b2221c8f189e5bdee691f5d64e1de1fbe7752", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -24,7 +24,7 @@ pub use crate::memory_usage::{Bytes, MemoryUsage};\n \n // We use jemalloc mainly to get heap usage statistics, actual performance\n // difference is not measures.\n-#[cfg(feature = \"jemalloc\")]\n+#[cfg(all(feature = \"jemalloc\", not(target_env = \"msvc\")))]\n #[global_allocator]\n static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n "}, {"sha": "9768f656c4266f7c4de698f40b7a8df330fe9b51", "filename": "crates/ra_prof/src/memory_usage.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_prof%2Fsrc%2Fmemory_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_prof%2Fsrc%2Fmemory_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Fmemory_usage.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -8,7 +8,7 @@ pub struct MemoryUsage {\n }\n \n impl MemoryUsage {\n-    #[cfg(feature = \"jemalloc\")]\n+    #[cfg(all(feature = \"jemalloc\", not(target_env = \"msvc\")))]\n     pub fn current() -> MemoryUsage {\n         jemalloc_ctl::epoch::advance().unwrap();\n         MemoryUsage {\n@@ -17,7 +17,7 @@ impl MemoryUsage {\n         }\n     }\n \n-    #[cfg(not(feature = \"jemalloc\"))]\n+    #[cfg(any(not(feature = \"jemalloc\"), target_env = \"msvc\"))]\n     pub fn current() -> MemoryUsage {\n         MemoryUsage { allocated: Bytes(0), resident: Bytes(0) }\n     }"}, {"sha": "6f005a2d88c9b0f9dccc4956ebfec057592d29ca", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -358,7 +358,7 @@ fn replace_children<N: AstNode>(\n fn test_increase_indent() {\n     let arm_list = {\n         let arm = make::match_arm(iter::once(make::placeholder_pat().into()), make::expr_unit());\n-        make::match_arm_list(vec![arm.clone(), arm].into_iter())\n+        make::match_arm_list(vec![arm.clone(), arm])\n     };\n     assert_eq!(\n         arm_list.syntax().to_string(),"}, {"sha": "9749327fa45a55cdb7ea96d574882d7440ae0fc1", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -4,6 +4,10 @@ use itertools::Itertools;\n \n use crate::{ast, AstNode, SourceFile};\n \n+pub fn name(text: &str) -> ast::Name {\n+    ast_from_text(&format!(\"mod {};\", text))\n+}\n+\n pub fn name_ref(text: &str) -> ast::NameRef {\n     ast_from_text(&format!(\"fn f() {{ {}; }}\", text))\n }\n@@ -43,6 +47,21 @@ pub fn expr_unit() -> ast::Expr {\n pub fn expr_unimplemented() -> ast::Expr {\n     expr_from_text(\"unimplemented!()\")\n }\n+pub fn expr_path(path: ast::Path) -> ast::Expr {\n+    expr_from_text(&path.syntax().to_string())\n+}\n+pub fn expr_continue() -> ast::Expr {\n+    expr_from_text(\"continue\")\n+}\n+pub fn expr_break() -> ast::Expr {\n+    expr_from_text(\"break\")\n+}\n+pub fn expr_return() -> ast::Expr {\n+    expr_from_text(\"return\")\n+}\n+pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Expr {\n+    expr_from_text(&format!(\"match {} {}\", expr.syntax(), match_arm_list.syntax()))\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }\n@@ -65,18 +84,18 @@ pub fn placeholder_pat() -> ast::PlaceholderPat {\n \n pub fn tuple_struct_pat(\n     path: ast::Path,\n-    pats: impl Iterator<Item = ast::Pat>,\n+    pats: impl IntoIterator<Item = ast::Pat>,\n ) -> ast::TupleStructPat {\n-    let pats_str = pats.map(|p| p.syntax().to_string()).join(\", \");\n+    let pats_str = pats.into_iter().map(|p| p.syntax().to_string()).join(\", \");\n     return from_text(&format!(\"{}({})\", path.syntax(), pats_str));\n \n     fn from_text(text: &str) -> ast::TupleStructPat {\n         ast_from_text(&format!(\"fn f({}: ())\", text))\n     }\n }\n \n-pub fn record_pat(path: ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::RecordPat {\n-    let pats_str = pats.map(|p| p.syntax().to_string()).join(\", \");\n+pub fn record_pat(path: ast::Path, pats: impl IntoIterator<Item = ast::Pat>) -> ast::RecordPat {\n+    let pats_str = pats.into_iter().map(|p| p.syntax().to_string()).join(\", \");\n     return from_text(&format!(\"{} {{ {} }}\", path.syntax(), pats_str));\n \n     fn from_text(text: &str) -> ast::RecordPat {\n@@ -92,52 +111,38 @@ pub fn path_pat(path: ast::Path) -> ast::PathPat {\n     }\n }\n \n-pub fn match_arm(pats: impl Iterator<Item = ast::Pat>, expr: ast::Expr) -> ast::MatchArm {\n-    let pats_str = pats.map(|p| p.syntax().to_string()).join(\" | \");\n+pub fn match_arm(pats: impl IntoIterator<Item = ast::Pat>, expr: ast::Expr) -> ast::MatchArm {\n+    let pats_str = pats.into_iter().map(|p| p.syntax().to_string()).join(\" | \");\n     return from_text(&format!(\"{} => {}\", pats_str, expr.syntax()));\n \n     fn from_text(text: &str) -> ast::MatchArm {\n         ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n     }\n }\n \n-pub fn match_arm_list(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n-    let arms_str = arms.map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n+pub fn match_arm_list(arms: impl IntoIterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n+    let arms_str = arms.into_iter().map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n     return from_text(&format!(\"{},\\n\", arms_str));\n \n     fn from_text(text: &str) -> ast::MatchArmList {\n         ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n     }\n }\n \n-pub fn let_match_early(expr: ast::Expr, path: &str, early_expression: &str) -> ast::LetStmt {\n-    return from_text(&format!(\n-        r#\"let {} = match {} {{\n-    {}(it) => it,\n-    None => {},\n-}};\"#,\n-        expr.syntax().text(),\n-        expr.syntax().text(),\n-        path,\n-        early_expression\n-    ));\n-\n-    fn from_text(text: &str) -> ast::LetStmt {\n-        ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n-    }\n-}\n-\n-pub fn where_pred(path: ast::Path, bounds: impl Iterator<Item = ast::TypeBound>) -> ast::WherePred {\n-    let bounds = bounds.map(|b| b.syntax().to_string()).join(\" + \");\n+pub fn where_pred(\n+    path: ast::Path,\n+    bounds: impl IntoIterator<Item = ast::TypeBound>,\n+) -> ast::WherePred {\n+    let bounds = bounds.into_iter().map(|b| b.syntax().to_string()).join(\" + \");\n     return from_text(&format!(\"{}: {}\", path.syntax(), bounds));\n \n     fn from_text(text: &str) -> ast::WherePred {\n         ast_from_text(&format!(\"fn f() where {} {{ }}\", text))\n     }\n }\n \n-pub fn where_clause(preds: impl Iterator<Item = ast::WherePred>) -> ast::WhereClause {\n-    let preds = preds.map(|p| p.syntax().to_string()).join(\", \");\n+pub fn where_clause(preds: impl IntoIterator<Item = ast::WherePred>) -> ast::WhereClause {\n+    let preds = preds.into_iter().map(|p| p.syntax().to_string()).join(\", \");\n     return from_text(preds.as_str());\n \n     fn from_text(text: &str) -> ast::WhereClause {\n@@ -153,6 +158,14 @@ pub fn if_expression(condition: &ast::Expr, statement: &str) -> ast::IfExpr {\n     ))\n }\n \n+pub fn let_stmt(pattern: ast::Pat, initializer: Option<ast::Expr>) -> ast::LetStmt {\n+    let text = match initializer {\n+        Some(it) => format!(\"let {} = {};\", pattern.syntax(), it.syntax()),\n+        None => format!(\"let {};\", pattern.syntax()),\n+    };\n+    ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n+}\n+\n fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     let res = parse.tree().syntax().descendants().find_map(N::cast).unwrap();"}, {"sha": "77b9ae2b467ec22461de160665d33778b9088604", "filename": "xtask/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2FCargo.toml?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -12,3 +12,4 @@ quote = \"1.0.2\"\n proc-macro2 = \"1.0.1\"\n ron = \"0.5.1\"\n serde = { version = \"1.0.0\", features = [\"derive\"] }\n+anyhow = \"1.0.19\""}, {"sha": "44507fb74873e15ef28941ef0acc0831c6233196", "filename": "xtask/src/bin/pre-commit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2Fsrc%2Fbin%2Fpre-commit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2Fsrc%2Fbin%2Fpre-commit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fbin%2Fpre-commit.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -19,10 +19,10 @@ fn update_staged() -> Result<()> {\n         .current_dir(&root)\n         .output()?;\n     if !output.status.success() {\n-        Err(format!(\n+        anyhow::bail!(\n             \"`git diff --diff-filter=MAR --name-only --cached` exited with {}\",\n             output.status\n-        ))?;\n+        );\n     }\n     for line in String::from_utf8(output.stdout)?.lines() {\n         run(&format!(\"git update-index --add {}\", root.join(line).to_string_lossy()), \".\")?;"}, {"sha": "53f524f42dfe7aaaacd236d1f7f4f31be355cea5", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -52,7 +52,7 @@ fn update(path: &Path, contents: &str, mode: Mode) -> Result<()> {\n         _ => (),\n     }\n     if mode == Mode::Verify {\n-        Err(format!(\"`{}` is not up-to-date\", path.display()))?;\n+        anyhow::bail!(\"`{}` is not up-to-date\", path.display());\n     }\n     eprintln!(\"updating {}\", path.display());\n     fs::write(path, contents)?;\n@@ -101,10 +101,8 @@ fn do_extract_comment_blocks(text: &str, allow_blocks_with_empty_lins: bool) ->\n         let is_comment = line.starts_with(prefix);\n         if is_comment {\n             block.push(line[prefix.len()..].to_string());\n-        } else {\n-            if !block.is_empty() {\n-                res.push(mem::replace(&mut block, Vec::new()))\n-            }\n+        } else if !block.is_empty() {\n+            res.push(mem::replace(&mut block, Vec::new()));\n         }\n     }\n     if !block.is_empty() {"}, {"sha": "2977da2fae2f9689a4ad618a9435ddbad86b6999", "filename": "xtask/src/codegen/gen_parser_tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2Fsrc%2Fcodegen%2Fgen_parser_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2Fsrc%2Fcodegen%2Fgen_parser_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_parser_tests.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -102,10 +102,10 @@ fn tests_from_dir(dir: &Path) -> Result<Tests> {\n         for test in collect_tests(&text) {\n             if test.ok {\n                 if let Some(old_test) = res.ok.insert(test.name.clone(), test) {\n-                    return Err(format!(\"Duplicate test: {}\", old_test.name).into());\n+                    anyhow::bail!(\"Duplicate test: {}\", old_test.name);\n                 }\n             } else if let Some(old_test) = res.err.insert(test.name.clone(), test) {\n-                return Err(format!(\"Duplicate test: {}\", old_test.name).into());\n+                anyhow::bail!(\"Duplicate test: {}\", old_test.name);\n             }\n         }\n         Ok(())"}, {"sha": "bfee2f9c8e78e6542a4fe9c6f6bb3e50a515298f", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -2,19 +2,17 @@\n \n pub mod codegen;\n \n+use anyhow::Context;\n+pub use anyhow::Result;\n use std::{\n-    env,\n-    error::Error,\n-    fs,\n+    env, fs,\n     io::{Error as IoError, ErrorKind},\n     path::{Path, PathBuf},\n     process::{Command, Output, Stdio},\n };\n \n use crate::codegen::Mode;\n \n-pub type Result<T> = std::result::Result<T, Box<dyn Error>>;\n-\n const TOOLCHAIN: &str = \"stable\";\n \n pub fn project_root() -> PathBuf {\n@@ -69,7 +67,7 @@ pub fn run_rustfmt(mode: Mode) -> Result<()> {\n         .status()\n     {\n         Ok(status) if status.success() => (),\n-        _ => install_rustfmt()?,\n+        _ => install_rustfmt().context(\"install rustfmt\")?,\n     };\n \n     if mode == Mode::Verify {\n@@ -112,7 +110,7 @@ pub fn run_clippy() -> Result<()> {\n         .status()\n     {\n         Ok(status) if status.success() => (),\n-        _ => install_clippy()?,\n+        _ => install_clippy().context(\"install clippy\")?,\n     };\n \n     let allowed_lints = [\n@@ -162,9 +160,9 @@ where\n     let exec = args.next().unwrap();\n     let mut cmd = Command::new(exec);\n     f(cmd.args(args).current_dir(proj_dir).stderr(Stdio::inherit()));\n-    let output = cmd.output()?;\n+    let output = cmd.output().with_context(|| format!(\"running `{}`\", cmdline))?;\n     if !output.status.success() {\n-        Err(format!(\"`{}` exited with {}\", cmdline, output.status))?;\n+        anyhow::bail!(\"`{}` exited with {}\", cmdline, output.status);\n     }\n     Ok(output)\n }"}, {"sha": "f14e6c8ae7e3309365b5892501806018990c9219", "filename": "xtask/src/main.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622413bc72ea56d5f62a16788d897cb61eca948/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=c622413bc72ea56d5f62a16788d897cb61eca948", "patch": "@@ -9,6 +9,7 @@\n //! `.cargo/config`.\n mod help;\n \n+use anyhow::Context;\n use core::fmt::Write;\n use core::str;\n use pico_args::Arguments;\n@@ -19,7 +20,7 @@ use xtask::{\n };\n \n // Latest stable, feel free to send a PR if this lags behind.\n-const REQUIRED_RUST_VERSION: u32 = 38;\n+const REQUIRED_RUST_VERSION: u32 = 39;\n \n struct InstallOpt {\n     client: Option<ClientOpt>,\n@@ -113,21 +114,21 @@ fn handle_extra_flags(e: pico_args::Error) -> Result<()> {\n             write!(&mut invalid_flags, \"{}, \", flag)?;\n         }\n         let (invalid_flags, _) = invalid_flags.split_at(invalid_flags.len() - 2);\n-        Err(format!(\"Invalid flags: {}\", invalid_flags).into())\n+        anyhow::bail!(\"Invalid flags: {}\", invalid_flags)\n     } else {\n-        Err(e.to_string().into())\n+        anyhow::bail!(e.to_string())\n     }\n }\n \n fn install(opts: InstallOpt) -> Result<()> {\n     if cfg!(target_os = \"macos\") {\n-        fix_path_for_mac()?\n+        fix_path_for_mac().context(\"Fix path for mac\")?\n     }\n     if let Some(server) = opts.server {\n-        install_server(server)?;\n+        install_server(server).context(\"install server\")?;\n     }\n     if let Some(client) = opts.client {\n-        install_client(client)?;\n+        install_client(client).context(\"install client\")?;\n     }\n     Ok(())\n }\n@@ -139,7 +140,7 @@ fn fix_path_for_mac() -> Result<()> {\n         const ROOT_DIR: &str = \"\";\n         let home_dir = match env::var(\"HOME\") {\n             Ok(home) => home,\n-            Err(e) => Err(format!(\"Failed getting HOME from environment with error: {}.\", e))?,\n+            Err(e) => anyhow::bail!(\"Failed getting HOME from environment with error: {}.\", e),\n         };\n \n         [ROOT_DIR, &home_dir]\n@@ -153,12 +154,12 @@ fn fix_path_for_mac() -> Result<()> {\n     if !vscode_path.is_empty() {\n         let vars = match env::var_os(\"PATH\") {\n             Some(path) => path,\n-            None => Err(\"Could not get PATH variable from env.\")?,\n+            None => anyhow::bail!(\"Could not get PATH variable from env.\"),\n         };\n \n         let mut paths = env::split_paths(&vars).collect::<Vec<_>>();\n         paths.append(&mut vscode_path);\n-        let new_paths = env::join_paths(paths)?;\n+        let new_paths = env::join_paths(paths).context(\"build env PATH\")?;\n         env::set_var(\"PATH\", &new_paths);\n     }\n \n@@ -197,7 +198,7 @@ fn install_client(ClientOpt::VsCode: ClientOpt) -> Result<()> {\n \n     let code_binary = match code_binary {\n         Some(it) => it,\n-        None => Err(\"Can't execute `code --version`. Perhaps it is not in $PATH?\")?,\n+        None => anyhow::bail!(\"Can't execute `code --version`. Perhaps it is not in $PATH?\"),\n     };\n \n     Cmd {\n@@ -218,8 +219,10 @@ fn install_client(ClientOpt::VsCode: ClientOpt) -> Result<()> {\n     .run_with_output()?;\n \n     if !str::from_utf8(&output.stdout)?.contains(\"ra-lsp\") {\n-        Err(\"Could not install the Visual Studio Code extension. \\\n-             Please make sure you have at least NodeJS 10.x installed and try again.\")?;\n+        anyhow::bail!(\n+            \"Could not install the Visual Studio Code extension. \\\n+             Please make sure you have at least NodeJS 10.x installed and try again.\"\n+        );\n     }\n \n     Ok(())\n@@ -239,7 +242,7 @@ fn install_server(opts: ServerOpt) -> Result<()> {\n     if old_rust {\n         eprintln!(\n             \"\\nWARNING: at least rust 1.{}.0 is required to compile rust-analyzer\\n\",\n-            REQUIRED_RUST_VERSION\n+            REQUIRED_RUST_VERSION,\n         )\n     }\n \n@@ -252,7 +255,7 @@ fn install_server(opts: ServerOpt) -> Result<()> {\n     if res.is_err() && old_rust {\n         eprintln!(\n             \"\\nWARNING: at least rust 1.{}.0 is required to compile rust-analyzer\\n\",\n-            REQUIRED_RUST_VERSION\n+            REQUIRED_RUST_VERSION,\n         )\n     }\n "}]}