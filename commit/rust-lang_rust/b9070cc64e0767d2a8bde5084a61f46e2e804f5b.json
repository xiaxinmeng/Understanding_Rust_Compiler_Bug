{"sha": "b9070cc64e0767d2a8bde5084a61f46e2e804f5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MDcwY2M2NGUwNzY3ZDJhOGJkZTUwODRhNjFmNDZlMmU4MDRmNWI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-14T14:43:39Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-14T14:44:20Z"}, "message": "Refactor the test of diagnostic tests", "tree": {"sha": "11eff9785ddae6ac25b9b74543fb36180bd20d82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11eff9785ddae6ac25b9b74543fb36180bd20d82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9070cc64e0767d2a8bde5084a61f46e2e804f5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9070cc64e0767d2a8bde5084a61f46e2e804f5b", "html_url": "https://github.com/rust-lang/rust/commit/b9070cc64e0767d2a8bde5084a61f46e2e804f5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a25cc28204c6d02a5108b13568ec71914f096a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a25cc28204c6d02a5108b13568ec71914f096a5", "html_url": "https://github.com/rust-lang/rust/commit/5a25cc28204c6d02a5108b13568ec71914f096a5"}], "stats": {"total": 752, "additions": 278, "deletions": 474}, "files": [{"sha": "d3ee9cf55609c9168f91101cb25b4bc5a5f7d82b", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 224, "deletions": 16, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=b9070cc64e0767d2a8bde5084a61f46e2e804f5b", "patch": "@@ -246,25 +246,233 @@ impl AstDiagnostic for MismatchedArgCount {\n }\n \n #[cfg(test)]\n-fn check_diagnostics(ra_fixture: &str) {\n-    use ra_db::{fixture::WithFixture, FileId};\n-    use ra_syntax::TextRange;\n+mod tests {\n+    use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId};\n+    use hir_expand::diagnostics::{Diagnostic, DiagnosticSink};\n+    use ra_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n+    use ra_syntax::{TextRange, TextSize};\n     use rustc_hash::FxHashMap;\n \n-    use crate::test_db::TestDB;\n+    use crate::{diagnostics::validate_body, test_db::TestDB};\n+\n+    impl TestDB {\n+        fn diagnostics<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n+            let crate_graph = self.crate_graph();\n+            for krate in crate_graph.iter() {\n+                let crate_def_map = self.crate_def_map(krate);\n+\n+                let mut fns = Vec::new();\n+                for (module_id, _) in crate_def_map.modules.iter() {\n+                    for decl in crate_def_map[module_id].scope.declarations() {\n+                        if let ModuleDefId::FunctionId(f) = decl {\n+                            fns.push(f)\n+                        }\n+                    }\n+\n+                    for impl_id in crate_def_map[module_id].scope.impls() {\n+                        let impl_data = self.impl_data(impl_id);\n+                        for item in impl_data.items.iter() {\n+                            if let AssocItemId::FunctionId(f) = item {\n+                                fns.push(*f)\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                for f in fns {\n+                    let mut sink = DiagnosticSink::new(&mut cb);\n+                    validate_body(self, f.into(), &mut sink);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn check_diagnostics(ra_fixture: &str) {\n+        let db = TestDB::with_files(ra_fixture);\n+        let annotations = db.extract_annotations();\n+\n+        let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n+        db.diagnostics(|d| {\n+            // FXIME: macros...\n+            let file_id = d.source().file_id.original_file(&db);\n+            let range = d.syntax_node(&db).text_range();\n+            let message = d.message().to_owned();\n+            actual.entry(file_id).or_default().push((range, message));\n+        });\n+\n+        for (file_id, diags) in actual.iter_mut() {\n+            diags.sort_by_key(|it| it.0.start());\n+            let text = db.file_text(*file_id);\n+            // For multiline spans, place them on line start\n+            for (range, content) in diags {\n+                if text[*range].contains('\\n') {\n+                    *range = TextRange::new(range.start(), range.start() + TextSize::from(1));\n+                    *content = format!(\"... {}\", content);\n+                }\n+            }\n+        }\n+\n+        assert_eq!(annotations, actual);\n+    }\n+\n+    #[test]\n+    fn no_such_field_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+struct S { foo: i32, bar: () }\n+impl S {\n+    fn new() -> S {\n+        S {\n+        //^... Missing structure fields:\n+        //|    - bar\n+            foo: 92,\n+            baz: 62,\n+          //^^^^^^^ no such field\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct MyStruct {\n+    my_val: usize,\n+    #[cfg(feature = \"foo\")]\n+    bar: bool,\n+}\n+\n+impl MyStruct {\n+    #[cfg(feature = \"foo\")]\n+    pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n+        Self { my_val, bar }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n+        Self { my_val }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_enum_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+enum Foo {\n+    #[cfg(not(feature = \"foo\"))]\n+    Buz,\n+    #[cfg(feature = \"foo\")]\n+    Bar,\n+    Baz\n+}\n+\n+fn test_fn(f: Foo) {\n+    match f {\n+        Foo::Bar => {},\n+        Foo::Baz => {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct S {\n+    #[cfg(feature = \"foo\")]\n+    foo: u32,\n+    #[cfg(not(feature = \"foo\"))]\n+    bar: u32,\n+}\n+\n+impl S {\n+    #[cfg(feature = \"foo\")]\n+    fn new(foo: u32) -> Self {\n+        Self { foo }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    fn new(bar: u32) -> Self {\n+        Self { bar }\n+    }\n+    fn new2(bar: u32) -> Self {\n+        #[cfg(feature = \"foo\")]\n+        { Self { foo: bar } }\n+        #[cfg(not(feature = \"foo\"))]\n+        { Self { bar } }\n+    }\n+    fn new2(val: u32) -> Self {\n+        Self {\n+            #[cfg(feature = \"foo\")]\n+            foo: val,\n+            #[cfg(not(feature = \"foo\"))]\n+            bar: val,\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n \n-    let db = TestDB::with_files(ra_fixture);\n-    let annotations = db.extract_annotations();\n+    #[test]\n+    fn no_such_field_with_type_macro() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! Type { () => { u32 }; }\n+struct Foo { bar: Type![] }\n \n-    let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n-    db.diag(|d| {\n-        // FXIME: macros...\n-        let file_id = d.source().file_id.original_file(&db);\n-        let range = d.syntax_node(&db).text_range();\n-        let message = d.message().to_owned();\n-        actual.entry(file_id).or_default().push((range, message));\n-    });\n-    actual.values_mut().for_each(|diags| diags.sort_by_key(|it| it.0.start()));\n+impl Foo {\n+    fn new() -> Self {\n+        Foo { bar: 0 }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn missing_record_pat_field_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+struct S { foo: i32, bar: () }\n+fn baz(s: S) {\n+    let S { foo: _ } = s;\n+        //^^^^^^^^^^ Missing structure fields:\n+        //         | - bar\n+}\n+\"#,\n+        );\n+    }\n \n-    assert_eq!(annotations, actual);\n+    #[test]\n+    fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n+        check_diagnostics(\n+            r\"\n+struct S { foo: i32, bar: () }\n+fn baz(s: S) -> i32 {\n+    match s {\n+        S { foo, .. } => foo,\n+    }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn break_outside_of_loop() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() { break; }\n+         //^^^^^ break outside of loop\n+\"#,\n+        );\n+    }\n }"}, {"sha": "91caedc3df52c6cece4a626af89a1736f2a22618", "filename": "crates/ra_hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=b9070cc64e0767d2a8bde5084a61f46e2e804f5b", "patch": "@@ -376,7 +376,7 @@ pub fn record_pattern_missing_fields(\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::check_diagnostics;\n+    use crate::diagnostics::tests::check_diagnostics;\n \n     #[test]\n     fn simple_free_fn_zero() {"}, {"sha": "507edcb7def8ca3cb8fcc629fb0ba0b260bbb895", "filename": "crates/ra_hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=b9070cc64e0767d2a8bde5084a61f46e2e804f5b", "patch": "@@ -837,7 +837,7 @@ fn enum_variant_matches(cx: &MatchCheckCtx, pat_id: PatId, enum_variant_id: Enum\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::check_diagnostics;\n+    use crate::diagnostics::tests::check_diagnostics;\n \n     #[test]\n     fn empty_tuple() {"}, {"sha": "9e4ed9a8b7f48161aef29dd9981442b71f8c288a", "filename": "crates/ra_hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=b9070cc64e0767d2a8bde5084a61f46e2e804f5b", "patch": "@@ -121,3 +121,53 @@ fn walk_unsafe(\n         walk_unsafe(unsafe_exprs, db, infer, body, child, inside_unsafe_block);\n     });\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_raw_ptr() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x = &5 as *const usize;\n+    unsafe { let y = *x; }\n+    let z = *x;\n+}         //^^ This operation is unsafe and requires an unsafe function or block\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_unsafe_call() {\n+        check_diagnostics(\n+            r#\"\n+struct HasUnsafe;\n+\n+impl HasUnsafe {\n+    unsafe fn unsafe_fn(&self) {\n+        let x = &5 as *const usize;\n+        let y = *x;\n+    }\n+}\n+\n+unsafe fn unsafe_fn() {\n+    let x = &5 as *const usize;\n+    let y = *x;\n+}\n+\n+fn main() {\n+    unsafe_fn();\n+  //^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n+    HasUnsafe.unsafe_fn();\n+  //^^^^^^^^^^^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n+    unsafe {\n+        unsafe_fn();\n+        HasUnsafe.unsafe_fn();\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "a1714ff0fcd7da04b0dc852d47a5cb39f85c7b70", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 2, "deletions": 48, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=b9070cc64e0767d2a8bde5084a61f46e2e804f5b", "patch": "@@ -5,19 +5,13 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n-use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId, ModuleId};\n-use hir_expand::{\n-    db::AstDatabase,\n-    diagnostics::{Diagnostic, DiagnosticSink},\n-};\n+use hir_def::{db::DefDatabase, ModuleId};\n+use hir_expand::db::AstDatabase;\n use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase, Upcast};\n use ra_syntax::TextRange;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use stdx::format_to;\n use test_utils::extract_annotations;\n \n-use crate::diagnostics::validate_body;\n-\n #[salsa::database(\n     ra_db::SourceDatabaseExtStorage,\n     ra_db::SourceDatabaseStorage,\n@@ -94,46 +88,6 @@ impl TestDB {\n         panic!(\"Can't find module for file\")\n     }\n \n-    pub(crate) fn diag<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n-        let crate_graph = self.crate_graph();\n-        for krate in crate_graph.iter() {\n-            let crate_def_map = self.crate_def_map(krate);\n-\n-            let mut fns = Vec::new();\n-            for (module_id, _) in crate_def_map.modules.iter() {\n-                for decl in crate_def_map[module_id].scope.declarations() {\n-                    if let ModuleDefId::FunctionId(f) = decl {\n-                        fns.push(f)\n-                    }\n-                }\n-\n-                for impl_id in crate_def_map[module_id].scope.impls() {\n-                    let impl_data = self.impl_data(impl_id);\n-                    for item in impl_data.items.iter() {\n-                        if let AssocItemId::FunctionId(f) = item {\n-                            fns.push(*f)\n-                        }\n-                    }\n-                }\n-            }\n-\n-            for f in fns {\n-                let mut sink = DiagnosticSink::new(&mut cb);\n-                validate_body(self, f.into(), &mut sink);\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn diagnostics(&self) -> (String, u32) {\n-        let mut buf = String::new();\n-        let mut count = 0;\n-        self.diag(|d| {\n-            format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n-            count += 1;\n-        });\n-        (buf, count)\n-    }\n-\n     pub(crate) fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {\n         let mut files = Vec::new();\n         let crate_graph = self.crate_graph();"}, {"sha": "d57b3f288588266cd4dddaeb37821623a1af3067", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 0, "deletions": 408, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9070cc64e0767d2a8bde5084a61f46e2e804f5b/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=b9070cc64e0767d2a8bde5084a61f46e2e804f5b", "patch": "@@ -20,7 +20,6 @@ use hir_def::{\n     AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n };\n use hir_expand::{db::AstDatabase, InFile};\n-use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, FileRange, SourceDatabase, SourceDatabaseExt};\n use ra_syntax::{\n     algo,\n@@ -341,410 +340,3 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }\n }\n-\n-#[test]\n-fn no_such_field_diagnostics() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-        //- /lib.rs\n-        struct S { foo: i32, bar: () }\n-        impl S {\n-            fn new() -> S {\n-                S {\n-                    foo: 92,\n-                    baz: 62,\n-                }\n-            }\n-        }\n-        \",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\n-    \"baz: 62\": no such field\n-    \"{\\n            foo: 92,\\n            baz: 62,\\n        }\": Missing structure fields:\n-    - bar\n-    \"###\n-    );\n-}\n-\n-#[test]\n-fn no_such_field_with_feature_flag_diagnostics() {\n-    let diagnostics = TestDB::with_files(\n-        r#\"\n-        //- /lib.rs crate:foo cfg:feature=foo\n-        struct MyStruct {\n-            my_val: usize,\n-            #[cfg(feature = \"foo\")]\n-            bar: bool,\n-        }\n-\n-        impl MyStruct {\n-            #[cfg(feature = \"foo\")]\n-            pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n-                Self { my_val, bar }\n-            }\n-\n-            #[cfg(not(feature = \"foo\"))]\n-            pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n-                Self { my_val }\n-            }\n-        }\n-        \"#,\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn no_such_field_enum_with_feature_flag_diagnostics() {\n-    let diagnostics = TestDB::with_files(\n-        r#\"\n-        //- /lib.rs crate:foo cfg:feature=foo\n-        enum Foo {\n-            #[cfg(not(feature = \"foo\"))]\n-            Buz,\n-            #[cfg(feature = \"foo\")]\n-            Bar,\n-            Baz\n-        }\n-\n-        fn test_fn(f: Foo) {\n-            match f {\n-                Foo::Bar => {},\n-                Foo::Baz => {},\n-            }\n-        }\n-        \"#,\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n-    let diagnostics = TestDB::with_files(\n-        r#\"\n-        //- /lib.rs crate:foo cfg:feature=foo\n-        struct S {\n-            #[cfg(feature = \"foo\")]\n-            foo: u32,\n-            #[cfg(not(feature = \"foo\"))]\n-            bar: u32,\n-        }\n-\n-        impl S {\n-            #[cfg(feature = \"foo\")]\n-            fn new(foo: u32) -> Self {\n-                Self { foo }\n-            }\n-            #[cfg(not(feature = \"foo\"))]\n-            fn new(bar: u32) -> Self {\n-                Self { bar }\n-            }\n-        }\n-        \"#,\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn no_such_field_with_feature_flag_diagnostics_on_block_expr() {\n-    let diagnostics = TestDB::with_files(\n-        r#\"\n-        //- /lib.rs crate:foo cfg:feature=foo\n-        struct S {\n-            #[cfg(feature = \"foo\")]\n-            foo: u32,\n-            #[cfg(not(feature = \"foo\"))]\n-            bar: u32,\n-        }\n-\n-        impl S {\n-            fn new(bar: u32) -> Self {\n-                #[cfg(feature = \"foo\")]\n-                {\n-                Self { foo: bar }\n-                }\n-                #[cfg(not(feature = \"foo\"))]\n-                {\n-                Self { bar }\n-                }\n-            }\n-        }\n-        \"#,\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn no_such_field_with_feature_flag_diagnostics_on_struct_fields() {\n-    let diagnostics = TestDB::with_files(\n-        r#\"\n-        //- /lib.rs crate:foo cfg:feature=foo\n-        struct S {\n-            #[cfg(feature = \"foo\")]\n-            foo: u32,\n-            #[cfg(not(feature = \"foo\"))]\n-            bar: u32,\n-        }\n-\n-        impl S {\n-            fn new(val: u32) -> Self {\n-                Self {\n-                    #[cfg(feature = \"foo\")]\n-                    foo: val,\n-                    #[cfg(not(feature = \"foo\"))]\n-                    bar: val,\n-                }\n-            }\n-        }\n-        \"#,\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn no_such_field_with_type_macro() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-        macro_rules! Type {\n-            () => { u32 };\n-        }\n-\n-        struct Foo {\n-            bar: Type![],\n-        }\n-        impl Foo {\n-            fn new() -> Self {\n-                Foo { bar: 0 }\n-            }\n-        }\n-        \",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn missing_record_pat_field_diagnostic() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-        //- /lib.rs\n-        struct S { foo: i32, bar: () }\n-        fn baz(s: S) {\n-            let S { foo: _ } = s;\n-        }\n-        \",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\n-    \"{ foo: _ }\": Missing structure fields:\n-    - bar\n-    \"###\n-    );\n-}\n-\n-#[test]\n-fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-        //- /lib.rs\n-        struct S { foo: i32, bar: () }\n-        fn baz(s: S) -> i32 {\n-            match s {\n-                S { foo, .. } => foo,\n-            }\n-        }\n-        \",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @\"\");\n-}\n-\n-#[test]\n-fn missing_unsafe_diagnostic_with_raw_ptr() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-//- /lib.rs\n-fn missing_unsafe() {\n-    let x = &5 as *const usize;\n-    let y = *x;\n-}\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r#\"\"*x\": This operation is unsafe and requires an unsafe function or block\"#);\n-}\n-\n-#[test]\n-fn missing_unsafe_diagnostic_with_unsafe_call() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-//- /lib.rs\n-unsafe fn unsafe_fn() {\n-    let x = &5 as *const usize;\n-    let y = *x;\n-}\n-\n-fn missing_unsafe() {\n-    unsafe_fn();\n-}\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r#\"\"unsafe_fn()\": This operation is unsafe and requires an unsafe function or block\"#);\n-}\n-\n-#[test]\n-fn missing_unsafe_diagnostic_with_unsafe_method_call() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-struct HasUnsafe;\n-\n-impl HasUnsafe {\n-    unsafe fn unsafe_fn(&self) {\n-        let x = &5 as *const usize;\n-        let y = *x;\n-    }\n-}\n-\n-fn missing_unsafe() {\n-    HasUnsafe.unsafe_fn();\n-}\n-\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r#\"\"HasUnsafe.unsafe_fn()\": This operation is unsafe and requires an unsafe function or block\"#);\n-}\n-\n-#[test]\n-fn no_missing_unsafe_diagnostic_with_raw_ptr_in_unsafe_block() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-fn nothing_to_see_move_along() {\n-    let x = &5 as *const usize;\n-    unsafe {\n-        let y = *x;\n-    }\n-}\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @\"\");\n-}\n-\n-#[test]\n-fn missing_unsafe_diagnostic_with_raw_ptr_outside_unsafe_block() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-fn nothing_to_see_move_along() {\n-    let x = &5 as *const usize;\n-    unsafe {\n-        let y = *x;\n-    }\n-    let z = *x;\n-}\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r#\"\"*x\": This operation is unsafe and requires an unsafe function or block\"#);\n-}\n-\n-#[test]\n-fn no_missing_unsafe_diagnostic_with_unsafe_call_in_unsafe_block() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-unsafe fn unsafe_fn() {\n-    let x = &5 as *const usize;\n-    let y = *x;\n-}\n-\n-fn nothing_to_see_move_along() {\n-    unsafe {\n-        unsafe_fn();\n-    }\n-}\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @\"\");\n-}\n-\n-#[test]\n-fn no_missing_unsafe_diagnostic_with_unsafe_method_call_in_unsafe_block() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-struct HasUnsafe;\n-\n-impl HasUnsafe {\n-    unsafe fn unsafe_fn() {\n-        let x = &5 as *const usize;\n-        let y = *x;\n-    }\n-}\n-\n-fn nothing_to_see_move_along() {\n-    unsafe {\n-        HasUnsafe.unsafe_fn();\n-    }\n-}\n-\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @\"\");\n-}\n-\n-#[test]\n-fn break_outside_of_loop() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-        //- /lib.rs\n-        fn foo() {\n-            break;\n-        }\n-        \",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"break\": break outside of loop\n-    \"###\n-    );\n-}"}]}