{"sha": "f65638e669256f37ddaf4ada6617b57cc6dee0da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2NTYzOGU2NjkyNTZmMzdkZGFmNGFkYTY2MTdiNTdjYzZkZWUwZGE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-27T17:28:38Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-28T16:28:04Z"}, "message": "De-@ IdentInterner.", "tree": {"sha": "6797b5bfd7c386022e0161881df213dbf62e21a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6797b5bfd7c386022e0161881df213dbf62e21a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f65638e669256f37ddaf4ada6617b57cc6dee0da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f65638e669256f37ddaf4ada6617b57cc6dee0da", "html_url": "https://github.com/rust-lang/rust/commit/f65638e669256f37ddaf4ada6617b57cc6dee0da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f65638e669256f37ddaf4ada6617b57cc6dee0da/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83c4e25d93ab936567df8fa5c338b5d05c1245ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/83c4e25d93ab936567df8fa5c338b5d05c1245ec", "html_url": "https://github.com/rust-lang/rust/commit/83c4e25d93ab936567df8fa5c338b5d05c1245ec"}], "stats": {"total": 101, "additions": 53, "deletions": 48}, "files": [{"sha": "101784a7e73d6f8ff36964dca0ddf0cac3451160", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=f65638e669256f37ddaf4ada6617b57cc6dee0da", "patch": "@@ -23,6 +23,7 @@ use metadata::loader;\n use metadata::loader::Os;\n \n use std::cell::RefCell;\n+use std::rc::Rc;\n use collections::HashMap;\n use syntax::ast;\n use syntax::abi;\n@@ -41,7 +42,7 @@ use syntax::visit;\n pub fn read_crates(sess: &Session,\n                    krate: &ast::Crate,\n                    os: loader::Os,\n-                   intr: @IdentInterner) {\n+                   intr: Rc<IdentInterner>) {\n     let mut e = Env {\n         sess: sess,\n         os: os,\n@@ -114,7 +115,7 @@ struct Env<'a> {\n     os: loader::Os,\n     crate_cache: @RefCell<Vec<cache_entry>>,\n     next_crate_num: ast::CrateNum,\n-    intr: @IdentInterner\n+    intr: Rc<IdentInterner>\n }\n \n fn visit_crate(e: &Env, c: &ast::Crate) {\n@@ -295,7 +296,7 @@ fn resolve_crate(e: &mut Env,\n                 id_hash: id_hash,\n                 hash: hash.map(|a| &*a),\n                 os: e.os,\n-                intr: e.intr,\n+                intr: e.intr.clone(),\n                 rejected_via_hash: false,\n             };\n             let loader::Library {"}, {"sha": "c65659a8aa45981e5e4d567e8d1282df73579239", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=f65638e669256f37ddaf4ada6617b57cc6dee0da", "patch": "@@ -63,7 +63,7 @@ pub fn each_child_of_item(cstore: &cstore::CStore,\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore.get_crate_data(cnum)\n     };\n-    decoder::each_child_of_item(cstore.intr,\n+    decoder::each_child_of_item(cstore.intr.clone(),\n                                 crate_data,\n                                 def_id.node,\n                                 get_crate_data,\n@@ -80,7 +80,7 @@ pub fn each_top_level_item_of_crate(cstore: &cstore::CStore,\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore.get_crate_data(cnum)\n     };\n-    decoder::each_top_level_item_of_crate(cstore.intr,\n+    decoder::each_top_level_item_of_crate(cstore.intr.clone(),\n                                           crate_data,\n                                           get_crate_data,\n                                           callback)\n@@ -118,27 +118,27 @@ pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n                       -> Vec<@ty::VariantInfo> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n+    return decoder::get_enum_variants(cstore.intr.clone(), cdata, def.node, tcx)\n }\n \n /// Returns information about the given implementation.\n pub fn get_impl(tcx: &ty::ctxt, impl_def_id: ast::DefId)\n                 -> ty::Impl {\n     let cdata = tcx.sess.cstore.get_crate_data(impl_def_id.krate);\n-    decoder::get_impl(tcx.sess.cstore.intr, cdata, impl_def_id.node, tcx)\n+    decoder::get_impl(tcx.sess.cstore.intr.clone(), cdata, impl_def_id.node, tcx)\n }\n \n pub fn get_method(tcx: &ty::ctxt, def: ast::DefId) -> ty::Method {\n     let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n-    decoder::get_method(tcx.sess.cstore.intr, cdata, def.node, tcx)\n+    decoder::get_method(tcx.sess.cstore.intr.clone(), cdata, def.node, tcx)\n }\n \n pub fn get_method_name_and_explicit_self(cstore: &cstore::CStore,\n                                          def: ast::DefId)\n                                      -> (ast::Ident, ast::ExplicitSelf_)\n {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_method_name_and_explicit_self(cstore.intr, cdata, def.node)\n+    decoder::get_method_name_and_explicit_self(cstore.intr.clone(), cdata, def.node)\n }\n \n pub fn get_trait_method_def_ids(cstore: &cstore::CStore,\n@@ -158,7 +158,7 @@ pub fn get_provided_trait_methods(tcx: &ty::ctxt,\n                                -> Vec<@ty::Method> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n+    decoder::get_provided_trait_methods(cstore.intr.clone(), cdata, def.node, tcx)\n }\n \n pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<@ty::TraitRef> {\n@@ -177,7 +177,7 @@ pub fn get_static_methods_if_impl(cstore: &cstore::CStore,\n                                   def: ast::DefId)\n                                -> Option<Vec<StaticMethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_static_methods_if_impl(cstore.intr, cdata, def.node)\n+    decoder::get_static_methods_if_impl(cstore.intr.clone(), cdata, def.node)\n }\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n@@ -191,7 +191,7 @@ pub fn get_struct_fields(cstore: &cstore::CStore,\n                          def: ast::DefId)\n                       -> Vec<ty::field_ty> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_struct_fields(cstore.intr, cdata, def.node)\n+    decoder::get_struct_fields(cstore.intr.clone(), cdata, def.node)\n }\n \n pub fn get_type(tcx: &ty::ctxt,\n@@ -251,7 +251,7 @@ pub fn get_impl_method(cstore: &cstore::CStore,\n                        mname: ast::Ident)\n                     -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n+    decoder::get_impl_method(cstore.intr.clone(), cdata, def.node, mname)\n }\n \n pub fn get_item_visibility(cstore: &cstore::CStore,"}, {"sha": "6d58cd57dd462f62dbf53e439432b9d31f5a9a65", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=f65638e669256f37ddaf4ada6617b57cc6dee0da", "patch": "@@ -19,6 +19,7 @@ use metadata::loader;\n \n use std::cell::RefCell;\n use std::c_vec::CVec;\n+use std::rc::Rc;\n use collections::HashMap;\n use syntax::ast;\n use syntax::parse::token::IdentInterner;\n@@ -70,14 +71,14 @@ pub struct CStore {\n     priv used_crate_sources: RefCell<Vec<CrateSource> >,\n     priv used_libraries: RefCell<Vec<(~str, NativeLibaryKind)> >,\n     priv used_link_args: RefCell<Vec<~str> >,\n-    intr: @IdentInterner\n+    intr: Rc<IdentInterner>\n }\n \n // Map from NodeId's of local extern crate statements to crate numbers\n type extern_mod_crate_map = HashMap<ast::NodeId, ast::CrateNum>;\n \n impl CStore {\n-    pub fn new(intr: @IdentInterner) -> CStore {\n+    pub fn new(intr: Rc<IdentInterner>) -> CStore {\n         CStore {\n             metas: RefCell::new(HashMap::new()),\n             extern_mod_crate_map: RefCell::new(HashMap::new()),"}, {"sha": "7439ae020df17c3beecc10f0086d33ca27761b26", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f65638e669256f37ddaf4ada6617b57cc6dee0da", "patch": "@@ -278,7 +278,7 @@ fn item_region_param_defs(item_doc: ebml::Doc, cdata: Cmd)\n     reader::tagged_docs(item_doc, tag_region_param_def, |rp_doc| {\n             let ident_str_doc = reader::get_doc(rp_doc,\n                                                 tag_region_param_def_ident);\n-            let ident = item_name(token::get_ident_interner(), ident_str_doc);\n+            let ident = item_name(&*token::get_ident_interner(), ident_str_doc);\n             let def_id_doc = reader::get_doc(rp_doc,\n                                              tag_region_param_def_def_id);\n             let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n@@ -460,13 +460,13 @@ pub fn get_impl_vtables(cdata: Cmd,\n }\n \n \n-pub fn get_impl_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n+pub fn get_impl_method(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n                        name: ast::Ident) -> Option<ast::DefId> {\n     let items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n     let mut found = None;\n     reader::tagged_docs(find_item(id, items), tag_item_impl_method, |mid| {\n         let m_did = reader::with_doc_data(mid, parse_def_id);\n-        if item_name(intr, find_item(m_did.node, items)) == name {\n+        if item_name(&*intr, find_item(m_did.node, items)) == name {\n             found = Some(translate_def_id(cdata, m_did));\n         }\n         true\n@@ -509,7 +509,7 @@ pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n     })\n }\n \n-fn each_child_of_item_or_crate(intr: @IdentInterner,\n+fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                                cdata: Cmd,\n                                item_doc: ebml::Doc,\n                                get_crate_data: GetCrateDataCb,\n@@ -536,7 +536,7 @@ fn each_child_of_item_or_crate(intr: @IdentInterner,\n             None => {}\n             Some(child_item_doc) => {\n                 // Hand off the item to the callback.\n-                let child_name = item_name(intr, child_item_doc);\n+                let child_name = item_name(&*intr, child_item_doc);\n                 let def_like = item_to_def_like(child_item_doc,\n                                                 child_def_id,\n                                                 cdata.cnum);\n@@ -577,7 +577,7 @@ fn each_child_of_item_or_crate(intr: @IdentInterner,\n                                     // Hand off the static method\n                                     // to the callback.\n                                     let static_method_name =\n-                                        item_name(intr, impl_method_doc);\n+                                        item_name(&*intr, impl_method_doc);\n                                     let static_method_def_like =\n                                         item_to_def_like(impl_method_doc,\n                                                          impl_method_def_id,\n@@ -638,7 +638,7 @@ fn each_child_of_item_or_crate(intr: @IdentInterner,\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item(intr: @IdentInterner,\n+pub fn each_child_of_item(intr: Rc<IdentInterner>,\n                           cdata: Cmd,\n                           id: ast::NodeId,\n                           get_crate_data: GetCrateDataCb,\n@@ -659,7 +659,7 @@ pub fn each_child_of_item(intr: @IdentInterner,\n }\n \n /// Iterates over all the top-level crate items.\n-pub fn each_top_level_item_of_crate(intr: @IdentInterner,\n+pub fn each_top_level_item_of_crate(intr: Rc<IdentInterner>,\n                                     cdata: Cmd,\n                                     get_crate_data: GetCrateDataCb,\n                                     callback: |DefLike,\n@@ -711,7 +711,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n     }\n }\n \n-pub fn get_enum_variants(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n+pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n                      tcx: &ty::ctxt) -> Vec<@ty::VariantInfo> {\n     let data = cdata.data();\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n@@ -723,7 +723,7 @@ pub fn get_enum_variants(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type(ast::DefId { krate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n-        let name = item_name(intr, item);\n+        let name = item_name(&*intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n           ty::ty_bare_fn(ref f) => f.sig.inputs.clone(),\n           _ => Vec::new(), // Nullary enum variant.\n@@ -770,20 +770,20 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n     }\n }\n \n-fn item_impl_methods(intr: @IdentInterner, cdata: Cmd, item: ebml::Doc,\n+fn item_impl_methods(intr: Rc<IdentInterner>, cdata: Cmd, item: ebml::Doc,\n                      tcx: &ty::ctxt) -> Vec<@ty::Method> {\n     let mut rslt = Vec::new();\n     reader::tagged_docs(item, tag_item_impl_method, |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n-        rslt.push(@get_method(intr, cdata, m_did.node, tcx));\n+        rslt.push(@get_method(intr.clone(), cdata, m_did.node, tcx));\n         true\n     });\n \n     rslt\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(intr: @IdentInterner, cdata: Cmd, impl_id: ast::NodeId,\n+pub fn get_impl(intr: Rc<IdentInterner>, cdata: Cmd, impl_id: ast::NodeId,\n                tcx: &ty::ctxt)\n                 -> ty::Impl {\n     let data = cdata.data();\n@@ -793,23 +793,23 @@ pub fn get_impl(intr: @IdentInterner, cdata: Cmd, impl_id: ast::NodeId,\n             krate: cdata.cnum,\n             node: impl_id,\n         },\n-        ident: item_name(intr, impl_item),\n+        ident: item_name(&*intr, impl_item),\n         methods: item_impl_methods(intr, cdata, impl_item, tcx),\n     }\n }\n \n pub fn get_method_name_and_explicit_self(\n-    intr: @IdentInterner,\n+    intr: Rc<IdentInterner>,\n     cdata: Cmd,\n     id: ast::NodeId) -> (ast::Ident, ast::ExplicitSelf_)\n {\n     let method_doc = lookup_item(id, cdata.data());\n-    let name = item_name(intr, method_doc);\n+    let name = item_name(&*intr, method_doc);\n     let explicit_self = get_explicit_self(method_doc);\n     (name, explicit_self)\n }\n \n-pub fn get_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n+pub fn get_method(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n                   tcx: &ty::ctxt) -> ty::Method\n {\n     let method_doc = lookup_item(id, cdata.data());\n@@ -823,7 +823,7 @@ pub fn get_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n         _ => ImplContainer(container_id),\n     };\n \n-    let name = item_name(intr, method_doc);\n+    let name = item_name(&*intr, method_doc);\n     let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n                                              tag_item_method_tps);\n     let rp_defs = item_region_param_defs(method_doc, cdata);\n@@ -867,7 +867,7 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n     unwrap_(Decodable::decode(&mut decoder))\n }\n \n-pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,\n+pub fn get_provided_trait_methods(intr: Rc<IdentInterner>, cdata: Cmd,\n                                   id: ast::NodeId, tcx: &ty::ctxt) ->\n         Vec<@ty::Method> {\n     let data = cdata.data();\n@@ -879,7 +879,7 @@ pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,\n         let mth = lookup_item(did.node, data);\n \n         if item_method_sort(mth) == 'p' {\n-            result.push(@get_method(intr, cdata, did.node, tcx));\n+            result.push(@get_method(intr.clone(), cdata, did.node, tcx));\n         }\n         true\n     });\n@@ -921,7 +921,7 @@ pub fn get_type_name_if_impl(cdata: Cmd,\n     ret\n }\n \n-pub fn get_static_methods_if_impl(intr: @IdentInterner,\n+pub fn get_static_methods_if_impl(intr: Rc<IdentInterner>,\n                                   cdata: Cmd,\n                                   node_id: ast::NodeId)\n                                -> Option<Vec<StaticMethodInfo> > {\n@@ -957,7 +957,7 @@ pub fn get_static_methods_if_impl(intr: @IdentInterner,\n                 }\n \n                 static_impl_methods.push(StaticMethodInfo {\n-                    ident: item_name(intr, impl_method_doc),\n+                    ident: item_name(&*intr, impl_method_doc),\n                     def_id: item_def_id(impl_method_doc, cdata),\n                     purity: purity,\n                     vis: item_visibility(impl_method_doc),\n@@ -1009,7 +1009,7 @@ fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n     }\n }\n \n-pub fn get_struct_fields(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId)\n+pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n     -> Vec<ty::field_ty> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n@@ -1018,7 +1018,7 @@ pub fn get_struct_fields(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId)\n         let f = item_family(an_item);\n         if f == PublicField || f == PrivateField || f == InheritedField {\n             // FIXME #6993: name should be of type Name, not Ident\n-            let name = item_name(intr, an_item);\n+            let name = item_name(&*intr, an_item);\n             let did = item_def_id(an_item, cdata);\n             result.push(ty::field_ty {\n                 name: name.name,"}, {"sha": "6de1bf69f6da90b314670b9f3a033de792102d43", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=f65638e669256f37ddaf4ada6617b57cc6dee0da", "patch": "@@ -29,6 +29,7 @@ use std::cast;\n use std::cmp;\n use std::io;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n+use std::rc::Rc;\n use std::str;\n use std::slice;\n \n@@ -52,7 +53,7 @@ pub struct Context<'a> {\n     id_hash: &'a str,\n     hash: Option<&'a Svh>,\n     os: Os,\n-    intr: @IdentInterner,\n+    intr: Rc<IdentInterner>,\n     rejected_via_hash: bool,\n }\n "}, {"sha": "0d33c26343852c16d0bc97059bcaf4061e239b22", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f65638e669256f37ddaf4ada6617b57cc6dee0da", "patch": "@@ -329,7 +329,7 @@ pub struct Parser<'a> {\n     restriction: restriction,\n     quote_depth: uint, // not (yet) related to the quasiquoter\n     reader: ~Reader:,\n-    interner: @token::IdentInterner,\n+    interner: Rc<token::IdentInterner>,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice\n     obsolete_set: HashSet<ObsoleteSyntax>,"}, {"sha": "01bdaa381cb2ea8cd0a4890c36b5d9a93c9490e7", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f65638e669256f37ddaf4ada6617b57cc6dee0da", "patch": "@@ -22,6 +22,7 @@ use std::char;\n use std::fmt;\n use std::local_data;\n use std::path::BytesContainer;\n+use std::rc::Rc;\n \n #[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, Eq, TotalEq, Hash, Show)]\n@@ -531,13 +532,14 @@ pub type IdentInterner = StrInterner;\n \n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n-pub fn get_ident_interner() -> @IdentInterner {\n-    local_data_key!(key: @::parse::token::IdentInterner)\n-    match local_data::get(key, |k| k.map(|k| *k)) {\n+// FIXME(eddyb) #8726 This should probably use a task-local reference.\n+pub fn get_ident_interner() -> Rc<IdentInterner> {\n+    local_data_key!(key: Rc<::parse::token::IdentInterner>)\n+    match local_data::get(key, |k| k.map(|k| k.clone())) {\n         Some(interner) => interner,\n         None => {\n-            let interner = @mk_fresh_ident_interner();\n-            local_data::set(key, interner);\n+            let interner = Rc::new(mk_fresh_ident_interner());\n+            local_data::set(key, interner.clone());\n             interner\n         }\n     }"}, {"sha": "5b4dbab04b110c196a6839e883e5d258f199dbca", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65638e669256f37ddaf4ada6617b57cc6dee0da/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f65638e669256f37ddaf4ada6617b57cc6dee0da", "patch": "@@ -31,8 +31,8 @@ use std::char;\n use std::str;\n use std::io;\n use std::io::{IoResult, MemWriter};\n+use std::rc::Rc;\n \n-// The &mut State is stored here to prevent recursive type.\n pub enum AnnNode<'a> {\n     NodeBlock(&'a ast::Block),\n     NodeItem(&'a ast::Item),\n@@ -57,7 +57,7 @@ pub struct CurrentCommentAndLiteral {\n pub struct State<'a> {\n     s: pp::Printer,\n     cm: Option<&'a CodeMap>,\n-    intr: @token::IdentInterner,\n+    intr: Rc<token::IdentInterner>,\n     comments: Option<Vec<comments::Comment> >,\n     literals: Option<Vec<comments::Literal> >,\n     cur_cmnt_and_lit: CurrentCommentAndLiteral,"}]}