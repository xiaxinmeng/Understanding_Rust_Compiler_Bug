{"sha": "d85ff16173b54a1aa813eabb411c45c28ffcb66d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NWZmMTYxNzNiNTRhMWFhODEzZWFiYjQxMWM0NWMyOGZmY2I2NmQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-07T21:14:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-03T00:05:14Z"}, "message": "Treat builtin bounds like all other kinds of trait matches. Introduce a simple hashset in the fulfillment context to catch cases where we register the exact same obligation twice. This helps prevent duplicate error reports but also handles the recursive obligations created by builtin bounds.", "tree": {"sha": "1f6de482ed7c6d579650a6fe114adae3d6bb2593", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f6de482ed7c6d579650a6fe114adae3d6bb2593"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d85ff16173b54a1aa813eabb411c45c28ffcb66d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d85ff16173b54a1aa813eabb411c45c28ffcb66d", "html_url": "https://github.com/rust-lang/rust/commit/d85ff16173b54a1aa813eabb411c45c28ffcb66d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d85ff16173b54a1aa813eabb411c45c28ffcb66d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a325c666d2cb7e297bf3057ff2442f96a79428b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a325c666d2cb7e297bf3057ff2442f96a79428b", "html_url": "https://github.com/rust-lang/rust/commit/3a325c666d2cb7e297bf3057ff2442f96a79428b"}], "stats": {"total": 54, "additions": 29, "deletions": 25}, "files": [{"sha": "25c86be993f70e86ea81dde9f8af69d0769449cb", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d85ff16173b54a1aa813eabb411c45c28ffcb66d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85ff16173b54a1aa813eabb411c45c28ffcb66d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=d85ff16173b54a1aa813eabb411c45c28ffcb66d", "patch": "@@ -11,6 +11,8 @@\n use middle::mem_categorization::Typer;\n use middle::ty;\n use middle::typeck::infer::InferCtxt;\n+use std::collections::HashSet;\n+use std::rc::Rc;\n use util::ppaux::Repr;\n \n use super::CodeAmbiguity;\n@@ -30,6 +32,13 @@ use super::select::SelectionContext;\n /// method `select_all_or_error` can be used to report any remaining\n /// ambiguous cases as errors.\n pub struct FulfillmentContext<'tcx> {\n+    // a simple cache that aims to cache *exact duplicate obligations*\n+    // and avoid adding them twice. This serves a different purpose\n+    // than the `SelectionCache`: it avoids duplicate errors and\n+    // permits recursive obligations, which are often generated from\n+    // traits like `Send` et al.\n+    duplicate_set: HashSet<Rc<ty::TraitRef<'tcx>>>,\n+\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n     trait_obligations: Vec<Obligation<'tcx>>,\n@@ -43,6 +52,7 @@ pub struct FulfillmentContext<'tcx> {\n impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n+            duplicate_set: HashSet::new(),\n             trait_obligations: Vec::new(),\n             attempted_mark: 0,\n         }\n@@ -52,9 +62,13 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                tcx: &ty::ctxt<'tcx>,\n                                obligation: Obligation<'tcx>)\n     {\n-        debug!(\"register_obligation({})\", obligation.repr(tcx));\n-        assert!(!obligation.trait_ref.has_escaping_regions());\n-        self.trait_obligations.push(obligation);\n+        if self.duplicate_set.insert(obligation.trait_ref.clone()) {\n+            debug!(\"register_obligation({})\", obligation.repr(tcx));\n+            assert!(!obligation.trait_ref.has_escaping_regions());\n+            self.trait_obligations.push(obligation);\n+        } else {\n+            debug!(\"register_obligation({}) -- already seen, skip\", obligation.repr(tcx));\n+        }\n     }\n \n     pub fn select_all_or_error<'a>(&mut self,"}, {"sha": "71a183b475c6f370438d76c8e6e642c8a846969b", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d85ff16173b54a1aa813eabb411c45c28ffcb66d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85ff16173b54a1aa813eabb411c45c28ffcb66d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=d85ff16173b54a1aa813eabb411c45c28ffcb66d", "patch": "@@ -113,7 +113,7 @@ pub enum MethodMatchedData {\n /// candidate is one that might match or might not, depending on how\n /// type variables wind up being resolved. This only occurs during inference.\n ///\n-/// For selection to suceed, there must be exactly one non-ambiguous\n+/// For selection to succeed, there must be exactly one non-ambiguous\n /// candidate.  Usually, it is not possible to have more than one\n /// definitive candidate, due to the coherence rules. However, there is\n /// one case where it could occur: if there is a blanket impl for a\n@@ -1149,24 +1149,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                              candidates: &mut CandidateSet<'tcx>)\n                                              -> Result<(),SelectionError<'tcx>>\n     {\n-        // FIXME -- To be more like a normal impl, we should just\n-        // ignore the nested cases here, and instead generate nested\n-        // obligations in `confirm_candidate`. However, this doesn't\n-        // work because we require handling the recursive cases to\n-        // avoid infinite cycles (that is, with recursive types,\n-        // sometimes `Foo : Copy` only holds if `Foo : Copy`).\n-\n         match self.builtin_bound(bound, stack.obligation.self_ty()) {\n-            Ok(If(nested)) => {\n-                debug!(\"builtin_bound: bound={} nested={}\",\n-                       bound.repr(self.tcx()),\n-                       nested.repr(self.tcx()));\n-                let data = self.vtable_builtin_data(stack.obligation, bound, nested);\n-                match self.winnow_selection(Some(stack), VtableBuiltin(data)) {\n-                    EvaluatedToOk => { Ok(candidates.vec.push(BuiltinCandidate(bound))) }\n-                    EvaluatedToAmbig => { Ok(candidates.ambiguous = true) }\n-                    EvaluatedToErr => { Err(Unimplemented) }\n-                }\n+            Ok(If(_)) => {\n+                debug!(\"builtin_bound: bound={}\",\n+                       bound.repr(self.tcx()));\n+                candidates.vec.push(BuiltinCandidate(bound));\n+                Ok(())\n             }\n             Ok(ParameterBuiltin) => { Ok(()) }\n             Ok(AmbiguousBuiltin) => { Ok(candidates.ambiguous = true) }\n@@ -1539,8 +1527,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                candidate.repr(self.tcx()));\n \n         match candidate {\n-            // FIXME -- see assemble_builtin_bound_candidates()\n-            BuiltinCandidate(_) |\n+            BuiltinCandidate(builtin_bound) => {\n+                Ok(VtableBuiltin(\n+                    try!(self.confirm_builtin_candidate(obligation, builtin_bound))))\n+            }\n+\n             ErrorCandidate => {\n                 Ok(VtableBuiltin(VtableBuiltinData { nested: VecPerParamSpace::empty() }))\n             }\n@@ -1590,8 +1581,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match try!(self.builtin_bound(bound, obligation.self_ty())) {\n             If(nested) => Ok(self.vtable_builtin_data(obligation, bound, nested)),\n-            AmbiguousBuiltin |\n-            ParameterBuiltin => {\n+            AmbiguousBuiltin | ParameterBuiltin => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"builtin bound for {} was ambig\","}]}