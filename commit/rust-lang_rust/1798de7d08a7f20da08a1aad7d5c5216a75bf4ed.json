{"sha": "1798de7d08a7f20da08a1aad7d5c5216a75bf4ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3OThkZTdkMDhhN2YyMGRhMDhhMWFhZDdkNWM1MjE2YTc1YmY0ZWQ=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-21T14:35:11Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-23T04:13:57Z"}, "message": "add new vector representation as a library", "tree": {"sha": "4ad1ac37a96af17a48a3b179a6842d291a3b88c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ad1ac37a96af17a48a3b179a6842d291a3b88c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed", "html_url": "https://github.com/rust-lang/rust/commit/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17d23b8c1727d5fc6fa696d931caf87fa8c0809b", "url": "https://api.github.com/repos/rust-lang/rust/commits/17d23b8c1727d5fc6fa696d931caf87fa8c0809b", "html_url": "https://github.com/rust-lang/rust/commit/17d23b8c1727d5fc6fa696d931caf87fa8c0809b"}], "stats": {"total": 234, "additions": 233, "deletions": 1}, "files": [{"sha": "7e53a0071bd1cc01f6ee06e61032765f80509ced", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=1798de7d08a7f20da08a1aad7d5c5216a75bf4ed", "patch": "@@ -110,6 +110,7 @@ pub mod char;\n pub mod tuple;\n \n pub mod vec;\n+pub mod vec_ng;\n pub mod at_vec;\n pub mod str;\n "}, {"sha": "6bee8cb70f5671ac7880c7cd62eebd043e0fc0a9", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=1798de7d08a7f20da08a1aad7d5c5216a75bf4ed", "patch": "@@ -52,7 +52,7 @@ pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n     // `realloc(ptr, 0)` may allocate, but it may also return a null pointer\n     // http://pubs.opengroup.org/onlinepubs/9699919799/functions/realloc.html\n     if size == 0 {\n-        free(ptr);\n+        free(ptr as *mut c_void);\n         mut_null()\n     } else {\n         let p = realloc(ptr as *mut c_void, size as size_t);"}, {"sha": "e503497d95dffd9fbef41b90fbb3beb21cbb5149", "filename": "src/libstd/vec_ng.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=1798de7d08a7f20da08a1aad7d5c5216a75bf4ed", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Migrate documentation over from `std::vec` when it is removed.\n+#[doc(hidden)];\n+\n+use prelude::*;\n+use container::Container;\n+use mem::size_of;\n+use cast::{forget, transmute};\n+use rt::global_heap::{malloc_raw, realloc_raw};\n+use vec::Items;\n+use unstable::raw::Slice;\n+use ptr::{offset, read_ptr};\n+use libc::{free, c_void};\n+use unstable::intrinsics::move_val_init;\n+\n+pub struct Vec<T> {\n+    priv len: uint,\n+    priv cap: uint,\n+    priv ptr: *mut T\n+}\n+\n+impl<T> Vec<T> {\n+    #[inline]\n+    pub fn new() -> Vec<T> {\n+        Vec { len: 0, cap: 0, ptr: 0 as *mut T }\n+    }\n+\n+    pub fn with_capacity(capacity: uint) -> Vec<T> {\n+        if capacity == 0 {\n+            Vec::new()\n+        } else {\n+            let size = capacity.checked_mul(&size_of::<T>()).expect(\"capacity overflow\");\n+            let ptr = unsafe { malloc_raw(size) };\n+            Vec { len: 0, cap: capacity, ptr: ptr as *mut T }\n+        }\n+    }\n+\n+    pub fn from_fn(length: uint, op: |uint| -> T) -> Vec<T> {\n+        unsafe {\n+            let mut xs = Vec::with_capacity(length);\n+            while xs.len < length {\n+                move_val_init(xs.as_mut_slice().unsafe_mut_ref(xs.len), op(xs.len));\n+                xs.len += 1;\n+            }\n+            xs\n+        }\n+    }\n+}\n+\n+impl<T: Clone> Vec<T> {\n+    pub fn from_elem(length: uint, value: T) -> Vec<T> {\n+        unsafe {\n+            let mut xs = Vec::with_capacity(length);\n+            while xs.len < length {\n+                move_val_init(xs.as_mut_slice().unsafe_mut_ref(xs.len), value.clone());\n+                xs.len += 1;\n+            }\n+            xs\n+        }\n+    }\n+}\n+\n+impl<T> Container for Vec<T> {\n+    #[inline]\n+    fn len(&self) -> uint {\n+        self.len\n+    }\n+}\n+\n+impl<T> Vec<T> {\n+    #[inline]\n+    pub fn capacity(&self) -> uint {\n+        self.cap\n+    }\n+\n+    pub fn reserve_exact(&mut self, capacity: uint) {\n+        if capacity >= self.len {\n+            let size = capacity.checked_mul(&size_of::<T>()).expect(\"capacity overflow\");\n+            self.cap = capacity;\n+            unsafe {\n+                self.ptr = realloc_raw(self.ptr as *mut u8, size) as *mut T;\n+            }\n+        }\n+    }\n+\n+    pub fn shrink_to_fit(&mut self) {\n+        if self.len == 0 {\n+            unsafe { free(self.ptr as *mut c_void) };\n+            self.cap = 0;\n+            self.ptr = 0 as *mut T;\n+        } else {\n+            unsafe {\n+                // Overflow check is unnecessary as the vector is already at least this large.\n+                self.ptr = realloc_raw(self.ptr as *mut u8, self.len * size_of::<T>()) as *mut T;\n+            }\n+            self.cap = self.len;\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn pop(&mut self) -> Option<T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            unsafe {\n+                self.len -= 1;\n+                Some(read_ptr(self.as_slice().unsafe_ref(self.len())))\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn push(&mut self, value: T) {\n+        if self.len == self.cap {\n+            if self.cap == 0 { self.cap += 2 }\n+            let old_size = self.cap * size_of::<T>();\n+            self.cap = self.cap * 2;\n+            let size = old_size * 2;\n+            if old_size > size { fail!(\"capacity overflow\") }\n+            unsafe {\n+                self.ptr = realloc_raw(self.ptr as *mut u8, size) as *mut T;\n+            }\n+        }\n+\n+        unsafe {\n+            let end = offset(self.ptr as *T, self.len as int) as *mut T;\n+            move_val_init(&mut *end, value);\n+            self.len += 1;\n+        }\n+    }\n+\n+    pub fn truncate(&mut self, len: uint) {\n+        unsafe {\n+            let mut i = len;\n+            // drop any extra elements\n+            while i < self.len {\n+                read_ptr(self.as_slice().unsafe_ref(i));\n+                i += 1;\n+            }\n+        }\n+        self.len = len;\n+    }\n+\n+    #[inline]\n+    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+        let slice = Slice { data: self.ptr as *T, len: self.len };\n+        unsafe { transmute(slice) }\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        let slice = Slice { data: self.ptr as *T, len: self.len };\n+        unsafe { transmute(slice) }\n+    }\n+\n+    #[inline]\n+    pub fn move_iter(self) -> MoveItems<T> {\n+        unsafe {\n+            let iter = transmute(self.as_slice().iter());\n+            let ptr = self.ptr as *mut c_void;\n+            forget(self);\n+            MoveItems { allocation: ptr, iter: iter }\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn set_len(&mut self, len: uint) {\n+        self.len = len;\n+    }\n+}\n+\n+\n+#[unsafe_destructor]\n+impl<T> Drop for Vec<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            for x in self.as_mut_slice().iter() {\n+                read_ptr(x);\n+            }\n+            free(self.ptr as *mut c_void)\n+        }\n+    }\n+}\n+\n+pub struct MoveItems<T> {\n+    priv allocation: *mut c_void, // the block of memory allocated for the vector\n+    priv iter: Items<'static, T>\n+}\n+\n+impl<T> Iterator<T> for MoveItems<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            self.iter.next().map(|x| read_ptr(x))\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        unsafe {\n+            self.iter.next_back().map(|x| read_ptr(x))\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for MoveItems<T> {\n+    fn drop(&mut self) {\n+        // destroy the remaining elements\n+        for _x in *self {}\n+        unsafe {\n+            free(self.allocation)\n+        }\n+    }\n+}"}]}