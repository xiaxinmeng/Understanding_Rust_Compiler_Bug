{"sha": "0b5e681f5af0d3989b49121969f09cf29f029263", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNWU2ODFmNWFmMGQzOTg5YjQ5MTIxOTY5ZjA5Y2YyOWYwMjkyNjM=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2020-09-03T08:13:32Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2020-09-03T08:29:49Z"}, "message": "Improve SGX RWLock initializer test", "tree": {"sha": "c1626b0993c1e1d8c60eceb9a892448dbd823c01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1626b0993c1e1d8c60eceb9a892448dbd823c01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b5e681f5af0d3989b49121969f09cf29f029263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5e681f5af0d3989b49121969f09cf29f029263", "html_url": "https://github.com/rust-lang/rust/commit/0b5e681f5af0d3989b49121969f09cf29f029263", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b5e681f5af0d3989b49121969f09cf29f029263/comments", "author": null, "committer": null, "parents": [{"sha": "08deb863bdebfcbbb71c18acf903eca84f1df4e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/08deb863bdebfcbbb71c18acf903eca84f1df4e7", "html_url": "https://github.com/rust-lang/rust/commit/08deb863bdebfcbbb71c18acf903eca84f1df4e7"}], "stats": {"total": 34, "additions": 11, "deletions": 23}, "files": [{"sha": "17c9e72ee39fa2ed2b2e690f01d80dcd855a28e2", "filename": "library/std/src/sys/sgx/rwlock/tests.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0b5e681f5af0d3989b49121969f09cf29f029263/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5e681f5af0d3989b49121969f09cf29f029263/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs?ref=0b5e681f5af0d3989b49121969f09cf29f029263", "patch": "@@ -1,14 +1,12 @@\n use super::*;\n-use crate::mem::{self, MaybeUninit};\n-use core::array::FixedSizeArray;\n \n-// Verify that the bytes of initialized RWLock are the same as in\n-// libunwind. If they change, `src/UnwindRustSgx.h` in libunwind needs to\n-// be changed too.\n+// Verify that the byte pattern libunwind uses to initialize an RWLock is\n+// equivalent to the value of RWLock::new(). If the value changes,\n+// `src/UnwindRustSgx.h` in libunwind needs to be changed too.\n #[test]\n fn test_c_rwlock_initializer() {\n     #[rustfmt::skip]\n-    const RWLOCK_INIT: &[u8] = &[\n+    const C_RWLOCK_INIT: &[u8] = &[\n         /* 0x00 */ 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n         /* 0x10 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n         /* 0x20 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n@@ -20,24 +18,14 @@ fn test_c_rwlock_initializer() {\n         /* 0x80 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n     ];\n \n-    #[inline(never)]\n-    fn zero_stack() {\n-        test::black_box(MaybeUninit::<[RWLock; 16]>::zeroed());\n-    }\n-\n-    #[inline(never)]\n-    unsafe fn rwlock_new(init: &mut MaybeUninit<RWLock>) {\n-        init.write(RWLock::new());\n-    }\n+    // For the test to work, we need the padding/unused bytes in RWLock to be\n+    // initialized as 0. In practice, this is the case with statics.\n+    static RUST_RWLOCK_INIT: RWLock = RWLock::new();\n \n     unsafe {\n-        // try hard to make sure that the padding/unused bytes in RWLock\n-        // get initialized as 0. If the assertion below fails, that might\n-        // just be an issue with the test code and not with the value of\n-        // RWLOCK_INIT.\n-        zero_stack();\n-        let mut init = MaybeUninit::<RWLock>::zeroed();\n-        rwlock_new(&mut init);\n-        assert_eq!(mem::transmute::<_, [u8; 144]>(init.assume_init()).as_slice(), RWLOCK_INIT)\n+        // If the assertion fails, that not necessarily an issue with the value\n+        // of C_RWLOCK_INIT. It might just be an issue with the way padding\n+        // bytes are initialized in the test code.\n+        assert_eq!(&crate::mem::transmute_copy::<_, [u8; 144]>(&RUST_RWLOCK_INIT), C_RWLOCK_INIT);\n     };\n }"}]}