{"sha": "3cbff72da24d2a45552dd51eb7735ae3ee235bf3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjYmZmNzJkYTI0ZDJhNDU1NTJkZDUxZWI3NzM1YWUzZWUyMzViZjM=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-08-08T00:50:03Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-08-08T02:57:00Z"}, "message": "enable PIE by default on Linux for full ASLR\n\nRust already builds all code as position independent by default, so the\nlinker can be told to build a position independent executable if it's\nnot disabled with `-C relocation-model=dynamic-no-pic`. Position\nindependent code does have a significant cost on i686 (not on x86_64 or\nARM) but there's no significant cost to linking code that's already\nposition independent as a position independent executable.\n\nAddress space layout randomization makes exploiting vulnerabilities much\nmore difficult by providing a statistical defence against an attempt to\nfind or modify existing code / data. Without ASLR, it's trivial to use a\nvulnerability to take over control of the process via return-oriented\nprogramming.\n\nRust code can be used for return-oriented programming whether it is safe\nor unsafe, so even a fully safe application needs to be built as a\nposition independent executable to defend against vulnerabilities in\nunsafe blocks or C libraries.\n\nSample program:\n\n    extern crate libc;\n\n    use std::mem;\n\n    static mut global: u32 = 5;\n    static constant: u32 = 5;\n    fn foo() {}\n\n    fn main() {\n        let local = 5;\n        println!(\"stack: {}, global: {}, constant: {}, fn: {}, lib fn: {}\",\n                 &local as *const u32,\n                 unsafe { &global as *const u32 },\n                 &constant as *const u32,\n                 unsafe { mem::transmute::<_, *const ()>(foo) },\n                 unsafe { mem::transmute::<_, *const ()>(libc::mprotect) });\n    }\n\nBefore:\n\n    stack: 0x3ff15eb9f94, global: 0x6ab488, constant: 0x47db40, fn: 0x4030e0, lib fn: 0x32749547530\n    stack: 0x3b5d47d80e4, global: 0x6ab488, constant: 0x47db40, fn: 0x4030e0, lib fn: 0x394469a7530\n    stack: 0x3fe2c4e5564, global: 0x6ab488, constant: 0x47db40, fn: 0x4030e0, lib fn: 0x399734a2530\n    stack: 0x3e525e0fb24, global: 0x6ab488, constant: 0x47db40, fn: 0x4030e0, lib fn: 0x2f62a810530\n    stack: 0x3b50fb3eae4, global: 0x6ab488, constant: 0x47db40, fn: 0x4030e0, lib fn: 0x2e590e86530\n\nAfter:\n\n    stack: 0x38cf12c90a4, global: 0x3e2d46b488, constant: 0x3e2d23cf80, fn: 0x3e2d1c2510, lib fn: 0x2617d3b4530\n    stack: 0x3d733faf474, global: 0x7eb1839488, constant: 0x7eb160af80, fn: 0x7eb1590510, lib fn: 0x32d30c1f530\n    stack: 0x3bb42212ec4, global: 0x5bbb365488, constant: 0x5bbb136f80, fn: 0x5bbb0bc510, lib fn: 0x3595e6c1530\n    stack: 0x39f678c1ab4, global: 0x22c4e3c488, constant: 0x22c4c0df80, fn: 0x22c4b93510, lib fn: 0x3835b727530\n    stack: 0x3afb25bd394, global: 0x493eab2488, constant: 0x493e883f80, fn: 0x493e809510, lib fn: 0x3478d6a7530\n\nThis may also be necessary on other platforms, but I can only test on\nLinux right now. Note that GDB gained support for debugging position\nindependent executables in version 7.1 (March 2010).", "tree": {"sha": "b290cbcbde56399b076ea74008934970ada06c8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b290cbcbde56399b076ea74008934970ada06c8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cbff72da24d2a45552dd51eb7735ae3ee235bf3", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cbff72da24d2a45552dd51eb7735ae3ee235bf3", "html_url": "https://github.com/rust-lang/rust/commit/3cbff72da24d2a45552dd51eb7735ae3ee235bf3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cbff72da24d2a45552dd51eb7735ae3ee235bf3/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12e0f72f517516ac4fce2aed85e6142e9b874bce", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e0f72f517516ac4fce2aed85e6142e9b874bce", "html_url": "https://github.com/rust-lang/rust/commit/12e0f72f517516ac4fce2aed85e6142e9b874bce"}], "stats": {"total": 18, "additions": 15, "deletions": 3}, "files": [{"sha": "7c9844dbe33fb4693616efda8aaa6400786f96a6", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3cbff72da24d2a45552dd51eb7735ae3ee235bf3/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cbff72da24d2a45552dd51eb7735ae3ee235bf3/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=3cbff72da24d2a45552dd51eb7735ae3ee235bf3", "patch": "@@ -1400,6 +1400,20 @@ fn link_args(cmd: &mut Command,\n         cmd.arg(\"-Wl,--gc-sections\");\n     }\n \n+    let used_link_args = sess.cstore.get_used_link_args().borrow();\n+\n+    // Dynamically linked executables can be compiled as position independent if the default\n+    // relocation model of position independent code is not changed. This is a requirement to take\n+    // advantage of ASLR, as otherwise the functions in the executable are not randomized and can\n+    // be used during an exploit of a vulnerability in any code.\n+    if sess.targ_cfg.os == abi::OsLinux {\n+        let mut args = sess.opts.cg.link_args.iter().chain(used_link_args.iter());\n+        if !dylib && sess.opts.cg.relocation_model.as_slice() == \"pic\" &&\n+            !args.any(|x| x.as_slice() == \"-static\") {\n+            cmd.arg(\"-pie\");\n+        }\n+    }\n+\n     if sess.targ_cfg.os == abi::OsLinux || sess.targ_cfg.os == abi::OsDragonfly {\n         // GNU-style linkers will use this to omit linking to libraries which\n         // don't actually fulfill any relocations, but only for libraries which\n@@ -1568,9 +1582,7 @@ fn link_args(cmd: &mut Command,\n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     cmd.args(sess.opts.cg.link_args.as_slice());\n-    for arg in sess.cstore.get_used_link_args().borrow().iter() {\n-        cmd.arg(arg.as_slice());\n-    }\n+    cmd.args(used_link_args.as_slice());\n }\n \n // # Native library linking"}]}