{"sha": "292e313259f422c8f4c31ecaedcc14058e8f4f8b", "node_id": "C_kwDOAAsO6NoAKDI5MmUzMTMyNTlmNDIyYzhmNGMzMWVjYWVkY2MxNDA1OGU4ZjRmOGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-08T15:58:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-08T15:58:51Z"}, "message": "Auto merge of #9451 - kraktus:manual_filter2, r=dswij\n\nAdd `manual_filter` lint for `Option`\n\nShare much of its implementation with `manual_map` and should greatly benefit from its previous feedback.\nI'm sure it's possible to even more refactor both and would gladly take input on that as well as any clippy idiomatic usage, since this is my first lint addition.\n\nI've added the lint to the complexity section for now, I don't know if every new lint needs to go in nursery first.\n\nThe matching could be expanded to more than `Some(<value>)` to lint on arbitrary struct matching inside the `Some` but I've left it like it was for `manual_map` for now. `needless_match::pat_same_as_expr` provides a more generic match example.\n\nclose https://github.com/rust-lang/rust-clippy/issues/8822\n\nchangelog: Add lint [`manual_filter`] for `Option`", "tree": {"sha": "57a9020d932e78c457c5e1a96d299da076a4dae7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57a9020d932e78c457c5e1a96d299da076a4dae7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/292e313259f422c8f4c31ecaedcc14058e8f4f8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/292e313259f422c8f4c31ecaedcc14058e8f4f8b", "html_url": "https://github.com/rust-lang/rust/commit/292e313259f422c8f4c31ecaedcc14058e8f4f8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/292e313259f422c8f4c31ecaedcc14058e8f4f8b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c8e473ffea22fdf9ffbecb53c1c7288d38fe923", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c8e473ffea22fdf9ffbecb53c1c7288d38fe923", "html_url": "https://github.com/rust-lang/rust/commit/2c8e473ffea22fdf9ffbecb53c1c7288d38fe923"}, {"sha": "830fdf2b56d2a2f0f8e8135e05ec30b08e54ad3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/830fdf2b56d2a2f0f8e8135e05ec30b08e54ad3a", "html_url": "https://github.com/rust-lang/rust/commit/830fdf2b56d2a2f0f8e8135e05ec30b08e54ad3a"}], "stats": {"total": 1374, "additions": 1118, "deletions": 256}, "files": [{"sha": "da29804fad0034536539ee25236ff2096b4d5773", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -3988,6 +3988,7 @@ Released 2018-09-13\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_bits`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_bits\n [`manual_clamp`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_clamp\n+[`manual_filter`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n [`manual_find`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map"}, {"sha": "758f99360648932dae1e56111b74a20f9d879982", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -137,6 +137,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n     LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n+    LintId::of(matches::MANUAL_FILTER),\n     LintId::of(matches::MANUAL_MAP),\n     LintId::of(matches::MANUAL_UNWRAP_OR),\n     LintId::of(matches::MATCH_AS_REF),"}, {"sha": "e3849e5a626bda6b5ab541cc453db97d08e327ee", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -27,6 +27,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(manual_strip::MANUAL_STRIP),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n+    LintId::of(matches::MANUAL_FILTER),\n     LintId::of(matches::MANUAL_UNWRAP_OR),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_SINGLE_BINDING),"}, {"sha": "72715eddbb91d4e0b5dbd74bb60adc789bd8e800", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -259,6 +259,7 @@ store.register_lints(&[\n     match_result_ok::MATCH_RESULT_OK,\n     matches::COLLAPSIBLE_MATCH,\n     matches::INFALLIBLE_DESTRUCTURING_MATCH,\n+    matches::MANUAL_FILTER,\n     matches::MANUAL_MAP,\n     matches::MANUAL_UNWRAP_OR,\n     matches::MATCH_AS_REF,"}, {"sha": "66ba1f6f9c55007771d75d415ff517bea32bdbe5", "filename": "clippy_lints/src/matches/manual_filter.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -0,0 +1,153 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::contains_unsafe_block;\n+use clippy_utils::{is_res_lang_ctor, path_res, path_to_local_id};\n+\n+use rustc_hir::LangItem::OptionSome;\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::{sym, SyntaxContext};\n+\n+use super::manual_utils::{check_with, SomeExpr};\n+use super::MANUAL_FILTER;\n+\n+// Function called on the <expr> of `[&+]Some((ref | ref mut) x) => <expr>`\n+// Need to check if it's of the form `<expr>=if <cond> {<then_expr>} else {<else_expr>}`\n+// AND that only one `then/else_expr` resolves to `Some(x)` while the other resolves to `None`\n+// return the `cond` expression if so.\n+fn get_cond_expr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'_>,\n+    expr: &'tcx Expr<'_>,\n+    ctxt: SyntaxContext,\n+) -> Option<SomeExpr<'tcx>> {\n+    if_chain! {\n+        if let Some(block_expr) = peels_blocks_incl_unsafe_opt(expr);\n+        if let ExprKind::If(cond, then_expr, Some(else_expr)) = block_expr.kind;\n+        if let PatKind::Binding(_,target, ..) = pat.kind;\n+        if let (then_visitor, else_visitor)\n+            = (is_some_expr(cx, target, ctxt, then_expr),\n+                is_some_expr(cx, target, ctxt, else_expr));\n+        if then_visitor != else_visitor; // check that one expr resolves to `Some(x)`, the other to `None`\n+        then {\n+            return Some(SomeExpr {\n+                    expr: peels_blocks_incl_unsafe(cond.peel_drop_temps()),\n+                    needs_unsafe_block: contains_unsafe_block(cx, expr),\n+                    needs_negated: !then_visitor // if the `then_expr` resolves to `None`, need to negate the cond\n+                })\n+            }\n+    };\n+    None\n+}\n+\n+fn peels_blocks_incl_unsafe_opt<'a>(expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n+    // we don't want to use `peel_blocks` here because we don't care if the block is unsafe, it's\n+    // checked by `contains_unsafe_block`\n+    if let ExprKind::Block(block, None) = expr.kind {\n+        if block.stmts.is_empty() {\n+            return block.expr;\n+        }\n+    };\n+    None\n+}\n+\n+fn peels_blocks_incl_unsafe<'a>(expr: &'a Expr<'a>) -> &'a Expr<'a> {\n+    peels_blocks_incl_unsafe_opt(expr).unwrap_or(expr)\n+}\n+\n+// function called for each <expr> expression:\n+// Some(x) => if <cond> {\n+//    <expr>\n+// } else {\n+//    <expr>\n+// }\n+// Returns true if <expr> resolves to `Some(x)`, `false` otherwise\n+fn is_some_expr<'tcx>(cx: &LateContext<'_>, target: HirId, ctxt: SyntaxContext, expr: &'tcx Expr<'_>) -> bool {\n+    if let Some(inner_expr) = peels_blocks_incl_unsafe_opt(expr) {\n+        // there can be not statements in the block as they would be removed when switching to `.filter`\n+        if let ExprKind::Call(callee, [arg]) = inner_expr.kind {\n+            return ctxt == expr.span.ctxt()\n+                && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome)\n+                && path_to_local_id(arg, target);\n+        }\n+    };\n+    false\n+}\n+\n+// given the closure: `|<pattern>| <expr>`\n+// returns `|&<pattern>| <expr>`\n+fn add_ampersand_if_copy(body_str: String, has_copy_trait: bool) -> String {\n+    if has_copy_trait {\n+        let mut with_ampersand = body_str;\n+        with_ampersand.insert(1, '&');\n+        with_ampersand\n+    } else {\n+        body_str\n+    }\n+}\n+\n+pub(super) fn check_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    scrutinee: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'_>],\n+    expr: &'tcx Expr<'_>,\n+) {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    if is_type_diagnostic_item(cx, ty, sym::Option)\n+    && let [first_arm, second_arm] = arms\n+    && first_arm.guard.is_none()\n+    && second_arm.guard.is_none()\n+         {\n+            check(cx, expr, scrutinee, first_arm.pat, first_arm.body, Some(second_arm.pat), second_arm.body);\n+        }\n+}\n+\n+pub(super) fn check_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &'tcx Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+    then_expr: &'tcx Expr<'_>,\n+    else_expr: &'tcx Expr<'_>,\n+) {\n+    check(cx, expr, let_expr, let_pat, then_expr, None, else_expr);\n+}\n+\n+fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    then_pat: &'tcx Pat<'_>,\n+    then_body: &'tcx Expr<'_>,\n+    else_pat: Option<&'tcx Pat<'_>>,\n+    else_body: &'tcx Expr<'_>,\n+) {\n+    if let Some(sugg_info) = check_with(\n+        cx,\n+        expr,\n+        scrutinee,\n+        then_pat,\n+        then_body,\n+        else_pat,\n+        else_body,\n+        get_cond_expr,\n+    ) {\n+        let body_str = add_ampersand_if_copy(sugg_info.body_str, sugg_info.scrutinee_impl_copy);\n+        span_lint_and_sugg(\n+            cx,\n+            MANUAL_FILTER,\n+            expr.span,\n+            \"manual implementation of `Option::filter`\",\n+            \"try this\",\n+            if sugg_info.needs_brackets {\n+                format!(\n+                    \"{{ {}{}.filter({body_str}) }}\",\n+                    sugg_info.scrutinee_str, sugg_info.as_ref_str\n+                )\n+            } else {\n+                format!(\"{}{}.filter({body_str})\", sugg_info.scrutinee_str, sugg_info.as_ref_str)\n+            },\n+            sugg_info.app,\n+        );\n+    }\n+}"}, {"sha": "aaba239677fffafa163e7e76805b30be9d037d75", "filename": "clippy_lints/src/matches/manual_map.rs", "status": "modified", "additions": 64, "deletions": 254, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -1,22 +1,13 @@\n-use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n+use super::manual_utils::{check_with, SomeExpr};\n+use super::MANUAL_MAP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n-use clippy_utils::{\n-    can_move_expr_to_closure, is_else_clause, is_lint_allowed, is_res_lang_ctor, path_res, path_to_local_id,\n-    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n-};\n-use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{\n-    def::Res, Arm, BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path,\n-    QPath, UnsafeSource,\n-};\n-use rustc_lint::LateContext;\n-use rustc_span::{sym, SyntaxContext};\n \n-use super::MANUAL_MAP;\n+use clippy_utils::{is_res_lang_ctor, path_res};\n+\n+use rustc_hir::LangItem::OptionSome;\n+use rustc_hir::{Arm, Block, BlockCheckMode, Expr, ExprKind, Pat, UnsafeSource};\n+use rustc_lint::LateContext;\n+use rustc_span::SyntaxContext;\n \n pub(super) fn check_match<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -43,7 +34,6 @@ pub(super) fn check_if_let<'tcx>(\n     check(cx, expr, let_expr, let_pat, then_expr, None, else_expr);\n }\n \n-#[expect(clippy::too_many_lines)]\n fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n@@ -53,254 +43,74 @@ fn check<'tcx>(\n     else_pat: Option<&'tcx Pat<'_>>,\n     else_body: &'tcx Expr<'_>,\n ) {\n-    let (scrutinee_ty, ty_ref_count, ty_mutability) =\n-        peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n-    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::Option)\n-        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Option))\n-    {\n-        return;\n-    }\n-\n-    let expr_ctxt = expr.span.ctxt();\n-    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n-        try_parse_pattern(cx, then_pat, expr_ctxt),\n-        else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n+    if let Some(sugg_info) = check_with(\n+        cx,\n+        expr,\n+        scrutinee,\n+        then_pat,\n+        then_body,\n+        else_pat,\n+        else_body,\n+        get_some_expr,\n     ) {\n-        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n-            (else_body, pattern, ref_count, true)\n-        },\n-        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n-            (else_body, pattern, ref_count, false)\n-        },\n-        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n-            (then_body, pattern, ref_count, true)\n-        },\n-        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n-            (then_body, pattern, ref_count, false)\n-        },\n-        _ => return,\n-    };\n-\n-    // Top level or patterns aren't allowed in closures.\n-    if matches!(some_pat.kind, PatKind::Or(_)) {\n-        return;\n-    }\n-\n-    let some_expr = match get_some_expr(cx, some_expr, false, expr_ctxt) {\n-        Some(expr) => expr,\n-        None => return,\n-    };\n-\n-    // These two lints will go back and forth with each other.\n-    if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n-        && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n-    {\n-        return;\n-    }\n-\n-    // `map` won't perform any adjustments.\n-    if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n-        return;\n-    }\n-\n-    // Determine which binding mode to use.\n-    let explicit_ref = some_pat.contains_explicit_ref_binding();\n-    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then_some(ty_mutability));\n-\n-    let as_ref_str = match binding_ref {\n-        Some(Mutability::Mut) => \".as_mut()\",\n-        Some(Mutability::Not) => \".as_ref()\",\n-        None => \"\",\n-    };\n-\n-    match can_move_expr_to_closure(cx, some_expr.expr) {\n-        Some(captures) => {\n-            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n-            // TODO: check all the references made in the scrutinee expression. This will require interacting\n-            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n-            if let Some(binding_ref_mutability) = binding_ref {\n-                let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n-                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n-                    _ => None,\n-                });\n-                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n-                    match captures.get(l) {\n-                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n-                        Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n-                            return;\n-                        },\n-                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n-                    }\n-                }\n-            }\n-        },\n-        None => return,\n-    };\n-\n-    let mut app = Applicability::MachineApplicable;\n-\n-    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n-    // it's being passed by value.\n-    let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n-    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n-        format!(\"({scrutinee_str})\")\n-    } else {\n-        scrutinee_str.into()\n-    };\n-\n-    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-        if_chain! {\n-            if !some_expr.needs_unsafe_block;\n-            if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n-            if func.span.ctxt() == some_expr.expr.span.ctxt();\n-            then {\n-                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+        span_lint_and_sugg(\n+            cx,\n+            MANUAL_MAP,\n+            expr.span,\n+            \"manual implementation of `Option::map`\",\n+            \"try this\",\n+            if sugg_info.needs_brackets {\n+                format!(\n+                    \"{{ {}{}.map({}) }}\",\n+                    sugg_info.scrutinee_str, sugg_info.as_ref_str, sugg_info.body_str\n+                )\n             } else {\n-                if path_to_local_id(some_expr.expr, id)\n-                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                    && binding_ref.is_some()\n-                {\n-                    return;\n-                }\n-\n-                // `ref` and `ref mut` annotations were handled earlier.\n-                let annotation = if matches!(annotation, BindingAnnotation::MUT) {\n-                    \"mut \"\n-                } else {\n-                    \"\"\n-                };\n-                let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n-                if some_expr.needs_unsafe_block {\n-                    format!(\"|{annotation}{some_binding}| unsafe {{ {expr_snip} }}\")\n-                } else {\n-                    format!(\"|{annotation}{some_binding}| {expr_snip}\")\n-                }\n-            }\n-        }\n-    } else if !is_wild_none && explicit_ref.is_none() {\n-        // TODO: handle explicit reference annotations.\n-        let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n-        let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n-        if some_expr.needs_unsafe_block {\n-            format!(\"|{pat_snip}| unsafe {{ {expr_snip} }}\")\n-        } else {\n-            format!(\"|{pat_snip}| {expr_snip}\")\n-        }\n-    } else {\n-        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n-        return;\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        MANUAL_MAP,\n-        expr.span,\n-        \"manual implementation of `Option::map`\",\n-        \"try this\",\n-        if else_pat.is_none() && is_else_clause(cx.tcx, expr) {\n-            format!(\"{{ {scrutinee_str}{as_ref_str}.map({body_str}) }}\")\n-        } else {\n-            format!(\"{scrutinee_str}{as_ref_str}.map({body_str})\")\n-        },\n-        app,\n-    );\n-}\n-\n-// Checks whether the expression could be passed as a function, or whether a closure is needed.\n-// Returns the function to be passed to `map` if it exists.\n-fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    match expr.kind {\n-        ExprKind::Call(func, [arg])\n-            if path_to_local_id(arg, binding)\n-                && cx.typeck_results().expr_adjustments(arg).is_empty()\n-                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n-        {\n-            Some(func)\n-        },\n-        _ => None,\n-    }\n-}\n-\n-enum OptionPat<'a> {\n-    Wild,\n-    None,\n-    Some {\n-        // The pattern contained in the `Some` tuple.\n-        pattern: &'a Pat<'a>,\n-        // The number of references before the `Some` tuple.\n-        // e.g. `&&Some(_)` has a ref count of 2.\n-        ref_count: usize,\n-    },\n-}\n-\n-struct SomeExpr<'tcx> {\n-    expr: &'tcx Expr<'tcx>,\n-    needs_unsafe_block: bool,\n-}\n-\n-// Try to parse into a recognized `Option` pattern.\n-// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n-    fn f<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        pat: &'tcx Pat<'_>,\n-        ref_count: usize,\n-        ctxt: SyntaxContext,\n-    ) -> Option<OptionPat<'tcx>> {\n-        match pat.kind {\n-            PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n-            PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionNone) => {\n-                Some(OptionPat::None)\n-            },\n-            PatKind::TupleStruct(ref qpath, [pattern], _)\n-                if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionSome) && pat.span.ctxt() == ctxt =>\n-            {\n-                Some(OptionPat::Some { pattern, ref_count })\n+                format!(\n+                    \"{}{}.map({})\",\n+                    sugg_info.scrutinee_str, sugg_info.as_ref_str, sugg_info.body_str\n+                )\n             },\n-            _ => None,\n-        }\n+            sugg_info.app,\n+        );\n     }\n-    f(cx, pat, 0, ctxt)\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n fn get_some_expr<'tcx>(\n     cx: &LateContext<'tcx>,\n+    _: &'tcx Pat<'_>,\n     expr: &'tcx Expr<'_>,\n-    needs_unsafe_block: bool,\n     ctxt: SyntaxContext,\n ) -> Option<SomeExpr<'tcx>> {\n-    // TODO: Allow more complex expressions.\n-    match expr.kind {\n-        ExprKind::Call(callee, [arg])\n-            if ctxt == expr.span.ctxt() && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome) =>\n-        {\n-            Some(SomeExpr {\n-                expr: arg,\n-                needs_unsafe_block,\n-            })\n-        },\n-        ExprKind::Block(\n-            Block {\n-                stmts: [],\n-                expr: Some(expr),\n-                rules,\n-                ..\n+    fn get_some_expr_internal<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        expr: &'tcx Expr<'_>,\n+        needs_unsafe_block: bool,\n+        ctxt: SyntaxContext,\n+    ) -> Option<SomeExpr<'tcx>> {\n+        // TODO: Allow more complex expressions.\n+        match expr.kind {\n+            ExprKind::Call(callee, [arg])\n+                if ctxt == expr.span.ctxt() && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome) =>\n+            {\n+                Some(SomeExpr::new_no_negated(arg, needs_unsafe_block))\n             },\n-            _,\n-        ) => get_some_expr(\n-            cx,\n-            expr,\n-            needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n-            ctxt,\n-        ),\n-        _ => None,\n+            ExprKind::Block(\n+                Block {\n+                    stmts: [],\n+                    expr: Some(expr),\n+                    rules,\n+                    ..\n+                },\n+                _,\n+            ) => get_some_expr_internal(\n+                cx,\n+                expr,\n+                needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+                ctxt,\n+            ),\n+            _ => None,\n+        }\n     }\n-}\n-\n-// Checks for the `None` value.\n-fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    is_res_lang_ctor(cx, path_res(cx, peel_blocks(expr)), OptionNone)\n+    get_some_expr_internal(cx, expr, false, ctxt)\n }"}, {"sha": "792908aa7dfca0ec738d24490cd543cf4efdf4e2", "filename": "clippy_lints/src/matches/manual_utils.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Fmatches%2Fmanual_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Fmatches%2Fmanual_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_utils.rs?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -0,0 +1,278 @@\n+use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n+use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n+use clippy_utils::ty::{is_copy, is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n+use clippy_utils::{\n+    can_move_expr_to_closure, is_else_clause, is_lint_allowed, is_res_lang_ctor, path_res, path_to_local_id,\n+    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, sugg::Sugg, CaptureKind,\n+};\n+use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::{def::Res, BindingAnnotation, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::{sym, SyntaxContext};\n+\n+#[expect(clippy::too_many_arguments)]\n+#[expect(clippy::too_many_lines)]\n+pub(super) fn check_with<'tcx, F>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    then_pat: &'tcx Pat<'_>,\n+    then_body: &'tcx Expr<'_>,\n+    else_pat: Option<&'tcx Pat<'_>>,\n+    else_body: &'tcx Expr<'_>,\n+    get_some_expr_fn: F,\n+) -> Option<SuggInfo<'tcx>>\n+where\n+    F: Fn(&LateContext<'tcx>, &'tcx Pat<'_>, &'tcx Expr<'_>, SyntaxContext) -> Option<SomeExpr<'tcx>>,\n+{\n+    let (scrutinee_ty, ty_ref_count, ty_mutability) =\n+        peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n+    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::Option)\n+        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Option))\n+    {\n+        return None;\n+    }\n+\n+    let expr_ctxt = expr.span.ctxt();\n+    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+        try_parse_pattern(cx, then_pat, expr_ctxt),\n+        else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n+    ) {\n+        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+            (else_body, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+            (else_body, pattern, ref_count, false)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n+            (then_body, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n+            (then_body, pattern, ref_count, false)\n+        },\n+        _ => return None,\n+    };\n+\n+    // Top level or patterns aren't allowed in closures.\n+    if matches!(some_pat.kind, PatKind::Or(_)) {\n+        return None;\n+    }\n+\n+    let some_expr = match get_some_expr_fn(cx, some_pat, some_expr, expr_ctxt) {\n+        Some(expr) => expr,\n+        None => return None,\n+    };\n+\n+    // These two lints will go back and forth with each other.\n+    if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n+        && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+    {\n+        return None;\n+    }\n+\n+    // `map` won't perform any adjustments.\n+    if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n+        return None;\n+    }\n+\n+    // Determine which binding mode to use.\n+    let explicit_ref = some_pat.contains_explicit_ref_binding();\n+    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then_some(ty_mutability));\n+\n+    let as_ref_str = match binding_ref {\n+        Some(Mutability::Mut) => \".as_mut()\",\n+        Some(Mutability::Not) => \".as_ref()\",\n+        None => \"\",\n+    };\n+\n+    match can_move_expr_to_closure(cx, some_expr.expr) {\n+        Some(captures) => {\n+            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+            // TODO: check all the references made in the scrutinee expression. This will require interacting\n+            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+            if let Some(binding_ref_mutability) = binding_ref {\n+                let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n+                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                });\n+                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                    match captures.get(l) {\n+                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return None,\n+                        Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n+                            return None;\n+                        },\n+                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                    }\n+                }\n+            }\n+        },\n+        None => return None,\n+    };\n+\n+    let mut app = Applicability::MachineApplicable;\n+\n+    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+    // it's being passed by value.\n+    let scrutinee = peel_hir_expr_refs(scrutinee).0;\n+    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+        format!(\"({scrutinee_str})\")\n+    } else {\n+        scrutinee_str.into()\n+    };\n+\n+    let closure_expr_snip = some_expr.to_snippet_with_context(cx, expr_ctxt, &mut app);\n+    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+        if_chain! {\n+            if !some_expr.needs_unsafe_block;\n+            if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n+            if func.span.ctxt() == some_expr.expr.span.ctxt();\n+            then {\n+                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+            } else {\n+                if path_to_local_id(some_expr.expr, id)\n+                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                    && binding_ref.is_some()\n+                {\n+                    return None;\n+                }\n+\n+                // `ref` and `ref mut` annotations were handled earlier.\n+                let annotation = if matches!(annotation, BindingAnnotation::MUT) {\n+                    \"mut \"\n+                } else {\n+                    \"\"\n+                };\n+\n+                if some_expr.needs_unsafe_block {\n+                    format!(\"|{annotation}{some_binding}| unsafe {{ {closure_expr_snip} }}\")\n+                } else {\n+                    format!(\"|{annotation}{some_binding}| {closure_expr_snip}\")\n+                }\n+            }\n+        }\n+    } else if !is_wild_none && explicit_ref.is_none() {\n+        // TODO: handle explicit reference annotations.\n+        let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n+        if some_expr.needs_unsafe_block {\n+            format!(\"|{pat_snip}| unsafe {{ {closure_expr_snip} }}\")\n+        } else {\n+            format!(\"|{pat_snip}| {closure_expr_snip}\")\n+        }\n+    } else {\n+        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+        return None;\n+    };\n+\n+    // relies on the fact that Option<T>: Copy where T: copy\n+    let scrutinee_impl_copy = is_copy(cx, scrutinee_ty);\n+\n+    Some(SuggInfo {\n+        needs_brackets: else_pat.is_none() && is_else_clause(cx.tcx, expr),\n+        scrutinee_impl_copy,\n+        scrutinee_str,\n+        as_ref_str,\n+        body_str,\n+        app,\n+    })\n+}\n+\n+pub struct SuggInfo<'a> {\n+    pub needs_brackets: bool,\n+    pub scrutinee_impl_copy: bool,\n+    pub scrutinee_str: String,\n+    pub as_ref_str: &'a str,\n+    pub body_str: String,\n+    pub app: Applicability,\n+}\n+\n+// Checks whether the expression could be passed as a function, or whether a closure is needed.\n+// Returns the function to be passed to `map` if it exists.\n+fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    match expr.kind {\n+        ExprKind::Call(func, [arg])\n+            if path_to_local_id(arg, binding)\n+                && cx.typeck_results().expr_adjustments(arg).is_empty()\n+                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n+        {\n+            Some(func)\n+        },\n+        _ => None,\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(super) enum OptionPat<'a> {\n+    Wild,\n+    None,\n+    Some {\n+        // The pattern contained in the `Some` tuple.\n+        pattern: &'a Pat<'a>,\n+        // The number of references before the `Some` tuple.\n+        // e.g. `&&Some(_)` has a ref count of 2.\n+        ref_count: usize,\n+    },\n+}\n+\n+pub(super) struct SomeExpr<'tcx> {\n+    pub expr: &'tcx Expr<'tcx>,\n+    pub needs_unsafe_block: bool,\n+    pub needs_negated: bool, // for `manual_filter` lint\n+}\n+\n+impl<'tcx> SomeExpr<'tcx> {\n+    pub fn new_no_negated(expr: &'tcx Expr<'tcx>, needs_unsafe_block: bool) -> Self {\n+        Self {\n+            expr,\n+            needs_unsafe_block,\n+            needs_negated: false,\n+        }\n+    }\n+\n+    pub fn to_snippet_with_context(\n+        &self,\n+        cx: &LateContext<'tcx>,\n+        ctxt: SyntaxContext,\n+        app: &mut Applicability,\n+    ) -> Sugg<'tcx> {\n+        let sugg = Sugg::hir_with_context(cx, self.expr, ctxt, \"..\", app);\n+        if self.needs_negated { !sugg } else { sugg }\n+    }\n+}\n+\n+// Try to parse into a recognized `Option` pattern.\n+// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n+pub(super) fn try_parse_pattern<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    ctxt: SyntaxContext,\n+) -> Option<OptionPat<'tcx>> {\n+    fn f<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        pat: &'tcx Pat<'_>,\n+        ref_count: usize,\n+        ctxt: SyntaxContext,\n+    ) -> Option<OptionPat<'tcx>> {\n+        match pat.kind {\n+            PatKind::Wild => Some(OptionPat::Wild),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n+            PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionNone) => {\n+                Some(OptionPat::None)\n+            },\n+            PatKind::TupleStruct(ref qpath, [pattern], _)\n+                if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionSome) && pat.span.ctxt() == ctxt =>\n+            {\n+                Some(OptionPat::Some { pattern, ref_count })\n+            },\n+            _ => None,\n+        }\n+    }\n+    f(cx, pat, 0, ctxt)\n+}\n+\n+// Checks for the `None` value.\n+fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    is_res_lang_ctor(cx, path_res(cx, peel_blocks(expr)), OptionNone)\n+}"}, {"sha": "7d8171ead89e10787dee90e48d11a7e33b527a6a", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -1,7 +1,9 @@\n mod collapsible_match;\n mod infallible_destructuring_match;\n+mod manual_filter;\n mod manual_map;\n mod manual_unwrap_or;\n+mod manual_utils;\n mod match_as_ref;\n mod match_bool;\n mod match_like_matches;\n@@ -898,6 +900,34 @@ declare_clippy_lint! {\n     \"reimplementation of `map`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of `match` which could be implemented using `filter`\n+    ///\n+    /// ### Why is this bad?\n+    /// Using the `filter` method is clearer and more concise.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// match Some(0) {\n+    ///     Some(x) => if x % 2 == 0 {\n+    ///                     Some(x)\n+    ///                } else {\n+    ///                     None\n+    ///                 },\n+    ///     None => None,\n+    /// };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// Some(0).filter(|&x| x % 2 == 0);\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub MANUAL_FILTER,\n+    complexity,\n+    \"reimplentation of `filter`\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     msrv: Option<RustcVersion>,\n@@ -939,6 +969,7 @@ impl_lint_pass!(Matches => [\n     SIGNIFICANT_DROP_IN_SCRUTINEE,\n     TRY_ERR,\n     MANUAL_MAP,\n+    MANUAL_FILTER,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n@@ -988,6 +1019,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     if !in_constant(cx, expr.hir_id) {\n                         manual_unwrap_or::check(cx, expr, ex, arms);\n                         manual_map::check_match(cx, expr, ex, arms);\n+                        manual_filter::check_match(cx, ex, arms, expr);\n                     }\n \n                     if self.infallible_destructuring_match_linted {\n@@ -1014,6 +1046,14 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     }\n                     if !in_constant(cx, expr.hir_id) {\n                         manual_map::check_if_let(cx, expr, if_let.let_pat, if_let.let_expr, if_let.if_then, else_expr);\n+                        manual_filter::check_if_let(\n+                            cx,\n+                            expr,\n+                            if_let.let_pat,\n+                            if_let.let_expr,\n+                            if_let.if_then,\n+                            else_expr,\n+                        );\n                     }\n                 }\n                 redundant_pattern_match::check_if_let("}, {"sha": "f25bced0c2b3dd15ccfb3d6508fd1759002c6006", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -1,7 +1,9 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::source::{snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite};\n+use crate::source::{\n+    snippet, snippet_opt, snippet_with_applicability, snippet_with_context, snippet_with_macro_callsite,\n+};\n use crate::ty::expr_sig;\n use crate::{get_parent_expr_for_hir, higher};\n use rustc_ast::util::parser::AssocOp;\n@@ -110,7 +112,7 @@ impl<'a> Sugg<'a> {\n         if expr.span.ctxt() == ctxt {\n             Self::hir_from_snippet(expr, |span| snippet(cx, span, default))\n         } else {\n-            let snip = snippet_with_applicability(cx, expr.span, default, applicability);\n+            let (snip, _) = snippet_with_context(cx, expr.span, ctxt, default, applicability);\n             Sugg::NonParen(snip)\n         }\n     }"}, {"sha": "c75341860047ec20666f4aee0fe52c6b80bef959", "filename": "src/docs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/src%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/src%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs.rs?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -258,6 +258,7 @@ docs! {\n     \"manual_async_fn\",\n     \"manual_bits\",\n     \"manual_clamp\",\n+    \"manual_filter\",\n     \"manual_filter_map\",\n     \"manual_find\",\n     \"manual_find_map\","}, {"sha": "19a4d9319d94b700d1e88671e4e8f9f6ae6c20ef", "filename": "src/docs/manual_filter.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/src%2Fdocs%2Fmanual_filter.txt", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/src%2Fdocs%2Fmanual_filter.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_filter.txt?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for usages of `match` which could be implemented using `filter`\n+\n+### Why is this bad?\n+Using the `filter` method is clearer and more concise.\n+\n+### Example\n+```\n+match Some(0) {\n+    Some(x) => if x % 2 == 0 {\n+                    Some(x)\n+               } else {\n+                    None\n+                },\n+    None => None,\n+};\n+```\n+Use instead:\n+```\n+Some(0).filter(|&x| x % 2 == 0);\n+```\n\\ No newline at end of file"}, {"sha": "3553291b87df6731aca2e71f905ed63eef21cda7", "filename": "tests/ui/manual_filter.fixed", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/tests%2Fui%2Fmanual_filter.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/tests%2Fui%2Fmanual_filter.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_filter.fixed?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -0,0 +1,119 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_filter)]\n+#![allow(unused_variables, dead_code)]\n+\n+fn main() {\n+    Some(0).filter(|&x| x <= 0);\n+\n+    Some(1).filter(|&x| x <= 0);\n+\n+    Some(2).filter(|&x| x <= 0);\n+\n+    Some(3).filter(|&x| x > 0);\n+\n+    let y = Some(4);\n+    y.filter(|&x| x <= 0);\n+\n+    Some(5).filter(|&x| x > 0);\n+\n+    Some(6).as_ref().filter(|&x| x > &0);\n+\n+    let external_cond = true;\n+    Some(String::new()).filter(|x| external_cond);\n+\n+    Some(7).filter(|&x| external_cond);\n+\n+    Some(8).filter(|&x| x != 0);\n+\n+    Some(9).filter(|&x| x > 10 && x < 100);\n+\n+    const fn f1() {\n+        // Don't lint, `.filter` is not const\n+        match Some(10) {\n+            Some(x) => {\n+                if x > 10 && x < 100 {\n+                    Some(x)\n+                } else {\n+                    None\n+                }\n+            },\n+            None => None,\n+        };\n+    }\n+\n+    #[allow(clippy::blocks_in_if_conditions)]\n+    Some(11).filter(|&x| {\n+                println!(\"foo\");\n+                x > 10 && x < 100\n+            });\n+\n+    match Some(12) {\n+        // Don't Lint, statement is lost by `.filter`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(13) {\n+        // Don't Lint, because of `None => Some(1)`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => Some(1),\n+    };\n+\n+    unsafe fn f(x: u32) -> bool {\n+        true\n+    }\n+    let _ = Some(14).filter(|&x| unsafe { f(x) });\n+    let _ = Some(15).filter(|&x| unsafe { f(x) });\n+\n+    #[allow(clippy::redundant_pattern_matching)]\n+    if let Some(_) = Some(16) {\n+        Some(16)\n+    } else { Some(16).filter(|&x| x % 2 == 0) };\n+\n+    match Some((17, 17)) {\n+        // Not linted for now could be\n+        Some((x, y)) => {\n+            if y != x {\n+                Some((x, y))\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    struct NamedTuple {\n+        pub x: u8,\n+        pub y: (i32, u32),\n+    }\n+\n+    match Some(NamedTuple {\n+        // Not linted for now could be\n+        x: 17,\n+        y: (18, 19),\n+    }) {\n+        Some(NamedTuple { x, y }) => {\n+            if y.1 != x as u32 {\n+                Some(NamedTuple { x, y })\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+}"}, {"sha": "aa9f90f752b1790b1cb3ef52d6052d12221503c6", "filename": "tests/ui/manual_filter.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/tests%2Fui%2Fmanual_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/tests%2Fui%2Fmanual_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_filter.rs?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -0,0 +1,243 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_filter)]\n+#![allow(unused_variables, dead_code)]\n+\n+fn main() {\n+    match Some(0) {\n+        None => None,\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+    };\n+\n+    match Some(1) {\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(2) {\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    match Some(3) {\n+        Some(x) => {\n+            if x > 0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    let y = Some(4);\n+    match y {\n+        // Some(4)\n+        None => None,\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+    };\n+\n+    match Some(5) {\n+        Some(x) => {\n+            if x > 0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    match Some(6) {\n+        Some(ref x) => {\n+            if x > &0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    let external_cond = true;\n+    match Some(String::new()) {\n+        Some(x) => {\n+            if external_cond {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    if let Some(x) = Some(7) {\n+        if external_cond { Some(x) } else { None }\n+    } else {\n+        None\n+    };\n+\n+    match &Some(8) {\n+        &Some(x) => {\n+            if x != 0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    match Some(9) {\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    const fn f1() {\n+        // Don't lint, `.filter` is not const\n+        match Some(10) {\n+            Some(x) => {\n+                if x > 10 && x < 100 {\n+                    Some(x)\n+                } else {\n+                    None\n+                }\n+            },\n+            None => None,\n+        };\n+    }\n+\n+    #[allow(clippy::blocks_in_if_conditions)]\n+    match Some(11) {\n+        // Lint, statement is preserved by `.filter`\n+        Some(x) => {\n+            if {\n+                println!(\"foo\");\n+                x > 10 && x < 100\n+            } {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(12) {\n+        // Don't Lint, statement is lost by `.filter`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(13) {\n+        // Don't Lint, because of `None => Some(1)`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => Some(1),\n+    };\n+\n+    unsafe fn f(x: u32) -> bool {\n+        true\n+    }\n+    let _ = match Some(14) {\n+        Some(x) => {\n+            if unsafe { f(x) } {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+    let _ = match Some(15) {\n+        Some(x) => unsafe {\n+            if f(x) { Some(x) } else { None }\n+        },\n+        None => None,\n+    };\n+\n+    #[allow(clippy::redundant_pattern_matching)]\n+    if let Some(_) = Some(16) {\n+        Some(16)\n+    } else if let Some(x) = Some(16) {\n+        // Lint starting from here\n+        if x % 2 == 0 { Some(x) } else { None }\n+    } else {\n+        None\n+    };\n+\n+    match Some((17, 17)) {\n+        // Not linted for now could be\n+        Some((x, y)) => {\n+            if y != x {\n+                Some((x, y))\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    struct NamedTuple {\n+        pub x: u8,\n+        pub y: (i32, u32),\n+    }\n+\n+    match Some(NamedTuple {\n+        // Not linted for now could be\n+        x: 17,\n+        y: (18, 19),\n+    }) {\n+        Some(NamedTuple { x, y }) => {\n+            if y.1 != x as u32 {\n+                Some(NamedTuple { x, y })\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+}"}, {"sha": "53dea9229306bb2dc2ac21f4eedc46ed8e735e19", "filename": "tests/ui/manual_filter.stderr", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/292e313259f422c8f4c31ecaedcc14058e8f4f8b/tests%2Fui%2Fmanual_filter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/292e313259f422c8f4c31ecaedcc14058e8f4f8b/tests%2Fui%2Fmanual_filter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_filter.stderr?ref=292e313259f422c8f4c31ecaedcc14058e8f4f8b", "patch": "@@ -0,0 +1,191 @@\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:7:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         None => None,\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+...  |\n+LL | |         },\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).filter(|&x| x <= 0)`\n+   |\n+   = note: `-D clippy::manual-filter` implied by `-D warnings`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:18:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 None\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(1).filter(|&x| x <= 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:29:5\n+   |\n+LL | /     match Some(2) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 None\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(2).filter(|&x| x <= 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:40:5\n+   |\n+LL | /     match Some(3) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(3).filter(|&x| x > 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:52:5\n+   |\n+LL | /     match y {\n+LL | |         // Some(4)\n+LL | |         None => None,\n+LL | |         Some(x) => {\n+...  |\n+LL | |         },\n+LL | |     };\n+   | |_____^ help: try this: `y.filter(|&x| x <= 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:64:5\n+   |\n+LL | /     match Some(5) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(5).filter(|&x| x > 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:75:5\n+   |\n+LL | /     match Some(6) {\n+LL | |         Some(ref x) => {\n+LL | |             if x > &0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(6).as_ref().filter(|&x| x > &0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:87:5\n+   |\n+LL | /     match Some(String::new()) {\n+LL | |         Some(x) => {\n+LL | |             if external_cond {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(String::new()).filter(|x| external_cond)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:98:5\n+   |\n+LL | /     if let Some(x) = Some(7) {\n+LL | |         if external_cond { Some(x) } else { None }\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^ help: try this: `Some(7).filter(|&x| external_cond)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:104:5\n+   |\n+LL | /     match &Some(8) {\n+LL | |         &Some(x) => {\n+LL | |             if x != 0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(8).filter(|&x| x != 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:115:5\n+   |\n+LL | /     match Some(9) {\n+LL | |         Some(x) => {\n+LL | |             if x > 10 && x < 100 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(9).filter(|&x| x > 10 && x < 100)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:141:5\n+   |\n+LL | /     match Some(11) {\n+LL | |         // Lint, statement is preserved by `.filter`\n+LL | |         Some(x) => {\n+LL | |             if {\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     Some(11).filter(|&x| {\n+LL +                 println!(\"foo\");\n+LL +                 x > 10 && x < 100\n+LL ~             });\n+   |\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:185:13\n+   |\n+LL |       let _ = match Some(14) {\n+   |  _____________^\n+LL | |         Some(x) => {\n+LL | |             if unsafe { f(x) } {\n+LL | |                 Some(x)\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(14).filter(|&x| unsafe { f(x) })`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:195:13\n+   |\n+LL |       let _ = match Some(15) {\n+   |  _____________^\n+LL | |         Some(x) => unsafe {\n+LL | |             if f(x) { Some(x) } else { None }\n+LL | |         },\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(15).filter(|&x| unsafe { f(x) })`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:205:12\n+   |\n+LL |       } else if let Some(x) = Some(16) {\n+   |  ____________^\n+LL | |         // Lint starting from here\n+LL | |         if x % 2 == 0 { Some(x) } else { None }\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^ help: try this: `{ Some(16).filter(|&x| x % 2 == 0) }`\n+\n+error: aborting due to 15 previous errors\n+"}]}