{"sha": "d3efedb752bb2198796603d8a479a5e3ee472a97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZWZlZGI3NTJiYjIxOTg3OTY2MDNkOGE0NzlhNWUzZWU0NzJhOTc=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-07T16:43:10Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-07T16:43:10Z"}, "message": "Merge #1253\n\n1253: Share literal validation logic with compiler r=matklad a=matklad\n\nThis is neat: the unescape module is literary what compiler is using right now:\r\n\r\nhttps://github.com/rust-lang/rust/blob/c6ac57564852cb6e2d0db60f7b46d9eb98d4b449/src/libsyntax/parse/unescape.rs\r\n\r\nSo, yeah, code sharing via copy-paste!\r\n\r\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "ca6a4aee6ad4077a869a932a18c6c8d134406f8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca6a4aee6ad4077a869a932a18c6c8d134406f8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3efedb752bb2198796603d8a479a5e3ee472a97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3efedb752bb2198796603d8a479a5e3ee472a97", "html_url": "https://github.com/rust-lang/rust/commit/d3efedb752bb2198796603d8a479a5e3ee472a97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3efedb752bb2198796603d8a479a5e3ee472a97/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "ef782adc293deb287128f005dbab2038ba3ccdc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef782adc293deb287128f005dbab2038ba3ccdc1", "html_url": "https://github.com/rust-lang/rust/commit/ef782adc293deb287128f005dbab2038ba3ccdc1"}, {"sha": "313314e14b629ebf50389dbd2d440bda922f6ae7", "url": "https://api.github.com/repos/rust-lang/rust/commits/313314e14b629ebf50389dbd2d440bda922f6ae7", "html_url": "https://github.com/rust-lang/rust/commit/313314e14b629ebf50389dbd2d440bda922f6ae7"}], "stats": {"total": 1821, "additions": 620, "deletions": 1201}, "files": [{"sha": "39c25dbdc71deee83557fbe671062b6632f3e158", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3efedb752bb2198796603d8a479a5e3ee472a97/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3efedb752bb2198796603d8a479a5e3ee472a97/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=d3efedb752bb2198796603d8a479a5e3ee472a97", "patch": "@@ -23,7 +23,6 @@ mod syntax_node;\n mod syntax_text;\n mod syntax_error;\n mod parsing;\n-mod string_lexing;\n mod validation;\n mod ptr;\n "}, {"sha": "4c3eea3d2e9d62b74be5bec29a4a42b1ef229948", "filename": "crates/ra_syntax/src/string_lexing.rs", "status": "removed", "additions": 0, "deletions": 333, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -1,333 +0,0 @@\n-use crate::{TextRange, TextUnit};\n-use self::StringComponentKind::*;\n-\n-#[derive(Debug, Eq, PartialEq, Clone)]\n-pub(crate) struct StringComponent {\n-    pub(crate) range: TextRange,\n-    pub(crate) kind: StringComponentKind,\n-}\n-\n-#[derive(Debug, Eq, PartialEq, Clone)]\n-pub(crate) enum StringComponentKind {\n-    IgnoreNewline,\n-    CodePoint,\n-    AsciiEscape,\n-    AsciiCodeEscape,\n-    UnicodeEscape,\n-}\n-\n-pub(crate) fn parse_quoted_literal(\n-    prefix: Option<char>,\n-    quote: char,\n-    src: &str,\n-) -> StringComponentIter {\n-    let prefix = prefix.map(|p| match p {\n-        'b' => b'b',\n-        _ => panic!(\"invalid prefix\"),\n-    });\n-    let quote = match quote {\n-        '\\'' => b'\\'',\n-        '\"' => b'\"',\n-        _ => panic!(\"invalid quote\"),\n-    };\n-    StringComponentIter { src, prefix, quote, pos: 0, has_closing_quote: false, suffix: None }\n-}\n-\n-pub(crate) struct StringComponentIter<'a> {\n-    src: &'a str,\n-    prefix: Option<u8>,\n-    quote: u8,\n-    pos: usize,\n-    pub(crate) has_closing_quote: bool,\n-    pub(crate) suffix: Option<TextRange>,\n-}\n-\n-impl<'a> Iterator for StringComponentIter<'a> {\n-    type Item = StringComponent;\n-    fn next(&mut self) -> Option<StringComponent> {\n-        if self.pos == 0 {\n-            if let Some(prefix) = self.prefix {\n-                assert!(\n-                    self.advance() == prefix as char,\n-                    \"literal should start with a {:?}\",\n-                    prefix as char,\n-                );\n-            }\n-            assert!(\n-                self.advance() == self.quote as char,\n-                \"literal should start with a {:?}\",\n-                self.quote as char,\n-            );\n-        }\n-\n-        if let Some(component) = self.parse_component() {\n-            return Some(component);\n-        }\n-\n-        // We get here when there are no char components left to parse\n-        if self.peek() == Some(self.quote as char) {\n-            self.advance();\n-            self.has_closing_quote = true;\n-            if let Some(range) = self.parse_suffix() {\n-                self.suffix = Some(range);\n-            }\n-        }\n-\n-        assert!(\n-            self.peek() == None,\n-            \"literal should leave no unparsed input: src = {:?}, pos = {}, length = {}\",\n-            self.src,\n-            self.pos,\n-            self.src.len()\n-        );\n-\n-        None\n-    }\n-}\n-\n-impl<'a> StringComponentIter<'a> {\n-    fn peek(&self) -> Option<char> {\n-        if self.pos == self.src.len() {\n-            return None;\n-        }\n-\n-        self.src[self.pos..].chars().next()\n-    }\n-\n-    fn advance(&mut self) -> char {\n-        let next = self.peek().expect(\"cannot advance if end of input is reached\");\n-        self.pos += next.len_utf8();\n-        next\n-    }\n-\n-    fn parse_component(&mut self) -> Option<StringComponent> {\n-        let next = self.peek()?;\n-\n-        // Ignore string close\n-        if next == self.quote as char {\n-            return None;\n-        }\n-\n-        let start = self.start_range();\n-        self.advance();\n-\n-        if next == '\\\\' {\n-            // Strings can use `\\` to ignore newlines, so we first try to parse one of those\n-            // before falling back to parsing char escapes\n-            if self.quote == b'\"' {\n-                if let Some(component) = self.parse_ignore_newline(start) {\n-                    return Some(component);\n-                }\n-            }\n-\n-            Some(self.parse_escape(start))\n-        } else {\n-            Some(self.finish_component(start, CodePoint))\n-        }\n-    }\n-\n-    fn parse_ignore_newline(&mut self, start: TextUnit) -> Option<StringComponent> {\n-        // In string literals, when a `\\` occurs immediately before the newline, the `\\`,\n-        // the newline, and all whitespace at the beginning of the next line are ignored\n-        match self.peek() {\n-            Some('\\n') | Some('\\r') => {\n-                self.skip_whitespace();\n-                Some(self.finish_component(start, IgnoreNewline))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    fn skip_whitespace(&mut self) {\n-        while self.peek().map(|c| c.is_whitespace()) == Some(true) {\n-            self.advance();\n-        }\n-    }\n-\n-    fn parse_escape(&mut self, start: TextUnit) -> StringComponent {\n-        if self.peek().is_none() {\n-            return self.finish_component(start, AsciiEscape);\n-        }\n-\n-        let next = self.advance();\n-        match next {\n-            'x' => self.parse_ascii_code_escape(start),\n-            'u' => self.parse_unicode_escape(start),\n-            _ => self.finish_component(start, AsciiEscape),\n-        }\n-    }\n-\n-    fn parse_unicode_escape(&mut self, start: TextUnit) -> StringComponent {\n-        match self.peek() {\n-            Some('{') => {\n-                self.advance();\n-\n-                // Parse anything until we reach `}`\n-                while let Some(next) = self.peek() {\n-                    self.advance();\n-                    if next == '}' {\n-                        break;\n-                    }\n-                }\n-\n-                self.finish_component(start, UnicodeEscape)\n-            }\n-            Some(_) | None => self.finish_component(start, UnicodeEscape),\n-        }\n-    }\n-\n-    fn parse_ascii_code_escape(&mut self, start: TextUnit) -> StringComponent {\n-        let code_start = self.pos;\n-        while let Some(next) = self.peek() {\n-            if next == '\\'' || (self.pos - code_start == 2) {\n-                break;\n-            }\n-\n-            self.advance();\n-        }\n-        self.finish_component(start, AsciiCodeEscape)\n-    }\n-\n-    fn parse_suffix(&mut self) -> Option<TextRange> {\n-        let start = self.start_range();\n-        let _ = self.peek()?;\n-        while let Some(_) = self.peek() {\n-            self.advance();\n-        }\n-        Some(self.finish_range(start))\n-    }\n-\n-    fn start_range(&self) -> TextUnit {\n-        TextUnit::from_usize(self.pos)\n-    }\n-\n-    fn finish_range(&self, start: TextUnit) -> TextRange {\n-        TextRange::from_to(start, TextUnit::from_usize(self.pos))\n-    }\n-\n-    fn finish_component(&self, start: TextUnit, kind: StringComponentKind) -> StringComponent {\n-        let range = self.finish_range(start);\n-        StringComponent { range, kind }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    fn parse(src: &str) -> (bool, Vec<StringComponent>) {\n-        let component_iterator = &mut parse_quoted_literal(None, '\\'', src);\n-        let components: Vec<_> = component_iterator.collect();\n-        (component_iterator.has_closing_quote, components)\n-    }\n-\n-    fn unclosed_char_component(src: &str) -> StringComponent {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(!has_closing_quote, \"char should not have closing quote\");\n-        assert!(components.len() == 1);\n-        components[0].clone()\n-    }\n-\n-    fn closed_char_component(src: &str) -> StringComponent {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        assert!(components.len() == 1, \"Literal: {}\\nComponents: {:#?}\", src, components);\n-        components[0].clone()\n-    }\n-\n-    fn closed_char_components(src: &str) -> Vec<StringComponent> {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        components\n-    }\n-\n-    fn range_closed(src: &str) -> TextRange {\n-        TextRange::from_to(1.into(), (src.len() as u32 - 1).into())\n-    }\n-\n-    fn range_unclosed(src: &str) -> TextRange {\n-        TextRange::from_to(1.into(), (src.len() as u32).into())\n-    }\n-\n-    #[test]\n-    fn test_unicode_escapes() {\n-        let unicode_escapes = &[r\"{DEAD}\", \"{BEEF}\", \"{FF}\", \"{}\", \"\"];\n-        for escape in unicode_escapes {\n-            let escape_sequence = format!(r\"'\\u{}'\", escape);\n-            let component = closed_char_component(&escape_sequence);\n-            let expected_range = range_closed(&escape_sequence);\n-            assert_eq!(component.kind, UnicodeEscape);\n-            assert_eq!(component.range, expected_range);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_escapes_unclosed() {\n-        let unicode_escapes = &[\"{DEAD\", \"{BEEF\", \"{FF\"];\n-        for escape in unicode_escapes {\n-            let escape_sequence = format!(r\"'\\u{}'\", escape);\n-            let component = unclosed_char_component(&escape_sequence);\n-            let expected_range = range_unclosed(&escape_sequence);\n-            assert_eq!(component.kind, UnicodeEscape);\n-            assert_eq!(component.range, expected_range);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_empty_char() {\n-        let (has_closing_quote, components) = parse(\"''\");\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        assert!(components.len() == 0);\n-    }\n-\n-    #[test]\n-    fn test_unclosed_char() {\n-        let component = unclosed_char_component(\"'a\");\n-        assert!(component.kind == CodePoint);\n-        assert!(component.range == TextRange::from_to(1.into(), 2.into()));\n-    }\n-\n-    #[test]\n-    fn test_digit_escapes() {\n-        let literals = &[r\"\", r\"5\", r\"55\"];\n-\n-        for literal in literals {\n-            let lit_text = format!(r\"'\\x{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == AsciiCodeEscape);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-\n-        // More than 2 digits starts a new codepoint\n-        let components = closed_char_components(r\"'\\x555'\");\n-        assert!(components.len() == 2);\n-        assert!(components[1].kind == CodePoint);\n-    }\n-\n-    #[test]\n-    fn test_ascii_escapes() {\n-        let literals = &[\n-            r\"\\'\", \"\\\\\\\"\", // equivalent to \\\"\n-            r\"\\n\", r\"\\r\", r\"\\t\", r\"\\\\\", r\"\\0\",\n-        ];\n-\n-        for literal in literals {\n-            let lit_text = format!(\"'{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == AsciiEscape);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_no_escapes() {\n-        let literals = &['\"', 'n', 'r', 't', '0', 'x', 'u'];\n-\n-        for &literal in literals {\n-            let lit_text = format!(\"'{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == CodePoint);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-    }\n-}"}, {"sha": "27e12293be2e740662cd92042fa7695e3646cf83", "filename": "crates/ra_syntax/src/syntax_error.rs", "status": "modified", "additions": 45, "deletions": 59, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d3efedb752bb2198796603d8a479a5e3ee472a97/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3efedb752bb2198796603d8a479a5e3ee472a97/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs?ref=d3efedb752bb2198796603d8a479a5e3ee472a97", "patch": "@@ -2,7 +2,10 @@ use std::fmt;\n \n use ra_parser::ParseError;\n \n-use crate::{TextRange, TextUnit};\n+use crate::{\n+    TextRange, TextUnit,\n+    validation::EscapeError,\n+};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SyntaxError {\n@@ -67,32 +70,7 @@ impl fmt::Display for SyntaxError {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum SyntaxErrorKind {\n     ParseError(ParseError),\n-    UnescapedCodepoint,\n-    EmptyChar,\n-    UnclosedChar,\n-    OverlongChar,\n-    EmptyByte,\n-    UnclosedByte,\n-    OverlongByte,\n-    ByteOutOfRange,\n-    UnescapedByte,\n-    EmptyByteEscape,\n-    InvalidByteEscape,\n-    TooShortByteCodeEscape,\n-    MalformedByteCodeEscape,\n-    UnicodeEscapeForbidden,\n-    EmptyAsciiEscape,\n-    InvalidAsciiEscape,\n-    TooShortAsciiCodeEscape,\n-    AsciiCodeEscapeOutOfRange,\n-    MalformedAsciiCodeEscape,\n-    UnclosedUnicodeEscape,\n-    MalformedUnicodeEscape,\n-    EmptyUnicodeEcape,\n-    OverlongUnicodeEscape,\n-    UnicodeEscapeOutOfRange,\n-    UnclosedString,\n-    InvalidSuffix,\n+    EscapeError(EscapeError),\n     InvalidBlockAttr,\n     InvalidMatchInnerAttr,\n     InvalidTupleIndexFormat,\n@@ -102,38 +80,6 @@ impl fmt::Display for SyntaxErrorKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use self::SyntaxErrorKind::*;\n         match self {\n-            UnescapedCodepoint => write!(f, \"This codepoint should always be escaped\"),\n-            EmptyAsciiEscape => write!(f, \"Empty escape sequence\"),\n-            InvalidAsciiEscape => write!(f, \"Invalid escape sequence\"),\n-            EmptyChar => write!(f, \"Empty char literal\"),\n-            UnclosedChar => write!(f, \"Unclosed char literal\"),\n-            OverlongChar => write!(f, \"Char literal should be one character long\"),\n-            EmptyByte => write!(f, \"Empty byte literal\"),\n-            UnclosedByte => write!(f, \"Unclosed byte literal\"),\n-            OverlongByte => write!(f, \"Byte literal should be one character long\"),\n-            ByteOutOfRange => write!(f, \"Byte should be a valid ASCII character\"),\n-            UnescapedByte => write!(f, \"This byte should always be escaped\"),\n-            EmptyByteEscape => write!(f, \"Empty escape sequence\"),\n-            InvalidByteEscape => write!(f, \"Invalid escape sequence\"),\n-            TooShortByteCodeEscape => write!(f, \"Escape sequence should have two digits\"),\n-            MalformedByteCodeEscape => write!(f, \"Escape sequence should be a hexadecimal number\"),\n-            UnicodeEscapeForbidden => {\n-                write!(f, \"Unicode escapes are not allowed in byte literals or byte strings\")\n-            }\n-            TooShortAsciiCodeEscape => write!(f, \"Escape sequence should have two digits\"),\n-            AsciiCodeEscapeOutOfRange => {\n-                write!(f, \"Escape sequence should be between \\\\x00 and \\\\x7F\")\n-            }\n-            MalformedAsciiCodeEscape => write!(f, \"Escape sequence should be a hexadecimal number\"),\n-            UnclosedUnicodeEscape => write!(f, \"Missing `}}`\"),\n-            MalformedUnicodeEscape => write!(f, \"Malformed unicode escape sequence\"),\n-            EmptyUnicodeEcape => write!(f, \"Empty unicode escape sequence\"),\n-            OverlongUnicodeEscape => {\n-                write!(f, \"Unicode escape sequence should have at most 6 digits\")\n-            }\n-            UnicodeEscapeOutOfRange => write!(f, \"Unicode escape code should be at most 0x10FFFF\"),\n-            UnclosedString => write!(f, \"Unclosed string literal\"),\n-            InvalidSuffix => write!(f, \"Invalid literal suffix\"),\n             InvalidBlockAttr => {\n                 write!(f, \"A block in this position cannot accept inner attributes\")\n             }\n@@ -144,6 +90,46 @@ impl fmt::Display for SyntaxErrorKind {\n                 write!(f, \"Tuple (struct) field access is only allowed through decimal integers with no underscores or suffix\")\n             }\n             ParseError(msg) => write!(f, \"{}\", msg.0),\n+            EscapeError(err) => write!(f, \"{}\", err),\n         }\n     }\n }\n+\n+impl fmt::Display for EscapeError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let msg = match self {\n+            EscapeError::ZeroChars => \"Empty literal\",\n+            EscapeError::MoreThanOneChar => \"Literal should be one character long\",\n+            EscapeError::LoneSlash => \"Character must be escaped: '\\\\'\",\n+            EscapeError::InvalidEscape => \"Invalid escape sequence\",\n+            EscapeError::BareCarriageReturn => \"Character must be escaped: '\\r'\",\n+            EscapeError::EscapeOnlyChar => \"Character must be escaped\",\n+            EscapeError::TooShortHexEscape => \"Escape sequence should have two digits\",\n+            EscapeError::InvalidCharInHexEscape => \"Escape sequence should be a hexadecimal number\",\n+            EscapeError::OutOfRangeHexEscape => \"Escape sequence should be ASCII\",\n+            EscapeError::NoBraceInUnicodeEscape => \"Invalid escape sequence\",\n+            EscapeError::InvalidCharInUnicodeEscape => \"Invalid escape sequence\",\n+            EscapeError::EmptyUnicodeEscape => \"Invalid escape sequence\",\n+            EscapeError::UnclosedUnicodeEscape => \"Missing '}'\",\n+            EscapeError::LeadingUnderscoreUnicodeEscape => \"Invalid escape sequence\",\n+            EscapeError::OverlongUnicodeEscape => {\n+                \"Unicode escape sequence should have at most 6 digits\"\n+            }\n+            EscapeError::LoneSurrogateUnicodeEscape => {\n+                \"Unicode escape code should not be a surrogate\"\n+            }\n+            EscapeError::OutOfRangeUnicodeEscape => {\n+                \"Unicode escape code should be at most 0x10FFFF\"\n+            }\n+            EscapeError::UnicodeEscapeInByte => \"Unicode escapes are not allowed in bytes\",\n+            EscapeError::NonAsciiCharInByte => \"Non ASCII characters are not allowed in bytes\",\n+        };\n+        write!(f, \"{}\", msg)\n+    }\n+}\n+\n+impl From<EscapeError> for SyntaxErrorKind {\n+    fn from(err: EscapeError) -> Self {\n+        SyntaxErrorKind::EscapeError(err)\n+    }\n+}"}, {"sha": "11a1fb4a73a23c4327dec503bc7a2bea8f1d3c92", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d3efedb752bb2198796603d8a479a5e3ee472a97/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3efedb752bb2198796603d8a479a5e3ee472a97/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=d3efedb752bb2198796603d8a479a5e3ee472a97", "patch": "@@ -1,17 +1,17 @@\n-mod byte;\n-mod byte_string;\n-mod char;\n-mod string;\n+mod unescape;\n+\n mod block;\n mod field_expr;\n \n use crate::{\n-    SourceFile, SyntaxError, AstNode, SyntaxNode,\n+    SourceFile, SyntaxError, AstNode, SyntaxNode, TextUnit,\n     SyntaxKind::{L_CURLY, R_CURLY, BYTE, BYTE_STRING, STRING, CHAR},\n     ast,\n     algo::visit::{visitor_ctx, VisitorCtx},\n };\n \n+pub(crate) use unescape::EscapeError;\n+\n pub(crate) fn validate(file: &SourceFile) -> Vec<SyntaxError> {\n     let mut errors = Vec::new();\n     for node in file.syntax().descendants() {\n@@ -26,11 +26,55 @@ pub(crate) fn validate(file: &SourceFile) -> Vec<SyntaxError> {\n \n // FIXME: kill duplication\n fn validate_literal(literal: &ast::Literal, acc: &mut Vec<SyntaxError>) {\n-    match literal.token().kind() {\n-        BYTE => byte::validate_byte_node(literal.token(), acc),\n-        BYTE_STRING => byte_string::validate_byte_string_node(literal.token(), acc),\n-        STRING => string::validate_string_node(literal.token(), acc),\n-        CHAR => char::validate_char_node(literal.token(), acc),\n+    let token = literal.token();\n+    let text = token.text().as_str();\n+    match token.kind() {\n+        BYTE => {\n+            if let Some(end) = text.rfind('\\'') {\n+                if let Some(without_quotes) = text.get(2..end) {\n+                    if let Err((off, err)) = unescape::unescape_byte(without_quotes) {\n+                        let off = token.range().start() + TextUnit::from_usize(off + 2);\n+                        acc.push(SyntaxError::new(err.into(), off))\n+                    }\n+                }\n+            }\n+        }\n+        CHAR => {\n+            if let Some(end) = text.rfind('\\'') {\n+                if let Some(without_quotes) = text.get(1..end) {\n+                    if let Err((off, err)) = unescape::unescape_char(without_quotes) {\n+                        let off = token.range().start() + TextUnit::from_usize(off + 1);\n+                        acc.push(SyntaxError::new(err.into(), off))\n+                    }\n+                }\n+            }\n+        }\n+        BYTE_STRING => {\n+            if let Some(end) = text.rfind('\\\"') {\n+                if let Some(without_quotes) = text.get(2..end) {\n+                    unescape::unescape_byte_str(without_quotes, &mut |range, char| {\n+                        if let Err(err) = char {\n+                            let off = range.start;\n+                            let off = token.range().start() + TextUnit::from_usize(off + 2);\n+                            acc.push(SyntaxError::new(err.into(), off))\n+                        }\n+                    })\n+                }\n+            }\n+        }\n+        STRING => {\n+            if let Some(end) = text.rfind('\\\"') {\n+                if let Some(without_quotes) = text.get(1..end) {\n+                    unescape::unescape_str(without_quotes, &mut |range, char| {\n+                        if let Err(err) = char {\n+                            let off = range.start;\n+                            let off = token.range().start() + TextUnit::from_usize(off + 1);\n+                            acc.push(SyntaxError::new(err.into(), off))\n+                        }\n+                    })\n+                }\n+            }\n+        }\n         _ => (),\n     }\n }"}, {"sha": "f653e65d033f9931d95813b52a3c46dc721b1f19", "filename": "crates/ra_syntax/src/validation/byte.rs", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -1,199 +0,0 @@\n-//! Validation of byte literals\n-\n-use crate::{\n-    string_lexing::{self, StringComponentKind},\n-    TextRange,\n-    validation::char,\n-    SyntaxError,\n-    SyntaxErrorKind::*,\n-    SyntaxToken,\n-};\n-\n-pub(super) fn validate_byte_node(node: SyntaxToken, errors: &mut Vec<SyntaxError>) {\n-    let literal_text = node.text();\n-    let literal_range = node.range();\n-    let mut components = string_lexing::parse_quoted_literal(Some('b'), '\\'', literal_text);\n-    let mut len = 0;\n-    for component in &mut components {\n-        len += 1;\n-        let text = &literal_text[component.range];\n-        let range = component.range + literal_range.start();\n-        validate_byte_component(text, component.kind, range, errors);\n-    }\n-\n-    if !components.has_closing_quote {\n-        errors.push(SyntaxError::new(UnclosedByte, literal_range));\n-    }\n-\n-    if let Some(range) = components.suffix {\n-        errors.push(SyntaxError::new(InvalidSuffix, range + literal_range.start()));\n-    }\n-\n-    if len == 0 {\n-        errors.push(SyntaxError::new(EmptyByte, literal_range));\n-    }\n-\n-    if len > 1 {\n-        errors.push(SyntaxError::new(OverlongByte, literal_range));\n-    }\n-}\n-\n-pub(super) fn validate_byte_component(\n-    text: &str,\n-    kind: StringComponentKind,\n-    range: TextRange,\n-    errors: &mut Vec<SyntaxError>,\n-) {\n-    use self::StringComponentKind::*;\n-    match kind {\n-        AsciiEscape => validate_byte_escape(text, range, errors),\n-        AsciiCodeEscape => validate_byte_code_escape(text, range, errors),\n-        UnicodeEscape => errors.push(SyntaxError::new(UnicodeEscapeForbidden, range)),\n-        CodePoint => {\n-            let c = text.chars().next().expect(\"Code points should be one character long\");\n-\n-            // These bytes must always be escaped\n-            if c == '\\t' || c == '\\r' || c == '\\n' {\n-                errors.push(SyntaxError::new(UnescapedByte, range));\n-            }\n-\n-            // Only ASCII bytes are allowed\n-            if c > 0x7F as char {\n-                errors.push(SyntaxError::new(ByteOutOfRange, range));\n-            }\n-        }\n-        IgnoreNewline => { /* always valid */ }\n-    }\n-}\n-\n-fn validate_byte_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n-    if text.len() == 1 {\n-        // Escape sequence consists only of leading `\\`\n-        errors.push(SyntaxError::new(EmptyByteEscape, range));\n-    } else {\n-        let escape_code = text.chars().skip(1).next().unwrap();\n-        if !char::is_ascii_escape(escape_code) {\n-            errors.push(SyntaxError::new(InvalidByteEscape, range));\n-        }\n-    }\n-}\n-\n-fn validate_byte_code_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n-    // A ByteCodeEscape has 4 chars, example: `\\xDD`\n-    if !text.is_ascii() {\n-        errors.push(SyntaxError::new(MalformedByteCodeEscape, range));\n-    } else if text.chars().count() < 4 {\n-        errors.push(SyntaxError::new(TooShortByteCodeEscape, range));\n-    } else {\n-        assert!(text.chars().count() == 4, \"ByteCodeEscape cannot be longer than 4 chars\");\n-\n-        if u8::from_str_radix(&text[2..], 16).is_err() {\n-            errors.push(SyntaxError::new(MalformedByteCodeEscape, range));\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use crate::{SourceFile, TreeArc};\n-\n-    fn build_file(literal: &str) -> TreeArc<SourceFile> {\n-        let src = format!(\"const C: u8 = b'{}';\", literal);\n-        SourceFile::parse(&src)\n-    }\n-\n-    fn assert_valid_byte(literal: &str) {\n-        let file = build_file(literal);\n-        assert!(file.errors().len() == 0, \"Errors for literal '{}': {:?}\", literal, file.errors());\n-    }\n-\n-    fn assert_invalid_byte(literal: &str) {\n-        let file = build_file(literal);\n-        assert!(file.errors().len() > 0);\n-    }\n-\n-    #[test]\n-    fn test_ansi_codepoints() {\n-        for byte in 0..128 {\n-            match byte {\n-                b'\\n' | b'\\r' | b'\\t' => assert_invalid_byte(&(byte as char).to_string()),\n-                b'\\'' | b'\\\\' => { /* Ignore character close and backslash */ }\n-                _ => assert_valid_byte(&(byte as char).to_string()),\n-            }\n-        }\n-\n-        for byte in 128..=255u8 {\n-            assert_invalid_byte(&(byte as char).to_string());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_codepoints() {\n-        let invalid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n-        for c in &invalid {\n-            assert_invalid_byte(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_multiple_codepoints() {\n-        let invalid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n-        for c in &invalid {\n-            assert_invalid_byte(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_byte_escape() {\n-        let valid = [r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\"];\n-        for c in &valid {\n-            assert_valid_byte(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_byte_escape() {\n-        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n-        for c in &invalid {\n-            assert_invalid_byte(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_byte_code_escape() {\n-        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\", r\"\\xF0\"];\n-        for c in &valid {\n-            assert_valid_byte(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_byte_code_escape() {\n-        let invalid = [r\"\\x\", r\"\\x7\"];\n-        for c in &invalid {\n-            assert_invalid_byte(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_unicode_escape() {\n-        let well_formed = [r\"\\u{FF}\", r\"\\u{0}\", r\"\\u{F}\", r\"\\u{10FFFF}\", r\"\\u{1_0__FF___FF_____}\"];\n-        for c in &well_formed {\n-            assert_invalid_byte(c);\n-        }\n-\n-        let invalid = [\n-            r\"\\u\",\n-            r\"\\u{}\",\n-            r\"\\u{\",\n-            r\"\\u{FF\",\n-            r\"\\u{FFFFFF}\",\n-            r\"\\u{_F}\",\n-            r\"\\u{00FFFFF}\",\n-            r\"\\u{110000}\",\n-        ];\n-        for c in &invalid {\n-            assert_invalid_byte(c);\n-        }\n-    }\n-}"}, {"sha": "1d48c2d9b1674fc7888a8c151fd573592ff9a447", "filename": "crates/ra_syntax/src/validation/byte_string.rs", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -1,169 +0,0 @@\n-use crate::{\n-    string_lexing::{self, StringComponentKind},\n-    SyntaxError,\n-    SyntaxErrorKind::*,\n-    SyntaxToken,\n-};\n-\n-use super::byte;\n-\n-pub(crate) fn validate_byte_string_node(node: SyntaxToken, errors: &mut Vec<SyntaxError>) {\n-    let literal_text = node.text();\n-    let literal_range = node.range();\n-    let mut components = string_lexing::parse_quoted_literal(Some('b'), '\"', literal_text);\n-    for component in &mut components {\n-        let range = component.range + literal_range.start();\n-\n-        match component.kind {\n-            StringComponentKind::IgnoreNewline => { /* always valid */ }\n-            _ => {\n-                // Chars must escape \\t, \\n and \\r codepoints, but strings don't\n-                let text = &literal_text[component.range];\n-                match text {\n-                    \"\\t\" | \"\\n\" | \"\\r\" => { /* always valid */ }\n-                    _ => byte::validate_byte_component(text, component.kind, range, errors),\n-                }\n-            }\n-        }\n-    }\n-\n-    if !components.has_closing_quote {\n-        errors.push(SyntaxError::new(UnclosedString, literal_range));\n-    }\n-\n-    if let Some(range) = components.suffix {\n-        errors.push(SyntaxError::new(InvalidSuffix, range + literal_range.start()));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use crate::{SourceFile, TreeArc};\n-\n-    fn build_file(literal: &str) -> TreeArc<SourceFile> {\n-        let src = format!(r#\"const S: &'static [u8] = b\"{}\";\"#, literal);\n-        println!(\"Source: {}\", src);\n-        SourceFile::parse(&src)\n-    }\n-\n-    fn assert_valid_str(literal: &str) {\n-        let file = build_file(literal);\n-        assert!(file.errors().len() == 0, \"Errors for literal '{}': {:?}\", literal, file.errors());\n-    }\n-\n-    fn assert_invalid_str(literal: &str) {\n-        let file = build_file(literal);\n-        assert!(file.errors().len() > 0);\n-    }\n-\n-    #[test]\n-    fn test_ansi_codepoints() {\n-        for byte in 0..128 {\n-            match byte {\n-                b'\\\"' | b'\\\\' => { /* Ignore string close and backslash */ }\n-                _ => assert_valid_str(&(byte as char).to_string()),\n-            }\n-        }\n-\n-        for byte in 128..=255u8 {\n-            assert_invalid_str(&(byte as char).to_string());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_codepoints() {\n-        let invalid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n-        for c in &invalid {\n-            assert_invalid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_multiple_codepoints() {\n-        let invalid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n-        for c in &invalid {\n-            assert_invalid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_ascii_escape() {\n-        let valid = [r\"\\'\", r#\"\\\"\"#, r\"\\\\\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\"];\n-        for c in &valid {\n-            assert_valid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_ascii_escape() {\n-        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n-        for c in &invalid {\n-            assert_invalid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_ascii_code_escape() {\n-        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\", r\"\\xF0\"];\n-        for c in &valid {\n-            assert_valid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_ascii_code_escape() {\n-        let invalid = [r\"\\x\", r\"\\x7\"];\n-        for c in &invalid {\n-            assert_invalid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_unicode_escape() {\n-        let well_formed = [r\"\\u{FF}\", r\"\\u{0}\", r\"\\u{F}\", r\"\\u{10FFFF}\", r\"\\u{1_0__FF___FF_____}\"];\n-        for c in &well_formed {\n-            assert_invalid_str(c);\n-        }\n-\n-        let invalid = [\n-            r\"\\u\",\n-            r\"\\u{}\",\n-            r\"\\u{\",\n-            r\"\\u{FF\",\n-            r\"\\u{FFFFFF}\",\n-            r\"\\u{_F}\",\n-            r\"\\u{00FFFFF}\",\n-            r\"\\u{110000}\",\n-        ];\n-        for c in &invalid {\n-            assert_invalid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_mixed_invalid() {\n-        assert_invalid_str(\n-            r\"This is the tale of a string\n-with a newline in between, some emoji (\ud83d\udc68\u200d\ud83d\udc68\u200d) here and there,\n-unicode escapes like this: \\u{1FFBB} and weird stuff like\n-this \ufdfd\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_mixed_valid() {\n-        assert_valid_str(\n-            r\"This is the tale of a string\n-with a newline in between, no emoji at all,\n-nor unicode escapes or weird stuff\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_ignore_newline() {\n-        assert_valid_str(\n-            \"Hello \\\n-             World\",\n-        );\n-    }\n-}"}, {"sha": "0f1885873b7258fdd57cbf3ca12f0bf76bc77094", "filename": "crates/ra_syntax/src/validation/char.rs", "status": "removed", "additions": 0, "deletions": 273, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -1,273 +0,0 @@\n-//! Validation of char literals\n-\n-use std::u32;\n-\n-use arrayvec::ArrayString;\n-\n-use crate::{\n-    string_lexing::{self, StringComponentKind},\n-    TextRange,\n-    SyntaxError,\n-    SyntaxErrorKind::*,\n-    SyntaxToken,\n-};\n-\n-pub(super) fn validate_char_node(node: SyntaxToken, errors: &mut Vec<SyntaxError>) {\n-    let literal_text = node.text();\n-    let literal_range = node.range();\n-    let mut components = string_lexing::parse_quoted_literal(None, '\\'', literal_text);\n-    let mut len = 0;\n-    for component in &mut components {\n-        len += 1;\n-        let text = &literal_text[component.range];\n-        let range = component.range + literal_range.start();\n-        validate_char_component(text, component.kind, range, errors);\n-    }\n-\n-    if !components.has_closing_quote {\n-        errors.push(SyntaxError::new(UnclosedChar, literal_range));\n-    }\n-\n-    if let Some(range) = components.suffix {\n-        errors.push(SyntaxError::new(InvalidSuffix, range + literal_range.start()));\n-    }\n-\n-    if len == 0 {\n-        errors.push(SyntaxError::new(EmptyChar, literal_range));\n-    }\n-\n-    if len > 1 {\n-        errors.push(SyntaxError::new(OverlongChar, literal_range));\n-    }\n-}\n-\n-pub(super) fn validate_char_component(\n-    text: &str,\n-    kind: StringComponentKind,\n-    range: TextRange,\n-    errors: &mut Vec<SyntaxError>,\n-) {\n-    // Validate escapes\n-    use self::StringComponentKind::*;\n-    match kind {\n-        AsciiEscape => validate_ascii_escape(text, range, errors),\n-        AsciiCodeEscape => validate_ascii_code_escape(text, range, errors),\n-        UnicodeEscape => validate_unicode_escape(text, range, errors),\n-        CodePoint => {\n-            // These code points must always be escaped\n-            if text == \"\\t\" || text == \"\\r\" || text == \"\\n\" {\n-                errors.push(SyntaxError::new(UnescapedCodepoint, range));\n-            }\n-        }\n-        StringComponentKind::IgnoreNewline => { /* always valid */ }\n-    }\n-}\n-\n-fn validate_ascii_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n-    if text.len() == 1 {\n-        // Escape sequence consists only of leading `\\` (only occurs at EOF, otherwise e.g. '\\' is treated as an unclosed char containing a single quote `'`)\n-        errors.push(SyntaxError::new(EmptyAsciiEscape, range));\n-    } else {\n-        let escape_code = text.chars().skip(1).next().unwrap();\n-        if !is_ascii_escape(escape_code) {\n-            errors.push(SyntaxError::new(InvalidAsciiEscape, range));\n-        }\n-    }\n-}\n-\n-pub(super) fn is_ascii_escape(code: char) -> bool {\n-    match code {\n-        '\\\\' | '\\'' | '\"' | 'n' | 'r' | 't' | '0' => true,\n-        _ => false,\n-    }\n-}\n-\n-fn validate_ascii_code_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n-    // An AsciiCodeEscape has 4 chars, example: `\\xDD`\n-    if !text.is_ascii() {\n-        // FIXME: Give a more precise error message (say what the invalid character was)\n-        errors.push(SyntaxError::new(AsciiCodeEscapeOutOfRange, range));\n-    } else if text.chars().count() < 4 {\n-        errors.push(SyntaxError::new(TooShortAsciiCodeEscape, range));\n-    } else {\n-        assert_eq!(\n-            text.chars().count(),\n-            4,\n-            \"AsciiCodeEscape cannot be longer than 4 chars, but text '{}' is\",\n-            text,\n-        );\n-\n-        match u8::from_str_radix(&text[2..], 16) {\n-            Ok(code) if code < 128 => { /* Escape code is valid */ }\n-            Ok(_) => errors.push(SyntaxError::new(AsciiCodeEscapeOutOfRange, range)),\n-            Err(_) => errors.push(SyntaxError::new(MalformedAsciiCodeEscape, range)),\n-        }\n-    }\n-}\n-\n-fn validate_unicode_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n-    assert!(&text[..2] == \"\\\\u\", \"UnicodeEscape always starts with \\\\u\");\n-\n-    if text.len() == 2 {\n-        // No starting `{`\n-        errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-        return;\n-    }\n-\n-    if text.len() == 3 {\n-        // Only starting `{`\n-        errors.push(SyntaxError::new(UnclosedUnicodeEscape, range));\n-        return;\n-    }\n-\n-    let mut code = ArrayString::<[_; 6]>::new();\n-    let mut closed = false;\n-    for c in text[3..].chars() {\n-        assert!(!closed, \"no characters after escape is closed\");\n-\n-        if c.is_digit(16) {\n-            if code.len() == 6 {\n-                errors.push(SyntaxError::new(OverlongUnicodeEscape, range));\n-                return;\n-            }\n-\n-            code.push(c);\n-        } else if c == '_' {\n-            // Reject leading _\n-            if code.len() == 0 {\n-                errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                return;\n-            }\n-        } else if c == '}' {\n-            closed = true;\n-        } else {\n-            errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-            return;\n-        }\n-    }\n-\n-    if !closed {\n-        errors.push(SyntaxError::new(UnclosedUnicodeEscape, range))\n-    }\n-\n-    if code.len() == 0 {\n-        errors.push(SyntaxError::new(EmptyUnicodeEcape, range));\n-        return;\n-    }\n-\n-    match u32::from_str_radix(&code, 16) {\n-        Ok(code_u32) if code_u32 > 0x10FFFF => {\n-            errors.push(SyntaxError::new(UnicodeEscapeOutOfRange, range));\n-        }\n-        Ok(_) => {\n-            // Valid escape code\n-        }\n-        Err(_) => {\n-            errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use crate::{SourceFile, TreeArc};\n-\n-    fn build_file(literal: &str) -> TreeArc<SourceFile> {\n-        let src = format!(\"const C: char = '{}';\", literal);\n-        SourceFile::parse(&src)\n-    }\n-\n-    fn assert_valid_char(literal: &str) {\n-        let file = build_file(literal);\n-        assert!(file.errors().len() == 0, \"Errors for literal '{}': {:?}\", literal, file.errors());\n-    }\n-\n-    fn assert_invalid_char(literal: &str) {\n-        let file = build_file(literal);\n-        assert!(file.errors().len() > 0);\n-    }\n-\n-    #[test]\n-    fn test_ansi_codepoints() {\n-        for byte in 0..=255u8 {\n-            match byte {\n-                b'\\n' | b'\\r' | b'\\t' => assert_invalid_char(&(byte as char).to_string()),\n-                b'\\'' | b'\\\\' => { /* Ignore character close and backslash */ }\n-                _ => assert_valid_char(&(byte as char).to_string()),\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_codepoints() {\n-        let valid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n-        for c in &valid {\n-            assert_valid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_multiple_codepoints() {\n-        let invalid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n-        for c in &invalid {\n-            assert_invalid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_ascii_escape() {\n-        let valid = [r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\"];\n-        for c in &valid {\n-            assert_valid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_ascii_escape() {\n-        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n-        for c in &invalid {\n-            assert_invalid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_ascii_code_escape() {\n-        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\"];\n-        for c in &valid {\n-            assert_valid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_ascii_code_escape() {\n-        let invalid = [r\"\\x\", r\"\\x7\", r\"\\xF0\"];\n-        for c in &invalid {\n-            assert_invalid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_unicode_escape() {\n-        let valid = [r\"\\u{FF}\", r\"\\u{0}\", r\"\\u{F}\", r\"\\u{10FFFF}\", r\"\\u{1_0__FF___FF_____}\"];\n-        for c in &valid {\n-            assert_valid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_unicode_escape() {\n-        let invalid = [\n-            r\"\\u\",\n-            r\"\\u{}\",\n-            r\"\\u{\",\n-            r\"\\u{FF\",\n-            r\"\\u{FFFFFF}\",\n-            r\"\\u{_F}\",\n-            r\"\\u{00FFFFF}\",\n-            r\"\\u{110000}\",\n-        ];\n-        for c in &invalid {\n-            assert_invalid_char(c);\n-        }\n-    }\n-}"}, {"sha": "fc2f1b992125ce6e759ecc1cc62d35c91f00a12b", "filename": "crates/ra_syntax/src/validation/string.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -1,154 +0,0 @@\n-use crate::{\n-    string_lexing,\n-    SyntaxError,\n-    SyntaxErrorKind::*,\n-    SyntaxToken,\n-};\n-\n-use super::char;\n-\n-pub(crate) fn validate_string_node(node: SyntaxToken, errors: &mut Vec<SyntaxError>) {\n-    let literal_text = node.text();\n-    let literal_range = node.range();\n-    let mut components = string_lexing::parse_quoted_literal(None, '\"', literal_text);\n-    for component in &mut components {\n-        let range = component.range + literal_range.start();\n-\n-        // Chars must escape \\t, \\n and \\r codepoints, but strings don't\n-        let text = &literal_text[component.range];\n-        match text {\n-            \"\\t\" | \"\\n\" | \"\\r\" => { /* always valid */ }\n-            _ => char::validate_char_component(text, component.kind, range, errors),\n-        }\n-    }\n-\n-    if !components.has_closing_quote {\n-        errors.push(SyntaxError::new(UnclosedString, literal_range));\n-    }\n-\n-    if let Some(range) = components.suffix {\n-        errors.push(SyntaxError::new(InvalidSuffix, range + literal_range.start()));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use crate::{SourceFile, TreeArc};\n-\n-    fn build_file(literal: &str) -> TreeArc<SourceFile> {\n-        let src = format!(r#\"const S: &'static str = \"{}\";\"#, literal);\n-        println!(\"Source: {}\", src);\n-        SourceFile::parse(&src)\n-    }\n-\n-    fn assert_valid_str(literal: &str) {\n-        let file = build_file(literal);\n-        assert!(file.errors().len() == 0, \"Errors for literal '{}': {:?}\", literal, file.errors());\n-    }\n-\n-    fn assert_invalid_str(literal: &str) {\n-        let file = build_file(literal);\n-        assert!(file.errors().len() > 0);\n-    }\n-\n-    #[test]\n-    fn test_ansi_codepoints() {\n-        for byte in 0..=255u8 {\n-            match byte {\n-                b'\\\"' | b'\\\\' => { /* Ignore string close and backslash */ }\n-                _ => assert_valid_str(&(byte as char).to_string()),\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_codepoints() {\n-        let valid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n-        for c in &valid {\n-            assert_valid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_multiple_codepoints() {\n-        let valid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n-        for c in &valid {\n-            assert_valid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_ascii_escape() {\n-        let valid = [r\"\\'\", r#\"\\\"\"#, r\"\\\\\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\"];\n-        for c in &valid {\n-            assert_valid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_ascii_escape() {\n-        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n-        for c in &invalid {\n-            assert_invalid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_ascii_code_escape() {\n-        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\"];\n-        for c in &valid {\n-            assert_valid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_ascii_code_escape() {\n-        let invalid = [r\"\\x\", r\"\\x7\", r\"\\xF0\"];\n-        for c in &invalid {\n-            assert_invalid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_unicode_escape() {\n-        let valid = [r\"\\u{FF}\", r\"\\u{0}\", r\"\\u{F}\", r\"\\u{10FFFF}\", r\"\\u{1_0__FF___FF_____}\"];\n-        for c in &valid {\n-            assert_valid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_unicode_escape() {\n-        let invalid = [\n-            r\"\\u\",\n-            r\"\\u{}\",\n-            r\"\\u{\",\n-            r\"\\u{FF\",\n-            r\"\\u{FFFFFF}\",\n-            r\"\\u{_F}\",\n-            r\"\\u{00FFFFF}\",\n-            r\"\\u{110000}\",\n-        ];\n-        for c in &invalid {\n-            assert_invalid_str(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_mixed() {\n-        assert_valid_str(\n-            r\"This is the tale of a string\n-with a newline in between, some emoji (\ud83d\udc68\u200d\ud83d\udc68\u200d) here and there,\n-unicode escapes like this: \\u{1FFBB} and weird stuff like\n-this \ufdfd\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_ignore_newline() {\n-        assert_valid_str(\n-            \"Hello \\\n-             World\",\n-        );\n-    }\n-}"}, {"sha": "2086046b6715364bbdf25eb68c5bcbaa49033d36", "filename": "crates/ra_syntax/src/validation/unescape.rs", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/rust-lang/rust/blob/d3efedb752bb2198796603d8a479a5e3ee472a97/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3efedb752bb2198796603d8a479a5e3ee472a97/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Funescape.rs?ref=d3efedb752bb2198796603d8a479a5e3ee472a97", "patch": "@@ -0,0 +1,521 @@\n+//! Utilities for validating  string and char literals and turning them into\n+//! values they represent.\n+//!\n+//! This file is copy-pasted from the compiler\n+//!\n+//! https://github.com/rust-lang/rust/blob/c6ac57564852cb6e2d0db60f7b46d9eb98d4b449/src/libsyntax/parse/unescape.rs\n+//!\n+//! Hopefully, we'll share this code in a proper way some day\n+\n+use std::str::Chars;\n+use std::ops::Range;\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Hash)]\n+pub enum EscapeError {\n+    ZeroChars,\n+    MoreThanOneChar,\n+\n+    LoneSlash,\n+    InvalidEscape,\n+    BareCarriageReturn,\n+    EscapeOnlyChar,\n+\n+    TooShortHexEscape,\n+    InvalidCharInHexEscape,\n+    OutOfRangeHexEscape,\n+\n+    NoBraceInUnicodeEscape,\n+    InvalidCharInUnicodeEscape,\n+    EmptyUnicodeEscape,\n+    UnclosedUnicodeEscape,\n+    LeadingUnderscoreUnicodeEscape,\n+    OverlongUnicodeEscape,\n+    LoneSurrogateUnicodeEscape,\n+    OutOfRangeUnicodeEscape,\n+\n+    UnicodeEscapeInByte,\n+    NonAsciiCharInByte,\n+}\n+\n+/// Takes a contents of a char literal (without quotes), and returns an\n+/// unescaped char or an error\n+pub(crate) fn unescape_char(literal_text: &str) -> Result<char, (usize, EscapeError)> {\n+    let mut chars = literal_text.chars();\n+    unescape_char_or_byte(&mut chars, Mode::Char)\n+        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+}\n+\n+/// Takes a contents of a string literal (without quotes) and produces a\n+/// sequence of escaped characters or errors.\n+pub(crate) fn unescape_str<F>(literal_text: &str, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+{\n+    unescape_str_or_byte_str(literal_text, Mode::Str, callback)\n+}\n+\n+pub(crate) fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n+    let mut chars = literal_text.chars();\n+    unescape_char_or_byte(&mut chars, Mode::Byte)\n+        .map(byte_from_char)\n+        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+}\n+\n+/// Takes a contents of a string literal (without quotes) and produces a\n+/// sequence of escaped characters or errors.\n+pub(crate) fn unescape_byte_str<F>(literal_text: &str, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<u8, EscapeError>),\n+{\n+    unescape_str_or_byte_str(literal_text, Mode::ByteStr, &mut |range, char| {\n+        callback(range, char.map(byte_from_char))\n+    })\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+pub(crate) enum Mode {\n+    Char,\n+    Str,\n+    Byte,\n+    ByteStr,\n+}\n+\n+impl Mode {\n+    fn in_single_quotes(self) -> bool {\n+        match self {\n+            Mode::Char | Mode::Byte => true,\n+            Mode::Str | Mode::ByteStr => false,\n+        }\n+    }\n+\n+    pub(crate) fn in_double_quotes(self) -> bool {\n+        !self.in_single_quotes()\n+    }\n+\n+    pub(crate) fn is_bytes(self) -> bool {\n+        match self {\n+            Mode::Byte | Mode::ByteStr => true,\n+            Mode::Char | Mode::Str => false,\n+        }\n+    }\n+}\n+\n+fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+    if first_char != '\\\\' {\n+        return match first_char {\n+            '\\t' | '\\n' => Err(EscapeError::EscapeOnlyChar),\n+            '\\r' => Err(if chars.clone().next() == Some('\\n') {\n+                EscapeError::EscapeOnlyChar\n+            } else {\n+                EscapeError::BareCarriageReturn\n+            }),\n+            '\\'' if mode.in_single_quotes() => Err(EscapeError::EscapeOnlyChar),\n+            '\"' if mode.in_double_quotes() => Err(EscapeError::EscapeOnlyChar),\n+            _ => {\n+                if mode.is_bytes() && !first_char.is_ascii() {\n+                    return Err(EscapeError::NonAsciiCharInByte);\n+                }\n+                Ok(first_char)\n+            }\n+        };\n+    }\n+\n+    let second_char = chars.next().ok_or(EscapeError::LoneSlash)?;\n+\n+    let res = match second_char {\n+        '\"' => '\"',\n+        'n' => '\\n',\n+        'r' => '\\r',\n+        't' => '\\t',\n+        '\\\\' => '\\\\',\n+        '\\'' => '\\'',\n+        '0' => '\\0',\n+\n+        'x' => {\n+            let hi = chars.next().ok_or(EscapeError::TooShortHexEscape)?;\n+            let hi = hi.to_digit(16).ok_or(EscapeError::InvalidCharInHexEscape)?;\n+\n+            let lo = chars.next().ok_or(EscapeError::TooShortHexEscape)?;\n+            let lo = lo.to_digit(16).ok_or(EscapeError::InvalidCharInHexEscape)?;\n+\n+            let value = hi * 16 + lo;\n+\n+            if !mode.is_bytes() && !is_ascii(value) {\n+                return Err(EscapeError::OutOfRangeHexEscape);\n+            }\n+            let value = value as u8;\n+\n+            value as char\n+        }\n+\n+        'u' => {\n+            if chars.next() != Some('{') {\n+                return Err(EscapeError::NoBraceInUnicodeEscape);\n+            }\n+\n+            let mut n_digits = 1;\n+            let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n+                '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),\n+                '}' => return Err(EscapeError::EmptyUnicodeEscape),\n+                c => c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?,\n+            };\n+\n+            loop {\n+                match chars.next() {\n+                    None => return Err(EscapeError::UnclosedUnicodeEscape),\n+                    Some('_') => continue,\n+                    Some('}') => {\n+                        if n_digits > 6 {\n+                            return Err(EscapeError::OverlongUnicodeEscape);\n+                        }\n+                        if mode.is_bytes() {\n+                            return Err(EscapeError::UnicodeEscapeInByte);\n+                        }\n+\n+                        break std::char::from_u32(value).ok_or_else(|| {\n+                            if value > 0x10FFFF {\n+                                EscapeError::OutOfRangeUnicodeEscape\n+                            } else {\n+                                EscapeError::LoneSurrogateUnicodeEscape\n+                            }\n+                        })?;\n+                    }\n+                    Some(c) => {\n+                        let digit =\n+                            c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n+                        n_digits += 1;\n+                        if n_digits > 6 {\n+                            continue;\n+                        }\n+                        let digit = digit as u32;\n+                        value = value * 16 + digit;\n+                    }\n+                };\n+            }\n+        }\n+        _ => return Err(EscapeError::InvalidEscape),\n+    };\n+    Ok(res)\n+}\n+\n+fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+    let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n+    let res = scan_escape(first_char, chars, mode)?;\n+    if chars.next().is_some() {\n+        return Err(EscapeError::MoreThanOneChar);\n+    }\n+    Ok(res)\n+}\n+\n+/// Takes a contents of a string literal (without quotes) and produces a\n+/// sequence of escaped characters or errors.\n+fn unescape_str_or_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+{\n+    assert!(mode.in_double_quotes());\n+    let initial_len = src.len();\n+    let mut chars = src.chars();\n+    while let Some(first_char) = chars.next() {\n+        let start = initial_len - chars.as_str().len() - first_char.len_utf8();\n+\n+        let unescaped_char = match first_char {\n+            '\\\\' => {\n+                let (second_char, third_char) = {\n+                    let mut chars = chars.clone();\n+                    (chars.next(), chars.next())\n+                };\n+                match (second_char, third_char) {\n+                    (Some('\\n'), _) | (Some('\\r'), Some('\\n')) => {\n+                        skip_ascii_whitespace(&mut chars);\n+                        continue;\n+                    }\n+                    _ => scan_escape(first_char, &mut chars, mode),\n+                }\n+            }\n+            '\\r' => {\n+                let second_char = chars.clone().next();\n+                if second_char == Some('\\n') {\n+                    chars.next();\n+                    Ok('\\n')\n+                } else {\n+                    scan_escape(first_char, &mut chars, mode)\n+                }\n+            }\n+            '\\n' => Ok('\\n'),\n+            '\\t' => Ok('\\t'),\n+            _ => scan_escape(first_char, &mut chars, mode),\n+        };\n+        let end = initial_len - chars.as_str().len();\n+        callback(start..end, unescaped_char);\n+    }\n+\n+    fn skip_ascii_whitespace(chars: &mut Chars<'_>) {\n+        let str = chars.as_str();\n+        let first_non_space = str\n+            .bytes()\n+            .position(|b| b != b' ' && b != b'\\t' && b != b'\\n' && b != b'\\r')\n+            .unwrap_or(str.len());\n+        *chars = str[first_non_space..].chars()\n+    }\n+}\n+\n+fn byte_from_char(c: char) -> u8 {\n+    let res = c as u32;\n+    assert!(res <= u8::max_value() as u32, \"guaranteed because of Mode::Byte\");\n+    res as u8\n+}\n+\n+fn is_ascii(x: u32) -> bool {\n+    x <= 0x7F\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_unescape_char_bad() {\n+        fn check(literal_text: &str, expected_error: EscapeError) {\n+            let actual_result = unescape_char(literal_text).map_err(|(_offset, err)| err);\n+            assert_eq!(actual_result, Err(expected_error));\n+        }\n+\n+        check(\"\", EscapeError::ZeroChars);\n+        check(r\"\\\", EscapeError::LoneSlash);\n+\n+        check(\"\\n\", EscapeError::EscapeOnlyChar);\n+        check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n+        check(\"\\t\", EscapeError::EscapeOnlyChar);\n+        check(\"'\", EscapeError::EscapeOnlyChar);\n+        check(\"\\r\", EscapeError::BareCarriageReturn);\n+\n+        check(\"spam\", EscapeError::MoreThanOneChar);\n+        check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n+        check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n+        check(r\"\\na\", EscapeError::MoreThanOneChar);\n+        check(r\"\\ra\", EscapeError::MoreThanOneChar);\n+        check(r\"\\ta\", EscapeError::MoreThanOneChar);\n+        check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n+        check(r\"\\'a\", EscapeError::MoreThanOneChar);\n+        check(r\"\\0a\", EscapeError::MoreThanOneChar);\n+        check(r\"\\u{0}x\", EscapeError::MoreThanOneChar);\n+        check(r\"\\u{1F63b}}\", EscapeError::MoreThanOneChar);\n+\n+        check(r\"\\v\", EscapeError::InvalidEscape);\n+        check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n+        check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+\n+        check(r\"\\x\", EscapeError::TooShortHexEscape);\n+        check(r\"\\x0\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xf\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xa\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\xff\", EscapeError::OutOfRangeHexEscape);\n+        check(r\"\\xFF\", EscapeError::OutOfRangeHexEscape);\n+        check(r\"\\x80\", EscapeError::OutOfRangeHexEscape);\n+\n+        check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n+        check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n+        check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n+        check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n+        check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n+        check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n+        check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n+        check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n+        check(r\"\\u{FFFFFF}\", EscapeError::OutOfRangeUnicodeEscape);\n+        check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n+        check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n+\n+        check(r\"\\u{DC00}\", EscapeError::LoneSurrogateUnicodeEscape);\n+        check(r\"\\u{DDDD}\", EscapeError::LoneSurrogateUnicodeEscape);\n+        check(r\"\\u{DFFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n+\n+        check(r\"\\u{D800}\", EscapeError::LoneSurrogateUnicodeEscape);\n+        check(r\"\\u{DAAA}\", EscapeError::LoneSurrogateUnicodeEscape);\n+        check(r\"\\u{DBFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n+    }\n+\n+    #[test]\n+    fn test_unescape_char_good() {\n+        fn check(literal_text: &str, expected_char: char) {\n+            let actual_result = unescape_char(literal_text);\n+            assert_eq!(actual_result, Ok(expected_char));\n+        }\n+\n+        check(\"a\", 'a');\n+        check(\"\u044b\", '\u044b');\n+        check(\"\ud83e\udd80\", '\ud83e\udd80');\n+\n+        check(r#\"\\\"\"#, '\"');\n+        check(r\"\\n\", '\\n');\n+        check(r\"\\r\", '\\r');\n+        check(r\"\\t\", '\\t');\n+        check(r\"\\\\\", '\\\\');\n+        check(r\"\\'\", '\\'');\n+        check(r\"\\0\", '\\0');\n+\n+        check(r\"\\x00\", '\\0');\n+        check(r\"\\x5a\", 'Z');\n+        check(r\"\\x5A\", 'Z');\n+        check(r\"\\x7f\", 127 as char);\n+\n+        check(r\"\\u{0}\", '\\0');\n+        check(r\"\\u{000000}\", '\\0');\n+        check(r\"\\u{41}\", 'A');\n+        check(r\"\\u{0041}\", 'A');\n+        check(r\"\\u{00_41}\", 'A');\n+        check(r\"\\u{4__1__}\", 'A');\n+        check(r\"\\u{1F63b}\", '\ud83d\ude3b');\n+    }\n+\n+    #[test]\n+    fn test_unescape_str_good() {\n+        fn check(literal_text: &str, expected: &str) {\n+            let mut buf = Ok(String::with_capacity(literal_text.len()));\n+            unescape_str(literal_text, &mut |range, c| {\n+                if let Ok(b) = &mut buf {\n+                    match c {\n+                        Ok(c) => b.push(c),\n+                        Err(e) => buf = Err((range, e)),\n+                    }\n+                }\n+            });\n+            let buf = buf.as_ref().map(|it| it.as_ref());\n+            assert_eq!(buf, Ok(expected))\n+        }\n+\n+        check(\"foo\", \"foo\");\n+        check(\"\", \"\");\n+        check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n+\n+        check(\"hello \\\\\\n     world\", \"hello world\");\n+        check(\"hello \\\\\\r\\n     world\", \"hello world\");\n+        check(\"thread's\", \"thread's\")\n+    }\n+\n+    #[test]\n+    fn test_unescape_byte_bad() {\n+        fn check(literal_text: &str, expected_error: EscapeError) {\n+            let actual_result = unescape_byte(literal_text).map_err(|(_offset, err)| err);\n+            assert_eq!(actual_result, Err(expected_error));\n+        }\n+\n+        check(\"\", EscapeError::ZeroChars);\n+        check(r\"\\\", EscapeError::LoneSlash);\n+\n+        check(\"\\n\", EscapeError::EscapeOnlyChar);\n+        check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n+        check(\"\\t\", EscapeError::EscapeOnlyChar);\n+        check(\"'\", EscapeError::EscapeOnlyChar);\n+        check(\"\\r\", EscapeError::BareCarriageReturn);\n+\n+        check(\"spam\", EscapeError::MoreThanOneChar);\n+        check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n+        check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n+        check(r\"\\na\", EscapeError::MoreThanOneChar);\n+        check(r\"\\ra\", EscapeError::MoreThanOneChar);\n+        check(r\"\\ta\", EscapeError::MoreThanOneChar);\n+        check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n+        check(r\"\\'a\", EscapeError::MoreThanOneChar);\n+        check(r\"\\0a\", EscapeError::MoreThanOneChar);\n+\n+        check(r\"\\v\", EscapeError::InvalidEscape);\n+        check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n+        check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+\n+        check(r\"\\x\", EscapeError::TooShortHexEscape);\n+        check(r\"\\x0\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xa\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xf\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n+\n+        check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n+        check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n+        check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n+        check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n+        check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n+        check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n+        check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n+        check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n+\n+        check(\"\u044b\", EscapeError::NonAsciiCharInByte);\n+        check(\"\ud83e\udd80\", EscapeError::NonAsciiCharInByte);\n+\n+        check(r\"\\u{0}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{000000}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{41}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{0041}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{00_41}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{4__1__}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{1F63b}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{0}x\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{1F63b}}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{FFFFFF}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{DC00}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{DDDD}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{DFFF}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{D800}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{DAAA}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{DBFF}\", EscapeError::UnicodeEscapeInByte);\n+    }\n+\n+    #[test]\n+    fn test_unescape_byte_good() {\n+        fn check(literal_text: &str, expected_byte: u8) {\n+            let actual_result = unescape_byte(literal_text);\n+            assert_eq!(actual_result, Ok(expected_byte));\n+        }\n+\n+        check(\"a\", b'a');\n+\n+        check(r#\"\\\"\"#, b'\"');\n+        check(r\"\\n\", b'\\n');\n+        check(r\"\\r\", b'\\r');\n+        check(r\"\\t\", b'\\t');\n+        check(r\"\\\\\", b'\\\\');\n+        check(r\"\\'\", b'\\'');\n+        check(r\"\\0\", b'\\0');\n+\n+        check(r\"\\x00\", b'\\0');\n+        check(r\"\\x5a\", b'Z');\n+        check(r\"\\x5A\", b'Z');\n+        check(r\"\\x7f\", 127);\n+        check(r\"\\x80\", 128);\n+        check(r\"\\xff\", 255);\n+        check(r\"\\xFF\", 255);\n+    }\n+\n+    #[test]\n+    fn test_unescape_byte_str_good() {\n+        fn check(literal_text: &str, expected: &[u8]) {\n+            let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n+            unescape_byte_str(literal_text, &mut |range, c| {\n+                if let Ok(b) = &mut buf {\n+                    match c {\n+                        Ok(c) => b.push(c),\n+                        Err(e) => buf = Err((range, e)),\n+                    }\n+                }\n+            });\n+            let buf = buf.as_ref().map(|it| it.as_ref());\n+            assert_eq!(buf, Ok(expected))\n+        }\n+\n+        check(\"foo\", b\"foo\");\n+        check(\"\", b\"\");\n+        check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n+\n+        check(\"hello \\\\\\n     world\", b\"hello world\");\n+        check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n+        check(\"thread's\", b\"thread's\")\n+    }\n+}"}, {"sha": "e0e38d37d100b4d8a2515b69f8e26aee12d2e56c", "filename": "crates/ra_syntax/tests/data/parser/err/0030_string_suffixes.txt", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3efedb752bb2198796603d8a479a5e3ee472a97/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0030_string_suffixes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/d3efedb752bb2198796603d8a479a5e3ee472a97/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0030_string_suffixes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0030_string_suffixes.txt?ref=d3efedb752bb2198796603d8a479a5e3ee472a97", "patch": "@@ -40,7 +40,6 @@ SOURCE_FILE@[0; 112)\n         WHITESPACE@[43; 44) \" \"\n         LITERAL@[44; 59)\n           STRING@[44; 59) \"\\\"string\\\"invalid\"\n-          err: `Invalid literal suffix`\n         SEMI@[59; 60) \";\"\n       WHITESPACE@[60; 65) \"\\n    \"\n       LET_STMT@[65; 83)\n@@ -53,7 +52,6 @@ SOURCE_FILE@[0; 112)\n         WHITESPACE@[72; 73) \" \"\n         LITERAL@[73; 82)\n           BYTE@[73; 82) \"b\\'b\\'_suff\"\n-          err: `Invalid literal suffix`\n         SEMI@[82; 83) \";\"\n       WHITESPACE@[83; 88) \"\\n    \"\n       LET_STMT@[88; 109)\n@@ -66,7 +64,6 @@ SOURCE_FILE@[0; 112)\n         WHITESPACE@[95; 96) \" \"\n         LITERAL@[96; 108)\n           BYTE_STRING@[96; 108) \"b\\\"bs\\\"invalid\"\n-          err: `Invalid literal suffix`\n         SEMI@[108; 109) \";\"\n       WHITESPACE@[109; 110) \"\\n\"\n       R_CURLY@[110; 111) \"}\""}]}