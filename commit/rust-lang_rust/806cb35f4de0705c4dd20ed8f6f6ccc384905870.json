{"sha": "806cb35f4de0705c4dd20ed8f6f6ccc384905870", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwNmNiMzVmNGRlMDcwNWM0ZGQyMGVkOGY2ZjZjY2MzODQ5MDU4NzA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-30T00:36:49Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-30T00:36:49Z"}, "message": "rollup merge of #20289: nick29581/shadowing\n\nr? eddyb", "tree": {"sha": "d95e11aaf6290cb70075d0a11cf89b23ec6b26fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d95e11aaf6290cb70075d0a11cf89b23ec6b26fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/806cb35f4de0705c4dd20ed8f6f6ccc384905870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/806cb35f4de0705c4dd20ed8f6f6ccc384905870", "html_url": "https://github.com/rust-lang/rust/commit/806cb35f4de0705c4dd20ed8f6f6ccc384905870", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/806cb35f4de0705c4dd20ed8f6f6ccc384905870/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7a09cb2fdf3084ab22c3b23bd4d8c32a187a674", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a09cb2fdf3084ab22c3b23bd4d8c32a187a674", "html_url": "https://github.com/rust-lang/rust/commit/d7a09cb2fdf3084ab22c3b23bd4d8c32a187a674"}, {"sha": "9dce83ccd9234dbc6228bdac6074c0414c6e7b05", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dce83ccd9234dbc6228bdac6074c0414c6e7b05", "html_url": "https://github.com/rust-lang/rust/commit/9dce83ccd9234dbc6228bdac6074c0414c6e7b05"}], "stats": {"total": 598, "additions": 403, "deletions": 195}, "files": [{"sha": "c55a8ba104ebefc86c31fd17cc2053a02f82378d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -1343,7 +1343,10 @@ pub mod raw {\n #[cfg(test)]\n mod tests {\n     use std::boxed::Box;\n-    use prelude::*;\n+    use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n+    use prelude::{SliceExt, Iterator, IteratorExt, DoubleEndedIteratorExt};\n+    use prelude::{OrdSliceExt, CloneSliceExt, PartialEqSliceExt, AsSlice};\n+    use prelude::{RandomAccessIterator, Ord, VectorVector};\n     use core::cell::Cell;\n     use core::default::Default;\n     use core::mem;"}, {"sha": "1e1000e5ad06833963256013da52ee45aa8bbc83", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -3347,7 +3347,7 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     use super::*;\n-    use prelude::*;\n+    use prelude::{SliceExt, IteratorExt, DoubleEndedIteratorExt};\n     use test::Bencher;\n     use test::black_box;\n "}, {"sha": "7f01bf087381bf4988fe72779959ec6f2a7bf811", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 103, "deletions": 107, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -345,9 +345,6 @@ impl Rib {\n #[deriving(Show,PartialEq,Clone,Copy)]\n enum Shadowable {\n     Always,\n-    /// Means that the recorded import obeys the glob shadowing rules, i.e., can\n-    /// only be shadowed by another glob import.\n-    Glob,\n     Never\n }\n \n@@ -462,6 +459,22 @@ impl ImportResolution {\n \n         target.unwrap().shadowable\n     }\n+\n+    fn set_target_and_id(&mut self,\n+                         namespace: Namespace,\n+                         target: Option<Target>,\n+                         id: NodeId) {\n+        match namespace {\n+            TypeNS  => {\n+                self.type_target = target;\n+                self.type_id = id;\n+            }\n+            ValueNS => {\n+                self.value_target = target;\n+                self.value_id = id;\n+            }\n+        }\n+    }\n }\n \n /// The link from a module up to its nearest parent node.\n@@ -1719,11 +1732,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                     view_path.span,\n                                                     id,\n                                                     is_public,\n-                                                    if shadowable == Shadowable::Never {\n-                                                        Shadowable::Glob\n-                                                    } else {\n-                                                        shadowable\n-                                                    });\n+                                                    shadowable);\n                     }\n                 }\n             }\n@@ -2712,64 +2721,45 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // We've successfully resolved the import. Write the results in.\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n         let import_resolution = &mut (*import_resolutions)[target];\n+        {\n+            let check_and_write_import = |namespace, result: &_, used_public: &mut bool| {\n+                let namespace_name = match namespace {\n+                    TypeNS => \"type\",\n+                    ValueNS => \"value\",\n+                };\n \n-        match value_result {\n-            BoundResult(ref target_module, ref name_bindings) => {\n-                debug!(\"(resolving single import) found value target: {}\",\n-                       { name_bindings.value_def.borrow().clone().unwrap().def });\n-                self.check_for_conflicting_import(\n-                    &import_resolution.value_target,\n-                    directive.span,\n-                    target,\n-                    ValueNS);\n-\n-                self.check_that_import_is_importable(\n-                    &**name_bindings,\n-                    directive.span,\n-                    target,\n-                    ValueNS);\n-\n-                import_resolution.value_target =\n-                    Some(Target::new(target_module.clone(),\n-                                     name_bindings.clone(),\n-                                     directive.shadowable));\n-                import_resolution.value_id = directive.id;\n-                import_resolution.is_public = directive.is_public;\n-                value_used_public = name_bindings.defined_in_public_namespace(ValueNS);\n-            }\n-            UnboundResult => { /* Continue. */ }\n-            UnknownResult => {\n-                panic!(\"value result should be known at this point\");\n-            }\n-        }\n-        match type_result {\n-            BoundResult(ref target_module, ref name_bindings) => {\n-                debug!(\"(resolving single import) found type target: {}\",\n-                       { name_bindings.type_def.borrow().clone().unwrap().type_def });\n-                self.check_for_conflicting_import(\n-                    &import_resolution.type_target,\n-                    directive.span,\n-                    target,\n-                    TypeNS);\n-\n-                self.check_that_import_is_importable(\n-                    &**name_bindings,\n-                    directive.span,\n-                    target,\n-                    TypeNS);\n-\n-                import_resolution.type_target =\n-                    Some(Target::new(target_module.clone(),\n-                                     name_bindings.clone(),\n-                                     directive.shadowable));\n-                import_resolution.type_id = directive.id;\n-                import_resolution.is_public = directive.is_public;\n-                type_used_public = name_bindings.defined_in_public_namespace(TypeNS);\n-            }\n-            UnboundResult => { /* Continue. */ }\n-            UnknownResult => {\n-                panic!(\"type result should be known at this point\");\n-            }\n+                match *result {\n+                    BoundResult(ref target_module, ref name_bindings) => {\n+                        debug!(\"(resolving single import) found {} target: {}\",\n+                               namespace_name,\n+                               name_bindings.def_for_namespace(namespace));\n+                        self.check_for_conflicting_import(\n+                            &import_resolution.target_for_namespace(namespace),\n+                            directive.span,\n+                            target,\n+                            namespace);\n+\n+                        self.check_that_import_is_importable(\n+                            &**name_bindings,\n+                            directive.span,\n+                            target,\n+                            namespace);\n+\n+                        let target = Some(Target::new(target_module.clone(),\n+                                                      name_bindings.clone(),\n+                                                      directive.shadowable));\n+                        import_resolution.set_target_and_id(namespace, target, directive.id);\n+                        import_resolution.is_public = directive.is_public;\n+                        *used_public = name_bindings.defined_in_public_namespace(namespace);\n+                    }\n+                    UnboundResult => { /* Continue. */ }\n+                    UnknownResult => {\n+                        panic!(\"{} result should be known at this point\", namespace_name);\n+                    }\n+                }\n+            };\n+            check_and_write_import(ValueNS, &value_result, &mut value_used_public);\n+            check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n         }\n \n         self.check_for_conflicts_between_imports_and_items(\n@@ -2825,7 +2815,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     // Resolves a glob import. Note that this function cannot fail; it either\n     // succeeds or bails out (as importing * from an empty module or a module\n-    // that exports nothing is valid).\n+    // that exports nothing is valid). containing_module is the module we are\n+    // actually importing, i.e., `foo` in `use foo::*`.\n     fn resolve_glob_import(&mut self,\n                            module_: &Module,\n                            containing_module: Rc<Module>,\n@@ -2851,12 +2842,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         assert_eq!(containing_module.glob_count.get(), 0);\n \n         // Add all resolved imports from the containing module.\n-        let import_resolutions = containing_module.import_resolutions\n-                                                  .borrow();\n+        let import_resolutions = containing_module.import_resolutions.borrow();\n         for (ident, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {} into `{}`\",\n-                   target_import_resolution.type_target.is_none(),\n+                   token::get_name(*ident),\n                    self.module_to_string(module_));\n \n             if !target_import_resolution.is_public {\n@@ -2876,17 +2866,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // Continue.\n                         }\n                         Some(ref value_target) => {\n-                            dest_import_resolution.value_target =\n-                                Some(value_target.clone());\n+                            self.check_for_conflicting_import(&dest_import_resolution.value_target,\n+                                                              import_directive.span,\n+                                                              *ident,\n+                                                              ValueNS);\n+                            dest_import_resolution.value_target = Some(value_target.clone());\n                         }\n                     }\n                     match target_import_resolution.type_target {\n                         None => {\n                             // Continue.\n                         }\n                         Some(ref type_target) => {\n-                            dest_import_resolution.type_target =\n-                                Some(type_target.clone());\n+                            self.check_for_conflicting_import(&dest_import_resolution.type_target,\n+                                                              import_directive.span,\n+                                                              *ident,\n+                                                              TypeNS);\n+                            dest_import_resolution.type_target = Some(type_target.clone());\n                         }\n                     }\n                     dest_import_resolution.is_public = is_public;\n@@ -2908,8 +2904,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Add all children from the containing module.\n         self.populate_module_if_necessary(&containing_module);\n \n-        for (&name, name_bindings) in containing_module.children\n-                                                       .borrow().iter() {\n+        for (&name, name_bindings) in containing_module.children.borrow().iter() {\n             self.merge_import_resolution(module_,\n                                          containing_module.clone(),\n                                          import_directive,\n@@ -2919,8 +2914,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Add external module children from the containing module.\n-        for (&name, module) in containing_module.external_module_children\n-                                                .borrow().iter() {\n+        for (&name, module) in containing_module.external_module_children.borrow().iter() {\n             let name_bindings =\n                 Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n             self.merge_import_resolution(module_,\n@@ -2965,41 +2959,39 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                to `{}`\",\n-               token::get_name(name).get().to_string(),\n+               token::get_name(name).get(),\n                self.module_to_string(&*containing_module),\n                self.module_to_string(module_));\n \n         // Merge the child item into the import resolution.\n-        if name_bindings.defined_in_namespace_with(ValueNS, IMPORTABLE | PUBLIC) {\n-            debug!(\"(resolving glob import) ... for value target\");\n-            if dest_import_resolution.shadowable(ValueNS) == Shadowable::Never {\n-                let msg = format!(\"a value named `{}` has already been imported \\\n-                                   in this module\",\n-                                  token::get_name(name).get());\n-                self.session.span_err(import_directive.span, msg.as_slice());\n-            } else {\n-                dest_import_resolution.value_target =\n-                    Some(Target::new(containing_module.clone(),\n-                                     name_bindings.clone(),\n-                                     import_directive.shadowable));\n-                dest_import_resolution.value_id = id;\n-            }\n-        }\n-        if name_bindings.defined_in_namespace_with(TypeNS, IMPORTABLE | PUBLIC) {\n-            debug!(\"(resolving glob import) ... for type target\");\n-            if dest_import_resolution.shadowable(TypeNS) == Shadowable::Never {\n-                let msg = format!(\"a type named `{}` has already been imported \\\n-                                   in this module\",\n-                                  token::get_name(name).get());\n-                self.session.span_err(import_directive.span, msg.as_slice());\n-            } else {\n-                dest_import_resolution.type_target =\n-                    Some(Target::new(containing_module,\n-                                     name_bindings.clone(),\n-                                     import_directive.shadowable));\n-                dest_import_resolution.type_id = id;\n-            }\n+        {\n+            let merge_child_item = |namespace| {\n+                if name_bindings.defined_in_namespace_with(namespace, IMPORTABLE | PUBLIC) {\n+                    let namespace_name = match namespace {\n+                        TypeNS => \"type\",\n+                        ValueNS => \"value\",\n+                    };\n+                    debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n+                    if dest_import_resolution.shadowable(namespace) == Shadowable::Never {\n+                        let msg = format!(\"a {} named `{}` has already been imported \\\n+                                           in this module\",\n+                                          namespace_name,\n+                                          token::get_name(name).get());\n+                        self.session.span_err(import_directive.span, msg.as_slice());\n+                    } else {\n+                        let target = Target::new(containing_module.clone(),\n+                                                 name_bindings.clone(),\n+                                                 import_directive.shadowable);\n+                        dest_import_resolution.set_target_and_id(namespace,\n+                                                                 Some(target),\n+                                                                 id);\n+                    }\n+                }\n+            };\n+            merge_child_item(ValueNS);\n+            merge_child_item(TypeNS);\n         }\n+\n         dest_import_resolution.is_public = is_public;\n \n         self.check_for_conflicts_between_imports_and_items(\n@@ -3019,6 +3011,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return\n         }\n \n+        debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n+               token::get_name(name).get(),\n+               target.is_some());\n+\n         match *target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 let msg = format!(\"a {} named `{}` has already been imported \\"}, {"sha": "f0d738d839d7a01e281de85cfc35ae38926af7cc", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -1545,8 +1545,7 @@ pub fn arg_kind<'a, 'tcx>(cx: &FunctionContext<'a, 'tcx>, t: Ty<'tcx>)\n }\n \n // work around bizarre resolve errors\n-pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n-pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n+type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n \n // create_datums_for_fn_args: creates rvalue datums for each of the\n // incoming function arguments. These will later be stored into"}, {"sha": "b15b75c6715b755ddeeb0f9c1b2beabbd3d83f98", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -190,8 +190,8 @@ pub fn validate_substs(substs: &Substs) {\n }\n \n // work around bizarre resolve errors\n-pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n-pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n+type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n+type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n \n // Function context.  Every LLVM function we create will have one of\n // these."}, {"sha": "39c57b99b36f018e40e2db890de8d2605d825abd", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -537,7 +537,8 @@ pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use prelude::*;\n+    use prelude::{spawn, Some, None, Option, FnOnce, ToString, CloneSliceExt};\n+    use prelude::{Clone, RawPtr, Iterator, SliceExt, StrExt};\n     use ptr;\n     use thread::Thread;\n     use libc;"}, {"sha": "a405627aecc45a9be9e9a1ea705bf8c4524c428e", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -181,7 +181,7 @@\n // senders. Under the hood, however, there are actually three flavors of\n // channels in play.\n //\n-// * Oneshots - these channels are highly optimized for the one-send use case.\n+// * Flavor::Oneshots - these channels are highly optimized for the one-send use case.\n //              They contain as few atomics as possible and involve one and\n //              exactly one allocation.\n // * Streams - these channels are optimized for the non-shared use case. They\n@@ -316,7 +316,6 @@ use core::prelude::*;\n \n pub use self::TryRecvError::*;\n pub use self::TrySendError::*;\n-use self::Flavor::*;\n \n use alloc::arc::Arc;\n use core::kinds;\n@@ -337,7 +336,8 @@ macro_rules! test {\n             use super::*;\n             use comm::*;\n             use thread::Thread;\n-            use prelude::*;\n+            use prelude::{Ok, Err, spawn, range, drop, Box, Some, None, Option};\n+            use prelude::{Vec, Buffer, from_str, Clone};\n \n             $(#[$a])* #[test] fn f() { $b }\n         }\n@@ -478,7 +478,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n #[unstable]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(oneshot::Packet::new()));\n-    (Sender::new(Oneshot(a.clone())), Receiver::new(Oneshot(a)))\n+    (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n }\n \n /// Creates a new synchronous, bounded channel.\n@@ -518,7 +518,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n               of channel that is is creating\"]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(sync::Packet::new(bound)));\n-    (SyncSender::new(a.clone()), Receiver::new(Sync(a)))\n+    (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -592,15 +592,15 @@ impl<T: Send> Sender<T> {\n     #[unstable = \"this function may be renamed to send() in the future\"]\n     pub fn send_opt(&self, t: T) -> Result<(), T> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n-            Oneshot(ref p) => {\n+            Flavor::Oneshot(ref p) => {\n                 unsafe {\n                     let p = p.get();\n                     if !(*p).sent() {\n                         return (*p).send(t);\n                     } else {\n                         let a =\n                             Arc::new(RacyCell::new(stream::Packet::new()));\n-                        match (*p).upgrade(Receiver::new(Stream(a.clone()))) {\n+                        match (*p).upgrade(Receiver::new(Flavor::Stream(a.clone()))) {\n                             oneshot::UpSuccess => {\n                                 let ret = (*a.get()).send(t);\n                                 (a, ret)\n@@ -618,13 +618,13 @@ impl<T: Send> Sender<T> {\n                     }\n                 }\n             }\n-            Stream(ref p) => return unsafe { (*p.get()).send(t) },\n-            Shared(ref p) => return unsafe { (*p.get()).send(t) },\n-            Sync(..) => unreachable!(),\n+            Flavor::Stream(ref p) => return unsafe { (*p.get()).send(t) },\n+            Flavor::Shared(ref p) => return unsafe { (*p.get()).send(t) },\n+            Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n-            let tmp = Sender::new(Stream(new_inner));\n+            let tmp = Sender::new(Flavor::Stream(new_inner));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n         return ret;\n@@ -635,53 +635,53 @@ impl<T: Send> Sender<T> {\n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n-            Oneshot(ref p) => {\n+            Flavor::Oneshot(ref p) => {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n+                    match (*p.get()).upgrade(Receiver::new(Flavor::Shared(a.clone()))) {\n                         oneshot::UpSuccess |\n                         oneshot::UpDisconnected => (a, None, guard),\n                         oneshot::UpWoke(task) => (a, Some(task), guard)\n                     }\n                 }\n             }\n-            Stream(ref p) => {\n+            Flavor::Stream(ref p) => {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n+                    match (*p.get()).upgrade(Receiver::new(Flavor::Shared(a.clone()))) {\n                         stream::UpSuccess |\n                         stream::UpDisconnected => (a, None, guard),\n                         stream::UpWoke(task) => (a, Some(task), guard),\n                     }\n                 }\n             }\n-            Shared(ref p) => {\n+            Flavor::Shared(ref p) => {\n                 unsafe { (*p.get()).clone_chan(); }\n-                return Sender::new(Shared(p.clone()));\n+                return Sender::new(Flavor::Shared(p.clone()));\n             }\n-            Sync(..) => unreachable!(),\n+            Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n             (*packet.get()).inherit_blocker(sleeper, guard);\n \n-            let tmp = Sender::new(Shared(packet.clone()));\n+            let tmp = Sender::new(Flavor::Shared(packet.clone()));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n-        Sender::new(Shared(packet))\n+        Sender::new(Flavor::Shared(packet))\n     }\n }\n \n #[unsafe_destructor]\n impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n-            Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Sync(..) => unreachable!(),\n+            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Sync(..) => unreachable!(),\n         }\n     }\n }\n@@ -827,30 +827,30 @@ impl<T: Send> Receiver<T> {\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return Err(Empty),\n                         Err(oneshot::Disconnected) => return Err(Disconnected),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return Err(Empty),\n                         Err(stream::Disconnected) => return Err(Disconnected),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return Err(Empty),\n                         Err(shared::Disconnected) => return Err(Disconnected),\n                     }\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(sync::Empty) => return Err(Empty),\n@@ -881,30 +881,30 @@ impl<T: Send> Receiver<T> {\n     pub fn recv_opt(&self) -> Result<T, ()> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return unreachable!(),\n                         Err(oneshot::Disconnected) => return Err(()),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return unreachable!(),\n                         Err(stream::Disconnected) => return Err(()),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return unreachable!(),\n                         Err(shared::Disconnected) => return Err(()),\n                     }\n                 }\n-                Sync(ref p) => return unsafe { (*p.get()).recv() }\n+                Flavor::Sync(ref p) => return unsafe { (*p.get()).recv() }\n             };\n             unsafe {\n                 mem::swap(self.inner_mut(), new_port.inner_mut());\n@@ -924,22 +924,22 @@ impl<T: Send> select::Packet for Receiver<T> {\n     fn can_recv(&self) -> bool {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).can_recv() } {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).can_recv() } {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     return unsafe { (*p.get()).can_recv() };\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     return unsafe { (*p.get()).can_recv() };\n                 }\n             };\n@@ -953,24 +953,24 @@ impl<T: Send> select::Packet for Receiver<T> {\n     fn start_selection(&self, mut token: SignalToken) -> StartResult {\n         loop {\n             let (t, new_port) = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).start_selection(token) } {\n                         oneshot::SelSuccess => return Installed,\n                         oneshot::SelCanceled => return Abort,\n                         oneshot::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).start_selection(token) } {\n                         stream::SelSuccess => return Installed,\n                         stream::SelCanceled => return Abort,\n                         stream::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     return unsafe { (*p.get()).start_selection(token) };\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     return unsafe { (*p.get()).start_selection(token) };\n                 }\n             };\n@@ -985,14 +985,14 @@ impl<T: Send> select::Packet for Receiver<T> {\n         let mut was_upgrade = false;\n         loop {\n             let result = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => unsafe { (*p.get()).abort_selection() },\n-                Stream(ref p) => unsafe {\n+                Flavor::Oneshot(ref p) => unsafe { (*p.get()).abort_selection() },\n+                Flavor::Stream(ref p) => unsafe {\n                     (*p.get()).abort_selection(was_upgrade)\n                 },\n-                Shared(ref p) => return unsafe {\n+                Flavor::Shared(ref p) => return unsafe {\n                     (*p.get()).abort_selection(was_upgrade)\n                 },\n-                Sync(ref p) => return unsafe {\n+                Flavor::Sync(ref p) => return unsafe {\n                     (*p.get()).abort_selection()\n                 },\n             };\n@@ -1015,10 +1015,10 @@ impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n-            Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Sync(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Sync(ref mut p) => unsafe { (*p.get()).drop_port(); },\n         }\n     }\n }\n@@ -1047,7 +1047,7 @@ unsafe impl<T> kinds::Sync for RacyCell<T> { } // Oh dear\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use prelude::*;\n+    use prelude::{spawn, range, Some, None, from_str, Clone, Str};\n     use os;\n \n     pub fn stress_factor() -> uint {"}, {"sha": "79327a29615ae52e47fc09603b6e1926a1bfd5d0", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -400,8 +400,8 @@ impl<'a> Buffer for BufReader<'a> {\n mod test {\n     extern crate \"test\" as test_crate;\n     use super::*;\n-    use io::*;\n-    use prelude::*;\n+    use io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek};\n+    use prelude::{Ok, Err, range,  Vec, Buffer,  AsSlice, SliceExt, IteratorExt, CloneSliceExt};\n     use io;\n     use self::test_crate::Bencher;\n "}, {"sha": "7a25360e695e40575aa4ed1014a0ce031eb454b8", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -1959,8 +1959,8 @@ impl fmt::Show for FilePermission {\n #[cfg(test)]\n mod tests {\n     use self::BadReaderBehavior::*;\n-    use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput};\n-    use prelude::*;\n+    use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput, Writer};\n+    use prelude::{Ok, Vec, Buffer, CloneSliceExt};\n     use uint;\n \n     #[deriving(Clone, PartialEq, Show)]"}, {"sha": "93f37a8c98ff86a6401b47eb8b21a2e88e7550aa", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -269,7 +269,7 @@ mod tests {\n     use super::*;\n     use io::*;\n     use io::test::*;\n-    use prelude::*;\n+    use prelude::{Ok, Err, spawn, range, drop,  Some, None, channel, Send, FnOnce, Clone};\n     use io::fs::PathExtensions;\n     use time::Duration;\n "}, {"sha": "24cf06973cc6939f982f6ce6725d42003dfe6557", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -484,9 +484,12 @@ impl sys_common::AsInner<TcpAcceptorImp> for TcpAcceptor {\n mod test {\n     use io::net::tcp::*;\n     use io::net::ip::*;\n-    use io::*;\n+    use io::{EndOfFile, TimedOut, IoError, ShortWrite, OtherIoError, ConnectionAborted};\n+    use io::{ConnectionRefused, ConnectionReset, BrokenPipe, NotConnected};\n+    use io::{PermissionDenied, Listener, Acceptor};\n     use io::test::*;\n-    use prelude::*;\n+    use prelude::{Ok, Err, spawn, range, drop, Some, None, channel, Clone};\n+    use prelude::{Reader, Writer, IteratorExt};\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]"}, {"sha": "1431067d4c6a3879eb19997f735cb0b645287817", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -250,9 +250,9 @@ impl Writer for UdpStream {\n mod test {\n     use super::*;\n     use io::net::ip::*;\n-    use io::*;\n+    use io::{ShortWrite, IoError, TimedOut, PermissionDenied};\n     use io::test::*;\n-    use prelude::*;\n+    use prelude::{Ok, Err, spawn, range, drop, Some, None, channel, Clone, Reader, Writer};\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]"}, {"sha": "9e0c76e4e79f5de2cb55bbbc65919ce6060dac0a", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -745,8 +745,10 @@ mod tests {\n \n     use super::*;\n     use io::timer::*;\n-    use io::*;\n-    use prelude::*;\n+    use io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n+    use prelude::{Ok, Err, spawn, range, drop, Box, Some, None, Option, Vec, Buffer};\n+    use prelude::{from_str, Path, String, channel, Reader, Writer, Clone, Slice};\n+    use prelude::{SliceExt, Str, StrExt, AsSlice, ToString, GenericPath};\n     use io::fs::PathExtensions;\n     use time::Duration;\n     use str;"}, {"sha": "90d7c1388a196e56800786c23fa3d20627b8dede", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -280,7 +280,7 @@ mod test {\n     use io;\n     use boxed::Box;\n     use super::*;\n-    use prelude::*;\n+    use prelude::{Ok, range, Vec, Buffer, Writer, Reader, ToString, AsSlice};\n \n     #[test]\n     fn test_limit_reader_unlimited() {"}, {"sha": "48ff1a364e93c7d73f750df61d6597ca3a5bf27e", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -147,8 +147,10 @@ pub fn test_num<T>(ten: T, two: T) where\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n-    use super::*;\n+    use prelude::{range, Some, None, Option, IteratorExt};\n+    use super::{from_int, from_uint, from_i32, from_i64, from_u64, from_u32};\n+    use super::{from_f64, from_f32, from_u16, from_i16, from_u8, from_i8, Int};\n+    use super::{cast, NumCast, ToPrimitive, FromPrimitive, UnsignedInt};\n     use i8;\n     use i16;\n     use i32;"}, {"sha": "60f147eac9b2b490be0e4dc9086838f9065a8c65", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -1239,7 +1239,7 @@ mod bench {\n     extern crate test;\n     use self::test::Bencher;\n     use super::*;\n-    use prelude::*;\n+    use prelude::{Clone, GenericPath};\n \n     #[bench]\n     fn join_home_dir(b: &mut Bencher) {"}, {"sha": "bdf947438f36bd617093a36cf57868eab2a9e488", "filename": "src/libstd/sync/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Flibstd%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomic.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -180,7 +180,7 @@ impl<T: Send> Drop for AtomicOption<T> {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::{Some, None};\n     use super::*;\n \n     #[test]"}, {"sha": "007b28b6924e45cd893a53bdb63a99ecf439bb8a", "filename": "src/test/compile-fail/import-shadow-1.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-1.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::*;\n+use bar::*; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "e597b557383866cc344b0cde275fc1bbd32475f2", "filename": "src/test/compile-fail/import-shadow-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-2.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::*;\n+use foo::*; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "68222fa3fd727e2a03d99107d3aa4a870982a8dd", "filename": "src/test/compile-fail/import-shadow-3.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-3.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::Baz;\n+use bar::*; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "c698004bda0e48b2e73caf1cb1ec84c22190a2b6", "filename": "src/test/compile-fail/import-shadow-4.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-4.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::*;\n+use bar::Baz; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "6ad7e5ec3e260b5cea826f30468d7199b4ff3137", "filename": "src/test/compile-fail/import-shadow-5.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-5.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::Baz;\n+use bar::Baz; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "1864251e71b4212dd58a6ce847a7a33747f45dc5", "filename": "src/test/compile-fail/import-shadow-6.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-6.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use qux::*;\n+use foo::*; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "a2df266fb74f3b912593cdc5fe3c2e467c54cb82", "filename": "src/test/compile-fail/import-shadow-7.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Fcompile-fail%2Fimport-shadow-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-7.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::*;\n+use qux::*; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "39b0711721b54a5abccfadd47447c0d7b28f8503", "filename": "src/test/run-pass/issue-7663.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Frun-pass%2Fissue-7663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Frun-pass%2Fissue-7663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7663.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -17,8 +17,7 @@ mod test1 {\n     mod bar { pub fn p() -> int { 2 } }\n \n     pub mod baz {\n-        use test1::foo::*;\n-        use test1::bar::*;\n+        use test1::bar::p;\n \n         pub fn my_main() { assert!(p() == 2); }\n     }\n@@ -36,20 +35,7 @@ mod test2 {\n     }\n }\n \n-mod test3 {\n-\n-    mod foo { pub fn p() -> int { 1 } }\n-    mod bar { pub fn p() -> int { 2 } }\n-\n-    pub mod baz {\n-        use test3::bar::p;\n-\n-        pub fn my_main() { assert!(p() == 2); }\n-    }\n-}\n-\n fn main() {\n     test1::baz::my_main();\n     test2::baz::my_main();\n-    test3::baz::my_main();\n }"}, {"sha": "2d087406fd6f77a2d31eed60be0227d4646f8c12", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806cb35f4de0705c4dd20ed8f6f6ccc384905870/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=806cb35f4de0705c4dd20ed8f6f6ccc384905870", "patch": "@@ -23,7 +23,6 @@\n #![allow(unused_imports)]\n \n use std::io::*;\n-use std::io::net::tcp::*;\n use std::io::test::*;\n use std::io;\n use std::time::Duration;"}]}