{"sha": "f1bacb2dca610b0babeba526020e2b87899c2d44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYmFjYjJkY2E2MTBiMGJhYmViYTUyNjAyMGUyYjg3ODk5YzJkNDQ=", "commit": {"author": {"name": "Mahmut Bulut", "email": "vertexclique@gmail.com", "date": "2019-06-14T13:55:36Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-03T09:20:15Z"}, "message": "Check intrinsics for callability in const fns", "tree": {"sha": "dc79946f7e408b3e2d67ba1fb1df716061b85ceb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc79946f7e408b3e2d67ba1fb1df716061b85ceb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1bacb2dca610b0babeba526020e2b87899c2d44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1bacb2dca610b0babeba526020e2b87899c2d44", "html_url": "https://github.com/rust-lang/rust/commit/f1bacb2dca610b0babeba526020e2b87899c2d44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1bacb2dca610b0babeba526020e2b87899c2d44/comments", "author": {"login": "vertexclique", "id": 578559, "node_id": "MDQ6VXNlcjU3ODU1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/578559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vertexclique", "html_url": "https://github.com/vertexclique", "followers_url": "https://api.github.com/users/vertexclique/followers", "following_url": "https://api.github.com/users/vertexclique/following{/other_user}", "gists_url": "https://api.github.com/users/vertexclique/gists{/gist_id}", "starred_url": "https://api.github.com/users/vertexclique/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vertexclique/subscriptions", "organizations_url": "https://api.github.com/users/vertexclique/orgs", "repos_url": "https://api.github.com/users/vertexclique/repos", "events_url": "https://api.github.com/users/vertexclique/events{/privacy}", "received_events_url": "https://api.github.com/users/vertexclique/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4787e97475de6be9487e3d9255a9c2d3c0bf9252", "url": "https://api.github.com/repos/rust-lang/rust/commits/4787e97475de6be9487e3d9255a9c2d3c0bf9252", "html_url": "https://github.com/rust-lang/rust/commit/4787e97475de6be9487e3d9255a9c2d3c0bf9252"}], "stats": {"total": 342, "additions": 212, "deletions": 130}, "files": [{"sha": "19928f30f2ea5907076ad43501fbb4b58c7fd86f", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -939,6 +939,7 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_transmute\")]\n     pub fn transmute<T, U>(e: T) -> U;\n \n     /// Returns `true` if the actual type given as `T` requires drop"}, {"sha": "0fb3f575b52553a7440c43d4a33a87c0ee9dc53d", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 67, "deletions": 3, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -2,7 +2,8 @@ use crate::ty::query::Providers;\n use crate::hir::def_id::DefId;\n use crate::hir;\n use crate::ty::TyCtxt;\n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::{sym, Symbol};\n+use rustc_target::spec::abi::Abi;\n use crate::hir::map::blocks::FnLikeNode;\n use syntax::attr;\n \n@@ -63,13 +64,76 @@ impl<'tcx> TyCtxt<'tcx> {\n \n \n pub fn provide(providers: &mut Providers<'_>) {\n-    /// only checks whether the function has a `const` modifier\n+    /// Const evaluability whitelist is here to check evaluability at the\n+    /// top level beforehand.\n+    fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n+        match tcx.fn_sig(def_id).abi() {\n+            Abi::RustIntrinsic |\n+            Abi::PlatformIntrinsic => {\n+                match tcx.item_name(def_id) {\n+                    // Keep this list in the same order as the match patterns in\n+                    // `librustc_mir/interpret/intrinsics.rs`\n+                    | sym::caller_location\n+\n+                    | sym::min_align_of\n+                    | sym::pref_align_of\n+                    | sym::needs_drop\n+                    | sym::size_of\n+                    | sym::type_id\n+                    | sym::type_name\n+\n+                    | sym::ctpop\n+                    | sym::cttz\n+                    | sym::cttz_nonzero\n+                    | sym::ctlz\n+                    | sym::ctlz_nonzero\n+                    | sym::bswap\n+                    | sym::bitreverse\n+\n+                    | sym::wrapping_add\n+                    | sym::wrapping_sub\n+                    | sym::wrapping_mul\n+                    | sym::add_with_overflow\n+                    | sym::sub_with_overflow\n+                    | sym::mul_with_overflow\n+\n+                    | sym::saturating_add\n+                    | sym::saturating_sub\n+\n+                    | sym::unchecked_shl\n+                    | sym::unchecked_shr\n+\n+                    | sym::rotate_left\n+                    | sym::rotate_right\n+\n+                    | sym::ptr_offset_from\n+\n+                    | sym::transmute\n+\n+                    | sym::simd_insert\n+\n+                    | sym::simd_extract\n+\n+                    => Some(true),\n+\n+                    _ => Some(false)\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n+    /// said intrinsic is on the whitelist for being const callable.\n     fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         let hir_id = tcx.hir().as_local_hir_id(def_id)\n                               .expect(\"Non-local call to local provider is_const_fn\");\n \n         let node = tcx.hir().get(hir_id);\n-        if let Some(fn_like) = FnLikeNode::from_node(node) {\n+\n+        if let Some(whitelisted) = is_const_intrinsic(tcx, def_id) {\n+            whitelisted\n+        } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n             fn_like.constness() == hir::Constness::Const\n         } else if let hir::Node::Ctor(_) = node {\n             true"}, {"sha": "fc880b9e9295114f5d7d953074f3a32ebbcc6aab", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -408,10 +408,6 @@ declare_features! (\n     /// Allows using `#[doc(keyword = \"...\")]`.\n     (active, doc_keyword, \"1.28.0\", Some(51315), None),\n \n-    /// Allows reinterpretation of the bits of a value of one type as another\n-    /// type during const eval.\n-    (active, const_transmute, \"1.29.0\", Some(53605), None),\n-\n     /// Allows using `try {...}` expressions.\n     (active, try_blocks, \"1.29.0\", Some(31436), None),\n "}, {"sha": "b494c9bdd380b824f93ccd86728adadf4f2f544f", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -1364,6 +1364,8 @@ impl<'a, 'tcx> CrateMetadata {\n         let constness = match self.kind(id) {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n+            // Some intrinsics can be const fn\n+            EntryKind::ForeignFn(data) => data.decode(self).constness,\n             EntryKind::Variant(..) | EntryKind::Struct(..) => hir::Constness::Const,\n             _ => hir::Constness::NotConst,\n         };"}, {"sha": "fb70e10c84f3dcef07b0976941aab4bd6bdf83c1", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -1525,7 +1525,11 @@ impl EncodeContext<'tcx> {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     asyncness: hir::IsAsync::NotAsync,\n-                    constness: hir::Constness::NotConst,\n+                    constness: if self.tcx.is_const_fn_raw(def_id) {\n+                        hir::Constness::Const\n+                    } else {\n+                        hir::Constness::NotConst\n+                    },\n                     param_names: self.encode_fn_param_names(names),\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))"}, {"sha": "f6fdc51a8c2b6b5af437562110aa84379286165f", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 66, "deletions": 63, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -2,7 +2,7 @@\n //! looking at their MIR. Intrinsics/functions supported here are shared by CTFE\n //! and miri.\n \n-use syntax::symbol::Symbol;\n+use syntax_pos::symbol::{sym, Symbol};\n use syntax_pos::Span;\n use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Primitive, Size};\n@@ -22,7 +22,7 @@ mod caller_location;\n mod type_name;\n \n fn numeric_intrinsic<'tcx, Tag>(\n-    name: &str,\n+    name: Symbol,\n     bits: u128,\n     kind: Primitive,\n ) -> InterpResult<'tcx, Scalar<Tag>> {\n@@ -32,11 +32,11 @@ fn numeric_intrinsic<'tcx, Tag>(\n     };\n     let extra = 128 - size.bits() as u128;\n     let bits_out = match name {\n-        \"ctpop\" => bits.count_ones() as u128,\n-        \"ctlz\" => bits.leading_zeros() as u128 - extra,\n-        \"cttz\" => (bits << extra).trailing_zeros() as u128 - extra,\n-        \"bswap\" => (bits << extra).swap_bytes(),\n-        \"bitreverse\" => (bits << extra).reverse_bits(),\n+        sym::ctpop => bits.count_ones() as u128,\n+        sym::ctlz => bits.leading_zeros() as u128 - extra,\n+        sym::cttz => (bits << extra).trailing_zeros() as u128 - extra,\n+        sym::bswap => (bits << extra).swap_bytes(),\n+        sym::bitreverse => (bits << extra).reverse_bits(),\n         _ => bug!(\"not a numeric intrinsic: {}\", name),\n     };\n     Ok(Scalar::from_uint(bits_out, size))\n@@ -51,9 +51,9 @@ crate fn eval_nullary_intrinsic<'tcx>(\n     substs: SubstsRef<'tcx>,\n ) -> InterpResult<'tcx, &'tcx ty::Const<'tcx>> {\n     let tp_ty = substs.type_at(0);\n-    let name = &*tcx.item_name(def_id).as_str();\n+    let name = tcx.item_name(def_id);\n     Ok(match name {\n-        \"type_name\" => {\n+        sym::type_name => {\n             let alloc = type_name::alloc_type_name(tcx, tp_ty);\n             tcx.mk_const(ty::Const {\n                 val: ty::ConstKind::Value(ConstValue::Slice {\n@@ -64,20 +64,20 @@ crate fn eval_nullary_intrinsic<'tcx>(\n                 ty: tcx.mk_static_str(),\n             })\n         },\n-        \"needs_drop\" => ty::Const::from_bool(tcx, tp_ty.needs_drop(tcx, param_env)),\n-        \"size_of\" |\n-        \"min_align_of\" |\n-        \"pref_align_of\" => {\n+        sym::needs_drop => ty::Const::from_bool(tcx, tp_ty.needs_drop(tcx, param_env)),\n+        sym::size_of |\n+        sym::min_align_of |\n+        sym::pref_align_of => {\n             let layout = tcx.layout_of(param_env.and(tp_ty)).map_err(|e| err_inval!(Layout(e)))?;\n             let n = match name {\n-                \"pref_align_of\" => layout.align.pref.bytes(),\n-                \"min_align_of\" => layout.align.abi.bytes(),\n-                \"size_of\" => layout.size.bytes(),\n+                sym::pref_align_of => layout.align.pref.bytes(),\n+                sym::min_align_of => layout.align.abi.bytes(),\n+                sym::size_of => layout.size.bytes(),\n                 _ => bug!(),\n             };\n             ty::Const::from_usize(tcx, n)\n         },\n-        \"type_id\" => ty::Const::from_bits(\n+        sym::type_id => ty::Const::from_bits(\n             tcx,\n             tcx.type_id_hash(tp_ty).into(),\n             param_env.and(tcx.types.u64),\n@@ -96,30 +96,32 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx, bool> {\n         let substs = instance.substs;\n-        let intrinsic_name = &*self.tcx.item_name(instance.def_id()).as_str();\n+        let intrinsic_name = self.tcx.item_name(instance.def_id());\n \n         // We currently do not handle any intrinsics that are *allowed* to diverge,\n         // but `transmute` could lack a return place in case of UB.\n         let (dest, ret) = match ret {\n             Some(p) => p,\n             None => match intrinsic_name {\n-                \"transmute\" => throw_ub!(Unreachable),\n+                sym::transmute => throw_ub!(Unreachable),\n                 _ => return Ok(false),\n             }\n         };\n \n+        // Keep the patterns in this match ordered the same as the list in\n+        // `src/librustc/ty/constness.rs`\n         match intrinsic_name {\n-            \"caller_location\" => {\n+            sym::caller_location => {\n                 let location = self.alloc_caller_location_for_span(span);\n                 self.write_scalar(location.ptr, dest)?;\n             }\n \n-            \"min_align_of\" |\n-            \"pref_align_of\" |\n-            \"needs_drop\" |\n-            \"size_of\" |\n-            \"type_id\" |\n-            \"type_name\" => {\n+            sym::min_align_of |\n+            sym::pref_align_of |\n+            sym::needs_drop |\n+            sym::size_of |\n+            sym::type_id |\n+            sym::type_name => {\n                 let gid = GlobalId {\n                     instance,\n                     promoted: None,\n@@ -129,13 +131,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.copy_op(val, dest)?;\n             }\n \n-            | \"ctpop\"\n-            | \"cttz\"\n-            | \"cttz_nonzero\"\n-            | \"ctlz\"\n-            | \"ctlz_nonzero\"\n-            | \"bswap\"\n-            | \"bitreverse\" => {\n+            | sym::ctpop\n+            | sym::cttz\n+            | sym::cttz_nonzero\n+            | sym::ctlz\n+            | sym::ctlz_nonzero\n+            | sym::bswap\n+            | sym::bitreverse => {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n                 let val = self.read_scalar(args[0])?.not_undef()?;\n@@ -144,31 +146,32 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n                     _ => throw_unsup!(TypeNotPrimitive(ty)),\n                 };\n-                let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n-                    if bits == 0 {\n-                        throw_ub_format!(\"`{}` called on 0\", intrinsic_name);\n-                    }\n-                    numeric_intrinsic(intrinsic_name.trim_end_matches(\"_nonzero\"), bits, kind)?\n-                } else {\n-                    numeric_intrinsic(intrinsic_name, bits, kind)?\n+                let (nonzero, intrinsic_name) = match intrinsic_name {\n+                    sym::cttz_nonzero => (true, sym::cttz),\n+                    sym::ctlz_nonzero => (true, sym::ctlz),\n+                    other => (false, other),\n                 };\n+                if nonzero && bits == 0 {\n+                    throw_ub_format!(\"`{}_nonzero` called on 0\", intrinsic_name);\n+                }\n+                let out_val = numeric_intrinsic(intrinsic_name, bits, kind)?;\n                 self.write_scalar(out_val, dest)?;\n             }\n-            | \"wrapping_add\"\n-            | \"wrapping_sub\"\n-            | \"wrapping_mul\"\n-            | \"add_with_overflow\"\n-            | \"sub_with_overflow\"\n-            | \"mul_with_overflow\" => {\n+            | sym::wrapping_add\n+            | sym::wrapping_sub\n+            | sym::wrapping_mul\n+            | sym::add_with_overflow\n+            | sym::sub_with_overflow\n+            | sym::mul_with_overflow => {\n                 let lhs = self.read_immediate(args[0])?;\n                 let rhs = self.read_immediate(args[1])?;\n                 let (bin_op, ignore_overflow) = match intrinsic_name {\n-                    \"wrapping_add\" => (BinOp::Add, true),\n-                    \"wrapping_sub\" => (BinOp::Sub, true),\n-                    \"wrapping_mul\" => (BinOp::Mul, true),\n-                    \"add_with_overflow\" => (BinOp::Add, false),\n-                    \"sub_with_overflow\" => (BinOp::Sub, false),\n-                    \"mul_with_overflow\" => (BinOp::Mul, false),\n+                    sym::wrapping_add => (BinOp::Add, true),\n+                    sym::wrapping_sub => (BinOp::Sub, true),\n+                    sym::wrapping_mul => (BinOp::Mul, true),\n+                    sym::add_with_overflow => (BinOp::Add, false),\n+                    sym::sub_with_overflow => (BinOp::Sub, false),\n+                    sym::mul_with_overflow => (BinOp::Mul, false),\n                     _ => bug!(\"Already checked for int ops\")\n                 };\n                 if ignore_overflow {\n@@ -177,10 +180,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.binop_with_overflow(bin_op, lhs, rhs, dest)?;\n                 }\n             }\n-            \"saturating_add\" | \"saturating_sub\" => {\n+            sym::saturating_add | sym::saturating_sub => {\n                 let l = self.read_immediate(args[0])?;\n                 let r = self.read_immediate(args[1])?;\n-                let is_add = intrinsic_name == \"saturating_add\";\n+                let is_add = intrinsic_name == sym::saturating_add;\n                 let (val, overflowed, _ty) = self.overflowing_binary_op(if is_add {\n                     BinOp::Add\n                 } else {\n@@ -220,12 +223,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 self.write_scalar(val, dest)?;\n             }\n-            \"unchecked_shl\" | \"unchecked_shr\" => {\n+            sym::unchecked_shl | sym::unchecked_shr => {\n                 let l = self.read_immediate(args[0])?;\n                 let r = self.read_immediate(args[1])?;\n                 let bin_op = match intrinsic_name {\n-                    \"unchecked_shl\" => BinOp::Shl,\n-                    \"unchecked_shr\" => BinOp::Shr,\n+                    sym::unchecked_shl => BinOp::Shl,\n+                    sym::unchecked_shr => BinOp::Shr,\n                     _ => bug!(\"Already checked for int ops\")\n                 };\n                 let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, l, r)?;\n@@ -236,7 +239,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 self.write_scalar(val, dest)?;\n             }\n-            \"rotate_left\" | \"rotate_right\" => {\n+            sym::rotate_left | sym::rotate_right => {\n                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n                 let layout = self.layout_of(substs.type_at(0))?;\n@@ -247,7 +250,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let width_bits = layout.size.bits() as u128;\n                 let shift_bits = raw_shift_bits % width_bits;\n                 let inv_shift_bits = (width_bits - shift_bits) % width_bits;\n-                let result_bits = if intrinsic_name == \"rotate_left\" {\n+                let result_bits = if intrinsic_name == sym::rotate_left {\n                     (val_bits << shift_bits) | (val_bits >> inv_shift_bits)\n                 } else {\n                     (val_bits >> shift_bits) | (val_bits << inv_shift_bits)\n@@ -257,7 +260,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(result, dest)?;\n             }\n \n-            \"ptr_offset_from\" => {\n+            sym::ptr_offset_from => {\n                 let isize_layout = self.layout_of(self.tcx.types.isize)?;\n                 let a = self.read_immediate(args[0])?.to_scalar()?;\n                 let b = self.read_immediate(args[1])?.to_scalar()?;\n@@ -303,10 +306,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            \"transmute\" => {\n+            sym::transmute => {\n                 self.copy_op_transmute(args[0], dest)?;\n             }\n-            \"simd_insert\" => {\n+            sym::simd_insert => {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n                 let elem = args[2];\n                 let input = args[0];\n@@ -337,7 +340,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.copy_op(value, place)?;\n                 }\n             }\n-            \"simd_extract\" => {\n+            sym::simd_extract => {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n                 let (len, e_ty) = args[0].layout.ty.simd_size_and_type(self.tcx.tcx);\n                 assert!("}, {"sha": "aec3cf04a97ca195cec04325bc6b0108b71d96a4", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -326,22 +326,6 @@ impl NonConstOp for ThreadLocalAccess {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct Transmute;\n-impl NonConstOp for Transmute {\n-    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n-        Some(tcx.features().const_transmute)\n-    }\n-\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-        feature_err(\n-            &item.tcx.sess.parse_sess, sym::const_transmute, span,\n-            &format!(\"The use of std::mem::transmute() is gated in {}s\", item.const_kind())\n-        )\n-        .emit();\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct UnionAccess;\n impl NonConstOp for UnionAccess {"}, {"sha": "78e6d879c4636b1020c7479ffb6e76dfc046a0a0", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -8,7 +8,6 @@ use rustc::traits::{self, TraitEngine};\n use rustc::ty::cast::CastTy;\n use rustc::ty::{self, TyCtxt};\n use rustc_index::bit_set::BitSet;\n-use rustc_target::spec::abi::Abi;\n use rustc_error_codes::*;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n@@ -564,23 +563,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 };\n \n                 // At this point, we are calling a function whose `DefId` is known...\n-\n-                if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = self.tcx.fn_sig(def_id).abi() {\n-                    assert!(!self.tcx.is_const_fn(def_id));\n-\n-                    if self.tcx.item_name(def_id) == sym::transmute {\n-                        self.check_op(ops::Transmute);\n-                        return;\n-                    }\n-\n-                    // To preserve the current semantics, we return early, allowing all\n-                    // intrinsics (except `transmute`) to pass unchecked to miri.\n-                    //\n-                    // FIXME: We should keep a whitelist of allowed intrinsics (or at least a\n-                    // blacklist of unimplemented ones) and fail here instead.\n-                    return;\n-                }\n-\n                 if self.tcx.is_const_fn(def_id) {\n                     return;\n                 }"}, {"sha": "b7e1b83ee05b8b5935859ce1fd44fbb43797a1f9", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -415,28 +415,28 @@ fn check_terminator(\n ///\n /// Adding more intrinsics requires sign-off from @rust-lang/lang.\n fn is_intrinsic_whitelisted(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n-    match &*tcx.item_name(def_id).as_str() {\n-        | \"size_of\"\n-        | \"min_align_of\"\n-        | \"needs_drop\"\n+    match tcx.item_name(def_id) {\n+        | sym::size_of\n+        | sym::min_align_of\n+        | sym::needs_drop\n         // Arithmetic:\n-        | \"add_with_overflow\" // ~> .overflowing_add\n-        | \"sub_with_overflow\" // ~> .overflowing_sub\n-        | \"mul_with_overflow\" // ~> .overflowing_mul\n-        | \"wrapping_add\" // ~> .wrapping_add\n-        | \"wrapping_sub\" // ~> .wrapping_sub\n-        | \"wrapping_mul\" // ~> .wrapping_mul\n-        | \"saturating_add\" // ~> .saturating_add\n-        | \"saturating_sub\" // ~> .saturating_sub\n-        | \"unchecked_shl\" // ~> .wrapping_shl\n-        | \"unchecked_shr\" // ~> .wrapping_shr\n-        | \"rotate_left\" // ~> .rotate_left\n-        | \"rotate_right\" // ~> .rotate_right\n-        | \"ctpop\" // ~> .count_ones\n-        | \"ctlz\" // ~> .leading_zeros\n-        | \"cttz\" // ~> .trailing_zeros\n-        | \"bswap\" // ~> .swap_bytes\n-        | \"bitreverse\" // ~> .reverse_bits\n+        | sym::add_with_overflow // ~> .overflowing_add\n+        | sym::sub_with_overflow // ~> .overflowing_sub\n+        | sym::mul_with_overflow // ~> .overflowing_mul\n+        | sym::wrapping_add // ~> .wrapping_add\n+        | sym::wrapping_sub // ~> .wrapping_sub\n+        | sym::wrapping_mul // ~> .wrapping_mul\n+        | sym::saturating_add // ~> .saturating_add\n+        | sym::saturating_sub // ~> .saturating_sub\n+        | sym::unchecked_shl // ~> .wrapping_shl\n+        | sym::unchecked_shr // ~> .wrapping_shr\n+        | sym::rotate_left // ~> .rotate_left\n+        | sym::rotate_right // ~> .rotate_right\n+        | sym::ctpop // ~> .count_ones\n+        | sym::ctlz // ~> .leading_zeros\n+        | sym::cttz // ~> .trailing_zeros\n+        | sym::bswap // ~> .swap_bytes\n+        | sym::bitreverse // ~> .reverse_bits\n         => true,\n         _ => false,\n     }"}, {"sha": "0d0b8598cc67de89950312816178e78954089171", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -121,6 +121,7 @@ symbols! {\n         abi_vectorcall,\n         abi_x86_interrupt,\n         aborts,\n+        add_with_overflow,\n         advanced_slice_patterns,\n         adx_target_feature,\n         alias,\n@@ -171,7 +172,10 @@ symbols! {\n         box_patterns,\n         box_syntax,\n         braced_empty_structs,\n+        bswap,\n+        bitreverse,\n         C,\n+        caller_location,\n         cdylib,\n         cfg,\n         cfg_attr,\n@@ -226,6 +230,11 @@ symbols! {\n         crate_name,\n         crate_type,\n         crate_visibility_modifier,\n+        ctpop,\n+        cttz,\n+        cttz_nonzero,\n+        ctlz,\n+        ctlz_nonzero,\n         custom_attribute,\n         custom_derive,\n         custom_inner_attributes,\n@@ -430,6 +439,7 @@ symbols! {\n         member_constraints,\n         message,\n         meta,\n+        min_align_of,\n         min_const_fn,\n         min_const_unsafe_fn,\n         mips_target_feature,\n@@ -439,11 +449,13 @@ symbols! {\n         more_struct_aliases,\n         move_val_init,\n         movbe_target_feature,\n+        mul_with_overflow,\n         must_use,\n         naked,\n         naked_functions,\n         name,\n         needs_allocator,\n+        needs_drop,\n         needs_panic_runtime,\n         negate_unsigned,\n         never,\n@@ -519,6 +531,7 @@ symbols! {\n         poll_with_tls_context,\n         powerpc_target_feature,\n         precise_pointer_size_matching,\n+        pref_align_of,\n         prelude,\n         prelude_import,\n         primitive,\n@@ -535,6 +548,7 @@ symbols! {\n         proc_macro_non_items,\n         proc_macro_path_invoc,\n         profiler_runtime,\n+        ptr_offset_from,\n         pub_restricted,\n         pushpop_unsafe,\n         quad_precision_float,\n@@ -570,6 +584,8 @@ symbols! {\n         Return,\n         rhs,\n         rlib,\n+        rotate_left,\n+        rotate_right,\n         rt,\n         rtm_target_feature,\n         rust,\n@@ -637,14 +653,19 @@ symbols! {\n         rvalue_static_promotion,\n         sanitize,\n         sanitizer_runtime,\n+        saturating_add,\n+        saturating_sub,\n         _Self,\n         self_in_typedefs,\n         self_struct_ctor,\n         should_panic,\n         simd,\n+        simd_extract,\n         simd_ffi,\n+        simd_insert,\n         since,\n         size,\n+        size_of,\n         slice_patterns,\n         slicing_syntax,\n         soft,\n@@ -672,6 +693,7 @@ symbols! {\n         structural_match,\n         struct_variant,\n         sty,\n+        sub_with_overflow,\n         suggestion,\n         target_feature,\n         target_has_atomic,\n@@ -707,6 +729,8 @@ symbols! {\n         Ty,\n         ty,\n         type_alias_impl_trait,\n+        type_id,\n+        type_name,\n         TyCtxt,\n         TyKind,\n         type_alias_enum_variants,\n@@ -719,6 +743,8 @@ symbols! {\n         u64,\n         u8,\n         unboxed_closures,\n+        unchecked_shl,\n+        unchecked_shr,\n         underscore_const_names,\n         underscore_imports,\n         underscore_lifetimes,\n@@ -752,6 +778,9 @@ symbols! {\n         while_let,\n         windows,\n         windows_subsystem,\n+        wrapping_add,\n+        wrapping_sub,\n+        wrapping_mul,\n         Yield,\n     }\n }"}, {"sha": "bdcf537859cc40d08364c1c3d4a2065e7f828315", "filename": "src/test/ui/consts/const-eval/const-eval-intrinsic-promotion.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -0,0 +1,6 @@\n+#![feature(core_intrinsics)]\n+fn main() {\n+    // Test that calls to intrinsics are never promoted\n+    let x: &'static usize =\n+        &std::intrinsics::size_of::<i32>(); //~ ERROR temporary value dropped while borrowed\n+}"}, {"sha": "78143042ece7bfc30aa3d714e4677d37571c448f", "filename": "src/test/ui/consts/const-eval/const-eval-intrinsic-promotion.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.stderr?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -0,0 +1,13 @@\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/const-eval-intrinsic-promotion.rs:5:10\n+   |\n+LL |     let x: &'static usize =\n+   |            -------------- type annotation requires that borrow lasts for `'static`\n+LL |         &std::intrinsics::size_of::<i32>();\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0716`."}, {"sha": "da532643d9457630088faef894324e6038542b11", "filename": "src/test/ui/feature-gates/feature-gate-const_transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.rs?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -4,6 +4,6 @@ use std::mem;\n struct Foo(u32);\n \n const TRANSMUTED_U32: u32 = unsafe { mem::transmute(Foo(3)) };\n-//~^ ERROR The use of std::mem::transmute() is gated in constants\n+//~^ ERROR `std::intrinsics::transmute` is not yet stable as a const fn\n \n fn main() {}"}, {"sha": "772e8d294781a0cd57fa1901bfb751236a090fde", "filename": "src/test/ui/feature-gates/feature-gate-const_transmute.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1bacb2dca610b0babeba526020e2b87899c2d44/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.stderr?ref=f1bacb2dca610b0babeba526020e2b87899c2d44", "patch": "@@ -1,12 +1,10 @@\n-error[E0658]: The use of std::mem::transmute() is gated in constants\n+error: `std::intrinsics::transmute` is not yet stable as a const fn\n   --> $DIR/feature-gate-const_transmute.rs:6:38\n    |\n LL | const TRANSMUTED_U32: u32 = unsafe { mem::transmute(Foo(3)) };\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/53605\n    = help: add `#![feature(const_transmute)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}]}