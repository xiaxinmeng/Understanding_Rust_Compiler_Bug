{"sha": "de0e695f629c27030584cf5263601fed333f5c0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMGU2OTVmNjI5YzI3MDMwNTg0Y2Y1MjYzNjAxZmVkMzMzZjVjMGE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-16T18:23:44Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-29T16:45:32Z"}, "message": "Check the substituted return type in return type suggestions.\n\nFixes #43420.", "tree": {"sha": "e591ec3c7d33fd5ea5494719fe59592d4e0b6815", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e591ec3c7d33fd5ea5494719fe59592d4e0b6815"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de0e695f629c27030584cf5263601fed333f5c0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de0e695f629c27030584cf5263601fed333f5c0a", "html_url": "https://github.com/rust-lang/rust/commit/de0e695f629c27030584cf5263601fed333f5c0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de0e695f629c27030584cf5263601fed333f5c0a/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c11b47745265dd48fe680bc2e8865e52a571408", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c11b47745265dd48fe680bc2e8865e52a571408", "html_url": "https://github.com/rust-lang/rust/commit/6c11b47745265dd48fe680bc2e8865e52a571408"}], "stats": {"total": 325, "additions": 205, "deletions": 120}, "files": [{"sha": "31ceed5b965bff71377c4b3f9e121c702167fecd", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de0e695f629c27030584cf5263601fed333f5c0a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0e695f629c27030584cf5263601fed333f5c0a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=de0e695f629c27030584cf5263601fed333f5c0a", "patch": "@@ -59,6 +59,9 @@ pub enum MethodError<'tcx> {\n     // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n     // forgotten to import a trait.\n     IllegalSizedBound(Vec<DefId>),\n+\n+    // Found a match, but the return type is wrong\n+    BadReturnType,\n }\n \n // Contains a list of static methods that may apply, a list of unsatisfied trait predicates which\n@@ -111,6 +114,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Err(Ambiguity(..)) => true,\n             Err(PrivateMatch(..)) => allow_private,\n             Err(IllegalSizedBound(..)) => true,\n+            Err(BadReturnType) => {\n+                bug!(\"no return type expectations but got BadReturnType\")\n+            }\n+\n         }\n     }\n "}, {"sha": "228b6c88f24db77cbca22040d670d251369c8ce5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 164, "deletions": 120, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/de0e695f629c27030584cf5263601fed333f5c0a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0e695f629c27030584cf5263601fed333f5c0a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=de0e695f629c27030584cf5263601fed333f5c0a", "patch": "@@ -32,15 +32,6 @@ use std::rc::Rc;\n use self::CandidateKind::*;\n pub use self::PickKind::*;\n \n-pub enum LookingFor<'tcx> {\n-    /// looking for methods with the given name; this is the normal case\n-    MethodName(ast::Name),\n-\n-    /// looking for methods that return a given type; this is used to\n-    /// assemble suggestions\n-    ReturnType(Ty<'tcx>),\n-}\n-\n /// Boolean flag used to indicate if this search is for a suggestion\n /// or not.  If true, we can allow ambiguity and so forth.\n pub struct IsSuggestion(pub bool);\n@@ -49,7 +40,8 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n     mode: Mode,\n-    looking_for: LookingFor<'tcx>,\n+    method_name: Option<ast::Name>,\n+    return_type: Option<Ty<'tcx>>,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n@@ -84,6 +76,7 @@ struct CandidateStep<'tcx> {\n #[derive(Debug)]\n struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n+    xform_ret_ty: Option<Ty<'tcx>>,\n     item: ty::AssociatedItem,\n     kind: CandidateKind<'tcx>,\n     import_id: Option<ast::NodeId>,\n@@ -100,6 +93,13 @@ enum CandidateKind<'tcx> {\n                          ty::PolyTraitRef<'tcx>),\n }\n \n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+enum ProbeResult {\n+    NoMatch,\n+    BadReturnType,\n+    Match,\n+}\n+\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub struct Pick<'tcx> {\n     pub item: ty::AssociatedItem,\n@@ -175,19 +175,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                return_type,\n                scope_expr_id);\n         let method_names =\n-            self.probe_op(span, mode, LookingFor::ReturnType(return_type), IsSuggestion(true),\n+            self.probe_op(span, mode, None, Some(return_type), IsSuggestion(true),\n                           self_ty, scope_expr_id, ProbeScope::TraitsInScope,\n                           |probe_cx| Ok(probe_cx.candidate_method_names()))\n                 .unwrap_or(vec![]);\n-        method_names\n-            .iter()\n-            .flat_map(|&method_name| {\n-                match self.probe_for_name(span, mode, method_name, IsSuggestion(true), self_ty,\n-                                          scope_expr_id, ProbeScope::TraitsInScope) {\n-                    Ok(pick) => Some(pick.item),\n-                    Err(_) => None,\n-                }\n-            })\n+         method_names\n+             .iter()\n+             .flat_map(|&method_name| {\n+                 self.probe_op(\n+                     span, mode, Some(method_name), Some(return_type),\n+                     IsSuggestion(true), self_ty, scope_expr_id,\n+                     ProbeScope::TraitsInScope, |probe_cx| probe_cx.pick()\n+                 ).ok().map(|pick| pick.item)\n+             })\n             .collect()\n     }\n \n@@ -206,7 +206,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                scope_expr_id);\n         self.probe_op(span,\n                       mode,\n-                      LookingFor::MethodName(item_name),\n+                      Some(item_name),\n+                      None,\n                       is_suggestion,\n                       self_ty,\n                       scope_expr_id,\n@@ -217,7 +218,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn probe_op<OP,R>(&'a self,\n                       span: Span,\n                       mode: Mode,\n-                      looking_for: LookingFor<'tcx>,\n+                      method_name: Option<ast::Name>,\n+                      return_type: Option<Ty<'tcx>>,\n                       is_suggestion: IsSuggestion,\n                       self_ty: Ty<'tcx>,\n                       scope_expr_id: ast::NodeId,\n@@ -259,7 +261,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n             let mut probe_cx =\n-                ProbeContext::new(self, span, mode, looking_for, steps);\n+                ProbeContext::new(self, span, mode, method_name, return_type, steps);\n \n             probe_cx.assemble_inherent_candidates();\n             match scope {\n@@ -329,14 +331,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n            span: Span,\n            mode: Mode,\n-           looking_for: LookingFor<'tcx>,\n+           method_name: Option<ast::Name>,\n+           return_type: Option<Ty<'tcx>>,\n            steps: Vec<CandidateStep<'tcx>>)\n            -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n             fcx,\n             span,\n             mode,\n-            looking_for,\n+            method_name,\n+            return_type,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: FxHashSet(),\n@@ -358,33 +362,25 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // CANDIDATE ASSEMBLY\n \n-    fn push_inherent_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n-                               kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n-        let is_accessible = if let LookingFor::MethodName(name) = self.looking_for {\n-            let def_scope = self.tcx.adjust(name, item.container.id(), self.body_id).1;\n-            item.vis.is_accessible_from(def_scope, self.tcx)\n-        } else {\n-            true\n-        };\n-        if is_accessible {\n-            self.inherent_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n-        } else if self.private_candidate.is_none() {\n-            self.private_candidate = Some(item.def());\n-        }\n-    }\n-\n-    fn push_extension_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n-                               kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n-        let is_accessible = if let LookingFor::MethodName(name) = self.looking_for {\n+    fn push_candidate(&mut self,\n+                      candidate: Candidate<'tcx>,\n+                      is_inherent: bool)\n+    {\n+        let is_accessible = if let Some(name) = self.method_name {\n+            let item = candidate.item;\n             let def_scope = self.tcx.adjust(name, item.container.id(), self.body_id).1;\n             item.vis.is_accessible_from(def_scope, self.tcx)\n         } else {\n             true\n         };\n         if is_accessible {\n-            self.extension_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n+            if is_inherent {\n+                self.inherent_candidates.push(candidate);\n+            } else {\n+                self.extension_candidates.push(candidate);\n+            }\n         } else if self.private_candidate.is_none() {\n-            self.private_candidate = Some(item.def());\n+            self.private_candidate = Some(candidate.item.def());\n         }\n     }\n \n@@ -522,19 +518,22 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n \n             // Determine the receiver type that the method itself expects.\n-            let xform_self_ty = self.xform_self_ty(&item, impl_ty, impl_substs);\n+            let xform_tys = self.xform_self_ty(&item, impl_ty, impl_substs);\n \n             // We can't use normalize_associated_types_in as it will pollute the\n             // fcx's fulfillment context after this probe is over.\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n             let selcx = &mut traits::SelectionContext::new(self.fcx);\n-            let traits::Normalized { value: xform_self_ty, obligations } =\n-                traits::normalize(selcx, self.param_env, cause, &xform_self_ty);\n-            debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n-                   xform_self_ty);\n-\n-            self.push_inherent_candidate(xform_self_ty, item,\n-                                         InherentImplCandidate(impl_substs, obligations), None);\n+            let traits::Normalized { value: (xform_self_ty, xform_ret_ty), obligations } =\n+                traits::normalize(selcx, self.param_env, cause, &xform_tys);\n+            debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}/{:?}\",\n+                   xform_self_ty, xform_ret_ty);\n+\n+            self.push_candidate(Candidate {\n+                xform_self_ty, xform_ret_ty, item,\n+                kind: InherentImplCandidate(impl_substs, obligations),\n+                import_id: None\n+            }, true);\n         }\n     }\n \n@@ -555,10 +554,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.elaborate_bounds(&[trait_ref], |this, new_trait_ref, item| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n-            let xform_self_ty =\n+            let (xform_self_ty, xform_ret_ty) =\n                 this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n-\n-            this.push_inherent_candidate(xform_self_ty, item, ObjectCandidate, None);\n+            this.push_candidate(Candidate {\n+                xform_self_ty, xform_ret_ty, item,\n+                kind: ObjectCandidate,\n+                import_id: None\n+            }, true);\n         });\n     }\n \n@@ -595,7 +597,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.elaborate_bounds(&bounds, |this, poly_trait_ref, item| {\n             let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);\n \n-            let xform_self_ty = this.xform_self_ty(&item, trait_ref.self_ty(), trait_ref.substs);\n+            let (xform_self_ty, xform_ret_ty) =\n+                this.xform_self_ty(&item, trait_ref.self_ty(), trait_ref.substs);\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n@@ -604,8 +607,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // `WhereClausePick`.\n             assert!(!trait_ref.substs.needs_infer());\n \n-            this.push_inherent_candidate(xform_self_ty, item,\n-                                         WhereClauseCandidate(poly_trait_ref), None);\n+            this.push_candidate(Candidate {\n+                xform_self_ty, xform_ret_ty, item,\n+                kind: WhereClauseCandidate(poly_trait_ref),\n+                import_id: None\n+            }, true);\n         });\n     }\n \n@@ -658,17 +664,27 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn matches_return_type(&self, method: &ty::AssociatedItem,\n-                               expected: ty::Ty<'tcx>) -> bool {\n+    pub fn matches_return_type(&self,\n+                               method: &ty::AssociatedItem,\n+                               self_ty: Option<Ty<'tcx>>,\n+                               expected: Ty<'tcx>) -> bool {\n         match method.def() {\n             Def::Method(def_id) => {\n                 let fty = self.tcx.fn_sig(def_id);\n                 self.probe(|_| {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);\n-                    let output = fty.output().subst(self.tcx, substs);\n-                    let (output, _) = self.replace_late_bound_regions_with_fresh_var(\n-                        self.span, infer::FnCall, &output);\n-                    self.can_sub(self.param_env, output, expected).is_ok()\n+                    let fty = fty.subst(self.tcx, substs);\n+                    let (fty, _) = self.replace_late_bound_regions_with_fresh_var(\n+                        self.span, infer::FnCall, &fty);\n+\n+                    if let Some(self_ty) = self_ty {\n+                        if let Err(_) = self.at(&ObligationCause::dummy(), self.param_env)\n+                            .sup(fty.inputs()[0], self_ty)\n+                        {\n+                            return false\n+                        }\n+                    }\n+                    self.can_sub(self.param_env, fty.output(), expected).is_ok()\n                 })\n             }\n             _ => false,\n@@ -692,23 +708,31 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 continue;\n             }\n \n-            let xform_self_ty = self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n-            self.push_extension_candidate(xform_self_ty, item,\n-                                          TraitCandidate(trait_ref),\n-                                          import_id);\n+            let (xform_self_ty, xform_ret_ty) =\n+                self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n+            self.push_candidate(Candidate {\n+                xform_self_ty, xform_ret_ty, item, import_id,\n+                kind: TraitCandidate(trait_ref),\n+            }, false);\n         }\n         Ok(())\n     }\n \n     fn candidate_method_names(&self) -> Vec<ast::Name> {\n         let mut set = FxHashSet();\n-        let mut names: Vec<_> =\n-            self.inherent_candidates\n-                .iter()\n-                .chain(&self.extension_candidates)\n-                .map(|candidate| candidate.item.name)\n-                .filter(|&name| set.insert(name))\n-                .collect();\n+        let mut names: Vec<_> = self.inherent_candidates\n+            .iter()\n+            .chain(&self.extension_candidates)\n+            .filter(|candidate| {\n+                if let Some(return_ty) = self.return_type {\n+                    self.matches_return_type(&candidate.item, None, return_ty)\n+                } else {\n+                    true\n+                }\n+            })\n+            .map(|candidate| candidate.item.name)\n+            .filter(|&name| set.insert(name))\n+            .collect();\n \n         // sort them by the name so we have a stable result\n         names.sort_by_key(|n| n.as_str());\n@@ -719,10 +743,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     // THE ACTUAL SEARCH\n \n     fn pick(mut self) -> PickResult<'tcx> {\n-        assert!(match self.looking_for {\n-            LookingFor::MethodName(_) => true,\n-            LookingFor::ReturnType(_) => false,\n-        });\n+        assert!(self.method_name.is_some());\n \n         if let Some(r) = self.pick_core() {\n             return r;\n@@ -877,7 +898,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                            possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>)\n                            -> Option<PickResult<'tcx>> {\n         let mut applicable_candidates: Vec<_> = probes.iter()\n-            .filter(|&probe| self.consider_probe(self_ty, probe, possibly_unsatisfied_predicates))\n+            .map(|probe| {\n+                (probe, self.consider_probe(self_ty, probe, possibly_unsatisfied_predicates))\n+            })\n+            .filter(|&(_, status)| status != ProbeResult::NoMatch)\n             .collect();\n \n         debug!(\"applicable_candidates: {:?}\", applicable_candidates);\n@@ -898,7 +922,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n-        applicable_candidates.pop().map(|probe| Ok(probe.to_unadjusted_pick()))\n+        applicable_candidates.pop().map(|(probe, status)| {\n+            if status == ProbeResult::Match {\n+                Ok(probe.to_unadjusted_pick())\n+            } else {\n+                Err(MethodError::BadReturnType)\n+            }\n+        })\n     }\n \n     fn select_trait_candidate(&self, trait_ref: ty::TraitRef<'tcx>)\n@@ -939,7 +969,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                       self_ty: Ty<'tcx>,\n                       probe: &Candidate<'tcx>,\n                       possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>)\n-                      -> bool {\n+                      -> ProbeResult {\n         debug!(\"consider_probe: self_ty={:?} probe={:?}\", self_ty, probe);\n \n         self.probe(|_| {\n@@ -949,11 +979,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n                 Err(_) => {\n                     debug!(\"--> cannot relate self-types\");\n-                    return false;\n+                    return ProbeResult::NoMatch;\n                 }\n             };\n \n-            let mut successful = true;\n+            let mut result = ProbeResult::Match;\n             let selcx = &mut traits::SelectionContext::new(self);\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n@@ -996,15 +1026,15 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             // This candidate's primary obligation doesn't even\n                             // select - don't bother registering anything in\n                             // `potentially_unsatisfied_predicates`.\n-                            return false\n+                            return ProbeResult::NoMatch;\n                         } else {\n                             // Some nested subobligation of this predicate\n                             // failed.\n                             //\n                             // FIXME: try to find the exact nested subobligation\n                             // and point at it rather than reporting the entire\n                             // trait-ref?\n-                            successful = false;\n+                            result = ProbeResult::NoMatch;\n                             let trait_ref = self.resolve_type_vars_if_possible(&trait_ref);\n                             possibly_unsatisfied_predicates.push(trait_ref);\n                         }\n@@ -1020,13 +1050,31 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             for o in candidate_obligations.into_iter().chain(sub_obligations) {\n                 let o = self.resolve_type_vars_if_possible(&o);\n                 if !selcx.evaluate_obligation(&o) {\n-                    successful = false;\n+                    result = ProbeResult::NoMatch;\n                     if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n                         possibly_unsatisfied_predicates.push(pred.0.trait_ref);\n                     }\n                 }\n             }\n-            successful\n+\n+            if let ProbeResult::Match = result {\n+                if let (Some(return_ty), Some(xform_ret_ty)) =\n+                    (self.return_type, probe.xform_ret_ty)\n+                {\n+                    let xform_ret_ty = self.resolve_type_vars_if_possible(&xform_ret_ty);\n+                    debug!(\"comparing return_ty {:?} with xform ret ty {:?}\",\n+                           return_ty,\n+                           probe.xform_ret_ty);\n+                    if self.at(&ObligationCause::dummy(), self.param_env)\n+                        .sup(return_ty, xform_ret_ty)\n+                        .is_err()\n+                    {\n+                        return ProbeResult::BadReturnType;\n+                    }\n+                }\n+            }\n+\n+            result\n         })\n     }\n \n@@ -1047,22 +1095,25 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     ///\n     /// Now imagine the receiver is `Vec<_>`. It doesn't really matter at this time which impl we\n     /// use, so it's ok to just commit to \"using the method from the trait Foo\".\n-    fn collapse_candidates_to_trait_pick(&self, probes: &[&Candidate<'tcx>]) -> Option<Pick<'tcx>> {\n+    fn collapse_candidates_to_trait_pick(&self, probes: &[(&Candidate<'tcx>, ProbeResult)])\n+                                         -> Option<Pick<'tcx>>\n+    {\n         // Do all probes correspond to the same trait?\n-        let container = probes[0].item.container;\n+        let container = probes[0].0.item.container;\n         match container {\n             ty::TraitContainer(_) => {}\n             ty::ImplContainer(_) => return None,\n         }\n-        if probes[1..].iter().any(|p| p.item.container != container) {\n+        if probes[1..].iter().any(|&(p, _)| p.item.container != container) {\n             return None;\n         }\n \n+        // FIXME: check the return type here somehow.\n         // If so, just use this trait and call it a day.\n         Some(Pick {\n-            item: probes[0].item.clone(),\n+            item: probes[0].0.item.clone(),\n             kind: TraitPick,\n-            import_id: probes[0].import_id,\n+            import_id: probes[0].0.import_id,\n             autoderefs: 0,\n             autoref: None,\n             unsize: None,\n@@ -1100,23 +1151,23 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                      item: &ty::AssociatedItem,\n                      impl_ty: Ty<'tcx>,\n                      substs: &Substs<'tcx>)\n-                     -> Ty<'tcx> {\n+                     -> (Ty<'tcx>, Option<Ty<'tcx>>) {\n         if item.kind == ty::AssociatedKind::Method && self.mode == Mode::MethodCall {\n-            self.xform_method_self_ty(item.def_id, impl_ty, substs)\n+            let sig = self.xform_method_sig(item.def_id, substs);\n+            (sig.inputs()[0], Some(sig.output()))\n         } else {\n-            impl_ty\n+            (impl_ty, None)\n         }\n     }\n \n-    fn xform_method_self_ty(&self,\n-                            method: DefId,\n-                            impl_ty: Ty<'tcx>,\n-                            substs: &Substs<'tcx>)\n-                            -> Ty<'tcx> {\n-        let self_ty = self.tcx.fn_sig(method).input(0);\n-        debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n-               impl_ty,\n-               self_ty,\n+    fn xform_method_sig(&self,\n+                        method: DefId,\n+                        substs: &Substs<'tcx>)\n+                        -> ty::FnSig<'tcx>\n+    {\n+        let fn_sig = self.tcx.fn_sig(method);\n+        debug!(\"xform_self_ty(fn_sig={:?}, substs={:?})\",\n+               fn_sig,\n                substs);\n \n         assert!(!substs.has_escaping_regions());\n@@ -1132,10 +1183,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         // Erase any late-bound regions from the method and substitute\n         // in the values from the substitution.\n-        let xform_self_ty = self.erase_late_bound_regions(&self_ty);\n+        let xform_fn_sig = self.erase_late_bound_regions(&fn_sig);\n \n         if generics.types.is_empty() && generics.regions.is_empty() {\n-            xform_self_ty.subst(self.tcx, substs)\n+            xform_fn_sig.subst(self.tcx, substs)\n         } else {\n             let substs = Substs::for_item(self.tcx, method, |def, _| {\n                 let i = def.index as usize;\n@@ -1154,7 +1205,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     self.type_var_for_def(self.span, def, cur_substs)\n                 }\n             });\n-            xform_self_ty.subst(self.tcx, substs)\n+            xform_fn_sig.subst(self.tcx, substs)\n         }\n     }\n \n@@ -1198,17 +1249,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     /// Find the method with the appropriate name (or return type, as the case may be).\n     fn impl_or_trait_item(&self, def_id: DefId) -> Vec<ty::AssociatedItem> {\n-        match self.looking_for {\n-            LookingFor::MethodName(name) => {\n-                self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n-            }\n-            LookingFor::ReturnType(return_ty) => {\n-                self.tcx\n-                    .associated_items(def_id)\n-                    .map(|did| self.tcx.associated_item(did.def_id))\n-                    .filter(|m| self.matches_return_type(m, return_ty))\n-                    .collect()\n-            }\n+        if let Some(name) = self.method_name {\n+            self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n+        } else {\n+            self.tcx.associated_items(def_id).collect()\n         }\n     }\n }"}, {"sha": "f2d7842e473f61df3e943edf823badbbc8d3f147", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de0e695f629c27030584cf5263601fed333f5c0a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0e695f629c27030584cf5263601fed333f5c0a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=de0e695f629c27030584cf5263601fed333f5c0a", "patch": "@@ -321,6 +321,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 err.emit();\n             }\n+\n+            MethodError::BadReturnType => {\n+                bug!(\"no return type expectations but got BadReturnType\")\n+            }\n         }\n     }\n "}, {"sha": "d504b7cae28c4bb36d25e5c22a6bc19c849d9460", "filename": "src/test/ui/suggestions/issue-43420-no-over-suggest.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/de0e695f629c27030584cf5263601fed333f5c0a/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0e695f629c27030584cf5263601fed333f5c0a/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.rs?ref=de0e695f629c27030584cf5263601fed333f5c0a", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that we substitute type parameters before we suggest anything - otherwise\n+// we would suggest function such as `as_slice` for the `&[u16]`.\n+\n+fn foo(b: &[u16]) {}\n+\n+fn main() {\n+    let a: Vec<u8> = Vec::new();\n+    foo(&a);\n+}"}, {"sha": "bcad9ce56c65e8dc1f2c28d286dc3b01eb1dca22", "filename": "src/test/ui/suggestions/issue-43420-no-over-suggest.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de0e695f629c27030584cf5263601fed333f5c0a/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de0e695f629c27030584cf5263601fed333f5c0a/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.stderr?ref=de0e695f629c27030584cf5263601fed333f5c0a", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-43420-no-over-suggest.rs:18:9\n+   |\n+18 |     foo(&a);\n+   |         ^^ expected slice, found struct `std::vec::Vec`\n+   |\n+   = note: expected type `&[u16]`\n+              found type `&std::vec::Vec<u8>`\n+\n+error: aborting due to previous error\n+"}]}