{"sha": "746222fd9d6c16d3dc3c44c797dcc868297c133b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NjIyMmZkOWQ2YzE2ZDNkYzNjNDRjNzk3ZGNjODY4Mjk3YzEzM2I=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-29T01:07:19Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-29T01:07:19Z"}, "message": "Switch to using syscall crate directly - without import", "tree": {"sha": "3d5247c2bcfbe2e42438e38dd54133ee55af484e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d5247c2bcfbe2e42438e38dd54133ee55af484e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/746222fd9d6c16d3dc3c44c797dcc868297c133b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/746222fd9d6c16d3dc3c44c797dcc868297c133b", "html_url": "https://github.com/rust-lang/rust/commit/746222fd9d6c16d3dc3c44c797dcc868297c133b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/746222fd9d6c16d3dc3c44c797dcc868297c133b/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d73d32f58d477ca1562e3fc0e966efc88e81409e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d73d32f58d477ca1562e3fc0e966efc88e81409e", "html_url": "https://github.com/rust-lang/rust/commit/d73d32f58d477ca1562e3fc0e966efc88e81409e"}], "stats": {"total": 359, "additions": 171, "deletions": 188}, "files": [{"sha": "7e26162efbc8e54678e5e0500cfac154922739fe", "filename": "src/libstd/sys/redox/condvar.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -3,9 +3,8 @@ use intrinsics::{atomic_cxchg, atomic_xadd, atomic_xchg};\n use ptr;\n use time::Duration;\n \n-use super::mutex::{mutex_lock, mutex_unlock, Mutex};\n-\n-use libc::{futex, FUTEX_WAIT, FUTEX_WAKE, FUTEX_REQUEUE};\n+use sys::mutex::{mutex_lock, mutex_unlock, Mutex};\n+use sys::syscall::{futex, FUTEX_WAIT, FUTEX_WAKE, FUTEX_REQUEUE};\n \n pub struct Condvar {\n     lock: UnsafeCell<*mut i32>,"}, {"sha": "d292b43872439d579ce09447c0a0fe0634da5eb9", "filename": "src/libstd/sys/redox/ext/fs.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -216,7 +216,6 @@ impl MetadataExt for fs::Metadata {\n     }\n }\n \n-/* TODO\n /// Add special unix types (block/char device, fifo and socket)\n #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n pub trait FileTypeExt {\n@@ -236,12 +235,11 @@ pub trait FileTypeExt {\n \n #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n impl FileTypeExt for fs::FileType {\n-    fn is_block_device(&self) -> bool { self.as_inner().is(libc::S_IFBLK) }\n-    fn is_char_device(&self) -> bool { self.as_inner().is(libc::S_IFCHR) }\n-    fn is_fifo(&self) -> bool { self.as_inner().is(libc::S_IFIFO) }\n-    fn is_socket(&self) -> bool { self.as_inner().is(libc::S_IFSOCK) }\n+    fn is_block_device(&self) -> bool { false /*TODO*/ }\n+    fn is_char_device(&self) -> bool { false /*TODO*/ }\n+    fn is_fifo(&self) -> bool { false /*TODO*/ }\n+    fn is_socket(&self) -> bool { false /*TODO*/ }\n }\n-*/\n \n /// Creates a new symbolic link on the filesystem.\n ///"}, {"sha": "02edfa84aa090e18d431973e26ce9235d1d42abf", "filename": "src/libstd/sys/redox/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -44,7 +44,7 @@ pub mod prelude {\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::ffi::{OsStrExt, OsStringExt};\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::fs::{PermissionsExt, OpenOptionsExt, MetadataExt};\n+    pub use super::fs::{FileTypeExt, PermissionsExt, OpenOptionsExt, MetadataExt};\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::process::{CommandExt, ExitStatusExt};\n }"}, {"sha": "3a7c59d4e6d09d32e1aefbb5331fc60f8589eee8", "filename": "src/libstd/sys/redox/ext/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -86,12 +86,12 @@ pub trait CommandExt {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CommandExt for process::Command {\n     fn uid(&mut self, id: u32) -> &mut process::Command {\n-        self.as_inner_mut().uid(id as usize);\n+        self.as_inner_mut().uid(id);\n         self\n     }\n \n     fn gid(&mut self, id: u32) -> &mut process::Command {\n-        self.as_inner_mut().gid(id as usize);\n+        self.as_inner_mut().gid(id);\n         self\n     }\n "}, {"sha": "4c8e62d1863b6ed60d18bfb73c7b32c2e5a2e800", "filename": "src/libstd/sys/redox/fd.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -11,9 +11,8 @@\n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n use io::{self, Read};\n-use libc;\n use mem;\n-use sys::cvt;\n+use sys::{cvt, syscall};\n use sys_common::AsInner;\n use sys_common::io::read_to_end_uninitialized;\n \n@@ -36,7 +35,7 @@ impl FileDesc {\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        cvt(libc::read(self.fd, buf))\n+        cvt(syscall::read(self.fd, buf))\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n@@ -45,33 +44,33 @@ impl FileDesc {\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        cvt(libc::write(self.fd, buf))\n+        cvt(syscall::write(self.fd, buf))\n     }\n \n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n-        let new_fd = cvt(libc::dup(self.fd, &[]))?;\n+        let new_fd = cvt(syscall::dup(self.fd, &[]))?;\n         Ok(FileDesc::new(new_fd))\n     }\n \n     pub fn nonblocking(&self) -> io::Result<bool> {\n-        let flags = cvt(libc::fcntl(self.fd, libc::F_GETFL, 0))?;\n-        Ok(flags & libc::O_NONBLOCK == libc::O_NONBLOCK)\n+        let flags = cvt(syscall::fcntl(self.fd, syscall::F_GETFL, 0))?;\n+        Ok(flags & syscall::O_NONBLOCK == syscall::O_NONBLOCK)\n     }\n \n     pub fn set_cloexec(&self) -> io::Result<()> {\n-        let mut flags = cvt(libc::fcntl(self.fd, libc::F_GETFL, 0))?;\n-        flags |= libc::O_CLOEXEC;\n-        cvt(libc::fcntl(self.fd, libc::F_SETFL, flags)).and(Ok(()))\n+        let mut flags = cvt(syscall::fcntl(self.fd, syscall::F_GETFL, 0))?;\n+        flags |= syscall::O_CLOEXEC;\n+        cvt(syscall::fcntl(self.fd, syscall::F_SETFL, flags)).and(Ok(()))\n     }\n \n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        let mut flags = cvt(libc::fcntl(self.fd, libc::F_GETFL, 0))?;\n+        let mut flags = cvt(syscall::fcntl(self.fd, syscall::F_GETFL, 0))?;\n         if nonblocking {\n-            flags |= libc::O_NONBLOCK;\n+            flags |= syscall::O_NONBLOCK;\n         } else {\n-            flags &= !libc::O_NONBLOCK;\n+            flags &= !syscall::O_NONBLOCK;\n         }\n-        cvt(libc::fcntl(self.fd, libc::F_SETFL, flags)).and(Ok(()))\n+        cvt(syscall::fcntl(self.fd, syscall::F_SETFL, flags)).and(Ok(()))\n     }\n }\n \n@@ -96,6 +95,6 @@ impl Drop for FileDesc {\n         // the file descriptor was closed or not, and if we retried (for\n         // something like EINTR), we might close another valid file descriptor\n         // (opened after we closed ours.\n-        let _ = libc::close(self.fd);\n+        let _ = syscall::close(self.fd);\n     }\n }"}, {"sha": "80aec2e978dd01f01258998b5c74c4c77cebd6fc", "filename": "src/libstd/sys/redox/fs.rs", "status": "modified", "additions": 59, "deletions": 66, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -13,21 +13,18 @@ use os::unix::prelude::*;\n use ffi::{OsString, OsStr};\n use fmt;\n use io::{self, Error, ErrorKind, SeekFrom};\n-use libc::{self, c_int, mode_t};\n use path::{Path, PathBuf};\n use sync::Arc;\n use sys::fd::FileDesc;\n use sys::time::SystemTime;\n-use sys::cvt;\n+use sys::{cvt, syscall};\n use sys_common::{AsInner, FromInner};\n \n-use libc::{stat, fstat, fsync, ftruncate, lseek, open};\n-\n pub struct File(FileDesc);\n \n #[derive(Clone)]\n pub struct FileAttr {\n-    stat: stat,\n+    stat: syscall::Stat,\n }\n \n pub struct ReadDir {\n@@ -57,53 +54,53 @@ pub struct OpenOptions {\n     create_new: bool,\n     // system-specific\n     custom_flags: i32,\n-    mode: mode_t,\n+    mode: u16,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct FilePermissions { mode: mode_t }\n+pub struct FilePermissions { mode: u16 }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct FileType { mode: mode_t }\n+pub struct FileType { mode: u16 }\n \n-pub struct DirBuilder { mode: mode_t }\n+pub struct DirBuilder { mode: u16 }\n \n impl FileAttr {\n     pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n     pub fn perm(&self) -> FilePermissions {\n-        FilePermissions { mode: (self.stat.st_mode as mode_t) & 0o777 }\n+        FilePermissions { mode: (self.stat.st_mode as u16) & 0o777 }\n     }\n \n     pub fn file_type(&self) -> FileType {\n-        FileType { mode: self.stat.st_mode as mode_t }\n+        FileType { mode: self.stat.st_mode as u16 }\n     }\n }\n \n impl FileAttr {\n     pub fn modified(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_mtime as libc::time_t,\n+        Ok(SystemTime::from(syscall::TimeSpec {\n+            tv_sec: self.stat.st_mtime as i64,\n             tv_nsec: self.stat.st_mtime_nsec as i32,\n         }))\n     }\n \n     pub fn accessed(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_atime as libc::time_t,\n+        Ok(SystemTime::from(syscall::TimeSpec {\n+            tv_sec: self.stat.st_atime as i64,\n             tv_nsec: self.stat.st_atime_nsec as i32,\n         }))\n     }\n \n     pub fn created(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_ctime as libc::time_t,\n+        Ok(SystemTime::from(syscall::TimeSpec {\n+            tv_sec: self.stat.st_ctime as i64,\n             tv_nsec: self.stat.st_ctime_nsec as i32,\n         }))\n     }\n }\n \n-impl AsInner<stat> for FileAttr {\n-    fn as_inner(&self) -> &stat { &self.stat }\n+impl AsInner<syscall::Stat> for FileAttr {\n+    fn as_inner(&self) -> &syscall::Stat { &self.stat }\n }\n \n impl FilePermissions {\n@@ -119,16 +116,16 @@ impl FilePermissions {\n }\n \n impl FileType {\n-    pub fn is_dir(&self) -> bool { self.is(libc::MODE_DIR) }\n-    pub fn is_file(&self) -> bool { self.is(libc::MODE_FILE) }\n+    pub fn is_dir(&self) -> bool { self.is(syscall::MODE_DIR) }\n+    pub fn is_file(&self) -> bool { self.is(syscall::MODE_FILE) }\n     pub fn is_symlink(&self) -> bool { false }\n \n-    pub fn is(&self, mode: mode_t) -> bool { self.mode & (libc::MODE_DIR | libc::MODE_FILE) == mode }\n+    pub fn is(&self, mode: u16) -> bool { self.mode & (syscall::MODE_DIR | syscall::MODE_FILE) == mode }\n }\n \n impl FromInner<u32> for FilePermissions {\n     fn from_inner(mode: u32) -> FilePermissions {\n-        FilePermissions { mode: mode as mode_t }\n+        FilePermissions { mode: mode as u16 }\n     }\n }\n \n@@ -215,60 +212,60 @@ impl OpenOptions {\n     pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n \n     pub fn custom_flags(&mut self, flags: i32) { self.custom_flags = flags; }\n-    pub fn mode(&mut self, mode: u32) { self.mode = mode as mode_t; }\n+    pub fn mode(&mut self, mode: u32) { self.mode = mode as u16; }\n \n-    fn get_access_mode(&self) -> io::Result<c_int> {\n+    fn get_access_mode(&self) -> io::Result<usize> {\n         match (self.read, self.write, self.append) {\n-            (true,  false, false) => Ok(libc::O_RDONLY as c_int),\n-            (false, true,  false) => Ok(libc::O_WRONLY as c_int),\n-            (true,  true,  false) => Ok(libc::O_RDWR as c_int),\n-            (false, _,     true)  => Ok(libc::O_WRONLY as c_int | libc::O_APPEND as c_int),\n-            (true,  _,     true)  => Ok(libc::O_RDWR as c_int | libc::O_APPEND as c_int),\n-            (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),\n+            (true,  false, false) => Ok(syscall::O_RDONLY),\n+            (false, true,  false) => Ok(syscall::O_WRONLY),\n+            (true,  true,  false) => Ok(syscall::O_RDWR),\n+            (false, _,     true)  => Ok(syscall::O_WRONLY | syscall::O_APPEND),\n+            (true,  _,     true)  => Ok(syscall::O_RDWR | syscall::O_APPEND),\n+            (false, false, false) => Err(Error::from_raw_os_error(syscall::EINVAL)),\n         }\n     }\n \n-    fn get_creation_mode(&self) -> io::Result<c_int> {\n+    fn get_creation_mode(&self) -> io::Result<usize> {\n         match (self.write, self.append) {\n             (true, false) => {}\n             (false, false) =>\n                 if self.truncate || self.create || self.create_new {\n-                    return Err(Error::from_raw_os_error(libc::EINVAL));\n+                    return Err(Error::from_raw_os_error(syscall::EINVAL));\n                 },\n             (_, true) =>\n                 if self.truncate && !self.create_new {\n-                    return Err(Error::from_raw_os_error(libc::EINVAL));\n+                    return Err(Error::from_raw_os_error(syscall::EINVAL));\n                 },\n         }\n \n         Ok(match (self.create, self.truncate, self.create_new) {\n                 (false, false, false) => 0,\n-                (true,  false, false) => libc::O_CREAT as c_int,\n-                (false, true,  false) => libc::O_TRUNC as c_int,\n-                (true,  true,  false) => libc::O_CREAT as c_int | libc::O_TRUNC as c_int,\n-                (_,      _,    true)  => libc::O_CREAT as c_int | libc::O_EXCL as c_int,\n+                (true,  false, false) => syscall::O_CREAT,\n+                (false, true,  false) => syscall::O_TRUNC,\n+                (true,  true,  false) => syscall::O_CREAT | syscall::O_TRUNC,\n+                (_,      _,    true)  => syscall::O_CREAT | syscall::O_EXCL,\n            })\n     }\n }\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let flags = libc::O_CLOEXEC |\n+        let flags = syscall::O_CLOEXEC |\n                     opts.get_access_mode()? as usize |\n                     opts.get_creation_mode()? as usize |\n-                    (opts.custom_flags as usize & !libc::O_ACCMODE);\n-        let fd = cvt(open(path.to_str().unwrap(), flags | opts.mode as usize))?;\n+                    (opts.custom_flags as usize & !syscall::O_ACCMODE);\n+        let fd = cvt(syscall::open(path.to_str().unwrap(), flags | opts.mode as usize))?;\n         Ok(File(FileDesc::new(fd)))\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        let mut stat: stat = stat::default();\n-        cvt(fstat(self.0.raw(), &mut stat))?;\n+        let mut stat = syscall::Stat::default();\n+        cvt(syscall::fstat(self.0.raw(), &mut stat))?;\n         Ok(FileAttr { stat: stat })\n     }\n \n     pub fn fsync(&self) -> io::Result<()> {\n-        cvt(fsync(self.0.raw()))?;\n+        cvt(syscall::fsync(self.0.raw()))?;\n         Ok(())\n     }\n \n@@ -277,7 +274,7 @@ impl File {\n     }\n \n     pub fn truncate(&self, size: u64) -> io::Result<()> {\n-        cvt(ftruncate(self.0.raw(), size as usize))?;\n+        cvt(syscall::ftruncate(self.0.raw(), size as usize))?;\n         Ok(())\n     }\n \n@@ -299,11 +296,11 @@ impl File {\n         let (whence, pos) = match pos {\n             // Casting to `i64` is fine, too large values will end up as\n             // negative which will cause an error in `lseek64`.\n-            SeekFrom::Start(off) => (libc::SEEK_SET, off as i64),\n-            SeekFrom::End(off) => (libc::SEEK_END, off),\n-            SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n+            SeekFrom::Start(off) => (syscall::SEEK_SET, off as i64),\n+            SeekFrom::End(off) => (syscall::SEEK_END, off),\n+            SeekFrom::Current(off) => (syscall::SEEK_CUR, off),\n         };\n-        let n = cvt(lseek(self.0.raw(), pos as isize, whence))?;\n+        let n = cvt(syscall::lseek(self.0.raw(), pos as isize, whence))?;\n         Ok(n as u64)\n     }\n \n@@ -312,7 +309,7 @@ impl File {\n     }\n \n     pub fn dup(&self, buf: &[u8]) -> io::Result<File> {\n-        let fd = cvt(libc::dup(*self.fd().as_inner() as usize, buf))?;\n+        let fd = cvt(syscall::dup(*self.fd().as_inner() as usize, buf))?;\n         Ok(File(FileDesc::new(fd)))\n     }\n \n@@ -322,7 +319,7 @@ impl File {\n \n     pub fn path(&self) -> io::Result<PathBuf> {\n         let mut buf: [u8; 4096] = [0; 4096];\n-        match libc::fpath(*self.fd().as_inner() as usize, &mut buf) {\n+        match syscall::fpath(*self.fd().as_inner() as usize, &mut buf) {\n             Ok(count) => Ok(PathBuf::from(unsafe { String::from_utf8_unchecked(Vec::from(&buf[0..count])) })),\n             Err(err) => Err(Error::from_raw_os_error(err.errno)),\n         }\n@@ -339,13 +336,13 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let fd = cvt(libc::open(p.to_str().unwrap(), libc::O_CREAT | libc::O_DIRECTORY | libc::O_EXCL | (self.mode as usize & 0o777)))?;\n-        let _ = libc::close(fd);\n+        let fd = cvt(syscall::open(p.to_str().unwrap(), syscall::O_CREAT | syscall::O_DIRECTORY | syscall::O_EXCL | (self.mode as usize & 0o777)))?;\n+        let _ = syscall::close(fd);\n         Ok(())\n     }\n \n     pub fn set_mode(&mut self, mode: u32) {\n-        self.mode = mode as mode_t;\n+        self.mode = mode as u16;\n     }\n }\n \n@@ -374,7 +371,7 @@ impl fmt::Debug for File {\n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n     let root = Arc::new(p.to_path_buf());\n \n-    let fd = cvt(open(p.to_str().unwrap(), libc::O_CLOEXEC | libc::O_RDONLY | libc::O_DIRECTORY))?;\n+    let fd = cvt(syscall::open(p.to_str().unwrap(), syscall::O_CLOEXEC | syscall::O_RDONLY | syscall::O_DIRECTORY))?;\n     let file = FileDesc::new(fd);\n     let mut data = Vec::new();\n     file.read_to_end(&mut data)?;\n@@ -383,7 +380,7 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    cvt(libc::unlink(p.to_str().unwrap()))?;\n+    cvt(syscall::unlink(p.to_str().unwrap()))?;\n     Ok(())\n }\n \n@@ -393,12 +390,12 @@ pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n }\n \n pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    cvt(libc::chmod(p.to_str().unwrap(), perm.mode as usize))?;\n+    cvt(syscall::chmod(p.to_str().unwrap(), perm.mode as usize))?;\n     Ok(())\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    cvt(libc::rmdir(p.to_str().unwrap()))?;\n+    cvt(syscall::rmdir(p.to_str().unwrap()))?;\n     Ok(())\n }\n \n@@ -438,21 +435,17 @@ pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let mut stat: stat = stat::default();\n-\n-    let fd = cvt(open(p.to_str().unwrap(), libc::O_CLOEXEC | libc::O_STAT))?;\n-    cvt(fstat(fd, &mut stat))?;\n-    let _ = libc::close(fd);\n-\n-    Ok(FileAttr { stat: stat })\n+    let fd = cvt(syscall::open(p.to_str().unwrap(), syscall::O_CLOEXEC | syscall::O_STAT))?;\n+    let file = File(FileDesc::new(fd));\n+    file.file_attr()\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n     stat(p)\n }\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n-    let fd = cvt(open(p.to_str().unwrap(), libc::O_CLOEXEC | libc::O_STAT))?;\n+    let fd = cvt(syscall::open(p.to_str().unwrap(), syscall::O_CLOEXEC | syscall::O_STAT))?;\n     let file = File(FileDesc::new(fd));\n     file.path()\n }"}, {"sha": "07ead22b7a892e44735ab563c228a15e71ede458", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -1,7 +1,8 @@\n #![allow(dead_code, missing_docs, bad_style)]\n \n+pub extern crate syscall;\n+\n use io::{self, ErrorKind};\n-use libc;\n \n pub mod args;\n pub mod backtrace;\n@@ -42,40 +43,40 @@ pub fn init() {\n         use intrinsics;\n         let msg = \"fatal runtime error: out of memory\\n\";\n         unsafe {\n-            let _ = libc::write(libc::STDERR_FILENO, msg.as_bytes());\n+            let _ = syscall::write(2, msg.as_bytes());\n             intrinsics::abort();\n         }\n     }\n }\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n-    match errno as libc::c_int {\n-        libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n-        libc::ECONNRESET => ErrorKind::ConnectionReset,\n-        libc::EPERM | libc::EACCES => ErrorKind::PermissionDenied,\n-        libc::EPIPE => ErrorKind::BrokenPipe,\n-        libc::ENOTCONN => ErrorKind::NotConnected,\n-        libc::ECONNABORTED => ErrorKind::ConnectionAborted,\n-        libc::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n-        libc::EADDRINUSE => ErrorKind::AddrInUse,\n-        libc::ENOENT => ErrorKind::NotFound,\n-        libc::EINTR => ErrorKind::Interrupted,\n-        libc::EINVAL => ErrorKind::InvalidInput,\n-        libc::ETIMEDOUT => ErrorKind::TimedOut,\n-        libc::EEXIST => ErrorKind::AlreadyExists,\n+    match errno {\n+        syscall::ECONNREFUSED => ErrorKind::ConnectionRefused,\n+        syscall::ECONNRESET => ErrorKind::ConnectionReset,\n+        syscall::EPERM | syscall::EACCES => ErrorKind::PermissionDenied,\n+        syscall::EPIPE => ErrorKind::BrokenPipe,\n+        syscall::ENOTCONN => ErrorKind::NotConnected,\n+        syscall::ECONNABORTED => ErrorKind::ConnectionAborted,\n+        syscall::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n+        syscall::EADDRINUSE => ErrorKind::AddrInUse,\n+        syscall::ENOENT => ErrorKind::NotFound,\n+        syscall::EINTR => ErrorKind::Interrupted,\n+        syscall::EINVAL => ErrorKind::InvalidInput,\n+        syscall::ETIMEDOUT => ErrorKind::TimedOut,\n+        syscall::EEXIST => ErrorKind::AlreadyExists,\n \n         // These two constants can have the same value on some systems,\n         // but different values on others, so we can't use a match\n         // clause\n-        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+        x if x == syscall::EAGAIN || x == syscall::EWOULDBLOCK =>\n             ErrorKind::WouldBlock,\n \n         _ => ErrorKind::Other,\n     }\n }\n \n-pub fn cvt(result: Result<usize, libc::Error>) -> io::Result<usize> {\n-    result.map_err(|err| io::Error::from_raw_os_error(err.errno as i32))\n+pub fn cvt(result: Result<usize, syscall::Error>) -> io::Result<usize> {\n+    result.map_err(|err| io::Error::from_raw_os_error(err.errno))\n }\n \n /// On Redox, use an illegal instruction to abort"}, {"sha": "42424da858fbc844b2ba41bbd6ed81597616068e", "filename": "src/libstd/sys/redox/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -2,7 +2,7 @@ use cell::UnsafeCell;\n use intrinsics::{atomic_cxchg, atomic_xchg};\n use ptr;\n \n-use libc::{futex, getpid, FUTEX_WAIT, FUTEX_WAKE};\n+use sys::syscall::{futex, getpid, FUTEX_WAIT, FUTEX_WAKE};\n \n pub unsafe fn mutex_try_lock(m: *mut i32) -> bool {\n     atomic_cxchg(m, 0, 1).0 == 0"}, {"sha": "92c7d72887bf07a177b4d4eebb27409ba239fc9d", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -4,7 +4,7 @@ use iter::Iterator;\n use net::{Ipv4Addr, SocketAddr, SocketAddrV4};\n use str::FromStr;\n use string::{String, ToString};\n-use libc::EINVAL;\n+use sys::syscall::EINVAL;\n use time;\n use vec::{IntoIter, Vec};\n "}, {"sha": "9ebbae4199b78d9bf75e5fc672e343faa5a68d69", "filename": "src/libstd/sys/redox/os.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -19,7 +19,6 @@ use ffi::{OsString, OsStr};\n use fmt;\n use io::{self, Read, Write};\n use iter;\n-use libc::{self, c_int, c_char, c_void};\n use marker::PhantomData;\n use mem;\n use memchr;\n@@ -28,8 +27,7 @@ use ptr;\n use slice;\n use str;\n use sys_common::mutex::Mutex;\n-use sys::cvt;\n-use sys::fd;\n+use sys::{cvt, fd, syscall};\n use vec;\n \n const TMPBUF_SZ: usize = 128;\n@@ -42,7 +40,7 @@ pub fn errno() -> i32 {\n \n /// Gets a detailed string description for the given error number.\n pub fn error_string(errno: i32) -> String {\n-    if let Some(string) = libc::STR_ERROR.get(errno as usize) {\n+    if let Some(string) = syscall::STR_ERROR.get(errno as usize) {\n         string.to_string()\n     } else {\n         \"unknown error\".to_string()\n@@ -51,12 +49,12 @@ pub fn error_string(errno: i32) -> String {\n \n pub fn getcwd() -> io::Result<PathBuf> {\n     let mut buf = [0; 4096];\n-    let count = cvt(libc::getcwd(&mut buf))?;\n+    let count = cvt(syscall::getcwd(&mut buf))?;\n     Ok(PathBuf::from(OsString::from_vec(buf[.. count].to_vec())))\n }\n \n pub fn chdir(p: &path::Path) -> io::Result<()> {\n-    cvt(libc::chdir(p.to_str().unwrap())).and(Ok(()))\n+    cvt(syscall::chdir(p.to_str().unwrap())).and(Ok(()))\n }\n \n pub struct SplitPaths<'a> {\n@@ -200,6 +198,6 @@ pub fn home_dir() -> Option<PathBuf> {\n }\n \n pub fn exit(code: i32) -> ! {\n-    let _ = libc::exit(code as usize);\n+    let _ = syscall::exit(code as usize);\n     unreachable!();\n }"}, {"sha": "7f192bef495a960424f8e9e50140cd2118ce2bc7", "filename": "src/libstd/sys/redox/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use io;\n-use libc;\n+use sys::syscall;\n use sys::fd::FileDesc;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -21,7 +21,7 @@ pub struct AnonPipe(FileDesc);\n pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n     let mut fds = [0; 2];\n \n-    libc::pipe2(&mut fds, libc::O_CLOEXEC).map_err(|err| io::Error::from_raw_os_error(err.errno))?;\n+    syscall::pipe2(&mut fds, syscall::O_CLOEXEC).map_err(|err| io::Error::from_raw_os_error(err.errno))?;\n \n     Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))))\n }"}, {"sha": "3c0d96913285dbab8c1dff6803e5a89b7cb37451", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -13,12 +13,11 @@ use env;\n use ffi::OsStr;\n use fmt;\n use io::{self, Error, ErrorKind};\n-use libc::{self, pid_t, gid_t, uid_t};\n use path::Path;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n use sys::pipe::{self, AnonPipe};\n-use sys::cvt;\n+use sys::{cvt, syscall};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -47,8 +46,8 @@ pub struct Command {\n     env: HashMap<String, String>,\n \n     cwd: Option<String>,\n-    uid: Option<uid_t>,\n-    gid: Option<gid_t>,\n+    uid: Option<u32>,\n+    gid: Option<u32>,\n     saw_nul: bool,\n     closures: Vec<Box<FnMut() -> io::Result<()> + Send + Sync>>,\n     stdin: Option<Stdio>,\n@@ -121,10 +120,10 @@ impl Command {\n     pub fn cwd(&mut self, dir: &OsStr) {\n         self.cwd = Some(dir.to_str().unwrap().to_owned());\n     }\n-    pub fn uid(&mut self, id: uid_t) {\n+    pub fn uid(&mut self, id: u32) {\n         self.uid = Some(id);\n     }\n-    pub fn gid(&mut self, id: gid_t) {\n+    pub fn gid(&mut self, id: u32) {\n         self.gid = Some(id);\n     }\n \n@@ -156,11 +155,11 @@ impl Command {\n          let (input, output) = pipe::anon_pipe()?;\n \n          let pid = unsafe {\n-             match cvt(libc::clone(0))? {\n+             match cvt(syscall::clone(0))? {\n                  0 => {\n                      drop(input);\n                      let err = self.do_exec(theirs);\n-                     let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n+                     let errno = err.raw_os_error().unwrap_or(syscall::EINVAL) as u32;\n                      let bytes = [\n                          (errno >> 24) as u8,\n                          (errno >> 16) as u8,\n@@ -173,7 +172,7 @@ impl Command {\n                      // we want to be sure we *don't* run at_exit destructors as\n                      // we're being torn down regardless\n                      assert!(output.write(&bytes).is_ok());\n-                     let _ = libc::exit(1);\n+                     let _ = syscall::exit(1);\n                      panic!(\"failed to exit\");\n                  }\n                  n => n,\n@@ -261,7 +260,7 @@ impl Command {\n     // this file descriptor by dropping the FileDesc (which contains an\n     // allocation). Instead we just close it manually. This will never\n     // have the drop glue anyway because this code never returns (the\n-    // child will either exec() or invoke libc::exit)\n+    // child will either exec() or invoke syscall::exit)\n     unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n         macro_rules! t {\n             ($e:expr) => (match $e {\n@@ -271,29 +270,29 @@ impl Command {\n         }\n \n         if let Some(fd) = stdio.stderr.fd() {\n-            let _ = libc::close(libc::STDERR_FILENO);\n-            t!(cvt(libc::dup(fd, &[])));\n-            let _ = libc::close(fd);\n+            let _ = syscall::close(2);\n+            t!(cvt(syscall::dup(fd, &[])));\n+            let _ = syscall::close(fd);\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n-            let _ = libc::close(libc::STDOUT_FILENO);\n-            t!(cvt(libc::dup(fd, &[])));\n-            let _ = libc::close(fd);\n+            let _ = syscall::close(1);\n+            t!(cvt(syscall::dup(fd, &[])));\n+            let _ = syscall::close(fd);\n         }\n         if let Some(fd) = stdio.stdin.fd() {\n-            let _ = libc::close(libc::STDIN_FILENO);\n-            t!(cvt(libc::dup(fd, &[])));\n-            let _ = libc::close(fd);\n+            let _ = syscall::close(0);\n+            t!(cvt(syscall::dup(fd, &[])));\n+            let _ = syscall::close(fd);\n         }\n \n         if let Some(g) = self.gid {\n-            t!(cvt(libc::setregid(g, g)));\n+            t!(cvt(syscall::setregid(g as usize, g as usize)));\n         }\n         if let Some(u) = self.uid {\n-            t!(cvt(libc::setreuid(u, u)));\n+            t!(cvt(syscall::setreuid(u as usize, u as usize)));\n         }\n         if let Some(ref cwd) = self.cwd {\n-            t!(cvt(libc::chdir(cwd)));\n+            t!(cvt(syscall::chdir(cwd)));\n         }\n \n         for callback in self.closures.iter_mut() {\n@@ -324,7 +323,7 @@ impl Command {\n             path_env\n         };\n \n-        if let Err(err) = libc::exec(&program, &args) {\n+        if let Err(err) = syscall::execve(&program, &args) {\n             io::Error::from_raw_os_error(err.errno as i32)\n         } else {\n             panic!(\"return from exec without err\");\n@@ -370,7 +369,7 @@ impl Stdio {\n             // stderr. No matter which we dup first, the second will get\n             // overwritten prematurely.\n             Stdio::Fd(ref fd) => {\n-                if fd.raw() <= libc::STDERR_FILENO {\n+                if fd.raw() <= 2 {\n                     Ok((ChildStdio::Owned(fd.duplicate()?), None))\n                 } else {\n                     Ok((ChildStdio::Explicit(fd.raw()), None))\n@@ -471,7 +470,7 @@ impl fmt::Display for ExitStatus {\n \n /// The unique id of the process (this should never be negative).\n pub struct Process {\n-    pid: pid_t,\n+    pid: usize,\n     status: Option<ExitStatus>,\n }\n \n@@ -488,7 +487,7 @@ impl Process {\n             Err(Error::new(ErrorKind::InvalidInput,\n                            \"invalid argument: can't kill an exited process\"))\n         } else {\n-            cvt(libc::kill(self.pid, libc::SIGKILL))?;\n+            cvt(syscall::kill(self.pid, syscall::SIGKILL))?;\n             Ok(())\n         }\n     }\n@@ -498,7 +497,7 @@ impl Process {\n             return Ok(status)\n         }\n         let mut status = 0;\n-        cvt(libc::waitpid(self.pid, &mut status, 0))?;\n+        cvt(syscall::waitpid(self.pid, &mut status, 0))?;\n         self.status = Some(ExitStatus(status as i32));\n         Ok(ExitStatus(status as i32))\n     }"}, {"sha": "1fe7e33a35ecd7b667627b0d80f4ec0d8b368cac", "filename": "src/libstd/sys/redox/stdio.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use io;\n-use libc;\n-use sys::cvt;\n+use sys::{cvt, syscall};\n use sys::fd::FileDesc;\n \n pub struct Stdin(());\n@@ -21,14 +20,14 @@ impl Stdin {\n     pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n \n     pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n-        let fd = FileDesc::new(libc::STDIN_FILENO);\n+        let fd = FileDesc::new(0);\n         let ret = fd.read(data);\n         fd.into_raw();\n         ret\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        let fd = FileDesc::new(libc::STDIN_FILENO);\n+        let fd = FileDesc::new(0);\n         let ret = fd.read_to_end(buf);\n         fd.into_raw();\n         ret\n@@ -39,29 +38,29 @@ impl Stdout {\n     pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        let fd = FileDesc::new(libc::STDOUT_FILENO);\n+        let fd = FileDesc::new(1);\n         let ret = fd.write(data);\n         fd.into_raw();\n         ret\n     }\n \n     pub fn flush(&self) -> io::Result<()> {\n-        cvt(libc::fsync(libc::STDOUT_FILENO)).and(Ok(()))\n+        cvt(syscall::fsync(1)).and(Ok(()))\n     }\n }\n \n impl Stderr {\n     pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        let fd = FileDesc::new(libc::STDERR_FILENO);\n+        let fd = FileDesc::new(2);\n         let ret = fd.write(data);\n         fd.into_raw();\n         ret\n     }\n \n     pub fn flush(&self) -> io::Result<()> {\n-        cvt(libc::fsync(libc::STDERR_FILENO)).and(Ok(()))\n+        cvt(syscall::fsync(2)).and(Ok(()))\n     }\n }\n \n@@ -74,9 +73,9 @@ impl io::Write for Stderr {\n     }\n \n     fn flush(&mut self) -> io::Result<()> {\n-        cvt(libc::fsync(libc::STDERR_FILENO)).and(Ok(()))\n+        cvt(syscall::fsync(2)).and(Ok(()))\n     }\n }\n \n-pub const EBADF_ERR: i32 = ::libc::EBADF;\n+pub const EBADF_ERR: i32 = ::sys::syscall::EBADF;\n pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;"}, {"sha": "0e7b27d396107b97e5a2db33fdf8b9e764d23ee2", "filename": "src/libstd/sys/redox/thread.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -9,17 +9,15 @@\n // except according to those terms.\n \n use alloc::boxed::FnBox;\n-use cmp;\n use ffi::CStr;\n use io;\n-use libc;\n use mem;\n use sys_common::thread::start_thread;\n-use sys::cvt;\n+use sys::{cvt, syscall};\n use time::Duration;\n \n pub struct Thread {\n-    id: libc::pid_t,\n+    id: usize,\n }\n \n // Some platforms may have pthread_t as a pointer in which case we still want\n@@ -31,10 +29,10 @@ impl Thread {\n     pub unsafe fn new<'a>(_stack: usize, p: Box<FnBox() + 'a>) -> io::Result<Thread> {\n         let p = box p;\n \n-        let id = cvt(libc::clone(libc::CLONE_VM | libc::CLONE_FS | libc::CLONE_FILES))?;\n+        let id = cvt(syscall::clone(syscall::CLONE_VM | syscall::CLONE_FS | syscall::CLONE_FILES))?;\n         if id == 0 {\n             start_thread(&*p as *const _ as *mut _);\n-            let _ = libc::exit(0);\n+            let _ = syscall::exit(0);\n             panic!(\"thread failed to exit\");\n         } else {\n             mem::forget(p);\n@@ -43,7 +41,7 @@ impl Thread {\n     }\n \n     pub fn yield_now() {\n-        let ret = unsafe { libc::sched_yield() };\n+        let ret = syscall::sched_yield().expect(\"failed to sched_yield\");\n         debug_assert_eq!(ret, 0);\n     }\n \n@@ -58,13 +56,13 @@ impl Thread {\n         // If we're awoken with a signal then the return value will be -1 and\n         // nanosleep will fill in `ts` with the remaining time.\n         while secs > 0 || nsecs > 0 {\n-            let req = libc::timespec {\n-                tv_sec: cmp::min(libc::time_t::max_value() as u64, secs) as libc::time_t,\n+            let req = syscall::TimeSpec {\n+                tv_sec: secs as i64,\n                 tv_nsec: nsecs,\n             };\n             secs -= req.tv_sec as u64;\n-            let mut rem = libc::timespec::default();\n-            if libc::nanosleep(&req, &mut rem).is_err() {\n+            let mut rem = syscall::TimeSpec::default();\n+            if syscall::nanosleep(&req, &mut rem).is_err() {\n                 secs += rem.tv_sec as u64;\n                 nsecs = rem.tv_nsec;\n             } else {\n@@ -75,12 +73,12 @@ impl Thread {\n \n     pub fn join(self) {\n         let mut status = 0;\n-        libc::waitpid(self.id, &mut status, 0).unwrap();\n+        syscall::waitpid(self.id, &mut status, 0).unwrap();\n     }\n \n-    pub fn id(&self) -> libc::pid_t { self.id }\n+    pub fn id(&self) -> usize { self.id }\n \n-    pub fn into_id(self) -> libc::pid_t {\n+    pub fn into_id(self) -> usize {\n         let id = self.id;\n         mem::forget(self);\n         id"}, {"sha": "8f05e3bcfe716a45455319295509eccf36aef862", "filename": "src/libstd/sys/redox/time.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746222fd9d6c16d3dc3c44c797dcc868297c133b/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs?ref=746222fd9d6c16d3dc3c44c797dcc868297c133b", "patch": "@@ -10,15 +10,14 @@\n \n use cmp::Ordering;\n use fmt;\n-use libc;\n-use sys::cvt;\n+use sys::{cvt, syscall};\n use time::Duration;\n \n const NSEC_PER_SEC: u64 = 1_000_000_000;\n \n #[derive(Copy, Clone)]\n struct Timespec {\n-    t: libc::timespec,\n+    t: syscall::TimeSpec,\n }\n \n impl Timespec {\n@@ -53,8 +52,8 @@ impl Timespec {\n                                                duration to time\");\n         }\n         Timespec {\n-            t: libc::timespec {\n-                tv_sec: secs as libc::time_t,\n+            t: syscall::TimeSpec {\n+                tv_sec: secs as i64,\n                 tv_nsec: nsec as i32,\n             },\n         }\n@@ -73,8 +72,8 @@ impl Timespec {\n                                                duration from time\");\n         }\n         Timespec {\n-            t: libc::timespec {\n-                tv_sec: secs as libc::time_t,\n+            t: syscall::TimeSpec {\n+                tv_sec: secs as i64,\n                 tv_nsec: nsec as i32,\n             },\n         }\n@@ -115,7 +114,7 @@ pub struct SystemTime {\n \n pub const UNIX_EPOCH: SystemTime = SystemTime {\n     t: Timespec {\n-        t: libc::timespec {\n+        t: syscall::TimeSpec {\n             tv_sec: 0,\n             tv_nsec: 0,\n         },\n@@ -124,7 +123,7 @@ pub const UNIX_EPOCH: SystemTime = SystemTime {\n \n impl Instant {\n     pub fn now() -> Instant {\n-        Instant { t: now(libc::CLOCK_MONOTONIC) }\n+        Instant { t: now(syscall::CLOCK_MONOTONIC) }\n     }\n \n     pub fn sub_instant(&self, other: &Instant) -> Duration {\n@@ -153,7 +152,7 @@ impl fmt::Debug for Instant {\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n-        SystemTime { t: now(libc::CLOCK_REALTIME) }\n+        SystemTime { t: now(syscall::CLOCK_REALTIME) }\n     }\n \n     pub fn sub_time(&self, other: &SystemTime)\n@@ -170,8 +169,8 @@ impl SystemTime {\n     }\n }\n \n-impl From<libc::timespec> for SystemTime {\n-    fn from(t: libc::timespec) -> SystemTime {\n+impl From<syscall::TimeSpec> for SystemTime {\n+    fn from(t: syscall::TimeSpec) -> SystemTime {\n         SystemTime { t: Timespec { t: t } }\n     }\n }\n@@ -189,11 +188,11 @@ pub type clock_t = usize;\n \n fn now(clock: clock_t) -> Timespec {\n     let mut t = Timespec {\n-        t: libc::timespec {\n+        t: syscall::TimeSpec {\n             tv_sec: 0,\n             tv_nsec: 0,\n         }\n     };\n-    cvt(libc::clock_gettime(clock, &mut t.t)).unwrap();\n+    cvt(syscall::clock_gettime(clock, &mut t.t)).unwrap();\n     t\n }"}]}