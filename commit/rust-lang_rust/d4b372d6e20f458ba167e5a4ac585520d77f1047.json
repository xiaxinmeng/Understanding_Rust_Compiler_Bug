{"sha": "d4b372d6e20f458ba167e5a4ac585520d77f1047", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YjM3MmQ2ZTIwZjQ1OGJhMTY3ZTVhNGFjNTg1NTIwZDc3ZjEwNDc=", "commit": {"author": {"name": "Maik Klein", "email": "maikklein@googlemail.com", "date": "2017-12-01T18:57:45Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-18T15:08:49Z"}, "message": "Rename trans to monomorphize in comments", "tree": {"sha": "ac28443dae464dd468c717f7bd2f5affaaaf12f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac28443dae464dd468c717f7bd2f5affaaaf12f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4b372d6e20f458ba167e5a4ac585520d77f1047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4b372d6e20f458ba167e5a4ac585520d77f1047", "html_url": "https://github.com/rust-lang/rust/commit/d4b372d6e20f458ba167e5a4ac585520d77f1047", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4b372d6e20f458ba167e5a4ac585520d77f1047/comments", "author": {"login": "MaikKlein", "id": 1994306, "node_id": "MDQ6VXNlcjE5OTQzMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1994306?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MaikKlein", "html_url": "https://github.com/MaikKlein", "followers_url": "https://api.github.com/users/MaikKlein/followers", "following_url": "https://api.github.com/users/MaikKlein/following{/other_user}", "gists_url": "https://api.github.com/users/MaikKlein/gists{/gist_id}", "starred_url": "https://api.github.com/users/MaikKlein/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MaikKlein/subscriptions", "organizations_url": "https://api.github.com/users/MaikKlein/orgs", "repos_url": "https://api.github.com/users/MaikKlein/repos", "events_url": "https://api.github.com/users/MaikKlein/events{/privacy}", "received_events_url": "https://api.github.com/users/MaikKlein/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45f8a3b30c80b17ff78ac8d1aa14784a73ca593e", "url": "https://api.github.com/repos/rust-lang/rust/commits/45f8a3b30c80b17ff78ac8d1aa14784a73ca593e", "html_url": "https://github.com/rust-lang/rust/commit/45f8a3b30c80b17ff78ac8d1aa14784a73ca593e"}], "stats": {"total": 74, "additions": 37, "deletions": 37}, "files": [{"sha": "059d2c812748059fb2294cb98ad8da93cae4cbcb", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d4b372d6e20f458ba167e5a4ac585520d77f1047/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b372d6e20f458ba167e5a4ac585520d77f1047/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=d4b372d6e20f458ba167e5a4ac585520d77f1047", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Translation Item Collection\n+//! Mono Item Collection\n //! ===========================\n //!\n //! This module is responsible for discovering all items that will contribute to\n@@ -22,7 +22,7 @@\n //! in crate X might produce monomorphizations that are compiled into crate Y.\n //! We also have to collect these here.\n //!\n-//! The following kinds of \"translation items\" are handled here:\n+//! The following kinds of \"mono items\" are handled here:\n //!\n //! - Functions\n //! - Methods\n@@ -43,24 +43,24 @@\n //! -----------------\n //! Let's define some terms first:\n //!\n-//! - A \"translation item\" is something that results in a function or global in\n-//!   the LLVM IR of a codegen unit. Translation items do not stand on their\n-//!   own, they can reference other translation items. For example, if function\n-//!   `foo()` calls function `bar()` then the translation item for `foo()`\n-//!   references the translation item for function `bar()`. In general, the\n-//!   definition for translation item A referencing a translation item B is that\n+//! - A \"mono item\" is something that results in a function or global in\n+//!   the LLVM IR of a codegen unit. Mono items do not stand on their\n+//!   own, they can reference other mono items. For example, if function\n+//!   `foo()` calls function `bar()` then the mono item for `foo()`\n+//!   references the mono item for function `bar()`. In general, the\n+//!   definition for mono item A referencing a mono item B is that\n //!   the LLVM artifact produced for A references the LLVM artifact produced\n //!   for B.\n //!\n-//! - Translation items and the references between them form a directed graph,\n-//!   where the translation items are the nodes and references form the edges.\n-//!   Let's call this graph the \"translation item graph\".\n+//! - Mono items and the references between them form a directed graph,\n+//!   where the mono items are the nodes and references form the edges.\n+//!   Let's call this graph the \"mono item graph\".\n //!\n-//! - The translation item graph for a program contains all translation items\n+//! - The mono item graph for a program contains all mono items\n //!   that are needed in order to produce the complete LLVM IR of the program.\n //!\n //! The purpose of the algorithm implemented in this module is to build the\n-//! translation item graph for the current crate. It runs in two phases:\n+//! mono item graph for the current crate. It runs in two phases:\n //!\n //! 1. Discover the roots of the graph by traversing the HIR of the crate.\n //! 2. Starting from the roots, find neighboring nodes by inspecting the MIR\n@@ -69,26 +69,26 @@\n //!\n //! ### Discovering roots\n //!\n-//! The roots of the translation item graph correspond to the non-generic\n+//! The roots of the mono item graph correspond to the non-generic\n //! syntactic items in the source code. We find them by walking the HIR of the\n //! crate, and whenever we hit upon a function, method, or static item, we\n-//! create a translation item consisting of the items DefId and, since we only\n+//! create a mono item consisting of the items DefId and, since we only\n //! consider non-generic items, an empty type-substitution set.\n //!\n //! ### Finding neighbor nodes\n-//! Given a translation item node, we can discover neighbors by inspecting its\n+//! Given a mono item node, we can discover neighbors by inspecting its\n //! MIR. We walk the MIR and any time we hit upon something that signifies a\n-//! reference to another translation item, we have found a neighbor. Since the\n-//! translation item we are currently at is always monomorphic, we also know the\n+//! reference to another mono item, we have found a neighbor. Since the\n+//! mono item we are currently at is always monomorphic, we also know the\n //! concrete type arguments of its neighbors, and so all neighbors again will be\n //! monomorphic. The specific forms a reference to a neighboring node can take\n //! in MIR are quite diverse. Here is an overview:\n //!\n //! #### Calling Functions/Methods\n-//! The most obvious form of one translation item referencing another is a\n+//! The most obvious form of one mono item referencing another is a\n //! function or method call (represented by a CALL terminator in MIR). But\n //! calls are not the only thing that might introduce a reference between two\n-//! function translation items, and as we will see below, they are just a\n+//! function mono items, and as we will see below, they are just a\n //! specialized of the form described next, and consequently will don't get any\n //! special treatment in the algorithm.\n //!\n@@ -112,10 +112,10 @@\n //! }\n //! ```\n //! The MIR of none of these functions will contain an explicit call to\n-//! `print_val::<i32>`. Nonetheless, in order to translate this program, we need\n+//! `print_val::<i32>`. Nonetheless, in order to mono this program, we need\n //! an instance of this function. Thus, whenever we encounter a function or\n //! method in operand position, we treat it as a neighbor of the current\n-//! translation item. Calls are just a special case of that.\n+//! mono item. Calls are just a special case of that.\n //!\n //! #### Closures\n //! In a way, closures are a simple case. Since every closure object needs to be\n@@ -124,8 +124,8 @@\n //! true for closures inlined from other crates.\n //!\n //! #### Drop glue\n-//! Drop glue translation items are introduced by MIR drop-statements. The\n-//! generated translation item will again have drop-glue item neighbors if the\n+//! Drop glue mono items are introduced by MIR drop-statements. The\n+//! generated mono item will again have drop-glue item neighbors if the\n //! type to be dropped contains nested values that also need to be dropped. It\n //! might also have a function item neighbor for the explicit `Drop::drop`\n //! implementation of its type.\n@@ -150,23 +150,23 @@\n //! defined in the source code of that crate. It will also contain monomorphic\n //! instantiations of any extern generic functions and of functions marked with\n //! #[inline].\n-//! The collection algorithm handles this more or less transparently. If it is\n-//! about to create a translation item for something with an external `DefId`,\n+//! The collection algorithm handles this more or less mono. If it is\n+//! about to create a mono item for something with an external `DefId`,\n //! it will take a look if the MIR for that item is available, and if so just\n //! proceed normally. If the MIR is not available, it assumes that the item is\n //! just linked to and no node is created; which is exactly what we want, since\n //! no machine code should be generated in the current crate for such an item.\n //!\n //! Eager and Lazy Collection Mode\n //! ------------------------------\n-//! Translation item collection can be performed in one of two modes:\n+//! Mono item collection can be performed in one of two modes:\n //!\n //! - Lazy mode means that items will only be instantiated when actually\n //!   referenced. The goal is to produce the least amount of machine code\n //!   possible.\n //!\n //! - Eager mode is meant to be used in conjunction with incremental compilation\n-//!   where a stable set of translation items is more important than a minimal\n+//!   where a stable set of mono items is more important than a minimal\n //!   one. Thus, eager mode will instantiate drop-glue for every drop-able type\n //!   in the crate, even of no drop call for that type exists (yet). It will\n //!   also instantiate default implementations of trait methods, something that\n@@ -183,9 +183,9 @@\n //! statics we cannot inspect these properly.\n //!\n //! ### Const Fns\n-//! Ideally, no translation item should be generated for const fns unless there\n+//! Ideally, no mono item should be generated for const fns unless there\n //! is a call to them that cannot be evaluated at compile time. At the moment\n-//! this is not implemented however: a translation item will be produced\n+//! this is not implemented however: a mono item will be produced\n //! regardless of whether it is actually needed or not.\n \n use rustc::hir;\n@@ -218,18 +218,18 @@ pub enum MonoItemCollectionMode {\n     Lazy\n }\n \n-/// Maps every translation item to all translation items it references in its\n+/// Maps every mono item to all mono items it references in its\n /// body.\n pub struct InliningMap<'tcx> {\n-    // Maps a source translation item to the range of translation items\n+    // Maps a source mono item to the range of mono items\n     // accessed by it.\n     // The two numbers in the tuple are the start (inclusive) and\n     // end index (exclusive) within the `targets` vecs.\n     index: FxHashMap<MonoItem<'tcx>, (usize, usize)>,\n     targets: Vec<MonoItem<'tcx>>,\n \n-    // Contains one bit per translation item in the `targets` field. That bit\n-    // is true if that translation item needs to be inlined into every CGU.\n+    // Contains one bit per mono item in the `targets` field. That bit\n+    // is true if that mono item needs to be inlined into every CGU.\n     inlines: BitVector,\n }\n \n@@ -300,7 +300,7 @@ pub fn collect_crate_mono_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                      InliningMap<'tcx>) {\n     let roots = collect_roots(tcx, mode);\n \n-    debug!(\"Building translation item graph, beginning at roots\");\n+    debug!(\"Building mono item graph, beginning at roots\");\n     let mut visited = FxHashSet();\n     let mut recursion_depths = DefIdMap();\n     let mut inlining_map = InliningMap::new();\n@@ -347,7 +347,7 @@ fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     roots\n }\n \n-// Collect all monomorphized translation items reachable from `starting_point`\n+// Collect all monomorphized items reachable from `starting_point`\n fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    starting_point: MonoItem<'tcx>,\n                                    visited: &mut FxHashSet<MonoItem<'tcx>>,\n@@ -930,7 +930,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 self.output.push(MonoItem::Static(item.id));\n             }\n             hir::ItemConst(..) => {\n-                // const items only generate translation items if they are\n+                // const items only generate mono items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n             }\n             hir::ItemFn(..) => {"}]}