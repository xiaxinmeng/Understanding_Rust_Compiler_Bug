{"sha": "da7ada584a3e5c3467b8b9f344b4a0f2a81ce32a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhN2FkYTU4NGEzZTVjMzQ2N2I4YjlmMzQ0YjRhMGYyYTgxY2UzMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-12T15:29:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-12T15:29:51Z"}, "message": "Auto merge of #82703 - iago-lito:nonzero_add_mul_pow, r=m-ou-se\n\nImplement nonzero arithmetics for NonZero types.\n\nHello'all, this is my first PR to this repo.\n\nNon-zero natural numbers are stable by addition/multiplication/exponentiation, so it makes sense to make this arithmetic possible with `NonZeroU*`.\n\nThe major pitfall is that overflowing underlying `u*` types possibly lead to underlying `0` values, which break the major invariant of `NonZeroU*`. To accommodate it, only `checked_` and `saturating_` operations are implemented.\n\nOther variants allowing wrapped results like `wrapping_` or `overflowing_` are ruled out *de facto*.\n\n`impl Add<u*> for NonZeroU* { .. }` was considered, as it panics on overflow which enforces the invariant, but it does not so in release mode. I considered forcing `NonZeroU*::add` to panic in release mode by deferring the check to `u*::checked_add`, but this is less explicit for the user than directly using `NonZeroU*::checked_add`.\nFollowing `@Lokathor's` advice on zulip, I have dropped the idea.\n\n`@poliorcetics` on Discord also suggested implementing `_sub` operations, but I'd postpone this to another PR if there is a need for it. My opinion is that it could be useful in some cases, but that it makes less sense because non-null natural numbers are not stable by subtraction even in theory, while the overflowing problem is just about technical implementation.\n\nOne thing I don't like is that the type of the `other` arg differs in every implementation: `_add` methods accept any raw positive integer, `_mul` methods only accept non-zero values otherwise the invariant is also broken, and `_pow` only seems to accept `u32` for a reason I ignore but that seems consistent throughout `std`. Maybe there is a better way to harmonize this?\n\nThis is it, Iope I haven't forgotten anything and I'll be happy to read your feedback.", "tree": {"sha": "8e9b3f19ff8035cea636ed540d5b48306c3c3f91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e9b3f19ff8035cea636ed540d5b48306c3c3f91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da7ada584a3e5c3467b8b9f344b4a0f2a81ce32a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da7ada584a3e5c3467b8b9f344b4a0f2a81ce32a", "html_url": "https://github.com/rust-lang/rust/commit/da7ada584a3e5c3467b8b9f344b4a0f2a81ce32a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da7ada584a3e5c3467b8b9f344b4a0f2a81ce32a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60f1a2fc4b535ead9c85ce085fdce49b1b097531", "url": "https://api.github.com/repos/rust-lang/rust/commits/60f1a2fc4b535ead9c85ce085fdce49b1b097531", "html_url": "https://github.com/rust-lang/rust/commit/60f1a2fc4b535ead9c85ce085fdce49b1b097531"}, {"sha": "7afdaf2c06c624e08c7533bf4c1e291df823aaba", "url": "https://api.github.com/repos/rust-lang/rust/commits/7afdaf2c06c624e08c7533bf4c1e291df823aaba", "html_url": "https://github.com/rust-lang/rust/commit/7afdaf2c06c624e08c7533bf4c1e291df823aaba"}], "stats": {"total": 573, "additions": 572, "deletions": 1}, "files": [{"sha": "dd9b9330aee2b5ed466c0e5e9f42323190eeedc2", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 572, "deletions": 1, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/da7ada584a3e5c3467b8b9f344b4a0f2a81ce32a/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7ada584a3e5c3467b8b9f344b4a0f2a81ce32a/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=da7ada584a3e5c3467b8b9f344b4a0f2a81ce32a", "patch": "@@ -42,7 +42,8 @@ macro_rules! nonzero_integers {\n             pub struct $Ty($Int);\n \n             impl $Ty {\n-                /// Creates a non-zero without checking the value.\n+                /// Creates a non-zero without checking whether the value is non-zero.\n+                /// This results in undefined behaviour if the value is zero.\n                 ///\n                 /// # Safety\n                 ///\n@@ -285,6 +286,576 @@ nonzero_integers_div! {\n     NonZeroUsize(usize);\n }\n \n+// A bunch of methods for unsigned nonzero types only.\n+macro_rules! nonzero_unsigned_operations {\n+    ( $( $Ty: ident($Int: ty); )+ ) => {\n+        $(\n+            impl $Ty {\n+                /// Add an unsigned integer to a non-zero value.\n+                /// Check for overflow and return [`None`] on overflow\n+                /// As a consequence, the result cannot wrap to zero.\n+                ///\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(Some(two), one.checked_add(1));\n+                /// assert_eq!(None, max.checked_add(1));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn checked_add(self, other: $Int) -> Option<$Ty> {\n+                    if let Some(result) = self.get().checked_add(other) {\n+                        // SAFETY: $Int::checked_add returns None on overflow\n+                        // so the result cannot be zero.\n+                        Some(unsafe { $Ty::new_unchecked(result) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Add an unsigned integer to a non-zero value.\n+                #[doc = concat!(\"Return [`\", stringify!($Int), \"::MAX`] on overflow.\")]\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(two, one.saturating_add(1));\n+                /// assert_eq!(max, max.saturating_add(1));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn saturating_add(self, other: $Int) -> $Ty {\n+                    // SAFETY: $Int::saturating_add returns $Int::MAX on overflow\n+                    // so the result cannot be zero.\n+                    unsafe { $Ty::new_unchecked(self.get().saturating_add(other)) }\n+                }\n+\n+                /// Add an unsigned integer to a non-zero value,\n+                /// assuming overflow cannot occur.\n+                /// Overflow is unchecked, and it is undefined behaviour to overflow\n+                /// *even if the result would wrap to a non-zero value*.\n+                /// The behaviour is undefined as soon as\n+                #[doc = concat!(\"`self + rhs > \", stringify!($Int), \"::MAX`.\")]\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                ///\n+                /// assert_eq!(two, unsafe { one.unchecked_add(1) });\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub unsafe fn unchecked_add(self, other: $Int) -> $Ty {\n+                    // SAFETY: The caller ensures there is no overflow.\n+                    unsafe { $Ty::new_unchecked(self.get().unchecked_add(other)) }\n+                }\n+\n+                /// Returns the smallest power of two greater than or equal to n.\n+                /// Check for overflow and return [`None`]\n+                /// if the next power of two is greater than the type\u2019s maximum value.\n+                /// As a consequence, the result cannot wrap to zero.\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let three = \", stringify!($Ty), \"::new(3)?;\")]\n+                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(Some(two), two.checked_next_power_of_two() );\n+                /// assert_eq!(Some(four), three.checked_next_power_of_two() );\n+                /// assert_eq!(None, max.checked_next_power_of_two() );\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn checked_next_power_of_two(self) -> Option<$Ty> {\n+                    if let Some(nz) = self.get().checked_next_power_of_two() {\n+                        // SAFETY: The next power of two is positive\n+                        // and overflow is checked.\n+                        Some(unsafe { $Ty::new_unchecked(nz) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_unsigned_operations! {\n+    NonZeroU8(u8);\n+    NonZeroU16(u16);\n+    NonZeroU32(u32);\n+    NonZeroU64(u64);\n+    NonZeroU128(u128);\n+    NonZeroUsize(usize);\n+}\n+\n+// A bunch of methods for signed nonzero types only.\n+macro_rules! nonzero_signed_operations {\n+    ( $( $Ty: ident($Int: ty) -> $Uty: ident($Uint: ty); )+ ) => {\n+        $(\n+            impl $Ty {\n+                /// Computes the absolute value of self.\n+                #[doc = concat!(\"See [`\", stringify!($Int), \"::abs`]\")]\n+                /// for documentation on overflow behaviour.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                ///\n+                /// assert_eq!(pos, pos.abs());\n+                /// assert_eq!(pos, neg.abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn abs(self) -> $Ty {\n+                    // SAFETY: This cannot overflow to zero.\n+                    unsafe { $Ty::new_unchecked(self.get().abs()) }\n+                }\n+\n+                /// Checked absolute value.\n+                /// Check for overflow and returns [`None`] if\n+                #[doc = concat!(\"`self == \", stringify!($Int), \"::MIN`.\")]\n+                /// The result cannot be zero.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                ///\n+                /// assert_eq!(Some(pos), neg.checked_abs());\n+                /// assert_eq!(None, min.checked_abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn checked_abs(self) -> Option<$Ty> {\n+                    if let Some(nz) = self.get().checked_abs() {\n+                        // SAFETY: absolute value of nonzero cannot yield zero values.\n+                        Some(unsafe { $Ty::new_unchecked(nz) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Computes the absolute value of self,\n+                /// with overflow information, see\n+                #[doc = concat!(\"[`\", stringify!($Int), \"::overflowing_abs`].\")]\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                ///\n+                /// assert_eq!((pos, false), pos.overflowing_abs());\n+                /// assert_eq!((pos, false), neg.overflowing_abs());\n+                /// assert_eq!((min, true), min.overflowing_abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn overflowing_abs(self) -> ($Ty, bool) {\n+                    let (nz, flag) = self.get().overflowing_abs();\n+                    (\n+                        // SAFETY: absolute value of nonzero cannot yield zero values.\n+                        unsafe { $Ty::new_unchecked(nz) },\n+                        flag,\n+                    )\n+                }\n+\n+                /// Saturating absolute value, see\n+                #[doc = concat!(\"[`\", stringify!($Int), \"::saturating_abs`].\")]\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                #[doc = concat!(\"let min_plus = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN + 1)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(pos, pos.saturating_abs());\n+                /// assert_eq!(pos, neg.saturating_abs());\n+                /// assert_eq!(max, min.saturating_abs());\n+                /// assert_eq!(max, min_plus.saturating_abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn saturating_abs(self) -> $Ty {\n+                    // SAFETY: absolute value of nonzero cannot yield zero values.\n+                    unsafe { $Ty::new_unchecked(self.get().saturating_abs()) }\n+                }\n+\n+                /// Wrapping absolute value, see\n+                #[doc = concat!(\"[`\", stringify!($Int), \"::wrapping_abs`].\")]\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(pos, pos.wrapping_abs());\n+                /// assert_eq!(pos, neg.wrapping_abs());\n+                /// assert_eq!(min, min.wrapping_abs());\n+                /// # // FIXME: add once Neg is implemented?\n+                /// # // assert_eq!(max, (-max).wrapping_abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn wrapping_abs(self) -> $Ty {\n+                    // SAFETY: absolute value of nonzero cannot yield zero values.\n+                    unsafe { $Ty::new_unchecked(self.get().wrapping_abs()) }\n+                }\n+\n+                /// Computes the absolute value of self\n+                /// without any wrapping or panicking.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Uty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let u_pos = \", stringify!($Uty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let i_pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let i_neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                #[doc = concat!(\"let i_min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                #[doc = concat!(\"let u_max = \", stringify!($Uty), \"::new(\",\n+                                stringify!($Uint), \"::MAX / 2 + 1)?;\")]\n+                ///\n+                /// assert_eq!(u_pos, i_pos.unsigned_abs());\n+                /// assert_eq!(u_pos, i_neg.unsigned_abs());\n+                /// assert_eq!(u_max, i_min.unsigned_abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn unsigned_abs(self) -> $Uty {\n+                    // SAFETY: absolute value of nonzero cannot yield zero values.\n+                    unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_signed_operations! {\n+    NonZeroI8(i8) -> NonZeroU8(u8);\n+    NonZeroI16(i16) -> NonZeroU16(u16);\n+    NonZeroI32(i32) -> NonZeroU32(u32);\n+    NonZeroI64(i64) -> NonZeroU64(u64);\n+    NonZeroI128(i128) -> NonZeroU128(u128);\n+    NonZeroIsize(isize) -> NonZeroUsize(usize);\n+}\n+\n+// A bunch of methods for both signed and unsigned nonzero types.\n+macro_rules! nonzero_unsigned_signed_operations {\n+    ( $( $signedness:ident $Ty: ident($Int: ty); )+ ) => {\n+        $(\n+            impl $Ty {\n+                /// Multiply two non-zero integers together.\n+                /// Check for overflow and return [`None`] on overflow.\n+                /// As a consequence, the result cannot wrap to zero.\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(Some(four), two.checked_mul(two));\n+                /// assert_eq!(None, max.checked_mul(two));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {\n+                    if let Some(result) = self.get().checked_mul(other.get()) {\n+                        // SAFETY: checked_mul returns None on overflow\n+                        // and `other` is also non-null\n+                        // so the result cannot be zero.\n+                        Some(unsafe { $Ty::new_unchecked(result) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Multiply two non-zero integers together.\n+                #[doc = concat!(\"Return [`\", stringify!($Int), \"::MAX`] on overflow.\")]\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(four, two.saturating_mul(two));\n+                /// assert_eq!(max, four.saturating_mul(max));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn saturating_mul(self, other: $Ty) -> $Ty {\n+                    // SAFETY: saturating_mul returns u*::MAX on overflow\n+                    // and `other` is also non-null\n+                    // so the result cannot be zero.\n+                    unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }\n+                }\n+\n+                /// Multiply two non-zero integers together,\n+                /// assuming overflow cannot occur.\n+                /// Overflow is unchecked, and it is undefined behaviour to overflow\n+                /// *even if the result would wrap to a non-zero value*.\n+                /// The behaviour is undefined as soon as\n+                #[doc = sign_dependent_expr!{\n+                    $signedness ?\n+                    if signed {\n+                        concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`, \",\n+                                \"or `self * rhs < \", stringify!($Int), \"::MIN`.\")\n+                    }\n+                    if unsigned {\n+                        concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`.\")\n+                    }\n+                }]\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n+                ///\n+                /// assert_eq!(four, unsafe { two.unchecked_mul(two) });\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {\n+                    // SAFETY: The caller ensures there is no overflow.\n+                    unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }\n+                }\n+\n+                /// Raise non-zero value to an integer power.\n+                /// Check for overflow and return [`None`] on overflow.\n+                /// As a consequence, the result cannot wrap to zero.\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let three = \", stringify!($Ty), \"::new(3)?;\")]\n+                #[doc = concat!(\"let twenty_seven = \", stringify!($Ty), \"::new(27)?;\")]\n+                #[doc = concat!(\"let half_max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX / 2)?;\")]\n+                ///\n+                /// assert_eq!(Some(twenty_seven), three.checked_pow(3));\n+                /// assert_eq!(None, half_max.checked_pow(3));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn checked_pow(self, other: u32) -> Option<$Ty> {\n+                    if let Some(result) = self.get().checked_pow(other) {\n+                        // SAFETY: checked_pow returns None on overflow\n+                        // so the result cannot be zero.\n+                        Some(unsafe { $Ty::new_unchecked(result) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Raise non-zero value to an integer power.\n+                #[doc = sign_dependent_expr!{\n+                    $signedness ?\n+                    if signed {\n+                        concat!(\"Return [`\", stringify!($Int), \"::MIN`] \",\n+                                    \"or [`\", stringify!($Int), \"::MAX`] on overflow.\")\n+                    }\n+                    if unsigned {\n+                        concat!(\"Return [`\", stringify!($Int), \"::MAX`] on overflow.\")\n+                    }\n+                }]\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let three = \", stringify!($Ty), \"::new(3)?;\")]\n+                #[doc = concat!(\"let twenty_seven = \", stringify!($Ty), \"::new(27)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(twenty_seven, three.saturating_pow(3));\n+                /// assert_eq!(max, max.saturating_pow(3));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn saturating_pow(self, other: u32) -> $Ty {\n+                    // SAFETY: saturating_pow returns u*::MAX on overflow\n+                    // so the result cannot be zero.\n+                    unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+// Use this when the generated code should differ between signed and unsigned types.\n+macro_rules! sign_dependent_expr {\n+    (signed ? if signed { $signed_case:expr } if unsigned { $unsigned_case:expr } ) => {\n+        $signed_case\n+    };\n+    (unsigned ? if signed { $signed_case:expr } if unsigned { $unsigned_case:expr } ) => {\n+        $unsigned_case\n+    };\n+}\n+\n+nonzero_unsigned_signed_operations! {\n+    unsigned NonZeroU8(u8);\n+    unsigned NonZeroU16(u16);\n+    unsigned NonZeroU32(u32);\n+    unsigned NonZeroU64(u64);\n+    unsigned NonZeroU128(u128);\n+    unsigned NonZeroUsize(usize);\n+    signed NonZeroI8(i8);\n+    signed NonZeroI16(i16);\n+    signed NonZeroI32(i32);\n+    signed NonZeroI64(i64);\n+    signed NonZeroI128(i128);\n+    signed NonZeroIsize(isize);\n+}\n+\n macro_rules! nonzero_unsigned_is_power_of_two {\n     ( $( $Ty: ident )+ ) => {\n         $("}]}