{"sha": "d9d4d39612aae0b8398340bd83d592cafad8e4ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZDRkMzk2MTJhYWUwYjgzOTgzNDBiZDgzZDU5MmNhZmFkOGU0ZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-20T23:05:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-20T23:05:31Z"}, "message": "Auto merge of #73565 - matthewjasper:core-min-spec, r=nagisa\n\nUse min_specialization in libcore\n\nGetting `TrustedRandomAccess` to work is the main interesting thing here.\n\n- `get_unchecked` is now an unstable, hidden method on `Iterator`\n- The contract for `TrustedRandomAccess` is made clearer in documentation\n- Fixed a bug where `Debug` would create aliasing references when using the specialized zip impl\n- Added tests for the side effects of `next_back` and `nth`.\n\ncloses #68536", "tree": {"sha": "ba461f2cd99e0f09f35192da7848cbc8e2a3950c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba461f2cd99e0f09f35192da7848cbc8e2a3950c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9d4d39612aae0b8398340bd83d592cafad8e4ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9d4d39612aae0b8398340bd83d592cafad8e4ec", "html_url": "https://github.com/rust-lang/rust/commit/d9d4d39612aae0b8398340bd83d592cafad8e4ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9d4d39612aae0b8398340bd83d592cafad8e4ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e15510ca33ea15c893b78710101c962b11459963", "url": "https://api.github.com/repos/rust-lang/rust/commits/e15510ca33ea15c893b78710101c962b11459963", "html_url": "https://github.com/rust-lang/rust/commit/e15510ca33ea15c893b78710101c962b11459963"}, {"sha": "dbad8c93680710e80c54cbaf8416821f7a5750c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbad8c93680710e80c54cbaf8416821f7a5750c8", "html_url": "https://github.com/rust-lang/rust/commit/dbad8c93680710e80c54cbaf8416821f7a5750c8"}], "stats": {"total": 687, "additions": 487, "deletions": 200}, "files": [{"sha": "94ba6f56476ae416dc3613c4697cbe5d8c0e0ed9", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=d9d4d39612aae0b8398340bd83d592cafad8e4ec", "patch": "@@ -1,7 +1,7 @@\n use crate::intrinsics;\n-use crate::iter::{\n-    DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedRandomAccess,\n-};\n+use crate::iter::adapters::zip::try_get_unchecked;\n+use crate::iter::TrustedRandomAccess;\n+use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator};\n use crate::ops::Try;\n \n /// An iterator that yields `None` forever after the underlying iterator\n@@ -114,6 +114,19 @@ where\n     {\n         FuseImpl::find(self, predicate)\n     }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        match self.iter {\n+            // SAFETY: the caller must uphold the contract for `Iterator::get_unchecked`.\n+            Some(ref mut iter) => unsafe { try_get_unchecked(iter, idx) },\n+            // SAFETY: the caller asserts there is an item at `i`, so we're not exhausted.\n+            None => unsafe { intrinsics::unreachable() },\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -172,19 +185,12 @@ where\n     }\n }\n \n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<I> TrustedRandomAccess for Fuse<I>\n where\n     I: TrustedRandomAccess,\n {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n-        match self.iter {\n-            // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n-            Some(ref mut iter) => unsafe { iter.get_unchecked(i) },\n-            // SAFETY: the caller asserts there is an item at `i`, so we're not exhausted.\n-            None => unsafe { intrinsics::unreachable() },\n-        }\n-    }\n-\n     fn may_have_side_effect() -> bool {\n         I::may_have_side_effect()\n     }"}, {"sha": "9fcd137e1a634716c7407226abaf35588ce9129c", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 48, "deletions": 45, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=d9d4d39612aae0b8398340bd83d592cafad8e4ec", "patch": "@@ -15,6 +15,7 @@ pub use self::chain::Chain;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::flatten::{FlatMap, Flatten};\n pub use self::fuse::Fuse;\n+use self::zip::try_get_unchecked;\n pub(crate) use self::zip::TrustedRandomAccess;\n pub use self::zip::Zip;\n \n@@ -213,6 +214,15 @@ where\n     fn count(self) -> usize {\n         self.it.count()\n     }\n+\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> T\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::get_unchecked`.\n+        *unsafe { try_get_unchecked(&mut self.it, idx) }\n+    }\n }\n \n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n@@ -266,16 +276,11 @@ where\n }\n \n #[doc(hidden)]\n-unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Copied<I>\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I> TrustedRandomAccess for Copied<I>\n where\n-    I: TrustedRandomAccess<Item = &'a T>,\n-    T: Copy,\n+    I: TrustedRandomAccess,\n {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n-        unsafe { *self.it.get_unchecked(i) }\n-    }\n-\n     #[inline]\n     fn may_have_side_effect() -> bool {\n         I::may_have_side_effect()\n@@ -344,6 +349,15 @@ where\n     {\n         self.it.map(T::clone).fold(init, f)\n     }\n+\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> T\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::get_unchecked`.\n+        unsafe { try_get_unchecked(&mut self.it, idx).clone() }\n+    }\n }\n \n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n@@ -397,36 +411,14 @@ where\n }\n \n #[doc(hidden)]\n-unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I> TrustedRandomAccess for Cloned<I>\n where\n-    I: TrustedRandomAccess<Item = &'a T>,\n-    T: Clone,\n-{\n-    default unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n-        unsafe { self.it.get_unchecked(i) }.clone()\n-    }\n-\n-    #[inline]\n-    default fn may_have_side_effect() -> bool {\n-        true\n-    }\n-}\n-\n-#[doc(hidden)]\n-unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n-where\n-    I: TrustedRandomAccess<Item = &'a T>,\n-    T: Copy,\n+    I: TrustedRandomAccess,\n {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n-        unsafe { *self.it.get_unchecked(i) }\n-    }\n-\n     #[inline]\n     fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n+        true\n     }\n }\n \n@@ -872,6 +864,15 @@ where\n     {\n         self.iter.fold(init, map_fold(self.f, g))\n     }\n+\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> B\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::get_unchecked`.\n+        unsafe { (self.f)(try_get_unchecked(&mut self.iter, idx)) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -927,15 +928,11 @@ where\n }\n \n #[doc(hidden)]\n-unsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I, F> TrustedRandomAccess for Map<I, F>\n where\n     I: TrustedRandomAccess,\n-    F: FnMut(I::Item) -> B,\n {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n-        (self.f)(unsafe { self.iter.get_unchecked(i) })\n-    }\n     #[inline]\n     fn may_have_side_effect() -> bool {\n         true\n@@ -1306,6 +1303,16 @@ where\n \n         self.iter.fold(init, enumerate(self.count, fold))\n     }\n+\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::get_unchecked`.\n+        let value = unsafe { try_get_unchecked(&mut self.iter, idx) };\n+        (Add::add(self.count, idx), value)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1391,15 +1398,11 @@ where\n }\n \n #[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n where\n     I: TrustedRandomAccess,\n {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n-        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n-        (self.count + i, unsafe { self.iter.get_unchecked(i) })\n-    }\n-\n     fn may_have_side_effect() -> bool {\n         I::may_have_side_effect()\n     }"}, {"sha": "6cb618964830e17aa1d9b2548e61707ebe05d7ff", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 151, "deletions": 30, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=d9d4d39612aae0b8398340bd83d592cafad8e4ec", "patch": "@@ -1,4 +1,5 @@\n use crate::cmp;\n+use crate::fmt::{self, Debug};\n \n use super::super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedLen};\n \n@@ -9,7 +10,7 @@ use super::super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterat\n ///\n /// [`zip`]: trait.Iterator.html#method.zip\n /// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Zip<A, B> {\n@@ -56,6 +57,16 @@ where\n     fn nth(&mut self, n: usize) -> Option<Self::Item> {\n         ZipImpl::nth(self, n)\n     }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: `ZipImpl::get_unchecked` has same safety requirements as\n+        // `Iterator::get_unchecked`.\n+        unsafe { ZipImpl::get_unchecked(self, idx) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -82,6 +93,10 @@ trait ZipImpl<A, B> {\n     where\n         A: DoubleEndedIterator + ExactSizeIterator,\n         B: DoubleEndedIterator + ExactSizeIterator;\n+    // This has the same safety requirements as `Iterator::get_unchecked`\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n+    where\n+        Self: Iterator + TrustedRandomAccess;\n }\n \n // General Zip impl\n@@ -156,16 +171,23 @@ where\n \n         (lower, upper)\n     }\n+\n+    default unsafe fn get_unchecked(&mut self, _idx: usize) -> <Self as Iterator>::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        unreachable!(\"Always specialized\");\n+    }\n }\n \n #[doc(hidden)]\n impl<A, B> ZipImpl<A, B> for Zip<A, B>\n where\n-    A: TrustedRandomAccess,\n-    B: TrustedRandomAccess,\n+    A: TrustedRandomAccess + Iterator,\n+    B: TrustedRandomAccess + Iterator,\n {\n     fn new(a: A, b: B) -> Self {\n-        let len = cmp::min(a.len(), b.len());\n+        let len = cmp::min(a.size(), b.size());\n         Zip { a, b, index: 0, len }\n     }\n \n@@ -176,7 +198,7 @@ where\n             self.index += 1;\n             // SAFETY: `i` is smaller than `self.len`, thus smaller than `self.a.len()` and `self.b.len()`\n             unsafe { Some((self.a.get_unchecked(i), self.b.get_unchecked(i))) }\n-        } else if A::may_have_side_effect() && self.index < self.a.len() {\n+        } else if A::may_have_side_effect() && self.index < self.a.size() {\n             // match the base implementation's potential side effects\n             // SAFETY: we just checked that `self.index` < `self.a.len()`\n             unsafe {\n@@ -227,20 +249,26 @@ where\n         A: DoubleEndedIterator + ExactSizeIterator,\n         B: DoubleEndedIterator + ExactSizeIterator,\n     {\n-        // Adjust a, b to equal length\n-        if A::may_have_side_effect() {\n-            let sz = self.a.len();\n-            if sz > self.len {\n-                for _ in 0..sz - cmp::max(self.len, self.index) {\n-                    self.a.next_back();\n+        let a_side_effect = A::may_have_side_effect();\n+        let b_side_effect = B::may_have_side_effect();\n+        if a_side_effect || b_side_effect {\n+            let sz_a = self.a.size();\n+            let sz_b = self.b.size();\n+            // Adjust a, b to equal length, make sure that only the first call\n+            // of `next_back` does this, otherwise we will break the restriction\n+            // on calls to `self.next_back()` after calling `get_unchecked()`.\n+            if sz_a != sz_b {\n+                let sz_a = self.a.size();\n+                if a_side_effect && sz_a > self.len {\n+                    for _ in 0..sz_a - cmp::max(self.len, self.index) {\n+                        self.a.next_back();\n+                    }\n                 }\n-            }\n-        }\n-        if B::may_have_side_effect() {\n-            let sz = self.b.len();\n-            if sz > self.len {\n-                for _ in 0..sz - self.len {\n-                    self.b.next_back();\n+                let sz_b = self.b.size();\n+                if b_side_effect && sz_b > self.len {\n+                    for _ in 0..sz_b - self.len {\n+                        self.b.next_back();\n+                    }\n                 }\n             }\n         }\n@@ -254,6 +282,13 @@ where\n             None\n         }\n     }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::get_unchecked`.\n+        unsafe { (self.a.get_unchecked(idx), self.b.get_unchecked(idx)) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -265,16 +300,12 @@ where\n }\n \n #[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n where\n     A: TrustedRandomAccess,\n     B: TrustedRandomAccess,\n {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n-        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n-        unsafe { (self.a.get_unchecked(i), self.b.get_unchecked(i)) }\n-    }\n-\n     fn may_have_side_effect() -> bool {\n         A::may_have_side_effect() || B::may_have_side_effect()\n     }\n@@ -296,19 +327,109 @@ where\n {\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Debug, B: Debug> Debug for Zip<A, B> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ZipFmt::fmt(self, f)\n+    }\n+}\n+\n+trait ZipFmt<A, B> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result;\n+}\n+\n+impl<A: Debug, B: Debug> ZipFmt<A, B> for Zip<A, B> {\n+    default fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Zip\").field(\"a\", &self.a).field(\"b\", &self.b).finish()\n+    }\n+}\n+\n+impl<A: Debug + TrustedRandomAccess, B: Debug + TrustedRandomAccess> ZipFmt<A, B> for Zip<A, B> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // It's *not safe* to call fmt on the contained iterators, since once\n+        // we start iterating they're in strange, potentially unsafe, states.\n+        f.debug_struct(\"Zip\").finish()\n+    }\n+}\n+\n /// An iterator whose items are random-accessible efficiently\n ///\n /// # Safety\n ///\n-/// The iterator's .len() and size_hint() must be exact.\n-/// `.len()` must be cheap to call.\n+/// The iterator's `size_hint` must be exact and cheap to call.\n+///\n+/// `size` may not be overridden.\n+///\n+/// `<Self as Iterator>::get_unchecked` must be safe to call provided the\n+/// following conditions are met.\n ///\n-/// .get_unchecked() must return distinct mutable references for distinct\n-/// indices (if applicable), and must return a valid reference if index is in\n-/// 0..self.len().\n-pub(crate) unsafe trait TrustedRandomAccess: ExactSizeIterator {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n+/// 1. `0 <= idx` and `idx < self.size()`.\n+/// 2. If `self: !Clone`, then `get_unchecked` is never called with the same\n+///    index on `self` more than once.\n+/// 3. After `self.get_unchecked(idx)` has been called then `next_back` will\n+///    only be called at most `self.size() - idx - 1` times.\n+/// 4. After `get_unchecked` is called, then only the following methods will be\n+///    called on `self`:\n+///     * `std::clone::Clone::clone`\n+///     * `std::iter::Iterator::size_hint()`\n+///     * `std::iter::Iterator::next_back()`\n+///     * `std::iter::Iterator::get_unchecked()`\n+///     * `std::iter::TrustedRandomAccess::size()`\n+///\n+/// Further, given that these conditions are met, it must guarantee that:\n+///\n+/// * It does not change the value returned from `size_hint`\n+/// * It must be safe to call the methods listed above on `self` after calling\n+///   `get_unchecked`, assuming that the required traits are implemented.\n+/// * It must also be safe to drop `self` after calling `get_unchecked`.\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+#[rustc_specialization_trait]\n+pub unsafe trait TrustedRandomAccess: Sized {\n+    // Convenience method.\n+    fn size(&self) -> usize\n+    where\n+        Self: Iterator,\n+    {\n+        self.size_hint().0\n+    }\n     /// Returns `true` if getting an iterator element may have\n     /// side effects. Remember to take inner iterators into account.\n     fn may_have_side_effect() -> bool;\n }\n+\n+/// Like `Iterator::get_unchecked`, but doesn't require the compiler to\n+/// know that `U: TrustedRandomAccess`.\n+///\n+/// ## Safety\n+///\n+/// Same requirements calling `get_unchecked` directly.\n+#[doc(hidden)]\n+pub(in crate::iter::adapters) unsafe fn try_get_unchecked<I>(it: &mut I, idx: usize) -> I::Item\n+where\n+    I: Iterator,\n+{\n+    // SAFETY: the caller must uphold the contract for\n+    // `Iterator::get_unchecked`.\n+    unsafe { it.try_get_unchecked(idx) }\n+}\n+\n+unsafe trait SpecTrustedRandomAccess: Iterator {\n+    /// If `Self: TrustedRandomAccess`, it must be safe to call a\n+    /// `Iterator::get_unchecked(self, index)`.\n+    unsafe fn try_get_unchecked(&mut self, index: usize) -> Self::Item;\n+}\n+\n+unsafe impl<I: Iterator> SpecTrustedRandomAccess for I {\n+    default unsafe fn try_get_unchecked(&mut self, _: usize) -> Self::Item {\n+        panic!(\"Should only be called on TrustedRandomAccess iterators\");\n+    }\n+}\n+\n+unsafe impl<I: Iterator + TrustedRandomAccess> SpecTrustedRandomAccess for I {\n+    unsafe fn try_get_unchecked(&mut self, index: usize) -> Self::Item {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::get_unchecked`.\n+        unsafe { self.get_unchecked(index) }\n+    }\n+}"}, {"sha": "32e43ed42f385d9c3bc7ae461246cceb464c0a8b", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=d9d4d39612aae0b8398340bd83d592cafad8e4ec", "patch": "@@ -6,6 +6,7 @@ use crate::cmp::{self, Ordering};\n use crate::ops::{Add, Try};\n \n use super::super::LoopState;\n+use super::super::TrustedRandomAccess;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n use super::super::{FromIterator, Product, Sum, Zip};\n@@ -3245,6 +3246,17 @@ pub trait Iterator {\n     {\n         self.map(f).is_sorted()\n     }\n+\n+    /// See [TrustedRandomAccess]\n+    #[inline]\n+    #[doc(hidden)]\n+    #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+    unsafe fn get_unchecked(&mut self, _idx: usize) -> Self::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        unreachable!(\"Always specialized\");\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "19cd05de2a7581efa1d1ce4d547e2b3a3dc3a753", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=d9d4d39612aae0b8398340bd83d592cafad8e4ec", "patch": "@@ -118,7 +118,7 @@\n #![feature(repr_simd, platform_intrinsics)]\n #![feature(rustc_attrs)]\n #![feature(simd_ffi)]\n-#![feature(specialization)]\n+#![feature(min_specialization)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "0d97ddb29af79af77699a2f4581e3e31f1daefeb", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 150, "deletions": 106, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=d9d4d39612aae0b8398340bd83d592cafad8e4ec", "patch": "@@ -3647,21 +3647,21 @@ macro_rules! iterator {\n         struct $name:ident -> $ptr:ty,\n         $elem:ty,\n         $raw_mut:tt,\n-        {$( $mut_:tt )*},\n+        {$( $mut_:tt )?},\n         {$($extra:tt)*}\n     ) => {\n         // Returns the first element and moves the start of the iterator forwards by 1.\n         // Greatly improves performance compared to an inlined function. The iterator\n         // must not be empty.\n         macro_rules! next_unchecked {\n-            ($self: ident) => {& $( $mut_ )* *$self.post_inc_start(1)}\n+            ($self: ident) => {& $( $mut_ )? *$self.post_inc_start(1)}\n         }\n \n         // Returns the last element and moves the end of the iterator backwards by 1.\n         // Greatly improves performance compared to an inlined function. The iterator\n         // must not be empty.\n         macro_rules! next_back_unchecked {\n-            ($self: ident) => {& $( $mut_ )* *$self.pre_dec_end(1)}\n+            ($self: ident) => {& $( $mut_ )? *$self.pre_dec_end(1)}\n         }\n \n         // Shrinks the iterator when T is a ZST, by moving the end of the iterator\n@@ -3921,6 +3921,21 @@ macro_rules! iterator {\n                 None\n             }\n \n+            #[doc(hidden)]\n+            unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+                // SAFETY: the caller must guarantee that `i` is in bounds of\n+                // the underlying slice, so `i` cannot overflow an `isize`, and\n+                // the returned references is guaranteed to refer to an element\n+                // of the slice and thus guaranteed to be valid.\n+                //\n+                // Also note that the caller also guarantees that we're never\n+                // called with the same index again, and that no other methods\n+                // that will access this subslice are called, so it is valid\n+                // for the returned reference to be mutable in the case of\n+                // `IterMut`\n+                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n+            }\n+\n             $($extra)*\n         }\n \n@@ -5005,6 +5020,15 @@ impl<'a, T> Iterator for Windows<'a, T> {\n             Some(&self.v[start..])\n         }\n     }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        // SAFETY: since the caller guarantees that `i` is in bounds,\n+        // which means that `i` cannot overflow an `isize`, and the\n+        // slice created by `from_raw_parts` is a subslice of `self.v`\n+        // thus is guaranteed to be valid for the lifetime `'a` of `self.v`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(idx), self.size) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -5044,14 +5068,8 @@ unsafe impl<T> TrustedLen for Windows<'_, T> {}\n impl<T> FusedIterator for Windows<'_, T> {}\n \n #[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<'a, T> TrustedRandomAccess for Windows<'a, T> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n-        // SAFETY: since the caller guarantees that `i` is in bounds,\n-        // which means that `i` cannot overflow an `isize`, and the\n-        // slice created by `from_raw_parts` is a subslice of `self.v`\n-        // thus is guaranteed to be valid for the lifetime `'a` of `self.v`.\n-        unsafe { from_raw_parts(self.v.as_ptr().add(i), self.size) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }\n@@ -5141,6 +5159,23 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n             Some(&self.v[start..])\n         }\n     }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let start = idx * self.chunk_size;\n+        let end = match start.checked_add(self.chunk_size) {\n+            None => self.v.len(),\n+            Some(end) => cmp::min(end, self.v.len()),\n+        };\n+        // SAFETY: the caller guarantees that `i` is in bounds,\n+        // which means that `start` must be in bounds of the\n+        // underlying `self.v` slice, and we made sure that `end`\n+        // is also in bounds of `self.v`. Thus, `start` cannot overflow\n+        // an `isize`, and the slice constructed by `from_raw_parts`\n+        // is a subslice of `self.v` which is guaranteed to be valid\n+        // for the lifetime `'a` of `self.v`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -5187,22 +5222,8 @@ unsafe impl<T> TrustedLen for Chunks<'_, T> {}\n impl<T> FusedIterator for Chunks<'_, T> {}\n \n #[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<'a, T> TrustedRandomAccess for Chunks<'a, T> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n-        let start = i * self.chunk_size;\n-        let end = match start.checked_add(self.chunk_size) {\n-            None => self.v.len(),\n-            Some(end) => cmp::min(end, self.v.len()),\n-        };\n-        // SAFETY: the caller guarantees that `i` is in bounds,\n-        // which means that `start` must be in bounds of the\n-        // underlying `self.v` slice, and we made sure that `end`\n-        // is also in bounds of `self.v`. Thus, `start` cannot overflow\n-        // an `isize`, and the slice constructed by `from_raw_parts`\n-        // is a subslice of `self.v` which is guaranteed to be valid\n-        // for the lifetime `'a` of `self.v`.\n-        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }\n@@ -5287,6 +5308,22 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n             Some(&mut self.v[start..])\n         }\n     }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let start = idx * self.chunk_size;\n+        let end = match start.checked_add(self.chunk_size) {\n+            None => self.v.len(),\n+            Some(end) => cmp::min(end, self.v.len()),\n+        };\n+        // SAFETY: see comments for `Chunks::get_unchecked`.\n+        //\n+        // Also note that the caller also guarantees that we're never called\n+        // with the same index again, and that no other methods that will\n+        // access this subslice are called, so it is valid for the returned\n+        // slice to be mutable.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -5336,16 +5373,8 @@ unsafe impl<T> TrustedLen for ChunksMut<'_, T> {}\n impl<T> FusedIterator for ChunksMut<'_, T> {}\n \n #[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n-        let start = i * self.chunk_size;\n-        let end = match start.checked_add(self.chunk_size) {\n-            None => self.v.len(),\n-            Some(end) => cmp::min(end, self.v.len()),\n-        };\n-        // SAFETY: see comments for `Chunks::get_unchecked`.\n-        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }\n@@ -5432,6 +5461,13 @@ impl<'a, T> Iterator for ChunksExact<'a, T> {\n     fn last(mut self) -> Option<Self::Item> {\n         self.next_back()\n     }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let start = idx * self.chunk_size;\n+        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n+    }\n }\n \n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n@@ -5477,13 +5513,8 @@ unsafe impl<T> TrustedLen for ChunksExact<'_, T> {}\n impl<T> FusedIterator for ChunksExact<'_, T> {}\n \n #[doc(hidden)]\n-#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n-        let start = i * self.chunk_size;\n-        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n-        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }\n@@ -5564,6 +5595,13 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n     fn last(mut self) -> Option<Self::Item> {\n         self.next_back()\n     }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let start = idx * self.chunk_size;\n+        // SAFETY: see comments for `ChunksMut::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n+    }\n }\n \n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n@@ -5612,13 +5650,8 @@ unsafe impl<T> TrustedLen for ChunksExactMut<'_, T> {}\n impl<T> FusedIterator for ChunksExactMut<'_, T> {}\n \n #[doc(hidden)]\n-#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n-        let start = i * self.chunk_size;\n-        // SAFETY: see comments for `ChunksExactMut::get_unchecked`.\n-        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }\n@@ -5689,6 +5722,12 @@ impl<'a, T, const N: usize> Iterator for ArrayChunks<'a, T, N> {\n     fn last(self) -> Option<Self::Item> {\n         self.iter.last()\n     }\n+\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T; N] {\n+        // SAFETY: The safety guarantees of `get_unchecked` are transferred to\n+        // the caller.\n+        unsafe { self.iter.get_unchecked(i) }\n+    }\n }\n \n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n@@ -5720,11 +5759,6 @@ impl<T, const N: usize> FusedIterator for ArrayChunks<'_, T, N> {}\n #[doc(hidden)]\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T; N] {\n-        // SAFETY: The safety guarantees of `get_unchecked` are transferred to\n-        // the caller.\n-        unsafe { self.iter.get_unchecked(i) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }\n@@ -5817,6 +5851,17 @@ impl<'a, T> Iterator for RChunks<'a, T> {\n             Some(&self.v[0..end])\n         }\n     }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let end = self.v.len() - idx * self.chunk_size;\n+        let start = match end.checked_sub(self.chunk_size) {\n+            None => 0,\n+            Some(start) => start,\n+        };\n+        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -5862,17 +5907,8 @@ unsafe impl<T> TrustedLen for RChunks<'_, T> {}\n impl<T> FusedIterator for RChunks<'_, T> {}\n \n #[doc(hidden)]\n-#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<'a, T> TrustedRandomAccess for RChunks<'a, T> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n-        let end = self.v.len() - i * self.chunk_size;\n-        let start = match end.checked_sub(self.chunk_size) {\n-            None => 0,\n-            Some(start) => start,\n-        };\n-        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n-        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }\n@@ -5961,6 +5997,17 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n             Some(&mut self.v[0..end])\n         }\n     }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let end = self.v.len() - idx * self.chunk_size;\n+        let start = match end.checked_sub(self.chunk_size) {\n+            None => 0,\n+            Some(start) => start,\n+        };\n+        // SAFETY: see comments for `RChunks::get_unchecked` and `ChunksMut::get_unchecked`\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -6008,17 +6055,8 @@ unsafe impl<T> TrustedLen for RChunksMut<'_, T> {}\n impl<T> FusedIterator for RChunksMut<'_, T> {}\n \n #[doc(hidden)]\n-#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<'a, T> TrustedRandomAccess for RChunksMut<'a, T> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n-        let end = self.v.len() - i * self.chunk_size;\n-        let start = match end.checked_sub(self.chunk_size) {\n-            None => 0,\n-            Some(start) => start,\n-        };\n-        // SAFETY: see comments for `RChunks::get_unchecked`.\n-        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }\n@@ -6105,6 +6143,15 @@ impl<'a, T> Iterator for RChunksExact<'a, T> {\n     fn last(mut self) -> Option<Self::Item> {\n         self.next_back()\n     }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let end = self.v.len() - idx * self.chunk_size;\n+        let start = end - self.chunk_size;\n+        // SAFETY:\n+        // SAFETY: mostmy identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -6153,14 +6200,8 @@ unsafe impl<T> TrustedLen for RChunksExact<'_, T> {}\n impl<T> FusedIterator for RChunksExact<'_, T> {}\n \n #[doc(hidden)]\n-#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<'a, T> TrustedRandomAccess for RChunksExact<'a, T> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n-        let end = self.v.len() - i * self.chunk_size;\n-        let start = end - self.chunk_size;\n-        // SAFETY: mostmy identical to `Chunks::get_unchecked`.\n-        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }\n@@ -6243,6 +6284,14 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n     fn last(mut self) -> Option<Self::Item> {\n         self.next_back()\n     }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let end = self.v.len() - idx * self.chunk_size;\n+        let start = end - self.chunk_size;\n+        // SAFETY: see comments for `RChunksMut::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -6293,14 +6342,8 @@ unsafe impl<T> TrustedLen for RChunksExactMut<'_, T> {}\n impl<T> FusedIterator for RChunksExactMut<'_, T> {}\n \n #[doc(hidden)]\n-#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n-        let end = self.v.len() - i * self.chunk_size;\n-        let start = end - self.chunk_size;\n-        // SAFETY: see comments for `RChunksExact::get_unchecked`.\n-        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }\n@@ -6543,18 +6586,20 @@ where\n }\n \n // Use an equal-pointer optimization when types are `Eq`\n-impl<A> SlicePartialEq<A> for [A]\n+// We can't make `A` and `B` the same type because `min_specialization` won't\n+// allow it.\n+impl<A, B> SlicePartialEq<B> for [A]\n where\n-    A: PartialEq<A> + Eq,\n+    A: MarkerEq<B>,\n {\n-    default fn equal(&self, other: &[A]) -> bool {\n+    default fn equal(&self, other: &[B]) -> bool {\n         if self.len() != other.len() {\n             return false;\n         }\n \n         // While performance would suffer if `guaranteed_eq` just returned `false`\n         // for all arguments, correctness and return value of this function are not affected.\n-        if self.as_ptr().guaranteed_eq(other.as_ptr()) {\n+        if self.as_ptr().guaranteed_eq(other.as_ptr() as *const A) {\n             return true;\n         }\n \n@@ -6563,18 +6608,18 @@ where\n }\n \n // Use memcmp for bytewise equality when the types allow\n-impl<A> SlicePartialEq<A> for [A]\n+impl<A, B> SlicePartialEq<B> for [A]\n where\n-    A: PartialEq<A> + BytewiseEquality,\n+    A: BytewiseEquality<B>,\n {\n-    fn equal(&self, other: &[A]) -> bool {\n+    fn equal(&self, other: &[B]) -> bool {\n         if self.len() != other.len() {\n             return false;\n         }\n \n         // While performance would suffer if `guaranteed_eq` just returned `false`\n         // for all arguments, correctness and return value of this function are not affected.\n-        if self.as_ptr().guaranteed_eq(other.as_ptr()) {\n+        if self.as_ptr().guaranteed_eq(other.as_ptr() as *const A) {\n             return true;\n         }\n         // SAFETY: `self` and `other` are references and are thus guaranteed to be valid.\n@@ -6631,6 +6676,7 @@ impl<A: AlwaysApplicableOrd> SlicePartialOrd for A {\n     }\n }\n \n+#[rustc_specialization_trait]\n trait AlwaysApplicableOrd: SliceOrd + Ord {}\n \n macro_rules! always_applicable_ord {\n@@ -6695,15 +6741,22 @@ impl SliceOrd for u8 {\n     }\n }\n \n+// Hack to allow specializing on `Eq` even though `Eq` has a method.\n+#[rustc_unsafe_specialization_marker]\n+trait MarkerEq<T>: PartialEq<T> {}\n+\n+impl<T: Eq> MarkerEq<T> for T {}\n+\n #[doc(hidden)]\n /// Trait implemented for types that can be compared for equality using\n /// their bytewise representation\n-trait BytewiseEquality: Eq + Copy {}\n+#[rustc_specialization_trait]\n+trait BytewiseEquality<T>: MarkerEq<T> + Copy {}\n \n macro_rules! impl_marker_for {\n     ($traitname:ident, $($ty:ty)*) => {\n         $(\n-            impl $traitname for $ty { }\n+            impl $traitname<$ty> for $ty { }\n         )*\n     }\n }\n@@ -6712,25 +6765,16 @@ impl_marker_for!(BytewiseEquality,\n                  u8 i8 u16 i16 u32 i32 u64 i64 u128 i128 usize isize char bool);\n \n #[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n-        // SAFETY: the caller must guarantee that `i` is in bounds\n-        // of the underlying slice, so `i` cannot overflow an `isize`,\n-        // and the returned references is guaranteed to refer to an element\n-        // of the slice and thus guaranteed to be valid.\n-        unsafe { &*self.ptr.as_ptr().add(i) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }\n }\n \n #[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n-        // SAFETY: see comments for `Iter::get_unchecked`.\n-        unsafe { &mut *self.ptr.as_ptr().add(i) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }"}, {"sha": "7c1027f60babb6ef4db4c3d484f81465163b9e09", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=d9d4d39612aae0b8398340bd83d592cafad8e4ec", "patch": "@@ -13,8 +13,9 @@ use self::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n \n use crate::char;\n use crate::fmt::{self, Write};\n+use crate::iter::TrustedRandomAccess;\n use crate::iter::{Chain, FlatMap, Flatten};\n-use crate::iter::{Copied, Filter, FusedIterator, Map, TrustedLen, TrustedRandomAccess};\n+use crate::iter::{Copied, Filter, FusedIterator, Map, TrustedLen};\n use crate::mem;\n use crate::ops::Try;\n use crate::option;\n@@ -819,6 +820,13 @@ impl Iterator for Bytes<'_> {\n     {\n         self.0.rposition(predicate)\n     }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> u8 {\n+        // SAFETY: the caller must uphold the safety contract\n+        // for `Iterator::get_unchecked`.\n+        unsafe { self.0.get_unchecked(idx) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -862,12 +870,8 @@ impl FusedIterator for Bytes<'_> {}\n unsafe impl TrustedLen for Bytes<'_> {}\n \n #[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl TrustedRandomAccess for Bytes<'_> {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> u8 {\n-        // SAFETY: the caller must uphold the safety contract\n-        // for `TrustedRandomAccess::get_unchecked`.\n-        unsafe { self.0.get_unchecked(i) }\n-    }\n     fn may_have_side_effect() -> bool {\n         false\n     }"}, {"sha": "00e3972c42f9d41fe0e14eb356615e2c851f5fca", "filename": "library/core/tests/iter.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d4d39612aae0b8398340bd83d592cafad8e4ec/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=d9d4d39612aae0b8398340bd83d592cafad8e4ec", "patch": "@@ -304,6 +304,103 @@ fn test_zip_nth_side_effects() {\n     assert_eq!(b, vec![200, 300, 400, 500, 600]);\n }\n \n+#[test]\n+fn test_zip_next_back_side_effects() {\n+    let mut a = Vec::new();\n+    let mut b = Vec::new();\n+    let mut iter = [1, 2, 3, 4, 5, 6]\n+        .iter()\n+        .cloned()\n+        .map(|n| {\n+            a.push(n);\n+            n * 10\n+        })\n+        .zip([2, 3, 4, 5, 6, 7, 8].iter().cloned().map(|n| {\n+            b.push(n * 100);\n+            n * 1000\n+        }));\n+\n+    // The second iterator is one item longer, so `next_back` is called on it\n+    // one more time.\n+    assert_eq!(iter.next_back(), Some((60, 7000)));\n+    assert_eq!(iter.next_back(), Some((50, 6000)));\n+    assert_eq!(iter.next_back(), Some((40, 5000)));\n+    assert_eq!(iter.next_back(), Some((30, 4000)));\n+    assert_eq!(a, vec![6, 5, 4, 3]);\n+    assert_eq!(b, vec![800, 700, 600, 500, 400]);\n+}\n+\n+#[test]\n+fn test_zip_nth_back_side_effects() {\n+    let mut a = Vec::new();\n+    let mut b = Vec::new();\n+    let value = [1, 2, 3, 4, 5, 6]\n+        .iter()\n+        .cloned()\n+        .map(|n| {\n+            a.push(n);\n+            n * 10\n+        })\n+        .zip([2, 3, 4, 5, 6, 7, 8].iter().cloned().map(|n| {\n+            b.push(n * 100);\n+            n * 1000\n+        }))\n+        .nth_back(3);\n+    assert_eq!(value, Some((30, 4000)));\n+    assert_eq!(a, vec![6, 5, 4, 3]);\n+    assert_eq!(b, vec![800, 700, 600, 500, 400]);\n+}\n+\n+#[test]\n+fn test_zip_next_back_side_effects_exhausted() {\n+    let mut a = Vec::new();\n+    let mut b = Vec::new();\n+    let mut iter = [1, 2, 3, 4, 5, 6]\n+        .iter()\n+        .cloned()\n+        .map(|n| {\n+            a.push(n);\n+            n * 10\n+        })\n+        .zip([2, 3, 4].iter().cloned().map(|n| {\n+            b.push(n * 100);\n+            n * 1000\n+        }));\n+\n+    iter.next();\n+    iter.next();\n+    iter.next();\n+    iter.next();\n+    assert_eq!(iter.next_back(), None);\n+    assert_eq!(a, vec![1, 2, 3, 4, 6, 5]);\n+    assert_eq!(b, vec![200, 300, 400]);\n+}\n+\n+#[test]\n+fn test_zip_nth_back_side_effects_exhausted() {\n+    let mut a = Vec::new();\n+    let mut b = Vec::new();\n+    let mut iter = [1, 2, 3, 4, 5, 6]\n+        .iter()\n+        .cloned()\n+        .map(|n| {\n+            a.push(n);\n+            n * 10\n+        })\n+        .zip([2, 3, 4].iter().cloned().map(|n| {\n+            b.push(n * 100);\n+            n * 1000\n+        }));\n+\n+    iter.next();\n+    iter.next();\n+    iter.next();\n+    iter.next();\n+    assert_eq!(iter.nth_back(0), None);\n+    assert_eq!(a, vec![1, 2, 3, 4, 6, 5]);\n+    assert_eq!(b, vec![200, 300, 400]);\n+}\n+\n #[test]\n fn test_iterator_step_by() {\n     // Identity"}]}