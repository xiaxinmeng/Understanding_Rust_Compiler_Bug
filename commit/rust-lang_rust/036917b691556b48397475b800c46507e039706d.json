{"sha": "036917b691556b48397475b800c46507e039706d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNjkxN2I2OTE1NTZiNDgzOTc0NzViODAwYzQ2NTA3ZTAzOTcwNmQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-11-07T01:01:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-07T01:01:42Z"}, "message": "Merge pull request #2121 from topecongiro/clippy-lints\n\nRefactor code via clippy", "tree": {"sha": "f50444fce1d96e4cdc0f2477c43c613f7b9ba120", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f50444fce1d96e4cdc0f2477c43c613f7b9ba120"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/036917b691556b48397475b800c46507e039706d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaAQX2CRBK7hj4Ov3rIwAAdHIIAI85J+59DGbr6eAjxO4FnpB4\nINxKB57OLsQ3R1ErhZnWXdKz/a5J6Phr68lcjnFiq9HCyhnDoJrxHlAcCWcZ6utH\n8qMOCKJUuh+LlynbkZGwGJIBflIwLFs4W9DtnVYR+JzNclVLU0rn2452FAH0q9ih\nr1kJxU+SPzR88xDd+IE4C6y1XraPWy2URNotNmIQLo4m4etOmuOJ/unNWfzNazI+\nLUGYOmgUfCJFFWPyTsiLkzNeulY4eHQ5+XaJ+suKOVLLo86lpJ5GgAJHJdcw0Rev\n1/EeaAf/rnXEEL/ykZSbiYRTqiwr+dUHeTy0BCJMwNmDtrQFkByfTABKtUQoRFA=\n=uWr/\n-----END PGP SIGNATURE-----\n", "payload": "tree f50444fce1d96e4cdc0f2477c43c613f7b9ba120\nparent f412c875ea25d5f68bafe0837ccf46998596588e\nparent e917eff7bac845727416aa8fb5818ecf114627f3\nauthor Nick Cameron <nrc@ncameron.org> 1510016502 +1300\ncommitter GitHub <noreply@github.com> 1510016502 +1300\n\nMerge pull request #2121 from topecongiro/clippy-lints\n\nRefactor code via clippy"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/036917b691556b48397475b800c46507e039706d", "html_url": "https://github.com/rust-lang/rust/commit/036917b691556b48397475b800c46507e039706d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/036917b691556b48397475b800c46507e039706d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f412c875ea25d5f68bafe0837ccf46998596588e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f412c875ea25d5f68bafe0837ccf46998596588e", "html_url": "https://github.com/rust-lang/rust/commit/f412c875ea25d5f68bafe0837ccf46998596588e"}, {"sha": "e917eff7bac845727416aa8fb5818ecf114627f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e917eff7bac845727416aa8fb5818ecf114627f3", "html_url": "https://github.com/rust-lang/rust/commit/e917eff7bac845727416aa8fb5818ecf114627f3"}], "stats": {"total": 591, "additions": 289, "deletions": 302}, "files": [{"sha": "2982755aa9c44b715ed51151a7d4005922522e72", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -6,6 +6,15 @@ dependencies = [\n  \"memchr 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"derive-new\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"diff\"\n version = \"0.1.10\"\n@@ -98,6 +107,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"rustfmt-nightly\"\n version = \"0.2.14\"\n dependencies = [\n+ \"derive-new 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -242,6 +252,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n \"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n+\"checksum derive-new 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"415f627ab054041c3eb748c2e1da0ef751989f5f0c386b63a098e545854a98ba\"\n \"checksum diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a515461b6c8c08419850ced27bc29e86166dcdcde8fbe76f8b1f0589bb49472\"\n \"checksum dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09c3753c3db574d215cba4ea76018483895d7bff25a31b49ba45db21c48e50ab\"\n \"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\""}, {"sha": "3af4803bc5f3bad285e12b5f4e74c945e8f23c18", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -40,6 +40,7 @@ diff = \"0.1\"\n log = \"0.3\"\n env_logger = \"0.4\"\n getopts = \"0.2\"\n+derive-new = \"0.5\"\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2.11\""}, {"sha": "60cc59bc1a033696a621d7bbcb1cf362c4770ffd", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -254,15 +254,15 @@ fn extract_target_from_package(package: &Value) -> Option<Vec<Target>> {\n     let jtargets = get_json_array_with(package, \"targets\")?;\n     let mut targets: Vec<Target> = vec![];\n     for jtarget in jtargets {\n-        targets.push(Target::from_json(&jtarget)?);\n+        targets.push(Target::from_json(jtarget)?);\n     }\n     Some(targets)\n }\n \n-fn filter_packages_with_hitlist<'a>(\n+fn filter_packages_with_hitlist(\n     packages: Vec<Value>,\n-    workspace_hitlist: &'a WorkspaceHitlist,\n-) -> Result<Vec<Value>, &'a String> {\n+    workspace_hitlist: &WorkspaceHitlist,\n+) -> Result<Vec<Value>, &String> {\n     let some_hitlist: Option<HashSet<&String>> =\n         workspace_hitlist.get_some().map(HashSet::from_iter);\n     if some_hitlist.is_none() {\n@@ -387,7 +387,7 @@ fn format_files(\n         for f in files {\n             print!(\" {}\", f.display());\n         }\n-        println!(\"\");\n+        println!();\n     }\n     let mut command = Command::new(\"rustfmt\")\n         .stdout(stdout)"}, {"sha": "0df8d37807bec2fe26eef8803767e1e8e67f3f08", "filename": "src/bin/rustfmt-format-diff.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fbin%2Frustfmt-format-diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fbin%2Frustfmt-format-diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt-format-diff.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -33,7 +33,7 @@ use regex::Regex;\n /// The default pattern of files to format.\n ///\n /// We only want to format rust files by default.\n-const DEFAULT_PATTERN: &'static str = r\".*\\.rs\";\n+const DEFAULT_PATTERN: &str = r\".*\\.rs\";\n \n #[derive(Debug)]\n enum FormatDiffError {"}, {"sha": "f0e4f0a789780048afdb37099de2b4315c894483", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -73,9 +73,9 @@ impl CliOptions {\n             .map(|c| c == \"nightly\")\n             .unwrap_or(false);\n         if unstable_features && !rust_nightly {\n-            return Err(FmtError::from(format!(\n-                \"Unstable features are only available on Nightly channel\"\n-            )));\n+            return Err(FmtError::from(\n+                \"Unstable features are only available on Nightly channel\",\n+            ));\n         } else {\n             options.unstable_features = unstable_features;\n         }"}, {"sha": "6d5f48fbb2618973873ad463639e6db3e3e7ed9b", "filename": "src/comment.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -327,12 +327,10 @@ fn rewrite_comment_inner(\n             if line.is_empty() {\n                 continue;\n             }\n+        } else if is_prev_line_multi_line && !line.is_empty() {\n+            result.push(' ')\n         } else {\n-            if is_prev_line_multi_line && !line.is_empty() {\n-                result.push(' ')\n-            } else {\n-                result.push_str(&comment_line_separator);\n-            }\n+            result.push_str(&comment_line_separator);\n         }\n \n         if config.wrap_comments() && line.len() > fmt.shape.width && !has_url(line) {"}, {"sha": "450e016bc5ae066c8cab63dfde0d6eb0f036f5cb", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -478,7 +478,7 @@ macro_rules! create_config {\n                     $(\n                         println!(\"{}{}\", space_str, $dstring);\n                     )+\n-                    println!(\"\");\n+                    println!();\n                 )+\n             }\n         }\n@@ -500,7 +500,7 @@ macro_rules! create_config {\n ///\n /// Return the path if a config file exists, empty if no file exists, and Error for IO errors\n pub fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n-    const CONFIG_FILE_NAMES: [&'static str; 2] = [\".rustfmt.toml\", \"rustfmt.toml\"];\n+    const CONFIG_FILE_NAMES: [&str; 2] = [\".rustfmt.toml\", \"rustfmt.toml\"];\n     for config_file_name in &CONFIG_FILE_NAMES {\n         let config_file = dir.join(config_file_name);\n         match fs::metadata(&config_file) {"}, {"sha": "d8f42944ad0c2adc34deec6bd69b1174c141b518", "filename": "src/expr.rs", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -75,17 +75,15 @@ pub fn format_expr(\n         ast::ExprKind::Call(ref callee, ref args) => {\n             let inner_span = mk_sp(callee.span.hi(), expr.span.hi());\n             let callee_str = callee.rewrite(context, shape)?;\n-            rewrite_call(context, &callee_str, &args, inner_span, shape)\n+            rewrite_call(context, &callee_str, args, inner_span, shape)\n         }\n         ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, shape),\n         ast::ExprKind::Binary(ref op, ref lhs, ref rhs) => {\n             // FIXME: format comments between operands and operator\n             rewrite_pair(\n                 &**lhs,\n                 &**rhs,\n-                \"\",\n-                &format!(\" {} \", context.snippet(op.span)),\n-                \"\",\n+                PairParts::new(\"\", &format!(\" {} \", context.snippet(op.span)), \"\"),\n                 context,\n                 shape,\n                 context.config.binop_separator(),\n@@ -101,7 +99,7 @@ pub fn format_expr(\n             shape,\n         ),\n         ast::ExprKind::Tup(ref items) => {\n-            rewrite_tuple(context, &ptr_vec_to_ref_vec(&items), expr.span, shape)\n+            rewrite_tuple(context, &ptr_vec_to_ref_vec(items), expr.span, shape)\n         }\n         ast::ExprKind::If(..) |\n         ast::ExprKind::IfLet(..) |\n@@ -186,19 +184,15 @@ pub fn format_expr(\n         ast::ExprKind::Cast(ref expr, ref ty) => rewrite_pair(\n             &**expr,\n             &**ty,\n-            \"\",\n-            \" as \",\n-            \"\",\n+            PairParts::new(\"\", \" as \", \"\"),\n             context,\n             shape,\n             SeparatorPlace::Front,\n         ),\n         ast::ExprKind::Type(ref expr, ref ty) => rewrite_pair(\n             &**expr,\n             &**ty,\n-            \"\",\n-            \": \",\n-            \"\",\n+            PairParts::new(\"\", \": \", \"\"),\n             context,\n             shape,\n             SeparatorPlace::Back,\n@@ -215,9 +209,7 @@ pub fn format_expr(\n             rewrite_pair(\n                 &**expr,\n                 &**repeats,\n-                lbr,\n-                \"; \",\n-                rbr,\n+                PairParts::new(lbr, \"; \", rbr),\n                 context,\n                 shape,\n                 SeparatorPlace::Back,\n@@ -253,9 +245,7 @@ pub fn format_expr(\n                     rewrite_pair(\n                         &*lhs,\n                         &*rhs,\n-                        \"\",\n-                        &sp_delim,\n-                        \"\",\n+                        PairParts::new(\"\", &sp_delim, \"\"),\n                         context,\n                         shape,\n                         SeparatorPlace::Front,\n@@ -315,12 +305,17 @@ pub fn format_expr(\n         })\n }\n \n+#[derive(new)]\n+pub struct PairParts<'a> {\n+    prefix: &'a str,\n+    infix: &'a str,\n+    suffix: &'a str,\n+}\n+\n pub fn rewrite_pair<LHS, RHS>(\n     lhs: &LHS,\n     rhs: &RHS,\n-    prefix: &str,\n-    infix: &str,\n-    suffix: &str,\n+    pp: PairParts,\n     context: &RewriteContext,\n     shape: Shape,\n     separator_place: SeparatorPlace,\n@@ -330,20 +325,20 @@ where\n     RHS: Rewrite,\n {\n     let lhs_overhead = match separator_place {\n-        SeparatorPlace::Back => shape.used_width() + prefix.len() + infix.trim_right().len(),\n+        SeparatorPlace::Back => shape.used_width() + pp.prefix.len() + pp.infix.trim_right().len(),\n         SeparatorPlace::Front => shape.used_width(),\n     };\n     let lhs_shape = Shape {\n         width: context.budget(lhs_overhead),\n         ..shape\n     };\n     let lhs_result = lhs.rewrite(context, lhs_shape)\n-        .map(|lhs_str| format!(\"{}{}\", prefix, lhs_str))?;\n+        .map(|lhs_str| format!(\"{}{}\", pp.prefix, lhs_str))?;\n \n     // Try to the both lhs and rhs on the same line.\n     let rhs_orig_result = shape\n-        .offset_left(last_line_width(&lhs_result) + infix.len())\n-        .and_then(|s| s.sub_width(suffix.len()))\n+        .offset_left(last_line_width(&lhs_result) + pp.infix.len())\n+        .and_then(|s| s.sub_width(pp.suffix.len()))\n         .and_then(|rhs_shape| rhs.rewrite(context, rhs_shape));\n     if let Some(ref rhs_result) = rhs_orig_result {\n         // If the rhs looks like block expression, we allow it to stay on the same line\n@@ -354,10 +349,16 @@ where\n             .map(|first_line| first_line.ends_with('{'))\n             .unwrap_or(false);\n         if !rhs_result.contains('\\n') || allow_same_line {\n-            let one_line_width = last_line_width(&lhs_result) + infix.len()\n-                + first_line_width(&rhs_result) + suffix.len();\n+            let one_line_width = last_line_width(&lhs_result) + pp.infix.len()\n+                + first_line_width(rhs_result) + pp.suffix.len();\n             if one_line_width <= shape.width {\n-                return Some(format!(\"{}{}{}{}\", lhs_result, infix, rhs_result, suffix));\n+                return Some(format!(\n+                    \"{}{}{}{}\",\n+                    lhs_result,\n+                    pp.infix,\n+                    rhs_result,\n+                    pp.suffix\n+                ));\n             }\n         }\n     }\n@@ -366,8 +367,8 @@ where\n     // Re-evaluate the rhs because we have more space now:\n     let mut rhs_shape = match context.config.control_style() {\n         Style::Legacy => shape\n-            .sub_width(suffix.len() + prefix.len())?\n-            .visual_indent(prefix.len()),\n+            .sub_width(pp.suffix.len() + pp.prefix.len())?\n+            .visual_indent(pp.prefix.len()),\n         Style::Rfc => {\n             // Try to calculate the initial constraint on the right hand side.\n             let rhs_overhead = shape.rhs_overhead(context.config);\n@@ -376,31 +377,25 @@ where\n         }\n     };\n     let infix = match separator_place {\n-        SeparatorPlace::Back => infix.trim_right(),\n-        SeparatorPlace::Front => infix.trim_left(),\n+        SeparatorPlace::Back => pp.infix.trim_right(),\n+        SeparatorPlace::Front => pp.infix.trim_left(),\n     };\n     if separator_place == SeparatorPlace::Front {\n         rhs_shape = rhs_shape.offset_left(infix.len())?;\n     }\n     let rhs_result = rhs.rewrite(context, rhs_shape)?;\n-    match separator_place {\n-        SeparatorPlace::Back => Some(format!(\n-            \"{}{}\\n{}{}{}\",\n-            lhs_result,\n-            infix,\n-            rhs_shape.indent.to_string(context.config),\n-            rhs_result,\n-            suffix\n-        )),\n-        SeparatorPlace::Front => Some(format!(\n-            \"{}\\n{}{}{}{}\",\n-            lhs_result,\n-            rhs_shape.indent.to_string(context.config),\n-            infix,\n-            rhs_result,\n-            suffix\n-        )),\n-    }\n+    let indent_str = rhs_shape.indent.to_string(context.config);\n+    let infix_with_sep = match separator_place {\n+        SeparatorPlace::Back => format!(\"{}\\n{}\", infix, indent_str),\n+        SeparatorPlace::Front => format!(\"\\n{}{}\", indent_str, infix),\n+    };\n+    Some(format!(\n+        \"{}{}{}{}\",\n+        lhs_result,\n+        infix_with_sep,\n+        rhs_result,\n+        pp.suffix\n+    ))\n }\n \n pub fn rewrite_array<'a, I>(\n@@ -641,7 +636,7 @@ fn rewrite_closure(\n         };\n         if no_return_type && !needs_block {\n             // block.stmts.len() == 1\n-            if let Some(ref expr) = stmt_expr(&block.stmts[0]) {\n+            if let Some(expr) = stmt_expr(&block.stmts[0]) {\n                 if let Some(rw) = if is_block_closure_forced(expr) {\n                     rewrite_closure_with_block(context, shape, &prefix, expr)\n                 } else {\n@@ -2004,7 +1999,7 @@ pub fn rewrite_call(\n     rewrite_call_inner(\n         context,\n         callee,\n-        &ptr_vec_to_ref_vec(&args),\n+        &ptr_vec_to_ref_vec(args),\n         span,\n         shape,\n         context.config.fn_call_width(),"}, {"sha": "faf0638f7d1326e9b9cae1d6cc3008643f4ace9b", "filename": "src/imports.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -75,11 +75,11 @@ fn compare_path_list_items(a: &ast::PathListItem, b: &ast::PathListItem) -> Orde\n }\n \n fn compare_path_list_item_lists(\n-    a_items: &Vec<ast::PathListItem>,\n-    b_items: &Vec<ast::PathListItem>,\n+    a_items: &[ast::PathListItem],\n+    b_items: &[ast::PathListItem],\n ) -> Ordering {\n-    let mut a = a_items.clone();\n-    let mut b = b_items.clone();\n+    let mut a = a_items.to_owned();\n+    let mut b = b_items.to_owned();\n     a.sort_by(|a, b| compare_path_list_items(a, b));\n     b.sort_by(|a, b| compare_path_list_items(a, b));\n     for comparison_pair in a.iter().zip(b.iter()) {\n@@ -94,15 +94,14 @@ fn compare_path_list_item_lists(\n fn compare_view_path_types(a: &ast::ViewPath_, b: &ast::ViewPath_) -> Ordering {\n     use syntax::ast::ViewPath_::*;\n     match (a, b) {\n-        (&ViewPathSimple(..), &ViewPathSimple(..)) => Ordering::Equal,\n-        (&ViewPathSimple(..), _) => Ordering::Less,\n-        (&ViewPathGlob(_), &ViewPathSimple(..)) => Ordering::Greater,\n-        (&ViewPathGlob(_), &ViewPathGlob(_)) => Ordering::Equal,\n-        (&ViewPathGlob(_), &ViewPathList(..)) => Ordering::Less,\n+        (&ViewPathSimple(..), &ViewPathSimple(..)) | (&ViewPathGlob(_), &ViewPathGlob(_)) => {\n+            Ordering::Equal\n+        }\n+        (&ViewPathSimple(..), _) | (&ViewPathGlob(_), &ViewPathList(..)) => Ordering::Less,\n         (&ViewPathList(_, ref a_items), &ViewPathList(_, ref b_items)) => {\n             compare_path_list_item_lists(a_items, b_items)\n         }\n-        (&ViewPathList(..), _) => Ordering::Greater,\n+        (&ViewPathGlob(_), &ViewPathSimple(..)) | (&ViewPathList(..), _) => Ordering::Greater,\n     }\n }\n \n@@ -293,7 +292,7 @@ impl<'a> FmtVisitor<'a> {\n             }\n             Some(ref s) => {\n                 self.format_missing_with_indent(source!(self, span).lo());\n-                self.buffer.push_str(&s);\n+                self.buffer.push_str(s);\n                 self.last_pos = source!(self, span).hi();\n             }\n             None => {"}, {"sha": "731ce2343886018f0ff0d8aff775e9db70ec2a87", "filename": "src/items.rs", "status": "modified", "additions": 166, "deletions": 89, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -215,7 +215,7 @@ impl<'a> FnSig<'a> {\n                 unsafety: unsafety,\n                 visibility: visibility.clone(),\n             },\n-            visit::FnKind::Method(_, ref method_sig, vis, _) => {\n+            visit::FnKind::Method(_, method_sig, vis, _) => {\n                 let mut fn_sig = FnSig::from_method_sig(method_sig, generics);\n                 fn_sig.defaultness = defualtness;\n                 if let Some(vis) = vis {\n@@ -313,10 +313,10 @@ impl<'a> FmtVisitor<'a> {\n         let (mut result, force_newline_brace) =\n             rewrite_fn_base(&context, indent, ident, fn_sig, span, newline_brace, true)?;\n \n-        if self.config.fn_brace_style() == BraceStyle::AlwaysNextLine || force_newline_brace {\n-            newline_brace = true;\n-        } else if last_line_width(&result) + 2 > self.shape().width {\n-            // 2 = ` {`\n+        // 2 = ` {`\n+        if self.config.fn_brace_style() == BraceStyle::AlwaysNextLine || force_newline_brace\n+            || last_line_width(&result) + 2 > self.shape().width\n+        {\n             newline_brace = true;\n         } else if !result.contains('\\n') {\n             newline_brace = false;\n@@ -411,6 +411,18 @@ impl<'a> FmtVisitor<'a> {\n         None\n     }\n \n+    pub fn visit_static(&mut self, static_parts: &StaticParts) {\n+        let rewrite = rewrite_static(&self.get_context(), static_parts, self.block_indent);\n+        self.push_rewrite(static_parts.span, rewrite);\n+    }\n+\n+    pub fn visit_struct(&mut self, struct_parts: &StructParts) {\n+        let is_tuple = struct_parts.def.is_tuple();\n+        let rewrite = format_struct(&self.get_context(), struct_parts, self.block_indent, None)\n+            .map(|s| if is_tuple { s + \";\" } else { s });\n+        self.push_rewrite(struct_parts.span, rewrite);\n+    }\n+\n     pub fn visit_enum(\n         &mut self,\n         ident: ast::Ident,\n@@ -428,8 +440,6 @@ impl<'a> FmtVisitor<'a> {\n         let generics_str = format_generics(\n             &self.get_context(),\n             generics,\n-            \"{\",\n-            \"{\",\n             self.config.item_brace_style(),\n             enum_def.variants.is_empty(),\n             self.block_indent,\n@@ -531,12 +541,7 @@ impl<'a> FmtVisitor<'a> {\n                 // FIXME: Should limit the width, as we have a trailing comma\n                 format_struct(\n                     &context,\n-                    \"\",\n-                    field.node.name,\n-                    &ast::Visibility::Inherited,\n-                    &field.node.data,\n-                    None,\n-                    field.span,\n+                    &StructParts::from_variant(field),\n                     indent,\n                     Some(self.config.struct_variant_width()),\n                 )?\n@@ -546,7 +551,7 @@ impl<'a> FmtVisitor<'a> {\n                 // 1 = ','\n                 rewrite_assign_rhs(&context, lhs, expr, shape.sub_width(1)?)?\n             } else {\n-                String::from(field.node.name.to_string())\n+                field.node.name.to_string()\n             },\n         };\n \n@@ -670,7 +675,7 @@ pub fn format_impl(\n             result.push_str(&outer_indent_str);\n         }\n \n-        if result.chars().last().unwrap() == '{' {\n+        if result.ends_with('{') {\n             result.push_str(&sep);\n         }\n         result.push('}');\n@@ -857,40 +862,62 @@ fn rewrite_trait_ref(\n     }\n }\n \n-pub fn format_struct(\n-    context: &RewriteContext,\n-    item_name: &str,\n+pub struct StructParts<'a> {\n+    prefix: &'a str,\n     ident: ast::Ident,\n-    vis: &ast::Visibility,\n-    struct_def: &ast::VariantData,\n-    generics: Option<&ast::Generics>,\n+    vis: &'a ast::Visibility,\n+    def: &'a ast::VariantData,\n+    generics: Option<&'a ast::Generics>,\n     span: Span,\n+}\n+\n+impl<'a> StructParts<'a> {\n+    fn format_header(&self) -> String {\n+        format_header(self.prefix, self.ident, self.vis)\n+    }\n+\n+    fn from_variant(variant: &'a ast::Variant) -> Self {\n+        StructParts {\n+            prefix: \"\",\n+            ident: variant.node.name,\n+            vis: &ast::Visibility::Inherited,\n+            def: &variant.node.data,\n+            generics: None,\n+            span: variant.span,\n+        }\n+    }\n+\n+    pub fn from_item(item: &'a ast::Item) -> Self {\n+        let (prefix, def, generics) = match item.node {\n+            ast::ItemKind::Struct(ref def, ref generics) => (\"struct \", def, generics),\n+            ast::ItemKind::Union(ref def, ref generics) => (\"union \", def, generics),\n+            _ => unreachable!(),\n+        };\n+        StructParts {\n+            prefix: prefix,\n+            ident: item.ident,\n+            vis: &item.vis,\n+            def: def,\n+            generics: Some(generics),\n+            span: item.span,\n+        }\n+    }\n+}\n+\n+fn format_struct(\n+    context: &RewriteContext,\n+    struct_parts: &StructParts,\n     offset: Indent,\n     one_line_width: Option<usize>,\n ) -> Option<String> {\n-    match *struct_def {\n-        ast::VariantData::Unit(..) => Some(format_unit_struct(item_name, ident, vis)),\n-        ast::VariantData::Tuple(ref fields, _) => format_tuple_struct(\n-            context,\n-            item_name,\n-            ident,\n-            vis,\n-            fields,\n-            generics,\n-            span,\n-            offset,\n-        ),\n-        ast::VariantData::Struct(ref fields, _) => format_struct_struct(\n-            context,\n-            item_name,\n-            ident,\n-            vis,\n-            fields,\n-            generics,\n-            span,\n-            offset,\n-            one_line_width,\n-        ),\n+    match *struct_parts.def {\n+        ast::VariantData::Unit(..) => Some(format_unit_struct(struct_parts)),\n+        ast::VariantData::Tuple(ref fields, _) => {\n+            format_tuple_struct(context, struct_parts, fields, offset)\n+        }\n+        ast::VariantData::Struct(ref fields, _) => {\n+            format_struct_struct(context, struct_parts, fields, offset, one_line_width)\n+        }\n     }\n }\n \n@@ -1052,35 +1079,30 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n     }\n }\n \n-fn format_unit_struct(item_name: &str, ident: ast::Ident, vis: &ast::Visibility) -> String {\n-    format!(\"{};\", format_header(item_name, ident, vis))\n+fn format_unit_struct(p: &StructParts) -> String {\n+    format!(\"{};\", format_header(p.prefix, p.ident, p.vis))\n }\n \n pub fn format_struct_struct(\n     context: &RewriteContext,\n-    item_name: &str,\n-    ident: ast::Ident,\n-    vis: &ast::Visibility,\n+    struct_parts: &StructParts,\n     fields: &[ast::StructField],\n-    generics: Option<&ast::Generics>,\n-    span: Span,\n     offset: Indent,\n     one_line_width: Option<usize>,\n ) -> Option<String> {\n     let mut result = String::with_capacity(1024);\n+    let span = struct_parts.span;\n \n-    let header_str = format_header(item_name, ident, vis);\n+    let header_str = struct_parts.format_header();\n     result.push_str(&header_str);\n \n     let header_hi = span.lo() + BytePos(header_str.len() as u32);\n     let body_lo = context.codemap.span_after(span, \"{\");\n \n-    let generics_str = match generics {\n+    let generics_str = match struct_parts.generics {\n         Some(g) => format_generics(\n             context,\n             g,\n-            \"{\",\n-            \"{\",\n             context.config.item_brace_style(),\n             fields.is_empty(),\n             offset,\n@@ -1178,21 +1200,18 @@ fn get_bytepos_after_visibility(\n \n fn format_tuple_struct(\n     context: &RewriteContext,\n-    item_name: &str,\n-    ident: ast::Ident,\n-    vis: &ast::Visibility,\n+    struct_parts: &StructParts,\n     fields: &[ast::StructField],\n-    generics: Option<&ast::Generics>,\n-    span: Span,\n     offset: Indent,\n ) -> Option<String> {\n     let mut result = String::with_capacity(1024);\n+    let span = struct_parts.span;\n \n-    let header_str = format_header(item_name, ident, vis);\n+    let header_str = struct_parts.format_header();\n     result.push_str(&header_str);\n \n     let body_lo = if fields.is_empty() {\n-        let lo = get_bytepos_after_visibility(context, vis, span, \")\");\n+        let lo = get_bytepos_after_visibility(context, struct_parts.vis, span, \")\");\n         context.codemap.span_after(mk_sp(lo, span.hi()), \"(\")\n     } else {\n         fields[0].span.lo()\n@@ -1211,7 +1230,7 @@ fn format_tuple_struct(\n         }\n     };\n \n-    let where_clause_str = match generics {\n+    let where_clause_str = match struct_parts.generics {\n         Some(generics) => {\n             let budget = context.budget(last_line_width(&header_str));\n             let shape = Shape::legacy(budget, offset);\n@@ -1465,36 +1484,92 @@ pub fn rewrite_struct_field(\n     )\n }\n \n-pub fn rewrite_static(\n-    prefix: &str,\n-    vis: &ast::Visibility,\n+pub struct StaticParts<'a> {\n+    prefix: &'a str,\n+    vis: &'a ast::Visibility,\n     ident: ast::Ident,\n-    ty: &ast::Ty,\n+    ty: &'a ast::Ty,\n     mutability: ast::Mutability,\n-    expr_opt: Option<&ptr::P<ast::Expr>>,\n-    offset: Indent,\n+    expr_opt: Option<&'a ptr::P<ast::Expr>>,\n     span: Span,\n+}\n+\n+impl<'a> StaticParts<'a> {\n+    pub fn from_item(item: &'a ast::Item) -> Self {\n+        let (prefix, ty, mutability, expr) = match item.node {\n+            ast::ItemKind::Static(ref ty, mutability, ref expr) => (\"static\", ty, mutability, expr),\n+            ast::ItemKind::Const(ref ty, ref expr) => {\n+                (\"const\", ty, ast::Mutability::Immutable, expr)\n+            }\n+            _ => unreachable!(),\n+        };\n+        StaticParts {\n+            prefix: prefix,\n+            vis: &item.vis,\n+            ident: item.ident,\n+            ty: ty,\n+            mutability: mutability,\n+            expr_opt: Some(expr),\n+            span: item.span,\n+        }\n+    }\n+\n+    pub fn from_trait_item(ti: &'a ast::TraitItem) -> Self {\n+        let (ty, expr_opt) = match ti.node {\n+            ast::TraitItemKind::Const(ref ty, ref expr_opt) => (ty, expr_opt),\n+            _ => unreachable!(),\n+        };\n+        StaticParts {\n+            prefix: \"const\",\n+            vis: &ast::Visibility::Inherited,\n+            ident: ti.ident,\n+            ty: ty,\n+            mutability: ast::Mutability::Immutable,\n+            expr_opt: expr_opt.as_ref(),\n+            span: ti.span,\n+        }\n+    }\n+\n+    pub fn from_impl_item(ii: &'a ast::ImplItem) -> Self {\n+        let (ty, expr) = match ii.node {\n+            ast::ImplItemKind::Const(ref ty, ref expr) => (ty, expr),\n+            _ => unreachable!(),\n+        };\n+        StaticParts {\n+            prefix: \"const\",\n+            vis: &ii.vis,\n+            ident: ii.ident,\n+            ty: ty,\n+            mutability: ast::Mutability::Immutable,\n+            expr_opt: Some(expr),\n+            span: ii.span,\n+        }\n+    }\n+}\n+\n+fn rewrite_static(\n     context: &RewriteContext,\n+    static_parts: &StaticParts,\n+    offset: Indent,\n ) -> Option<String> {\n     let colon = colon_spaces(\n         context.config.space_before_type_annotation(),\n         context.config.space_after_type_annotation_colon(),\n     );\n     let prefix = format!(\n         \"{}{} {}{}{}\",\n-        format_visibility(vis),\n-        prefix,\n-        format_mutability(mutability),\n-        ident,\n+        format_visibility(static_parts.vis),\n+        static_parts.prefix,\n+        format_mutability(static_parts.mutability),\n+        static_parts.ident,\n         colon,\n     );\n     // 2 = \" =\".len()\n-    let ty_str = ty.rewrite(\n-        context,\n-        Shape::indented(offset.block_only(), context.config).offset_left(prefix.len() + 2)?,\n-    )?;\n+    let ty_shape =\n+        Shape::indented(offset.block_only(), context.config).offset_left(prefix.len() + 2)?;\n+    let ty_str = static_parts.ty.rewrite(context, ty_shape)?;\n \n-    if let Some(expr) = expr_opt {\n+    if let Some(expr) = static_parts.expr_opt {\n         let lhs = format!(\"{}{} =\", prefix, ty_str);\n         // 1 = ;\n         let remaining_width = context.budget(offset.block_indent + 1);\n@@ -1503,7 +1578,9 @@ pub fn rewrite_static(\n             lhs,\n             expr,\n             Shape::legacy(remaining_width, offset.block_only()),\n-        ).and_then(|res| recover_comment_removed(res, span, context))\n+        ).and_then(|res| {\n+            recover_comment_removed(res, static_parts.span, context)\n+        })\n             .map(|s| if s.ends_with(';') { s } else { s + \";\" })\n     } else {\n         Some(format!(\"{}{};\", prefix, ty_str))\n@@ -2318,16 +2395,16 @@ fn rewrite_generics_inner(\n     impl<'a> Rewrite for GenericsArg<'a> {\n         fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n             match *self {\n-                GenericsArg::Lifetime(ref lifetime) => lifetime.rewrite(context, shape),\n-                GenericsArg::TyParam(ref ty) => ty.rewrite(context, shape),\n+                GenericsArg::Lifetime(lifetime) => lifetime.rewrite(context, shape),\n+                GenericsArg::TyParam(ty) => ty.rewrite(context, shape),\n             }\n         }\n     }\n     impl<'a> Spanned for GenericsArg<'a> {\n         fn span(&self) -> Span {\n             match *self {\n-                GenericsArg::Lifetime(ref lifetime) => lifetime.span(),\n-                GenericsArg::TyParam(ref ty) => ty.span(),\n+                GenericsArg::Lifetime(lifetime) => lifetime.span(),\n+                GenericsArg::TyParam(ty) => ty.span(),\n             }\n         }\n     }\n@@ -2693,8 +2770,6 @@ fn format_header(item_name: &str, ident: ast::Ident, vis: &ast::Visibility) -> S\n fn format_generics(\n     context: &RewriteContext,\n     generics: &ast::Generics,\n-    opener: &str,\n-    terminator: &str,\n     brace_style: BraceStyle,\n     force_same_line_brace: bool,\n     offset: Indent,\n@@ -2720,7 +2795,7 @@ fn format_generics(\n             brace_style,\n             Shape::legacy(budget, offset.block_only()),\n             Density::Tall,\n-            terminator,\n+            \"{\",\n             Some(span.hi()),\n             span_end_before_where,\n             option,\n@@ -2740,9 +2815,11 @@ fn format_generics(\n     // and hence we take the closer into account as well for one line budget.\n     // We assume that the closer has the same length as the opener.\n     let overhead = if force_same_line_brace {\n-        1 + opener.len() + opener.len()\n+        // 3 = ` {}`\n+        3\n     } else {\n-        1 + opener.len()\n+        // 2 = ` {`\n+        2\n     };\n     let forbid_same_line_brace = overhead > remaining_budget;\n     if !forbid_same_line_brace && same_line_brace {\n@@ -2751,7 +2828,7 @@ fn format_generics(\n         result.push('\\n');\n         result.push_str(&offset.block_only().to_string(context.config));\n     }\n-    result.push_str(opener);\n+    result.push('{');\n \n     Some(result)\n }"}, {"sha": "c042d9d795415782ffd6d816f64c9ea4be590ffe", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -10,6 +10,8 @@\n \n #![feature(rustc_private)]\n \n+#[macro_use]\n+extern crate derive_new;\n extern crate diff;\n #[macro_use]\n extern crate log;\n@@ -307,7 +309,7 @@ where\n     // We always skip children for the \"Plain\" write mode, since there is\n     // nothing to distinguish the nested module contents.\n     let skip_children = config.skip_children() || config.write_mode() == config::WriteMode::Plain;\n-    for (path, module) in modules::list_files(krate, parse_session.codemap()) {\n+    for (path, module) in modules::list_files(krate, parse_session.codemap())? {\n         if skip_children && path.as_path() != main_file {\n             continue;\n         }"}, {"sha": "8f5feac474c12f222376f9e2e6703d8c0bac2ccb", "filename": "src/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -35,7 +35,7 @@ use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use utils::mk_sp;\n \n-const FORCED_BRACKET_MACROS: &'static [&'static str] = &[\"vec!\"];\n+const FORCED_BRACKET_MACROS: &[&str] = &[\"vec!\"];\n \n // FIXME: use the enum from libsyntax?\n #[derive(Clone, Copy, PartialEq, Eq)]\n@@ -70,10 +70,10 @@ pub enum MacroArg {\n \n impl Rewrite for MacroArg {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        match self {\n-            &MacroArg::Expr(ref expr) => expr.rewrite(context, shape),\n-            &MacroArg::Ty(ref ty) => ty.rewrite(context, shape),\n-            &MacroArg::Pat(ref pat) => pat.rewrite(context, shape),\n+        match *self {\n+            MacroArg::Expr(ref expr) => expr.rewrite(context, shape),\n+            MacroArg::Ty(ref ty) => ty.rewrite(context, shape),\n+            MacroArg::Pat(ref pat) => pat.rewrite(context, shape),\n         }\n     }\n }"}, {"sha": "d136f2709914a969f7a7c79ce324909869a59ccf", "filename": "src/modules.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -10,6 +10,7 @@\n \n use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n+use std::io;\n \n use syntax::ast;\n use syntax::codemap;\n@@ -23,17 +24,17 @@ use utils::contains_skip;\n pub fn list_files<'a>(\n     krate: &'a ast::Crate,\n     codemap: &codemap::CodeMap,\n-) -> BTreeMap<PathBuf, &'a ast::Mod> {\n+) -> Result<BTreeMap<PathBuf, &'a ast::Mod>, io::Error> {\n     let mut result = BTreeMap::new(); // Enforce file order determinism\n     let root_filename: PathBuf = codemap.span_to_filename(krate.span).into();\n     list_submodules(\n         &krate.module,\n         root_filename.parent().unwrap(),\n         codemap,\n         &mut result,\n-    );\n+    )?;\n     result.insert(root_filename, &krate.module);\n-    result\n+    Ok(result)\n }\n \n /// Recursively list all external modules included in a module.\n@@ -42,7 +43,7 @@ fn list_submodules<'a>(\n     search_dir: &Path,\n     codemap: &codemap::CodeMap,\n     result: &mut BTreeMap<PathBuf, &'a ast::Mod>,\n-) {\n+) -> Result<(), io::Error> {\n     debug!(\"list_submodules: search_dir: {:?}\", search_dir);\n     for item in &module.items {\n         if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n@@ -52,15 +53,16 @@ fn list_submodules<'a>(\n                 let dir_path = if is_internal {\n                     search_dir.join(&item.ident.to_string())\n                 } else {\n-                    let mod_path = module_file(item.ident, &item.attrs, search_dir, codemap);\n+                    let mod_path = module_file(item.ident, &item.attrs, search_dir, codemap)?;\n                     let dir_path = mod_path.parent().unwrap().to_owned();\n                     result.insert(mod_path, sub_mod);\n                     dir_path\n                 };\n-                list_submodules(sub_mod, &dir_path, codemap, result);\n+                list_submodules(sub_mod, &dir_path, codemap, result)?;\n             }\n         }\n     }\n+    Ok(())\n }\n \n /// Find the file corresponding to an external mod\n@@ -69,13 +71,16 @@ fn module_file(\n     attrs: &[ast::Attribute],\n     dir_path: &Path,\n     codemap: &codemap::CodeMap,\n-) -> PathBuf {\n+) -> Result<PathBuf, io::Error> {\n     if let Some(path) = parser::Parser::submod_path_from_attr(attrs, dir_path) {\n-        return path;\n+        return Ok(path);\n     }\n \n     match parser::Parser::default_submod_path(id, dir_path, codemap).result {\n-        Ok(parser::ModulePathSuccess { path, .. }) => path,\n-        Err(_) => panic!(\"Couldn't find module {}\", id),\n+        Ok(parser::ModulePathSuccess { path, .. }) => Ok(path),\n+        Err(_) => Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            format!(\"Couldn't find module {}\", id),\n+        )),\n     }\n }"}, {"sha": "a7e6c48b6d25c408614416d1f711681e3cb719ac", "filename": "src/patterns.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -16,7 +16,7 @@ use spanned::Spanned;\n use codemap::SpanUtils;\n use comment::FindUncommented;\n use expr::{can_be_overflowed_expr, rewrite_call_inner, rewrite_pair, rewrite_unary_prefix,\n-           wrap_struct_field};\n+           wrap_struct_field, PairParts};\n use lists::{itemize_list, shape_for_tactic, struct_lit_formatting, struct_lit_shape,\n             struct_lit_tactic, write_list, DefinitiveListTactic, SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n@@ -65,9 +65,7 @@ impl Rewrite for Pat {\n                 rewrite_pair(\n                     &**lhs,\n                     &**rhs,\n-                    \"\",\n-                    infix,\n-                    \"\",\n+                    PairParts::new(\"\", infix, \"\"),\n                     context,\n                     shape,\n                     SeparatorPlace::Front,"}, {"sha": "59b4ac438b07474d06c53f66bdb498ff2fd67482", "filename": "src/types.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -19,7 +19,7 @@ use syntax::symbol::keywords;\n use spanned::Spanned;\n use codemap::SpanUtils;\n use config::{IndentStyle, Style, TypeDensity};\n-use expr::{rewrite_pair, rewrite_tuple, rewrite_unary_prefix, wrap_args_with_parens};\n+use expr::{rewrite_pair, rewrite_tuple, rewrite_unary_prefix, wrap_args_with_parens, PairParts};\n use items::{format_generics_item_list, generics_shape_from_config};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListTactic, Separator,\n             SeparatorPlace, SeparatorTactic};\n@@ -695,7 +695,7 @@ impl Rewrite for ast::Ty {\n             }\n             ast::TyKind::Tup(ref items) => rewrite_tuple(\n                 context,\n-                &::utils::ptr_vec_to_ref_vec(&items),\n+                &::utils::ptr_vec_to_ref_vec(items),\n                 self.span,\n                 shape,\n             ),\n@@ -709,9 +709,7 @@ impl Rewrite for ast::Ty {\n                 rewrite_pair(\n                     &**ty,\n                     &**repeats,\n-                    lbr,\n-                    \"; \",\n-                    rbr,\n+                    PairParts::new(lbr, \"; \", rbr),\n                     context,\n                     shape,\n                     SeparatorPlace::Back,"}, {"sha": "999ba9f67b9544f4a713e704ef10bd17f4f170b3", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -19,7 +19,7 @@ use rewrite::RewriteContext;\n use shape::Shape;\n \n // When we get scoped annotations, we should have rustfmt::skip.\n-const SKIP_ANNOTATION: &'static str = \"rustfmt_skip\";\n+const SKIP_ANNOTATION: &str = \"rustfmt_skip\";\n \n // Computes the length of a string's last line, minus offset.\n pub fn extra_offset(text: &str, shape: Shape) -> usize {\n@@ -298,7 +298,6 @@ macro_rules! impl_enum_serialize_and_deserialize {\n         impl<'de> ::serde::de::Deserialize<'de> for $e {\n             fn deserialize<D>(d: D) -> Result<Self, D::Error>\n                     where D: ::serde::Deserializer<'de> {\n-                use std::ascii::AsciiExt;\n                 use serde::de::{Error, Visitor};\n                 use std::marker::PhantomData;\n                 use std::fmt;\n@@ -328,7 +327,6 @@ macro_rules! impl_enum_serialize_and_deserialize {\n             type Err = &'static str;\n \n             fn from_str(s: &str) -> Result<Self, Self::Err> {\n-                use std::ascii::AsciiExt;\n                 $(\n                     if stringify!($x).eq_ignore_ascii_case(s) {\n                         return Ok($e::$x);"}, {"sha": "417b12b2d53215686ebdc3cbd484f1c8c3fb269a", "filename": "src/visitor.rs", "status": "modified", "additions": 12, "deletions": 107, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/036917b691556b48397475b800c46507e039706d/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036917b691556b48397475b800c46507e039706d/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=036917b691556b48397475b800c46507e039706d", "patch": "@@ -23,9 +23,8 @@ use comment::{contains_comment, recover_missing_comment_in_span, remove_trailing\n               CodeCharKind, CommentCodeSlices, FindUncommented};\n use comment::rewrite_comment;\n use config::{BraceStyle, Config};\n-use items::{format_impl, format_struct, format_struct_struct, format_trait,\n-            rewrite_associated_impl_type, rewrite_associated_type, rewrite_static,\n-            rewrite_type_alias, FnSig};\n+use items::{format_impl, format_trait, rewrite_associated_impl_type, rewrite_associated_type,\n+            rewrite_type_alias, FnSig, StaticParts, StructParts};\n use lists::{itemize_list, write_list, DefinitiveListTactic, ListFormatting, SeparatorPlace,\n             SeparatorTactic};\n use macros::{rewrite_macro, MacroPosition};\n@@ -197,12 +196,11 @@ impl<'a> FmtVisitor<'a> {\n             }\n         }\n \n-        let mut unindent_comment = self.is_if_else_block && !b.stmts.is_empty();\n-        if unindent_comment {\n+        let unindent_comment = (self.is_if_else_block && !b.stmts.is_empty()) && {\n             let end_pos = source!(self, b.span).hi() - brace_compensation - remove_len;\n             let snippet = self.snippet(mk_sp(self.last_pos, end_pos));\n-            unindent_comment = snippet.contains(\"//\") || snippet.contains(\"/*\");\n-        }\n+            snippet.contains(\"//\") || snippet.contains(\"/*\")\n+        };\n         // FIXME: we should compress any newlines here to just one\n         if unindent_comment {\n             self.block_indent = self.block_indent.block_unindent(self.config);\n@@ -243,24 +241,13 @@ impl<'a> FmtVisitor<'a> {\n         generics: &ast::Generics,\n         fd: &ast::FnDecl,\n         s: Span,\n-        _: ast::NodeId,\n         defaultness: ast::Defaultness,\n         inner_attrs: Option<&[ast::Attribute]>,\n     ) {\n         let indent = self.block_indent;\n         let block;\n         let rewrite = match fk {\n-            visit::FnKind::ItemFn(ident, _, _, _, _, b) => {\n-                block = b;\n-                self.rewrite_fn(\n-                    indent,\n-                    ident,\n-                    &FnSig::from_fn_kind(&fk, generics, fd, defaultness),\n-                    mk_sp(s.lo(), b.span.lo()),\n-                    b,\n-                )\n-            }\n-            visit::FnKind::Method(ident, _, _, b) => {\n+            visit::FnKind::ItemFn(ident, _, _, _, _, b) | visit::FnKind::Method(ident, _, _, b) => {\n                 block = b;\n                 self.rewrite_fn(\n                     indent,\n@@ -357,22 +344,8 @@ impl<'a> FmtVisitor<'a> {\n                 let rw = rewrite_extern_crate(&self.get_context(), item);\n                 self.push_rewrite(item.span, rw);\n             }\n-            ast::ItemKind::Struct(ref def, ref generics) => {\n-                let rewrite = format_struct(\n-                    &self.get_context(),\n-                    \"struct \",\n-                    item.ident,\n-                    &item.vis,\n-                    def,\n-                    Some(generics),\n-                    item.span,\n-                    self.block_indent,\n-                    None,\n-                ).map(|s| match *def {\n-                    ast::VariantData::Tuple(..) => s + \";\",\n-                    _ => s,\n-                });\n-                self.push_rewrite(item.span, rewrite);\n+            ast::ItemKind::Struct(..) | ast::ItemKind::Union(..) => {\n+                self.visit_struct(&StructParts::from_item(item));\n             }\n             ast::ItemKind::Enum(ref def, ref generics) => {\n                 self.format_missing_with_indent(source!(self, item.span).lo());\n@@ -390,33 +363,8 @@ impl<'a> FmtVisitor<'a> {\n                 self.format_missing_with_indent(source!(self, item.span).lo());\n                 self.format_foreign_mod(foreign_mod, item.span);\n             }\n-            ast::ItemKind::Static(ref ty, mutability, ref expr) => {\n-                let rewrite = rewrite_static(\n-                    \"static\",\n-                    &item.vis,\n-                    item.ident,\n-                    ty,\n-                    mutability,\n-                    Some(expr),\n-                    self.block_indent,\n-                    item.span,\n-                    &self.get_context(),\n-                );\n-                self.push_rewrite(item.span, rewrite);\n-            }\n-            ast::ItemKind::Const(ref ty, ref expr) => {\n-                let rewrite = rewrite_static(\n-                    \"const\",\n-                    &item.vis,\n-                    item.ident,\n-                    ty,\n-                    ast::Mutability::Immutable,\n-                    Some(expr),\n-                    self.block_indent,\n-                    item.span,\n-                    &self.get_context(),\n-                );\n-                self.push_rewrite(item.span, rewrite);\n+            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n+                self.visit_static(&StaticParts::from_item(item));\n             }\n             ast::ItemKind::AutoImpl(..) => {\n                 // FIXME(#78): format impl definitions.\n@@ -427,7 +375,6 @@ impl<'a> FmtVisitor<'a> {\n                     generics,\n                     decl,\n                     item.span,\n-                    item.id,\n                     ast::Defaultness::Final,\n                     Some(&item.attrs),\n                 )\n@@ -444,20 +391,6 @@ impl<'a> FmtVisitor<'a> {\n                 );\n                 self.push_rewrite(item.span, rewrite);\n             }\n-            ast::ItemKind::Union(ref def, ref generics) => {\n-                let rewrite = format_struct_struct(\n-                    &self.get_context(),\n-                    \"union \",\n-                    item.ident,\n-                    &item.vis,\n-                    def.fields(),\n-                    Some(generics),\n-                    item.span,\n-                    self.block_indent,\n-                    None,\n-                );\n-                self.push_rewrite(item.span, rewrite);\n-            }\n             ast::ItemKind::GlobalAsm(..) => {\n                 let snippet = Some(self.snippet(item.span));\n                 self.push_rewrite(item.span, snippet);\n@@ -479,20 +412,7 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         match ti.node {\n-            ast::TraitItemKind::Const(ref ty, ref expr_opt) => {\n-                let rewrite = rewrite_static(\n-                    \"const\",\n-                    &ast::Visibility::Inherited,\n-                    ti.ident,\n-                    ty,\n-                    ast::Mutability::Immutable,\n-                    expr_opt.as_ref(),\n-                    self.block_indent,\n-                    ti.span,\n-                    &self.get_context(),\n-                );\n-                self.push_rewrite(ti.span, rewrite);\n-            }\n+            ast::TraitItemKind::Const(..) => self.visit_static(&StaticParts::from_trait_item(ti)),\n             ast::TraitItemKind::Method(ref sig, None) => {\n                 let indent = self.block_indent;\n                 let rewrite =\n@@ -505,7 +425,6 @@ impl<'a> FmtVisitor<'a> {\n                     &ti.generics,\n                     &sig.decl,\n                     ti.span,\n-                    ti.id,\n                     ast::Defaultness::Final,\n                     Some(&ti.attrs),\n                 );\n@@ -541,25 +460,11 @@ impl<'a> FmtVisitor<'a> {\n                     &ii.generics,\n                     &sig.decl,\n                     ii.span,\n-                    ii.id,\n                     ii.defaultness,\n                     Some(&ii.attrs),\n                 );\n             }\n-            ast::ImplItemKind::Const(ref ty, ref expr) => {\n-                let rewrite = rewrite_static(\n-                    \"const\",\n-                    &ii.vis,\n-                    ii.ident,\n-                    ty,\n-                    ast::Mutability::Immutable,\n-                    Some(expr),\n-                    self.block_indent,\n-                    ii.span,\n-                    &self.get_context(),\n-                );\n-                self.push_rewrite(ii.span, rewrite);\n-            }\n+            ast::ImplItemKind::Const(..) => self.visit_static(&StaticParts::from_impl_item(ii)),\n             ast::ImplItemKind::Type(ref ty) => {\n                 let rewrite = rewrite_associated_impl_type(\n                     ii.ident,"}]}