{"sha": "ac888e8675182c703c2cd097957878faf88dad94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjODg4ZTg2NzUxODJjNzAzYzJjZDA5Nzk1Nzg3OGZhZjg4ZGFkOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-07T07:44:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-07T07:44:53Z"}, "message": "Auto merge of #85022 - JohnTitor:rollup-2q4706v, r=JohnTitor\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #84779 (Add support for --test-args to cargotest)\n - #84781 (Don't check bootstrap artifacts by default)\n - #84787 (bump deps)\n - #84815 (Update coverage docs and command line help)\n - #84875 (Removes unneeded check of `#[no_coverage]` in mapgen)\n - #84897 (Coverage instruments closure bodies in macros (not the macro body))\n - #84911 (Retry clang+llvm download)\n - #84972 (CTFE inbounds-error-messages tweak)\n - #84990 (Sort rustdoc-gui tests)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8285c87d06d7609b41fe410ad6900c5ab02f7d61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8285c87d06d7609b41fe410ad6900c5ab02f7d61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac888e8675182c703c2cd097957878faf88dad94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac888e8675182c703c2cd097957878faf88dad94", "html_url": "https://github.com/rust-lang/rust/commit/ac888e8675182c703c2cd097957878faf88dad94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac888e8675182c703c2cd097957878faf88dad94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1773f14a24c49356b384e45ebb45643bc9bef2c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1773f14a24c49356b384e45ebb45643bc9bef2c4", "html_url": "https://github.com/rust-lang/rust/commit/1773f14a24c49356b384e45ebb45643bc9bef2c4"}, {"sha": "87faf2e64f11ed3e1271af890a181b191fbb77a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/87faf2e64f11ed3e1271af890a181b191fbb77a1", "html_url": "https://github.com/rust-lang/rust/commit/87faf2e64f11ed3e1271af890a181b191fbb77a1"}], "stats": {"total": 1159, "additions": 689, "deletions": 470}, "files": [{"sha": "77b917448e9506fc935633bdbaf7b90096ffc4f4", "filename": "Cargo.lock", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -864,24 +864,24 @@ dependencies = [\n \n [[package]]\n name = \"curl\"\n-version = \"0.4.34\"\n+version = \"0.4.36\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e268162af1a5fe89917ae25ba3b0a77c8da752bdc58e7dbb4f15b91fbd33756e\"\n+checksum = \"d0bac9f84ca0977c4d9b8db998689de55b9e976656a6bc87fada2ca710d504c7\"\n dependencies = [\n  \"curl-sys\",\n  \"libc\",\n  \"openssl-probe\",\n  \"openssl-sys\",\n  \"schannel\",\n- \"socket2\",\n+ \"socket2 0.4.0\",\n  \"winapi 0.3.9\",\n ]\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.4.39+curl-7.74.0\"\n+version = \"0.4.42+curl-7.76.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"07a8ce861e7b68a0b394e814d7ee9f1b2750ff8bd10372c6ad3bacc10e86f874\"\n+checksum = \"4636d8d6109c842707018a104051436bffb8991ea20b2d1293db70b6e0ee4c7c\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -2273,7 +2273,7 @@ version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5a33c1b55807fbed163481b5ba66db4b2fa6cde694a5027be10fb724206c5897\"\n dependencies = [\n- \"socket2\",\n+ \"socket2 0.3.16\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -2390,15 +2390,15 @@ dependencies = [\n \n [[package]]\n name = \"openssl\"\n-version = \"0.10.30\"\n+version = \"0.10.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8d575eff3665419f9b83678ff2815858ad9d11567e082f5ac1814baba4e2bcb4\"\n+checksum = \"a61075b62a23fef5a29815de7536d940aa35ce96d18ce0cc5076272db678a577\"\n dependencies = [\n  \"bitflags\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"foreign-types\",\n- \"lazy_static\",\n  \"libc\",\n+ \"once_cell\",\n  \"openssl-sys\",\n ]\n \n@@ -2410,18 +2410,18 @@ checksum = \"77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de\"\n \n [[package]]\n name = \"openssl-src\"\n-version = \"111.12.0+1.1.1h\"\n+version = \"111.15.0+1.1.1k\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"858a4132194f8570a7ee9eb8629e85b23cbc4565f2d4a162e87556e5956abf61\"\n+checksum = \"b1a5f6ae2ac04393b217ea9f700cd04fa9bf3d93fae2872069f3d15d908af70a\"\n dependencies = [\n  \"cc\",\n ]\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.58\"\n+version = \"0.9.61\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a842db4709b604f0fe5d1170ae3565899be2ad3d9cbc72dedc789ac0511f78de\"\n+checksum = \"313752393519e876837e09e1fa183ddef0be7735868dced3196f4472d536277f\"\n dependencies = [\n  \"autocfg\",\n  \"cc\",\n@@ -4863,6 +4863,16 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"socket2\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9e3dfc207c526015c632472a77be09cf1b6e46866581aecae5cc38fb4235dea2\"\n+dependencies = [\n+ \"libc\",\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"stable_deref_trait\"\n version = \"1.2.0\""}, {"sha": "30f125ca3beaed6a90b907e121f583c792951f11", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -8,7 +8,6 @@ use rustc_codegen_ssa::traits::{ConstMethods, CoverageInfoMethods};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n use rustc_llvm::RustString;\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::coverage::CodeRegion;\n use rustc_span::Symbol;\n \n@@ -249,7 +248,7 @@ fn save_function_record(\n ///\n /// We can find the unused functions (including generic functions) by the set difference of all MIR\n /// `DefId`s (`tcx` query `mir_keys`) minus the codegenned `DefId`s (`tcx` query\n-/// `collect_and_partition_mono_items`).\n+/// `codegened_and_inlined_items`).\n ///\n /// *HOWEVER* the codegenned `DefId`s are partitioned across multiple `CodegenUnit`s (CGUs), and\n /// this function is processing a `function_coverage_map` for the functions (`Instance`/`DefId`)\n@@ -281,11 +280,8 @@ fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n \n     let mut unused_def_ids_by_file: FxHashMap<Symbol, Vec<DefId>> = FxHashMap::default();\n     for &non_codegenned_def_id in all_def_ids.difference(codegenned_def_ids) {\n-        let codegen_fn_attrs = tcx.codegen_fn_attrs(non_codegenned_def_id);\n-        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_COVERAGE) {\n-            continue;\n-        }\n-        // Make sure the non-codegenned (unused) function has a file_name\n+        // Make sure the non-codegenned (unused) function has at least one MIR\n+        // `Coverage` statement with a code region, and return its file name.\n         if let Some(non_codegenned_file_name) = tcx.covered_file_name(non_codegenned_def_id) {\n             let def_ids =\n                 unused_def_ids_by_file.entry(*non_codegenned_file_name).or_insert_with(Vec::new);"}, {"sha": "ea582d470f906c4fe814ce392196be6905176fe4", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -306,6 +306,9 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n                 ptr.alloc_id,\n                 allocation_size.bytes()\n             ),\n+            DanglingIntPointer(_, CheckInAllocMsg::InboundsTest) => {\n+                write!(f, \"null pointer is not allowed for this operation\")\n+            }\n             DanglingIntPointer(i, msg) => {\n                 write!(f, \"{} failed: 0x{:x} is not a valid pointer\", msg, i)\n             }"}, {"sha": "69ab50fa86ede291ca440996b60dc85869a79e28", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -526,7 +526,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             min_ptr,\n             Size::from_bytes(size),\n             None,\n-            CheckInAllocMsg::InboundsTest,\n+            CheckInAllocMsg::PointerArithmeticTest,\n         )?;\n         Ok(offset_ptr)\n     }"}, {"sha": "52baf1a63305748e130813c822fed9ad3ad4254d", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -369,6 +369,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n         Err((if int == 0 {\n             // This is UB, seriously.\n+            // (`DanglingIntPointer` with these exact arguments has special printing code.)\n             err_ub!(DanglingIntPointer(0, CheckInAllocMsg::InboundsTest))\n         } else {\n             // This is just something we cannot support during const-eval."}, {"sha": "6e6e64d25ac38cb50c2efddc2cd3d0d9442d900c", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -330,7 +330,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                         vtable,\n                         3 * self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n                         Some(self.ecx.tcx.data_layout.pointer_align.abi),\n-                        CheckInAllocMsg::InboundsTest,\n+                        CheckInAllocMsg::InboundsTest, // will anyway be replaced by validity message\n                     ),\n                     self.path,\n                     err_ub!(DanglingIntPointer(..)) |\n@@ -416,7 +416,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 place.ptr,\n                 size,\n                 Some(align),\n-                CheckInAllocMsg::InboundsTest,\n+                CheckInAllocMsg::InboundsTest, // will anyway be replaced by validity message\n             ),\n             self.path,\n             err_ub!(AlignmentCheckFailed { required, has }) =>"}, {"sha": "c1e8f620b30c1dda7283b18eacc412256731bf79", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -32,7 +32,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::DefId;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::{CharPos, Pos, SourceFile, Span, Symbol};\n+use rustc_span::{CharPos, ExpnKind, Pos, SourceFile, Span, Symbol};\n \n /// A simple error message wrapper for `coverage::Error`s.\n #[derive(Debug)]\n@@ -113,8 +113,29 @@ struct Instrumentor<'a, 'tcx> {\n impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     fn new(pass_name: &'a str, tcx: TyCtxt<'tcx>, mir_body: &'a mut mir::Body<'tcx>) -> Self {\n         let source_map = tcx.sess.source_map();\n-        let (some_fn_sig, hir_body) = fn_sig_and_body(tcx, mir_body.source.def_id());\n-        let body_span = hir_body.value.span;\n+        let def_id = mir_body.source.def_id();\n+        let (some_fn_sig, hir_body) = fn_sig_and_body(tcx, def_id);\n+\n+        let mut body_span = hir_body.value.span;\n+\n+        if tcx.is_closure(def_id) {\n+            // If the MIR function is a closure, and if the closure body span\n+            // starts from a macro, but it's content is not in that macro, try\n+            // to find a non-macro callsite, and instrument the spans there\n+            // instead.\n+            loop {\n+                let expn_data = body_span.ctxt().outer_expn_data();\n+                if expn_data.is_root() {\n+                    break;\n+                }\n+                if let ExpnKind::Macro(..) = expn_data.kind {\n+                    body_span = expn_data.call_site;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n         let source_file = source_map.lookup_source_file(body_span.lo());\n         let fn_sig_span = match some_fn_sig.filter(|fn_sig| {\n             fn_sig.span.ctxt() == body_span.ctxt()"}, {"sha": "a59f0462c73114fd40b5010ed474c9f714621a3d", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -1080,12 +1080,12 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"gather statistics about the input (default: no)\"),\n     instrument_coverage: Option<InstrumentCoverage> = (None, parse_instrument_coverage, [TRACKED],\n         \"instrument the generated code to support LLVM source-based code coverage \\\n-        reports (note, the compiler build config must include `profiler = true`, \\\n-        and is mutually exclusive with `-C profile-generate`/`-C profile-use`); \\\n-        implies `-Z symbol-mangling-version=v0`; disables/overrides some Rust \\\n-        optimizations. Optional values are: `=all` (default coverage), \\\n-        `=except-unused-generics`, `=except-unused-functions`, or `=off` \\\n-        (default: instrument-coverage=off)\"),\n+        reports (note, the compiler build config must include `profiler = true`); \\\n+        implies `-Z symbol-mangling-version=v0`. Optional values are:\n+        `=all` (implicit value)\n+        `=except-unused-generics`\n+        `=except-unused-functions`\n+        `=off` (default)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "8561a2a39b8ea727b412ac923a80be361a75575c", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -280,7 +280,7 @@ impl Step for CodegenBackend {\n }\n \n macro_rules! tool_check_step {\n-    ($name:ident, $path:literal, $($alias:literal, )* $source_type:path) => {\n+    ($name:ident, $path:literal, $($alias:literal, )* $source_type:path $(, $default:literal )?) => {\n         #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n         pub struct $name {\n             pub target: TargetSelection,\n@@ -289,7 +289,7 @@ macro_rules! tool_check_step {\n         impl Step for $name {\n             type Output = ();\n             const ONLY_HOSTS: bool = true;\n-            const DEFAULT: bool = true;\n+            const DEFAULT: bool = true $( && $default )?;\n \n             fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 run.paths(&[ $path, $($alias),* ])\n@@ -368,7 +368,7 @@ tool_check_step!(Rustdoc, \"src/tools/rustdoc\", \"src/librustdoc\", SourceType::InT\n // rejected.\n tool_check_step!(Clippy, \"src/tools/clippy\", SourceType::InTree);\n \n-tool_check_step!(Bootstrap, \"src/bootstrap\", SourceType::InTree);\n+tool_check_step!(Bootstrap, \"src/bootstrap\", SourceType::InTree, false);\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target."}, {"sha": "c98398cf1d251566ebd0ba5c96e876e627b986c6", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -183,6 +183,7 @@ impl Step for Cargotest {\n             builder,\n             cmd.arg(&cargo)\n                 .arg(&out_dir)\n+                .args(builder.config.cmd.test_args())\n                 .env(\"RUSTC\", builder.rustc(compiler))\n                 .env(\"RUSTDOC\", builder.rustdoc(compiler)),\n         );\n@@ -830,6 +831,7 @@ impl Step for RustdocGUI {\n             command.arg(\"src/test/rustdoc-gui/lib.rs\").arg(\"-o\").arg(&out_dir);\n             builder.run(&mut command);\n \n+            let mut tests = Vec::new();\n             for file in fs::read_dir(\"src/test/rustdoc-gui\").unwrap() {\n                 let file = file.unwrap();\n                 let file_path = file.path();\n@@ -838,13 +840,17 @@ impl Step for RustdocGUI {\n                 if !file_name.to_str().unwrap().ends_with(\".goml\") {\n                     continue;\n                 }\n+                tests.push(file_path);\n+            }\n+            tests.sort_unstable();\n+            for test in tests {\n                 let mut command = Command::new(&nodejs);\n                 command\n                     .arg(\"src/tools/rustdoc-gui/tester.js\")\n                     .arg(\"--doc-folder\")\n                     .arg(out_dir.join(\"test_docs\"))\n                     .arg(\"--test-file\")\n-                    .arg(file_path);\n+                    .arg(test);\n                 builder.run(&mut command);\n             }\n         } else {"}, {"sha": "7b540b5c6e99dd2bc0f274df220bef1fb13f983a", "filename": "src/ci/scripts/install-clang.sh", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Fci%2Fscripts%2Finstall-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Fci%2Fscripts%2Finstall-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-clang.sh?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -18,7 +18,8 @@ if isMacOS; then\n         bindir=\"$(xcode-select --print-path)/Toolchains/XcodeDefault.xctoolchain/usr/bin\"\n     else\n         file=\"${MIRRORS_BASE}/clang%2Bllvm-${LLVM_VERSION}-x86_64-apple-darwin.tar.xz\"\n-        curl -f \"${file}\" | tar xJf -\n+        retry curl -f \"${file}\" -o \"clang+llvm-${LLVM_VERSION}-x86_64-apple-darwin.tar.xz\"\n+        tar xJf \"clang+llvm-${LLVM_VERSION}-x86_64-apple-darwin.tar.xz\"\n         bindir=\"$(pwd)/clang+llvm-${LLVM_VERSION}-x86_64-apple-darwin/bin\"\n     fi\n \n@@ -48,7 +49,8 @@ elif isWindows && [[ ${CUSTOM_MINGW-0} -ne 1 ]]; then\n \n     mkdir -p citools/clang-rust\n     cd citools\n-    curl -f \"${MIRRORS_BASE}/LLVM-${LLVM_VERSION}-win64.exe\" -o \"LLVM-${LLVM_VERSION}-win64.exe\"\n+    retry curl -f \"${MIRRORS_BASE}/LLVM-${LLVM_VERSION}-win64.exe\" \\\n+        -o \"LLVM-${LLVM_VERSION}-win64.exe\"\n     7z x -oclang-rust/ \"LLVM-${LLVM_VERSION}-win64.exe\"\n     ciCommandSetEnv RUST_CONFIGURE_ARGS \\\n         \"${RUST_CONFIGURE_ARGS} --set llvm.clang-cl=$(pwd)/clang-rust/bin/clang-cl.exe\""}, {"sha": "f7c2a26f01817016048f95d961878a64eb50effa", "filename": "src/doc/unstable-book/src/compiler-flags/instrument-coverage.md", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -0,0 +1,346 @@\n+# `instrument-coverage`\n+\n+The tracking issue for this feature is: [#79121].\n+\n+[#79121]: https://github.com/rust-lang/rust/issues/79121\n+\n+---\n+\n+## Introduction\n+\n+The Rust compiler includes two code coverage implementations:\n+\n+-   A GCC-compatible, gcov-based coverage implementation, enabled with `-Z profile`, which derives coverage data based on DebugInfo.\n+-   A source-based code coverage implementation, enabled with `-Z instrument-coverage`, which uses LLVM's native, efficient coverage instrumentation to generate very precise coverage data.\n+\n+This document describes how to enable and use the LLVM instrumentation-based coverage, via the `-Z instrument-coverage` compiler flag.\n+\n+## How it works\n+\n+When `-Z instrument-coverage` is enabled, the Rust compiler enhances rust-based libraries and binaries by:\n+\n+-   Automatically injecting calls to an LLVM intrinsic ([`llvm.instrprof.increment`]), at functions and branches in compiled code, to increment counters when conditional sections of code are executed.\n+-   Embedding additional information in the data section of each library and binary (using the [LLVM Code Coverage Mapping Format] _Version 4_, supported _only_ in LLVM 11 and up), to define the code regions (start and end positions in the source code) being counted.\n+\n+When running a coverage-instrumented program, the counter values are written to a `profraw` file at program termination. LLVM bundles tools that read the counter results, combine those results with the coverage map (embedded in the program binary), and generate coverage reports in multiple formats.\n+\n+[`llvm.instrprof.increment`]: https://llvm.org/docs/LangRef.html#llvm-instrprof-increment-intrinsic\n+[llvm code coverage mapping format]: https://llvm.org/docs/CoverageMappingFormat.html\n+\n+> **Note**: `-Z instrument-coverage` also automatically enables `-Z symbol-mangling-version=v0` (tracking issue [#60705]). The `v0` symbol mangler is strongly recommended, but be aware that this demangler is also experimental. The `v0` demangler can be overridden by explicitly adding `-Z symbol-mangling-version=legacy`.\n+\n+[#60705]: https://github.com/rust-lang/rust/issues/60705\n+\n+## Enable coverage profiling in the Rust compiler\n+\n+Rust's source-based code coverage requires the Rust \"profiler runtime\". Without it, compiling with `-Z instrument-coverage` generates an error that the profiler runtime is missing.\n+\n+The Rust `nightly` distribution channel includes the profiler runtime, by default.\n+\n+> **Important**: If you are building the Rust compiler from the source distribution, the profiler runtime is _not_ enabled in the default `config.toml.example`. Edit your `config.toml` file and ensure the `profiler` feature is set it to `true` (either under the `[build]` section, or under the settings for an individual `[target.<triple>]`):\n+>\n+> ```toml\n+> # Build the profiler runtime (required when compiling with options that depend\n+> # on this runtime, such as `-C profile-generate` or `-Z  instrument-coverage`).\n+> profiler = true\n+> ```\n+\n+### Building the demangler\n+\n+LLVM coverage reporting tools generate results that can include function names and other symbol references, and the raw coverage results report symbols using the compiler's \"mangled\" version of the symbol names, which can be difficult to interpret. To work around this issue, LLVM coverage tools also support a user-specified symbol name demangler.\n+\n+One option for a Rust demangler is [`rustfilt`], which can be installed with:\n+\n+```shell\n+cargo install rustfilt\n+```\n+\n+Another option, if you are building from the Rust compiler source distribution, is to use the `rust-demangler` tool included in the Rust source distribution, which can be built with:\n+\n+```shell\n+$ ./x.py build rust-demangler\n+```\n+\n+[`rustfilt`]: https://crates.io/crates/rustfilt\n+\n+## Compiling with coverage enabled\n+\n+Set the `-Z instrument-coverage` compiler flag in order to enable LLVM source-based code coverage profiling.\n+\n+The default option generates coverage for all functions, including unused (never called) functions and generics. The compiler flag supports an optional value to tailor this behavior. (See [`-Z instrument-coverage=<options>`](#-z-instrument-coverageoptions), below.)\n+\n+With `cargo`, you can instrument your program binary _and_ dependencies at the same time.\n+\n+For example (if your project's Cargo.toml builds a binary by default):\n+\n+```shell\n+$ cd your-project\n+$ cargo clean\n+$ RUSTFLAGS=\"-Z instrument-coverage\" cargo build\n+```\n+\n+If `cargo` is not configured to use your `profiler`-enabled version of `rustc`, set the path explicitly via the `RUSTC` environment variable. Here is another example, using a `stage1` build of `rustc` to compile an `example` binary (from the [`json5format`] crate):\n+\n+```shell\n+$ RUSTC=$HOME/rust/build/x86_64-unknown-linux-gnu/stage1/bin/rustc \\\n+    RUSTFLAGS=\"-Z instrument-coverage\" \\\n+    cargo build --example formatjson5\n+```\n+\n+> **Note**: that some compiler options, combined with `-Z instrument-coverage`, can produce LLVM IR and/or linked binaries that are incompatible with LLVM coverage maps. For example, coverage requires references to actual functions in LLVM IR. If any covered function is optimized out, the coverage tools may not be able to process the coverage results. If you need to pass additional options, with coverage enabled, test them early, to confirm you will get the coverage results you expect.\n+\n+## Running the instrumented binary to generate raw coverage profiling data\n+\n+In the previous example, `cargo` generated the coverage-instrumented binary `formatjson5`:\n+\n+```shell\n+$ echo \"{some: 'thing'}\" | target/debug/examples/formatjson5 -\n+```\n+\n+```json5\n+{\n+    some: \"thing\",\n+}\n+```\n+\n+After running this program, a new file, `default.profraw`, should be in the current working directory. It's often preferable to set a specific file name or path. You can change the output file using the environment variable `LLVM_PROFILE_FILE`:\n+\n+```shell\n+$ echo \"{some: 'thing'}\" \\\n+    | LLVM_PROFILE_FILE=\"formatjson5.profraw\" target/debug/examples/formatjson5 -\n+...\n+$ ls formatjson5.profraw\n+formatjson5.profraw\n+```\n+\n+If `LLVM_PROFILE_FILE` contains a path to a non-existent directory, the missing directory structure will be created. Additionally, the following special pattern strings are rewritten:\n+\n+-   `%p` - The process ID.\n+-   `%h` - The hostname of the machine running the program.\n+-   `%t` - The value of the TMPDIR environment variable.\n+-   `%Nm` - the instrumented binary\u2019s signature: The runtime creates a pool of N raw profiles, used for on-line profile merging. The runtime takes care of selecting a raw profile from the pool, locking it, and updating it before the program exits. `N` must be between `1` and `9`, and defaults to `1` if omitted (with simply `%m`).\n+-   `%c` - Does not add anything to the filename, but enables a mode (on some platforms, including Darwin) in which profile counter updates are continuously synced to a file. This means that if the instrumented program crashes, or is killed by a signal, perfect coverage information can still be recovered.\n+\n+## Installing LLVM coverage tools\n+\n+LLVM's supplies two tools\u2014`llvm-profdata` and `llvm-cov`\u2014that process coverage data and generate reports. There are several ways to find and/or install these tools, but note that the coverage mapping data generated by the Rust compiler requires LLVM version 11 or higher. (`llvm-cov --version` typically shows the tool's LLVM version number.):\n+\n+-   The LLVM tools may be installed (or installable) directly to your OS (such as via `apt-get`, for Linux).\n+-   If you are building the Rust compiler from source, you can optionally use the bundled LLVM tools, built from source. Those tool binaries can typically be found in your build platform directory at something like: `rust/build/x86_64-unknown-linux-gnu/llvm/bin/llvm-*`.\n+-   You can install compatible versions of these tools via `rustup`.\n+\n+The `rustup` option is guaranteed to install a compatible version of the LLVM tools, but they can be hard to find. We recommend [`cargo-binutils`], which installs Rust-specific wrappers around these and other LLVM tools, so you can invoke them via `cargo` commands!\n+\n+```shell\n+$ rustup component add llvm-tools-preview\n+$ cargo install cargo-binutils\n+$ cargo profdata -- --help  # note the additional \"--\" preceding the tool-specific arguments\n+```\n+\n+[`cargo-binutils`]: https://crates.io/crates/cargo-binutils\n+\n+## Creating coverage reports\n+\n+Raw profiles have to be indexed before they can be used to generate coverage reports. This is done using [`llvm-profdata merge`] (or `cargo profdata -- merge`), which can combine multiple raw profiles and index them at the same time:\n+\n+```shell\n+$ llvm-profdata merge -sparse formatjson5.profraw -o formatjson5.profdata\n+```\n+\n+Finally, the `.profdata` file is used, in combination with the coverage map (from the program binary) to generate coverage reports using [`llvm-cov report`] (or `cargo cov -- report`), for a coverage summaries; and [`llvm-cov show`] (or `cargo cov -- show`), to see detailed coverage of lines and regions (character ranges) overlaid on the original source code.\n+\n+These commands have several display and filtering options. For example:\n+\n+```shell\n+$ llvm-cov show -Xdemangler=rustfilt target/debug/examples/formatjson5 \\\n+    -instr-profile=formatjson5.profdata \\\n+    -show-line-counts-or-regions \\\n+    -show-instantiations \\\n+    -name=add_quoted_string\n+```\n+\n+<img alt=\"Screenshot of sample `llvm-cov show` result, for function add_quoted_string\" src=\"img/llvm-cov-show-01.png\" class=\"center\"/>\n+<br/>\n+<br/>\n+\n+Some of the more notable options in this example include:\n+\n+-   `--Xdemangler=rustfilt` - the command name or path used to demangle Rust symbols (`rustfilt` in the example, but this could also be a path to the `rust-demangler` tool)\n+-   `target/debug/examples/formatjson5` - the instrumented binary (from which to extract the coverage map)\n+-   `--instr-profile=<path-to-file>.profdata` - the location of the `.profdata` file created by `llvm-profdata merge` (from the `.profraw` file generated by the instrumented binary)\n+-   `--name=<exact-function-name>` - to show coverage for a specific function (or, consider using another filter option, such as `--name-regex=<pattern>`)\n+\n+[`llvm-profdata merge`]: https://llvm.org/docs/CommandGuide/llvm-profdata.html#profdata-merge\n+[`llvm-cov report`]: https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-report\n+[`llvm-cov show`]: https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-show\n+\n+> **Note**: Coverage can also be disabled on an individual function by annotating the function with the [`no_coverage` attribute] (which requires the feature flag `#![feature(no_coverage)]`).\n+\n+[`no_coverage` attribute]: ../language-features/no-coverage.md\n+\n+## Interpreting reports\n+\n+There are four statistics tracked in a coverage summary:\n+\n+-   Function coverage is the percentage of functions that have been executed at least once. A function is considered to be executed if any of its instantiations are executed.\n+-   Instantiation coverage is the percentage of function instantiations that have been executed at least once. Generic functions and functions generated from macros are two kinds of functions that may have multiple instantiations.\n+-   Line coverage is the percentage of code lines that have been executed at least once. Only executable lines within function bodies are considered to be code lines.\n+-   Region coverage is the percentage of code regions that have been executed at least once. A code region may span multiple lines: for example, in a large function body with no control flow. In other cases, a single line can contain multiple code regions: `return x || (y && z)` has countable code regions for `x` (which may resolve the expression, if `x` is `true`), `|| (y && z)` (executed only if `x` was `false`), and `return` (executed in either situation).\n+\n+Of these four statistics, function coverage is usually the least granular while region coverage is the most granular. The project-wide totals for each statistic are listed in the summary.\n+\n+## Test coverage\n+\n+A typical use case for coverage analysis is test coverage. Rust's source-based coverage tools can both measure your tests' code coverage as percentage, and pinpoint functions and branches not tested.\n+\n+The following example (using the [`json5format`] crate, for demonstration purposes) show how to generate and analyze coverage results for all tests in a crate.\n+\n+Since `cargo test` both builds and runs the tests, we set both the additional `RUSTFLAGS`, to add the `-Z instrument-coverage` flag, and `LLVM_PROFILE_FILE`, to set a custom filename for the raw profiling data generated during the test runs. Since there may be more than one test binary, apply `%m` in the filename pattern. This generates unique names for each test binary. (Otherwise, each executed test binary would overwrite the coverage results from the previous binary.)\n+\n+```shell\n+$ RUSTFLAGS=\"-Z instrument-coverage\" \\\n+    LLVM_PROFILE_FILE=\"json5format-%m.profraw\" \\\n+    cargo test --tests\n+```\n+\n+Make note of the test binary file paths, displayed after the word \"`Running`\" in the test output:\n+\n+```text\n+   ...\n+   Compiling json5format v0.1.3 ($HOME/json5format)\n+    Finished test [unoptimized + debuginfo] target(s) in 14.60s\n+\n+     Running target/debug/deps/json5format-fececd4653271682\n+running 25 tests\n+...\n+test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+\n+     Running target/debug/deps/lib-30768f9c53506dc5\n+running 31 tests\n+...\n+test result: ok. 31 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+```\n+\n+You should have one or more `.profraw` files now, one for each test binary. Run the `profdata` tool to merge them:\n+\n+```shell\n+$ cargo profdata -- merge \\\n+    -sparse json5format-*.profraw -o json5format.profdata\n+```\n+\n+Then run the `cov` tool, with the `profdata` file and all test binaries:\n+\n+```shell\n+$ cargo cov -- report \\\n+    --use-color --ignore-filename-regex='/.cargo/registry' \\\n+    --instr-profile=json5format.profdata \\\n+    --object target/debug/deps/lib-30768f9c53506dc5 \\\n+    --object target/debug/deps/json5format-fececd4653271682\n+$ cargo cov -- show \\\n+    --use-color --ignore-filename-regex='/.cargo/registry' \\\n+    --instr-profile=json5format.profdata \\\n+    --object target/debug/deps/lib-30768f9c53506dc5 \\\n+    --object target/debug/deps/json5format-fececd4653271682 \\\n+    --show-instantiations --show-line-counts-or-regions \\\n+    --Xdemangler=rustfilt | less -R\n+```\n+\n+> **Note**: The command line option `--ignore-filename-regex=/.cargo/registry`, which excludes the sources for dependencies from the coverage results.\\_\n+\n+### Tips for listing the binaries automatically\n+\n+For `bash` users, one suggested way to automatically complete the `cov` command with the list of binaries is with a command like:\n+\n+```bash\n+$ cargo cov -- report \\\n+    $( \\\n+      for file in \\\n+        $( \\\n+          RUSTFLAGS=\"-Z instrument-coverage\" \\\n+            cargo test --tests --no-run --message-format=json \\\n+              | jq -r \"select(.profile.test == true) | .filenames[]\" \\\n+              | grep -v dSYM - \\\n+        ); \\\n+      do \\\n+        printf \"%s %s \" -object $file; \\\n+      done \\\n+    ) \\\n+  --instr-profile=json5format.profdata --summary-only # and/or other options\n+```\n+\n+Adding `--no-run --message-format=json` to the _same_ `cargo test` command used to run\n+the tests (including the same environment variables and flags) generates output in a JSON\n+format that `jq` can easily query.\n+\n+The `printf` command takes this list and generates the `--object <binary>` arguments\n+for each listed test binary.\n+\n+### Including doc tests\n+\n+The previous examples run `cargo test` with `--tests`, which excludes doc tests.[^79417]\n+\n+To include doc tests in the coverage results, drop the `--tests` flag, and apply the\n+`-Z instrument-coverage` flag, and some doc-test-specific options in the\n+`RUSTDOCFLAGS` environment variable. (The `cargo profdata` command does not change.)\n+\n+```bash\n+$ RUSTFLAGS=\"-Z instrument-coverage\" \\\n+  RUSTDOCFLAGS=\"-Z instrument-coverage -Z unstable-options --persist-doctests target/debug/doctestbins\" \\\n+  LLVM_PROFILE_FILE=\"json5format-%m.profraw\" \\\n+    cargo test\n+$ cargo profdata -- merge \\\n+    -sparse json5format-*.profraw -o json5format.profdata\n+```\n+\n+The `-Z unstable-options --persist-doctests` flag is required, to save the test binaries\n+(with their coverage maps) for `llvm-cov`.\n+\n+```bash\n+$ cargo cov -- report \\\n+    $( \\\n+      for file in \\\n+        $( \\\n+          RUSTFLAGS=\"-Z instrument-coverage\" \\\n+          RUSTDOCFLAGS=\"-Z instrument-coverage -Z unstable-options --persist-doctests target/debug/doctestbins\" \\\n+            cargo test --no-run --message-format=json \\\n+              | jq -r \"select(.profile.test == true) | .filenames[]\" \\\n+              | grep -v dSYM - \\\n+        ) \\\n+        target/debug/doctestbins/*/rust_out; \\\n+      do \\\n+        [[ -x $file ]] && printf \"%s %s \" -object $file; \\\n+      done \\\n+    ) \\\n+  --instr-profile=json5format.profdata --summary-only # and/or other options\n+```\n+\n+> **Note**: The differences in this `cargo cov` command, compared with the version without\n+> doc tests, include:\n+\n+-   The `cargo test ... --no-run` command is updated with the same environment variables\n+    and flags used to _build_ the tests, _including_ the doc tests. (`LLVM_PROFILE_FILE`\n+    is only used when _running_ the tests.)\n+-   The file glob pattern `target/debug/doctestbins/*/rust_out` adds the `rust_out`\n+    binaries generated for doc tests (note, however, that some `rust_out` files may not\n+    be executable binaries).\n+-   `[[ -x $file ]] &&` filters the files passed on to the `printf`, to include only\n+    executable binaries.\n+\n+[^79417]:\n+    There is ongoing work to resolve a known issue\n+    [(#79417)](https://github.com/rust-lang/rust/issues/79417) that doc test coverage\n+    generates incorrect source line numbers in `llvm-cov show` results.\n+\n+## `-Z instrument-coverage=<options>`\n+\n+-   `-Z instrument-coverage=all`: Instrument all functions, including unused functions and unused generics. (This is the same as `-Z instrument-coverage`, with no value.)\n+-   `-Z instrument-coverage=except-unused-generics`: Instrument all functions except unused generics.\n+-   `-Z instrument-coverage=except-unused-functions`: Instrument only used (called) functions and instantiated generic functions.\n+-   `-Z instrument-coverage=off`: Do not instrument any functions. (This is the same as simply not including the `-Z instrument-coverage` option.)\n+\n+## Other references\n+\n+Rust's implementation and workflow for source-based code coverage is based on the same library and tools used to implement [source-based code coverage in Clang]. (This document is partially based on the Clang guide.)\n+\n+[source-based code coverage in clang]: https://clang.llvm.org/docs/SourceBasedCodeCoverage.html\n+[`json5format`]: https://crates.io/crates/json5format"}, {"sha": "cb65978e0a07e6dd6a27a2b54d6cf985be4911fd", "filename": "src/doc/unstable-book/src/compiler-flags/source-based-code-coverage.md", "status": "modified", "additions": 2, "deletions": 324, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -1,327 +1,5 @@\n # `source-based-code-coverage`\n \n-The tracking issue for this feature is: [#79121].\n+See compiler flag [`-Z instrument-coverage`].\n \n-------------------------\n-\n-## Introduction\n-\n-The Rust compiler includes two code coverage implementations:\n-\n-* A GCC-compatible, gcov-based coverage implementation, enabled with [`-Zprofile`], which operates on DebugInfo.\n-* A source-based code coverage implementation, enabled with `-Zinstrument-coverage`, which uses LLVM's native coverage instrumentation to generate very precise coverage data.\n-\n-This document describes how to enable and use the LLVM instrumentation-based coverage, via the `-Zinstrument-coverage` compiler flag.\n-\n-## How it works\n-\n-When `-Zinstrument-coverage` is enabled, the Rust compiler enhances rust-based libraries and binaries by:\n-\n-* Automatically injecting calls to an LLVM intrinsic ([`llvm.instrprof.increment`]), at functions and branches in compiled code, to increment counters when conditional sections of code are executed.\n-* Embedding additional information in the data section of each library and binary (using the [LLVM Code Coverage Mapping Format] _Version 4_, supported _only_ in LLVM 11 and up), to define the code regions (start and end positions in the source code) being counted.\n-\n-When running a coverage-instrumented program, the counter values are written to a `profraw` file at program termination. LLVM bundles tools that read the counter results, combine those results with the coverage map (embedded in the program binary), and generate coverage reports in multiple formats.\n-\n-## Enable coverage profiling in the Rust compiler\n-\n-Rust's source-based code coverage requires the Rust \"profiler runtime\". Without it, compiling with `-Zinstrument-coverage` generates an error that the profiler runtime is missing.\n-\n-The Rust `nightly` distribution channel should include the profiler runtime, by default.\n-\n-*IMPORTANT:* If you are building the Rust compiler from the source distribution, the profiler runtime is *not* enabled in the default `config.toml.example`. Edit your `config.toml` file and ensure the `profiler` feature is set it to `true`:\n-\n-```toml\n-# Build the profiler runtime (required when compiling with options that depend\n-# on this runtime, such as `-C profile-generate` or `-Z instrument-coverage`).\n-profiler = true\n-```\n-\n-If changed, rebuild the Rust compiler (see [rustc-dev-guide-how-to-build-and-run]).\n-\n-### Building the demangler\n-\n-LLVM coverage reporting tools generate results that can include function names and other symbol references, and the raw coverage results report symbols using the compiler's \"mangled\" version of the symbol names, which can be difficult to interpret. To work around this issue, LLVM coverage tools also support a user-specified symbol name demangler.\n-\n-One option for a Rust demangler is [`rustfilt`], which can be installed with:\n-\n-```shell\n-cargo install rustfilt\n-```\n-\n-Another option, if you are building from the Rust compiler source distribution, is to use the `rust-demangler` tool included in the Rust source distribution, which can be built with:\n-\n-```shell\n-$ ./x.py build rust-demangler\n-```\n-\n-## Compiling with coverage enabled\n-\n-Set the `-Zinstrument-coverage` compiler flag in order to enable LLVM source-based code coverage profiling.\n-\n-With `cargo`, you can instrument your program binary *and* dependencies at the same time.\n-\n-For example (if your project's Cargo.toml builds a binary by default):\n-\n-```shell\n-$ cd your-project\n-$ cargo clean\n-$ RUSTFLAGS=\"-Zinstrument-coverage\" cargo build\n-```\n-\n-If `cargo` is not configured to use your `profiler`-enabled version of `rustc`, set the path explicitly via the `RUSTC` environment variable. Here is another example, using a `stage1` build of `rustc` to compile an `example` binary (from the [`json5format`] crate):\n-\n-```shell\n-$ RUSTC=$HOME/rust/build/x86_64-unknown-linux-gnu/stage1/bin/rustc \\\n-    RUSTFLAGS=\"-Zinstrument-coverage\" \\\n-    cargo build --example formatjson5\n-```\n-\n-Note that some compiler options, combined with `-Zinstrument-coverage`, can produce LLVM IR and/or linked binaries that are incompatible with LLVM coverage maps. For example, coverage requires references to actual functions in LLVM IR. If any covered function is optimized out, the coverage tools may not be able to process the coverage results. If you need to pass additional options, with coverage enabled, test them early, to confirm you will get the coverage results you expect.\n-\n-## Running the instrumented binary to generate raw coverage profiling data\n-\n-In the previous example, `cargo` generated the coverage-instrumented binary `formatjson5`:\n-\n-```shell\n-$ echo \"{some: 'thing'}\" | target/debug/examples/formatjson5 -\n-```\n-```json5\n-{\n-    some: 'thing',\n-}\n-```\n-\n-After running this program, a new file, `default.profraw`, should be in the current working directory. It's often preferable to set a specific file name or path. You can change the output file using the environment variable `LLVM_PROFILE_FILE`:\n-\n-\n-```shell\n-$ echo \"{some: 'thing'}\" \\\n-    | LLVM_PROFILE_FILE=\"formatjson5.profraw\" target/debug/examples/formatjson5 -\n-...\n-$ ls formatjson5.profraw\n-formatjson5.profraw\n-```\n-\n-If `LLVM_PROFILE_FILE` contains a path to a non-existent directory, the missing directory structure will be created. Additionally, the following special pattern strings are rewritten:\n-\n-* `%p` - The process ID.\n-* `%h` - The hostname of the machine running the program.\n-* `%t` - The value of the TMPDIR environment variable.\n-* `%Nm` - the instrumented binary\u2019s signature: The runtime creates a pool of N raw profiles, used for on-line profile merging. The runtime takes care of selecting a raw profile from the pool, locking it, and updating it before the program exits. `N` must be between `1` and `9`, and defaults to `1` if omitted (with simply `%m`).\n-* `%c` - Does not add anything to the filename, but enables a mode (on some platforms, including Darwin) in which profile counter updates are continuously synced to a file. This means that if the instrumented program crashes, or is killed by a signal, perfect coverage information can still be recovered.\n-\n-## Installing LLVM coverage tools\n-\n-LLVM's supplies two tools\u2014`llvm-profdata` and `llvm-cov`\u2014that process coverage data and generate reports. There are several ways to find and/or install these tools, but note that the coverage mapping data generated by the Rust compiler requires LLVM version 11 or higher. (`llvm-cov --version` typically shows the tool's LLVM version number.):\n-\n-* The LLVM tools may be installed (or installable) directly to your OS (such as via `apt-get`, for Linux).\n-* If you are building the Rust compiler from source, you can optionally use the bundled LLVM tools, built from source. Those tool binaries can typically be found in your build platform directory at something like: `rust/build/x86_64-unknown-linux-gnu/llvm/bin/llvm-*`.\n-* You can install compatible versions of these tools via `rustup`.\n-\n-The `rustup` option is guaranteed to install a compatible version of the LLVM tools, but they can be hard to find. We recommend [`cargo-binutils`], which installs Rust-specific wrappers around these and other LLVM tools, so you can invoke them via `cargo` commands!\n-\n-```shell\n-$ rustup component add llvm-tools-preview\n-$ cargo install cargo-binutils\n-$ cargo profdata -- --help  # note the additional \"--\" preceding the tool-specific arguments\n-```\n-\n-## Creating coverage reports\n-\n-Raw profiles have to be indexed before they can be used to generate coverage reports. This is done using [`llvm-profdata merge`] (or `cargo profdata -- merge`), which can combine multiple raw profiles and index them at the same time:\n-\n-```shell\n-$ llvm-profdata merge -sparse formatjson5.profraw -o formatjson5.profdata\n-```\n-\n-Finally, the `.profdata` file is used, in combination with the coverage map (from the program binary) to generate coverage reports using [`llvm-cov report`] (or `cargo cov -- report`), for a coverage summaries; and [`llvm-cov show`] (or `cargo cov -- show`), to see detailed coverage of lines and regions (character ranges) overlaid on the original source code.\n-\n-These commands have several display and filtering options. For example:\n-\n-```shell\n-$ llvm-cov show -Xdemangler=rustfilt target/debug/examples/formatjson5 \\\n-    -instr-profile=formatjson5.profdata \\\n-    -show-line-counts-or-regions \\\n-    -show-instantiations \\\n-    -name=add_quoted_string\n-```\n-\n-<img alt=\"Screenshot of sample `llvm-cov show` result, for function add_quoted_string\" src=\"img/llvm-cov-show-01.png\" class=\"center\"/>\n-<br/>\n-<br/>\n-\n-Some of the more notable options in this example include:\n-\n-* `--Xdemangler=rustfilt` - the command name or path used to demangle Rust symbols (`rustfilt` in the example, but this could also be a path to the `rust-demangler` tool)\n-* `target/debug/examples/formatjson5` - the instrumented binary (from which to extract the coverage map)\n-* `--instr-profile=<path-to-file>.profdata` - the location of the `.profdata` file created by `llvm-profdata merge` (from the `.profraw` file generated by the instrumented binary)\n-* `--name=<exact-function-name>` - to show coverage for a specific function (or, consider using another filter option, such as `--name-regex=<pattern>`)\n-\n-## Interpreting reports\n-\n-There are four statistics tracked in a coverage summary:\n-\n-* Function coverage is the percentage of functions that have been executed at least once. A function is considered to be executed if any of its instantiations are executed.\n-* Instantiation coverage is the percentage of function instantiations that have been executed at least once. Generic functions and functions generated from macros are two kinds of functions that may have multiple instantiations.\n-* Line coverage is the percentage of code lines that have been executed at least once. Only executable lines within function bodies are considered to be code lines.\n-* Region coverage is the percentage of code regions that have been executed at least once. A code region may span multiple lines: for example, in a large function body with no control flow. In other cases, a single line can contain multiple code regions: `return x || (y && z)` has countable code regions for `x` (which may resolve the expression, if `x` is `true`), `|| (y && z)` (executed only if `x` was `false`), and `return` (executed in either situation).\n-\n-Of these four statistics, function coverage is usually the least granular while region coverage is the most granular. The project-wide totals for each statistic are listed in the summary.\n-\n-## Test coverage\n-\n-A typical use case for coverage analysis is test coverage. Rust's source-based coverage tools can both measure your tests' code coverage as percentage, and pinpoint functions and branches not tested.\n-\n-The following example (using the [`json5format`] crate, for demonstration purposes) show how to generate and analyze coverage results for all tests in a crate.\n-\n-Since `cargo test` both builds and runs the tests, we set both the additional `RUSTFLAGS`, to add the `-Zinstrument-coverage` flag, and `LLVM_PROFILE_FILE`, to set a custom filename for the raw profiling data generated during the test runs. Since there may be more than one test binary, apply `%m` in the filename pattern. This generates unique names for each test binary. (Otherwise, each executed test binary would overwrite the coverage results from the previous binary.)\n-\n-```shell\n-$ RUSTFLAGS=\"-Zinstrument-coverage\" \\\n-    LLVM_PROFILE_FILE=\"json5format-%m.profraw\" \\\n-    cargo test --tests\n-```\n-\n-Make note of the test binary file paths, displayed after the word \"`Running`\" in the test output:\n-\n-```text\n-   ...\n-   Compiling json5format v0.1.3 ($HOME/json5format)\n-    Finished test [unoptimized + debuginfo] target(s) in 14.60s\n-\n-     Running target/debug/deps/json5format-fececd4653271682\n-running 25 tests\n-...\n-test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n-\n-     Running target/debug/deps/lib-30768f9c53506dc5\n-running 31 tests\n-...\n-test result: ok. 31 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n-```\n-\n-You should have one or more `.profraw` files now, one for each test binary. Run the `profdata` tool to merge them:\n-\n-```shell\n-$ cargo profdata -- merge \\\n-    -sparse json5format-*.profraw -o json5format.profdata\n-```\n-\n-Then run the `cov` tool, with the `profdata` file and all test binaries:\n-\n-```shell\n-$ cargo cov -- report \\\n-    --use-color --ignore-filename-regex='/.cargo/registry' \\\n-    --instr-profile=json5format.profdata \\\n-    --object target/debug/deps/lib-30768f9c53506dc5 \\\n-    --object target/debug/deps/json5format-fececd4653271682\n-$ cargo cov -- show \\\n-    --use-color --ignore-filename-regex='/.cargo/registry' \\\n-    --instr-profile=json5format.profdata \\\n-    --object target/debug/deps/lib-30768f9c53506dc5 \\\n-    --object target/debug/deps/json5format-fececd4653271682 \\\n-    --show-instantiations --show-line-counts-or-regions \\\n-    --Xdemangler=rustfilt | less -R\n-```\n-\n-_Note the command line option `--ignore-filename-regex=/.cargo/registry`, which excludes the sources for dependencies from the coverage results._\n-\n-### Tips for listing the binaries automatically\n-\n-For `bash` users, one suggested way to automatically complete the `cov` command with the list of binaries is with a command like:\n-\n-```bash\n-$ cargo cov -- report \\\n-    $( \\\n-      for file in \\\n-        $( \\\n-          RUSTFLAGS=\"-Zinstrument-coverage\" \\\n-            cargo test --tests --no-run --message-format=json \\\n-              | jq -r \"select(.profile.test == true) | .filenames[]\" \\\n-              | grep -v dSYM - \\\n-        ); \\\n-      do \\\n-        printf \"%s %s \" -object $file; \\\n-      done \\\n-    ) \\\n-  --instr-profile=json5format.profdata --summary-only # and/or other options\n-```\n-\n-Adding `--no-run --message-format=json` to the _same_ `cargo test` command used to run\n-the tests (including the same environment variables and flags) generates output in a JSON\n-format that `jq` can easily query.\n-\n-The `printf` command takes this list and generates the `--object <binary>` arguments\n-for each listed test binary.\n-\n-### Including doc tests\n-\n-The previous examples run `cargo test` with `--tests`, which excludes doc tests.[^79417]\n-\n-To include doc tests in the coverage results, drop the `--tests` flag, and apply the\n-`-Zinstrument-coverage` flag, and some doc-test-specific options in the\n-`RUSTDOCFLAGS` environment variable. (The `cargo profdata` command does not change.)\n-\n-```bash\n-$ RUSTFLAGS=\"-Zinstrument-coverage\" \\\n-  RUSTDOCFLAGS=\"-Zinstrument-coverage -Zunstable-options --persist-doctests target/debug/doctestbins\" \\\n-  LLVM_PROFILE_FILE=\"json5format-%m.profraw\" \\\n-    cargo test\n-$ cargo profdata -- merge \\\n-    -sparse json5format-*.profraw -o json5format.profdata\n-```\n-\n-The `-Zunstable-options --persist-doctests` flag is required, to save the test binaries\n-(with their coverage maps) for `llvm-cov`.\n-\n-```bash\n-$ cargo cov -- report \\\n-    $( \\\n-      for file in \\\n-        $( \\\n-          RUSTFLAGS=\"-Zinstrument-coverage\" \\\n-          RUSTDOCFLAGS=\"-Zinstrument-coverage -Zunstable-options --persist-doctests target/debug/doctestbins\" \\\n-            cargo test --no-run --message-format=json \\\n-              | jq -r \"select(.profile.test == true) | .filenames[]\" \\\n-              | grep -v dSYM - \\\n-        ) \\\n-        target/debug/doctestbins/*/rust_out; \\\n-      do \\\n-        [[ -x $file ]] && printf \"%s %s \" -object $file; \\\n-      done \\\n-    ) \\\n-  --instr-profile=json5format.profdata --summary-only # and/or other options\n-```\n-\n-Note, the differences in this `cargo cov` command, compared with the version without\n-doc tests, include:\n-\n-* The `cargo test ... --no-run` command is updated with the same environment variables\n-  and flags used to _build_ the tests, _including_ the doc tests. (`LLVM_PROFILE_FILE`\n-  is only used when _running_ the tests.)\n-* The file glob pattern `target/debug/doctestbins/*/rust_out` adds the `rust_out`\n-  binaries generated for doc tests (note, however, that some `rust_out` files may not\n-  be executable binaries).\n-* `[[ -x $file ]] &&` filters the files passed on to the `printf`, to include only\n-  executable binaries.\n-\n-[^79417]: There is ongoing work to resolve a known issue\n-[(#79417)](https://github.com/rust-lang/rust/issues/79417) that doc test coverage\n-generates incorrect source line numbers in `llvm-cov show` results.\n-\n-## Other references\n-\n-Rust's implementation and workflow for source-based code coverage is based on the same library and tools used to implement [source-based code coverage in Clang]. (This document is partially based on the Clang guide.)\n-\n-[#79121]: https://github.com/rust-lang/rust/issues/79121\n-[`-Zprofile`]: profile.md\n-[`llvm.instrprof.increment`]: https://llvm.org/docs/LangRef.html#llvm-instrprof-increment-intrinsic\n-[LLVM Code Coverage Mapping Format]: https://llvm.org/docs/CoverageMappingFormat.html\n-[rustc-dev-guide-how-to-build-and-run]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html\n-[`rustfilt`]: https://crates.io/crates/rustfilt\n-[`json5format`]: https://crates.io/crates/json5format\n-[`cargo-binutils`]: https://crates.io/crates/cargo-binutils\n-[`llvm-profdata merge`]: https://llvm.org/docs/CommandGuide/llvm-profdata.html#profdata-merge\n-[`llvm-cov report`]: https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-report\n-[`llvm-cov show`]: https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-show\n-[source-based code coverage in Clang]: https://clang.llvm.org/docs/SourceBasedCodeCoverage.html\n+[`-z instrument-coverage`]: ./instrument-coverage.html"}, {"sha": "327cdb39791a29880a6c8c62ce9c4eb85c59f7a6", "filename": "src/doc/unstable-book/src/language-features/no-coverage.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-coverage.md?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -0,0 +1,30 @@\n+# `no_coverage`\n+\n+The tracking issue for this feature is: [#84605]\n+\n+[#84605]: https://github.com/rust-lang/rust/issues/84605\n+\n+---\n+\n+The `no_coverage` attribute can be used to selectively disable coverage\n+instrumentation in an annotated function. This might be useful to:\n+\n+-   Avoid instrumentation overhead in a performance critical function\n+-   Avoid generating coverage for a function that is not meant to be executed,\n+    but still target 100% coverage for the rest of the program.\n+\n+## Example\n+\n+```rust\n+#![feature(no_coverage)]\n+\n+// `foo()` will get coverage instrumentation (by default)\n+fn foo() {\n+  // ...\n+}\n+\n+#[no_coverage]\n+fn bar() {\n+  // ...\n+}\n+```"}, {"sha": "322f5681b3fd9278243359047748a891ca46fe21", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.async2.txt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -14,9 +14,9 @@\n    14|      1|    }\n    15|      1|}\n    16|       |\n-   17|       |// FIXME(#83985): The auto-generated closure in an async function is failing to include\n-   18|       |// the println!() and `let` assignment lines in the coverage code region(s), as it does in the\n-   19|       |// non-async function above, unless the `println!()` is inside a covered block.\n+   17|       |\n+   18|       |\n+   19|       |\n    20|      1|async fn async_func() {\n    21|      1|    println!(\"async_func was covered\");\n    22|      1|    let b = true;\n@@ -26,9 +26,9 @@\n                    ^0\n    26|      1|}\n    27|       |\n-   28|       |// FIXME(#83985): As above, this async function only has the `println!()` macro call, which is not\n-   29|       |// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.\n-   30|       |// It's only certain kinds of lines and/or their context that results in missing coverage.\n+   28|       |\n+   29|       |\n+   30|       |\n    31|      1|async fn async_func_just_println() {\n    32|      1|    println!(\"async_func_just_println was covered\");\n    33|      1|}"}, {"sha": "5715e0cc269f4f80eb0d06be405fbff921075527", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure.txt", "status": "modified", "additions": 84, "deletions": 22, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -37,7 +37,7 @@\n    37|      0|            countdown = 10;\n    38|      0|        }\n    39|      0|        \"alt string 2\".to_owned()\n-   40|      1|    };\n+   40|      0|    };\n    41|      1|    println!(\n    42|      1|        \"The string or alt: {}\"\n    43|      1|        ,\n@@ -125,36 +125,98 @@\n   125|      0|            countdown = 10;\n   126|      0|        }\n   127|      0|        \"closure should be unused\".to_owned()\n-  128|      1|    };\n-  129|      1|\n+  128|      0|    };\n+  129|       |\n   130|      1|    let mut countdown = 10;\n   131|      1|    let _short_unused_closure = | _unused_arg: u8 | countdown += 1;\n                                                                   ^0\n-  132|      1|\n-  133|      1|    // Macros can sometimes confuse the coverage results. Compare this next assignment, with an\n-  134|      1|    // unused closure that invokes the `println!()` macro, with the closure assignment above, that\n-  135|      1|    // does not use a macro. The closure above correctly shows `0` executions.\n-  136|      1|    let _short_unused_closure = | _unused_arg: u8 | println!(\"not called\");\n-  137|      1|    // The closure assignment above is executed, with a line count of `1`, but the `println!()`\n-  138|      1|    // could not have been called, and yet, there is no indication that it wasn't...\n-  139|      1|\n-  140|      1|    // ...but adding block braces gives the expected result, showing the block was not executed.\n+  132|       |\n+  133|       |\n+  134|      1|    let short_used_covered_closure_macro = | used_arg: u8 | println!(\"called\");\n+  135|      1|    let short_used_not_covered_closure_macro = | used_arg: u8 | println!(\"not called\");\n+                                                                              ^0\n+  136|      1|    let _short_unused_closure_macro = | _unused_arg: u8 | println!(\"not called\");\n+                                                                        ^0\n+  137|       |\n+  138|       |\n+  139|       |\n+  140|       |\n   141|      1|    let _short_unused_closure_block = | _unused_arg: u8 | { println!(\"not called\") };\n                                                                         ^0\n-  142|      1|\n+  142|       |\n   143|      1|    let _shortish_unused_closure = | _unused_arg: u8 | {\n   144|      0|        println!(\"not called\")\n-  145|      1|    };\n-  146|      1|\n+  145|      0|    };\n+  146|       |\n   147|      1|    let _as_short_unused_closure = |\n   148|       |        _unused_arg: u8\n-  149|      1|    | { println!(\"not called\") };\n-                    ^0\n-  150|      1|\n+  149|      0|    | { println!(\"not called\") };\n+  150|       |\n   151|      1|    let _almost_as_short_unused_closure = |\n   152|       |        _unused_arg: u8\n-  153|      1|    | { println!(\"not called\") }\n-                    ^0\n-  154|      1|    ;\n-  155|      1|}\n+  153|      0|    | { println!(\"not called\") }\n+  154|       |    ;\n+  155|       |\n+  156|       |\n+  157|       |\n+  158|       |\n+  159|       |\n+  160|      1|    let _short_unused_closure_line_break_no_block = | _unused_arg: u8 |\n+  161|      0|println!(\"not called\")\n+  162|       |    ;\n+  163|       |\n+  164|      1|    let _short_unused_closure_line_break_no_block2 =\n+  165|       |        | _unused_arg: u8 |\n+  166|      0|            println!(\n+  167|      0|                \"not called\"\n+  168|      0|            )\n+  169|       |    ;\n+  170|       |\n+  171|      1|    let short_used_not_covered_closure_line_break_no_block_embedded_branch =\n+  172|      1|        | _unused_arg: u8 |\n+  173|      0|            println!(\n+  174|      0|                \"not called: {}\",\n+  175|      0|                if is_true { \"check\" } else { \"me\" }\n+  176|      0|            )\n+  177|       |    ;\n+  178|       |\n+  179|      1|    let short_used_not_covered_closure_line_break_block_embedded_branch =\n+  180|      1|        | _unused_arg: u8 |\n+  181|      0|        {\n+  182|      0|            println!(\n+  183|      0|                \"not called: {}\",\n+  184|      0|                if is_true { \"check\" } else { \"me\" }\n+  185|       |            )\n+  186|      0|        }\n+  187|       |    ;\n+  188|       |\n+  189|      1|    let short_used_covered_closure_line_break_no_block_embedded_branch =\n+  190|      1|        | _unused_arg: u8 |\n+  191|      1|            println!(\n+  192|      1|                \"not called: {}\",\n+  193|      1|                if is_true { \"check\" } else { \"me\" }\n+                                                            ^0\n+  194|      1|            )\n+  195|       |    ;\n+  196|       |\n+  197|      1|    let short_used_covered_closure_line_break_block_embedded_branch =\n+  198|      1|        | _unused_arg: u8 |\n+  199|      1|        {\n+  200|      1|            println!(\n+  201|      1|                \"not called: {}\",\n+  202|      1|                if is_true { \"check\" } else { \"me\" }\n+                                                            ^0\n+  203|       |            )\n+  204|      1|        }\n+  205|       |    ;\n+  206|       |\n+  207|      1|    if is_false {\n+  208|      0|        short_used_not_covered_closure_macro(0);\n+  209|      0|        short_used_not_covered_closure_line_break_no_block_embedded_branch(0);\n+  210|      0|        short_used_not_covered_closure_line_break_block_embedded_branch(0);\n+  211|      1|    }\n+  212|      1|    short_used_covered_closure_macro(0);\n+  213|      1|    short_used_covered_closure_line_break_no_block_embedded_branch(0);\n+  214|      1|    short_used_covered_closure_line_break_block_embedded_branch(0);\n+  215|      1|}\n "}, {"sha": "87f7014760edf345a5e262dae753eaf7b8bf3ba9", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure_macro.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -14,15 +14,15 @@\n    14|       |\n    15|       |macro_rules! on_error {\n    16|       |    ($value:expr, $error_message:expr) => {\n-   17|      0|        $value.or_else(|e| {\n-   18|      0|            let message = format!($error_message, e);\n-   19|      0|            if message.len() > 0 {\n-   20|      0|                println!(\"{}\", message);\n-   21|      0|                Ok(String::from(\"ok\"))\n+   17|       |        $value.or_else(|e| { // FIXME(85000): no coverage in closure macros\n+   18|       |            let message = format!($error_message, e);\n+   19|       |            if message.len() > 0 {\n+   20|       |                println!(\"{}\", message);\n+   21|       |                Ok(String::from(\"ok\"))\n    22|       |            } else {\n-   23|      0|                bail!(\"error\");\n+   23|       |                bail!(\"error\");\n    24|       |            }\n-   25|      0|        })\n+   25|       |        })\n    26|       |    };\n    27|       |}\n    28|       |"}, {"sha": "2b5418132c307227f6cd2686b886a5b8c0082032", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure_macro_async.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -14,15 +14,15 @@\n    14|       |\n    15|       |macro_rules! on_error {\n    16|       |    ($value:expr, $error_message:expr) => {\n-   17|      0|        $value.or_else(|e| {\n-   18|      0|            let message = format!($error_message, e);\n-   19|      0|            if message.len() > 0 {\n-   20|      0|                println!(\"{}\", message);\n-   21|      0|                Ok(String::from(\"ok\"))\n+   17|       |        $value.or_else(|e| { // FIXME(85000): no coverage in closure macros\n+   18|       |            let message = format!($error_message, e);\n+   19|       |            if message.len() > 0 {\n+   20|       |                println!(\"{}\", message);\n+   21|       |                Ok(String::from(\"ok\"))\n    22|       |            } else {\n-   23|      0|                bail!(\"error\");\n+   23|       |                bail!(\"error\");\n    24|       |            }\n-   25|      0|        })\n+   25|       |        })\n    26|       |    };\n    27|       |}\n    28|       |"}, {"sha": "324b9138c4d9c10271c007767fbc080d9f061fb1", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.no_cov_crate.txt", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -11,8 +11,27 @@\n    11|       |    println!(\"called but not covered\");\n    12|       |}\n    13|       |\n-   14|      1|fn main() {\n-   15|      1|    do_not_add_coverage_1();\n-   16|      1|    do_not_add_coverage_2();\n-   17|      1|}\n+   14|       |#[no_coverage]\n+   15|       |fn do_not_add_coverage_not_called() {\n+   16|       |    println!(\"not called and not covered\");\n+   17|       |}\n+   18|       |\n+   19|      1|fn add_coverage_1() {\n+   20|      1|    println!(\"called and covered\");\n+   21|      1|}\n+   22|       |\n+   23|      1|fn add_coverage_2() {\n+   24|      1|    println!(\"called and covered\");\n+   25|      1|}\n+   26|       |\n+   27|      0|fn add_coverage_not_called() {\n+   28|      0|    println!(\"not called but covered\");\n+   29|      0|}\n+   30|       |\n+   31|      1|fn main() {\n+   32|      1|    do_not_add_coverage_1();\n+   33|      1|    do_not_add_coverage_2();\n+   34|      1|    add_coverage_1();\n+   35|      1|    add_coverage_2();\n+   36|      1|}\n "}, {"sha": "114507dc9fd2add172507e4fbfeaa01083c792b1", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.panic_unwind.txt", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.panic_unwind.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.panic_unwind.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.panic_unwind.txt?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -29,22 +29,4 @@\n    29|       |//   2. Since the `panic_unwind.rs` test is allowed to unwind, it is also allowed to execute the\n    30|       |//      normal program exit cleanup, including writing out the current values of the coverage\n    31|       |//      counters.\n-   32|       |//   3. The coverage results show (interestingly) that the `panic!()` call did execute, but it does\n-   33|       |//      not show coverage of the `if countdown == 1` branch in `main()` that calls\n-   34|       |//      `might_panic(true)` (causing the call to `panic!()`).\n-   35|       |//   4. The reason `main()`s `if countdown == 1` branch, calling `might_panic(true)`, appears\n-   36|       |//      \"uncovered\" is, InstrumentCoverage (intentionally) treats `TerminatorKind::Call` terminators\n-   37|       |//      as non-branching, because when a program executes normally, they always are. Errors handled\n-   38|       |//      via the try `?` operator produce error handling branches that *are* treated as branches in\n-   39|       |//      coverage results. By treating calls without try `?` operators as non-branching (assumed to\n-   40|       |//      return normally and continue) the coverage graph can be simplified, producing smaller,\n-   41|       |//      faster binaries, and cleaner coverage results.\n-   42|       |//   5. The reason the coverage results actually show `panic!()` was called is most likely because\n-   43|       |//      `panic!()` is a macro, not a simple function call, and there are other `Statement`s and/or\n-   44|       |//      `Terminator`s that execute with a coverage counter before the panic and unwind occur.\n-   45|       |//   6. Since the common practice is not to use `panic!()` for error handling, the coverage\n-   46|       |//      implementation avoids incurring an additional cost (in program size and execution time) to\n-   47|       |//      improve coverage results for an event that is generally not \"supposed\" to happen.\n-   48|       |//   7. FIXME(#78544): This issue describes a feature request for a proposed option to enable\n-   49|       |//      more accurate coverage results for tests that intentionally panic.\n "}, {"sha": "959d48ce9db160540aa5fcfe86f55e9619d111f1", "filename": "src/test/run-make-fulldeps/coverage/async2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -14,9 +14,9 @@ fn non_async_func() {\n     }\n }\n \n-// FIXME(#83985): The auto-generated closure in an async function is failing to include\n-// the println!() and `let` assignment lines in the coverage code region(s), as it does in the\n-// non-async function above, unless the `println!()` is inside a covered block.\n+\n+\n+\n async fn async_func() {\n     println!(\"async_func was covered\");\n     let b = true;\n@@ -25,9 +25,9 @@ async fn async_func() {\n     }\n }\n \n-// FIXME(#83985): As above, this async function only has the `println!()` macro call, which is not\n-// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.\n-// It's only certain kinds of lines and/or their context that results in missing coverage.\n+\n+\n+\n async fn async_func_just_println() {\n     println!(\"async_func_just_println was covered\");\n }"}, {"sha": "32ec0bcdf8c99d4467a713b5a619884f978ca648", "filename": "src/test/run-make-fulldeps/coverage/closure.rs", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -130,14 +130,14 @@ fn main() {\n     let mut countdown = 10;\n     let _short_unused_closure = | _unused_arg: u8 | countdown += 1;\n \n-    // Macros can sometimes confuse the coverage results. Compare this next assignment, with an\n-    // unused closure that invokes the `println!()` macro, with the closure assignment above, that\n-    // does not use a macro. The closure above correctly shows `0` executions.\n-    let _short_unused_closure = | _unused_arg: u8 | println!(\"not called\");\n-    // The closure assignment above is executed, with a line count of `1`, but the `println!()`\n-    // could not have been called, and yet, there is no indication that it wasn't...\n-\n-    // ...but adding block braces gives the expected result, showing the block was not executed.\n+\n+    let short_used_covered_closure_macro = | used_arg: u8 | println!(\"called\");\n+    let short_used_not_covered_closure_macro = | used_arg: u8 | println!(\"not called\");\n+    let _short_unused_closure_macro = | _unused_arg: u8 | println!(\"not called\");\n+\n+\n+\n+\n     let _short_unused_closure_block = | _unused_arg: u8 | { println!(\"not called\") };\n \n     let _shortish_unused_closure = | _unused_arg: u8 | {\n@@ -152,4 +152,64 @@ fn main() {\n         _unused_arg: u8\n     | { println!(\"not called\") }\n     ;\n+\n+\n+\n+\n+\n+    let _short_unused_closure_line_break_no_block = | _unused_arg: u8 |\n+println!(\"not called\")\n+    ;\n+\n+    let _short_unused_closure_line_break_no_block2 =\n+        | _unused_arg: u8 |\n+            println!(\n+                \"not called\"\n+            )\n+    ;\n+\n+    let short_used_not_covered_closure_line_break_no_block_embedded_branch =\n+        | _unused_arg: u8 |\n+            println!(\n+                \"not called: {}\",\n+                if is_true { \"check\" } else { \"me\" }\n+            )\n+    ;\n+\n+    let short_used_not_covered_closure_line_break_block_embedded_branch =\n+        | _unused_arg: u8 |\n+        {\n+            println!(\n+                \"not called: {}\",\n+                if is_true { \"check\" } else { \"me\" }\n+            )\n+        }\n+    ;\n+\n+    let short_used_covered_closure_line_break_no_block_embedded_branch =\n+        | _unused_arg: u8 |\n+            println!(\n+                \"not called: {}\",\n+                if is_true { \"check\" } else { \"me\" }\n+            )\n+    ;\n+\n+    let short_used_covered_closure_line_break_block_embedded_branch =\n+        | _unused_arg: u8 |\n+        {\n+            println!(\n+                \"not called: {}\",\n+                if is_true { \"check\" } else { \"me\" }\n+            )\n+        }\n+    ;\n+\n+    if is_false {\n+        short_used_not_covered_closure_macro(0);\n+        short_used_not_covered_closure_line_break_no_block_embedded_branch(0);\n+        short_used_not_covered_closure_line_break_block_embedded_branch(0);\n+    }\n+    short_used_covered_closure_macro(0);\n+    short_used_covered_closure_line_break_no_block_embedded_branch(0);\n+    short_used_covered_closure_line_break_block_embedded_branch(0);\n }"}, {"sha": "5e3b00d1ef54b4c34a1121f6929a8cf8ef9fe7b1", "filename": "src/test/run-make-fulldeps/coverage/closure_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -14,7 +14,7 @@ macro_rules! bail {\n \n macro_rules! on_error {\n     ($value:expr, $error_message:expr) => {\n-        $value.or_else(|e| {\n+        $value.or_else(|e| { // FIXME(85000): no coverage in closure macros\n             let message = format!($error_message, e);\n             if message.len() > 0 {\n                 println!(\"{}\", message);"}, {"sha": "e3e89e9c8b3c987e675d463c4b4ad9c5de4b209b", "filename": "src/test/run-make-fulldeps/coverage/closure_macro_async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -14,7 +14,7 @@ macro_rules! bail {\n \n macro_rules! on_error {\n     ($value:expr, $error_message:expr) => {\n-        $value.or_else(|e| {\n+        $value.or_else(|e| { // FIXME(85000): no coverage in closure macros\n             let message = format!($error_message, e);\n             if message.len() > 0 {\n                 println!(\"{}\", message);"}, {"sha": "6f8586d9f5ca642ec63c25d8c2f99ad739e1c3c1", "filename": "src/test/run-make-fulldeps/coverage/no_cov_crate.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -11,7 +11,26 @@ fn do_not_add_coverage_2() {\n     println!(\"called but not covered\");\n }\n \n+#[no_coverage]\n+fn do_not_add_coverage_not_called() {\n+    println!(\"not called and not covered\");\n+}\n+\n+fn add_coverage_1() {\n+    println!(\"called and covered\");\n+}\n+\n+fn add_coverage_2() {\n+    println!(\"called and covered\");\n+}\n+\n+fn add_coverage_not_called() {\n+    println!(\"not called but covered\");\n+}\n+\n fn main() {\n     do_not_add_coverage_1();\n     do_not_add_coverage_2();\n+    add_coverage_1();\n+    add_coverage_2();\n }"}, {"sha": "03128c2cce6281160e6e67be0022c448825f7dc1", "filename": "src/test/run-make-fulldeps/coverage/panic_unwind.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fpanic_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fpanic_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fpanic_unwind.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -29,21 +29,3 @@ fn main() -> Result<(), u8> {\n //   2. Since the `panic_unwind.rs` test is allowed to unwind, it is also allowed to execute the\n //      normal program exit cleanup, including writing out the current values of the coverage\n //      counters.\n-//   3. The coverage results show (interestingly) that the `panic!()` call did execute, but it does\n-//      not show coverage of the `if countdown == 1` branch in `main()` that calls\n-//      `might_panic(true)` (causing the call to `panic!()`).\n-//   4. The reason `main()`s `if countdown == 1` branch, calling `might_panic(true)`, appears\n-//      \"uncovered\" is, InstrumentCoverage (intentionally) treats `TerminatorKind::Call` terminators\n-//      as non-branching, because when a program executes normally, they always are. Errors handled\n-//      via the try `?` operator produce error handling branches that *are* treated as branches in\n-//      coverage results. By treating calls without try `?` operators as non-branching (assumed to\n-//      return normally and continue) the coverage graph can be simplified, producing smaller,\n-//      faster binaries, and cleaner coverage results.\n-//   5. The reason the coverage results actually show `panic!()` was called is most likely because\n-//      `panic!()` is a macro, not a simple function call, and there are other `Statement`s and/or\n-//      `Terminator`s that execute with a coverage counter before the panic and unwind occur.\n-//   6. Since the common practice is not to use `panic!()` for error handling, the coverage\n-//      implementation avoids incurring an additional cost (in program size and execution time) to\n-//      improve coverage results for an event that is generally not \"supposed\" to happen.\n-//   7. FIXME(#78544): This issue describes a feature request for a proposed option to enable\n-//      more accurate coverage results for tests that intentionally panic."}, {"sha": "404ce409d93bc67801e6cf86cc485c4a7fcd36ca", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -296,7 +296,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/ub-wide-ptr.rs:135:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ inbounds test failed: 0x0 is not a valid pointer\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ null pointer is not allowed for this operation\n \n error[E0080]: could not evaluate static initializer\n   --> $DIR/ub-wide-ptr.rs:139:5"}, {"sha": "39c5654276284ded2e5e1c1d4d446d8fce645ebc", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -296,7 +296,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/ub-wide-ptr.rs:135:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ inbounds test failed: 0x0 is not a valid pointer\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ null pointer is not allowed for this operation\n \n error[E0080]: could not evaluate static initializer\n   --> $DIR/ub-wide-ptr.rs:139:5"}, {"sha": "d5d213f9c79d4ceb783fa99a117839c6482711d4", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -74,7 +74,7 @@ error: any use of this value will cause an error\n LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                    |\n-   |                    inbounds test failed: 0x0 is not a valid pointer\n+   |                    null pointer is not allowed for this operation\n    |                    inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |                    inside `OFFSET_FROM_NULL` at $DIR/offset_from_ub.rs:36:14\n    | "}, {"sha": "45203d3e271199b82e42e735f8d6685b51aa901e", "filename": "src/test/ui/consts/offset_ub.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -23,7 +23,7 @@ error: any use of this value will cause an error\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  inbounds test failed: pointer must be in-bounds at offset 2, but is outside bounds of allocN which has size 1\n+   |                  pointer arithmetic failed: pointer must be in-bounds at offset 2, but is outside bounds of allocN which has size 1\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |                  inside `AFTER_END` at $DIR/offset_ub.rs:7:43\n    | \n@@ -41,7 +41,7 @@ error: any use of this value will cause an error\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  inbounds test failed: pointer must be in-bounds at offset 101, but is outside bounds of allocN which has size 100\n+   |                  pointer arithmetic failed: pointer must be in-bounds at offset 101, but is outside bounds of allocN which has size 100\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |                  inside `AFTER_ARRAY` at $DIR/offset_ub.rs:8:45\n    | \n@@ -131,7 +131,7 @@ error: any use of this value will cause an error\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  inbounds test failed: pointer must be in-bounds at offset 1, but is outside bounds of allocN which has size 0\n+   |                  pointer arithmetic failed: pointer must be in-bounds at offset 1, but is outside bounds of allocN which has size 0\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |                  inside `ZERO_SIZED_ALLOC` at $DIR/offset_ub.rs:15:50\n    | \n@@ -167,7 +167,7 @@ error: any use of this value will cause an error\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  inbounds test failed: 0x0 is not a valid pointer\n+   |                  pointer arithmetic failed: 0x0 is not a valid pointer\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |                  inside `NULL_OFFSET_ZERO` at $DIR/offset_ub.rs:19:50\n    | "}, {"sha": "62b33000e60b8e214fb41a2c29c2e406024f3db6", "filename": "src/test/ui/consts/ptr_comparisons.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -4,7 +4,7 @@ error: any use of this value will cause an error\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  inbounds test failed: pointer must be in-bounds at offset $TWO_WORDS, but is outside bounds of alloc2 which has size $WORD\n+   |                  pointer arithmetic failed: pointer must be in-bounds at offset $TWO_WORDS, but is outside bounds of alloc2 which has size $WORD\n    |                  inside `ptr::const_ptr::<impl *const usize>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |                  inside `_` at $DIR/ptr_comparisons.rs:61:34\n    | "}, {"sha": "54ff38e39dbe43af7c1427503481214f6dd72762", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac888e8675182c703c2cd097957878faf88dad94/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=ac888e8675182c703c2cd097957878faf88dad94", "patch": "@@ -85,7 +85,9 @@ fn main() {\n     let cargo = &Path::new(cargo);\n \n     for test in TEST_REPOS.iter().rev() {\n-        test_repo(cargo, out_dir, test);\n+        if args[3..].is_empty() || args[3..].iter().any(|s| s.contains(test.name)) {\n+            test_repo(cargo, out_dir, test);\n+        }\n     }\n }\n "}]}