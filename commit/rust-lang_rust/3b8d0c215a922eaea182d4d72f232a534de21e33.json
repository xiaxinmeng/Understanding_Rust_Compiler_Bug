{"sha": "3b8d0c215a922eaea182d4d72f232a534de21e33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiOGQwYzIxNWE5MjJlYWVhMTgyZDRkNzJmMjMyYTUzNGRlMjFlMzM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-20T13:21:02Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-20T13:21:02Z"}, "message": "Use more OO API for parent module", "tree": {"sha": "1b15feded11b298d973262ce204a1df8b72e081c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b15feded11b298d973262ce204a1df8b72e081c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b8d0c215a922eaea182d4d72f232a534de21e33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b8d0c215a922eaea182d4d72f232a534de21e33", "html_url": "https://github.com/rust-lang/rust/commit/3b8d0c215a922eaea182d4d72f232a534de21e33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b8d0c215a922eaea182d4d72f232a534de21e33/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "099da13f531c84a7c69fbf5eed6a658bf64b531b", "url": "https://api.github.com/repos/rust-lang/rust/commits/099da13f531c84a7c69fbf5eed6a658bf64b531b", "html_url": "https://github.com/rust-lang/rust/commit/099da13f531c84a7c69fbf5eed6a658bf64b531b"}], "stats": {"total": 123, "additions": 94, "deletions": 29}, "files": [{"sha": "d62826ee30878a3cef4fe693d1dedb44183c079e", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/3b8d0c215a922eaea182d4d72f232a534de21e33/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b8d0c215a922eaea182d4d72f232a534de21e33/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=3b8d0c215a922eaea182d4d72f232a534de21e33", "patch": "@@ -1,16 +1,90 @@\n pub(super) mod imp;\n pub(crate) mod scope;\n \n+use std::sync::Arc;\n+\n+use ra_editor::find_node_at_offset;\n+\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n     SmolStr, SyntaxNode, SyntaxNodeRef,\n };\n use relative_path::RelativePathBuf;\n \n-use crate::{db::SyntaxDatabase, syntax_ptr::SyntaxPtr, FileId};\n+use crate::{\n+    db::SyntaxDatabase, syntax_ptr::SyntaxPtr, FileId, FilePosition, Cancelable,\n+    descriptors::DescriptorDatabase,\n+};\n \n pub(crate) use self::scope::ModuleScope;\n \n+/// `ModuleDescriptor` is API entry point to get all the information\n+/// about a particular module.\n+#[derive(Debug, Clone)]\n+pub(crate) struct ModuleDescriptor {\n+    tree: Arc<ModuleTree>,\n+    module_id: ModuleId,\n+}\n+\n+impl ModuleDescriptor {\n+    /// Lookup `ModuleDescriptor` by position in the source code. Note that this\n+    /// is inherently lossy transformation: in general, a single source might\n+    /// correspond to several modules.\n+    pub fn guess_from_position(\n+        db: &impl DescriptorDatabase,\n+        position: FilePosition,\n+    ) -> Cancelable<Option<ModuleDescriptor>> {\n+        let source_root = db.file_source_root(position.file_id);\n+        let module_tree = db.module_tree(source_root)?;\n+        let file = db.file_syntax(position.file_id);\n+        let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n+        {\n+            Some(m) if !m.has_semi() => ModuleSource::new_inline(position.file_id, m),\n+            _ => ModuleSource::SourceFile(position.file_id),\n+        };\n+        let res = match module_tree.any_module_for_source(module_source) {\n+            None => None,\n+            Some(module_id) => Some(ModuleDescriptor {\n+                tree: module_tree,\n+                module_id,\n+            }),\n+        };\n+        Ok(res)\n+    }\n+\n+    /// Returns `mod foo;` or `mod foo {}` node whihc declared this module.\n+    /// Returns `None` for the root module\n+    pub fn parent_link_source(\n+        &self,\n+        db: &impl DescriptorDatabase,\n+    ) -> Option<(FileId, ast::ModuleNode)> {\n+        let link = self.module_id.parent_link(&self.tree)?;\n+        let file_id = link.owner(&self.tree).source(&self.tree).file_id();\n+        let src = link.bind_source(&self.tree, db);\n+        Some((file_id, src))\n+    }\n+\n+    pub fn parent(&self) -> Option<ModuleDescriptor> {\n+        let parent_id = self.module_id.parent(&self.tree)?;\n+        Some(ModuleDescriptor {\n+            tree: Arc::clone(&self.tree),\n+            module_id: parent_id,\n+        })\n+    }\n+    /// `name` is `None` for the crate's root module\n+    pub fn name(&self) -> Option<SmolStr> {\n+        let link = self.module_id.parent_link(&self.tree)?;\n+        Some(link.name(&self.tree))\n+    }\n+    pub fn child(&self, name: &str) -> Option<ModuleDescriptor> {\n+        let child_id = self.module_id.child(&self.tree, name)?;\n+        Some(ModuleDescriptor {\n+            tree: Arc::clone(&self.tree),\n+            module_id: child_id,\n+        })\n+    }\n+}\n+\n /// Phisically, rust source is organized as a set of files, but logically it is\n /// organized as a tree of modules. Usually, a single file corresponds to a\n /// single module, but it is not nessary the case.\n@@ -136,6 +210,9 @@ impl LinkId {\n     pub(crate) fn owner(self, tree: &ModuleTree) -> ModuleId {\n         tree.link(self).owner\n     }\n+    pub(crate) fn name(self, tree: &ModuleTree) -> SmolStr {\n+        tree.link(self).name.clone()\n+    }\n     pub(crate) fn bind_source<'a>(\n         self,\n         tree: &ModuleTree,"}, {"sha": "c0bed04bfa9a23485aaf2f71b3b6731ef5b4ceb3", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3b8d0c215a922eaea182d4d72f232a534de21e33/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b8d0c215a922eaea182d4d72f232a534de21e33/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=3b8d0c215a922eaea182d4d72f232a534de21e33", "patch": "@@ -21,7 +21,7 @@ use crate::{\n     db::{self, FileSyntaxQuery, SyntaxDatabase},\n     descriptors::{\n         function::{FnDescriptor, FnId},\n-        module::{ModuleSource, ModuleTree, Problem},\n+        module::{ModuleDescriptor, ModuleSource, ModuleTree, Problem},\n         DeclarationDescriptor, DescriptorDatabase,\n     },\n     input::{FilesDatabase, SourceRoot, SourceRootId, WORKSPACE},\n@@ -221,34 +221,22 @@ impl AnalysisImpl {\n         self.db.module_tree(source_root)\n     }\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let module_tree = self.module_tree(position.file_id)?;\n-        let file = self.db.file_syntax(position.file_id);\n-        let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n-        {\n-            Some(m) if !m.has_semi() => ModuleSource::new_inline(position.file_id, m),\n-            _ => ModuleSource::SourceFile(position.file_id),\n+        let descr = match ModuleDescriptor::guess_from_position(&*self.db, position)? {\n+            None => return Ok(Vec::new()),\n+            Some(it) => it,\n         };\n-\n-        let res = module_tree\n-            .modules_for_source(module_source)\n-            .into_iter()\n-            .filter_map(|module_id| {\n-                let link = module_id.parent_link(&module_tree)?;\n-                let file_id = link.owner(&module_tree).source(&module_tree).file_id();\n-                let decl = link.bind_source(&module_tree, &*self.db);\n-                let decl = decl.borrowed();\n-\n-                let decl_name = decl.name().unwrap();\n-\n-                let sym = FileSymbol {\n-                    name: decl_name.text(),\n-                    node_range: decl_name.syntax().range(),\n-                    kind: MODULE,\n-                };\n-                Some((file_id, sym))\n-            })\n-            .collect();\n-        Ok(res)\n+        let (file_id, decl) = match descr.parent_link_source(&*self.db) {\n+            None => return Ok(Vec::new()),\n+            Some(it) => it,\n+        };\n+        let decl = decl.borrowed();\n+        let decl_name = decl.name().unwrap();\n+        let sym = FileSymbol {\n+            name: decl_name.text(),\n+            node_range: decl_name.syntax().range(),\n+            kind: MODULE,\n+        };\n+        Ok(vec![(file_id, sym)])\n     }\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n         let module_tree = self.module_tree(file_id)?;"}]}