{"sha": "cbed41a174aad44e069bec09bf1e502591c132ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZWQ0MWExNzRhYWQ0NGUwNjliZWMwOWJmMWU1MDI1OTFjMTMyYWU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-05-23T11:18:20Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-06-12T11:04:33Z"}, "message": "Add destruction extents around blocks and statements in HAIR.", "tree": {"sha": "bf2845995cddb5c79ac4dfe9350cf84dbed2cda7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf2845995cddb5c79ac4dfe9350cf84dbed2cda7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbed41a174aad44e069bec09bf1e502591c132ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbed41a174aad44e069bec09bf1e502591c132ae", "html_url": "https://github.com/rust-lang/rust/commit/cbed41a174aad44e069bec09bf1e502591c132ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbed41a174aad44e069bec09bf1e502591c132ae/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "609813bbc292e32d257a2c205f783babe07a5c60", "url": "https://api.github.com/repos/rust-lang/rust/commits/609813bbc292e32d257a2c205f783babe07a5c60", "html_url": "https://github.com/rust-lang/rust/commit/609813bbc292e32d257a2c205f783babe07a5c60"}], "stats": {"total": 82, "additions": 60, "deletions": 22}, "files": [{"sha": "1933ef29b539bc16f95c8f5ef30f6cbb132dc597", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cbed41a174aad44e069bec09bf1e502591c132ae/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbed41a174aad44e069bec09bf1e502591c132ae/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=cbed41a174aad44e069bec09bf1e502591c132ae", "patch": "@@ -21,21 +21,24 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                      ast_block: &'tcx hir::Block,\n                      source_info: SourceInfo)\n                      -> BlockAnd<()> {\n-        let Block { extent, span, stmts, expr, targeted_by_break } = self.hir.mirror(ast_block);\n-        self.in_scope(extent, block, move |this| {\n-            if targeted_by_break {\n-                // This is a `break`-able block (currently only `catch { ... }`)\n-                let exit_block = this.cfg.start_new_block();\n-                let block_exit = this.in_breakable_scope(None, exit_block,\n-                                                         destination.clone(), |this| {\n+        let Block { extent, opt_destruction_extent, span, stmts, expr, targeted_by_break } =\n+            self.hir.mirror(ast_block);\n+        self.in_opt_scope(opt_destruction_extent, block, move |this| {\n+            this.in_scope(extent, block, move |this| {\n+                if targeted_by_break {\n+                    // This is a `break`-able block (currently only `catch { ... }`)\n+                    let exit_block = this.cfg.start_new_block();\n+                    let block_exit = this.in_breakable_scope(\n+                        None, exit_block, destination.clone(), |this| {\n+                            this.ast_block_stmts(destination, block, span, stmts, expr)\n+                        });\n+                    this.cfg.terminate(unpack!(block_exit), source_info,\n+                                       TerminatorKind::Goto { target: exit_block });\n+                    exit_block.unit()\n+                } else {\n                     this.ast_block_stmts(destination, block, span, stmts, expr)\n-                });\n-                this.cfg.terminate(unpack!(block_exit), source_info,\n-                                   TerminatorKind::Goto { target: exit_block });\n-                exit_block.unit()\n-            } else {\n-                this.ast_block_stmts(destination, block, span, stmts, expr)\n-            }\n+                }\n+            })\n         })\n     }\n \n@@ -67,12 +70,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let mut let_extent_stack = Vec::with_capacity(8);\n         let outer_visibility_scope = this.visibility_scope;\n         for stmt in stmts {\n-            let Stmt { span: _, kind } = this.hir.mirror(stmt);\n+            let Stmt { span: _, kind, opt_destruction_extent } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Expr { scope, expr } => {\n-                    unpack!(block = this.in_scope(scope, block, |this| {\n-                        let expr = this.hir.mirror(expr);\n-                        this.stmt_expr(block, expr)\n+                    unpack!(block = this.in_opt_scope(opt_destruction_extent, block, |this| {\n+                        this.in_scope(scope, block, |this| {\n+                            let expr = this.hir.mirror(expr);\n+                            this.stmt_expr(block, expr)\n+                        })\n                     }));\n                 }\n                 StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n@@ -89,10 +94,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n-                        unpack!(block = this.in_scope(init_scope, block, move |this| {\n-                            // FIXME #30046                              ^~~~\n-                            this.expr_into_pattern(block, pattern, init)\n-                        }));\n+                        unpack!(block = this.in_opt_scope(\n+                            opt_destruction_extent, block, move |this| {\n+                                this.in_scope(init_scope, block, move |this| {\n+                                    // FIXME #30046              ^~~~\n+                                    this.expr_into_pattern(block, pattern, init)\n+                                })\n+                            }));\n                     } else {\n                         this.visit_bindings(&pattern, &mut |this, _, _, node, span, _| {\n                             this.storage_live_binding(block, node, span);"}, {"sha": "d9c303369ccd23a2eded18ff0fc0e42d5fde2844", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cbed41a174aad44e069bec09bf1e502591c132ae/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbed41a174aad44e069bec09bf1e502591c132ae/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=cbed41a174aad44e069bec09bf1e502591c132ae", "patch": "@@ -269,6 +269,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         res\n     }\n \n+    pub fn in_opt_scope<F, R>(&mut self,\n+                              opt_extent: Option<CodeExtent>,\n+                              mut block: BasicBlock,\n+                              f: F)\n+                              -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n+    {\n+        debug!(\"in_opt_scope(opt_extent={:?}, block={:?})\", opt_extent, block);\n+        if let Some(extent) = opt_extent { self.push_scope(extent); }\n+        let rv = unpack!(block = f(self));\n+        if let Some(extent) = opt_extent {\n+            unpack!(block = self.pop_scope(extent, block));\n+        }\n+        debug!(\"in_scope: exiting opt_extent={:?} block={:?}\", opt_extent, block);\n+        block.and(rv)\n+    }\n+\n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self,"}, {"sha": "fad070ca8d8f9c5acd0fc69a351a1ef7b896bde0", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbed41a174aad44e069bec09bf1e502591c132ae/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbed41a174aad44e069bec09bf1e502591c132ae/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=cbed41a174aad44e069bec09bf1e502591c132ae", "patch": "@@ -22,9 +22,14 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n         // We have to eagerly translate the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n+        let opt_def_id = cx.tcx.hir.opt_local_def_id(self.id);\n+        let opt_destruction_extent = opt_def_id.and_then(|def_id| {\n+            cx.tcx.region_maps(def_id).opt_destruction_extent(self.id)\n+        });\n         Block {\n             targeted_by_break: self.targeted_by_break,\n             extent: CodeExtent::Misc(self.id),\n+            opt_destruction_extent: opt_destruction_extent,\n             span: self.span,\n             stmts: stmts,\n             expr: self.expr.to_ref(),\n@@ -37,7 +42,11 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 stmts: &'tcx [hir::Stmt])\n                                 -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n+    let opt_def_id = cx.tcx.hir.opt_local_def_id(block_id);\n     for (index, stmt) in stmts.iter().enumerate() {\n+        let opt_dxn_ext = opt_def_id.and_then(|def_id| {\n+            cx.tcx.region_maps(def_id).opt_destruction_extent(stmt.node.id())\n+        });\n         match stmt.node {\n             hir::StmtExpr(ref expr, id) |\n             hir::StmtSemi(ref expr, id) => {\n@@ -47,6 +56,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         scope: CodeExtent::Misc(id),\n                         expr: expr.to_ref(),\n                     },\n+                    opt_destruction_extent: opt_dxn_ext,\n                 })))\n             }\n             hir::StmtDecl(ref decl, id) => {\n@@ -69,6 +79,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 pattern: pattern,\n                                 initializer: local.init.to_ref(),\n                             },\n+                            opt_destruction_extent: opt_dxn_ext,\n                         })));\n                     }\n                 }"}, {"sha": "bb11cce748751deba568ab440df4e50dcd316ca6", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbed41a174aad44e069bec09bf1e502591c132ae/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbed41a174aad44e069bec09bf1e502591c132ae/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=cbed41a174aad44e069bec09bf1e502591c132ae", "patch": "@@ -33,6 +33,7 @@ pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPatt\n pub struct Block<'tcx> {\n     pub targeted_by_break: bool,\n     pub extent: CodeExtent,\n+    pub opt_destruction_extent: Option<CodeExtent>,\n     pub span: Span,\n     pub stmts: Vec<StmtRef<'tcx>>,\n     pub expr: Option<ExprRef<'tcx>>,\n@@ -47,6 +48,7 @@ pub enum StmtRef<'tcx> {\n pub struct Stmt<'tcx> {\n     pub span: Span,\n     pub kind: StmtKind<'tcx>,\n+    pub opt_destruction_extent: Option<CodeExtent>,\n }\n \n #[derive(Clone, Debug)]"}]}