{"sha": "88e522f921dad2f50b78f16dcd24ac256c8bf7c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZTUyMmY5MjFkYWQyZjUwYjc4ZjE2ZGNkMjRhYzI1NmM4YmY3Yzg=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-10T10:45:23Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-10T10:45:23Z"}, "message": "Use multiline in generics rather than fail", "tree": {"sha": "4d66e7330b244ce4cf00a063ef1a5df4031a200c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d66e7330b244ce4cf00a063ef1a5df4031a200c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88e522f921dad2f50b78f16dcd24ac256c8bf7c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88e522f921dad2f50b78f16dcd24ac256c8bf7c8", "html_url": "https://github.com/rust-lang/rust/commit/88e522f921dad2f50b78f16dcd24ac256c8bf7c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88e522f921dad2f50b78f16dcd24ac256c8bf7c8/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9eefc6fc8d113e80f92de53ae756cb5203e173b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eefc6fc8d113e80f92de53ae756cb5203e173b1", "html_url": "https://github.com/rust-lang/rust/commit/9eefc6fc8d113e80f92de53ae756cb5203e173b1"}], "stats": {"total": 169, "additions": 124, "deletions": 45}, "files": [{"sha": "f228bdf9d08ea54a97e74289eb530727ac719d60", "filename": "src/items.rs", "status": "modified", "additions": 124, "deletions": 45, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/88e522f921dad2f50b78f16dcd24ac256c8bf7c8/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88e522f921dad2f50b78f16dcd24ac256c8bf7c8/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=88e522f921dad2f50b78f16dcd24ac256c8bf7c8", "patch": "@@ -530,7 +530,9 @@ pub fn format_impl(context: &RewriteContext,\n     if let ast::ItemKind::Impl(_, _, _, ref generics, ref trait_ref, _, ref items) = item.node {\n         let mut result = String::new();\n         // First try to format the ref and type without a split at the 'for'.\n-        let mut ref_and_type = try_opt!(format_impl_ref_and_type(context, item, offset, false));\n+        let mut ref_and_type =\n+            format_impl_ref_and_type(context, item, offset, false)\n+                .unwrap_or(try_opt!(format_impl_ref_and_type(context, item, offset, true)));\n \n         // If there is a line break present in the first result format it again\n         // with a split at the 'for'. Skip this if there is no trait ref and\n@@ -540,10 +542,15 @@ pub fn format_impl(context: &RewriteContext,\n         }\n         result.push_str(&ref_and_type);\n \n-        let where_budget = try_opt!(context\n-                                        .config\n-                                        .max_width()\n-                                        .checked_sub(last_line_width(&result)));\n+        let where_budget = if result.contains('\\n') {\n+            context.config.max_width()\n+        } else {\n+            context\n+                .config\n+                .max_width()\n+                .checked_sub(last_line_width(&result))\n+                .unwrap_or(0)\n+        };\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n                                                              context.config.item_brace_style(),\n@@ -666,34 +673,89 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n             None => self_ty.span.lo,\n         };\n         let generics_indent = offset + last_line_width(&result);\n-        let shape = Shape::indented(generics_indent, context.config);\n-        let generics_str = try_opt!(rewrite_generics(context, generics, shape, mk_sp(lo, hi)));\n-        result.push_str(&generics_str);\n+        let shape = generics_shape_from_config(context.config,\n+                                               Shape::indented(generics_indent, context.config),\n+                                               0);\n+        let mut generics_str =\n+            try_opt!(rewrite_generics(context, generics, shape, shape.width, mk_sp(lo, hi)));\n \n         if polarity == ast::ImplPolarity::Negative {\n-            result.push_str(\" !\");\n+            generics_str.push_str(\" !\");\n         }\n+\n+        let mut retry_with_multiline = true;\n         if let Some(ref trait_ref) = *trait_ref {\n             if polarity != ast::ImplPolarity::Negative {\n-                result.push_str(\" \");\n+                generics_str.push_str(\" \");\n             }\n-            let used_space = last_line_width(&result);\n-            let budget = try_opt!(context.config.max_width().checked_sub(used_space));\n-            let indent = offset + used_space;\n-            result.push_str(&*try_opt!(trait_ref.rewrite(context, Shape::legacy(budget, indent))));\n-\n-            if split_at_for {\n-                result.push('\\n');\n-\n-                // Add indentation of one additional tab.\n-                let width = offset.block_indent + context.config.tab_spaces();\n-                let for_indent = Indent::new(0, width);\n-                result.push_str(&for_indent.to_string(context.config));\n-\n-                result.push_str(\"for\");\n+            let used_space = if generics_str.contains('\\n') {\n+                last_line_width(&generics_str)\n             } else {\n-                result.push_str(\" for\");\n+                result.len() + generics_str.len()\n+            };\n+            let budget = context\n+                .config\n+                .max_width()\n+                .checked_sub(used_space)\n+                .unwrap_or(0);\n+            let indent = offset + used_space;\n+            if let Some(trait_ref_str) = trait_ref.rewrite(context, Shape::legacy(budget, indent)) {\n+                if !trait_ref_str.contains('\\n') {\n+                    result.push_str(&generics_str);\n+                    result.push_str(&trait_ref_str);\n+                    if split_at_for {\n+                        result.push('\\n');\n+                        // Add indentation of one additional tab.\n+                        result.push_str(&offset\n+                                            .block_indent(context.config)\n+                                            .to_string(context.config));\n+                        result.push_str(\"for\");\n+                    } else {\n+                        result.push_str(\" for\");\n+                    }\n+                    retry_with_multiline = false;\n+                }\n+            }\n+            if retry_with_multiline {\n+                let mut generics_str =\n+                    try_opt!(rewrite_generics(context, generics, shape, 0, mk_sp(lo, hi)));\n+                if polarity == ast::ImplPolarity::Negative {\n+                    generics_str.push_str(\" !\");\n+                } else {\n+                    generics_str.push_str(\" \");\n+                }\n+                let used_space = if generics_str.contains('\\n') {\n+                    last_line_width(&generics_str)\n+                } else {\n+                    result.len() + generics_str.len()\n+                };\n+                let budget = context\n+                    .config\n+                    .max_width()\n+                    .checked_sub(used_space)\n+                    .unwrap_or(0);\n+                let indent = offset + used_space;\n+                if let Some(trait_ref_str) =\n+                    trait_ref.rewrite(context, Shape::legacy(budget, indent)) {\n+                    result.push_str(&generics_str);\n+                    result.push_str(&trait_ref_str);\n+                    if split_at_for {\n+                        result.push('\\n');\n+                        // Add indentation of one additional tab.\n+                        result.push_str(&offset\n+                                            .block_indent(context.config)\n+                                            .to_string(context.config));\n+                        result.push_str(\"for\");\n+                    } else {\n+                        result.push_str(\" for\");\n+                    }\n+                }\n             }\n+        } else {\n+            if polarity == ast::ImplPolarity::Negative {\n+                generics_str.push_str(\" \");\n+            }\n+            result.push_str(&generics_str);\n         }\n \n         let mut used_space = last_line_width(&result);\n@@ -709,7 +771,7 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n \n         // 1 = space before the type.\n         let budget = try_opt!(context.config.max_width().checked_sub(used_space + 1));\n-        let indent = offset + result.len() + 1;\n+        let indent = offset + last_line_width(&result) + 1;\n         let self_ty_str = self_ty.rewrite(context, Shape::legacy(budget, indent));\n         if let Some(self_ty_str) = self_ty_str {\n             result.push_str(\" \");\n@@ -778,9 +840,14 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         let body_lo = context.codemap.span_after(item.span, \"{\");\n \n         let generics_indent = offset + last_line_width(&result);\n-        let shape = Shape::indented(generics_indent, context.config);\n-        let generics_str =\n-            try_opt!(rewrite_generics(context, generics, shape, mk_sp(item.span.lo, body_lo)));\n+        let shape = generics_shape_from_config(context.config,\n+                                               Shape::indented(generics_indent, context.config),\n+                                               0);\n+        let generics_str = try_opt!(rewrite_generics(context,\n+                                                     generics,\n+                                                     shape,\n+                                                     shape.width,\n+                                                     mk_sp(item.span.lo, body_lo)));\n         result.push_str(&generics_str);\n \n         let trait_bound_str =\n@@ -1025,9 +1092,15 @@ fn format_tuple_struct(context: &RewriteContext,\n     let where_clause_str = match generics {\n         Some(generics) => {\n             let generics_indent = offset + last_line_width(&header_str);\n-            let shape = Shape::indented(generics_indent, context.config);\n-            let generics_str =\n-                try_opt!(rewrite_generics(context, generics, shape, mk_sp(span.lo, body_lo)));\n+            let shape = generics_shape_from_config(context.config,\n+                                                   Shape::indented(generics_indent,\n+                                                                   context.config),\n+                                                   0);\n+            let generics_str = try_opt!(rewrite_generics(context,\n+                                                         generics,\n+                                                         shape,\n+                                                         shape.width,\n+                                                         mk_sp(span.lo, body_lo)));\n             result.push_str(&generics_str);\n \n             let where_budget = try_opt!(context\n@@ -1156,8 +1229,13 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n \n     let generics_indent = indent + result.len();\n     let generics_span = mk_sp(context.codemap.span_after(span, \"type\"), ty.span.lo);\n-    let shape = try_opt!(Shape::indented(generics_indent, context.config).sub_width(\" =\".len()));\n-    let generics_str = try_opt!(rewrite_generics(context, generics, shape, generics_span));\n+    let shape = generics_shape_from_config(context.config,\n+                                           try_opt!(Shape::indented(generics_indent,\n+                                                                    context.config)\n+                                                        .sub_width(\" =\".len())),\n+                                           0);\n+    let generics_str =\n+        try_opt!(rewrite_generics(context, generics, shape, shape.width, generics_span));\n \n     result.push_str(&generics_str);\n \n@@ -1635,8 +1713,11 @@ fn rewrite_fn_base(context: &RewriteContext,\n     // Generics.\n     let generics_indent = indent + last_line_width(&result);\n     let generics_span = mk_sp(span.lo, span_for_return(&fd.output).lo);\n-    let shape = Shape::indented(generics_indent, context.config);\n-    let generics_str = try_opt!(rewrite_generics(context, generics, shape, generics_span));\n+    let shape = generics_shape_from_config(context.config,\n+                                           Shape::indented(generics_indent, context.config),\n+                                           0);\n+    let generics_str =\n+        try_opt!(rewrite_generics(context, generics, shape, shape.width, generics_span));\n     result.push_str(&generics_str);\n \n     let snuggle_angle_bracket = generics_str\n@@ -2101,6 +2182,7 @@ fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause) -> bool {\n fn rewrite_generics(context: &RewriteContext,\n                     generics: &ast::Generics,\n                     shape: Shape,\n+                    one_line_width: usize,\n                     span: Span)\n                     -> Option<String> {\n     // FIXME: convert bounds to where clauses where they get too big or if\n@@ -2111,13 +2193,9 @@ fn rewrite_generics(context: &RewriteContext,\n         return Some(String::new());\n     }\n \n-    let generics_shape = generics_shape_from_config(context.config, shape, 0);\n     // Strings for the generics.\n-    let lt_strs = lifetimes\n-        .iter()\n-        .map(|lt| lt.rewrite(context, generics_shape));\n-    let ty_strs = tys.iter()\n-        .map(|ty_param| ty_param.rewrite(context, generics_shape));\n+    let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(context, shape));\n+    let ty_strs = tys.iter().map(|ty_param| ty_param.rewrite(context, shape));\n \n     // Extract comments between generics.\n     let lt_spans = lifetimes.iter().map(|l| {\n@@ -2139,7 +2217,7 @@ fn rewrite_generics(context: &RewriteContext,\n                              |&(_, ref str)| str.clone(),\n                              context.codemap.span_after(span, \"<\"),\n                              span.hi);\n-    format_generics_item_list(context, items, generics_shape, generics_shape.width)\n+    format_generics_item_list(context, items, shape, one_line_width)\n }\n \n pub fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize) -> Shape {\n@@ -2385,8 +2463,9 @@ fn format_generics(context: &RewriteContext,\n                    offset: Indent,\n                    span: Span)\n                    -> Option<String> {\n-    let shape = Shape::indented(offset, context.config);\n-    let mut result = try_opt!(rewrite_generics(context, generics, shape, span));\n+    let shape =\n+        generics_shape_from_config(context.config, Shape::indented(offset, context.config), 0);\n+    let mut result = try_opt!(rewrite_generics(context, generics, shape, shape.width, span));\n \n     if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n         let budget = try_opt!(context"}]}