{"sha": "50576420f559be3c681e6833327845d6cf3217b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNTc2NDIwZjU1OWJlM2M2ODFlNjgzMzMyNzg0NWQ2Y2YzMjE3YjQ=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-24T11:27:38Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-12-12T19:35:15Z"}, "message": "BTreeMap: clarify comments and panics surrounding choose_parent_kv", "tree": {"sha": "a04e04954c33e7ca81959b2665fe55e00ef3e2f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a04e04954c33e7ca81959b2665fe55e00ef3e2f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50576420f559be3c681e6833327845d6cf3217b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50576420f559be3c681e6833327845d6cf3217b4", "html_url": "https://github.com/rust-lang/rust/commit/50576420f559be3c681e6833327845d6cf3217b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50576420f559be3c681e6833327845d6cf3217b4/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c5c4aa00203b6a5aa2352d16c3d8e4fb1ad23ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c5c4aa00203b6a5aa2352d16c3d8e4fb1ad23ee", "html_url": "https://github.com/rust-lang/rust/commit/4c5c4aa00203b6a5aa2352d16c3d8e4fb1ad23ee"}], "stats": {"total": 26, "additions": 14, "deletions": 12}, "files": [{"sha": "588066f9fec50ebc6a4564b08bf2db3ee8e12863", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50576420f559be3c681e6833327845d6cf3217b4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50576420f559be3c681e6833327845d6cf3217b4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=50576420f559be3c681e6833327845d6cf3217b4", "patch": "@@ -1282,30 +1282,32 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Chooses a balancing context involving the node as a child, thus between\n     /// the KV immediately to the left or to the right in the parent node.\n     /// Returns an `Err` if there is no parent.\n+    /// Panics if the parent is empty.\n     ///\n-    /// This method optimizes for a node that has fewer elements than its left\n-    /// and right siblings, if they exist, by preferring the left parent KV.\n-    /// Merging with the left sibling is faster, since we only need to move\n+    /// Prefers the left side, to be optimal if the given node is somehow\n+    /// underfull, meaning here only that it has fewer elements than its left\n+    /// sibling and than its right sibling, if they exist. In that case,\n+    /// merging with the left sibling is faster, since we only need to move\n     /// the node's N elements, instead of shifting them to the right and moving\n     /// more than N elements in front. Stealing from the left sibling is also\n     /// typically faster, since we only need to shift the node's N elements to\n     /// the right, instead of shifting at least N of the sibling's elements to\n     /// the left.\n     pub fn choose_parent_kv(self) -> Result<LeftOrRight<BalancingContext<'a, K, V>>, Self> {\n         match unsafe { ptr::read(&self) }.ascend() {\n-            Ok(parent) => match parent.left_kv() {\n+            Ok(parent_edge) => match parent_edge.left_kv() {\n                 Ok(left_parent_kv) => Ok(LeftOrRight::Left(BalancingContext {\n                     parent: unsafe { ptr::read(&left_parent_kv) },\n                     left_child: left_parent_kv.left_edge().descend(),\n                     right_child: self,\n                 })),\n-                Err(parent) => match parent.right_kv() {\n+                Err(parent_edge) => match parent_edge.right_kv() {\n                     Ok(right_parent_kv) => Ok(LeftOrRight::Right(BalancingContext {\n                         parent: unsafe { ptr::read(&right_parent_kv) },\n                         left_child: self,\n                         right_child: right_parent_kv.right_edge().descend(),\n                     })),\n-                    Err(_) => unreachable!(\"empty non-root node\"),\n+                    Err(_) => unreachable!(\"empty internal node\"),\n                 },\n             },\n             Err(root) => Err(root),"}, {"sha": "d8a0d51f28a9e5647ca2c062b552d2130565ce9b", "filename": "library/alloc/src/collections/btree/remove.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50576420f559be3c681e6833327845d6cf3217b4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50576420f559be3c681e6833327845d6cf3217b4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs?ref=50576420f559be3c681e6833327845d6cf3217b4", "patch": "@@ -55,12 +55,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             pos = unsafe { new_pos.cast_to_leaf_unchecked() };\n \n             // Only if we merged, the parent (if any) has shrunk, but skipping\n-            // the following step does not pay off in benchmarks.\n+            // the following step otherwise does not pay off in benchmarks.\n             //\n             // SAFETY: We won't destroy or rearrange the leaf where `pos` is at\n             // by handling its parent recursively; at worst we will destroy or\n             // rearrange the parent through the grandparent, thus change the\n-            // leaf's parent pointer.\n+            // link to the parent inside the leaf.\n             if let Ok(parent) = unsafe { pos.reborrow_mut() }.into_node().ascend() {\n                 parent.into_node().handle_shrunk_node_recursively(handle_emptied_internal_root);\n             }\n@@ -92,8 +92,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Stocks up a possibly underfull internal node, recursively.\n-    /// Climbs up until it reaches an ancestor that has elements to spare or the root.\n+    /// Stocks up a possibly underfull internal node and its ancestors,\n+    /// until it reaches an ancestor that has elements to spare or is the root.\n     fn handle_shrunk_node_recursively<F: FnOnce()>(mut self, handle_emptied_internal_root: F) {\n         loop {\n             self = match self.len() {\n@@ -124,7 +124,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     ) -> Option<NodeRef<marker::Mut<'a>, K, V, marker::Internal>> {\n         match self.forget_type().choose_parent_kv() {\n             Ok(Left(left_parent_kv)) => {\n-                debug_assert!(left_parent_kv.right_child_len() == MIN_LEN - 1);\n+                debug_assert_eq!(left_parent_kv.right_child_len(), MIN_LEN - 1);\n                 if left_parent_kv.can_merge() {\n                     let pos = left_parent_kv.merge(None);\n                     let parent_edge = unsafe { unwrap_unchecked(pos.into_node().ascend().ok()) };\n@@ -136,7 +136,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n                 }\n             }\n             Ok(Right(right_parent_kv)) => {\n-                debug_assert!(right_parent_kv.left_child_len() == MIN_LEN - 1);\n+                debug_assert_eq!(right_parent_kv.left_child_len(), MIN_LEN - 1);\n                 if right_parent_kv.can_merge() {\n                     let pos = right_parent_kv.merge(None);\n                     let parent_edge = unsafe { unwrap_unchecked(pos.into_node().ascend().ok()) };"}]}