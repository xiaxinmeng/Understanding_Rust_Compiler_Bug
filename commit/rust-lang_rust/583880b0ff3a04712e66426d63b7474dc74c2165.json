{"sha": "583880b0ff3a04712e66426d63b7474dc74c2165", "node_id": "C_kwDOAAsO6NoAKDU4Mzg4MGIwZmYzYTA0NzEyZTY2NDI2ZDYzYjc0NzRkYzc0YzIxNjU", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-05-05T15:03:51Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-05-18T09:42:43Z"}, "message": "Move logic for making potentially remapped paths absolute into helper method.", "tree": {"sha": "2896d3e1759343360867d10150c4ed3dbb89dddd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2896d3e1759343360867d10150c4ed3dbb89dddd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/583880b0ff3a04712e66426d63b7474dc74c2165", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/583880b0ff3a04712e66426d63b7474dc74c2165", "html_url": "https://github.com/rust-lang/rust/commit/583880b0ff3a04712e66426d63b7474dc74c2165", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/583880b0ff3a04712e66426d63b7474dc74c2165/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90fce805a35abd58b779cf7cabef533d56f16788", "url": "https://api.github.com/repos/rust-lang/rust/commits/90fce805a35abd58b779cf7cabef533d56f16788", "html_url": "https://github.com/rust-lang/rust/commit/90fce805a35abd58b779cf7cabef533d56f16788"}], "stats": {"total": 172, "additions": 108, "deletions": 64}, "files": [{"sha": "a382209e2067036f5f52a8ff592dc193672a177e", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 29, "deletions": 64, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/583880b0ff3a04712e66426d63b7474dc74c2165/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/583880b0ff3a04712e66426d63b7474dc74c2165/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=583880b0ff3a04712e66426d63b7474dc74c2165", "patch": "@@ -33,18 +33,14 @@ use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n use rustc_session::cstore::{ForeignModule, LinkagePreference, NativeLib};\n+use rustc_span::hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{\n     self, DebuggerVisualizerFile, ExternalSource, FileName, SourceFile, Span, SyntaxContext,\n };\n-use rustc_span::{\n-    hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind},\n-    RealFileName,\n-};\n use rustc_target::abi::VariantIdx;\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n-use std::path::Path;\n use tracing::{debug, trace};\n \n pub(super) struct EncodeContext<'a, 'tcx> {\n@@ -490,6 +486,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // is done.\n         let required_source_files = self.required_source_files.take().unwrap();\n \n+        let working_directory = &self.tcx.sess.opts.working_dir;\n+\n         let adapted = all_source_files\n             .iter()\n             .enumerate()\n@@ -502,76 +500,43 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 (!source_file.is_imported() || self.is_proc_macro)\n             })\n             .map(|(_, source_file)| {\n-                let mut adapted = match source_file.name {\n-                    FileName::Real(ref realname) => {\n-                        let mut adapted = (**source_file).clone();\n-                        adapted.name = FileName::Real(match realname {\n-                            RealFileName::LocalPath(path_to_file) => {\n-                                // Prepend path of working directory onto potentially\n-                                // relative paths, because they could become relative\n-                                // to a wrong directory.\n-                                // We include `working_dir` as part of the crate hash,\n-                                // so it's okay for us to use it as part of the encoded\n-                                // metadata.\n-                                let working_dir = &self.tcx.sess.opts.working_dir;\n-                                match working_dir {\n-                                    RealFileName::LocalPath(absolute) => {\n-                                        // Although neither working_dir or the file name were subject\n-                                        // to path remapping, the concatenation between the two may\n-                                        // be. Hence we need to do a remapping here.\n-                                        let joined = Path::new(absolute).join(path_to_file);\n-                                        let (joined, remapped) =\n-                                            source_map.path_mapping().map_prefix(joined);\n-                                        if remapped {\n-                                            RealFileName::Remapped {\n-                                                local_path: None,\n-                                                virtual_name: joined,\n-                                            }\n-                                        } else {\n-                                            RealFileName::LocalPath(joined)\n-                                        }\n-                                    }\n-                                    RealFileName::Remapped { local_path: _, virtual_name } => {\n-                                        // If working_dir has been remapped, then we emit\n-                                        // Remapped variant as the expanded path won't be valid\n-                                        RealFileName::Remapped {\n-                                            local_path: None,\n-                                            virtual_name: Path::new(virtual_name)\n-                                                .join(path_to_file),\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            RealFileName::Remapped { local_path: _, virtual_name } => {\n-                                RealFileName::Remapped {\n-                                    // We do not want any local path to be exported into metadata\n-                                    local_path: None,\n-                                    virtual_name: virtual_name.clone(),\n-                                }\n-                            }\n-                        });\n-                        adapted.name_hash = {\n-                            let mut hasher: StableHasher = StableHasher::new();\n-                            adapted.name.hash(&mut hasher);\n-                            hasher.finish::<u128>()\n-                        };\n-                        Lrc::new(adapted)\n+                match source_file.name {\n+                    FileName::Real(ref original_file_name) => {\n+                        let adapted_file_name =\n+                            source_map.path_mapping().to_embeddable_absolute_path(\n+                                original_file_name.clone(),\n+                                working_directory,\n+                            );\n+\n+                        if adapted_file_name != *original_file_name {\n+                            let mut adapted: SourceFile = (**source_file).clone();\n+                            adapted.name = FileName::Real(adapted_file_name);\n+                            adapted.name_hash = {\n+                                let mut hasher: StableHasher = StableHasher::new();\n+                                adapted.name.hash(&mut hasher);\n+                                hasher.finish::<u128>()\n+                            };\n+                            Lrc::new(adapted)\n+                        } else {\n+                            // Nothing to adapt\n+                            source_file.clone()\n+                        }\n                     }\n-\n                     // expanded code, not from a file\n                     _ => source_file.clone(),\n-                };\n-\n+                }\n+            })\n+            .map(|mut source_file| {\n                 // We're serializing this `SourceFile` into our crate metadata,\n                 // so mark it as coming from this crate.\n                 // This also ensures that we don't try to deserialize the\n                 // `CrateNum` for a proc-macro dependency - since proc macro\n                 // dependencies aren't loaded when we deserialize a proc-macro,\n                 // trying to remap the `CrateNum` would fail.\n                 if self.is_proc_macro {\n-                    Lrc::make_mut(&mut adapted).cnum = LOCAL_CRATE;\n+                    Lrc::make_mut(&mut source_file).cnum = LOCAL_CRATE;\n                 }\n-                adapted\n+                source_file\n             })\n             .collect::<Vec<_>>();\n "}, {"sha": "44aa9f72809f658548fd50d1f5bbd1bffd7ead62", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/583880b0ff3a04712e66426d63b7474dc74c2165/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/583880b0ff3a04712e66426d63b7474dc74c2165/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=583880b0ff3a04712e66426d63b7474dc74c2165", "patch": "@@ -1155,4 +1155,83 @@ impl FilePathMapping {\n             other => (other.clone(), false),\n         }\n     }\n+\n+    /// Expand a relative path to an absolute path with remapping taken into account.\n+    /// Use this when absolute paths are required (e.g. debuginfo or crate metadata).\n+    ///\n+    /// The resulting `RealFileName` will have its `local_path` portion erased if\n+    /// possible (i.e. if there's also a remapped path).\n+    pub fn to_embeddable_absolute_path(\n+        &self,\n+        file_path: RealFileName,\n+        working_directory: &RealFileName,\n+    ) -> RealFileName {\n+        match file_path {\n+            // Anything that's already remapped we don't modify, except for erasing\n+            // the `local_path` portion.\n+            RealFileName::Remapped { local_path: _, virtual_name } => {\n+                RealFileName::Remapped {\n+                    // We do not want any local path to be exported into metadata\n+                    local_path: None,\n+                    // We use the remapped name verbatim, even if it looks like a relative\n+                    // path. The assumption is that the user doesn't want us to further\n+                    // process paths that have gone through remapping.\n+                    virtual_name,\n+                }\n+            }\n+\n+            RealFileName::LocalPath(unmapped_file_path) => {\n+                // If no remapping has been applied yet, try to do so\n+                let (new_path, was_remapped) = self.map_prefix(unmapped_file_path);\n+                if was_remapped {\n+                    // It was remapped, so don't modify further\n+                    return RealFileName::Remapped { local_path: None, virtual_name: new_path };\n+                }\n+\n+                if new_path.is_absolute() {\n+                    // No remapping has applied to this path and it is absolute,\n+                    // so the working directory cannot influence it either, so\n+                    // we are done.\n+                    return RealFileName::LocalPath(new_path);\n+                }\n+\n+                debug_assert!(new_path.is_relative());\n+                let unmapped_file_path_rel = new_path;\n+\n+                match working_directory {\n+                    RealFileName::LocalPath(unmapped_working_dir_abs) => {\n+                        let file_path_abs = unmapped_working_dir_abs.join(unmapped_file_path_rel);\n+\n+                        // Although neither `working_directory` nor the file name were subject\n+                        // to path remapping, the concatenation between the two may be. Hence\n+                        // we need to do a remapping here.\n+                        let (file_path_abs, was_remapped) = self.map_prefix(file_path_abs);\n+                        if was_remapped {\n+                            RealFileName::Remapped {\n+                                // Erase the actual path\n+                                local_path: None,\n+                                virtual_name: file_path_abs,\n+                            }\n+                        } else {\n+                            // No kind of remapping applied to this path, so\n+                            // we leave it as it is.\n+                            RealFileName::LocalPath(file_path_abs)\n+                        }\n+                    }\n+                    RealFileName::Remapped {\n+                        local_path: _,\n+                        virtual_name: remapped_working_dir_abs,\n+                    } => {\n+                        // If working_directory has been remapped, then we emit\n+                        // Remapped variant as the expanded path won't be valid\n+                        RealFileName::Remapped {\n+                            local_path: None,\n+                            virtual_name: Path::new(remapped_working_dir_abs)\n+                                .join(unmapped_file_path_rel),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n }"}]}