{"sha": "ba801577b909cf1123846bb425d5f489db8325b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhODAxNTc3YjkwOWNmMTEyMzg0NmJiNDI1ZDVmNDg5ZGI4MzI1Yjg=", "commit": {"author": {"name": "Adrien T\u00e9tar", "email": "adri-from-59@hotmail.fr", "date": "2014-01-02T12:24:49Z"}, "committer": {"name": "Adrien T\u00e9tar", "email": "adri-from-59@hotmail.fr", "date": "2014-01-04T12:06:54Z"}, "message": "doc: un-xfail conditions tutorial", "tree": {"sha": "0357a4bc008883282f7bd0afca66a26c1c7e46d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0357a4bc008883282f7bd0afca66a26c1c7e46d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba801577b909cf1123846bb425d5f489db8325b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba801577b909cf1123846bb425d5f489db8325b8", "html_url": "https://github.com/rust-lang/rust/commit/ba801577b909cf1123846bb425d5f489db8325b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba801577b909cf1123846bb425d5f489db8325b8/comments", "author": {"login": "adrientetar", "id": 1250894, "node_id": "MDQ6VXNlcjEyNTA4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1250894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adrientetar", "html_url": "https://github.com/adrientetar", "followers_url": "https://api.github.com/users/adrientetar/followers", "following_url": "https://api.github.com/users/adrientetar/following{/other_user}", "gists_url": "https://api.github.com/users/adrientetar/gists{/gist_id}", "starred_url": "https://api.github.com/users/adrientetar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adrientetar/subscriptions", "organizations_url": "https://api.github.com/users/adrientetar/orgs", "repos_url": "https://api.github.com/users/adrientetar/repos", "events_url": "https://api.github.com/users/adrientetar/events{/privacy}", "received_events_url": "https://api.github.com/users/adrientetar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "adrientetar", "id": 1250894, "node_id": "MDQ6VXNlcjEyNTA4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1250894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adrientetar", "html_url": "https://github.com/adrientetar", "followers_url": "https://api.github.com/users/adrientetar/followers", "following_url": "https://api.github.com/users/adrientetar/following{/other_user}", "gists_url": "https://api.github.com/users/adrientetar/gists{/gist_id}", "starred_url": "https://api.github.com/users/adrientetar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adrientetar/subscriptions", "organizations_url": "https://api.github.com/users/adrientetar/orgs", "repos_url": "https://api.github.com/users/adrientetar/repos", "events_url": "https://api.github.com/users/adrientetar/events{/privacy}", "received_events_url": "https://api.github.com/users/adrientetar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbdf6458112f33c0c72ebdedb1f1c93bd737d3a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbdf6458112f33c0c72ebdedb1f1c93bd737d3a8", "html_url": "https://github.com/rust-lang/rust/commit/bbdf6458112f33c0c72ebdedb1f1c93bd737d3a8"}], "stats": {"total": 78, "additions": 42, "deletions": 36}, "files": [{"sha": "52894c03e3ced8517f131ce0c257a00a6003cf58", "filename": "doc/tutorial-conditions.md", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ba801577b909cf1123846bb425d5f489db8325b8/doc%2Ftutorial-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba801577b909cf1123846bb425d5f489db8325b8/doc%2Ftutorial-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-conditions.md?ref=ba801577b909cf1123846bb425d5f489db8325b8", "patch": "@@ -43,12 +43,13 @@ $ ./example numbers.txt\n \n An example program that does this task reads like this:\n \n-~~~~{.xfail-test}\n+~~~~\n # #[allow(unused_imports)];\n+# extern mod extra;\n use std::io::buffered::BufferedReader;\n-use std::io::fs::File;\n+use std::io::File;\n # mod BufferedReader {\n-#     use std::io::fs::File;\n+#     use std::io::File;\n #     use std::io::mem::MemReader;\n #     use std::io::buffered::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n@@ -71,10 +72,9 @@ fn main() {\n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n \n-    let args = std::os::args();\n-\n     // Path takes a generic by-value, rather than by reference\n-    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+#    let _g = std::io::ignore_io_error();\n+    let path = Path::new(&\"foo.txt\");\n     let mut reader = BufferedReader::new(File::open(&path));\n \n     // 1. Iterate over the lines of our file.\n@@ -242,13 +242,14 @@ If the example is rewritten to use failure, these error cases can be trapped.\n In this rewriting, failures are trapped by placing the I/O logic in a sub-task,\n and trapping its exit status using `task::try`:\n \n-~~~~{.xfail-test}\n+~~~~\n # #[allow(unused_imports)];\n+# extern mod extra;\n use std::io::buffered::BufferedReader;\n-use std::io::fs::File;\n+use std::io::File;\n use std::task;\n # mod BufferedReader {\n-#     use std::io::fs::File;\n+#     use std::io::File;\n #     use std::io::mem::MemReader;\n #     use std::io::buffered::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n@@ -280,8 +281,8 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let args = std::os::args();\n-    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+#    let _g = std::io::ignore_io_error();\n+    let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n     for line in reader.lines() {\n@@ -346,12 +347,13 @@ If no handler is found, `Condition::raise` will fail the task with an appropriat\n Rewriting the example to use a condition in place of ignoring malformed lines makes it slightly longer,\n but similarly clear as the version that used `fail!` in the logic where the error occurs:\n \n-~~~~{.xfail-test}\n+~~~~\n # #[allow(unused_imports)];\n+# extern mod extra;\n use std::io::buffered::BufferedReader;\n-use std::io::fs::File;\n+use std::io::File;\n # mod BufferedReader {\n-#     use std::io::fs::File;\n+#     use std::io::File;\n #     use std::io::mem::MemReader;\n #     use std::io::buffered::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n@@ -378,8 +380,8 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let args = std::os::args();\n-    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+#    let _g = std::io::ignore_io_error();\n+    let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n     for line in reader.lines() {\n@@ -415,12 +417,13 @@ To trap a condition, use `Condition::trap` in some caller of the site that calls\n For example, this version of the program traps the `malformed_line` condition\n and replaces bad input lines with the pair `(-1,-1)`:\n \n-~~~~{.xfail-test}\n+~~~~\n # #[allow(unused_imports)];\n+# extern mod extra;\n use std::io::buffered::BufferedReader;\n-use std::io::fs::File;\n+use std::io::File;\n # mod BufferedReader {\n-#     use std::io::fs::File;\n+#     use std::io::File;\n #     use std::io::mem::MemReader;\n #     use std::io::buffered::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n@@ -452,8 +455,8 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let args = std::os::args();\n-    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+#    let _g = std::io::ignore_io_error();\n+    let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n     for line in reader.lines() {\n@@ -490,12 +493,13 @@ In the example program, the first form of the `malformed_line` API implicitly as\n This assumption may not be correct; some callers may wish to skip malformed lines, for example.\n Changing the condition's return type from `(int,int)` to `Option<(int,int)>` will suffice to support this type of recovery:\n \n-~~~~{.xfail-test}\n+~~~~\n # #[allow(unused_imports)];\n+# extern mod extra;\n use std::io::buffered::BufferedReader;\n-use std::io::fs::File;\n+use std::io::File;\n # mod BufferedReader {\n-#     use std::io::fs::File;\n+#     use std::io::File;\n #     use std::io::mem::MemReader;\n #     use std::io::buffered::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n@@ -528,8 +532,8 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let args = std::os::args();\n-    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+#    let _g = std::io::ignore_io_error();\n+    let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n     for line in reader.lines() {\n@@ -575,12 +579,13 @@ until all relevant combinations encountered in practice are encoded.\n In the example, suppose a third possible recovery form arose: reusing the previous value read.\n This can be encoded in the handler API by introducing a helper type: `enum MalformedLineFix`.\n \n-~~~~{.xfail-test}\n+~~~~\n # #[allow(unused_imports)];\n+# extern mod extra;\n use std::io::buffered::BufferedReader;\n-use std::io::fs::File;\n+use std::io::File;\n # mod BufferedReader {\n-#     use std::io::fs::File;\n+#     use std::io::File;\n #     use std::io::mem::MemReader;\n #     use std::io::buffered::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n@@ -622,8 +627,8 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let args = std::os::args();\n-    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+#    let _g = std::io::ignore_io_error();\n+    let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n     for line in reader.lines() {\n@@ -699,12 +704,13 @@ task <unnamed> failed at 'called `Option::unwrap()` on a `None` value', .../libs\n To make the program robust &mdash; or at least flexible &mdash; in the face of this potential failure,\n a second condition and a helper function will suffice:\n \n-~~~~{.xfail-test}\n+~~~~\n # #[allow(unused_imports)];\n+# extern mod extra;\n use std::io::buffered::BufferedReader;\n-use std::io::fs::File;\n+use std::io::File;\n # mod BufferedReader {\n-#     use std::io::fs::File;\n+#     use std::io::File;\n #     use std::io::mem::MemReader;\n #     use std::io::buffered::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n@@ -760,8 +766,8 @@ fn parse_int(x: &str) -> int {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let args = std::os::args();\n-    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+#    let _g = std::io::ignore_io_error();\n+    let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n     for line in reader.lines() {"}]}