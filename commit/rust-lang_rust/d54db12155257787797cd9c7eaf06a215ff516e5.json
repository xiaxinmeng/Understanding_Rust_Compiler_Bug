{"sha": "d54db12155257787797cd9c7eaf06a215ff516e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NGRiMTIxNTUyNTc3ODc3OTdjZDljN2VhZjA2YTIxNWZmNTE2ZTU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-15T01:17:18Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-15T23:20:33Z"}, "message": "rustc: Implement automatic reference for method receivers", "tree": {"sha": "a0b604747b19f73d818a54ba774c48b6ee3800f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0b604747b19f73d818a54ba774c48b6ee3800f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d54db12155257787797cd9c7eaf06a215ff516e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d54db12155257787797cd9c7eaf06a215ff516e5", "html_url": "https://github.com/rust-lang/rust/commit/d54db12155257787797cd9c7eaf06a215ff516e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d54db12155257787797cd9c7eaf06a215ff516e5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe9d07dda6e884df9873376c85941cc766dbd1dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe9d07dda6e884df9873376c85941cc766dbd1dc", "html_url": "https://github.com/rust-lang/rust/commit/fe9d07dda6e884df9873376c85941cc766dbd1dc"}], "stats": {"total": 232, "additions": 170, "deletions": 62}, "files": [{"sha": "b509880ab5fb38ccf3cdc0e8e688faaa7ac11ed6", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -236,7 +236,8 @@ struct mem_categorization_ctxt {\n \n impl &mem_categorization_ctxt {\n     fn cat_borrow_of_expr(expr: @ast::expr) -> cmt {\n-        // a borrowed expression must be either an @, ~, or a @vec, ~vec\n+        // Any expression can be borrowed (to account for auto-ref on method\n+        // receivers), but @, ~, @vec, and ~vec are handled specially.\n         let expr_ty = ty::expr_ty(self.tcx, expr);\n         match ty::get(expr_ty).struct {\n           ty::ty_evec(*) | ty::ty_estr(*) => {\n@@ -255,10 +256,7 @@ impl &mem_categorization_ctxt {\n           */\n \n           _ => {\n-            self.tcx.sess.span_bug(\n-                expr.span,\n-                fmt!{\"Borrowing of non-derefable type `%s`\",\n-                     ty_to_str(self.tcx, expr_ty)});\n+            self.cat_rvalue(expr, expr_ty)\n           }\n         }\n     }"}, {"sha": "2734fa85ae611a189debf5012eaf948e3d92d9e4", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -3056,9 +3056,15 @@ fn adapt_borrowed_value(lv: lval_result,\n       }\n \n       _ => {\n-        bcx.tcx().sess.span_bug(\n-            e.span, fmt!{\"cannot borrow a value of type %s\",\n-                         ppaux::ty_to_str(bcx.tcx(), e_ty)});\n+        // Just take a reference. This is basically like trans_addr_of.\n+        let mut {bcx, val, kind} = trans_temp_lval(bcx, e);\n+        let is_immediate = ty::type_is_immediate(e_ty);\n+        if (kind == lv_temporary && is_immediate) || kind == lv_owned_imm {\n+            val = do_spill(bcx, val, e_ty);\n+        }\n+        return {lv: {bcx: bcx, val: val, kind: lv_temporary},\n+                ty: ty::mk_rptr(bcx.tcx(), ty::re_static,\n+                                {ty: e_ty, mutbl: ast::m_imm})};\n       }\n     }\n }"}, {"sha": "6e45762eca6fa8e50d81f25d33a5da6e605a3d8d", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 107, "deletions": 43, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -11,13 +11,21 @@ import syntax::ast_map::node_id_to_str;\n import syntax::ast_util::{dummy_sp, new_def_hash};\n import dvec::{DVec, dvec};\n \n+enum method_lookup_mode {\n+    subtyping_mode,\n+    assignability_mode,\n+    immutable_reference_mode,\n+    mutable_reference_mode\n+}\n+\n type candidate = {\n-    self_ty: ty::t,          // type of a in a.b()\n-    self_substs: ty::substs, // values for any tvars def'd on the class\n-    rcvr_ty: ty::t,          // type of receiver in the method def\n-    n_tps_m: uint,           // number of tvars defined on the method\n-    fty: ty::t,              // type of the method\n-    entry: method_map_entry\n+    self_ty: ty::t,             // type of a in a.b()\n+    self_substs: ty::substs,    // values for any tvars def'd on the class\n+    rcvr_ty: ty::t,             // type of receiver in the method def\n+    n_tps_m: uint,              // number of tvars defined on the method\n+    fty: ty::t,                 // type of the method\n+    entry: method_map_entry,\n+    mode: method_lookup_mode    // the mode we used\n };\n \n fn transform_self_type_for_method\n@@ -141,16 +149,33 @@ class lookup {\n             // it.\n             if self.candidates.len() > 0u { break; }\n \n-            // Look for inherent methods.\n+            // Look for inherent and extension methods, using subtyping.\n             self.add_inherent_and_extension_candidates\n-                (optional_inherent_methods, false);\n+                (optional_inherent_methods, subtyping_mode);\n \n             // if we found anything, stop before trying borrows\n             if self.candidates.len() > 0u { break; }\n \n-            // Again, look for inherent methods.\n+            // Again, look for inherent and extension methods, this time using\n+            // assignability.\n+            self.add_inherent_and_extension_candidates\n+                (optional_inherent_methods, assignability_mode);\n+\n+            // If we found anything, stop before trying auto-ref.\n+            if self.candidates.len() > 0u { break; }\n+\n+            // Now look for inherent and extension methods, this time using an\n+            // immutable reference.\n             self.add_inherent_and_extension_candidates\n-                (optional_inherent_methods, true);\n+                (optional_inherent_methods, immutable_reference_mode);\n+\n+            // if we found anything, stop before attempting auto-deref.\n+            if self.candidates.len() > 0u { break; }\n+\n+            // Now look for inherent and extension methods, this time using a\n+            // mutable reference.\n+            self.add_inherent_and_extension_candidates\n+                (optional_inherent_methods, mutable_reference_mode);\n \n             // if we found anything, stop before attempting auto-deref.\n             if self.candidates.len() > 0u { break; }\n@@ -362,9 +387,8 @@ class lookup {\n     }\n \n     // Returns true if any were added and false otherwise.\n-    fn add_candidates_from_impl(im: @resolve3::Impl,\n-                                use_assignability: bool) -> bool {\n-\n+    fn add_candidates_from_impl(im: @resolve3::Impl, mode: method_lookup_mode)\n+                             -> bool {\n         let mut added_any = false;\n \n         // Check whether this impl has a method with the right name.\n@@ -382,15 +406,33 @@ class lookup {\n                 self.tcx(), impl_substs.self_r,\n                 impl_ty, m.self_type);\n \n-            // Depending on our argument, we find potential\n-            // matches either by checking subtypability or\n-            // type assignability. Collect the matches.\n-            let matches = if use_assignability {\n-                self.fcx.can_mk_assignty(self.self_expr, self.borrow_lb,\n-                                         self.self_ty, impl_ty)\n-            } else {\n-                self.fcx.can_mk_subty(self.self_ty, impl_ty)\n-            };\n+            // Depending on our argument, we find potential matches by\n+            // checking subtypability, type assignability, or reference\n+            // subtypability. Collect the matches.\n+            let matches;\n+            match mode {\n+                subtyping_mode => \n+                    matches = self.fcx.can_mk_subty(self.self_ty, impl_ty),\n+                assignability_mode =>\n+                    matches = self.fcx.can_mk_assignty(self.self_expr,\n+                                                       self.borrow_lb,\n+                                                       self.self_ty,\n+                                                       impl_ty),\n+                immutable_reference_mode => {\n+                    let region = self.fcx.infcx.next_region_var_with_scope_lb\n+                        (self.self_expr.id);\n+                    let tm = { ty: self.self_ty, mutbl: ast::m_imm };\n+                    let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n+                    matches = self.fcx.can_mk_subty(ref_ty, impl_ty);\n+                }\n+                mutable_reference_mode => {\n+                    let region = self.fcx.infcx.next_region_var_with_scope_lb\n+                        (self.self_expr.id);\n+                    let tm = { ty: self.self_ty, mutbl: ast::m_mutbl };\n+                    let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n+                    matches = self.fcx.can_mk_subty(ref_ty, impl_ty);\n+                }\n+            }\n             debug!{\"matches = %?\", matches};\n             match matches {\n               result::err(_) => { /* keep looking */ }\n@@ -404,7 +446,8 @@ class lookup {\n                          n_tps_m: m.n_tps,\n                          fty: fty,\n                          entry: {derefs: self.derefs,\n-                                 origin: method_static(m.did)}});\n+                                 origin: method_static(m.did)},\n+                         mode: mode});\n                     self.candidate_impls.insert(im.did, ());\n                     added_any = true;\n                 }\n@@ -431,12 +474,13 @@ class lookup {\n              rcvr_ty: self.self_ty,\n              n_tps_m: (*m.tps).len(),\n              fty: fty,\n-             entry: {derefs: self.derefs, origin: origin}});\n+             entry: {derefs: self.derefs, origin: origin},\n+             mode: subtyping_mode});\n     }\n \n     fn add_inherent_and_extension_candidates(optional_inherent_methods:\n                                                 option<@DVec<@Impl>>,\n-                                             use_assignability: bool) {\n+                                             mode: method_lookup_mode) {\n \n         // Add inherent methods.\n         match optional_inherent_methods {\n@@ -451,8 +495,7 @@ class lookup {\n                         adding candidates from impl: %s\",\n                         node_id_to_str(self.tcx().items,\n                                        implementation.did.node)};\n-                self.add_candidates_from_impl(implementation,\n-                                              use_assignability);\n+                self.add_candidates_from_impl(implementation, mode);\n             }\n           }\n         }\n@@ -479,8 +522,7 @@ class lookup {\n                                 candidates) adding impl %s\",\n                                 self.def_id_to_str\n                                 (implementation.did)};\n-                        self.add_candidates_from_impl\n-                            (implementation, use_assignability);\n+                        self.add_candidates_from_impl(implementation, mode);\n                     }\n                   }\n                 }\n@@ -505,19 +547,41 @@ class lookup {\n                self.fcx.infcx.ty_to_str(cand.fty),\n                cand.entry};\n \n-        // Make the actual receiver type (cand.self_ty) assignable to the\n-        // required receiver type (cand.rcvr_ty).  If this method is not\n-        // from an impl, this'll basically be a no-nop.\n-        match self.fcx.mk_assignty(self.self_expr, self.borrow_lb,\n-                                   cand.self_ty, cand.rcvr_ty) {\n-          result::ok(_) => (),\n-          result::err(_) => {\n-            self.tcx().sess.span_bug(\n-                self.expr.span,\n-                fmt!{\"%s was assignable to %s but now is not?\",\n-                     self.fcx.infcx.ty_to_str(cand.self_ty),\n-                     self.fcx.infcx.ty_to_str(cand.rcvr_ty)});\n-          }\n+        match cand.mode {\n+            subtyping_mode | assignability_mode => {\n+                // Make the actual receiver type (cand.self_ty) assignable to\n+                // the required receiver type (cand.rcvr_ty).  If this method\n+                // is not from an impl, this'll basically be a no-nop.\n+                match self.fcx.mk_assignty(self.self_expr, self.borrow_lb,\n+                                           cand.self_ty, cand.rcvr_ty) {\n+                  result::ok(_) => (),\n+                  result::err(_) => {\n+                    self.tcx().sess.span_bug(\n+                        self.expr.span,\n+                        fmt!{\"%s was assignable to %s but now is not?\",\n+                             self.fcx.infcx.ty_to_str(cand.self_ty),\n+                             self.fcx.infcx.ty_to_str(cand.rcvr_ty)});\n+                  }\n+                }\n+            }\n+            immutable_reference_mode => {\n+                // Borrow as an immutable reference.\n+                let region_var = self.fcx.infcx.next_region_var_with_scope_lb\n+                    (self.self_expr.id);\n+                self.fcx.infcx.borrowings.push({expr_id: self.self_expr.id,\n+                                                span: self.self_expr.span,\n+                                                scope: region_var,\n+                                                mutbl: ast::m_imm});\n+            }\n+            mutable_reference_mode => {\n+                // Borrow as a mutable reference.\n+                let region_var = self.fcx.infcx.next_region_var_with_scope_lb\n+                    (self.self_expr.id);\n+                self.fcx.infcx.borrowings.push({expr_id: self.self_expr.id,\n+                                                span: self.self_expr.span,\n+                                                scope: region_var,\n+                                                mutbl: ast::m_mutbl});\n+            }\n         }\n \n         // Construct the full set of type parameters for the method,\n@@ -546,7 +610,7 @@ class lookup {\n         let all_substs = {tps: vec::append(cand.self_substs.tps, m_substs)\n                           with cand.self_substs};\n \n-         self.fcx.write_ty_substs(self.node_id, cand.fty, all_substs);\n+        self.fcx.write_ty_substs(self.node_id, cand.fty, all_substs);\n \n         return cand.entry;\n     }"}, {"sha": "316f37971960f38d31dd1ca55224e4d079bd65f2", "filename": "src/test/compile-fail/auto-ref-borrowck-failure.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fauto-ref-borrowck-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fauto-ref-borrowck-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-ref-borrowck-failure.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -0,0 +1,21 @@\n+// Tests that auto-ref can't create mutable aliases to immutable memory.\n+\n+struct Foo {\n+    x: int;\n+}\n+\n+trait Stuff {\n+    fn printme();\n+}\n+\n+impl &mut Foo : Stuff {\n+    fn printme() {\n+        io::println(fmt!(\"%d\", self.x));\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo { x: 3 };\n+    x.printme();    //~ ERROR illegal borrow\n+}\n+"}, {"sha": "eba939d76e7ebe8df59222b5c368737fc509c172", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: attempted access of field `eat` on type `noisy`\n+// error-pattern: attempted access of field `eat` on type `@noisy`\n trait noisy {\n   fn speak();\n }\n@@ -39,4 +39,4 @@ class cat : noisy {\n fn main() {\n   let nyan : noisy  = cat(0u, 2, \"nyan\") as noisy;\n   nyan.eat();\n-}\n\\ No newline at end of file\n+}"}, {"sha": "5131bd81c7ca0159eb7f53b608b7a7aa275a2109", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -6,7 +6,7 @@ import std::map::map;\n // Test that trait types printed in error msgs include the type arguments.\n \n fn main() {\n-    let x: map<~str,~str> = map::str_hash::<~str>() as map::<~str,~str>;\n+    let x: map<~str,~str> = map::str_hash::<~str>() as @map::<~str,~str>;\n     let y: map<uint,~str> = x;\n-    //~^ ERROR mismatched types: expected `std::map::map<uint,~str>`\n+    //~^ ERROR mismatched types: expected `@std::map::map<uint,~str>`\n }"}, {"sha": "28c3b1c4463ed1a524987553ba802bc10109179d", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -11,7 +11,7 @@ fn a_fn1(e: an_enum/&a) -> an_enum/&b {\n }\n \n fn a_fn2(e: a_trait/&a) -> a_trait/&b {\n-    return e; //~ ERROR mismatched types: expected `a_trait/&b` but found `a_trait/&a`\n+    return e; //~ ERROR mismatched types: expected `@a_trait/&b` but found `@a_trait/&a`\n }\n \n fn a_fn3(e: a_class/&a) -> a_class/&b {\n@@ -24,4 +24,4 @@ fn a_fn4(e: int/&a) -> int/&b {\n     return e;\n }\n \n-fn main() { }\n\\ No newline at end of file\n+fn main() { }"}, {"sha": "6138976395598d6a35004e024c7ed11ab8d3cefd", "filename": "src/test/compile-fail/regions-infer-paramd-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -15,7 +15,7 @@ trait set_foo_foo {\n \n impl with_foo: set_foo_foo {\n     fn set_foo(f: foo) {\n-        self.f = f; //~ ERROR mismatched types: expected `foo/&self` but found `foo/&`\n+        self.f = f; //~ ERROR mismatched types: expected `@foo/&self` but found `@foo/&`\n     }\n }\n "}, {"sha": "661f64ec651ae6cb6216ccb133fbf7868641f744", "filename": "src/test/compile-fail/regions-trait-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -13,7 +13,7 @@ impl has_ctxt: get_ctxt {\n fn make_gc() -> get_ctxt  {\n     let ctxt = { v: 22u };\n     let hc = { c: &ctxt };\n-    return hc as get_ctxt; //~ ERROR mismatched types: expected `get_ctxt/&`\n+    return hc as get_ctxt; //~ ERROR mismatched types: expected `@get_ctxt/&`\n }\n \n fn main() {"}, {"sha": "b3a0d0fcf6263adec13ae547e451409c5636fbbf", "filename": "src/test/compile-fail/regions-trait-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -3,11 +3,11 @@ trait get_ctxt {\n }\n \n fn make_gc1(gc: get_ctxt/&a) -> get_ctxt/&b  {\n-    return gc; //~ ERROR mismatched types: expected `get_ctxt/&b` but found `get_ctxt/&a`\n+    return gc; //~ ERROR mismatched types: expected `@get_ctxt/&b` but found `@get_ctxt/&a`\n }\n \n fn make_gc2(gc: get_ctxt/&a) -> get_ctxt/&b  {\n-    return gc as get_ctxt; //~ ERROR mismatched types: expected `get_ctxt/&b` but found `get_ctxt/&a`\n+    return gc as get_ctxt; //~ ERROR mismatched types: expected `@get_ctxt/&b` but found `@get_ctxt/&a`\n }\n \n fn main() {"}, {"sha": "9e15a31d95aa0d7c1b6d85ec2e4919ad55d75e8f", "filename": "src/test/compile-fail/trait-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -2,7 +2,7 @@ trait foo<T> { }\n \n fn bar(x: foo<uint>) -> foo<int> {\n     return (x as foo::<int>);\n-    //~^ ERROR mismatched types: expected `foo<int>` but found `foo<uint>`\n+    //~^ ERROR mismatched types: expected `@foo<int>` but found `@foo<uint>`\n }\n \n fn main() {}"}, {"sha": "e5d4d106b5327c32ebd2a2c95c1f552b4270cd65", "filename": "src/test/run-pass/auto-ref.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Frun-pass%2Fauto-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54db12155257787797cd9c7eaf06a215ff516e5/src%2Ftest%2Frun-pass%2Fauto-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref.rs?ref=d54db12155257787797cd9c7eaf06a215ff516e5", "patch": "@@ -0,0 +1,19 @@\n+struct Foo {\n+    x: int;\n+}\n+\n+trait Stuff {\n+    fn printme();\n+}\n+\n+impl &Foo : Stuff {\n+    fn printme() {\n+        io::println(fmt!(\"%d\", self.x));\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo { x: 3 };\n+    x.printme();\n+}\n+"}]}