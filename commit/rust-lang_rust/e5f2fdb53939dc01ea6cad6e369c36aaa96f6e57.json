{"sha": "e5f2fdb53939dc01ea6cad6e369c36aaa96f6e57", "node_id": "C_kwDOAAsO6NoAKGU1ZjJmZGI1MzkzOWRjMDFlYTZjYWQ2ZTM2OWMzNmFhYTk2ZjZlNTc", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-01-22T21:16:11Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-01-22T21:16:11Z"}, "message": "Restructure the code leveraging in abilities more than modes", "tree": {"sha": "408e67a096fc9a11eb2c6a7f68e043cc22d9f054", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/408e67a096fc9a11eb2c6a7f68e043cc22d9f054"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5f2fdb53939dc01ea6cad6e369c36aaa96f6e57", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmHsdBsACgkQgTGiTgx5\n76+4YxAArkwsMl9lnlzO/6eBtLXfY35gtngGnofOdpBDF6ZCQM5JjSNrmQUd8j+Y\nbtcSuYTio7bnwUrSbN0JrtVr8y/puingBQ4lOIPORgq9niXWUpZSSdRCraoraKsY\nreTWdhr3fT2kPbceiJHfVcIg0D7NMdKoRVmcVOak3Cu/KUJ5QjELypE2iPs8estd\ntAkO+CNezxGM6zfJDqMLamOLMwmND0Zw+0EZuRCjflgMq5nNz5SqDd66hrgm9myC\nk4u/ki4EWVTgi7/QhEEiVhlrj78pnKtkrB1lgIrd3pNW/Ia17jzHCI9e5dPcUv+y\nm4rOxQL8KVaLs7pJiri5N9E1jgfbBJDKcZWGe287yxaHwvz1fjtLras5ye/3Ckxh\nbtiXZEgEhXHixsao2XFUw/1gccjrQp8WCtTzuwpcLDyDMzSonWxlImgdm01fxg3B\nJ7wxD0f6Dlr5CMU3Xl076DkcDitYLrwjRQ08cEpZFI/Bu+nc9hzaUu4opuhh6na5\nLSJpsPGRsgEKAoYEL4gCV/4IaPr9foCv3d3t8ht6gQK+TVc+rfWXdcDrhuUPYAKj\nn0CFrEjf4MC4oyTTlS8U0npBPS/PMqFsiKBbOMBc/lx1NV8gscYmlapCbFl0NuWP\nEduwWOST+YYWBPDlWQUc3u4lpGgXiTRmJH3CWf/ON/Yp5r3EH+Q=\n=HC1L\n-----END PGP SIGNATURE-----", "payload": "tree 408e67a096fc9a11eb2c6a7f68e043cc22d9f054\nparent e2567b034dd6847cc026eb80db47bd1271fe71de\nauthor Santiago Pastorino <spastorino@gmail.com> 1642886171 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1642886171 -0300\n\nRestructure the code leveraging in abilities more than modes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f2fdb53939dc01ea6cad6e369c36aaa96f6e57", "html_url": "https://github.com/rust-lang/rust/commit/e5f2fdb53939dc01ea6cad6e369c36aaa96f6e57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5f2fdb53939dc01ea6cad6e369c36aaa96f6e57/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2567b034dd6847cc026eb80db47bd1271fe71de", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2567b034dd6847cc026eb80db47bd1271fe71de", "html_url": "https://github.com/rust-lang/rust/commit/e2567b034dd6847cc026eb80db47bd1271fe71de"}], "stats": {"total": 98, "additions": 47, "deletions": 51}, "files": [{"sha": "f22ca11d1c36edf8e1455f486bfda97bf01dabf5", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e5f2fdb53939dc01ea6cad6e369c36aaa96f6e57/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f2fdb53939dc01ea6cad6e369c36aaa96f6e57/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=e5f2fdb53939dc01ea6cad6e369c36aaa96f6e57", "patch": "@@ -11,7 +11,7 @@ use crate::traits::util::impl_trait_ref_and_oblig;\n use crate::traits::SkipLeakCheck;\n use crate::traits::{\n     self, FulfillmentContext, Normalized, Obligation, ObligationCause, PredicateObligation,\n-    SelectionContext,\n+    PredicateObligations, SelectionContext,\n };\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n@@ -137,12 +137,23 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n     header\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n enum OverlapMode {\n     Stable,\n     WithNegative,\n     Strict,\n }\n \n+impl OverlapMode {\n+    fn use_negative_impl(&self) -> bool {\n+        *self == OverlapMode::Strict || *self == OverlapMode::WithNegative\n+    }\n+\n+    fn use_implicit_negative(&self) -> bool {\n+        *self == OverlapMode::Stable || *self == OverlapMode::WithNegative\n+    }\n+}\n+\n fn overlap_mode<'tcx>(tcx: TyCtxt<'tcx>, impl1_def_id: DefId, impl2_def_id: DefId) -> OverlapMode {\n     if tcx.has_attr(impl1_def_id, sym::rustc_strict_coherence)\n         != tcx.has_attr(impl2_def_id, sym::rustc_strict_coherence)\n@@ -190,6 +201,16 @@ fn overlap_within_probe<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     let tcx = infcx.tcx;\n \n+    let overlap_mode = overlap_mode(tcx, impl1_def_id, impl2_def_id);\n+\n+    if overlap_mode.use_negative_impl() {\n+        if negative_impl(selcx, impl1_def_id, impl2_def_id)\n+            || negative_impl(selcx, impl2_def_id, impl1_def_id)\n+        {\n+            return None;\n+        }\n+    }\n+\n     // For the purposes of this check, we don't bring any placeholder\n     // types into scope; instead, we replace the generic types with\n     // fresh type variables, and hence we do our evaluations in an\n@@ -199,29 +220,15 @@ fn overlap_within_probe<'cx, 'tcx>(\n     let impl1_header = with_fresh_ty_vars(selcx, param_env, impl1_def_id);\n     let impl2_header = with_fresh_ty_vars(selcx, param_env, impl2_def_id);\n \n-    match overlap_mode(tcx, impl1_def_id, impl2_def_id) {\n-        OverlapMode::Stable => {\n-            if stable_disjoint(selcx, param_env, &impl1_header, impl2_header) {\n-                return None;\n-            }\n-        }\n-        OverlapMode::Strict => {\n-            if strict_disjoint(selcx, impl1_def_id, impl2_def_id) {\n-                return None;\n-            }\n+    debug!(\"overlap: impl1_header={:?}\", impl1_header);\n+    debug!(\"overlap: impl2_header={:?}\", impl2_header);\n \n-            // Equate for error reporting\n-            let _ = selcx\n-                .infcx()\n-                .at(&ObligationCause::dummy(), param_env)\n-                .eq_impl_headers(&impl1_header, &impl2_header);\n-        }\n-        OverlapMode::WithNegative => {\n-            if stable_disjoint(selcx, param_env, &impl1_header, impl2_header)\n-                || strict_disjoint(selcx, impl1_def_id, impl2_def_id)\n-            {\n-                return None;\n-            }\n+    let obligations = equate_impl_headers(selcx, &impl1_header, &impl2_header)?;\n+    debug!(\"overlap: unification check succeeded\");\n+\n+    if overlap_mode.use_implicit_negative() {\n+        if implicit_negative(selcx, param_env, &impl1_header, impl2_header, obligations) {\n+            return None;\n         }\n     }\n \n@@ -242,31 +249,29 @@ fn overlap_within_probe<'cx, 'tcx>(\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n+fn equate_impl_headers<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    impl1_header: &ty::ImplHeader<'tcx>,\n+    impl2_header: &ty::ImplHeader<'tcx>,\n+) -> Option<PredicateObligations<'tcx>> {\n+    // Do `a` and `b` unify? If not, no overlap.\n+    selcx\n+        .infcx()\n+        .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+        .eq_impl_headers(impl1_header, impl2_header)\n+        .map(|infer_ok| infer_ok.obligations)\n+        .ok()\n+}\n+\n /// Given impl1 and impl2 check if both impls can be satisfied by a common type (including\n /// where-clauses) If so, return false, otherwise return true, they are disjoint.\n-fn stable_disjoint<'cx, 'tcx>(\n+fn implicit_negative<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     impl1_header: &ty::ImplHeader<'tcx>,\n     impl2_header: ty::ImplHeader<'tcx>,\n+    obligations: PredicateObligations<'tcx>,\n ) -> bool {\n-    debug!(\"overlap: impl1_header={:?}\", impl1_header);\n-    debug!(\"overlap: impl2_header={:?}\", impl2_header);\n-\n-    // Do `a` and `b` unify? If not, no overlap.\n-    let obligations = match selcx\n-        .infcx()\n-        .at(&ObligationCause::dummy(), param_env)\n-        .eq_impl_headers(&impl1_header, &impl2_header)\n-    {\n-        Ok(InferOk { obligations, value: () }) => obligations,\n-        Err(_) => {\n-            return true;\n-        }\n-    };\n-\n-    debug!(\"overlap: unification check succeeded\");\n-\n     // There's no overlap if obligations are unsatisfiable or if the obligation negated is\n     // satisfied.\n     //\n@@ -318,16 +323,7 @@ fn stable_disjoint<'cx, 'tcx>(\n \n /// Given impl1 and impl2 check if both impls are never satisfied by a common type (including\n /// where-clauses) If so, return true, they are disjoint and false otherwise.\n-fn strict_disjoint<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    impl1_def_id: DefId,\n-    impl2_def_id: DefId,\n-) -> bool {\n-    explicit_disjoint(selcx, impl1_def_id, impl2_def_id)\n-        || explicit_disjoint(selcx, impl2_def_id, impl1_def_id)\n-}\n-\n-fn explicit_disjoint<'cx, 'tcx>(\n+fn negative_impl<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,"}]}