{"sha": "a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZTJlYjAzOTU5NDFmNWNhNzljZDU5YzhhYjBhOWYzMTMzYTJkZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-14T04:02:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-14T04:02:48Z"}, "message": "auto merge of #18017 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "2782a6efa84382e234077244930b2d78d54ce7ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2782a6efa84382e234077244930b2d78d54ce7ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "html_url": "https://github.com/rust-lang/rust/commit/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c3ddd297128a96f72be09bddf138e4e603a7aa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c3ddd297128a96f72be09bddf138e4e603a7aa1", "html_url": "https://github.com/rust-lang/rust/commit/1c3ddd297128a96f72be09bddf138e4e603a7aa1"}, {"sha": "2e2d681d88d99c4bb7033b852f98d6f979af5672", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e2d681d88d99c4bb7033b852f98d6f979af5672", "html_url": "https://github.com/rust-lang/rust/commit/2e2d681d88d99c4bb7033b852f98d6f979af5672"}], "stats": {"total": 825, "additions": 480, "deletions": 345}, "files": [{"sha": "6c586957862b48bce0bda73fe34d46f844d3ad39", "filename": "mk/tests.mk", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -199,14 +199,29 @@ check-docs: cleantestlibs cleantmptestlogs check-stage2-docs\n \n # Some less critical tests that are not prone to breakage.\n # Not run as part of the normal test suite, but tested by bors on checkin.\n-check-secondary: check-lexer check-pretty\n+check-secondary: check-build-compiletest check-lexer check-pretty\n \n # check + check-secondary.\n-check-all: check check-secondary\n+#\n+# Issue #17883: build check-secondary first so hidden dependencies in\n+# e.g. building compiletest are exercised (resolve those by adding\n+# deps to rules that need them; not by putting `check` first here).\n+check-all: check-secondary check\n \n # Pretty-printing tests.\n check-pretty: check-stage2-T-$(CFG_BUILD)-H-$(CFG_BUILD)-pretty-exec\n \n+define DEF_CHECK_BUILD_COMPILETEST_FOR_STAGE\n+check-stage$(1)-build-compiletest: \t$$(HBIN$(1)_H_$(CFG_BUILD))/compiletest$$(X_$(CFG_BUILD))\n+endef\n+\n+$(foreach stage,$(STAGES), \\\n+ $(eval $(call DEF_CHECK_BUILD_COMPILETEST_FOR_STAGE,$(stage))))\n+\n+check-build-compiletest: \\\n+\tcheck-stage1-build-compiletest \\\n+\tcheck-stage2-build-compiletest\n+\n .PHONY: cleantmptestlogs cleantestlibs\n \n cleantmptestlogs:\n@@ -284,7 +299,7 @@ tidy:\n \t\t| xargs -n 10 $(CFG_PYTHON) $(S)src/etc/tidy.py\n \t\t$(Q)echo $(ALL_HS) \\\n \t\t| xargs -n 10 $(CFG_PYTHON) $(S)src/etc/tidy.py\n-\t\t$(Q)find $(S)src -type f -perm a+x \\\n+\t\t$(Q)find $(S)src -type f -perm +a+x \\\n \t\t    -not -name '*.rs' -and -not -name '*.py' \\\n \t\t    -and -not -name '*.sh' \\\n \t\t| grep '^$(S)src/jemalloc' -v \\\n@@ -720,6 +735,13 @@ PRETTY_DEPS_pretty-rpass-full = $(RPASS_FULL_TESTS)\n PRETTY_DEPS_pretty-rfail = $(RFAIL_TESTS)\n PRETTY_DEPS_pretty-bench = $(BENCH_TESTS)\n PRETTY_DEPS_pretty-pretty = $(PRETTY_TESTS)\n+# The stage- and host-specific dependencies are for e.g. macro_crate_test which pulls in\n+# external crates.\n+PRETTY_DEPS$(1)_H_$(3)_pretty-rpass =\n+PRETTY_DEPS$(1)_H_$(3)_pretty-rpass-full = $$(HLIB$(1)_H_$(3))/stamp.syntax $$(HLIB$(1)_H_$(3))/stamp.rustc\n+PRETTY_DEPS$(1)_H_$(3)_pretty-rfail =\n+PRETTY_DEPS$(1)_H_$(3)_pretty-bench =\n+PRETTY_DEPS$(1)_H_$(3)_pretty-pretty =\n PRETTY_DIRNAME_pretty-rpass = run-pass\n PRETTY_DIRNAME_pretty-rpass-full = run-pass-fulldeps\n PRETTY_DIRNAME_pretty-rfail = run-fail\n@@ -738,7 +760,8 @@ check-stage$(1)-T-$(2)-H-$(3)-$(4)-exec: $$(call TEST_OK_FILE,$(1),$(2),$(3),$(4\n \n $$(call TEST_OK_FILE,$(1),$(2),$(3),$(4)): \\\n \t        $$(TEST_SREQ$(1)_T_$(2)_H_$(3)) \\\n-\t        $$(PRETTY_DEPS_$(4))\n+\t        $$(PRETTY_DEPS_$(4)) \\\n+\t        $$(PRETTY_DEPS$(1)_H_$(3)_$(4))\n \t@$$(call E, run pretty-rpass [$(2)]: $$<)\n \t$$(Q)$$(call CFG_RUN_CTEST_$(2),$(1),$$<,$(3)) \\\n \t\t$$(PRETTY_ARGS$(1)-T-$(2)-H-$(3)-$(4)) \\"}, {"sha": "ff6b1b153332494f247dc42e5bf9fc95ec1fe790", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -947,15 +947,12 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         String::from_chars(c.as_slice())\n     }\n \n-    #[cfg(target_os = \"windows\")]\n+    #[cfg(windows)]\n     fn prefix_matches( line : &str, prefix : &str ) -> bool {\n         to_lower(line).as_slice().starts_with(to_lower(prefix).as_slice())\n     }\n \n-    #[cfg(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n+    #[cfg(unix)]\n     fn prefix_matches( line : &str, prefix : &str ) -> bool {\n         line.starts_with( prefix )\n     }\n@@ -1356,24 +1353,21 @@ fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: String\n }\n \n // Linux and mac don't require adjusting the library search path\n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"macos\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n+#[cfg(unix)]\n fn make_cmdline(_libpath: &str, prog: &str, args: &[String]) -> String {\n     format!(\"{} {}\", prog, args.connect(\" \"))\n }\n \n-#[cfg(target_os = \"windows\")]\n+#[cfg(windows)]\n fn make_cmdline(libpath: &str, prog: &str, args: &[String]) -> String {\n-    format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog, args.connect(\" \"))\n-}\n \n-// Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n-// for diagnostic purposes\n-#[cfg(target_os = \"windows\")]\n-fn lib_path_cmd_prefix(path: &str) -> String {\n-    format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n+    // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n+    // for diagnostic purposes\n+    fn lib_path_cmd_prefix(path: &str) -> String {\n+        format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n+    }\n+\n+    format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog, args.connect(\" \"))\n }\n \n fn dump_output(config: &Config, testfile: &Path, out: &str, err: &str) {"}, {"sha": "50222973509ad6eccda20b5d280496ed7b8a31b6", "filename": "src/doc/README.md", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2FREADME.md?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -1,4 +1,6 @@\n-# Dependencies\n+# Rust documentations\n+\n+## Dependencies\n \n [Pandoc](http://johnmacfarlane.net/pandoc/installing.html), a universal\n document converter, is required to generate docs as HTML from Rust's\n@@ -10,7 +12,7 @@ docs from the master (English) docs.\n [GNU gettext](http://www.gnu.org/software/gettext/) is required for managing\n the translation data.\n \n-# Building\n+## Building\n \n To generate all the docs, just run `make docs` from the root of the repository.\n This will convert the distributed Markdown docs to HTML and generate HTML doc\n@@ -24,7 +26,7 @@ rustdoc --output html-doc/ --output-format html ../src/libstd/path.rs\n \n (This, of course, requires a working build of the `rustdoc` tool.)\n \n-# Additional notes\n+## Additional notes\n \n To generate an HTML version of a doc from Markdown manually, you can do\n something like:\n@@ -33,37 +35,39 @@ something like:\n pandoc --from=markdown --to=html5 --number-sections -o reference.html reference.md\n ~~~~\n \n-(reference.md being the Rust Reference Manual.)\n+(`reference.md` being the Rust Reference Manual.)\n \n The syntax for pandoc flavored markdown can be found at:\n-http://johnmacfarlane.net/pandoc/README.html#pandocs-markdown\n+\n+- http://johnmacfarlane.net/pandoc/README.html#pandocs-markdown\n \n A nice quick reference (for non-pandoc markdown) is at:\n-http://kramdown.rubyforge.org/quickref.html\n \n-# Notes for translators\n+- http://kramdown.gettalong.org/quickref.html\n+\n+## Notes for translators\n \n Notice: The procedure described below is a work in progress. We are working on\n translation system but the procedure contains some manual operations for now.\n \n-To start the translation for a new language, see po4a.conf at first.\n+To start the translation for a new language, see `po4a.conf` at first.\n \n-To generate .pot and .po files, do something like:\n+To generate `.pot` and `.po` files, do something like:\n \n ~~~~\n po4a --copyright-holder=\"The Rust Project Developers\" \\\n     --package-name=\"Rust\" \\\n-    --package-version=\"0.11.0\" \\\n+    --package-version=\"0.13.0\" \\\n     -M UTF-8 -L UTF-8 \\\n     src/doc/po4a.conf\n ~~~~\n \n-(the version number must be changed if it is not 0.11.0 now.)\n+(the version number must be changed if it is not `0.13.0` now.)\n \n-Now you can translate documents with .po files, commonly used with gettext. If\n+Now you can translate documents with `.po` files, commonly used with gettext. If\n you are not familiar with gettext-based translation, please read the online\n manual linked from http://www.gnu.org/software/gettext/ . We use UTF-8 as the\n-file encoding of .po files.\n+file encoding of `.po` files.\n \n When you want to make a commit, do the command below before staging your\n change:\n@@ -79,4 +83,4 @@ for f in src/doc/po/**/*.po; do\n done\n ~~~~\n \n-This removes untranslated entries from .po files to save disk space.\n+This removes untranslated entries from `.po` files to save disk space."}, {"sha": "0b0a6b7b697170ba6d21ef2addabe37997ac9120", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -298,7 +298,7 @@ fn main() {\n C code:\n \n ~~~~c\n-typedef void (*rust_callback)(int32_t);\n+typedef void (*rust_callback)(void*, int32_t);\n void* cb_target;\n rust_callback cb;\n "}, {"sha": "afca75a76d444f733e8e3e73f7334cfae63ad33e", "filename": "src/doc/guide-strings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2Fguide-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2Fguide-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-strings.md?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -206,5 +206,5 @@ Many more bytes than graphemes!\n \n # Other Documentation\n \n-* [the `&str` API documentation](/std/str/index.html)\n+* [the `&str` API documentation](std/str/index.html)\n * [the `String` API documentation](std/string/index.html)"}, {"sha": "5357a0fcafa14244505a93cf4268b811c4c6d65b", "filename": "src/doc/guide.md", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -1746,8 +1746,7 @@ For our first project, we'll implement a classic beginner programming problem:\n the guessing game. Here's how it works: Our program will generate a random\n integer between one and a hundred. It will then prompt us to enter a guess.\n Upon entering our guess, it will tell us if we're too low or too high. Once we\n-guess correctly, it will congratulate us, and print the number of guesses we've\n-taken to the screen. Sound good?\n+guess correctly, it will congratulate us. Sound good?\n \n ## Set up\n \n@@ -3538,9 +3537,8 @@ restriction:\n \n 1. If the borrow is immutable, you may read the data the pointer points to.\n 2. If the borrow is mutable, you may read and write the data the pointer points to.\n-3. You may lend the pointer to someone else in an immutable fashion, **BUT**\n-4. When you do so, they must return it to you before you must give your own\n-   borrow back.\n+3. You may lend the pointer to someone else, **BUT**\n+4. When you do so, they must return it before you can give your own borrow back.\n \n This last requirement can seem odd, but it also makes sense. If you have to\n return something, and you've lent it to someone, they need to give it back to\n@@ -5062,8 +5060,8 @@ println!(\"The value of x[0] is: {}\", x[0]); // error: use of moved value: `x`\n ```\n \n `x` is now owned by the proc, and so we can't use it anymore. Many other\n-languages would let us do this, but it's not safe to do so. Rust's type system\n-catches the error.\n+languages would let us do this, but it's not safe to do so. Rust's borrow\n+checker catches the error.\n \n If tasks were only able to capture these values, they wouldn't be very useful.\n Luckily, tasks can communicate with each other through **channel**s. Channels"}, {"sha": "3c4b973002e92d3b999197bd98332da84d0b953d", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -185,40 +185,24 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n \n ### Keywords\n \n-The keywords are the following strings, organized by first letter:\n+<p id=\"keyword-table-marker\">The keywords are the following strings, organized by first letter:</p>\n \n-<div id=\"keywords\">\n |          |        |        |       |\n |----------|--------|--------|-------|\n | as       |        |        |       |\n-|----------|--------|--------|-------|\n | box      | break  |        |       |\n-|----------|--------|--------|-------|\n | continue | crate  |        |       |\n-|----------|--------|--------|-------|\n | else     | enum   | extern |       |\n-|----------|--------|--------|-------|\n | false    | fn     | for    |       |\n-|----------|--------|--------|-------|\n | if       | impl   | in     |       |\n-|----------|--------|--------|-------|\n | let      | loop   |        |       |\n-|----------|--------|--------|-------|\n | match    | mod    | mut    |       |\n-|----------|--------|--------|-------|\n | priv     | proc   | pub    |       |\n-|----------|--------|--------|-------|\n | ref      | return |        |       |\n-|----------|--------|--------|-------|\n | self     | static | struct | super |\n-|----------|--------|--------|-------|\n | trait    | true   | type   |       |\n-|----------|--------|--------|-------|\n | unsafe   | use    |        |       |\n-|----------|--------|--------|-------|\n | while    |        |        |       |\n-|----------|--------|--------|-------|\n-</div>\n \n Each of these keywords has special meaning in its grammar, and all of them are\n excluded from the `ident` rule."}, {"sha": "4bbb809840211d426a672483927e70ff5a15c30f", "filename": "src/doc/rust.css", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -393,4 +393,9 @@ pre.rust { position: relative; }\n     }\n }\n \n-#keywords table td { border: none; }\n+#keyword-table-marker + table thead { display: none; }\n+#keyword-table-marker + table td { border: none; }\n+#keyword-table-marker + table {\n+    margin-left: 2em;\n+    margin-bottom: 1em;\n+}"}, {"sha": "d3de1d2b64e0ad17a7e932552fb2368acc522f1e", "filename": "src/etc/unicode.py", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -604,6 +604,15 @@ def optimize_width_table(wtable):\n         rf.write(preamble)\n \n         # download and parse all the data\n+        fetch(\"ReadMe.txt\")\n+        with open(\"ReadMe.txt\") as readme:\n+            pattern = \"for Version (\\d+)\\.(\\d+)\\.(\\d+) of the Unicode\"\n+            unicode_version = re.search(pattern, readme.read()).groups()\n+        rf.write(\"\"\"\n+/// The version of [Unicode](http://www.unicode.org/)\n+/// that the `UnicodeChar` and `UnicodeStrSlice` traits are based on.\n+pub const UNICODE_VERSION: (uint, uint, uint) = (%s, %s, %s);\n+\"\"\" % unicode_version)\n         (canon_decomp, compat_decomp, gencats, combines,\n                 lowerupper, upperlower) = load_unicode_data(\"UnicodeData.txt\")\n         want_derived = [\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\"]"}, {"sha": "a2483f23534e6950d58da254fb8c6a4aba7f22f1", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -276,7 +276,6 @@ impl<T: Sync + Send> Drop for Weak<T> {\n #[allow(experimental)]\n mod tests {\n     use std::clone::Clone;\n-    use std::collections::MutableSeq;\n     use std::comm::channel;\n     use std::mem::drop;\n     use std::ops::Drop;"}, {"sha": "9ead4cbcfd0d88a2f56be36fd210cb96d73309d5", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -2659,7 +2659,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = Bitv::with_capacity(BENCH_BITS, false);\n         b.iter(|| {\n-            for i in range(0u, 100) {\n+            for _ in range(0u, 100) {\n                 bitv.set((r.next_u32() as uint) % BENCH_BITS, r.gen());\n             }\n             &bitv"}, {"sha": "088784070e715dc7aaf7df2954944d864e72ee49", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -890,13 +890,13 @@ mod tests {\n         }\n \n         let v = vec![1i,2,3,4,5];\n-        let u = vec![9i,8,1,2,3,4,5];\n+        let mut u = vec![9i,8,1,2,3,4,5];\n         let mut m = list_from(v.as_slice());\n         m.prepend(list_from(u.as_slice()));\n         check_links(&m);\n-        let sum = u.append(v.as_slice());\n-        assert_eq!(sum.len(), m.len());\n-        for elt in sum.into_iter() {\n+        u.extend(v.as_slice().iter().map(|&b| b));\n+        assert_eq!(u.len(), m.len());\n+        for elt in u.into_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n         }\n     }"}, {"sha": "4d8e67f6ac8f97cff5617c2bb6e8b21a97fcef44", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -611,10 +611,10 @@ mod tests {\n         assert_eq!(deq.len(), 3);\n         deq.push_front(a.clone());\n         assert_eq!(deq.len(), 4);\n-        assert_eq!((*deq.get(0)).clone(), a.clone());\n-        assert_eq!((*deq.get(1)).clone(), b.clone());\n-        assert_eq!((*deq.get(2)).clone(), c.clone());\n-        assert_eq!((*deq.get(3)).clone(), d.clone());\n+        assert_eq!(deq[0].clone(), a.clone());\n+        assert_eq!(deq[1].clone(), b.clone());\n+        assert_eq!(deq[2].clone(), c.clone());\n+        assert_eq!(deq[3].clone(), d.clone());\n     }\n \n     #[test]\n@@ -626,7 +626,7 @@ mod tests {\n         assert_eq!(deq.len(), 66);\n \n         for i in range(0u, 66) {\n-            assert_eq!(*deq.get(i), 65 - i);\n+            assert_eq!(deq[i], 65 - i);\n         }\n \n         let mut deq = RingBuf::new();\n@@ -635,7 +635,7 @@ mod tests {\n         }\n \n         for i in range(0u, 66) {\n-            assert_eq!(*deq.get(i), i);\n+            assert_eq!(deq[i], i);\n         }\n     }\n "}, {"sha": "f49371b8e88628bd11c2a2c7597c355e849916db", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -883,6 +883,7 @@ mod tests {\n     use std::slice::{AsSlice, ImmutableSlice};\n     use string::String;\n     use vec::Vec;\n+    use slice::CloneableVector;\n \n     use unicode::char::UnicodeChar;\n \n@@ -1504,7 +1505,7 @@ mod tests {\n     fn vec_str_conversions() {\n         let s1: String = String::from_str(\"All mimsy were the borogoves\");\n \n-        let v: Vec<u8> = Vec::from_slice(s1.as_bytes());\n+        let v: Vec<u8> = s1.as_bytes().to_vec();\n         let s2: String = String::from_str(from_utf8(v.as_slice()).unwrap());\n         let mut i: uint = 0u;\n         let n1: uint = s1.len();"}, {"sha": "061064ff803d564ab6ba0fcb8d7bc500089842a8", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -1036,6 +1036,7 @@ mod tests {\n     use str::{Str, StrSlice, Owned};\n     use super::{as_string, String};\n     use vec::Vec;\n+    use slice::CloneableVector;\n \n     #[test]\n     fn test_as_string() {\n@@ -1051,15 +1052,15 @@ mod tests {\n \n     #[test]\n     fn test_from_utf8() {\n-        let xs = Vec::from_slice(b\"hello\");\n+        let xs = b\"hello\".to_vec();\n         assert_eq!(String::from_utf8(xs), Ok(String::from_str(\"hello\")));\n \n-        let xs = Vec::from_slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes());\n+        let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes().to_vec();\n         assert_eq!(String::from_utf8(xs), Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n \n-        let xs = Vec::from_slice(b\"hello\\xFF\");\n+        let xs = b\"hello\\xFF\".to_vec();\n         assert_eq!(String::from_utf8(xs),\n-                   Err(Vec::from_slice(b\"hello\\xFF\")));\n+                   Err(b\"hello\\xFF\".to_vec()));\n     }\n \n     #[test]\n@@ -1211,7 +1212,8 @@ mod tests {\n     fn test_push_bytes() {\n         let mut s = String::from_str(\"ABC\");\n         unsafe {\n-            s.push_bytes([b'D']);\n+            let mv = s.as_mut_vec();\n+            mv.push_all([b'D']);\n         }\n         assert_eq!(s.as_slice(), \"ABCD\");\n     }\n@@ -1239,17 +1241,18 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_pop_char() {\n+    fn test_pop() {\n         let mut data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n-        assert_eq!(data.pop_char().unwrap(), '\ud852\udf62'); // 4 bytes\n-        assert_eq!(data.pop_char().unwrap(), '\u20ac'); // 3 bytes\n-        assert_eq!(data.pop_char().unwrap(), '\u00a2'); // 2 bytes\n-        assert_eq!(data.pop_char().unwrap(), 'b'); // 1 bytes\n-        assert_eq!(data.pop_char().unwrap(), '\u534e');\n+        assert_eq!(data.pop().unwrap(), '\ud852\udf62'); // 4 bytes\n+        assert_eq!(data.pop().unwrap(), '\u20ac'); // 3 bytes\n+        assert_eq!(data.pop().unwrap(), '\u00a2'); // 2 bytes\n+        assert_eq!(data.pop().unwrap(), 'b'); // 1 bytes\n+        assert_eq!(data.pop().unwrap(), '\u534e');\n         assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n     }\n \n     #[test]\n+    #[allow(deprecated)] // use remove(0) instead\n     fn test_shift_char() {\n         let mut data = String::from_str(\"\ud852\udf62\u20ac\u00a2b\u534e\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n         assert_eq!(data.shift_char().unwrap(), '\ud852\udf62'); // 4 bytes"}, {"sha": "c714e3935706cbf8a891565868ca7beea44c1b9f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -2266,8 +2266,8 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_mut_slice_from() {\n-        let mut values = Vec::from_slice([1u8,2,3,4,5]);\n+    fn test_slice_from_mut() {\n+        let mut values = vec![1u8,2,3,4,5];\n         {\n             let slice = values.slice_from_mut(2);\n             assert!(slice == [3, 4, 5]);\n@@ -2280,8 +2280,8 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_mut_slice_to() {\n-        let mut values = Vec::from_slice([1u8,2,3,4,5]);\n+    fn test_slice_to_mut() {\n+        let mut values = vec![1u8,2,3,4,5];\n         {\n             let slice = values.slice_to_mut(2);\n             assert!(slice == [1, 2]);\n@@ -2294,8 +2294,8 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_mut_split_at() {\n-        let mut values = Vec::from_slice([1u8,2,3,4,5]);\n+    fn test_split_at_mut() {\n+        let mut values = vec![1u8,2,3,4,5];\n         {\n             let (left, right) = values.split_at_mut(2);\n             {\n@@ -2315,7 +2315,7 @@ mod tests {\n             }\n         }\n \n-        assert!(values == Vec::from_slice([2u8, 3, 5, 6, 7]));\n+        assert!(values == vec![2u8, 3, 5, 6, 7]);\n     }\n \n     #[test]\n@@ -2355,16 +2355,16 @@ mod tests {\n \n     #[test]\n     fn test_grow_fn() {\n-        let mut v = Vec::from_slice([0u, 1]);\n+        let mut v = vec![0u, 1];\n         v.grow_fn(3, |i| i);\n-        assert!(v == Vec::from_slice([0u, 1, 0, 1, 2]));\n+        assert!(v == vec![0u, 1, 0, 1, 2]);\n     }\n \n     #[test]\n     fn test_retain() {\n-        let mut vec = Vec::from_slice([1u, 2, 3, 4]);\n+        let mut vec = vec![1u, 2, 3, 4];\n         vec.retain(|x| x%2 == 0);\n-        assert!(vec == Vec::from_slice([2u, 4]));\n+        assert!(vec == vec![2u, 4]);\n     }\n \n     #[test]\n@@ -2567,32 +2567,32 @@ mod tests {\n \n     #[test]\n     fn test_move_items() {\n-        let mut vec = vec!(1i, 2, 3);\n-        let mut vec2 : Vec<int> = vec!();\n+        let vec = vec![1, 2, 3];\n+        let mut vec2 : Vec<i32> = vec![];\n         for i in vec.into_iter() {\n             vec2.push(i);\n         }\n-        assert!(vec2 == vec!(1i, 2, 3));\n+        assert!(vec2 == vec![1, 2, 3]);\n     }\n \n     #[test]\n     fn test_move_items_reverse() {\n-        let mut vec = vec!(1i, 2, 3);\n-        let mut vec2 : Vec<int> = vec!();\n+        let vec = vec![1, 2, 3];\n+        let mut vec2 : Vec<i32> = vec![];\n         for i in vec.into_iter().rev() {\n             vec2.push(i);\n         }\n-        assert!(vec2 == vec!(3i, 2, 1));\n+        assert!(vec2 == vec![3, 2, 1]);\n     }\n \n     #[test]\n     fn test_move_items_zero_sized() {\n-        let mut vec = vec!((), (), ());\n-        let mut vec2 : Vec<()> = vec!();\n+        let vec = vec![(), (), ()];\n+        let mut vec2 : Vec<()> = vec![];\n         for i in vec.into_iter() {\n             vec2.push(i);\n         }\n-        assert!(vec2 == vec!((), (), ()));\n+        assert!(vec2 == vec![(), (), ()]);\n     }\n \n     #[test]\n@@ -2707,7 +2707,7 @@ mod tests {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst = Vec::from_slice(src.clone().as_slice());\n+            let dst = src.clone().as_slice().to_vec();\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         });\n@@ -2871,7 +2871,7 @@ mod tests {\n \n         b.iter(|| {\n             let mut dst = dst.clone();\n-            dst.push_all_move(src.clone());\n+            dst.extend(src.clone().into_iter());\n             assert_eq!(dst.len(), dst_len + src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         });"}, {"sha": "f507556909c8f14f4c001ffe7533d3bf07c5d46d", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -147,7 +147,7 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n #[inline]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n-        fail!(\"from_digit: radix is to high (maximum 36)\");\n+        fail!(\"from_digit: radix is too high (maximum 36)\");\n     }\n     if num < radix {\n         unsafe {"}, {"sha": "8807756d01b7ee494a9586a9fbd558502eb1f634", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -117,7 +117,7 @@ fn test_is_digit() {\n fn test_escape_default() {\n     fn string(c: char) -> String {\n         let mut result = String::new();\n-        escape_default(c, |c| { result.push_char(c); });\n+        escape_default(c, |c| { result.push(c); });\n         return result;\n     }\n     let s = string('\\n');\n@@ -152,7 +152,7 @@ fn test_escape_default() {\n fn test_escape_unicode() {\n     fn string(c: char) -> String {\n         let mut result = String::new();\n-        escape_unicode(c, |c| { result.push_char(c); });\n+        escape_unicode(c, |c| { result.push(c); });\n         return result;\n     }\n     let s = string('\\x00');"}, {"sha": "476a2b50fcc8130b5f746391440a0c4a9fb4ccd7", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -868,7 +868,7 @@ fn bench_multiple_take(b: &mut Bencher) {\n     let mut it = range(0u, 42).cycle();\n     b.iter(|| {\n         let n = it.next().unwrap();\n-        for m in range(0u, n) {\n+        for _ in range(0u, n) {\n             it.take(it.next().unwrap()).all(|_| true);\n         }\n     });"}, {"sha": "e4dde7c641e1e0c44be074263adbcd46ad723155", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -109,7 +109,7 @@ fn test_transmute() {\n     }\n \n     unsafe {\n-        assert!(Vec::from_slice([76u8]) == transmute(\"L\".to_string()));\n+        assert!(vec![76u8] == transmute(\"L\".to_string()));\n     }\n }\n "}, {"sha": "b023833f394746738d3275f29c029f9ec1fa3a70", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -89,6 +89,7 @@ fn test_collect() {\n }\n \n #[test]\n+#[allow(deprecated)] // we know fold_ is deprecated\n fn test_fold() {\n     assert_eq!(fold_(range(0i, 0)\n                     .map(|_| Ok::<(), ()>(()))),"}, {"sha": "0313c22933cfabb0fc8fcbb7ca45a20530df9ac4", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -682,7 +682,7 @@ mod test {\n     }\n \n     #[test]\n-    #[ignore(cfg(windows))] // FIXME (#9406)\n+    #[cfg_attr(windows, ignore)] // FIXME (#9406)\n     fn test_lots_of_files() {\n         // this is a good test because it touches lots of differently named files\n         glob(\"/*/*/*/*\").skip(10000).next();"}, {"sha": "e21186a5fc8791dcf4798d5516622caa9015819b", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -735,6 +735,20 @@ r#\"digraph single_edge {\n \"#);\n     }\n \n+    #[test]\n+    fn test_some_labelled() {\n+        let labels : Trivial = SomeNodesLabelled(vec![Some(\"A\"), None]);\n+        let result = test_input(LabelledGraph::new(\"test_some_labelled\", labels,\n+                                                   vec![edge(0, 1, \"A-1\")]));\n+        assert_eq!(result.unwrap().as_slice(),\n+r#\"digraph test_some_labelled {\n+    N0[label=\"A\"];\n+    N1[label=\"N1\"];\n+    N0 -> N1[label=\"A-1\"];\n+}\n+\"#);\n+    }\n+\n     #[test]\n     fn single_cyclic_node() {\n         let labels : Trivial = UnlabelledNodes(1);"}, {"sha": "f46d96ffe4a3567558a3857cfebe90d9920cd738", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -1027,7 +1027,6 @@ mod test {\n     use std::rt::task::TaskOpts;\n     use std::rt::task::Task;\n     use std::rt::local::Local;\n-    use std::time::Duration;\n \n     use {TaskState, PoolConfig, SchedPool};\n     use basic;"}, {"sha": "c5d076a70b5823985ad153acd12da4b71dfe03e4", "filename": "src/libnum/integer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibnum%2Finteger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibnum%2Finteger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Finteger.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -462,6 +462,7 @@ macro_rules! impl_integer_for_uint {\n             }\n \n             #[test]\n+            #[allow(type_overflow)]\n             fn test_lcm() {\n                 assert_eq!((1 as $T).lcm(&0), 0 as $T);\n                 assert_eq!((0 as $T).lcm(&1), 0 as $T);"}, {"sha": "d6b02a1d0639efb51e713831234b4f40ce6363b8", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -641,41 +641,50 @@ impl<'a> Context<'a> {\n         // rlibs/dylibs.\n         let sess = self.sess;\n         let dylibname = self.dylibname();\n-        let mut locs = locs.iter().map(|l| Path::new(l.as_slice())).filter(|loc| {\n-            if !loc.exists() {\n-                sess.err(format!(\"extern location does not exist: {}\",\n-                                 loc.display()).as_slice());\n-                return false;\n-            }\n-            let file = loc.filename_str().unwrap();\n-            if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n-                return true\n-            } else {\n-                match dylibname {\n-                    Some((prefix, suffix)) => {\n-                        if file.starts_with(prefix) && file.ends_with(suffix) {\n-                            return true\n+        let mut rlibs = HashSet::new();\n+        let mut dylibs = HashSet::new();\n+        {\n+            let mut locs = locs.iter().map(|l| Path::new(l.as_slice())).filter(|loc| {\n+                if !loc.exists() {\n+                    sess.err(format!(\"extern location for {} does not exist: {}\",\n+                                     self.crate_name, loc.display()).as_slice());\n+                    return false;\n+                }\n+                let file = match loc.filename_str() {\n+                    Some(file) => file,\n+                    None => {\n+                        sess.err(format!(\"extern location for {} is not a file: {}\",\n+                                         self.crate_name, loc.display()).as_slice());\n+                        return false;\n+                    }\n+                };\n+                if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n+                    return true\n+                } else {\n+                    match dylibname {\n+                        Some((prefix, suffix)) => {\n+                            if file.starts_with(prefix) && file.ends_with(suffix) {\n+                                return true\n+                            }\n                         }\n+                        None => {}\n                     }\n-                    None => {}\n                 }\n-            }\n-            sess.err(format!(\"extern location is of an unknown type: {}\",\n-                             loc.display()).as_slice());\n-            false\n-        });\n+                sess.err(format!(\"extern location for {} is of an unknown type: {}\",\n+                                 self.crate_name, loc.display()).as_slice());\n+                false\n+            });\n \n-        // Now that we have an iterator of good candidates, make sure there's at\n-        // most one rlib and at most one dylib.\n-        let mut rlibs = HashSet::new();\n-        let mut dylibs = HashSet::new();\n-        for loc in locs {\n-            if loc.filename_str().unwrap().ends_with(\".rlib\") {\n-                rlibs.insert(fs::realpath(&loc).unwrap());\n-            } else {\n-                dylibs.insert(fs::realpath(&loc).unwrap());\n+            // Now that we have an iterator of good candidates, make sure there's at\n+            // most one rlib and at most one dylib.\n+            for loc in locs {\n+                if loc.filename_str().unwrap().ends_with(\".rlib\") {\n+                    rlibs.insert(fs::realpath(&loc).unwrap());\n+                } else {\n+                    dylibs.insert(fs::realpath(&loc).unwrap());\n+                }\n             }\n-        }\n+        };\n \n         // Extract the rlib/dylib pair.\n         let mut metadata = None;"}, {"sha": "3f725b86420cd21160d52fab31f8bb9120f31390", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -32,7 +32,7 @@ use syntax::ptr::P;\n use syntax::visit::{mod, Visitor, FnKind};\n use util::ppaux::ty_to_string;\n \n-pub const DUMMY_WILD_PAT: Pat = Pat {\n+pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n     node: PatWild(PatWildSingle),\n     span: DUMMY_SP\n@@ -309,12 +309,11 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n }\n \n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n-    match is_useful(cx, matrix, &[&DUMMY_WILD_PAT], ConstructWitness) {\n+    match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n-            let dummy = DUMMY_WILD_PAT.clone();\n             let witness = match pats.as_slice() {\n                 [ref witness] => &**witness,\n-                [] => &dummy,\n+                [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n             };\n             span_err!(cx.tcx.sess, sp, E0004,\n@@ -568,9 +567,8 @@ fn is_useful(cx: &MatchCheckCtxt,\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n                                 let pat_slice = pats.as_slice();\n-                                let dummy = DUMMY_WILD_PAT.clone();\n                                 let subpats = Vec::from_fn(arity, |i| {\n-                                    pat_slice.get(i).map_or(&dummy, |p| &**p)\n+                                    pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 });\n                                 vec![construct_witness(cx, &c, subpats, left_ty)]\n                             };\n@@ -592,9 +590,8 @@ fn is_useful(cx: &MatchCheckCtxt,\n                 }).collect();\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     UsefulWithWitness(pats) => {\n-                        let dummy = DUMMY_WILD_PAT.clone();\n                         let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = Vec::from_elem(arity, &dummy);\n+                        let wild_pats = Vec::from_elem(arity, DUMMY_WILD_PAT);\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                         let mut new_pats = vec![enum_pat];\n                         new_pats.extend(pats.into_iter());\n@@ -615,11 +612,10 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          v: &[&Pat], ctor: Constructor, lty: ty::t,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n-    let dummy = DUMMY_WILD_PAT.clone();\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, r.as_slice(), &dummy, &ctor, 0u, arity)\n+        specialize(cx, r.as_slice(), &ctor, 0u, arity)\n     }).collect());\n-    match specialize(cx, v, &dummy, &ctor, 0u, arity) {\n+    match specialize(cx, v, &ctor, 0u, arity) {\n         Some(v) => is_useful(cx, &matrix, v.as_slice(), witness),\n         None => NotUseful\n     }\n@@ -741,15 +737,15 @@ fn range_covered_by_constructor(ctor: &Constructor,\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n+pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                       constructor: &Constructor, col: uint, arity: uint) -> Option<Vec<&'a Pat>> {\n     let &Pat {\n         id: pat_id, node: ref node, span: pat_span\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match node {\n \n         &PatWild(_) =>\n-            Some(Vec::from_elem(arity, dummy)),\n+            Some(Vec::from_elem(arity, DUMMY_WILD_PAT)),\n \n         &PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n@@ -762,7 +758,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n                 } else {\n                     None\n                 },\n-                _ => Some(Vec::from_elem(arity, dummy))\n+                _ => Some(Vec::from_elem(arity, DUMMY_WILD_PAT))\n             }\n         }\n \n@@ -776,7 +772,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n                 DefVariant(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.iter().map(|p| &**p).collect(),\n-                        &None => Vec::from_elem(arity, dummy)\n+                        &None => Vec::from_elem(arity, DUMMY_WILD_PAT)\n                     })\n                 }\n                 _ => None\n@@ -812,7 +808,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n                 let args = struct_fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n                         Some(ref f) => &*f.pat,\n-                        _ => dummy\n+                        _ => DUMMY_WILD_PAT\n                     }\n                 }).collect();\n                 args\n@@ -855,13 +851,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n                 // Fixed-length vectors.\n                 Single => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| dummy);\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| DUMMY_WILD_PAT);\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| dummy);\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| DUMMY_WILD_PAT);\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n@@ -931,7 +927,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n \n fn is_refutable<A>(cx: &MatchCheckCtxt, pat: &Pat, refutable: |&Pat| -> A) -> Option<A> {\n     let pats = Matrix(vec!(vec!(pat)));\n-    match is_useful(cx, &pats, [&DUMMY_WILD_PAT], ConstructWitness) {\n+    match is_useful(cx, &pats, [DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             assert_eq!(pats.len(), 1);\n             Some(refutable(&*pats[0]))"}, {"sha": "2a2655cc49c668eac36a015c8bae267edca380b9", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -32,13 +32,16 @@ struct RvalueContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n-                _: visit::FnKind<'v>,\n+                fk: visit::FnKind<'v>,\n                 fd: &'v ast::FnDecl,\n                 b: &'v ast::Block,\n-                _: Span,\n+                s: Span,\n                 _: ast::NodeId) {\n-        let mut euv = euv::ExprUseVisitor::new(self, self.tcx);\n-        euv.walk_fn(fd, b);\n+        {\n+            let mut euv = euv::ExprUseVisitor::new(self, self.tcx);\n+            euv.walk_fn(fd, b);\n+        }\n+        visit::walk_fn(self, fk, fd, b, s)\n     }\n }\n "}, {"sha": "61b013d795ea029b40fe39dff68099e1fb8aa32c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -441,6 +441,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     fn should_warn_about_item(&mut self, item: &ast::Item) -> bool {\n         let should_warn = match item.node {\n             ast::ItemStatic(..)\n+            | ast::ItemConst(..)\n             | ast::ItemFn(..)\n             | ast::ItemEnum(..)\n             | ast::ItemStruct(..) => true,"}, {"sha": "3a1058c009f6c6075b3b8444620b43633192ecbe", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -352,19 +352,6 @@ struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pats: Vec<&'p ast::Pat>,\n     data: &'a ArmData<'p, 'blk, 'tcx>,\n     bound_ptrs: Vec<(Ident, ValueRef)>,\n-\n-    // This is a pointer to an instance of check_match::DUMMY_WILD_PAT. The\n-    // check_match code requires that we pass this in (with the same lifetime as\n-    // the patterns passed in). Unfortunately this is required to be propagated\n-    // into this structure in order to get the lifetimes to work.\n-    //\n-    // Lots of the `check_match` code will deal with &DUMMY_WILD_PAT when\n-    // returning references, which used to have the `'static` lifetime before\n-    // const was added to the language. The DUMMY_WILD_PAT does not implement\n-    // Sync, however, so it must be a const, which longer has a static lifetime,\n-    // hence we're passing it in here. This certainly isn't crucial, and if it\n-    // can be removed, please do!\n-    dummy: &'p ast::Pat,\n }\n \n impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n@@ -417,7 +404,6 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         *pats.get_mut(col) = pat;\n         Match {\n             pats: pats,\n-            dummy: br.dummy,\n             data: &*br.data,\n             bound_ptrs: bound_ptrs\n         }\n@@ -465,7 +451,6 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n             Match {\n                 pats: pats,\n-                dummy: br.dummy,\n                 data: br.data,\n                 bound_ptrs: bound_ptrs\n             }\n@@ -560,8 +545,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n \n     let mcx = check_match::MatchCheckCtxt { tcx: bcx.tcx() };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, pats.as_slice(), m[0].dummy, &ctor, col,\n-                                variant_size)\n+        check_match::specialize(&mcx, pats.as_slice(), &ctor, col, variant_size)\n     )\n }\n \n@@ -1051,7 +1035,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     match adt_vals {\n         Some(field_vals) => {\n             let pats = enter_match(bcx, dm, m, col, val, |pats|\n-                check_match::specialize(&mcx, pats, m[0].dummy,\n+                check_match::specialize(&mcx, pats,\n                                         &check_match::Single, col,\n                                         field_vals.len())\n             );\n@@ -1375,7 +1359,6 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         bindings_map: create_bindings_map(bcx, &**arm.pats.get(0), discr_expr, &*arm.body)\n     }).collect();\n \n-    let dummy = check_match::DUMMY_WILD_PAT.clone();\n     let mut static_inliner = StaticInliner::new(scope_cx.tcx());\n     let arm_pats: Vec<Vec<P<ast::Pat>>> = arm_datas.iter().map(|arm_data| {\n         arm_data.arm.pats.iter().map(|p| static_inliner.fold_pat((*p).clone())).collect()\n@@ -1384,7 +1367,6 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     for (arm_data, pats) in arm_datas.iter().zip(arm_pats.iter()) {\n         matches.extend(pats.iter().map(|p| Match {\n             pats: vec![&**p],\n-            dummy: &dummy,\n             data: arm_data,\n             bound_ptrs: Vec::new(),\n         }));"}, {"sha": "1b23841c913ce625b83c9495943e44a6131a3b79", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -788,7 +788,7 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                          llself.is_some(),\n                          abi);\n \n-        fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n+        fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n         // Invoke the actual rust fn and update bcx/llresult.\n         let (llret, b) = base::invoke(bcx,\n@@ -829,12 +829,15 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                          cleanup::CustomScope(arg_cleanup_scope),\n                          false,\n                          abi);\n-        fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n+        fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n+\n         bcx = foreign::trans_native_call(bcx, callee_ty,\n                                          llfn, opt_llretslot.unwrap(),\n                                          llargs.as_slice(), arg_tys);\n     }\n \n+    fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);\n+\n     // If the caller doesn't care about the result of this fn call,\n     // drop the temporary slot we made.\n     match (dest, opt_llretslot) {"}, {"sha": "f3844a956faddece67bfd56cc71390bdc38681b8", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -74,6 +74,7 @@ pub struct CachedEarlyExit {\n pub trait Cleanup {\n     fn must_unwind(&self) -> bool;\n     fn clean_on_unwind(&self) -> bool;\n+    fn is_lifetime_end(&self) -> bool;\n     fn trans<'blk, 'tcx>(&self,\n                          bcx: Block<'blk, 'tcx>,\n                          debug_loc: Option<NodeInfo>)\n@@ -875,6 +876,10 @@ impl<'blk, 'tcx> CleanupScope<'blk, 'tcx> {\n             LoopScopeKind(id, _) => format!(\"{}_loop_{}_\", prefix, id),\n         }\n     }\n+\n+    pub fn drop_non_lifetime_clean(&mut self) {\n+        self.cleanups.retain(|c| c.is_lifetime_end());\n+    }\n }\n \n impl<'blk, 'tcx> CleanupScopeKind<'blk, 'tcx> {\n@@ -943,6 +948,10 @@ impl Cleanup for DropValue {\n         self.must_unwind\n     }\n \n+    fn is_lifetime_end(&self) -> bool {\n+        false\n+    }\n+\n     fn trans<'blk, 'tcx>(&self,\n                          bcx: Block<'blk, 'tcx>,\n                          debug_loc: Option<NodeInfo>)\n@@ -978,6 +987,10 @@ impl Cleanup for FreeValue {\n         true\n     }\n \n+    fn is_lifetime_end(&self) -> bool {\n+        false\n+    }\n+\n     fn trans<'blk, 'tcx>(&self,\n                          bcx: Block<'blk, 'tcx>,\n                          debug_loc: Option<NodeInfo>)\n@@ -1008,6 +1021,10 @@ impl Cleanup for FreeSlice {\n         true\n     }\n \n+    fn is_lifetime_end(&self) -> bool {\n+        false\n+    }\n+\n     fn trans<'blk, 'tcx>(&self,\n                          bcx: Block<'blk, 'tcx>,\n                          debug_loc: Option<NodeInfo>)\n@@ -1035,6 +1052,10 @@ impl Cleanup for LifetimeEnd {\n         true\n     }\n \n+    fn is_lifetime_end(&self) -> bool {\n+        true\n+    }\n+\n     fn trans<'blk, 'tcx>(&self,\n                          bcx: Block<'blk, 'tcx>,\n                          debug_loc: Option<NodeInfo>)"}, {"sha": "b328df1949e0e57ab9e2b608e3671109073b1e64", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -655,19 +655,19 @@ mod test {\n \n     #[test]\n     fn smoke_lock() {\n-        static lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n-            let _guard = lock.lock();\n+            let _guard = LK.lock();\n         }\n     }\n \n     #[test]\n     fn smoke_cond() {\n-        static lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n-            let guard = lock.lock();\n+            let guard = LK.lock();\n             let t = Thread::start(proc() {\n-                let guard = lock.lock();\n+                let guard = LK.lock();\n                 guard.signal();\n             });\n             guard.wait();\n@@ -679,25 +679,25 @@ mod test {\n \n     #[test]\n     fn smoke_lock_noguard() {\n-        static lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n-            lock.lock_noguard();\n-            lock.unlock_noguard();\n+            LK.lock_noguard();\n+            LK.unlock_noguard();\n         }\n     }\n \n     #[test]\n     fn smoke_cond_noguard() {\n-        static lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n-            lock.lock_noguard();\n+            LK.lock_noguard();\n             let t = Thread::start(proc() {\n-                lock.lock_noguard();\n-                lock.signal_noguard();\n-                lock.unlock_noguard();\n+                LK.lock_noguard();\n+                LK.signal_noguard();\n+                LK.unlock_noguard();\n             });\n-            lock.wait_noguard();\n-            lock.unlock_noguard();\n+            LK.wait_noguard();\n+            LK.unlock_noguard();\n \n             t.join();\n         }"}, {"sha": "eda38e96cbb1afa9089ffa2211a2a2b42421120b", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -2964,8 +2964,8 @@ mod tests {\n         let s = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n         let obj: FloatStruct = super::decode(s).unwrap();\n         assert!(obj.f.is_nan());\n-        assert!(obj.a.get(0).is_nan());\n-        assert_eq!(obj.a.get(1), &123f64);\n+        assert!(obj.a[0].is_nan());\n+        assert_eq!(obj.a[1], 123f64);\n     }\n \n     #[test]"}, {"sha": "71d38ac66597fc7246f30ce116b0ec3ec970fb2a", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -582,15 +582,15 @@ mod tests {\n         assert_eq!('A'.to_ascii().to_char(), 'A');\n         assert_eq!('A'.to_ascii().to_byte(), 65u8);\n \n-        assert_eq!('A'.to_ascii().to_lower().to_char(), 'a');\n-        assert_eq!('Z'.to_ascii().to_lower().to_char(), 'z');\n-        assert_eq!('a'.to_ascii().to_upper().to_char(), 'A');\n-        assert_eq!('z'.to_ascii().to_upper().to_char(), 'Z');\n-\n-        assert_eq!('@'.to_ascii().to_lower().to_char(), '@');\n-        assert_eq!('['.to_ascii().to_lower().to_char(), '[');\n-        assert_eq!('`'.to_ascii().to_upper().to_char(), '`');\n-        assert_eq!('{'.to_ascii().to_upper().to_char(), '{');\n+        assert_eq!('A'.to_ascii().to_lowercase().to_char(), 'a');\n+        assert_eq!('Z'.to_ascii().to_lowercase().to_char(), 'z');\n+        assert_eq!('a'.to_ascii().to_uppercase().to_char(), 'A');\n+        assert_eq!('z'.to_ascii().to_uppercase().to_char(), 'Z');\n+\n+        assert_eq!('@'.to_ascii().to_lowercase().to_char(), '@');\n+        assert_eq!('['.to_ascii().to_lowercase().to_char(), '[');\n+        assert_eq!('`'.to_ascii().to_uppercase().to_char(), '`');\n+        assert_eq!('{'.to_ascii().to_uppercase().to_char(), '{');\n \n         assert!('0'.to_ascii().is_digit());\n         assert!('9'.to_ascii().is_digit());"}, {"sha": "42e3a823ff4f59abb0463dfce8149db23f78bfb9", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -273,8 +273,8 @@ mod tests {\n     }\n \n     bitflags! {\n-        flags AnotherSetOfFlags: uint {\n-            const AnotherFlag = 1u,\n+        flags AnotherSetOfFlags: i8 {\n+            const AnotherFlag = -1_i8,\n         }\n     }\n \n@@ -283,6 +283,9 @@ mod tests {\n         assert_eq!(Flags::empty().bits(), 0x00000000);\n         assert_eq!(FlagA.bits(), 0x00000001);\n         assert_eq!(FlagABC.bits(), 0x00000111);\n+\n+        assert_eq!(AnotherSetOfFlags::empty().bits(), 0x00);\n+        assert_eq!(AnotherFlag.bits(), !0_i8);\n     }\n \n     #[test]\n@@ -292,6 +295,8 @@ mod tests {\n         assert!(Flags::from_bits(0x10) == Some(FlagB));\n         assert!(Flags::from_bits(0x11) == Some(FlagA | FlagB));\n         assert!(Flags::from_bits(0x1000) == None);\n+\n+        assert!(AnotherSetOfFlags::from_bits(!0_i8) == Some(AnotherFlag));\n     }\n \n     #[test]\n@@ -302,27 +307,35 @@ mod tests {\n         assert!(Flags::from_bits_truncate(0x11) == (FlagA | FlagB));\n         assert!(Flags::from_bits_truncate(0x1000) == Flags::empty());\n         assert!(Flags::from_bits_truncate(0x1001) == FlagA);\n+\n+        assert!(AnotherSetOfFlags::from_bits_truncate(0_i8) == AnotherSetOfFlags::empty());\n     }\n \n     #[test]\n     fn test_is_empty(){\n         assert!(Flags::empty().is_empty());\n         assert!(!FlagA.is_empty());\n         assert!(!FlagABC.is_empty());\n+\n+        assert!(!AnotherFlag.is_empty());\n     }\n \n     #[test]\n     fn test_is_all() {\n         assert!(Flags::all().is_all());\n         assert!(!FlagA.is_all());\n         assert!(FlagABC.is_all());\n+\n+        assert!(AnotherFlag.is_all());\n     }\n \n     #[test]\n     fn test_two_empties_do_not_intersect() {\n         let e1 = Flags::empty();\n         let e2 = Flags::empty();\n         assert!(!e1.intersects(e2));\n+\n+        assert!(AnotherFlag.intersects(AnotherFlag));\n     }\n \n     #[test]\n@@ -353,6 +366,8 @@ mod tests {\n         assert!(!e1.contains(e2));\n         assert!(e2.contains(e1));\n         assert!(FlagABC.contains(e2));\n+\n+        assert!(AnotherFlag.contains(AnotherFlag));\n     }\n \n     #[test]\n@@ -361,6 +376,10 @@ mod tests {\n         let e2 = FlagA | FlagB;\n         e1.insert(e2);\n         assert!(e1 == e2);\n+\n+        let mut e3 = AnotherSetOfFlags::empty();\n+        e3.insert(AnotherFlag);\n+        assert!(e3 == AnotherFlag);\n     }\n \n     #[test]\n@@ -369,6 +388,10 @@ mod tests {\n         let e2 = FlagA | FlagC;\n         e1.remove(e2);\n         assert!(e1 == FlagB);\n+\n+        let mut e3 = AnotherFlag;\n+        e3.remove(AnotherFlag);\n+        assert!(e3 == AnotherSetOfFlags::empty());\n     }\n \n     #[test]\n@@ -383,6 +406,10 @@ mod tests {\n         let mut e3 = e1;\n         e3.toggle(e2);\n         assert!(e3 == FlagA | FlagB);\n+\n+        let mut m4 = AnotherSetOfFlags::empty();\n+        m4.toggle(AnotherSetOfFlags::empty());\n+        assert!(m4 == AnotherSetOfFlags::empty());\n     }\n \n     #[test]"}, {"sha": "bdd9d8d9d1f5977f4458abbfc82d4b844153b114", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -1930,6 +1930,7 @@ mod test_map {\n     }\n \n     #[test]\n+    #[allow(deprecated)] // insert_or_update_with\n     fn test_update_with() {\n         let mut m = HashMap::with_capacity(4);\n         assert!(m.insert(1i, 2i));"}, {"sha": "8ab0d3a5504017e26af48204acaf681ad98134ba", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -400,7 +400,7 @@ mod test {\n \n     impl Reader for ShortReader {\n         fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-            match self.lengths.shift() {\n+            match self.lengths.remove(0) {\n                 Some(i) => Ok(i),\n                 None => Err(io::standard_error(io::EndOfFile))\n             }\n@@ -551,7 +551,7 @@ mod test {\n \n     #[test]\n     fn test_read_line() {\n-        let in_buf = MemReader::new(Vec::from_slice(b\"a\\nb\\nc\"));\n+        let in_buf = MemReader::new(b\"a\\nb\\nc\".to_vec());\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         assert_eq!(reader.read_line(), Ok(\"a\\n\".to_string()));\n         assert_eq!(reader.read_line(), Ok(\"b\\n\".to_string()));\n@@ -561,7 +561,7 @@ mod test {\n \n     #[test]\n     fn test_lines() {\n-        let in_buf = MemReader::new(Vec::from_slice(b\"a\\nb\\nc\"));\n+        let in_buf = MemReader::new(b\"a\\nb\\nc\".to_vec());\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n         assert_eq!(it.next(), Some(Ok(\"a\\n\".to_string())));"}, {"sha": "e8fed67fffed14c6420612111c783baf00279fc7", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -1415,7 +1415,7 @@ mod test {\n         check!(copy(&input, &output));\n \n         assert_eq!(check!(File::open(&output).read_to_end()),\n-                   (Vec::from_slice(b\"foo\")));\n+                   b\"foo\".to_vec());\n     }\n \n     #[test]\n@@ -1459,7 +1459,7 @@ mod test {\n         }\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n-                   (Vec::from_slice(b\"foobar\")));\n+                   b\"foobar\".to_vec());\n     }\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n@@ -1497,7 +1497,7 @@ mod test {\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(stat(&out)).size, check!(input.stat()).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n-                   (Vec::from_slice(b\"foobar\")));\n+                   b\"foobar\".to_vec());\n \n         // can't link to yourself\n         match link(&input, &input) {\n@@ -1560,7 +1560,7 @@ mod test {\n         check!(file.fsync());\n         assert_eq!(check!(file.stat()).size, 10);\n         assert_eq!(check!(File::open(&path).read_to_end()),\n-                   (Vec::from_slice(b\"foobar\\0\\0\\0\\0\")));\n+                   b\"foobar\\0\\0\\0\\0\".to_vec());\n \n         // Truncate to a smaller length, don't seek, and then write something.\n         // Ensure that the intermediate zeroes are all filled in (we're seeked\n@@ -1571,7 +1571,7 @@ mod test {\n         check!(file.fsync());\n         assert_eq!(check!(file.stat()).size, 9);\n         assert_eq!(check!(File::open(&path).read_to_end()),\n-                   (Vec::from_slice(b\"fo\\0\\0\\0\\0wut\")));\n+                   b\"fo\\0\\0\\0\\0wut\".to_vec());\n         drop(file);\n     }\n "}, {"sha": "f86ae05d623ca462c2a70e87c9e899b19326d996", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -617,7 +617,7 @@ mod test {\n     #[bench]\n     fn bench_mem_reader(b: &mut Bencher) {\n         b.iter(|| {\n-            let buf = Vec::from_slice([5 as u8, ..100]);\n+            let buf = [5 as u8, ..100].to_vec();\n             {\n                 let mut rdr = MemReader::new(buf);\n                 for _i in range(0u, 10) {"}, {"sha": "8592d48974a25f8c143a202cb01b2dbf4fddbc58", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -1949,62 +1949,62 @@ mod tests {\n                         return Ok(0);\n                     }\n                 };\n-                behavior.shift();\n+                behavior.remove(0);\n             }\n         }\n     }\n \n     #[test]\n     fn test_read_at_least() {\n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n-                                   Vec::from_slice([GoodBehavior(uint::MAX)]));\n+        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n+                                   vec![GoodBehavior(uint::MAX)]);\n         let mut buf = [0u8, ..5];\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n         assert!(r.read_exact(5).unwrap().len() == 5); // read_exact uses read_at_least\n         assert!(r.read_at_least(0, buf).is_ok());\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n-                                   Vec::from_slice([BadBehavior(50), GoodBehavior(uint::MAX)]));\n+        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n+                                   vec![BadBehavior(50), GoodBehavior(uint::MAX)]);\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n-                                   Vec::from_slice([BadBehavior(1), GoodBehavior(1),\n-                                                    BadBehavior(50), GoodBehavior(uint::MAX)]));\n+        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n+                                   vec![BadBehavior(1), GoodBehavior(1),\n+                                        BadBehavior(50), GoodBehavior(uint::MAX)]);\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n-                                   Vec::from_slice([BadBehavior(uint::MAX)]));\n+        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n+                                   vec![BadBehavior(uint::MAX)]);\n         assert_eq!(r.read_at_least(1, buf).unwrap_err().kind, NoProgress);\n \n-        let mut r = MemReader::new(Vec::from_slice(b\"hello, world!\"));\n+        let mut r = MemReader::new(b\"hello, world!\".to_vec());\n         assert_eq!(r.read_at_least(5, buf).unwrap(), 5);\n         assert_eq!(r.read_at_least(6, buf).unwrap_err().kind, InvalidInput);\n     }\n \n     #[test]\n     fn test_push_at_least() {\n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n-                                   Vec::from_slice([GoodBehavior(uint::MAX)]));\n+        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n+                                   vec![GoodBehavior(uint::MAX)]);\n         let mut buf = Vec::new();\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n         assert!(r.push_at_least(0, 5, &mut buf).is_ok());\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n-                                   Vec::from_slice([BadBehavior(50), GoodBehavior(uint::MAX)]));\n+        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n+                                   vec![BadBehavior(50), GoodBehavior(uint::MAX)]);\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n-                                   Vec::from_slice([BadBehavior(1), GoodBehavior(1),\n-                                                    BadBehavior(50), GoodBehavior(uint::MAX)]));\n+        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n+                                   vec![BadBehavior(1), GoodBehavior(1),\n+                                        BadBehavior(50), GoodBehavior(uint::MAX)]);\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n-                                   Vec::from_slice([BadBehavior(uint::MAX)]));\n+        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n+                                   vec![BadBehavior(uint::MAX)]);\n         assert_eq!(r.push_at_least(1, 5, &mut buf).unwrap_err().kind, NoProgress);\n \n-        let mut r = MemReader::new(Vec::from_slice(b\"hello, world!\"));\n+        let mut r = MemReader::new(b\"hello, world!\".to_vec());\n         assert_eq!(r.push_at_least(5, 1, &mut buf).unwrap_err().kind, InvalidInput);\n     }\n "}, {"sha": "9d85701eb298413dd48a8407d539d5e1b436bed8", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -126,9 +126,7 @@ fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n #[cfg(all(test, not(target_os = \"android\")))]\n mod test {\n     use super::*;\n-    use io::net::tcp::*;\n     use io::net::ip::*;\n-    use io::net::udp::*;\n \n     #[test]\n     fn dns_smoke_test() {"}, {"sha": "d6528ce977e9821e8c9c7412b40c24fca6052894", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -521,10 +521,8 @@ impl Clone for TcpAcceptor {\n #[cfg(test)]\n #[allow(experimental)]\n mod test {\n-    use super::*;\n     use io::net::tcp::*;\n     use io::net::ip::*;\n-    use io::net::udp::*;\n     use io::*;\n     use io::test::*;\n     use prelude::*;"}, {"sha": "9362a48a6f00bb108e340b3820f476d3b7f62c86", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -118,7 +118,6 @@ impl Writer for PipeStream {\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n     use prelude::*;\n \n     #[test]"}, {"sha": "88f8434b9576e12dcfe9fd8380bc482e40991871", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -727,7 +727,7 @@ mod tests {\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.stdout.is_some());\n-        let ret = read_all(p.stdout.get_mut_ref() as &mut Reader);\n+        let ret = read_all(p.stdout.as_mut().unwrap() as &mut Reader);\n         assert!(p.wait().unwrap().success());\n         return ret;\n     }\n@@ -758,9 +758,9 @@ mod tests {\n                             .stdin(CreatePipe(true, false))\n                             .stdout(CreatePipe(false, true))\n                             .spawn().unwrap();\n-        p.stdin.get_mut_ref().write(\"foobar\".as_bytes()).unwrap();\n+        p.stdin.as_mut().unwrap().write(\"foobar\".as_bytes()).unwrap();\n         drop(p.stdin.take());\n-        let out = read_all(p.stdout.get_mut_ref() as &mut Reader);\n+        let out = read_all(p.stdout.as_mut().unwrap() as &mut Reader);\n         assert!(p.wait().unwrap().success());\n         assert_eq!(out, \"foobar\\n\".to_string());\n     }\n@@ -1019,7 +1019,7 @@ mod tests {\n     fn test_add_to_env() {\n         let prog = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n-        let output = str::from_utf8_lossy(result.output.as_slice()).into_string();\n+        let output = String::from_utf8_lossy(result.output.as_slice()).into_string();\n \n         assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);"}, {"sha": "93037f765d635c2d582e7ce2a4be1f0b2066caee", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -385,13 +385,15 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n+    #[test]\n     fn smoke() {\n         // Just make sure we can acquire handles\n         stdin();\n         stdout();\n         stderr();\n     }\n \n+    #[test]\n     fn capture_stdout() {\n         use io::{ChanReader, ChanWriter};\n \n@@ -404,9 +406,10 @@ mod tests {\n         assert_eq!(r.read_to_string().unwrap(), \"hello!\\n\".to_string());\n     }\n \n+    #[test]\n     fn capture_stderr() {\n         use realstd::comm::channel;\n-        use realstd::io::{Writer, ChanReader, ChanWriter, Reader};\n+        use realstd::io::{ChanReader, ChanWriter, Reader};\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));"}, {"sha": "a657989fe1244486b225b7f669be6d44e8ef748d", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -235,7 +235,6 @@ mod test {\n     use super::*;\n     use time::Duration;\n     use task::spawn;\n-    use io::*;\n     use prelude::*;\n \n     #[test]"}, {"sha": "48ee7664c16acb12da8c6530bf52587ddbefd212", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -819,72 +819,82 @@ mod bench {\n     mod uint {\n         use super::test::Bencher;\n         use rand::{weak_rng, Rng};\n-        use num::ToStrRadix;\n+        use std::fmt;\n+\n+        #[inline]\n+        fn to_string(x: uint, base: u8) {\n+            format!(\"{}\", fmt::radix(x, base));\n+        }\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { rng.gen::<uint>().to_str_radix(2); })\n+            b.iter(|| { to_string(rng.gen::<uint>(), 2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { rng.gen::<uint>().to_str_radix(8); })\n+            b.iter(|| { to_string(rng.gen::<uint>(), 8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { rng.gen::<uint>().to_str_radix(10); })\n+            b.iter(|| { to_string(rng.gen::<uint>(), 10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { rng.gen::<uint>().to_str_radix(16); })\n+            b.iter(|| { to_string(rng.gen::<uint>(), 16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { rng.gen::<uint>().to_str_radix(36); })\n+            b.iter(|| { to_string(rng.gen::<uint>(), 36); })\n         }\n     }\n \n     mod int {\n         use super::test::Bencher;\n         use rand::{weak_rng, Rng};\n-        use num::ToStrRadix;\n+        use std::fmt;\n+\n+        #[inline]\n+        fn to_string(x: int, base: u8) {\n+            format!(\"{}\", fmt::radix(x, base));\n+        }\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { rng.gen::<int>().to_str_radix(2); })\n+            b.iter(|| { to_string(rng.gen::<int>(), 2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { rng.gen::<int>().to_str_radix(8); })\n+            b.iter(|| { to_string(rng.gen::<int>(), 8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { rng.gen::<int>().to_str_radix(10); })\n+            b.iter(|| { to_string(rng.gen::<int>(), 10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { rng.gen::<int>().to_str_radix(16); })\n+            b.iter(|| { to_string(rng.gen::<int>(), 16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { rng.gen::<int>().to_str_radix(36); })\n+            b.iter(|| { to_string(rng.gen::<int>(), 36); })\n         }\n     }\n "}, {"sha": "27eafdab642aef00ed89578cbe0e32c32eae9b41", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -775,7 +775,7 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n         t!(v: b\"a/b/c\", [b\"d\", b\"e\"], b\"a/b/c/d/e\");\n         t!(v: b\"a/b/c\", [b\"d\", b\"/e\", b\"f\"], b\"/e/f\");\n-        t!(v: b\"a/b/c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")], b\"a/b/c/d/e\");\n+        t!(v: b\"a/b/c\", [b\"d\".to_vec(), b\"e\".to_vec()], b\"a/b/c/d/e\");\n     }\n \n     #[test]\n@@ -879,7 +879,7 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n         t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n         t!(v: b\"a/b/c\", [b\"d\", b\"e\"], b\"a/b/c/d/e\");\n-        t!(v: b\"a/b/c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")], b\"a/b/c/d/e\");\n+        t!(v: b\"a/b/c\", [b\"d\".to_vec(), b\"e\".to_vec()], b\"a/b/c/d/e\");\n     }\n \n     #[test]"}, {"sha": "8ca1cec3e0ae9675a16ef8aaa02dba8308d969bd", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -76,7 +76,6 @@ mod test {\n \n     use super::ReaderRng;\n     use io::MemReader;\n-    use mem;\n     use rand::Rng;\n \n     #[test]\n@@ -87,25 +86,25 @@ mod test {\n                      0,   0, 0, 0, 0, 0, 0, 3];\n         let mut rng = ReaderRng::new(MemReader::new(v));\n \n-        assert_eq!(rng.next_u64(), mem::to_be64(1));\n-        assert_eq!(rng.next_u64(), mem::to_be64(2));\n-        assert_eq!(rng.next_u64(), mem::to_be64(3));\n+        assert_eq!(rng.next_u64(), 1_u64.to_be());\n+        assert_eq!(rng.next_u64(), 2_u64.to_be());\n+        assert_eq!(rng.next_u64(), 3_u64.to_be());\n     }\n     #[test]\n     fn test_reader_rng_u32() {\n         let v = vec![0u8, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3];\n         let mut rng = ReaderRng::new(MemReader::new(v));\n \n-        assert_eq!(rng.next_u32(), mem::to_be32(1));\n-        assert_eq!(rng.next_u32(), mem::to_be32(2));\n-        assert_eq!(rng.next_u32(), mem::to_be32(3));\n+        assert_eq!(rng.next_u32(), 1_u32.to_be());\n+        assert_eq!(rng.next_u32(), 2_u32.to_be());\n+        assert_eq!(rng.next_u32(), 3_u32.to_be());\n     }\n     #[test]\n     fn test_reader_rng_fill_bytes() {\n         let v = [1u8, 2, 3, 4, 5, 6, 7, 8];\n         let mut w = [0u8, .. 8];\n \n-        let mut rng = ReaderRng::new(MemReader::new(Vec::from_slice(v)));\n+        let mut rng = ReaderRng::new(MemReader::new(v.as_slice().to_vec()));\n         rng.fill_bytes(w);\n \n         assert!(v == w);"}, {"sha": "04d3bb8b3a7eae298c3a22db24de04e28d17efde", "filename": "src/libstd/task.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -447,6 +447,7 @@ mod test {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_with_wrapper() {\n         let (tx, rx) = channel();\n         TaskBuilder::new().with_wrapper(proc(body) {"}, {"sha": "1dc1f4b87f27cbdf2f2babfb810ac90f43072789", "filename": "src/libsync/comm/duplex.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibsync%2Fcomm%2Fduplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibsync%2Fcomm%2Fduplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fduplex.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -59,10 +59,11 @@ impl<S:Send,R:Send> DuplexStream<S, R> {\n     }\n }\n \n+#[allow(deprecated)]\n #[cfg(test)]\n mod test {\n     use std::prelude::*;\n-    use comm::{duplex};\n+    use comm::duplex;\n \n     #[test]\n     pub fn duplex_stream_1() {"}, {"sha": "09fa8920a07d7daff55f56213b3417af62bfcae5", "filename": "src/libsync/deque.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fdeque.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -553,14 +553,12 @@ mod tests {\n         let threads = range(0, NTHREADS).map(|_| {\n             let s = s.clone();\n             Thread::start(proc() {\n-                unsafe {\n-                    loop {\n-                        match s.steal() {\n-                            Data(2) => { HITS.fetch_add(1, SeqCst); }\n-                            Data(..) => fail!(),\n-                            _ if DONE.load(SeqCst) => break,\n-                            _ => {}\n-                        }\n+                loop {\n+                    match s.steal() {\n+                        Data(2) => { HITS.fetch_add(1, SeqCst); }\n+                        Data(..) => fail!(),\n+                        _ if DONE.load(SeqCst) => break,\n+                        _ => {}\n                     }\n                 }\n             })\n@@ -572,7 +570,7 @@ mod tests {\n             if rng.gen_range(0i, 3) == 2 {\n                 match w.pop() {\n                     None => {}\n-                    Some(2) => unsafe { HITS.fetch_add(1, SeqCst); },\n+                    Some(2) => { HITS.fetch_add(1, SeqCst); },\n                     Some(_) => fail!(),\n                 }\n             } else {\n@@ -581,22 +579,20 @@ mod tests {\n             }\n         }\n \n-        unsafe {\n-            while HITS.load(SeqCst) < AMT as uint {\n-                match w.pop() {\n-                    None => {}\n-                    Some(2) => { HITS.fetch_add(1, SeqCst); },\n-                    Some(_) => fail!(),\n-                }\n+        while HITS.load(SeqCst) < AMT as uint {\n+            match w.pop() {\n+                None => {}\n+                Some(2) => { HITS.fetch_add(1, SeqCst); },\n+                Some(_) => fail!(),\n             }\n-            DONE.store(true, SeqCst);\n         }\n+        DONE.store(true, SeqCst);\n \n         for thread in threads.into_iter() {\n             thread.join();\n         }\n \n-        assert_eq!(unsafe { HITS.load(SeqCst) }, expected as uint);\n+        assert_eq!(HITS.load(SeqCst), expected as uint);\n     }\n \n     #[test]\n@@ -655,7 +651,7 @@ mod tests {\n             }\n         }\n \n-        unsafe { DONE.store(true, SeqCst); }\n+        DONE.store(true, SeqCst);\n \n         for thread in threads.into_iter() {\n             thread.join();"}, {"sha": "796c62354c3113b7502c29f81ad53cb866366b64", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -536,45 +536,45 @@ mod test {\n \n     #[test]\n     fn smoke_static() {\n-        static m: StaticMutex = MUTEX_INIT;\n+        static M: StaticMutex = MUTEX_INIT;\n         unsafe {\n-            drop(m.lock());\n-            drop(m.lock());\n-            m.destroy();\n+            drop(M.lock());\n+            drop(M.lock());\n+            M.destroy();\n         }\n     }\n \n     #[test]\n     fn lots_and_lots() {\n-        static m: StaticMutex = MUTEX_INIT;\n+        static M: StaticMutex = MUTEX_INIT;\n         static mut CNT: uint = 0;\n-        static M: uint = 1000;\n-        static N: uint = 3;\n+        static J: uint = 1000;\n+        static K: uint = 3;\n \n         fn inc() {\n-            for _ in range(0, M) {\n+            for _ in range(0, J) {\n                 unsafe {\n-                    let _g = m.lock();\n+                    let _g = M.lock();\n                     CNT += 1;\n                 }\n             }\n         }\n \n         let (tx, rx) = channel();\n-        for _ in range(0, N) {\n+        for _ in range(0, K) {\n             let tx2 = tx.clone();\n             native::task::spawn(proc() { inc(); tx2.send(()); });\n             let tx2 = tx.clone();\n             spawn(proc() { inc(); tx2.send(()); });\n         }\n \n         drop(tx);\n-        for _ in range(0, 2 * N) {\n+        for _ in range(0, 2 * K) {\n             rx.recv();\n         }\n-        assert_eq!(unsafe {CNT}, M * N * 2);\n+        assert_eq!(unsafe {CNT}, J * K * 2);\n         unsafe {\n-            m.destroy();\n+            M.destroy();\n         }\n     }\n "}, {"sha": "62b3766091226aaf1515bb6a8fa996bed174f92b", "filename": "src/libsync/one.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibsync%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibsync%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fone.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -126,17 +126,17 @@ mod test {\n \n     #[test]\n     fn smoke_once() {\n-        static o: Once = ONCE_INIT;\n+        static O: Once = ONCE_INIT;\n         let mut a = 0i;\n-        o.doit(|| a += 1);\n+        O.doit(|| a += 1);\n         assert_eq!(a, 1);\n-        o.doit(|| a += 1);\n+        O.doit(|| a += 1);\n         assert_eq!(a, 1);\n     }\n \n     #[test]\n     fn stampede_once() {\n-        static o: Once = ONCE_INIT;\n+        static O: Once = ONCE_INIT;\n         static mut run: bool = false;\n \n         let (tx, rx) = channel();\n@@ -145,7 +145,7 @@ mod test {\n             spawn(proc() {\n                 for _ in range(0u, 4) { task::deschedule() }\n                 unsafe {\n-                    o.doit(|| {\n+                    O.doit(|| {\n                         assert!(!run);\n                         run = true;\n                     });\n@@ -156,7 +156,7 @@ mod test {\n         }\n \n         unsafe {\n-            o.doit(|| {\n+            O.doit(|| {\n                 assert!(!run);\n                 run = true;\n             });"}, {"sha": "c1aa588eecc49f94d1746fdc2cdfbb52d63ad679", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -1333,14 +1333,16 @@ impl Item_ {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n             ItemStatic(..) => \"static item\",\n+            ItemConst(..) => \"constant item\",\n             ItemFn(..) => \"function\",\n             ItemMod(..) => \"module\",\n             ItemForeignMod(..) => \"foreign module\",\n             ItemTy(..) => \"type alias\",\n             ItemEnum(..) => \"enum\",\n             ItemStruct(..) => \"struct\",\n             ItemTrait(..) => \"trait\",\n-            _ => \"item\"\n+            ItemMac(..) |\n+            ItemImpl(..) => \"item\"\n         }\n     }\n }"}, {"sha": "a1bce6e8e8b048b1814b24834c5848db5436ded1", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -575,7 +575,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n \n #[cfg(test)]\n mod test {\n-    use super::{expand,Words,Variables,Number};\n+    use super::{expand,Param,Words,Variables,Number};\n     use std::result::Ok;\n \n     #[test]\n@@ -605,40 +605,39 @@ mod test {\n     fn test_param_stack_failure_conditions() {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n+        fn get_res(fmt: &str, cap: &str, params: &[Param], vars: &mut Variables) ->\n+            Result<Vec<u8>, String>\n+        {\n+            let mut u8v: Vec<_> = fmt.bytes().collect();\n+            u8v.extend(cap.as_bytes().iter().map(|&b| b));\n+            expand(u8v.as_slice(), params, vars)\n+        }\n+\n         let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n-        for cap in caps.iter() {\n-            let res = expand(cap.as_bytes(), [], vars);\n+        for &cap in caps.iter() {\n+            let res = get_res(\"\", cap, [], vars);\n             assert!(res.is_err(),\n-                    \"Op {} succeeded incorrectly with 0 stack entries\", *cap);\n-            let p = if *cap == \"%s\" || *cap == \"%l\" {\n+                    \"Op {} succeeded incorrectly with 0 stack entries\", cap);\n+            let p = if cap == \"%s\" || cap == \"%l\" {\n                 Words(\"foo\".to_string())\n             } else {\n                 Number(97)\n             };\n-            let res = expand(\"%p1\".bytes().collect::<Vec<_>>()\n-                             .append(cap.as_bytes()).as_slice(),\n-                             [p],\n-                             vars);\n+            let res = get_res(\"%p1\", cap, [p], vars);\n             assert!(res.is_ok(),\n-                    \"Op {} failed with 1 stack entry: {}\", *cap, res.unwrap_err());\n+                    \"Op {} failed with 1 stack entry: {}\", cap, res.unwrap_err());\n         }\n         let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n-        for cap in caps.iter() {\n+        for &cap in caps.iter() {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n-                    \"Binop {} succeeded incorrectly with 0 stack entries\", *cap);\n-            let res = expand(\"%{1}\".bytes().collect::<Vec<_>>()\n-                             .append(cap.as_bytes()).as_slice(),\n-                              [],\n-                              vars);\n+                    \"Binop {} succeeded incorrectly with 0 stack entries\", cap);\n+            let res = get_res(\"%{1}\", cap, [], vars);\n             assert!(res.is_err(),\n-                    \"Binop {} succeeded incorrectly with 1 stack entry\", *cap);\n-            let res = expand(\"%{1}%{2}\".bytes().collect::<Vec<_>>()\n-                             .append(cap.as_bytes()).as_slice(),\n-                             [],\n-                             vars);\n+                    \"Binop {} succeeded incorrectly with 1 stack entry\", cap);\n+            let res = get_res(\"%{1}%{2}\", cap, [], vars);\n             assert!(res.is_ok(),\n-                    \"Binop {} failed with 2 stack entries: {}\", *cap, res.unwrap_err());\n+                    \"Binop {} failed with 2 stack entries: {}\", cap, res.unwrap_err());\n         }\n     }\n "}, {"sha": "b84aec77a09c343d6f92b9286a4c891ccc0a6193", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -64,6 +64,7 @@ pub mod char {\n     pub use normalize::{decompose_canonical, decompose_compatible, compose};\n \n     pub use tables::normalization::canonical_combining_class;\n+    pub use tables::UNICODE_VERSION;\n \n     pub use u_char::{is_alphabetic, is_XID_start, is_XID_continue};\n     pub use u_char::{is_lowercase, is_uppercase, is_whitespace};"}, {"sha": "3f15abcad6dcd6f093ee22a099e3116476092e89", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -12,6 +12,10 @@\n \n #![allow(missing_doc, non_uppercase_statics, non_snake_case)]\n \n+/// The version of [Unicode](http://www.unicode.org/)\n+/// that the `UnicodeChar` and `UnicodeStrSlice` traits are based on.\n+pub const UNICODE_VERSION: (uint, uint, uint) = (7, 0, 0);\n+\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::{Equal, Less, Greater};\n     use core::slice::ImmutableSlice;"}, {"sha": "9b7df81a5dcbd666e0e489327f6dc9d97516f519", "filename": "src/test/compile-fail/empty-extern-arg.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --extern std=\n+// error-pattern: is not a file\n+\n+fn main() {}"}, {"sha": "ef8174a26aa8206964e2a9c98d86946f38513f44", "filename": "src/test/compile-fail/issue-17651.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that moves of unsized values within closures are caught\n+// and rejected.\n+\n+fn main() {\n+    (|| box *[0u].as_slice())();\n+    //~^ ERROR cannot move a value of type [uint]\n+}"}, {"sha": "0cfee6daf3f1921499dacc78001725a3e8e9abb8", "filename": "src/test/compile-fail/issue-17718-const-naming.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -12,5 +12,6 @@\n \n const foo: int = 3;\n //~^ ERROR: should have an uppercase name such as\n+//~^^ ERROR: constant item is never used\n \n fn main() {}"}, {"sha": "96d40c52657fe2f20aaeaa379c01c50c8c1dc86e", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -35,6 +35,13 @@ pub static used_static2: int = used_static;\n const USED_STATIC: int = 0;\n const STATIC_USED_IN_ENUM_DISCRIMINANT: int = 10;\n \n+pub const pub_const: int = 0;\n+const priv_const: int = 0; //~ ERROR: constant item is never used\n+const used_const: int = 0;\n+pub const used_const2: int = used_const;\n+const USED_CONST: int = 1;\n+const CONST_USED_IN_ENUM_DISCRIMINANT: int = 11;\n+\n pub type typ = *const UsedStruct4;\n pub struct PubStruct;\n struct PrivStruct; //~ ERROR: struct is never used\n@@ -61,7 +68,10 @@ pub struct PubStruct2 {\n \n pub enum pub_enum { foo1, bar1 }\n pub enum pub_enum2 { a(*const StructUsedInEnum) }\n-pub enum pub_enum3 { Foo = STATIC_USED_IN_ENUM_DISCRIMINANT }\n+pub enum pub_enum3 {\n+    Foo = STATIC_USED_IN_ENUM_DISCRIMINANT,\n+    Bar = CONST_USED_IN_ENUM_DISCRIMINANT,\n+}\n \n enum priv_enum { foo2, bar2 } //~ ERROR: enum is never used\n enum used_enum {\n@@ -82,6 +92,7 @@ pub fn pub_fn() {\n     let i = 1i;\n     match i {\n         USED_STATIC => (),\n+        USED_CONST => (),\n         _ => ()\n     }\n     f::<StructUsedInGeneric>();"}, {"sha": "982d4f6a0b56d242f7107c7374e4ff1ae3cb2260", "filename": "src/test/run-pass/lang-item-public.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flang-item-public.rs?ref=a1e2eb0395941f5ca79cd59c8ab0a9f3133a2df0", "patch": "@@ -28,6 +28,10 @@ extern {}\n #[link(name = \"execinfo\")]\n extern {}\n \n+#[cfg(target_os = \"freebsd\")]\n+#[link(name = \"c\")]\n+extern {}\n+\n #[cfg(target_os = \"dragonfly\")]\n #[link(name = \"c\")]\n extern {}"}]}