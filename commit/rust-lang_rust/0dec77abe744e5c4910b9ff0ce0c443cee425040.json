{"sha": "0dec77abe744e5c4910b9ff0ce0c443cee425040", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZWM3N2FiZTc0NGU1YzQ5MTBiOWZmMGNlMGM0NDNjZWU0MjUwNDA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-23T10:51:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-23T10:51:56Z"}, "message": "Merge #7018\n\n7018: Cleanup handle_code_action r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "879ee0d311aa48bfbc948d4ad182456d259671bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/879ee0d311aa48bfbc948d4ad182456d259671bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dec77abe744e5c4910b9ff0ce0c443cee425040", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf4yFMCRBK7hj4Ov3rIwAAdHIIAFFQPgQPoUQvQKaP2XO42jqY\nolrENdAFQRoYpkvYCyAgHErMrODJBgwEZIVrTPAyTxyces+OSenEn4t1US7dXihi\ne4KmZJ/+hwtYrrf90V6CqMjSEM1dTLKPPNwjZhLbzRoSvvbTLZkbsI7nASu5wqOB\nX5yAdqNLZxV3zIMPCaHZQi+Ov3TUUq8sCC6KcfWx+fk8oIkhIO8Zz682HblpNaqX\nLHxcD/8LgjSAF6iq5sxzz4fmMug7S+2pctF4MeRnAiadUyl8wV/Xuolks69DtVzJ\nOufCt+bK+TV4kecoQFctdGu/VYS3Jto/zN9G36Ub5sjEP0El9uttIsi2kwXC7eI=\n=4NeM\n-----END PGP SIGNATURE-----\n", "payload": "tree 879ee0d311aa48bfbc948d4ad182456d259671bf\nparent fd1fcf2c2e90ab04103a6aa9d033ec64dcc8d555\nparent 2ec92b3dc3e3c51641e288fcba7ba13e7372cdd6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1608720716 +0000\ncommitter GitHub <noreply@github.com> 1608720716 +0000\n\nMerge #7018\n\n7018: Cleanup handle_code_action r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dec77abe744e5c4910b9ff0ce0c443cee425040", "html_url": "https://github.com/rust-lang/rust/commit/0dec77abe744e5c4910b9ff0ce0c443cee425040", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dec77abe744e5c4910b9ff0ce0c443cee425040/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd1fcf2c2e90ab04103a6aa9d033ec64dcc8d555", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd1fcf2c2e90ab04103a6aa9d033ec64dcc8d555", "html_url": "https://github.com/rust-lang/rust/commit/fd1fcf2c2e90ab04103a6aa9d033ec64dcc8d555"}, {"sha": "2ec92b3dc3e3c51641e288fcba7ba13e7372cdd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ec92b3dc3e3c51641e288fcba7ba13e7372cdd6", "html_url": "https://github.com/rust-lang/rust/commit/2ec92b3dc3e3c51641e288fcba7ba13e7372cdd6"}], "stats": {"total": 119, "additions": 58, "deletions": 61}, "files": [{"sha": "55bc2bceca1460608b3580d3ef3062e3060692fe", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 58, "deletions": 61, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/0dec77abe744e5c4910b9ff0ce0c443cee425040/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dec77abe744e5c4910b9ff0ce0c443cee425040/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=0dec77abe744e5c4910b9ff0ce0c443cee425040", "patch": "@@ -5,11 +5,13 @@\n use std::{\n     io::Write as _,\n     process::{self, Stdio},\n+    sync::Arc,\n };\n \n use ide::{\n-    CompletionResolveCapability, FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData,\n-    NavigationTarget, Query, RangeInfo, Runnable, RunnableKind, SearchScope, SymbolKind, TextEdit,\n+    AssistConfig, CompletionResolveCapability, FileId, FilePosition, FileRange, HoverAction,\n+    HoverGotoTypeData, LineIndex, NavigationTarget, Query, RangeInfo, Runnable, RunnableKind,\n+    SearchScope, SymbolKind, TextEdit,\n };\n use itertools::Itertools;\n use lsp_server::ErrorCode;\n@@ -865,58 +867,8 @@ pub(crate) fn handle_formatting(\n     }\n }\n \n-fn handle_fixes(\n-    snap: &GlobalStateSnapshot,\n-    params: &lsp_types::CodeActionParams,\n-    res: &mut Vec<lsp_ext::CodeAction>,\n-) -> Result<()> {\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n-    let range = from_proto::text_range(&line_index, params.range);\n-\n-    match &params.context.only {\n-        Some(v) => {\n-            if !v.iter().any(|it| {\n-                it == &lsp_types::CodeActionKind::EMPTY\n-                    || it == &lsp_types::CodeActionKind::QUICKFIX\n-            }) {\n-                return Ok(());\n-            }\n-        }\n-        None => {}\n-    };\n-\n-    let diagnostics = snap.analysis.diagnostics(&snap.config.diagnostics, file_id)?;\n-\n-    for fix in diagnostics\n-        .into_iter()\n-        .filter_map(|d| d.fix)\n-        .filter(|fix| fix.fix_trigger_range.intersect(range).is_some())\n-    {\n-        let edit = to_proto::snippet_workspace_edit(&snap, fix.source_change)?;\n-        let action = lsp_ext::CodeAction {\n-            title: fix.label.to_string(),\n-            group: None,\n-            kind: Some(CodeActionKind::QUICKFIX),\n-            edit: Some(edit),\n-            is_preferred: Some(false),\n-            data: None,\n-        };\n-        res.push(action);\n-    }\n-\n-    for fix in snap.check_fixes.get(&file_id).into_iter().flatten() {\n-        let fix_range = from_proto::text_range(&line_index, fix.range);\n-        if fix_range.intersect(range).is_none() {\n-            continue;\n-        }\n-        res.push(fix.action.clone());\n-    }\n-    Ok(())\n-}\n-\n pub(crate) fn handle_code_action(\n-    mut snap: GlobalStateSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CodeActionParams,\n ) -> Result<Option<Vec<lsp_ext::CodeAction>>> {\n     let _p = profile::span(\"handle_code_action\");\n@@ -932,31 +884,76 @@ pub(crate) fn handle_code_action(\n     let range = from_proto::text_range(&line_index, params.range);\n     let frange = FileRange { file_id, range };\n \n-    snap.config.assist.allowed = params\n-        .clone()\n-        .context\n-        .only\n-        .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());\n+    let assists_config = AssistConfig {\n+        allowed: params\n+            .clone()\n+            .context\n+            .only\n+            .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect()),\n+        ..snap.config.assist\n+    };\n \n     let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n \n-    handle_fixes(&snap, &params, &mut res)?;\n+    let include_quick_fixes = match &params.context.only {\n+        Some(v) => v.iter().any(|it| {\n+            it == &lsp_types::CodeActionKind::EMPTY || it == &lsp_types::CodeActionKind::QUICKFIX\n+        }),\n+        None => true,\n+    };\n+    if include_quick_fixes {\n+        add_quick_fixes(&snap, frange, &line_index, &mut res)?;\n+    }\n \n     if snap.config.client_caps.code_action_resolve {\n         for (index, assist) in\n-            snap.analysis.unresolved_assists(&snap.config.assist, frange)?.into_iter().enumerate()\n+            snap.analysis.unresolved_assists(&assists_config, frange)?.into_iter().enumerate()\n         {\n             res.push(to_proto::unresolved_code_action(&snap, params.clone(), assist, index)?);\n         }\n     } else {\n-        for assist in snap.analysis.resolved_assists(&snap.config.assist, frange)?.into_iter() {\n+        for assist in snap.analysis.resolved_assists(&assists_config, frange)?.into_iter() {\n             res.push(to_proto::resolved_code_action(&snap, assist)?);\n         }\n     }\n \n     Ok(Some(res))\n }\n \n+fn add_quick_fixes(\n+    snap: &GlobalStateSnapshot,\n+    frange: FileRange,\n+    line_index: &Arc<LineIndex>,\n+    acc: &mut Vec<lsp_ext::CodeAction>,\n+) -> Result<()> {\n+    let diagnostics = snap.analysis.diagnostics(&snap.config.diagnostics, frange.file_id)?;\n+\n+    for fix in diagnostics\n+        .into_iter()\n+        .filter_map(|d| d.fix)\n+        .filter(|fix| fix.fix_trigger_range.intersect(frange.range).is_some())\n+    {\n+        let edit = to_proto::snippet_workspace_edit(&snap, fix.source_change)?;\n+        let action = lsp_ext::CodeAction {\n+            title: fix.label.to_string(),\n+            group: None,\n+            kind: Some(CodeActionKind::QUICKFIX),\n+            edit: Some(edit),\n+            is_preferred: Some(false),\n+            data: None,\n+        };\n+        acc.push(action);\n+    }\n+\n+    for fix in snap.check_fixes.get(&frange.file_id).into_iter().flatten() {\n+        let fix_range = from_proto::text_range(&line_index, fix.range);\n+        if fix_range.intersect(frange.range).is_some() {\n+            acc.push(fix.action.clone());\n+        }\n+    }\n+    Ok(())\n+}\n+\n pub(crate) fn handle_code_action_resolve(\n     mut snap: GlobalStateSnapshot,\n     mut code_action: lsp_ext::CodeAction,"}]}