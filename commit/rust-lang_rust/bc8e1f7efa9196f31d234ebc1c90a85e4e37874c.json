{"sha": "bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjOGUxZjdlZmE5MTk2ZjMxZDIzNGViYzFjOTBhODVlNGUzNzg3NGM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-10T20:53:57Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:29Z"}, "message": "rustc: use an offset instead of a field path in Layout::StructWrappedNullablePointer.", "tree": {"sha": "e5a72b472a4be342e83222c9db7157ec44244238", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5a72b472a4be342e83222c9db7157ec44244238"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "html_url": "https://github.com/rust-lang/rust/commit/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50a3fd0097f0dcd3661387ebb4dee8062b8caab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/50a3fd0097f0dcd3661387ebb4dee8062b8caab4", "html_url": "https://github.com/rust-lang/rust/commit/50a3fd0097f0dcd3661387ebb4dee8062b8caab4"}], "stats": {"total": 250, "additions": 137, "deletions": 113}, "files": [{"sha": "c16092666f7b17ce026f3abb42961d0b133d0fbf", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 79, "deletions": 78, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "patch": "@@ -841,35 +841,47 @@ impl<'a, 'tcx> Struct {\n         })\n     }\n \n-    /// Find the path leading to a non-zero leaf field, starting from\n+    /// Find the offset of a non-zero leaf field, starting from\n     /// the given type and recursing through aggregates.\n-    /// The tuple is `(path, source_path)`,\n-    /// where `path` is in memory order and `source_path` in source order.\n+    /// The tuple is `(offset, primitive, source_path)`.\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n     fn non_zero_field_in_type(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               param_env: ty::ParamEnv<'tcx>,\n                               ty: Ty<'tcx>)\n-                              -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'tcx>> {\n-        match (ty.layout(tcx, param_env)?, &ty.sty) {\n-            (&Scalar { non_zero: true, .. }, _) |\n-            (&CEnum { non_zero: true, .. }, _) => Ok(Some((vec![], vec![]))),\n+                              -> Result<Option<(Size, Primitive, FieldPath)>, LayoutError<'tcx>> {\n+        let layout = ty.layout(tcx, param_env)?;\n+        match (layout, &ty.sty) {\n+            (&Scalar { non_zero: true, value, .. }, _) => {\n+                Ok(Some((Size::from_bytes(0), value, vec![])))\n+            }\n+            (&CEnum { non_zero: true, discr, .. }, _) => {\n+                Ok(Some((Size::from_bytes(0), Int(discr), vec![])))\n+            }\n+\n             (&FatPointer { non_zero: true, .. }, _) => {\n-                Ok(Some((vec![FAT_PTR_ADDR as u32], vec![FAT_PTR_ADDR as u32])))\n+                Ok(Some((layout.field_offset(tcx, FAT_PTR_ADDR, None),\n+                         Pointer,\n+                         vec![FAT_PTR_ADDR as u32])))\n             }\n \n             // Is this the NonZero lang item wrapping a pointer or integer type?\n             (&Univariant { non_zero: true, .. }, &ty::TyAdt(def, substs)) => {\n                 let fields = &def.struct_variant().fields;\n                 assert_eq!(fields.len(), 1);\n-                match *fields[0].ty(tcx, substs).layout(tcx, param_env)? {\n+                let field = fields[0].ty(tcx, substs).layout(tcx, param_env)?;\n+                match *field {\n                     // FIXME(eddyb) also allow floating-point types here.\n-                    Scalar { value: Int(_), non_zero: false } |\n-                    Scalar { value: Pointer, non_zero: false } => {\n-                        Ok(Some((vec![0], vec![0])))\n+                    Scalar { value: value @ Int(_), non_zero: false } |\n+                    Scalar { value: value @ Pointer, non_zero: false } => {\n+                        Ok(Some((layout.field_offset(tcx, 0, None),\n+                                 value,\n+                                 vec![0])))\n                     }\n                     FatPointer { non_zero: false, .. } => {\n-                        let tmp = vec![FAT_PTR_ADDR as u32, 0];\n-                        Ok(Some((tmp.clone(), tmp)))\n+                        Ok(Some((layout.field_offset(tcx, 0, None) +\n+                                 field.field_offset(tcx, FAT_PTR_ADDR, None),\n+                                 Pointer,\n+                                 vec![FAT_PTR_ADDR as u32, 0])))\n                     }\n                     _ => Ok(None)\n                 }\n@@ -878,31 +890,31 @@ impl<'a, 'tcx> Struct {\n             // Perhaps one of the fields of this struct is non-zero\n             // let's recurse and find out\n             (&Univariant { ref variant, .. }, &ty::TyAdt(def, substs)) if def.is_struct() => {\n-                Struct::non_zero_field_paths(\n+                Struct::non_zero_field(\n                     tcx,\n                     param_env,\n                     def.struct_variant().fields.iter().map(|field| {\n                         field.ty(tcx, substs)\n                     }),\n-                    Some(&variant.memory_index[..]))\n+                    &variant.offsets)\n             }\n \n             // Perhaps one of the upvars of this closure is non-zero\n             (&Univariant { ref variant, .. }, &ty::TyClosure(def, substs)) => {\n                 let upvar_tys = substs.upvar_tys(def, tcx);\n-                Struct::non_zero_field_paths(\n+                Struct::non_zero_field(\n                     tcx,\n                     param_env,\n                     upvar_tys,\n-                    Some(&variant.memory_index[..]))\n+                    &variant.offsets)\n             }\n             // Can we use one of the fields in this tuple?\n             (&Univariant { ref variant, .. }, &ty::TyTuple(tys, _)) => {\n-                Struct::non_zero_field_paths(\n+                Struct::non_zero_field(\n                     tcx,\n                     param_env,\n                     tys.iter().cloned(),\n-                    Some(&variant.memory_index[..]))\n+                    &variant.offsets)\n             }\n \n             // Is this a fixed-size array of something non-zero\n@@ -915,11 +927,11 @@ impl<'a, 'tcx> Struct {\n                     }\n                 }\n                 if count.val.to_const_int().unwrap().to_u64().unwrap() != 0 {\n-                    Struct::non_zero_field_paths(\n+                    Struct::non_zero_field(\n                         tcx,\n                         param_env,\n                         Some(ety).into_iter(),\n-                        None)\n+                        &[Size::from_bytes(0)])\n                 } else {\n                     Ok(None)\n                 }\n@@ -938,27 +950,20 @@ impl<'a, 'tcx> Struct {\n         }\n     }\n \n-    /// Find the path leading to a non-zero leaf field, starting from\n+    /// Find the offset of a non-zero leaf field, starting from\n     /// the given set of fields and recursing through aggregates.\n-    /// Returns Some((path, source_path)) on success.\n-    /// `path` is translated to memory order. `source_path` is not.\n-    fn non_zero_field_paths<I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               param_env: ty::ParamEnv<'tcx>,\n-                               fields: I,\n-                               permutation: Option<&[u32]>)\n-                               -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'tcx>>\n+    /// Returns Some((offset, primitive, source_path)) on success.\n+    fn non_zero_field<I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         param_env: ty::ParamEnv<'tcx>,\n+                         fields: I,\n+                         offsets: &[Size])\n+                         -> Result<Option<(Size, Primitive, FieldPath)>, LayoutError<'tcx>>\n     where I: Iterator<Item=Ty<'tcx>> {\n         for (i, ty) in fields.enumerate() {\n             let r = Struct::non_zero_field_in_type(tcx, param_env, ty)?;\n-            if let Some((mut path, mut source_path)) = r {\n+            if let Some((offset, primitive, mut source_path)) = r {\n                 source_path.push(i as u32);\n-                let index = if let Some(p) = permutation {\n-                    p[i] as usize\n-                } else {\n-                    i\n-                };\n-                path.push(index as u32);\n-                return Ok(Some((path, source_path)));\n+                return Ok(Some((offsets[i] + offset, primitive, source_path)));\n             }\n         }\n         Ok(None)\n@@ -1135,18 +1140,19 @@ pub enum Layout {\n     /// identity function.\n     RawNullablePointer {\n         nndiscr: u64,\n-        value: Primitive\n+        discr: Primitive\n     },\n \n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n-    /// `nndiscr` is represented by the struct `nonnull`, where the `discrfield`th\n-    /// field is known to be nonnull due to its type; if that field is null, then\n+    /// `nndiscr` is represented by the struct `nonnull`, where the field at the\n+    /// `discr_offset` offset is known to be nonnull due to its type; if that field is null, then\n     /// it represents the other case, which is known to be zero sized.\n     StructWrappedNullablePointer {\n         nndiscr: u64,\n         nonnull: Struct,\n-        discrfield: FieldPath,\n-        /// Like discrfield, but in source order. For debuginfo.\n+        discr: Primitive,\n+        discr_offset: Size,\n+        /// Like discr_offset, but the source field path. For debuginfo.\n         discrfield_source: FieldPath\n     }\n }\n@@ -1440,44 +1446,36 @@ impl<'a, 'tcx> Layout {\n                         if !Struct::would_be_zero_sized(dl, other_fields)? {\n                             continue;\n                         }\n-                        let paths = Struct::non_zero_field_paths(tcx,\n-                                                                 param_env,\n-                                                                 variants[discr].iter().cloned(),\n-                                                                 None)?;\n-                        let (mut path, mut path_source) = if let Some(p) = paths { p }\n+\n+                        let st = Struct::new(dl,\n+                            &variants[discr].iter().map(|ty| ty.layout(tcx, param_env))\n+                              .collect::<Result<Vec<_>, _>>()?,\n+                            &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n+\n+                        let field = Struct::non_zero_field(tcx,\n+                                                           param_env,\n+                                                           variants[discr].iter().cloned(),\n+                                                           &st.offsets)?;\n+                        let (offset, primitive, mut path_source) = if let Some(f) = field { f }\n                           else { continue };\n \n                         // FIXME(eddyb) should take advantage of a newtype.\n-                        if path == &[0] && variants[discr].len() == 1 {\n-                            let value = match *variants[discr][0].layout(tcx, param_env)? {\n-                                Scalar { value, .. } => value,\n-                                CEnum { discr, .. } => Int(discr),\n-                                _ => bug!(\"Layout::compute: `{}`'s non-zero \\\n-                                           `{}` field not scalar?!\",\n-                                           ty, variants[discr][0])\n-                            };\n+                        if offset.bytes() == 0 && primitive.size(dl) == st.stride() &&\n+                           variants[discr].len() == 1 {\n                             return success(RawNullablePointer {\n                                 nndiscr: discr as u64,\n-                                value,\n+                                discr: primitive,\n                             });\n                         }\n \n-                        let st = Struct::new(dl,\n-                            &variants[discr].iter().map(|ty| ty.layout(tcx, param_env))\n-                              .collect::<Result<Vec<_>, _>>()?,\n-                            &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n-\n-                        // We have to fix the last element of path here.\n-                        let mut i = *path.last().unwrap();\n-                        i = st.memory_index[i as usize];\n-                        *path.last_mut().unwrap() = i;\n-                        path.reverse();\n+                        // We have to fix the source path here.\n                         path_source.reverse();\n \n                         return success(StructWrappedNullablePointer {\n                             nndiscr: discr as u64,\n                             nonnull: st,\n-                            discrfield: path,\n+                            discr: primitive,\n+                            discr_offset: offset,\n                             discrfield_source: path_source\n                         });\n                     }\n@@ -1621,7 +1619,7 @@ impl<'a, 'tcx> Layout {\n         let dl = cx.data_layout();\n \n         match *self {\n-            Scalar { value, .. } | RawNullablePointer { value, .. } => {\n+            Scalar { value, .. } | RawNullablePointer { discr: value, .. } => {\n                 value.size(dl)\n             }\n \n@@ -1664,7 +1662,7 @@ impl<'a, 'tcx> Layout {\n         let dl = cx.data_layout();\n \n         match *self {\n-            Scalar { value, .. } | RawNullablePointer { value, .. } => {\n+            Scalar { value, .. } | RawNullablePointer { discr: value, .. } => {\n                 value.align(dl)\n             }\n \n@@ -1876,7 +1874,8 @@ impl<'a, 'tcx> Layout {\n         match *layout {\n             Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n                                                    nndiscr,\n-                                                   discrfield: _,\n+                                                   discr: _,\n+                                                   discr_offset: _,\n                                                    discrfield_source: _ } => {\n                 debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n                        ty, nndiscr, variant_layout);\n@@ -1891,12 +1890,12 @@ impl<'a, 'tcx> Layout {\n                                                &fields,\n                                                variant_layout)]);\n             }\n-            Layout::RawNullablePointer { nndiscr, value } => {\n+            Layout::RawNullablePointer { nndiscr, discr } => {\n                 debug!(\"print-type-size t: `{:?}` adt raw nullable nndiscr {} is {:?}\",\n-                       ty, nndiscr, value);\n+                       ty, nndiscr, discr);\n                 let variant_def = &adt_def.variants[nndiscr as usize];\n                 record(adt_kind.into(), None,\n-                       vec![build_primitive_info(variant_def.name, &value)]);\n+                       vec![build_primitive_info(variant_def.name, &discr)]);\n             }\n             Layout::Univariant { variant: ref variant_layout, non_zero: _ } => {\n                 let variant_names = || {\n@@ -2410,19 +2409,21 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout\n                 align.hash_stable(hcx, hasher);\n                 primitive_align.hash_stable(hcx, hasher);\n             }\n-            RawNullablePointer { nndiscr, ref value } => {\n+            RawNullablePointer { nndiscr, ref discr } => {\n                 nndiscr.hash_stable(hcx, hasher);\n-                value.hash_stable(hcx, hasher);\n+                discr.hash_stable(hcx, hasher);\n             }\n             StructWrappedNullablePointer {\n                 nndiscr,\n                 ref nonnull,\n-                ref discrfield,\n+                ref discr,\n+                discr_offset,\n                 ref discrfield_source\n             } => {\n                 nndiscr.hash_stable(hcx, hasher);\n                 nonnull.hash_stable(hcx, hasher);\n-                discrfield.hash_stable(hcx, hasher);\n+                discr.hash_stable(hcx, hasher);\n+                discr_offset.hash_stable(hcx, hasher);\n                 discrfield_source.hash_stable(hcx, hasher);\n             }\n         }"}, {"sha": "329da2c36a2ad332b4a3ceb07d0d341d25a41db7", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "patch": "@@ -295,7 +295,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n         match *self.layout {\n             // The primitives for this algorithm.\n             Layout::Scalar { value, .. } |\n-            Layout::RawNullablePointer { value, .. } => {\n+            Layout::RawNullablePointer { discr: value, .. } => {\n                 let kind = match value {\n                     layout::Int(_) |\n                     layout::Pointer => RegKind::Integer,"}, {"sha": "dcbb2de9c4dedc708438416f3e23412a205533e0", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "patch": "@@ -66,7 +66,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n \n         match *layout {\n             Layout::Scalar { value, .. } |\n-            Layout::RawNullablePointer { value, .. } => {\n+            Layout::RawNullablePointer { discr: value, .. } => {\n                 let reg = match value {\n                     layout::Int(_) |\n                     layout::Pointer => Class::Int,"}, {"sha": "7dcb5d219b794221565cd0f03164468670464329", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 46, "deletions": 32, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, Layout, LayoutTyper};\n+use rustc::ty::layout::{self, Align, Layout, LayoutTyper, Size};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -25,7 +25,6 @@ use type_::Type;\n use value::Value;\n use glue;\n \n-use std::iter;\n use std::ptr;\n use std::ops;\n \n@@ -330,14 +329,26 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         }\n     }\n \n-    // Double index to account for padding (FieldPath already uses `Struct::memory_index`)\n-    fn gepi_struct_llfields_path(self, bcx: &Builder, discrfield: &layout::FieldPath) -> ValueRef {\n-        let path = iter::once(C_u32(bcx.ccx, 0)).chain(discrfield.iter().map(|&i| {\n-            let i = adt::memory_index_to_gep(i as u64);\n-            assert_eq!(i as u32 as u64, i);\n-            C_u32(bcx.ccx, i as u32)\n-        })).collect::<Vec<_>>();\n-        bcx.inbounds_gep(self.llval, &path)\n+    // Return a pointer to the discriminant, given its type and offset.\n+    fn gepi_discr_at_offset(self, bcx: &Builder,\n+                            discr: ty::layout::Primitive,\n+                            offset: Size)\n+                            -> (ValueRef, Alignment) {\n+        let size = discr.size(bcx.ccx);\n+        let ptr_ty = Type::from_primitive(bcx.ccx, discr).ptr_to();\n+\n+        // If the discriminant is not on a multiple of the primitive's size,\n+        // we need to go through i8*. Also assume the worst alignment.\n+        if offset.bytes() % size.bytes() != 0 {\n+            let byte_ptr = bcx.pointercast(self.llval, Type::i8p(bcx.ccx));\n+            let byte_ptr = bcx.inbounds_gep(byte_ptr, &[C_usize(bcx.ccx, offset.bytes())]);\n+            let byte_align = Alignment::Packed(Align::from_bytes(1, 1).unwrap());\n+            return (bcx.pointercast(byte_ptr, ptr_ty), byte_align);\n+        }\n+\n+        let discr_ptr = bcx.pointercast(self.llval, ptr_ty);\n+        (bcx.inbounds_gep(discr_ptr, &[C_usize(bcx.ccx, offset.bytes() / size.bytes())]),\n+         self.alignment)\n     }\n \n     /// Helper for cases where the discriminant is simply loaded.\n@@ -378,16 +389,16 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 self.load_discr(bcx, discr, ptr.llval, 0, variants.len() as u64 - 1)\n             }\n             layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n-            layout::RawNullablePointer { nndiscr, .. } => {\n-                let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n-                let discr = bcx.load(self.llval, self.alignment.non_abi());\n-                bcx.icmp(cmp, discr, C_null(val_ty(discr)))\n-            }\n-            layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-                let llptrptr = self.gepi_struct_llfields_path(bcx, discrfield);\n-                let llptr = bcx.load(llptrptr, self.alignment.non_abi());\n+            layout::RawNullablePointer { nndiscr, discr } |\n+            layout::StructWrappedNullablePointer { nndiscr, discr, .. } => {\n+                let discr_offset = match *l {\n+                    layout::StructWrappedNullablePointer { discr_offset, .. } => discr_offset,\n+                    _ => Size::from_bytes(0),\n+                };\n+                let (lldiscrptr, alignment) = self.gepi_discr_at_offset(bcx, discr, discr_offset);\n+                let lldiscr = bcx.load(lldiscrptr, alignment.non_abi());\n                 let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n-                bcx.icmp(cmp, llptr, C_null(val_ty(llptr)))\n+                bcx.icmp(cmp, lldiscr, C_null(Type::from_primitive(bcx.ccx, discr)))\n             },\n             _ => bug!(\"{} is not an enum\", l.ty)\n         };\n@@ -418,27 +429,30 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             | layout::Vector { .. } => {\n                 assert_eq!(to, 0);\n             }\n-            layout::RawNullablePointer { nndiscr, .. } => {\n+            layout::RawNullablePointer { nndiscr, discr, .. } |\n+            layout::StructWrappedNullablePointer { nndiscr, discr, .. } => {\n                 if to != nndiscr {\n-                    let llptrty = val_ty(self.llval).element_type();\n-                    bcx.store(C_null(llptrty), self.llval, self.alignment.non_abi());\n-                }\n-            }\n-            layout::StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n-                if to != nndiscr {\n-                    if target_sets_discr_via_memset(bcx) {\n+                    let (use_memset, discr_offset) = match *l {\n+                        layout::StructWrappedNullablePointer { discr_offset, .. } => {\n+                            (target_sets_discr_via_memset(bcx), discr_offset)\n+                        }\n+                        _ => (false, Size::from_bytes(0)),\n+                    };\n+                    if use_memset {\n                         // Issue #34427: As workaround for LLVM bug on\n                         // ARM, use memset of 0 on whole struct rather\n                         // than storing null to single target field.\n                         let llptr = bcx.pointercast(self.llval, Type::i8(bcx.ccx).ptr_to());\n                         let fill_byte = C_u8(bcx.ccx, 0);\n-                        let size = C_usize(bcx.ccx, nonnull.stride().bytes());\n-                        let align = C_u32(bcx.ccx, nonnull.align.abi() as u32);\n+                        let (size, align) = l.size_and_align(bcx.ccx);\n+                        let size = C_usize(bcx.ccx, size.bytes());\n+                        let align = C_u32(bcx.ccx, align.abi() as u32);\n                         base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                     } else {\n-                        let llptrptr = self.gepi_struct_llfields_path(bcx, discrfield);\n-                        let llptrty = val_ty(llptrptr).element_type();\n-                        bcx.store(C_null(llptrty), llptrptr, self.alignment.non_abi());\n+                        let (lldiscrptr, alignment) =\n+                            self.gepi_discr_at_offset(bcx, discr, discr_offset);\n+                        bcx.store(C_null(Type::from_primitive(bcx.ccx, discr)),\n+                            lldiscrptr, alignment.non_abi());\n                     }\n                 }\n             }"}, {"sha": "2359aa811fa756212b146445175707f28f7e1565", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "patch": "@@ -287,4 +287,14 @@ impl Type {\n             I128 => Type::i128(cx),\n         }\n     }\n+\n+    pub fn from_primitive(cx: &CrateContext, p: layout::Primitive) -> Type {\n+        use rustc::ty::layout::Primitive::*;\n+        match p {\n+            Int(i) => Type::from_integer(cx, i),\n+            F32 => Type::f32(cx),\n+            F64 => Type::f64(cx),\n+            Pointer => Type::i8p(cx),\n+        }\n+    }\n }"}, {"sha": "c9cdde78a4d1bb75758d78648d9a88fe034613e7", "filename": "src/test/ui/print_type_sizes/nullable.stdout", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout?ref=bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "patch": "@@ -19,6 +19,5 @@ print-type-size     field `.pre`: 1 bytes\n print-type-size     end padding: 1 bytes\n print-type-size type: `MyOption<core::nonzero::NonZero<u32>>`: 4 bytes, alignment: 4 bytes\n print-type-size     variant `Some`: 4 bytes\n-print-type-size         field `.0`: 4 bytes\n print-type-size type: `core::nonzero::NonZero<u32>`: 4 bytes, alignment: 4 bytes\n print-type-size     field `.0`: 4 bytes"}]}