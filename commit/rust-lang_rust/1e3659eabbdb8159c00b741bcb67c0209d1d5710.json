{"sha": "1e3659eabbdb8159c00b741bcb67c0209d1d5710", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMzY1OWVhYmJkYjgxNTljMDBiNzQxYmNiNjdjMDIwOWQxZDU3MTA=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-24T00:07:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-24T00:07:02Z"}, "message": "Merge pull request #59 from oli-obk/master\n\nenable A<Struct> -> A<Trait> downcasting where `A<Trait>` is a fat pointer", "tree": {"sha": "16cba87ed2759ace487694afa41b4bdc8bc81475", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16cba87ed2759ace487694afa41b4bdc8bc81475"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e3659eabbdb8159c00b741bcb67c0209d1d5710", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e3659eabbdb8159c00b741bcb67c0209d1d5710", "html_url": "https://github.com/rust-lang/rust/commit/1e3659eabbdb8159c00b741bcb67c0209d1d5710", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e3659eabbdb8159c00b741bcb67c0209d1d5710/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b012edc7ab8690610b0502be24f3eb8ed30486b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b012edc7ab8690610b0502be24f3eb8ed30486b", "html_url": "https://github.com/rust-lang/rust/commit/5b012edc7ab8690610b0502be24f3eb8ed30486b"}, {"sha": "38748fa6150a99aaa16902ecd081a38bcfb92630", "url": "https://api.github.com/repos/rust-lang/rust/commits/38748fa6150a99aaa16902ecd081a38bcfb92630", "html_url": "https://github.com/rust-lang/rust/commit/38748fa6150a99aaa16902ecd081a38bcfb92630"}], "stats": {"total": 719, "additions": 634, "deletions": 85}, "files": [{"sha": "fde3db15968cf4da951261349dce41628e427dc9", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -10,6 +10,7 @@ use syntax::codemap::Span;\n pub enum EvalError<'tcx> {\n     FunctionPointerTyMismatch(&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>),\n     DanglingPointerDeref,\n+    InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n     InvalidDiscriminant,\n@@ -19,7 +20,6 @@ pub enum EvalError<'tcx> {\n         allocation_size: usize,\n     },\n     ReadPointerAsBytes,\n-    ReadBytesAsPointer,\n     InvalidPointerMath,\n     ReadUndefBytes,\n     InvalidBoolOp(mir::BinOp),\n@@ -53,6 +53,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n         match *self {\n             EvalError::FunctionPointerTyMismatch(..) =>\n                 \"tried to call a function through a function pointer of a different type\",\n+            EvalError::InvalidMemoryAccess =>\n+                \"tried to access memory through an invalid pointer\",\n             EvalError::DanglingPointerDeref =>\n                 \"dangling pointer was dereferenced\",\n             EvalError::InvalidFunctionPointer =>\n@@ -65,8 +67,6 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"pointer offset outside bounds of allocation\",\n             EvalError::ReadPointerAsBytes =>\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n-            EvalError::ReadBytesAsPointer =>\n-                \"attempted to interpret some raw bytes as a pointer address\",\n             EvalError::InvalidPointerMath =>\n                 \"attempted to do math or a comparison on pointers into different allocations\",\n             EvalError::ReadUndefBytes =>"}, {"sha": "6227999569cf462d29064ce74626cb543ca0f5b3", "filename": "src/interpreter/cast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -25,8 +25,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             U16(u) => self.cast_const_int(u as u64, ty, false),\n             U32(u) => self.cast_const_int(u as u64, ty, false),\n             Char(c) => self.cast_const_int(c as u64, ty, false),\n-            U64(u) |\n-            IntegerPtr(u) => self.cast_const_int(u, ty, false),\n+            U64(u) => self.cast_const_int(u, ty, false),\n             FnPtr(ptr) |\n             Ptr(ptr) => self.cast_ptr(ptr, ty),\n         }\n@@ -74,7 +73,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyFloat(ast::FloatTy::F64) => Ok(F64(v as f64)),\n             ty::TyFloat(ast::FloatTy::F32) if negative => Ok(F32(v as i64 as f32)),\n             ty::TyFloat(ast::FloatTy::F32) => Ok(F32(v as f32)),\n-            ty::TyRawPtr(_) => Ok(IntegerPtr(v)),\n+            ty::TyRawPtr(_) => Ok(Ptr(Pointer::from_int(v as usize))),\n             ty::TyChar if v as u8 as u64 == v => Ok(Char(v as u8 as char)),\n             ty::TyChar => Err(EvalError::InvalidChar(v)),\n             _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),"}, {"sha": "9de72dc6225b410b43077f5228d0dcbd1227da7a", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -621,12 +621,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let src = self.eval_operand_to_ptr(operand)?;\n                         let src_ty = self.operand_ty(operand);\n                         let dest_ty = self.monomorphize(dest_ty, self.substs());\n+                        // FIXME: cases where dest_ty is not a fat pointer. e.g. Arc<Struct> -> Arc<Trait>\n                         assert!(self.type_is_fat_ptr(dest_ty));\n                         let (ptr, extra) = self.get_fat_ptr(dest);\n                         self.move_(src, ptr, src_ty)?;\n                         let src_pointee_ty = pointee_type(src_ty).unwrap();\n                         let dest_pointee_ty = pointee_type(dest_ty).unwrap();\n \n+                        // A<Struct> -> A<Trait> conversion\n+                        let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(src_pointee_ty, dest_pointee_ty);\n+\n                         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n                             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                                 self.memory.write_usize(extra, length as u64)?;\n@@ -858,7 +862,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n-                    Field(field, _) => {\n+                    Field(field, field_ty) => {\n                         use rustc::ty::layout::Layout::*;\n                         let variant = match *base_layout {\n                             Univariant { ref variant, .. } => variant,\n@@ -878,7 +882,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         };\n \n                         let offset = variant.field_offset(field.index()).bytes();\n-                        base.ptr.offset(offset as isize)\n+                        let ptr = base.ptr.offset(offset as isize);\n+                        match (&field_ty.sty, base.extra) {\n+                            (&ty::TyStr, extra @ LvalueExtra::Length(_)) |\n+                            (&ty::TySlice(_), extra @ LvalueExtra::Length(_)) |\n+                            (&ty::TyTrait(_), extra @ LvalueExtra::Vtable(_)) => return Ok(Lvalue {\n+                                ptr: ptr,\n+                                extra: extra,\n+                            }),\n+                            (&ty::TyTrait(_), _) => bug!(\"trait field without vtable\"),\n+                            _ => ptr,\n+                        }\n                     },\n \n                     Downcast(_, variant) => {\n@@ -899,6 +913,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Deref => {\n                         let pointee_ty = pointee_type(base_ty).expect(\"Deref of non-pointer\");\n+                        let pointee_ty = self.tcx.struct_tail(pointee_ty);\n                         let ptr = self.memory.read_ptr(base.ptr)?;\n                         let extra = match pointee_ty.sty {\n                             ty::TySlice(_) | ty::TyStr => {\n@@ -1049,13 +1064,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             &ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n             &ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n                 if self.type_is_sized(ty) {\n-                    match self.memory.read_ptr(ptr) {\n-                        Ok(p) => PrimVal::Ptr(p),\n-                        Err(EvalError::ReadBytesAsPointer) => {\n-                            PrimVal::IntegerPtr(self.memory.read_usize(ptr)?)\n-                        }\n-                        Err(e) => return Err(e),\n-                    }\n+                    PrimVal::Ptr(self.memory.read_ptr(ptr)?)\n                 } else {\n                     bug!(\"primitive read of fat pointer type: {:?}\", ty);\n                 }"}, {"sha": "38b62254130f6920a584d5d7f6db7686ad3ff172", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 115, "deletions": 28, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -132,18 +132,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr_arg = args_ptrs[0];\n                 let offset = self.memory.read_isize(args_ptrs[1])?;\n \n-                match self.memory.read_ptr(ptr_arg) {\n-                    Ok(ptr) => {\n-                        let result_ptr = ptr.offset(offset as isize * pointee_size);\n-                        self.memory.write_ptr(dest, result_ptr)?;\n-                    }\n-                    Err(EvalError::ReadBytesAsPointer) => {\n-                        let addr = self.memory.read_isize(ptr_arg)?;\n-                        let result_addr = addr + offset * pointee_size as i64;\n-                        self.memory.write_isize(dest, result_addr)?;\n-                    }\n-                    Err(e) => return Err(e),\n-                }\n+                let ptr = self.memory.read_ptr(ptr_arg)?;\n+                let result_ptr = ptr.offset(offset as isize * pointee_size);\n+                self.memory.write_ptr(dest, result_ptr)?;\n             }\n \n             \"overflowing_sub\" => {\n@@ -188,22 +179,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"size_of_val\" => {\n                 let ty = substs.type_at(0);\n-                if self.type_is_sized(ty) {\n-                    let size = self.type_size(ty) as u64;\n-                    self.memory.write_uint(dest, size, pointer_size)?;\n-                } else {\n-                    match ty.sty {\n-                        ty::TySlice(_) | ty::TyStr => {\n-                            let elem_ty = ty.sequence_element_type(self.tcx);\n-                            let elem_size = self.type_size(elem_ty) as u64;\n-                            let ptr_size = self.memory.pointer_size() as isize;\n-                            let n = self.memory.read_usize(args_ptrs[0].offset(ptr_size))?;\n-                            self.memory.write_uint(dest, n * elem_size, pointer_size)?;\n-                        }\n-\n-                        _ => return Err(EvalError::Unimplemented(format!(\"unimplemented: size_of_val::<{:?}>\", ty))),\n-                    }\n-                }\n+                let (size, _) = self.size_and_align_of_dst(ty, args_ptrs[0])?;\n+                self.memory.write_uint(dest, size, pointer_size)?;\n             }\n             // FIXME: wait for eval_operand_to_ptr to be gone\n             /*\n@@ -248,4 +225,114 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // current frame.\n         Ok(())\n     }\n+\n+    fn size_and_align_of_dst(\n+        &self,\n+        ty: ty::Ty<'tcx>,\n+        value: Pointer,\n+    ) -> EvalResult<'tcx, (u64, u64)> {\n+        let pointer_size = self.memory.pointer_size();\n+        if self.type_is_sized(ty) {\n+            Ok((self.type_size(ty) as u64, self.type_align(ty) as u64))\n+        } else {\n+            match ty.sty {\n+                ty::TyAdt(def, substs) => {\n+                    // First get the size of all statically known fields.\n+                    // Don't use type_of::sizing_type_of because that expects t to be sized,\n+                    // and it also rounds up to alignment, which we want to avoid,\n+                    // as the unsized field's alignment could be smaller.\n+                    assert!(!ty.is_simd());\n+                    let layout = self.type_layout(ty);\n+                    debug!(\"DST {} layout: {:?}\", ty, layout);\n+\n+                    // Returns size in bytes of all fields except the last one\n+                    // (we will be recursing on the last one).\n+                    fn local_prefix_bytes(variant: &ty::layout::Struct) -> u64 {\n+                        let fields = variant.offset_after_field.len();\n+                        if fields > 1 {\n+                            variant.offset_after_field[fields - 2].bytes()\n+                        } else {\n+                            0\n+                        }\n+                    }\n+\n+                    let (sized_size, sized_align) = match *layout {\n+                        ty::layout::Layout::Univariant { ref variant, .. } => {\n+                            (local_prefix_bytes(variant), variant.align.abi())\n+                        }\n+                        _ => {\n+                            bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n+                                 ty, layout);\n+                        }\n+                    };\n+                    debug!(\"DST {} statically sized prefix size: {} align: {}\",\n+                           ty, sized_size, sized_align);\n+\n+                    // Recurse to get the size of the dynamically sized field (must be\n+                    // the last field).\n+                    let last_field = def.struct_variant().fields.last().unwrap();\n+                    let field_ty = self.field_ty(substs, last_field);\n+                    let (unsized_size, unsized_align) = self.size_and_align_of_dst(field_ty, value)?;\n+\n+                    // FIXME (#26403, #27023): We should be adding padding\n+                    // to `sized_size` (to accommodate the `unsized_align`\n+                    // required of the unsized field that follows) before\n+                    // summing it with `sized_size`. (Note that since #26403\n+                    // is unfixed, we do not yet add the necessary padding\n+                    // here. But this is where the add would go.)\n+\n+                    // Return the sum of sizes and max of aligns.\n+                    let size = sized_size + unsized_size;\n+\n+                    // Choose max of two known alignments (combined value must\n+                    // be aligned according to more restrictive of the two).\n+                    let align = ::std::cmp::max(sized_align, unsized_align);\n+\n+                    // Issue #27023: must add any necessary padding to `size`\n+                    // (to make it a multiple of `align`) before returning it.\n+                    //\n+                    // Namely, the returned size should be, in C notation:\n+                    //\n+                    //   `size + ((size & (align-1)) ? align : 0)`\n+                    //\n+                    // emulated via the semi-standard fast bit trick:\n+                    //\n+                    //   `(size + (align-1)) & -align`\n+\n+                    if size & (align - 1) != 0 {\n+                        Ok((size + align, align))\n+                    } else {\n+                        Ok((size, align))\n+                    }\n+                }\n+                ty::TyTrait(..) => {\n+                    let (_, vtable) = self.get_fat_ptr(value);\n+                    let vtable = self.memory.read_ptr(vtable)?;\n+                    // the second entry in the vtable is the dynamic size of the object.\n+                    let size = self.memory.read_usize(vtable.offset(pointer_size as isize))?;\n+                    let align = self.memory.read_usize(vtable.offset(pointer_size as isize * 2))?;\n+                    Ok((size, align))\n+                }\n+\n+                ty::TySlice(_) | ty::TyStr => {\n+                    let elem_ty = ty.sequence_element_type(self.tcx);\n+                    let elem_size = self.type_size(elem_ty) as u64;\n+                    let (_, len_ptr) = self.get_fat_ptr(value);\n+                    let n = self.memory.read_usize(len_ptr)?;\n+                    let align = self.type_align(elem_ty);\n+                    Ok((n * elem_size, align as u64))\n+                }\n+\n+                _ => bug!(\"size_of_val::<{:?}>\", ty),\n+            }\n+        }\n+    }\n+    /// Returns the normalized type of a struct field\n+    fn field_ty(\n+        &self,\n+        param_substs: &Substs<'tcx>,\n+        f: ty::FieldDef<'tcx>,\n+    )-> ty::Ty<'tcx> {\n+        self.tcx.normalize_associated_type(&f.ty(self.tcx, param_substs))\n+    }\n }"}, {"sha": "27e6ffff00ebe409744ca1a12d1ac657cdec75e5", "filename": "src/memory.rs", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -55,6 +55,12 @@ impl Pointer {\n     pub fn points_to_zst(&self) -> bool {\n         self.alloc_id == ZST_ALLOC_ID\n     }\n+    pub fn from_int(i: usize) -> Self {\n+        Pointer {\n+            alloc_id: ZST_ALLOC_ID,\n+            offset: i,\n+        }\n+    }\n     fn zst_ptr() -> Self {\n         Pointer {\n             alloc_id: ZST_ALLOC_ID,\n@@ -105,29 +111,15 @@ const ZST_ALLOC_ID: AllocId = AllocId(0);\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn new(layout: &'a TargetDataLayout, max_memory: usize) -> Self {\n-        let mut mem = Memory {\n+        Memory {\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n             function_alloc_cache: HashMap::new(),\n             next_id: AllocId(1),\n             layout: layout,\n             memory_size: max_memory,\n             memory_usage: 0,\n-        };\n-        // alloc id 0 is reserved for ZSTs, this is an optimization to prevent ZST\n-        // (e.g. function items, (), [], ...) from requiring memory\n-        let alloc = Allocation {\n-            bytes: Vec::new(),\n-            relocations: BTreeMap::new(),\n-            undef_mask: UndefMask::new(0),\n-            align: 1,\n-            immutable: false, // must be mutable, because sometimes we \"move out\" of a ZST\n-        };\n-        mem.alloc_map.insert(ZST_ALLOC_ID, alloc);\n-        // check that additional zst allocs work\n-        debug_assert!(mem.allocate(0, 1).unwrap().points_to_zst());\n-        debug_assert!(mem.get(ZST_ALLOC_ID).is_ok());\n-        mem\n+        }\n     }\n \n     pub fn allocations(&self) -> ::std::collections::hash_map::Iter<AllocId, Allocation> {\n@@ -293,6 +285,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n+                None if id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n                 None => Err(EvalError::DanglingPointerDeref),\n             }\n         }\n@@ -304,6 +297,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n+                None if id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n                 None => Err(EvalError::DanglingPointerDeref),\n             }\n         }\n@@ -345,25 +339,30 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     /// Print an allocation and all allocations it points to, recursively.\n     pub fn dump(&self, id: AllocId) {\n+        use std::fmt::Write;\n         let mut allocs_seen = HashSet::new();\n         let mut allocs_to_print = VecDeque::new();\n         allocs_to_print.push_back(id);\n \n         while let Some(id) = allocs_to_print.pop_front() {\n             allocs_seen.insert(id);\n-            let prefix = format!(\"Alloc {:<5} \", format!(\"{}:\", id));\n-            print!(\"{}\", prefix);\n+            let mut msg = format!(\"Alloc {:<5} \", format!(\"{}:\", id));\n+            if id == ZST_ALLOC_ID {\n+                trace!(\"{} zst allocation\", msg);\n+                continue;\n+            }\n+            let prefix_len = msg.len();\n             let mut relocations = vec![];\n \n             let alloc = match (self.alloc_map.get(&id), self.functions.get(&id)) {\n                 (Some(a), None) => a,\n                 (None, Some(_)) => {\n                     // FIXME: print function name\n-                    println!(\"function pointer\");\n+                    trace!(\"{} function pointer\", msg);\n                     continue;\n                 },\n                 (None, None) => {\n-                    println!(\"(deallocated)\");\n+                    trace!(\"{} (deallocated)\", msg);\n                     continue;\n                 },\n                 (Some(_), Some(_)) => bug!(\"miri invariant broken: an allocation id exists that points to both a function and a memory location\"),\n@@ -377,25 +376,26 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                     relocations.push((i, target_id));\n                 }\n                 if alloc.undef_mask.is_range_defined(i, i + 1) {\n-                    print!(\"{:02x} \", alloc.bytes[i]);\n+                    write!(msg, \"{:02x} \", alloc.bytes[i]).unwrap();\n                 } else {\n-                    print!(\"__ \");\n+                    msg.push_str(\"__ \");\n                 }\n             }\n \n             let immutable = if alloc.immutable { \" (immutable)\" } else { \"\" };\n-            println!(\"({} bytes){}\", alloc.bytes.len(), immutable);\n+            trace!(\"{}({} bytes){}\", msg, alloc.bytes.len(), immutable);\n \n             if !relocations.is_empty() {\n-                print!(\"{:1$}\", \"\", prefix.len()); // Print spaces.\n+                msg.clear();\n+                write!(msg, \"{:1$}\", \"\", prefix_len).unwrap(); // Print spaces.\n                 let mut pos = 0;\n                 let relocation_width = (self.pointer_size() - 1) * 3;\n                 for (i, target_id) in relocations {\n-                    print!(\"{:1$}\", \"\", (i - pos) * 3);\n-                    print!(\"\u2514{0:\u2500^1$}\u2518 \", format!(\"({})\", target_id), relocation_width);\n+                    write!(msg, \"{:1$}\", \"\", (i - pos) * 3).unwrap();\n+                    write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", format!(\"({})\", target_id), relocation_width).unwrap();\n                     pos = i + self.pointer_size();\n                 }\n-                println!(\"\");\n+                trace!(\"{}\", msg);\n             }\n         }\n     }\n@@ -404,6 +404,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n /// Byte accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     fn get_bytes_unchecked(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n+        if size == 0 {\n+            return Ok(&[]);\n+        }\n         let alloc = self.get(ptr.alloc_id)?;\n         if ptr.offset + size > alloc.bytes.len() {\n             return Err(EvalError::PointerOutOfBounds {\n@@ -416,6 +419,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     fn get_bytes_unchecked_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &mut [u8]> {\n+        if size == 0 {\n+            return Ok(&mut []);\n+        }\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         if ptr.offset + size > alloc.bytes.len() {\n             return Err(EvalError::PointerOutOfBounds {\n@@ -428,6 +434,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     fn get_bytes(&self, ptr: Pointer, size: usize, align: usize) -> EvalResult<'tcx, &[u8]> {\n+        if size == 0 {\n+            return Ok(&[]);\n+        }\n         self.check_align(ptr, align)?;\n         if self.relocations(ptr, size)?.count() != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n@@ -437,6 +446,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     fn get_bytes_mut(&mut self, ptr: Pointer, size: usize, align: usize) -> EvalResult<'tcx, &mut [u8]> {\n+        if size == 0 {\n+            return Ok(&mut []);\n+        }\n         self.check_align(ptr, align)?;\n         self.clear_relocations(ptr, size)?;\n         self.mark_definedness(ptr, size, true)?;\n@@ -447,15 +459,17 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn freeze(&mut self, alloc_id: AllocId) -> EvalResult<'tcx, ()> {\n-        // Never freeze the zero-sized allocation. If you do that, then getting a mutable handle to\n-        // _any_ ZST becomes an error, since they all share the same allocation.\n+        // It's not possible to freeze the zero-sized allocation, because it doesn't exist.\n         if alloc_id != ZST_ALLOC_ID {\n             self.get_mut(alloc_id)?.immutable = true;\n         }\n         Ok(())\n     }\n \n     pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize, align: usize) -> EvalResult<'tcx, ()> {\n+        if size == 0 {\n+            return Ok(());\n+        }\n         self.check_relocation_edges(src, size)?;\n \n         let src_bytes = self.get_bytes_unchecked(src, size)?.as_ptr();\n@@ -503,7 +517,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         match alloc.relocations.get(&ptr.offset) {\n             Some(&alloc_id) => Ok(Pointer { alloc_id: alloc_id, offset: offset }),\n-            None => Err(EvalError::ReadBytesAsPointer),\n+            None => Ok(Pointer::from_int(offset)),\n         }\n     }\n \n@@ -514,7 +528,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn write_primval(&mut self, ptr: Pointer, val: PrimVal) -> EvalResult<'tcx, ()> {\n-        let pointer_size = self.pointer_size();\n         match val {\n             PrimVal::Bool(b) => self.write_bool(ptr, b),\n             PrimVal::I8(n)   => self.write_int(ptr, n as i64, 1),\n@@ -526,7 +539,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             PrimVal::U32(n)  => self.write_uint(ptr, n as u64, 4),\n             PrimVal::U64(n)  => self.write_uint(ptr, n as u64, 8),\n             PrimVal::Char(c) => self.write_uint(ptr, c as u64, 4),\n-            PrimVal::IntegerPtr(n) => self.write_uint(ptr, n as u64, pointer_size),\n             PrimVal::F32(f) => self.write_f32(ptr, f),\n             PrimVal::F64(f) => self.write_f64(ptr, f),\n             PrimVal::FnPtr(p) |\n@@ -712,6 +724,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn mark_definedness(&mut self, ptr: Pointer, size: usize, new_state: bool)\n         -> EvalResult<'tcx, ()>\n     {\n+        if size == 0 {\n+            return Ok(())\n+        }\n         let mut alloc = self.get_mut(ptr.alloc_id)?;\n         alloc.undef_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n         Ok(())"}, {"sha": "717ad99dbcd50b813321f2c77af5331909584c3a", "filename": "src/primval.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -14,7 +14,6 @@ pub enum PrimVal {\n \n     Ptr(Pointer),\n     FnPtr(Pointer),\n-    IntegerPtr(u64),\n     Char(char),\n \n     F32(f32), F64(f64),\n@@ -209,14 +208,8 @@ pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> Eva\n             })\n         }\n \n-        (IntegerPtr(l), IntegerPtr(r)) => int_binops!(IntegerPtr, l, r),\n-\n-        (Ptr(_), IntegerPtr(_)) |\n-        (IntegerPtr(_), Ptr(_)) |\n         (FnPtr(_), Ptr(_)) |\n-        (Ptr(_), FnPtr(_)) |\n-        (FnPtr(_), IntegerPtr(_)) |\n-        (IntegerPtr(_), FnPtr(_)) =>\n+        (Ptr(_), FnPtr(_)) =>\n             unrelated_ptr_ops(bin_op)?,\n \n         (FnPtr(l_ptr), FnPtr(r_ptr)) => match bin_op {"}, {"sha": "fcf34ed44c93aa523d2fd73dbb939a8a3e056bb6", "filename": "tests/compile-fail/null_pointer_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnull_pointer_deref.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR: attempted to interpret some raw bytes as a pointer address\n+    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR: tried to access memory through an invalid pointer\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "937546fdc350ac17d315c8af1a40b7a322ffa47e", "filename": "tests/compile-fail/wild_pointer_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwild_pointer_deref.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let p = 42 as *const i32;\n-    let x = unsafe { *p }; //~ ERROR: attempted to interpret some raw bytes as a pointer address\n+    let x = unsafe { *p }; //~ ERROR: tried to access memory through an invalid pointer\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "970cc9abc9daf0d2040f5629fc18e922067d8fc1", "filename": "tests/compile-fail/zst.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Fcompile-fail%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Fcompile-fail%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let x = &() as *const () as *const i32;\n+    let _ = unsafe { *x }; //~ ERROR: tried to access memory through an invalid pointer\n+}"}, {"sha": "3a9f24ad4cc7c7bb1bef2788755583bb35d3b303", "filename": "tests/run-pass/cast-rfc0401-vtable-kinds.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that you can cast between different pointers to trait objects\n+// whose vtable have the same kind (both lengths, or both trait pointers).\n+\n+trait Foo<T> {\n+    fn foo(&self, _: T) -> u32 { 42 }\n+}\n+\n+trait Bar {\n+    fn bar(&self) { println!(\"Bar!\"); }\n+}\n+\n+impl<T> Foo<T> for () {}\n+impl Foo<u32> for u32 { fn foo(&self, _: u32) -> u32 { self+43 } }\n+impl Bar for () {}\n+\n+unsafe fn round_trip_and_call<'a>(t: *const (Foo<u32>+'a)) -> u32 {\n+    let foo_e : *const Foo<u16> = t as *const _;\n+    let r_1 = foo_e as *mut Foo<u32>;\n+\n+    (&*r_1).foo(0)\n+}\n+\n+#[repr(C)]\n+struct FooS<T:?Sized>(T);\n+#[repr(C)]\n+struct BarS<T:?Sized>(T);\n+\n+fn foo_to_bar<T:?Sized>(u: *const FooS<T>) -> *const BarS<T> {\n+    u as *const BarS<T>\n+}\n+\n+fn main() {\n+    let x = 4u32;\n+    let y : &Foo<u32> = &x;\n+    let fl = unsafe { round_trip_and_call(y as *const Foo<u32>) };\n+    assert_eq!(fl, (43+4));\n+\n+    let s = FooS([0,1,2]);\n+    let u: &FooS<[u32]> = &s;\n+    let u: *const FooS<[u32]> = u;\n+    let bar_ref : *const BarS<[u32]> = foo_to_bar(u);\n+    let z : &BarS<[u32]> = unsafe{&*bar_ref};\n+    assert_eq!(&z.0, &[0,1,2]);\n+}"}, {"sha": "9f8067f372aef89cae35b5d49d1c7e952b192510", "filename": "tests/run-pass/dst-irrefutable-bind.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fdst-irrefutable-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fdst-irrefutable-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-irrefutable-bind.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Test<T: ?Sized>(T);\n+\n+fn main() {\n+    let x = Test([1,2,3]);\n+    let x : &Test<[i32]> = &x;\n+\n+    let & ref _y = x;\n+\n+    // Make sure binding to a fat pointer behind a reference\n+    // still works\n+    let slice = &[1,2,3];\n+    let x = Test(&slice);\n+    let Test(&_slice) = x;\n+}"}, {"sha": "3a74626b0299f2be8af8229e70da2ad5ded479db", "filename": "tests/run-pass/dst-raw.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-raw.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test DST raw pointers\n+\n+\n+trait Trait {\n+    fn foo(&self) -> isize;\n+}\n+\n+struct A {\n+    f: isize\n+}\n+impl Trait for A {\n+    fn foo(&self) -> isize {\n+        self.f\n+    }\n+}\n+\n+struct Foo<T: ?Sized> {\n+    f: T\n+}\n+\n+pub fn main() {\n+    // raw trait object\n+    let x = A { f: 42 };\n+    let z: *const Trait = &x;\n+    let r = unsafe {\n+        (&*z).foo()\n+    };\n+    assert_eq!(r, 42);\n+\n+    // raw DST struct\n+    let p = Foo {f: A { f: 42 }};\n+    let o: *const Foo<Trait> = &p;\n+    let r = unsafe {\n+        (&*o).f.foo()\n+    };\n+    assert_eq!(r, 42);\n+\n+    // raw slice\n+    let a: *const [_] = &[1, 2, 3];\n+    unsafe {\n+        let b = (*a)[2];\n+        assert_eq!(b, 3);\n+        let len = (*a).len();\n+        assert_eq!(len, 3);\n+    }\n+\n+    // raw slice with explicit cast\n+    let a = &[1, 2, 3] as *const [i32];\n+    unsafe {\n+        let b = (*a)[2];\n+        assert_eq!(b, 3);\n+        let len = (*a).len();\n+        assert_eq!(len, 3);\n+    }\n+\n+    // raw DST struct with slice\n+    let c: *const Foo<[_]> = &Foo {f: [1, 2, 3]};\n+    unsafe {\n+        let b = (&*c).f[0];\n+        assert_eq!(b, 1);\n+        let len = (&*c).f.len();\n+        assert_eq!(len, 3);\n+    }\n+\n+    // all of the above with *mut\n+    let mut x = A { f: 42 };\n+    let z: *mut Trait = &mut x;\n+    let r = unsafe {\n+        (&*z).foo()\n+    };\n+    assert_eq!(r, 42);\n+\n+    let mut p = Foo {f: A { f: 42 }};\n+    let o: *mut Foo<Trait> = &mut p;\n+    let r = unsafe {\n+        (&*o).f.foo()\n+    };\n+    assert_eq!(r, 42);\n+\n+    let a: *mut [_] = &mut [1, 2, 3];\n+    unsafe {\n+        let b = (*a)[2];\n+        assert_eq!(b, 3);\n+        let len = (*a).len();\n+        assert_eq!(len, 3);\n+    }\n+\n+    let a = &mut [1, 2, 3] as *mut [i32];\n+    unsafe {\n+        let b = (*a)[2];\n+        assert_eq!(b, 3);\n+        let len = (*a).len();\n+        assert_eq!(len, 3);\n+    }\n+\n+    let c: *mut Foo<[_]> = &mut Foo {f: [1, 2, 3]};\n+    unsafe {\n+        let b = (&*c).f[0];\n+        assert_eq!(b, 1);\n+        let len = (&*c).f.len();\n+        assert_eq!(len, 3);\n+    }\n+}"}, {"sha": "58d7b35a5275cc2de0351d2e97ecd6342818c05d", "filename": "tests/run-pass/dst-struct-sole.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fdst-struct-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fdst-struct-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-struct-sole.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// As dst-struct.rs, but the unsized field is the only field in the struct.\n+\n+\n+struct Fat<T: ?Sized> {\n+    ptr: T\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[isize]>) {\n+    let y = &x.ptr;\n+    assert_eq!(x.ptr.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.ptr[1], 2);\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.ptr;\n+    let bar = Bar;\n+    assert_eq!(x.ptr.len(), 3);\n+    assert_eq!(y[0].to_bar(), bar);\n+    assert_eq!(x.ptr[1].to_bar(), bar);\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { ptr: [1, 2, 3] };\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[isize]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[isize]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[isize]> = &Fat { ptr: [1, 2, 3] };\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = Fat { ptr: [bar, bar, bar] };\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &Fat { ptr: [bar, bar, bar] };\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[isize]> = &mut Fat { ptr: [1, 2, 3] };\n+    f5.ptr[1] = 34;\n+    assert_eq!(f5.ptr[0], 1);\n+    assert_eq!(f5.ptr[1], 34);\n+    assert_eq!(f5.ptr[2], 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[isize]> = &Fat { ptr: [] };\n+    assert!(f5.ptr.is_empty());\n+    let f5: &Fat<[Bar]> = &Fat { ptr: [] };\n+    assert!(f5.ptr.is_empty());\n+}"}, {"sha": "fc806f5429a47c320a9c55a37aa204b8f3bdcf5a", "filename": "tests/run-pass/issue-23261.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fissue-23261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fissue-23261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-23261.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Matching on a DST struct should not trigger an LLVM assertion.\n+\n+struct Foo<T: ?Sized> {\n+    a: i32,\n+    inner: T\n+}\n+\n+trait Get {\n+    fn get(&self) -> i32;\n+}\n+\n+impl Get for i32 {\n+    fn get(&self) -> i32 {\n+        *self\n+    }\n+}\n+\n+fn check_val(val: &Foo<[u8]>) {\n+    match *val {\n+        Foo { a, .. } => {\n+            assert_eq!(a, 32);\n+        }\n+    }\n+}\n+\n+fn check_dst_val(val: &Foo<[u8]>) {\n+    match *val {\n+        Foo { ref inner, .. } => {\n+            assert_eq!(inner, [1, 2, 3]);\n+        }\n+    }\n+}\n+\n+fn check_both(val: &Foo<[u8]>) {\n+    match *val {\n+        Foo { a, ref inner } => {\n+            assert_eq!(a, 32);\n+            assert_eq!(inner, [1, 2, 3]);\n+        }\n+    }\n+}\n+\n+fn check_trait_obj(val: &Foo<Get>) {\n+    match *val {\n+        Foo { a, ref inner } => {\n+            assert_eq!(a, 32);\n+            assert_eq!(inner.get(), 32);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let foo: &Foo<[u8]> = &Foo { a: 32, inner: [1, 2, 3] };\n+    check_val(foo);\n+    check_dst_val(foo);\n+    check_both(foo);\n+\n+    let foo: &Foo<Get> = &Foo { a: 32, inner: 32 };\n+    check_trait_obj(foo);\n+}"}, {"sha": "95269d0569dec11e7fb6532ee671b799be609217", "filename": "tests/run-pass/issue-36278-prefix-nesting.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fissue-36278-prefix-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fissue-36278-prefix-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-36278-prefix-nesting.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 36278: On an unsized struct with >1 level of nontrivial\n+// nesting, ensure we are computing dynamic size of prefix correctly.\n+\n+use std::mem;\n+\n+const SZ: usize = 100;\n+struct P<T: ?Sized>([u8; SZ], T);\n+\n+type Ack<T> = P<P<T>>;\n+\n+fn main() {\n+    let size_of_sized; let size_of_unsized;\n+    let x: Box<Ack<[u8; 0]>> = Box::new(P([0; SZ], P([0; SZ], [0; 0])));\n+    size_of_sized = mem::size_of_val::<Ack<_>>(&x);\n+    let y: Box<Ack<[u8   ]>> = x;\n+    size_of_unsized = mem::size_of_val::<Ack<_>>(&y);\n+    assert_eq!(size_of_sized, size_of_unsized);\n+}"}, {"sha": "e5c9e3577d1c302a1cd6458eccf6019e01e1845b", "filename": "tests/run-pass/mir_fat_ptr.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fmir_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fmir_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmir_fat_ptr.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// test that ordinary fat pointer operations work.\n+\n+struct Wrapper<T: ?Sized>(u32, T);\n+\n+struct FatPtrContainer<'a> {\n+    ptr: &'a [u8]\n+}\n+\n+fn fat_ptr_project(a: &Wrapper<[u8]>) -> &[u8] {\n+    &a.1\n+}\n+\n+fn fat_ptr_simple(a: &[u8]) -> &[u8] {\n+    a\n+}\n+\n+fn fat_ptr_via_local(a: &[u8]) -> &[u8] {\n+    let x = a;\n+    x\n+}\n+\n+fn fat_ptr_from_struct(s: FatPtrContainer) -> &[u8] {\n+    s.ptr\n+}\n+\n+fn fat_ptr_to_struct(a: &[u8]) -> FatPtrContainer {\n+    FatPtrContainer { ptr: a }\n+}\n+\n+fn fat_ptr_store_to<'a>(a: &'a [u8], b: &mut &'a [u8]) {\n+    *b = a;\n+}\n+\n+fn fat_ptr_constant() -> &'static str {\n+    \"HELLO\"\n+}\n+\n+fn main() {\n+    let a = Wrapper(4, [7,6,5]);\n+\n+    let p = fat_ptr_project(&a);\n+    let p = fat_ptr_simple(p);\n+    let p = fat_ptr_via_local(p);\n+    let p = fat_ptr_from_struct(fat_ptr_to_struct(p));\n+\n+    let mut target : &[u8] = &[42];\n+    fat_ptr_store_to(p, &mut target);\n+    assert_eq!(target, &a.1);\n+\n+    assert_eq!(fat_ptr_constant(), \"HELLO\");\n+}"}, {"sha": "e3d93957fd96bc3ef20447703d7005a0eccbc2c2", "filename": "tests/run-pass/traits.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftraits.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -10,9 +10,14 @@ impl Trait for Struct {\n     }\n }\n \n+struct Foo<T: ?Sized>(T);\n+\n fn main() {\n     let y: &Trait = &Struct(42);\n     y.method();\n+    let x: Foo<Struct> = Foo(Struct(42));\n+    let y: &Foo<Trait> = &x;\n+    y.0.method();\n     /*\n     let x: Box<Fn(i32) -> i32> = Box::new(|x| x * 2);\n     assert_eq!(x(21), 42);"}, {"sha": "78d3025587f04c95de1cc280c0fca2236720c469", "filename": "tests/run-pass/zst.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3659eabbdb8159c00b741bcb67c0209d1d5710/tests%2Frun-pass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst.rs?ref=1e3659eabbdb8159c00b741bcb67c0209d1d5710", "patch": "@@ -21,4 +21,6 @@ fn main() {\n     assert_eq!(use_zst(), A);\n     assert_eq!(&A as *const A as *const (), &() as *const _);\n     assert_eq!(&A as *const A, &A as *const A);\n+    let x = 42 as *mut ();\n+    unsafe { *x = (); }\n }"}]}