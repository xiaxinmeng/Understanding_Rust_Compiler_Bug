{"sha": "650b1b1f3a41aa747da37dea3b32108b08146075", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MGIxYjFmM2E0MWFhNzQ3ZGEzN2RlYTNiMzIxMDhiMDgxNDYwNzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-08T18:12:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-08T18:12:26Z"}, "message": "Auto merge of #45016 - pnkfelix:mir-borrowck-gather-and-signal-move-errors, r=nikomatsakis\n\nMIR-borrowck: gather and signal any move errors\n\nWhen building up the `MoveData` structure for a given MIR, also accumulate any erroneous actions, and then report all of those errors when the construction is complete.\n\nThis PR adds a host of move-related error constructor methods to `trait BorrowckErrors`. I think I got the notes right; but we should plan to audit all of the notes before turning MIR-borrowck on by default.\n\nFix #44830", "tree": {"sha": "e01fce73d7b35963516ad747221b59563402bacf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e01fce73d7b35963516ad747221b59563402bacf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/650b1b1f3a41aa747da37dea3b32108b08146075", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/650b1b1f3a41aa747da37dea3b32108b08146075", "html_url": "https://github.com/rust-lang/rust/commit/650b1b1f3a41aa747da37dea3b32108b08146075", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/650b1b1f3a41aa747da37dea3b32108b08146075/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ade0b01ebf18550e41d24c6e36f91afaccd7f389", "url": "https://api.github.com/repos/rust-lang/rust/commits/ade0b01ebf18550e41d24c6e36f91afaccd7f389", "html_url": "https://github.com/rust-lang/rust/commit/ade0b01ebf18550e41d24c6e36f91afaccd7f389"}, {"sha": "86ca5cf94241104c2a24d75f98784f65a40f7baa", "url": "https://api.github.com/repos/rust-lang/rust/commits/86ca5cf94241104c2a24d75f98784f65a40f7baa", "html_url": "https://github.com/rust-lang/rust/commit/86ca5cf94241104c2a24d75f98784f65a40f7baa"}], "stats": {"total": 936, "additions": 557, "deletions": 379}, "files": [{"sha": "075a629de04da403e208252464feb29111a92446", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -260,6 +260,19 @@ impl<'tcx> Mir<'tcx> {\n         debug_assert!(location.statement_index < block.statements.len());\n         block.statements[location.statement_index].make_nop()\n     }\n+\n+    /// Returns the source info associated with `location`.\n+    pub fn source_info(&self, location: Location) -> &SourceInfo {\n+        let block = &self[location.block];\n+        let stmts = &block.statements;\n+        let idx = location.statement_index;\n+        if location.statement_index < stmts.len() {\n+            &stmts[idx].source_info\n+        } else {\n+            assert!(location.statement_index == stmts.len());\n+            &block.terminator().source_info\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "1f2b917bdb9943154cd6ca5fc5e269f7c00a06e3", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -14,6 +14,7 @@ use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::NoteClosureEnv;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::ty;\n+use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n use syntax::ast;\n use syntax_pos;\n use errors::DiagnosticBuilder;\n@@ -134,51 +135,29 @@ fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n }\n \n // (keep in sync with gather_moves::check_and_get_illegal_move_origin )\n-fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+fn report_cannot_move_out_of<'a, 'tcx>(bccx: &'a BorrowckCtxt<'a, 'tcx>,\n                                        move_from: mc::cmt<'tcx>)\n                                        -> DiagnosticBuilder<'a> {\n     match move_from.cat {\n         Categorization::Deref(_, mc::BorrowedPtr(..)) |\n         Categorization::Deref(_, mc::Implicit(..)) |\n         Categorization::Deref(_, mc::UnsafePtr(..)) |\n         Categorization::StaticItem => {\n-            let mut err = struct_span_err!(bccx, move_from.span, E0507,\n-                             \"cannot move out of {}\",\n-                             move_from.descriptive_string(bccx.tcx));\n-            err.span_label(\n-                move_from.span,\n-                format!(\"cannot move out of {}\", move_from.descriptive_string(bccx.tcx))\n-                );\n-            err\n+            bccx.cannot_move_out_of(\n+                move_from.span, &move_from.descriptive_string(bccx.tcx), Origin::Ast)\n         }\n-\n         Categorization::Interior(ref b, mc::InteriorElement(ik)) => {\n-            let type_name = match (&b.ty.sty, ik) {\n-                (&ty::TyArray(_, _), Kind::Index) => \"array\",\n-                (&ty::TySlice(_), _) => \"slice\",\n-                _ => {\n-                    span_bug!(move_from.span, \"this path should not cause illegal move\");\n-                },\n-            };\n-            let mut err = struct_span_err!(bccx, move_from.span, E0508,\n-                                           \"cannot move out of type `{}`, \\\n-                                            a non-copy {}\",\n-                                           b.ty, type_name);\n-            err.span_label(move_from.span, \"cannot move out of here\");\n-            err\n+            bccx.cannot_move_out_of_interior_noncopy(\n+                move_from.span, b.ty, ik == Kind::Index, Origin::Ast)\n         }\n \n         Categorization::Downcast(ref b, _) |\n         Categorization::Interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n                 ty::TyAdt(def, _) if def.has_dtor(bccx.tcx) => {\n-                    let mut err = struct_span_err!(bccx, move_from.span, E0509,\n-                                                   \"cannot move out of type `{}`, \\\n-                                                   which implements the `Drop` trait\",\n-                                                   b.ty);\n-                    err.span_label(move_from.span, \"cannot move out of here\");\n-                    err\n-                },\n+                    bccx.cannot_move_out_of_interior_of_drop(\n+                        move_from.span, b.ty, Origin::Ast)\n+                }\n                 _ => {\n                     span_bug!(move_from.span, \"this path should not cause illegal move\");\n                 }"}, {"sha": "031dbcb1ebb91c2a0198476898eb072b3a04c5ae", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 266, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -317,272 +317,6 @@ fn main() {\n ```\n \"##,\n \n-E0507: r##\"\n-You tried to move out of a value which was borrowed. Erroneous code example:\n-\n-```compile_fail,E0507\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n-}\n-```\n-\n-Here, the `nothing_is_true` method takes the ownership of `self`. However,\n-`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\n-which is a borrow of the content owned by the `RefCell`. To fix this error,\n-you have three choices:\n-\n-* Try to avoid moving the variable.\n-* Somehow reclaim the ownership.\n-* Implement the `Copy` trait on the type.\n-\n-Examples:\n-\n-```\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(&self) {} // First case, we don't take ownership\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // ok!\n-}\n-```\n-\n-Or:\n-\n-```\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-    let x = x.into_inner(); // we get back ownership\n-\n-    x.nothing_is_true(); // ok!\n-}\n-```\n-\n-Or:\n-\n-```\n-use std::cell::RefCell;\n-\n-#[derive(Clone, Copy)] // we implement the Copy trait\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // ok!\n-}\n-```\n-\n-Moving a member out of a mutably borrowed struct will also cause E0507 error:\n-\n-```compile_fail,E0507\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-struct Batcave {\n-    knight: TheDarkKnight\n-}\n-\n-fn main() {\n-    let mut cave = Batcave {\n-        knight: TheDarkKnight\n-    };\n-    let borrowed = &mut cave;\n-\n-    borrowed.knight.nothing_is_true(); // E0507\n-}\n-```\n-\n-It is fine only if you put something back. `mem::replace` can be used for that:\n-\n-```\n-# struct TheDarkKnight;\n-# impl TheDarkKnight { fn nothing_is_true(self) {} }\n-# struct Batcave { knight: TheDarkKnight }\n-use std::mem;\n-\n-let mut cave = Batcave {\n-    knight: TheDarkKnight\n-};\n-let borrowed = &mut cave;\n-\n-mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n-\"##,\n-\n-E0508: r##\"\n-A value was moved out of a non-copy fixed-size array.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0508\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,\n-                           //        a non-copy fixed-size array\n-}\n-```\n-\n-The first element was moved out of the array, but this is not\n-possible because `NonCopy` does not implement the `Copy` trait.\n-\n-Consider borrowing the element instead of moving it:\n-\n-```\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    let _value = &array[0]; // Borrowing is allowed, unlike moving.\n-}\n-```\n-\n-Alternatively, if your type implements `Clone` and you need to own the value,\n-consider borrowing and then cloning:\n-\n-```\n-#[derive(Clone)]\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    // Now you can clone the array element.\n-    let _value = array[0].clone();\n-}\n-```\n-\"##,\n-\n-E0509: r##\"\n-This error occurs when an attempt is made to move out of a value whose type\n-implements the `Drop` trait.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0509\n-struct FancyNum {\n-    num: usize\n-}\n-\n-struct DropStruct {\n-    fancy: FancyNum\n-}\n-\n-impl Drop for DropStruct {\n-    fn drop(&mut self) {\n-        // Destruct DropStruct, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n-    let fancy_field = drop_struct.fancy; // Error E0509\n-    println!(\"Fancy: {}\", fancy_field.num);\n-    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n-}\n-```\n-\n-Here, we tried to move a field out of a struct of type `DropStruct` which\n-implements the `Drop` trait. However, a struct cannot be dropped if one or\n-more of its fields have been moved.\n-\n-Structs implementing the `Drop` trait have an implicit destructor that gets\n-called when they go out of scope. This destructor may use the fields of the\n-struct, so moving out of the struct could make it impossible to run the\n-destructor. Therefore, we must think of all values whose type implements the\n-`Drop` trait as single units whose fields cannot be moved.\n-\n-This error can be fixed by creating a reference to the fields of a struct,\n-enum, or tuple using the `ref` keyword:\n-\n-```\n-struct FancyNum {\n-    num: usize\n-}\n-\n-struct DropStruct {\n-    fancy: FancyNum\n-}\n-\n-impl Drop for DropStruct {\n-    fn drop(&mut self) {\n-        // Destruct DropStruct, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n-    let ref fancy_field = drop_struct.fancy; // No more errors!\n-    println!(\"Fancy: {}\", fancy_field.num);\n-    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n-}\n-```\n-\n-Note that this technique can also be used in the arms of a match expression:\n-\n-```\n-struct FancyNum {\n-    num: usize\n-}\n-\n-enum DropEnum {\n-    Fancy(FancyNum)\n-}\n-\n-impl Drop for DropEnum {\n-    fn drop(&mut self) {\n-        // Destruct DropEnum, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    // Creates and enum of type `DropEnum`, which implements `Drop`\n-    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\n-    match drop_enum {\n-        // Creates a reference to the inside of `DropEnum::Fancy`\n-        DropEnum::Fancy(ref fancy_field) => // No error!\n-            println!(\"It was fancy-- {}!\", fancy_field.num),\n-    }\n-    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\n-}\n-```\n-\"##,\n-\n E0595: r##\"\n Closures cannot mutate immutable captured variables.\n "}, {"sha": "db6a0ee4ba5d368cc4614162c9b3affed39078dc", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -30,6 +30,7 @@ use dataflow::{MoveDataParamEnv};\n use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{Borrows, BorrowData, BorrowIndex};\n+use dataflow::move_paths::{MoveError, IllegalMoveOriginKind};\n use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -59,7 +60,33 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     let param_env = tcx.param_env(def_id);\n     tcx.infer_ctxt().enter(|_infcx| {\n \n-        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n+        let move_data = match MoveData::gather_moves(mir, tcx, param_env) {\n+            Ok(move_data) => move_data,\n+            Err((move_data, move_errors)) => {\n+                for move_error in move_errors {\n+                    let (span, kind): (Span, IllegalMoveOriginKind) = match move_error {\n+                        MoveError::UnionMove { .. } =>\n+                            unimplemented!(\"dont know how to report union move errors yet.\"),\n+                        MoveError::IllegalMove { cannot_move_out_of: o } => (o.span, o.kind),\n+                    };\n+                    let origin = Origin::Mir;\n+                    let mut err = match kind {\n+                        IllegalMoveOriginKind::Static =>\n+                            tcx.cannot_move_out_of(span, \"static item\", origin),\n+                        IllegalMoveOriginKind::BorrowedContent =>\n+                            tcx.cannot_move_out_of(span, \"borrowed_content\", origin),\n+                        IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } =>\n+                            tcx.cannot_move_out_of_interior_of_drop(span, ty, origin),\n+                        IllegalMoveOriginKind::InteriorOfSlice { elem_ty: ty, is_index } =>\n+                            tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n+                        IllegalMoveOriginKind::InteriorOfArray { elem_ty: ty, is_index } =>\n+                            tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n+                    };\n+                    err.emit();\n+                }\n+                move_data\n+            }\n+        };\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n         let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n         let flow_borrows = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n@@ -1106,9 +1133,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     // Retrieve span of given borrow from the current MIR representation\n     fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n-        self.mir.basic_blocks()[borrow.location.block]\n-            .statements[borrow.location.statement_index]\n-            .source_info.span\n+        self.mir.source_info(borrow.location).span\n     }\n }\n "}, {"sha": "0790d937cebf014df686036a22f07ea2c78658e4", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 102, "deletions": 63, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -22,17 +22,15 @@ use std::mem;\n use super::abs_domain::Lift;\n \n use super::{LocationMap, MoveData, MovePath, MovePathLookup, MovePathIndex, MoveOut, MoveOutIndex};\n+use super::{MoveError};\n+use super::IllegalMoveOriginKind::*;\n \n-pub(super) struct MoveDataBuilder<'a, 'tcx: 'a> {\n+struct MoveDataBuilder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     data: MoveData<'tcx>,\n-}\n-\n-pub enum MovePathError {\n-    IllegalMove,\n-    UnionMove { path: MovePathIndex },\n+    errors: Vec<MoveError<'tcx>>,\n }\n \n impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n@@ -47,6 +45,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             mir,\n             tcx,\n             param_env,\n+            errors: Vec::new(),\n             data: MoveData {\n                 moves: IndexVec::new(),\n                 loc_map: LocationMap::new(mir),\n@@ -85,7 +84,9 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         assert_eq!(path_map_ent, move_path);\n         move_path\n     }\n+}\n \n+impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     /// This creates a MovePath for a given lvalue, returning an `MovePathError`\n     /// if that lvalue can't be moved from.\n     ///\n@@ -94,13 +95,15 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     ///\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n     fn move_path_for(&mut self, lval: &Lvalue<'tcx>)\n-                     -> Result<MovePathIndex, MovePathError>\n+                     -> Result<MovePathIndex, MoveError<'tcx>>\n     {\n         debug!(\"lookup({:?})\", lval);\n         match *lval {\n-            Lvalue::Local(local) => Ok(self.data.rev_lookup.locals[local]),\n-            // error: can't move out of a static\n-            Lvalue::Static(..) => Err(MovePathError::IllegalMove),\n+            Lvalue::Local(local) => Ok(self.builder.data.rev_lookup.locals[local]),\n+            Lvalue::Static(..) => {\n+                let span = self.builder.mir.source_info(self.loc).span;\n+                Err(MoveError::cannot_move_out_of(span, Static))\n+            }\n             Lvalue::Projection(ref proj) => {\n                 self.move_path_for_projection(lval, proj)\n             }\n@@ -116,37 +119,52 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     fn move_path_for_projection(&mut self,\n                                 lval: &Lvalue<'tcx>,\n                                 proj: &LvalueProjection<'tcx>)\n-                                -> Result<MovePathIndex, MovePathError>\n+                                -> Result<MovePathIndex, MoveError<'tcx>>\n     {\n         let base = try!(self.move_path_for(&proj.base));\n-        let lv_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        let mir = self.builder.mir;\n+        let tcx = self.builder.tcx;\n+        let lv_ty = proj.base.ty(mir, tcx).to_ty(tcx);\n         match lv_ty.sty {\n-            // error: can't move out of borrowed content\n-            ty::TyRef(..) | ty::TyRawPtr(..) => return Err(MovePathError::IllegalMove),\n-            // error: can't move out of struct with destructor\n-            ty::TyAdt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() =>\n-                return Err(MovePathError::IllegalMove),\n+            ty::TyRef(..) | ty::TyRawPtr(..) =>\n+                return Err(MoveError::cannot_move_out_of(mir.source_info(self.loc).span,\n+                                                         BorrowedContent)),\n+            ty::TyAdt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n+                return Err(MoveError::cannot_move_out_of(mir.source_info(self.loc).span,\n+                                                         InteriorOfTypeWithDestructor {\n+                    container_ty: lv_ty\n+                })),\n             // move out of union - always move the entire union\n             ty::TyAdt(adt, _) if adt.is_union() =>\n-                return Err(MovePathError::UnionMove { path: base }),\n-            // error: can't move out of a slice\n-            ty::TySlice(..) =>\n-                return Err(MovePathError::IllegalMove),\n-            ty::TyArray(..) => match proj.elem {\n-                // error: can't move out of an array\n-                ProjectionElem::Index(..) => return Err(MovePathError::IllegalMove),\n+                return Err(MoveError::UnionMove { path: base }),\n+            ty::TySlice(elem_ty) =>\n+                return Err(MoveError::cannot_move_out_of(\n+                    mir.source_info(self.loc).span,\n+                    InteriorOfSlice {\n+                        elem_ty, is_index: match proj.elem {\n+                            ProjectionElem::Index(..) => true,\n+                            _ => false\n+                        },\n+                    })),\n+            ty::TyArray(elem_ty, _num_elems) => match proj.elem {\n+                ProjectionElem::Index(..) =>\n+                    return Err(MoveError::cannot_move_out_of(\n+                        mir.source_info(self.loc).span,\n+                        InteriorOfArray {\n+                            elem_ty, is_index: true\n+                        })),\n                 _ => {\n                     // FIXME: still badly broken\n                 }\n             },\n             _ => {}\n         };\n-        match self.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n+        match self.builder.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n             Entry::Occupied(ent) => Ok(*ent.get()),\n             Entry::Vacant(ent) => {\n-                let path = Self::new_move_path(\n-                    &mut self.data.move_paths,\n-                    &mut self.data.path_map,\n+                let path = MoveDataBuilder::new_move_path(\n+                    &mut self.builder.data.move_paths,\n+                    &mut self.builder.data.path_map,\n                     Some(base),\n                     lval.clone()\n                 );\n@@ -155,8 +173,10 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n         }\n     }\n+}\n \n-    fn finalize(self) -> MoveData<'tcx> {\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+    fn finalize(self) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n         debug!(\"{}\", {\n             debug!(\"moves for {:?}:\", self.mir.span);\n             for (j, mo) in self.data.moves.iter_enumerated() {\n@@ -168,14 +188,20 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n             \"done dumping moves\"\n         });\n-        self.data\n+\n+        if self.errors.len() > 0 {\n+            Err((self.data, self.errors))\n+        } else {\n+            Ok(self.data)\n+        }\n     }\n }\n \n pub(super) fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      param_env: ty::ParamEnv<'tcx>)\n-                                     -> MoveData<'tcx> {\n+                                     -> Result<MoveData<'tcx>,\n+                                               (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n     let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n \n     for (bb, block) in mir.basic_blocks().iter_enumerated() {\n@@ -197,6 +223,22 @@ pub(super) fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     fn gather_statement(&mut self, loc: Location, stmt: &Statement<'tcx>) {\n         debug!(\"gather_statement({:?}, {:?})\", loc, stmt);\n+        (Gatherer { builder: self, loc }).gather_statement(stmt);\n+    }\n+\n+    fn gather_terminator(&mut self, loc: Location, term: &Terminator<'tcx>) {\n+        debug!(\"gather_terminator({:?}, {:?})\", loc, term);\n+        (Gatherer { builder: self, loc }).gather_terminator(term);\n+    }\n+}\n+\n+struct Gatherer<'b, 'a: 'b, 'tcx: 'a> {\n+    builder: &'b mut MoveDataBuilder<'a, 'tcx>,\n+    loc: Location,\n+}\n+\n+impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n+    fn gather_statement(&mut self, stmt: &Statement<'tcx>) {\n         match stmt.kind {\n             StatementKind::Assign(ref lval, ref rval) => {\n                 self.create_move_path(lval);\n@@ -206,7 +248,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                     // the exterior.\n                     self.create_move_path(&lval.clone().deref());\n                 }\n-                self.gather_rvalue(loc, rval);\n+                self.gather_rvalue(rval);\n             }\n             StatementKind::StorageLive(_) |\n             StatementKind::StorageDead(_) => {}\n@@ -221,22 +263,22 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn gather_rvalue(&mut self, loc: Location, rvalue: &Rvalue<'tcx>) {\n+    fn gather_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n         match *rvalue {\n             Rvalue::Use(ref operand) |\n             Rvalue::Repeat(ref operand, _) |\n             Rvalue::Cast(_, ref operand, _) |\n             Rvalue::UnaryOp(_, ref operand) => {\n-                self.gather_operand(loc, operand)\n+                self.gather_operand(operand)\n             }\n             Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs) |\n             Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n-                self.gather_operand(loc, lhs);\n-                self.gather_operand(loc, rhs);\n+                self.gather_operand(lhs);\n+                self.gather_operand(rhs);\n             }\n             Rvalue::Aggregate(ref _kind, ref operands) => {\n                 for operand in operands {\n-                    self.gather_operand(loc, operand);\n+                    self.gather_operand(operand);\n                 }\n             }\n             Rvalue::Ref(..) |\n@@ -258,16 +300,15 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn gather_terminator(&mut self, loc: Location, term: &Terminator<'tcx>) {\n-        debug!(\"gather_terminator({:?}, {:?})\", loc, term);\n+    fn gather_terminator(&mut self, term: &Terminator<'tcx>) {\n         match term.kind {\n             TerminatorKind::Goto { target: _ } |\n             TerminatorKind::Resume |\n             TerminatorKind::GeneratorDrop |\n             TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n-                self.gather_move(loc, &Lvalue::Local(RETURN_POINTER));\n+                self.gather_move(&Lvalue::Local(RETURN_POINTER));\n             }\n \n             TerminatorKind::Assert { .. } |\n@@ -276,20 +317,20 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n \n             TerminatorKind::Yield { ref value, .. } => {\n-                self.gather_operand(loc, value);\n+                self.gather_operand(value);\n             }\n \n             TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n-                self.gather_move(loc, location);\n+                self.gather_move(location);\n             }\n             TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n                 self.create_move_path(location);\n-                self.gather_operand(loc, value);\n+                self.gather_operand(value);\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n-                self.gather_operand(loc, func);\n+                self.gather_operand(func);\n                 for arg in args {\n-                    self.gather_operand(loc, arg);\n+                    self.gather_operand(arg);\n                 }\n                 if let Some((ref destination, _bb)) = *destination {\n                     self.create_move_path(destination);\n@@ -298,40 +339,38 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn gather_operand(&mut self, loc: Location, operand: &Operand<'tcx>) {\n+    fn gather_operand(&mut self, operand: &Operand<'tcx>) {\n         match *operand {\n             Operand::Constant(..) => {} // not-a-move\n             Operand::Consume(ref lval) => { // a move\n-                self.gather_move(loc, lval);\n+                self.gather_move(lval);\n             }\n         }\n     }\n \n-    fn gather_move(&mut self, loc: Location, lval: &Lvalue<'tcx>) {\n-        debug!(\"gather_move({:?}, {:?})\", loc, lval);\n+    fn gather_move(&mut self, lval: &Lvalue<'tcx>) {\n+        debug!(\"gather_move({:?}, {:?})\", self.loc, lval);\n \n-        let lv_ty = lval.ty(self.mir, self.tcx).to_ty(self.tcx);\n-        if !lv_ty.moves_by_default(self.tcx, self.param_env, DUMMY_SP) {\n-            debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", loc, lval, lv_ty);\n+        let tcx = self.builder.tcx;\n+        let lv_ty = lval.ty(self.builder.mir, tcx).to_ty(tcx);\n+        if !lv_ty.moves_by_default(tcx, self.builder.param_env, DUMMY_SP) {\n+            debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", self.loc, lval, lv_ty);\n             return\n         }\n \n         let path = match self.move_path_for(lval) {\n-            Ok(path) | Err(MovePathError::UnionMove { path }) => path,\n-            Err(MovePathError::IllegalMove) => {\n-                // Moving out of a bad path. Eventually, this should be a MIR\n-                // borrowck error instead of a bug.\n-                span_bug!(self.mir.span,\n-                          \"Broken MIR: moving out of lvalue {:?}: {:?} at {:?}\",\n-                          lval, lv_ty, loc);\n+            Ok(path) | Err(MoveError::UnionMove { path }) => path,\n+            Err(error @ MoveError::IllegalMove { .. }) => {\n+                self.builder.errors.push(error);\n+                return;\n             }\n         };\n-        let move_out = self.data.moves.push(MoveOut { path: path, source: loc });\n+        let move_out = self.builder.data.moves.push(MoveOut { path: path, source: self.loc });\n \n         debug!(\"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n-               loc, lval, move_out, path);\n+               self.loc, lval, move_out, path);\n \n-        self.data.path_map[path].push(move_out);\n-        self.data.loc_map[loc].push(move_out);\n+        self.builder.data.path_map[path].push(move_out);\n+        self.builder.data.loc_map[self.loc].push(move_out);\n     }\n }"}, {"sha": "9369156a223c87e7f6f113ea20a16f72ff847371", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -13,6 +13,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n+use syntax_pos::{Span};\n \n use std::fmt;\n use std::ops::{Index, IndexMut};\n@@ -227,11 +228,39 @@ impl<'tcx> MovePathLookup<'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct IllegalMoveOrigin<'tcx> {\n+    pub(crate) span: Span,\n+    pub(crate) kind: IllegalMoveOriginKind<'tcx>,\n+}\n+\n+#[derive(Debug)]\n+pub(crate) enum IllegalMoveOriginKind<'tcx> {\n+    Static,\n+    BorrowedContent,\n+    InteriorOfTypeWithDestructor { container_ty: ty::Ty<'tcx> },\n+    InteriorOfSlice { elem_ty: ty::Ty<'tcx>, is_index: bool, },\n+    InteriorOfArray { elem_ty: ty::Ty<'tcx>, is_index: bool, },\n+}\n+\n+#[derive(Debug)]\n+pub enum MoveError<'tcx> {\n+    IllegalMove { cannot_move_out_of: IllegalMoveOrigin<'tcx> },\n+    UnionMove { path: MovePathIndex },\n+}\n+\n+impl<'tcx> MoveError<'tcx> {\n+    fn cannot_move_out_of(span: Span, kind: IllegalMoveOriginKind<'tcx>) -> Self {\n+        let origin = IllegalMoveOrigin { span, kind };\n+        MoveError::IllegalMove { cannot_move_out_of: origin }\n+    }\n+}\n+\n impl<'a, 'tcx> MoveData<'tcx> {\n     pub fn gather_moves(mir: &Mir<'tcx>,\n                         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         param_env: ty::ParamEnv<'tcx>)\n-                        -> Self {\n+                        -> Result<Self, (Self, Vec<MoveError<'tcx>>)> {\n         builder::gather_moves(mir, tcx, param_env)\n     }\n }"}, {"sha": "645af0bff64deb09c5875a051098d538fe465cb6", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -999,6 +999,272 @@ fn print_fancy_ref(fancy_ref: &FancyNum){\n ```\n \"##,\n \n+E0507: r##\"\n+You tried to move out of a value which was borrowed. Erroneous code example:\n+\n+```compile_fail,E0507\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n+}\n+```\n+\n+Here, the `nothing_is_true` method takes the ownership of `self`. However,\n+`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\n+which is a borrow of the content owned by the `RefCell`. To fix this error,\n+you have three choices:\n+\n+* Try to avoid moving the variable.\n+* Somehow reclaim the ownership.\n+* Implement the `Copy` trait on the type.\n+\n+Examples:\n+\n+```\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(&self) {} // First case, we don't take ownership\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+    let x = x.into_inner(); // we get back ownership\n+\n+    x.nothing_is_true(); // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+use std::cell::RefCell;\n+\n+#[derive(Clone, Copy)] // we implement the Copy trait\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // ok!\n+}\n+```\n+\n+Moving a member out of a mutably borrowed struct will also cause E0507 error:\n+\n+```compile_fail,E0507\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+struct Batcave {\n+    knight: TheDarkKnight\n+}\n+\n+fn main() {\n+    let mut cave = Batcave {\n+        knight: TheDarkKnight\n+    };\n+    let borrowed = &mut cave;\n+\n+    borrowed.knight.nothing_is_true(); // E0507\n+}\n+```\n+\n+It is fine only if you put something back. `mem::replace` can be used for that:\n+\n+```\n+# struct TheDarkKnight;\n+# impl TheDarkKnight { fn nothing_is_true(self) {} }\n+# struct Batcave { knight: TheDarkKnight }\n+use std::mem;\n+\n+let mut cave = Batcave {\n+    knight: TheDarkKnight\n+};\n+let borrowed = &mut cave;\n+\n+mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n+\"##,\n+\n+E0508: r##\"\n+A value was moved out of a non-copy fixed-size array.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0508\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,\n+                           //        a non-copy fixed-size array\n+}\n+```\n+\n+The first element was moved out of the array, but this is not\n+possible because `NonCopy` does not implement the `Copy` trait.\n+\n+Consider borrowing the element instead of moving it:\n+\n+```\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    let _value = &array[0]; // Borrowing is allowed, unlike moving.\n+}\n+```\n+\n+Alternatively, if your type implements `Clone` and you need to own the value,\n+consider borrowing and then cloning:\n+\n+```\n+#[derive(Clone)]\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    // Now you can clone the array element.\n+    let _value = array[0].clone();\n+}\n+```\n+\"##,\n+\n+E0509: r##\"\n+This error occurs when an attempt is made to move out of a value whose type\n+implements the `Drop` trait.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0509\n+struct FancyNum {\n+    num: usize\n+}\n+\n+struct DropStruct {\n+    fancy: FancyNum\n+}\n+\n+impl Drop for DropStruct {\n+    fn drop(&mut self) {\n+        // Destruct DropStruct, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n+    let fancy_field = drop_struct.fancy; // Error E0509\n+    println!(\"Fancy: {}\", fancy_field.num);\n+    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n+}\n+```\n+\n+Here, we tried to move a field out of a struct of type `DropStruct` which\n+implements the `Drop` trait. However, a struct cannot be dropped if one or\n+more of its fields have been moved.\n+\n+Structs implementing the `Drop` trait have an implicit destructor that gets\n+called when they go out of scope. This destructor may use the fields of the\n+struct, so moving out of the struct could make it impossible to run the\n+destructor. Therefore, we must think of all values whose type implements the\n+`Drop` trait as single units whose fields cannot be moved.\n+\n+This error can be fixed by creating a reference to the fields of a struct,\n+enum, or tuple using the `ref` keyword:\n+\n+```\n+struct FancyNum {\n+    num: usize\n+}\n+\n+struct DropStruct {\n+    fancy: FancyNum\n+}\n+\n+impl Drop for DropStruct {\n+    fn drop(&mut self) {\n+        // Destruct DropStruct, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n+    let ref fancy_field = drop_struct.fancy; // No more errors!\n+    println!(\"Fancy: {}\", fancy_field.num);\n+    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n+}\n+```\n+\n+Note that this technique can also be used in the arms of a match expression:\n+\n+```\n+struct FancyNum {\n+    num: usize\n+}\n+\n+enum DropEnum {\n+    Fancy(FancyNum)\n+}\n+\n+impl Drop for DropEnum {\n+    fn drop(&mut self) {\n+        // Destruct DropEnum, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    // Creates and enum of type `DropEnum`, which implements `Drop`\n+    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\n+    match drop_enum {\n+        // Creates a reference to the inside of `DropEnum::Fancy`\n+        DropEnum::Fancy(ref fancy_field) => // No error!\n+            println!(\"It was fancy-- {}!\", fancy_field.num),\n+    }\n+    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\n+}\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "be1b794ecdfab698db3816582a3fd4adc2536666", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -45,7 +45,7 @@ impl MirPass for ElaborateDrops {\n         }\n         let id = src.item_id();\n         let param_env = tcx.param_env(tcx.hir.local_def_id(id));\n-        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n+        let move_data = MoveData::gather_moves(mir, tcx, param_env).unwrap();\n         let elaborate_patch = {\n             let mir = &*mir;\n             let env = MoveDataParamEnv {"}, {"sha": "8d6458d793474e2d414875f30cccffba54d18c44", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -45,7 +45,7 @@ impl MirPass for SanityCheck {\n \n         let attributes = tcx.get_attrs(def_id);\n         let param_env = tcx.param_env(def_id);\n-        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n+        let move_data = MoveData::gather_moves(mir, tcx, param_env).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n         let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n         let flow_inits ="}, {"sha": "37d53ca829e8562220d4922707517dc2c2a32a6b", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -248,6 +248,52 @@ pub trait BorrowckErrors {\n     {\n         self.cannot_assign(span, &format!(\"immutable static item `{}`\", desc), o)\n     }\n+\n+    fn cannot_move_out_of(&self, move_from_span: Span, move_from_desc: &str, o: Origin)\n+                          -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, move_from_span, E0507,\n+                                       \"cannot move out of {}{OGN}\",\n+                                       move_from_desc, OGN=o);\n+        err.span_label(\n+            move_from_span,\n+            format!(\"cannot move out of {}\", move_from_desc));\n+        err\n+    }\n+\n+    fn cannot_move_out_of_interior_noncopy(&self,\n+                                           move_from_span: Span,\n+                                           ty: ty::Ty,\n+                                           is_index: bool,\n+                                           o: Origin)\n+                                           -> DiagnosticBuilder\n+    {\n+        let type_name = match (&ty.sty, is_index) {\n+            (&ty::TyArray(_, _), true) => \"array\",\n+            (&ty::TySlice(_),    _) => \"slice\",\n+            _ => span_bug!(move_from_span, \"this path should not cause illegal move\"),\n+        };\n+        let mut err = struct_span_err!(self, move_from_span, E0508,\n+                                       \"cannot move out of type `{}`, \\\n+                                        a non-copy {}{OGN}\",\n+                                       ty, type_name, OGN=o);\n+        err.span_label(move_from_span, \"cannot move out of here\");\n+        err\n+    }\n+\n+    fn cannot_move_out_of_interior_of_drop(&self,\n+                                           move_from_span: Span,\n+                                           container_ty: ty::Ty,\n+                                           o: Origin)\n+                                           -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, move_from_span, E0509,\n+                                       \"cannot move out of type `{}`, \\\n+                                        which implements the `Drop` trait{OGN}\",\n+                                       container_ty, OGN=o);\n+        err.span_label(move_from_span, \"cannot move out of here\");\n+        err\n+    }\n }\n \n impl<'b, 'tcx, 'gcx> BorrowckErrors for TyCtxt<'b, 'tcx, 'gcx> {"}, {"sha": "fcdcf198c28523430c969b63cc249d38221a82a3", "filename": "src/test/compile-fail/borrowck/borrowck-fn-in-const-a.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-fn-in-const-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-fn-in-const-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-fn-in-const-a.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -8,12 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n // Check that we check fns appearing in constant declarations.\n // Issue #22382.\n \n const MOVE: fn(&String) -> String = {\n     fn broken(x: &String) -> String {\n-        return *x //~ ERROR cannot move\n+        return *x //[ast]~ ERROR cannot move out of borrowed content [E0507]\n+                  //[mir]~^ ERROR (Ast) [E0507]\n+                  //[mir]~| ERROR (Mir) [E0507]\n     }\n     broken\n };"}, {"sha": "99b5ef794c2cd0134935de0eca0671a5b85805c6", "filename": "src/test/compile-fail/borrowck/borrowck-move-in-irrefut-pat.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-in-irrefut-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-in-irrefut-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-in-irrefut-pat.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -8,19 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n fn with<F>(f: F) where F: FnOnce(&String) {}\n \n fn arg_item(&_x: &String) {}\n-    //~^ ERROR cannot move out of borrowed content\n+    //[ast]~^ ERROR cannot move out of borrowed content [E0507]\n+    //[mir]~^^ ERROR (Ast) [E0507]\n+    //[mir]~|  ERROR (Mir) [E0507]\n \n fn arg_closure() {\n     with(|&_x| ())\n-    //~^ ERROR cannot move out of borrowed content\n+    //[ast]~^ ERROR cannot move out of borrowed content [E0507]\n+    //[mir]~^^ ERROR (Ast) [E0507]\n+    //[mir]~|  ERROR (Mir) [E0507]\n }\n \n fn let_pat() {\n     let &_x = &\"hi\".to_string();\n-    //~^ ERROR cannot move out of borrowed content\n+    //[ast]~^ ERROR cannot move out of borrowed content [E0507]\n+    //[mir]~^^ ERROR (Ast) [E0507]\n+    //[mir]~|  ERROR (Mir) [E0507]\n }\n \n pub fn main() {}"}, {"sha": "c7e1ea1b758a1a30d6a44e27d68fe0848fac99e7", "filename": "src/test/compile-fail/borrowck/borrowck-move-out-of-overloaded-auto-deref.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -8,9 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n use std::rc::Rc;\n \n pub fn main() {\n     let _x = Rc::new(vec![1, 2]).into_iter();\n-    //~^ ERROR cannot move out of borrowed content\n+    //[ast]~^ ERROR cannot move out of borrowed content [E0507]\n+    //[mir]~^^ ERROR (Ast) [E0507]\n+    //[mir]~|  ERROR (Mir) [E0507]\n }"}, {"sha": "9e8021fd108a685ac55f97528c428af489c3b9c7", "filename": "src/test/compile-fail/borrowck/borrowck-move-out-of-static-item.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-static-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-static-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-static-item.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n // Ensure that moves out of static items is forbidden\n \n struct Foo {\n@@ -22,5 +25,7 @@ fn test(f: Foo) {\n }\n \n fn main() {\n-    test(BAR); //~ ERROR cannot move out of static item\n+    test(BAR); //[ast]~ ERROR cannot move out of static item [E0507]\n+               //[mir]~^ ERROR (Ast) [E0507]\n+               //[mir]~| ERROR (Mir) [E0507]\n }"}, {"sha": "982f31b1341c1cc4e8d5ec240bcce7504250a003", "filename": "src/test/compile-fail/borrowck/borrowck-move-out-of-struct-with-dtor.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n struct S {f:String}\n impl Drop for S {\n     fn drop(&mut self) { println!(\"{}\", self.f); }\n@@ -16,17 +19,23 @@ impl Drop for S {\n fn move_in_match() {\n     match (S {f:\"foo\".to_string()}) {\n         S {f:_s} => {}\n-        //~^ ERROR cannot move out of type `S`, which implements the `Drop` trait\n+        //[ast]~^ ERROR cannot move out of type `S`, which implements the `Drop` trait [E0509]\n+        //[mir]~^^ ERROR (Ast) [E0509]\n+        //[mir]~|  ERROR (Mir) [E0509]\n     }\n }\n \n fn move_in_let() {\n     let S {f:_s} = S {f:\"foo\".to_string()};\n-    //~^ ERROR cannot move out of type `S`, which implements the `Drop` trait\n+    //[ast]~^ ERROR cannot move out of type `S`, which implements the `Drop` trait [E0509]\n+    //[mir]~^^ ERROR (Ast) [E0509]\n+    //[mir]~|  ERROR (Mir) [E0509]\n }\n \n fn move_in_fn_arg(S {f:_s}: S) {\n-    //~^ ERROR cannot move out of type `S`, which implements the `Drop` trait\n+    //[ast]~^ ERROR cannot move out of type `S`, which implements the `Drop` trait [E0509]\n+    //[mir]~^^ ERROR (Ast) [E0509]\n+    //[mir]~|  ERROR (Mir) [E0509]\n }\n \n fn main() {}"}, {"sha": "4a1828c69582e2b78f3fa870321dd352085a1379", "filename": "src/test/compile-fail/borrowck/borrowck-struct-update-with-dtor.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-struct-update-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-struct-update-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-struct-update-with-dtor.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n // Issue 4691: Ensure that functional-struct-update can only copy, not\n // move, when the struct implements Drop.\n \n@@ -20,12 +23,16 @@ impl Drop for T { fn drop(&mut self) { } }\n \n fn f(s0:S) {\n     let _s2 = S{a: 2, ..s0};\n-    //~^ error: cannot move out of type `S`, which implements the `Drop` trait\n+    //[ast]~^ error: cannot move out of type `S`, which implements the `Drop` trait\n+    //[mir]~^^ ERROR (Ast) [E0509]\n+    //[mir]~|  ERROR (Mir) [E0509]\n }\n \n fn g(s0:T) {\n     let _s2 = T{a: 2, ..s0};\n-    //~^ error: cannot move out of type `T`, which implements the `Drop` trait\n+    //[ast]~^ error: cannot move out of type `T`, which implements the `Drop` trait\n+    //[mir]~^^ ERROR (Ast) [E0509]\n+    //[mir]~|  ERROR (Mir) [E0509]\n }\n \n fn main() { }"}, {"sha": "7f3120cc83edc5ebe0a6c4ab02cc01d9fad3b296", "filename": "src/test/compile-fail/borrowck/move-in-static-initializer-issue-38520.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fmove-in-static-initializer-issue-38520.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650b1b1f3a41aa747da37dea3b32108b08146075/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fmove-in-static-initializer-issue-38520.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fmove-in-static-initializer-issue-38520.rs?ref=650b1b1f3a41aa747da37dea3b32108b08146075", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n // Regression test for #38520. Check that moves of `Foo` are not\n // permitted as `Foo` is not copy (even in a static/const\n // initializer).\n@@ -21,8 +24,12 @@ const fn get(x: Foo) -> usize {\n }\n \n const X: Foo = Foo(22);\n-static Y: usize = get(*&X); //~ ERROR E0507\n-const Z: usize = get(*&X); //~ ERROR E0507\n+static Y: usize = get(*&X); //[ast]~ ERROR E0507\n+                            //[mir]~^ ERROR (Ast) [E0507]\n+                            //[mir]~| ERROR (Mir) [E0507]\n+const Z: usize = get(*&X); //[ast]~ ERROR E0507\n+                           //[mir]~^ ERROR (Ast) [E0507]\n+                           //[mir]~| ERROR (Mir) [E0507]\n \n fn main() {\n }"}]}