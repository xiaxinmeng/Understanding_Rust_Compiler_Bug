{"sha": "f376443b8f2e8935c33f1edd08586ec7f29a900c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNzY0NDNiOGYyZTg5MzVjMzNmMWVkZDA4NTg2ZWM3ZjI5YTkwMGM=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-03T15:51:57Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-14T09:35:54Z"}, "message": "Move iterator impls to a new module", "tree": {"sha": "2a29f6089ffd0558f0bdd5f9525698c6ce598959", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a29f6089ffd0558f0bdd5f9525698c6ce598959"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f376443b8f2e8935c33f1edd08586ec7f29a900c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f376443b8f2e8935c33f1edd08586ec7f29a900c", "html_url": "https://github.com/rust-lang/rust/commit/f376443b8f2e8935c33f1edd08586ec7f29a900c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f376443b8f2e8935c33f1edd08586ec7f29a900c/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5f55b7e1562286798358730e06b0ba13b4c0ea6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5f55b7e1562286798358730e06b0ba13b4c0ea6", "html_url": "https://github.com/rust-lang/rust/commit/b5f55b7e1562286798358730e06b0ba13b4c0ea6"}], "stats": {"total": 6268, "additions": 3152, "deletions": 3116}, "files": [{"sha": "2e8c3cd43e99998f26b98805264a9c1561a34f79", "filename": "library/core/src/slice/iter.rs", "status": "added", "additions": 2495, "deletions": 0, "changes": 2495, "blob_url": "https://github.com/rust-lang/rust/blob/f376443b8f2e8935c33f1edd08586ec7f29a900c/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f376443b8f2e8935c33f1edd08586ec7f29a900c/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=f376443b8f2e8935c33f1edd08586ec7f29a900c", "patch": "@@ -0,0 +1,2495 @@\n+//! Definitions of a bunch of iterators for `[T]`.\n+\n+#[macro_use] // import iterator! and forward_iterator!\n+mod macros;\n+\n+use crate::cmp;\n+use crate::cmp::Ordering;\n+use crate::fmt;\n+use crate::intrinsics::{assume, exact_div, unchecked_sub};\n+use crate::iter::{FusedIterator, TrustedLen, TrustedRandomAccess};\n+use crate::marker::{self, Send, Sized, Sync};\n+use crate::mem;\n+use crate::ptr::NonNull;\n+\n+use super::{from_raw_parts, from_raw_parts_mut};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> IntoIterator for &'a [T] {\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> IntoIterator for &'a mut [T] {\n+    type Item = &'a mut T;\n+    type IntoIter = IterMut<'a, T>;\n+\n+    fn into_iter(self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n+// Macro helper functions\n+#[inline(always)]\n+fn size_from_ptr<T>(_: *const T) -> usize {\n+    mem::size_of::<T>()\n+}\n+\n+/// Immutable slice iterator\n+///\n+/// This struct is created by the [`iter`] method on [slices].\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // First, we declare a type which has `iter` method to get the `Iter` struct (&[usize here]):\n+/// let slice = &[1, 2, 3];\n+///\n+/// // Then, we iterate over it:\n+/// for element in slice.iter() {\n+///     println!(\"{}\", element);\n+/// }\n+/// ```\n+///\n+/// [`iter`]: ../../std/primitive.slice.html#method.iter\n+/// [slices]: ../../std/primitive.slice.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Iter<'a, T: 'a> {\n+    pub(super) ptr: NonNull<T>,\n+    pub(super) end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    // ptr == end is a quick test for the Iterator being empty, that works\n+    // for both ZST and non-ZST.\n+    pub(super) _marker: marker::PhantomData<&'a T>,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Iter\").field(&self.as_slice()).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync> Sync for Iter<'_, T> {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync> Send for Iter<'_, T> {}\n+\n+impl<'a, T> Iter<'a, T> {\n+    /// Views the underlying data as a subslice of the original data.\n+    ///\n+    /// This has the same lifetime as the original slice, and so the\n+    /// iterator can continue to be used while this exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // First, we declare a type which has the `iter` method to get the `Iter`\n+    /// // struct (&[usize here]):\n+    /// let slice = &[1, 2, 3];\n+    ///\n+    /// // Then, we get the iterator:\n+    /// let mut iter = slice.iter();\n+    /// // So if we print what `as_slice` method returns here, we have \"[1, 2, 3]\":\n+    /// println!(\"{:?}\", iter.as_slice());\n+    ///\n+    /// // Next, we move to the second element of the slice:\n+    /// iter.next();\n+    /// // Now `as_slice` returns \"[2, 3]\":\n+    /// println!(\"{:?}\", iter.as_slice());\n+    /// ```\n+    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n+    pub fn as_slice(&self) -> &'a [T] {\n+        self.make_slice()\n+    }\n+}\n+\n+iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, {\n+    fn is_sorted_by<F>(self, mut compare: F) -> bool\n+    where\n+        Self: Sized,\n+        F: FnMut(&Self::Item, &Self::Item) -> Option<Ordering>,\n+    {\n+        self.as_slice().windows(2).all(|w| {\n+            compare(&&w[0], &&w[1]).map(|o| o != Ordering::Greater).unwrap_or(false)\n+        })\n+    }\n+}}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Clone for Iter<'_, T> {\n+    fn clone(&self) -> Self {\n+        Iter { ptr: self.ptr, end: self.end, _marker: self._marker }\n+    }\n+}\n+\n+#[stable(feature = \"slice_iter_as_ref\", since = \"1.13.0\")]\n+impl<T> AsRef<[T]> for Iter<'_, T> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n+/// Mutable slice iterator.\n+///\n+/// This struct is created by the [`iter_mut`] method on [slices].\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n+/// // struct (&[usize here]):\n+/// let mut slice = &mut [1, 2, 3];\n+///\n+/// // Then, we iterate over it and increment each element value:\n+/// for element in slice.iter_mut() {\n+///     *element += 1;\n+/// }\n+///\n+/// // We now have \"[2, 3, 4]\":\n+/// println!(\"{:?}\", slice);\n+/// ```\n+///\n+/// [`iter_mut`]: ../../std/primitive.slice.html#method.iter_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IterMut<'a, T: 'a> {\n+    pub(super) ptr: NonNull<T>,\n+    pub(super) end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    // ptr == end is a quick test for the Iterator being empty, that works\n+    // for both ZST and non-ZST.\n+    pub(super) _marker: marker::PhantomData<&'a mut T>,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"IterMut\").field(&self.make_slice()).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Send> Send for IterMut<'_, T> {}\n+\n+impl<'a, T> IterMut<'a, T> {\n+    /// Views the underlying data as a subslice of the original data.\n+    ///\n+    /// To avoid creating `&mut` references that alias, this is forced\n+    /// to consume the iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n+    /// // struct (&[usize here]):\n+    /// let mut slice = &mut [1, 2, 3];\n+    ///\n+    /// {\n+    ///     // Then, we get the iterator:\n+    ///     let mut iter = slice.iter_mut();\n+    ///     // We move to next element:\n+    ///     iter.next();\n+    ///     // So if we print what `into_slice` method returns here, we have \"[2, 3]\":\n+    ///     println!(\"{:?}\", iter.into_slice());\n+    /// }\n+    ///\n+    /// // Now let's modify a value of the slice:\n+    /// {\n+    ///     // First we get back the iterator:\n+    ///     let mut iter = slice.iter_mut();\n+    ///     // We change the value of the first element of the slice returned by the `next` method:\n+    ///     *iter.next().unwrap() += 1;\n+    /// }\n+    /// // Now slice is \"[2, 2, 3]\":\n+    /// println!(\"{:?}\", slice);\n+    /// ```\n+    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n+    pub fn into_slice(self) -> &'a mut [T] {\n+        // SAFETY: the iterator was created from a mutable slice with pointer\n+        // `self.ptr` and length `len!(self)`. This guarantees that all the prerequisites\n+        // for `from_raw_parts_mut` are fulfilled.\n+        unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }\n+    }\n+\n+    /// Views the underlying data as a subslice of the original data.\n+    ///\n+    /// To avoid creating `&mut [T]` references that alias, the returned slice\n+    /// borrows its lifetime from the iterator the method is applied on.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// # #![feature(slice_iter_mut_as_slice)]\n+    /// let mut slice: &mut [usize] = &mut [1, 2, 3];\n+    ///\n+    /// // First, we get the iterator:\n+    /// let mut iter = slice.iter_mut();\n+    /// // So if we check what the `as_slice` method returns here, we have \"[1, 2, 3]\":\n+    /// assert_eq!(iter.as_slice(), &[1, 2, 3]);\n+    ///\n+    /// // Next, we move to the second element of the slice:\n+    /// iter.next();\n+    /// // Now `as_slice` returns \"[2, 3]\":\n+    /// assert_eq!(iter.as_slice(), &[2, 3]);\n+    /// ```\n+    #[unstable(feature = \"slice_iter_mut_as_slice\", reason = \"recently added\", issue = \"58957\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        self.make_slice()\n+    }\n+}\n+\n+iterator! {struct IterMut -> *mut T, &'a mut T, mut, {mut}, {}}\n+\n+/// An internal abstraction over the splitting iterators, so that\n+/// splitn, splitn_mut etc can be implemented once.\n+#[doc(hidden)]\n+pub(super) trait SplitIter: DoubleEndedIterator {\n+    /// Marks the underlying iterator as complete, extracting the remaining\n+    /// portion of the slice.\n+    fn finish(&mut self) -> Option<Self::Item>;\n+}\n+\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function.\n+///\n+/// This struct is created by the [`split`] method on [slices].\n+///\n+/// [`split`]: ../../std/primitive.slice.html#method.split\n+/// [slices]: ../../std/primitive.slice.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Split<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    pub(super) v: &'a [T],\n+    pub(super) pred: P,\n+    pub(super) finished: bool,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T: fmt::Debug, P> fmt::Debug for Split<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Split\").field(\"v\", &self.v).field(\"finished\", &self.finished).finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, P> Clone for Split<'_, T, P>\n+where\n+    P: Clone + FnMut(&T) -> bool,\n+{\n+    fn clone(&self) -> Self {\n+        Split { v: self.v, pred: self.pred.clone(), finished: self.finished }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, P> Iterator for Split<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        match self.v.iter().position(|x| (self.pred)(x)) {\n+            None => self.finish(),\n+            Some(idx) => {\n+                let ret = Some(&self.v[..idx]);\n+                self.v = &self.v[idx + 1..];\n+                ret\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished { (0, Some(0)) } else { (1, Some(self.v.len() + 1)) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        match self.v.iter().rposition(|x| (self.pred)(x)) {\n+            None => self.finish(),\n+            Some(idx) => {\n+                let ret = Some(&self.v[idx + 1..]);\n+                self.v = &self.v[..idx];\n+                ret\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T, P> SplitIter for Split<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a [T]> {\n+        if self.finished {\n+            None\n+        } else {\n+            self.finished = true;\n+            Some(self.v)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T, P> FusedIterator for Split<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function. Unlike `Split`, it contains the matched part as a terminator\n+/// of the subslice.\n+///\n+/// This struct is created by the [`split_inclusive`] method on [slices].\n+///\n+/// [`split_inclusive`]: ../../std/primitive.slice.html#method.split_inclusive\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+pub struct SplitInclusive<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    pub(super) v: &'a [T],\n+    pub(super) pred: P,\n+    pub(super) finished: bool,\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitInclusive<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusive\")\n+            .field(\"v\", &self.v)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<T, P> Clone for SplitInclusive<'_, T, P>\n+where\n+    P: Clone + FnMut(&T) -> bool,\n+{\n+    fn clone(&self) -> Self {\n+        SplitInclusive { v: self.v, pred: self.pred.clone(), finished: self.finished }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, T, P> Iterator for SplitInclusive<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let idx =\n+            self.v.iter().position(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(self.v.len());\n+        if idx == self.v.len() {\n+            self.finished = true;\n+        }\n+        let ret = Some(&self.v[..idx]);\n+        self.v = &self.v[idx..];\n+        ret\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished { (0, Some(0)) } else { (1, Some(self.v.len() + 1)) }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, T, P> DoubleEndedIterator for SplitInclusive<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        // The last index of self.v is already checked and found to match\n+        // by the last iteration, so we start searching a new match\n+        // one index to the left.\n+        let remainder = if self.v.is_empty() { &[] } else { &self.v[..(self.v.len() - 1)] };\n+        let idx = remainder.iter().rposition(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(0);\n+        if idx == 0 {\n+            self.finished = true;\n+        }\n+        let ret = Some(&self.v[idx..]);\n+        self.v = &self.v[..idx];\n+        ret\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<T, P> FusedIterator for SplitInclusive<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An iterator over the mutable subslices of the vector which are separated\n+/// by elements that match `pred`.\n+///\n+/// This struct is created by the [`split_mut`] method on [slices].\n+///\n+/// [`split_mut`]: ../../std/primitive.slice.html#method.split_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SplitMut<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    pub(super) v: &'a mut [T],\n+    pub(super) pred: P,\n+    pub(super) finished: bool,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitMut<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitMut\").field(\"v\", &self.v).field(\"finished\", &self.finished).finish()\n+    }\n+}\n+\n+impl<'a, T, P> SplitIter for SplitMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished {\n+            None\n+        } else {\n+            self.finished = true;\n+            Some(mem::replace(&mut self.v, &mut []))\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, P> Iterator for SplitMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let idx_opt = {\n+            // work around borrowck limitations\n+            let pred = &mut self.pred;\n+            self.v.iter().position(|x| (*pred)(x))\n+        };\n+        match idx_opt {\n+            None => self.finish(),\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.split_at_mut(idx);\n+                self.v = &mut tail[1..];\n+                Some(head)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // if the predicate doesn't match anything, we yield one slice\n+            // if it matches every element, we yield len+1 empty slices.\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let idx_opt = {\n+            // work around borrowck limitations\n+            let pred = &mut self.pred;\n+            self.v.iter().rposition(|x| (*pred)(x))\n+        };\n+        match idx_opt {\n+            None => self.finish(),\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.split_at_mut(idx);\n+                self.v = head;\n+                Some(&mut tail[1..])\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T, P> FusedIterator for SplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An iterator over the mutable subslices of the vector which are separated\n+/// by elements that match `pred`. Unlike `SplitMut`, it contains the matched\n+/// parts in the ends of the subslices.\n+///\n+/// This struct is created by the [`split_inclusive_mut`] method on [slices].\n+///\n+/// [`split_inclusive_mut`]: ../../std/primitive.slice.html#method.split_inclusive_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+pub struct SplitInclusiveMut<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    pub(super) v: &'a mut [T],\n+    pub(super) pred: P,\n+    pub(super) finished: bool,\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitInclusiveMut<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusiveMut\")\n+            .field(\"v\", &self.v)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, T, P> Iterator for SplitInclusiveMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let idx_opt = {\n+            // work around borrowck limitations\n+            let pred = &mut self.pred;\n+            self.v.iter().position(|x| (*pred)(x))\n+        };\n+        let idx = idx_opt.map(|idx| idx + 1).unwrap_or(self.v.len());\n+        if idx == self.v.len() {\n+            self.finished = true;\n+        }\n+        let tmp = mem::replace(&mut self.v, &mut []);\n+        let (head, tail) = tmp.split_at_mut(idx);\n+        self.v = tail;\n+        Some(head)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // if the predicate doesn't match anything, we yield one slice\n+            // if it matches every element, we yield len+1 empty slices.\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, T, P> DoubleEndedIterator for SplitInclusiveMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let idx_opt = if self.v.is_empty() {\n+            None\n+        } else {\n+            // work around borrowck limitations\n+            let pred = &mut self.pred;\n+\n+            // The last index of self.v is already checked and found to match\n+            // by the last iteration, so we start searching a new match\n+            // one index to the left.\n+            let remainder = &self.v[..(self.v.len() - 1)];\n+            remainder.iter().rposition(|x| (*pred)(x))\n+        };\n+        let idx = idx_opt.map(|idx| idx + 1).unwrap_or(0);\n+        if idx == 0 {\n+            self.finished = true;\n+        }\n+        let tmp = mem::replace(&mut self.v, &mut []);\n+        let (head, tail) = tmp.split_at_mut(idx);\n+        self.v = head;\n+        Some(tail)\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<T, P> FusedIterator for SplitInclusiveMut<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, starting from the end of the slice.\n+///\n+/// This struct is created by the [`rsplit`] method on [slices].\n+///\n+/// [`rsplit`]: ../../std/primitive.slice.html#method.rsplit\n+/// [slices]: ../../std/primitive.slice.html\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+#[derive(Clone)] // Is this correct, or does it incorrectly require `T: Clone`?\n+pub struct RSplit<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    pub(super) inner: Split<'a, T, P>,\n+}\n+\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+impl<T: fmt::Debug, P> fmt::Debug for RSplit<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"RSplit\")\n+            .field(\"v\", &self.inner.v)\n+            .field(\"finished\", &self.inner.finished)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+impl<'a, T, P> Iterator for RSplit<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        self.inner.next_back()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+impl<'a, T, P> DoubleEndedIterator for RSplit<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        self.inner.next()\n+    }\n+}\n+\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+impl<'a, T, P> SplitIter for RSplit<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a [T]> {\n+        self.inner.finish()\n+    }\n+}\n+\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+impl<T, P> FusedIterator for RSplit<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An iterator over the subslices of the vector which are separated\n+/// by elements that match `pred`, starting from the end of the slice.\n+///\n+/// This struct is created by the [`rsplit_mut`] method on [slices].\n+///\n+/// [`rsplit_mut`]: ../../std/primitive.slice.html#method.rsplit_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+pub struct RSplitMut<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    pub(super) inner: SplitMut<'a, T, P>,\n+}\n+\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+impl<T: fmt::Debug, P> fmt::Debug for RSplitMut<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"RSplitMut\")\n+            .field(\"v\", &self.inner.v)\n+            .field(\"finished\", &self.inner.finished)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+impl<'a, T, P> SplitIter for RSplitMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.finish()\n+    }\n+}\n+\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+impl<'a, T, P> Iterator for RSplitMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.next_back()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+impl<'a, T, P> DoubleEndedIterator for RSplitMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.next()\n+    }\n+}\n+\n+#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+impl<T, P> FusedIterator for RSplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An private iterator over subslices separated by elements that\n+/// match a predicate function, splitting at most a fixed number of\n+/// times.\n+#[derive(Debug)]\n+pub(super) struct GenericSplitN<I> {\n+    pub(super) iter: I,\n+    pub(super) count: usize,\n+}\n+\n+impl<T, I: SplitIter<Item = T>> Iterator for GenericSplitN<I> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        match self.count {\n+            0 => None,\n+            1 => {\n+                self.count -= 1;\n+                self.iter.finish()\n+            }\n+            _ => {\n+                self.count -= 1;\n+                self.iter.next()\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper_opt) = self.iter.size_hint();\n+        (lower, upper_opt.map(|upper| cmp::min(self.count, upper)))\n+    }\n+}\n+\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, limited to a given number of splits.\n+///\n+/// This struct is created by the [`splitn`] method on [slices].\n+///\n+/// [`splitn`]: ../../std/primitive.slice.html#method.splitn\n+/// [slices]: ../../std/primitive.slice.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SplitN<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    pub(super) inner: GenericSplitN<Split<'a, T, P>>,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitN<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitN\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+/// An iterator over subslices separated by elements that match a\n+/// predicate function, limited to a given number of splits, starting\n+/// from the end of the slice.\n+///\n+/// This struct is created by the [`rsplitn`] method on [slices].\n+///\n+/// [`rsplitn`]: ../../std/primitive.slice.html#method.rsplitn\n+/// [slices]: ../../std/primitive.slice.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RSplitN<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    pub(super) inner: GenericSplitN<RSplit<'a, T, P>>,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T: fmt::Debug, P> fmt::Debug for RSplitN<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"RSplitN\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, limited to a given number of splits.\n+///\n+/// This struct is created by the [`splitn_mut`] method on [slices].\n+///\n+/// [`splitn_mut`]: ../../std/primitive.slice.html#method.splitn_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SplitNMut<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    pub(super) inner: GenericSplitN<SplitMut<'a, T, P>>,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitNMut<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitNMut\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+/// An iterator over subslices separated by elements that match a\n+/// predicate function, limited to a given number of splits, starting\n+/// from the end of the slice.\n+///\n+/// This struct is created by the [`rsplitn_mut`] method on [slices].\n+///\n+/// [`rsplitn_mut`]: ../../std/primitive.slice.html#method.rsplitn_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RSplitNMut<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    pub(super) inner: GenericSplitN<RSplitMut<'a, T, P>>,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T: fmt::Debug, P> fmt::Debug for RSplitNMut<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"RSplitNMut\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+forward_iterator! { SplitN: T, &'a [T] }\n+forward_iterator! { RSplitN: T, &'a [T] }\n+forward_iterator! { SplitNMut: T, &'a mut [T] }\n+forward_iterator! { RSplitNMut: T, &'a mut [T] }\n+\n+/// An iterator over overlapping subslices of length `size`.\n+///\n+/// This struct is created by the [`windows`] method on [slices].\n+///\n+/// [`windows`]: ../../std/primitive.slice.html#method.windows\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Windows<'a, T: 'a> {\n+    pub(super) v: &'a [T],\n+    pub(super) size: usize,\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Clone for Windows<'_, T> {\n+    fn clone(&self) -> Self {\n+        Windows { v: self.v, size: self.size }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> Iterator for Windows<'a, T> {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.size > self.v.len() {\n+            None\n+        } else {\n+            let ret = Some(&self.v[..self.size]);\n+            self.v = &self.v[1..];\n+            ret\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.size > self.v.len() {\n+            (0, Some(0))\n+        } else {\n+            let size = self.v.len() - self.size + 1;\n+            (size, Some(size))\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (end, overflow) = self.size.overflowing_add(n);\n+        if end > self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let nth = &self.v[n..end];\n+            self.v = &self.v[n + 1..];\n+            Some(nth)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.size > self.v.len() {\n+            None\n+        } else {\n+            let start = self.v.len() - self.size;\n+            Some(&self.v[start..])\n+        }\n+    }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        // SAFETY: since the caller guarantees that `i` is in bounds,\n+        // which means that `i` cannot overflow an `isize`, and the\n+        // slice created by `from_raw_parts` is a subslice of `self.v`\n+        // thus is guaranteed to be valid for the lifetime `'a` of `self.v`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(idx), self.size) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.size > self.v.len() {\n+            None\n+        } else {\n+            let ret = Some(&self.v[self.v.len() - self.size..]);\n+            self.v = &self.v[..self.v.len() - 1];\n+            ret\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let (end, overflow) = self.v.len().overflowing_sub(n);\n+        if end < self.size || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let ret = &self.v[end - self.size..end];\n+            self.v = &self.v[..end - 1];\n+            Some(ret)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ExactSizeIterator for Windows<'_, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for Windows<'_, T> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Windows<'_, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<'a, T> TrustedRandomAccess for Windows<'a, T> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n+/// time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last slice\n+/// of the iteration will be the remainder.\n+///\n+/// This struct is created by the [`chunks`] method on [slices].\n+///\n+/// [`chunks`]: ../../std/primitive.slice.html#method.chunks\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Chunks<'a, T: 'a> {\n+    pub(super) v: &'a [T],\n+    pub(super) chunk_size: usize,\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Clone for Chunks<'_, T> {\n+    fn clone(&self) -> Self {\n+        Chunks { v: self.v, chunk_size: self.chunk_size }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> Iterator for Chunks<'a, T> {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n+            let (fst, snd) = self.v.split_at(chunksz);\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.v.is_empty() {\n+            (0, Some(0))\n+        } else {\n+            let n = self.v.len() / self.chunk_size;\n+            let rem = self.v.len() % self.chunk_size;\n+            let n = if rem > 0 { n + 1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let end = match start.checked_add(self.chunk_size) {\n+                Some(sum) => cmp::min(self.v.len(), sum),\n+                None => self.v.len(),\n+            };\n+            let nth = &self.v[start..end];\n+            self.v = &self.v[end..];\n+            Some(nth)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n+            Some(&self.v[start..])\n+        }\n+    }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let start = idx * self.chunk_size;\n+        let end = match start.checked_add(self.chunk_size) {\n+            None => self.v.len(),\n+            Some(end) => cmp::min(end, self.v.len()),\n+        };\n+        // SAFETY: the caller guarantees that `i` is in bounds,\n+        // which means that `start` must be in bounds of the\n+        // underlying `self.v` slice, and we made sure that `end`\n+        // is also in bounds of `self.v`. Thus, `start` cannot overflow\n+        // an `isize`, and the slice constructed by `from_raw_parts`\n+        // is a subslice of `self.v` which is guaranteed to be valid\n+        // for the lifetime `'a` of `self.v`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.chunk_size;\n+            let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n+            let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * self.chunk_size;\n+            let end = match start.checked_add(self.chunk_size) {\n+                Some(res) => cmp::min(res, self.v.len()),\n+                None => self.v.len(),\n+            };\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[..start];\n+            Some(nth_back)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ExactSizeIterator for Chunks<'_, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for Chunks<'_, T> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Chunks<'_, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<'a, T> TrustedRandomAccess for Chunks<'a, T> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n+/// elements at a time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last slice\n+/// of the iteration will be the remainder.\n+///\n+/// This struct is created by the [`chunks_mut`] method on [slices].\n+///\n+/// [`chunks_mut`]: ../../std/primitive.slice.html#method.chunks_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ChunksMut<'a, T: 'a> {\n+    pub(super) v: &'a mut [T],\n+    pub(super) chunk_size: usize,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> Iterator for ChunksMut<'a, T> {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let sz = cmp::min(self.v.len(), self.chunk_size);\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(sz);\n+            self.v = tail;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.v.is_empty() {\n+            (0, Some(0))\n+        } else {\n+            let n = self.v.len() / self.chunk_size;\n+            let rem = self.v.len() % self.chunk_size;\n+            let n = if rem > 0 { n + 1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let end = match start.checked_add(self.chunk_size) {\n+                Some(sum) => cmp::min(self.v.len(), sum),\n+                None => self.v.len(),\n+            };\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(end);\n+            let (_, nth) = head.split_at_mut(start);\n+            self.v = tail;\n+            Some(nth)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n+            Some(&mut self.v[start..])\n+        }\n+    }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let start = idx * self.chunk_size;\n+        let end = match start.checked_add(self.chunk_size) {\n+            None => self.v.len(),\n+            Some(end) => cmp::min(end, self.v.len()),\n+        };\n+        // SAFETY: see comments for `Chunks::get_unchecked`.\n+        //\n+        // Also note that the caller also guarantees that we're never called\n+        // with the same index again, and that no other methods that will\n+        // access this subslice are called, so it is valid for the returned\n+        // slice to be mutable.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.chunk_size;\n+            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n+            self.v = head;\n+            Some(tail)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * self.chunk_size;\n+            let end = match start.checked_add(self.chunk_size) {\n+                Some(res) => cmp::min(res, self.v.len()),\n+                None => self.v.len(),\n+            };\n+            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (head, nth_back) = temp.split_at_mut(start);\n+            self.v = head;\n+            Some(nth_back)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ExactSizeIterator for ChunksMut<'_, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for ChunksMut<'_, T> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for ChunksMut<'_, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n+/// time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n+/// the [`remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`chunks_exact`] method on [slices].\n+///\n+/// [`chunks_exact`]: ../../std/primitive.slice.html#method.chunks_exact\n+/// [`remainder`]: ChunksExact::remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+pub struct ChunksExact<'a, T: 'a> {\n+    pub(super) v: &'a [T],\n+    pub(super) rem: &'a [T],\n+    pub(super) chunk_size: usize,\n+}\n+\n+impl<'a, T> ChunksExact<'a, T> {\n+    /// Returns the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+    pub fn remainder(&self) -> &'a [T] {\n+        self.rem\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+impl<T> Clone for ChunksExact<'_, T> {\n+    fn clone(&self) -> Self {\n+        ChunksExact { v: self.v, rem: self.rem, chunk_size: self.chunk_size }\n+    }\n+}\n+\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+impl<'a, T> Iterator for ChunksExact<'a, T> {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.chunk_size);\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let (_, snd) = self.v.split_at(start);\n+            self.v = snd;\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let start = idx * self.chunk_size;\n+        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n+    }\n+}\n+\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+impl<'a, T> DoubleEndedIterator for ChunksExact<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * self.chunk_size;\n+            let end = start + self.chunk_size;\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[..start];\n+            Some(nth_back)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+impl<T> ExactSizeIterator for ChunksExact<'_, T> {\n+    fn is_empty(&self) -> bool {\n+        self.v.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for ChunksExact<'_, T> {}\n+\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+impl<T> FusedIterator for ChunksExact<'_, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n+/// elements at a time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last up to\n+/// `chunk_size-1` elements will be omitted but can be retrieved from the\n+/// [`into_remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`chunks_exact_mut`] method on [slices].\n+///\n+/// [`chunks_exact_mut`]: ../../std/primitive.slice.html#method.chunks_exact_mut\n+/// [`into_remainder`]: ChunksExactMut::into_remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+pub struct ChunksExactMut<'a, T: 'a> {\n+    pub(super) v: &'a mut [T],\n+    pub(super) rem: &'a mut [T],\n+    pub(super) chunk_size: usize,\n+}\n+\n+impl<'a, T> ChunksExactMut<'a, T> {\n+    /// Returns the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+    pub fn into_remainder(self) -> &'a mut [T] {\n+        self.rem\n+    }\n+}\n+\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            self.v = tail;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (_, snd) = tmp.split_at_mut(start);\n+            self.v = snd;\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let start = idx * self.chunk_size;\n+        // SAFETY: see comments for `ChunksMut::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n+    }\n+}\n+\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            self.v = head;\n+            Some(tail)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * self.chunk_size;\n+            let end = start + self.chunk_size;\n+            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (head, nth_back) = temp.split_at_mut(start);\n+            self.v = head;\n+            Some(nth_back)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+impl<T> ExactSizeIterator for ChunksExactMut<'_, T> {\n+    fn is_empty(&self) -> bool {\n+        self.v.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for ChunksExactMut<'_, T> {}\n+\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+impl<T> FusedIterator for ChunksExactMut<'_, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) chunks (`N` elements at a\n+/// time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `N-1` elements will be omitted but can be retrieved from\n+/// the [`remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`array_chunks`] method on [slices].\n+///\n+/// [`array_chunks`]: ../../std/primitive.slice.html#method.array_chunks\n+/// [`remainder`]: ArrayChunks::remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+pub struct ArrayChunks<'a, T: 'a, const N: usize> {\n+    pub(super) iter: Iter<'a, [T; N]>,\n+    pub(super) rem: &'a [T],\n+}\n+\n+impl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n+    /// Returns the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `N-1`\n+    /// elements.\n+    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+    pub fn remainder(&self) -> &'a [T] {\n+        self.rem\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> Clone for ArrayChunks<'_, T, N> {\n+    fn clone(&self) -> Self {\n+        ArrayChunks { iter: self.iter.clone(), rem: self.rem }\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> Iterator for ArrayChunks<'a, T, N> {\n+    type Item = &'a [T; N];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T; N]> {\n+        self.iter.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth(n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        self.iter.last()\n+    }\n+\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T; N] {\n+        // SAFETY: The safety guarantees of `get_unchecked` are transferred to\n+        // the caller.\n+        unsafe { self.iter.get_unchecked(i) }\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> DoubleEndedIterator for ArrayChunks<'a, T, N> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T; N]> {\n+        self.iter.next_back()\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth_back(n)\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> ExactSizeIterator for ArrayChunks<'_, T, N> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, const N: usize> TrustedLen for ArrayChunks<'_, T, N> {}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> FusedIterator for ArrayChunks<'_, T, N> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`N` elements\n+/// at a time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `N-1` elements will be omitted but can be retrieved from\n+/// the [`into_remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`array_chunks_mut`] method on [slices].\n+///\n+/// [`array_chunks_mut`]: ../../std/primitive.slice.html#method.array_chunks_mut\n+/// [`into_remainder`]: ../../std/slice/struct.ArrayChunksMut.html#method.into_remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+pub struct ArrayChunksMut<'a, T: 'a, const N: usize> {\n+    pub(super) iter: IterMut<'a, [T; N]>,\n+    pub(super) rem: &'a mut [T],\n+}\n+\n+impl<'a, T, const N: usize> ArrayChunksMut<'a, T, N> {\n+    /// Returns the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `N-1`\n+    /// elements.\n+    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+    pub fn into_remainder(self) -> &'a mut [T] {\n+        self.rem\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> Iterator for ArrayChunksMut<'a, T, N> {\n+    type Item = &'a mut [T; N];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T; N]> {\n+        self.iter.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth(n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        self.iter.last()\n+    }\n+\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T; N] {\n+        // SAFETY: The safety guarantees of `get_unchecked` are transferred to\n+        // the caller.\n+        unsafe { self.iter.get_unchecked(i) }\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> DoubleEndedIterator for ArrayChunksMut<'a, T, N> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T; N]> {\n+        self.iter.next_back()\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth_back(n)\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> ExactSizeIterator for ArrayChunksMut<'_, T, N> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, const N: usize> TrustedLen for ArrayChunksMut<'_, T, N> {}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> FusedIterator for ArrayChunksMut<'_, T, N> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunksMut<'a, T, N> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n+/// time), starting at the end of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last slice\n+/// of the iteration will be the remainder.\n+///\n+/// This struct is created by the [`rchunks`] method on [slices].\n+///\n+/// [`rchunks`]: ../../std/primitive.slice.html#method.rchunks\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+pub struct RChunks<'a, T: 'a> {\n+    pub(super) v: &'a [T],\n+    pub(super) chunk_size: usize,\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<T> Clone for RChunks<'_, T> {\n+    fn clone(&self) -> Self {\n+        RChunks { v: self.v, chunk_size: self.chunk_size }\n+    }\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<'a, T> Iterator for RChunks<'a, T> {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n+            let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.v.is_empty() {\n+            (0, Some(0))\n+        } else {\n+            let n = self.v.len() / self.chunk_size;\n+            let rem = self.v.len() % self.chunk_size;\n+            let n = if rem > 0 { n + 1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n+        if end >= self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            // Can't underflow because of the check above\n+            let end = self.v.len() - end;\n+            let start = match end.checked_sub(self.chunk_size) {\n+                Some(sum) => sum,\n+                None => 0,\n+            };\n+            let nth = &self.v[start..end];\n+            self.v = &self.v[0..start];\n+            Some(nth)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let rem = self.v.len() % self.chunk_size;\n+            let end = if rem == 0 { self.chunk_size } else { rem };\n+            Some(&self.v[0..end])\n+        }\n+    }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let end = self.v.len() - idx * self.chunk_size;\n+        let start = match end.checked_sub(self.chunk_size) {\n+            None => 0,\n+            Some(start) => start,\n+        };\n+        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n+    }\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<'a, T> DoubleEndedIterator for RChunks<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.chunk_size;\n+            let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n+            let (fst, snd) = self.v.split_at(chunksz);\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            // can't underflow because `n < len`\n+            let offset_from_end = (len - 1 - n) * self.chunk_size;\n+            let end = self.v.len() - offset_from_end;\n+            let start = end.saturating_sub(self.chunk_size);\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[end..];\n+            Some(nth_back)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<T> ExactSizeIterator for RChunks<'_, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for RChunks<'_, T> {}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<T> FusedIterator for RChunks<'_, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<'a, T> TrustedRandomAccess for RChunks<'a, T> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n+/// elements at a time), starting at the end of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last slice\n+/// of the iteration will be the remainder.\n+///\n+/// This struct is created by the [`rchunks_mut`] method on [slices].\n+///\n+/// [`rchunks_mut`]: ../../std/primitive.slice.html#method.rchunks_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+pub struct RChunksMut<'a, T: 'a> {\n+    pub(super) v: &'a mut [T],\n+    pub(super) chunk_size: usize,\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<'a, T> Iterator for RChunksMut<'a, T> {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let sz = cmp::min(self.v.len(), self.chunk_size);\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n+            self.v = head;\n+            Some(tail)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.v.is_empty() {\n+            (0, Some(0))\n+        } else {\n+            let n = self.v.len() / self.chunk_size;\n+            let rem = self.v.len() % self.chunk_size;\n+            let n = if rem > 0 { n + 1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n+        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n+        if end >= self.v.len() || overflow {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            // Can't underflow because of the check above\n+            let end = self.v.len() - end;\n+            let start = match end.checked_sub(self.chunk_size) {\n+                Some(sum) => sum,\n+                None => 0,\n+            };\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(start);\n+            let (nth, _) = tail.split_at_mut(end - start);\n+            self.v = head;\n+            Some(nth)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let rem = self.v.len() % self.chunk_size;\n+            let end = if rem == 0 { self.chunk_size } else { rem };\n+            Some(&mut self.v[0..end])\n+        }\n+    }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let end = self.v.len() - idx * self.chunk_size;\n+        let start = match end.checked_sub(self.chunk_size) {\n+            None => 0,\n+            Some(start) => start,\n+        };\n+        // SAFETY: see comments for `RChunks::get_unchecked` and `ChunksMut::get_unchecked`\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n+    }\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.chunk_size;\n+            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(sz);\n+            self.v = tail;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            // can't underflow because `n < len`\n+            let offset_from_end = (len - 1 - n) * self.chunk_size;\n+            let end = self.v.len() - offset_from_end;\n+            let start = end.saturating_sub(self.chunk_size);\n+            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (_, nth_back) = tmp.split_at_mut(start);\n+            self.v = tail;\n+            Some(nth_back)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<T> ExactSizeIterator for RChunksMut<'_, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for RChunksMut<'_, T> {}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<T> FusedIterator for RChunksMut<'_, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<'a, T> TrustedRandomAccess for RChunksMut<'a, T> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n+/// time), starting at the end of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n+/// the [`remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`rchunks_exact`] method on [slices].\n+///\n+/// [`rchunks_exact`]: ../../std/primitive.slice.html#method.rchunks_exact\n+/// [`remainder`]: ChunksExact::remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+pub struct RChunksExact<'a, T: 'a> {\n+    pub(super) v: &'a [T],\n+    pub(super) rem: &'a [T],\n+    pub(super) chunk_size: usize,\n+}\n+\n+impl<'a, T> RChunksExact<'a, T> {\n+    /// Returns the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+    pub fn remainder(&self) -> &'a [T] {\n+        self.rem\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<'a, T> Clone for RChunksExact<'a, T> {\n+    fn clone(&self) -> RChunksExact<'a, T> {\n+        RChunksExact { v: self.v, rem: self.rem, chunk_size: self.chunk_size }\n+    }\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<'a, T> Iterator for RChunksExact<'a, T> {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n+        if end >= self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let (fst, _) = self.v.split_at(self.v.len() - end);\n+            self.v = fst;\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let end = self.v.len() - idx * self.chunk_size;\n+        let start = end - self.chunk_size;\n+        // SAFETY:\n+        // SAFETY: mostmy identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n+    }\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<'a, T> DoubleEndedIterator for RChunksExact<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.chunk_size);\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            // now that we know that `n` corresponds to a chunk,\n+            // none of these operations can underflow/overflow\n+            let offset = (len - n) * self.chunk_size;\n+            let start = self.v.len() - offset;\n+            let end = start + self.chunk_size;\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[end..];\n+            Some(nth_back)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<'a, T> ExactSizeIterator for RChunksExact<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.v.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for RChunksExact<'_, T> {}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<T> FusedIterator for RChunksExact<'_, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<'a, T> TrustedRandomAccess for RChunksExact<'a, T> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n+/// elements at a time), starting at the end of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last up to\n+/// `chunk_size-1` elements will be omitted but can be retrieved from the\n+/// [`into_remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`rchunks_exact_mut`] method on [slices].\n+///\n+/// [`rchunks_exact_mut`]: ../../std/primitive.slice.html#method.rchunks_exact_mut\n+/// [`into_remainder`]: ChunksExactMut::into_remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+pub struct RChunksExactMut<'a, T: 'a> {\n+    pub(super) v: &'a mut [T],\n+    pub(super) rem: &'a mut [T],\n+    pub(super) chunk_size: usize,\n+}\n+\n+impl<'a, T> RChunksExactMut<'a, T> {\n+    /// Returns the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+    pub fn into_remainder(self) -> &'a mut [T] {\n+        self.rem\n+    }\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            self.v = head;\n+            Some(tail)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n+        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n+        if end >= self.v.len() || overflow {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (fst, _) = tmp.split_at_mut(tmp_len - end);\n+            self.v = fst;\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+\n+    #[doc(hidden)]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+        let end = self.v.len() - idx * self.chunk_size;\n+        let start = end - self.chunk_size;\n+        // SAFETY: see comments for `RChunksMut::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n+    }\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            self.v = tail;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            // now that we know that `n` corresponds to a chunk,\n+            // none of these operations can underflow/overflow\n+            let offset = (len - n) * self.chunk_size;\n+            let start = self.v.len() - offset;\n+            let end = start + self.chunk_size;\n+            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (_, nth_back) = tmp.split_at_mut(start);\n+            self.v = tail;\n+            Some(nth_back)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<T> ExactSizeIterator for RChunksExactMut<'_, T> {\n+    fn is_empty(&self) -> bool {\n+        self.v.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for RChunksExactMut<'_, T> {}\n+\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+impl<T> FusedIterator for RChunksExactMut<'_, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}"}, {"sha": "9fcc7a71af8ad262814bc7e4a869f6bdaf20faea", "filename": "library/core/src/slice/iter/macros.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/f376443b8f2e8935c33f1edd08586ec7f29a900c/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f376443b8f2e8935c33f1edd08586ec7f29a900c/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=f376443b8f2e8935c33f1edd08586ec7f29a900c", "patch": "@@ -0,0 +1,407 @@\n+//! Macros used by iterators of slice.\n+\n+// Inlining is_empty and len makes a huge performance difference\n+macro_rules! is_empty {\n+    // The way we encode the length of a ZST iterator, this works both for ZST\n+    // and non-ZST.\n+    ($self: ident) => {\n+        $self.ptr.as_ptr() as *const T == $self.end\n+    };\n+}\n+\n+// To get rid of some bounds checks (see `position`), we compute the length in a somewhat\n+// unexpected way. (Tested by `codegen/slice-position-bounds-check`.)\n+macro_rules! len {\n+    ($self: ident) => {{\n+        #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n+\n+        let start = $self.ptr;\n+        let size = size_from_ptr(start.as_ptr());\n+        if size == 0 {\n+            // This _cannot_ use `unchecked_sub` because we depend on wrapping\n+            // to represent the length of long ZST slice iterators.\n+            ($self.end as usize).wrapping_sub(start.as_ptr() as usize)\n+        } else {\n+            // We know that `start <= end`, so can do better than `offset_from`,\n+            // which needs to deal in signed.  By setting appropriate flags here\n+            // we can tell LLVM this, which helps it remove bounds checks.\n+            // SAFETY: By the type invariant, `start <= end`\n+            let diff = unsafe { unchecked_sub($self.end as usize, start.as_ptr() as usize) };\n+            // By also telling LLVM that the pointers are apart by an exact\n+            // multiple of the type size, it can optimize `len() == 0` down to\n+            // `start == end` instead of `(end - start) < size`.\n+            // SAFETY: By the type invariant, the pointers are aligned so the\n+            //         distance between them must be a multiple of pointee size\n+            unsafe { exact_div(diff, size) }\n+        }\n+    }};\n+}\n+\n+// The shared definition of the `Iter` and `IterMut` iterators\n+macro_rules! iterator {\n+    (\n+        struct $name:ident -> $ptr:ty,\n+        $elem:ty,\n+        $raw_mut:tt,\n+        {$( $mut_:tt )?},\n+        {$($extra:tt)*}\n+    ) => {\n+        // Returns the first element and moves the start of the iterator forwards by 1.\n+        // Greatly improves performance compared to an inlined function. The iterator\n+        // must not be empty.\n+        macro_rules! next_unchecked {\n+            ($self: ident) => {& $( $mut_ )? *$self.post_inc_start(1)}\n+        }\n+\n+        // Returns the last element and moves the end of the iterator backwards by 1.\n+        // Greatly improves performance compared to an inlined function. The iterator\n+        // must not be empty.\n+        macro_rules! next_back_unchecked {\n+            ($self: ident) => {& $( $mut_ )? *$self.pre_dec_end(1)}\n+        }\n+\n+        // Shrinks the iterator when T is a ZST, by moving the end of the iterator\n+        // backwards by `n`. `n` must not exceed `self.len()`.\n+        macro_rules! zst_shrink {\n+            ($self: ident, $n: ident) => {\n+                $self.end = ($self.end as * $raw_mut u8).wrapping_offset(-$n) as * $raw_mut T;\n+            }\n+        }\n+\n+        impl<'a, T> $name<'a, T> {\n+            // Helper function for creating a slice from the iterator.\n+            #[inline(always)]\n+            fn make_slice(&self) -> &'a [T] {\n+                // SAFETY: the iterator was created from a slice with pointer\n+                // `self.ptr` and length `len!(self)`. This guarantees that all\n+                // the prerequisites for `from_raw_parts` are fulfilled.\n+                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n+            }\n+\n+            // Helper function for moving the start of the iterator forwards by `offset` elements,\n+            // returning the old start.\n+            // Unsafe because the offset must not exceed `self.len()`.\n+            #[inline(always)]\n+            unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n+                if mem::size_of::<T>() == 0 {\n+                    zst_shrink!(self, offset);\n+                    self.ptr.as_ptr()\n+                } else {\n+                    let old = self.ptr.as_ptr();\n+                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n+                    // so this new pointer is inside `self` and thus guaranteed to be non-null.\n+                    self.ptr = unsafe { NonNull::new_unchecked(self.ptr.as_ptr().offset(offset)) };\n+                    old\n+                }\n+            }\n+\n+            // Helper function for moving the end of the iterator backwards by `offset` elements,\n+            // returning the new end.\n+            // Unsafe because the offset must not exceed `self.len()`.\n+            #[inline(always)]\n+            unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n+                if mem::size_of::<T>() == 0 {\n+                    zst_shrink!(self, offset);\n+                    self.ptr.as_ptr()\n+                } else {\n+                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n+                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n+                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n+                    self.end = unsafe { self.end.offset(-offset) };\n+                    self.end\n+                }\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<T> ExactSizeIterator for $name<'_, T> {\n+            #[inline(always)]\n+            fn len(&self) -> usize {\n+                len!(self)\n+            }\n+\n+            #[inline(always)]\n+            fn is_empty(&self) -> bool {\n+                is_empty!(self)\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, T> Iterator for $name<'a, T> {\n+            type Item = $elem;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n+\n+                // SAFETY: `assume` calls are safe since a slice's start pointer\n+                // must be non-null, and slices over non-ZSTs must also have a\n+                // non-null end pointer. The call to `next_unchecked!` is safe\n+                // since we check if the iterator is empty first.\n+                unsafe {\n+                    assume(!self.ptr.as_ptr().is_null());\n+                    if mem::size_of::<T>() != 0 {\n+                        assume(!self.end.is_null());\n+                    }\n+                    if is_empty!(self) {\n+                        None\n+                    } else {\n+                        Some(next_unchecked!(self))\n+                    }\n+                }\n+            }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                let exact = len!(self);\n+                (exact, Some(exact))\n+            }\n+\n+            #[inline]\n+            fn count(self) -> usize {\n+                len!(self)\n+            }\n+\n+            #[inline]\n+            fn nth(&mut self, n: usize) -> Option<$elem> {\n+                if n >= len!(self) {\n+                    // This iterator is now empty.\n+                    if mem::size_of::<T>() == 0 {\n+                        // We have to do it this way as `ptr` may never be 0, but `end`\n+                        // could be (due to wrapping).\n+                        self.end = self.ptr.as_ptr();\n+                    } else {\n+                        // SAFETY: end can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n+                        unsafe {\n+                            self.ptr = NonNull::new_unchecked(self.end as *mut T);\n+                        }\n+                    }\n+                    return None;\n+                }\n+                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n+                unsafe {\n+                    self.post_inc_start(n as isize);\n+                    Some(next_unchecked!(self))\n+                }\n+            }\n+\n+            #[inline]\n+            fn last(mut self) -> Option<$elem> {\n+                self.next_back()\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn for_each<F>(mut self, mut f: F)\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item),\n+            {\n+                while let Some(x) = self.next() {\n+                    f(x);\n+                }\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn all<F>(&mut self, mut f: F) -> bool\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item) -> bool,\n+            {\n+                while let Some(x) = self.next() {\n+                    if !f(x) {\n+                        return false;\n+                    }\n+                }\n+                true\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn any<F>(&mut self, mut f: F) -> bool\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item) -> bool,\n+            {\n+                while let Some(x) = self.next() {\n+                    if f(x) {\n+                        return true;\n+                    }\n+                }\n+                false\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+            where\n+                Self: Sized,\n+                P: FnMut(&Self::Item) -> bool,\n+            {\n+                while let Some(x) = self.next() {\n+                    if predicate(&x) {\n+                        return Some(x);\n+                    }\n+                }\n+                None\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item) -> Option<B>,\n+            {\n+                while let Some(x) = self.next() {\n+                    if let Some(y) = f(x) {\n+                        return Some(y);\n+                    }\n+                }\n+                None\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile. Also, the `assume` avoids a bounds check.\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n+                Self: Sized,\n+                P: FnMut(Self::Item) -> bool,\n+            {\n+                let n = len!(self);\n+                let mut i = 0;\n+                while let Some(x) = self.next() {\n+                    if predicate(x) {\n+                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n+                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n+                        unsafe { assume(i < n) };\n+                        return Some(i);\n+                    }\n+                    i += 1;\n+                }\n+                None\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile. Also, the `assume` avoids a bounds check.\n+            #[inline]\n+            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n+                P: FnMut(Self::Item) -> bool,\n+                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n+            {\n+                let n = len!(self);\n+                let mut i = n;\n+                while let Some(x) = self.next_back() {\n+                    i -= 1;\n+                    if predicate(x) {\n+                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n+                        // and is only decreasing.\n+                        unsafe { assume(i < n) };\n+                        return Some(i);\n+                    }\n+                }\n+                None\n+            }\n+\n+            #[doc(hidden)]\n+            unsafe fn get_unchecked(&mut self, idx: usize) -> Self::Item {\n+                // SAFETY: the caller must guarantee that `i` is in bounds of\n+                // the underlying slice, so `i` cannot overflow an `isize`, and\n+                // the returned references is guaranteed to refer to an element\n+                // of the slice and thus guaranteed to be valid.\n+                //\n+                // Also note that the caller also guarantees that we're never\n+                // called with the same index again, and that no other methods\n+                // that will access this subslice are called, so it is valid\n+                // for the returned reference to be mutable in the case of\n+                // `IterMut`\n+                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n+            }\n+\n+            $($extra)*\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n+\n+                // SAFETY: `assume` calls are safe since a slice's start pointer must be non-null,\n+                // and slices over non-ZSTs must also have a non-null end pointer.\n+                // The call to `next_back_unchecked!` is safe since we check if the iterator is\n+                // empty first.\n+                unsafe {\n+                    assume(!self.ptr.as_ptr().is_null());\n+                    if mem::size_of::<T>() != 0 {\n+                        assume(!self.end.is_null());\n+                    }\n+                    if is_empty!(self) {\n+                        None\n+                    } else {\n+                        Some(next_back_unchecked!(self))\n+                    }\n+                }\n+            }\n+\n+            #[inline]\n+            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n+                if n >= len!(self) {\n+                    // This iterator is now empty.\n+                    self.end = self.ptr.as_ptr();\n+                    return None;\n+                }\n+                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n+                unsafe {\n+                    self.pre_dec_end(n as isize);\n+                    Some(next_back_unchecked!(self))\n+                }\n+            }\n+        }\n+\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n+        impl<T> FusedIterator for $name<'_, T> {}\n+\n+        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+        unsafe impl<T> TrustedLen for $name<'_, T> {}\n+    }\n+}\n+\n+macro_rules! forward_iterator {\n+    ($name:ident: $elem:ident, $iter_of:ty) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, $elem, P> Iterator for $name<'a, $elem, P>\n+        where\n+            P: FnMut(&T) -> bool,\n+        {\n+            type Item = $iter_of;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$iter_of> {\n+                self.inner.next()\n+            }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                self.inner.size_hint()\n+            }\n+        }\n+\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n+        impl<'a, $elem, P> FusedIterator for $name<'a, $elem, P> where P: FnMut(&T) -> bool {}\n+    };\n+}"}, {"sha": "bbaf0fae05afb02b921f332b43b273bcd1b08f29", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 250, "deletions": 3116, "changes": 3366, "blob_url": "https://github.com/rust-lang/rust/blob/f376443b8f2e8935c33f1edd08586ec7f29a900c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f376443b8f2e8935c33f1edd08586ec7f29a900c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=f376443b8f2e8935c33f1edd08586ec7f29a900c"}]}