{"sha": "4ff701b7db609cabe59832d47779832a16627b5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZjcwMWI3ZGI2MDljYWJlNTk4MzJkNDc3Nzk4MzJhMTY2MjdiNWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-20T08:00:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-20T08:00:49Z"}, "message": "auto merge of #5965 : alexcrichton/rust/issue-4364, r=pcwalton\n\nThis closes #4364. I came into rust after modes had begun to be phased out, so I'm not exactly sure what they all did. My strategy was basically to turn on the compilation warnings and then when everything compiles and passes all the tests it's all good.\r\n\r\nIn most cases, I just dropped the mode, but in others I converted things to use `&` pointers when otherwise a move would happen.\r\n\r\nThis depends on #5963. When running the tests, everything passed except for a few compile-fail tests. These tests leaked memory, causing the task to abort differently. By suppressing the ICE from #5963, no leaks happen and the tests all pass. I would have looked into where the leaks were coming from, but I wasn't sure where or how to debug them (I found `RUSTRT_TRACK_ALLOCATIONS`, but it wasn't all that useful).", "tree": {"sha": "49317e2439d493b798412dad2c92b60e366f229f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49317e2439d493b798412dad2c92b60e366f229f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ff701b7db609cabe59832d47779832a16627b5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff701b7db609cabe59832d47779832a16627b5f", "html_url": "https://github.com/rust-lang/rust/commit/4ff701b7db609cabe59832d47779832a16627b5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ff701b7db609cabe59832d47779832a16627b5f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "028dc589d1cfb7e44b36b978ea1dcc304d70cee0", "url": "https://api.github.com/repos/rust-lang/rust/commits/028dc589d1cfb7e44b36b978ea1dcc304d70cee0", "html_url": "https://github.com/rust-lang/rust/commit/028dc589d1cfb7e44b36b978ea1dcc304d70cee0"}, {"sha": "cd982ad3f74673c55af6034a4f757e60be9b381c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd982ad3f74673c55af6034a4f757e60be9b381c", "html_url": "https://github.com/rust-lang/rust/commit/cd982ad3f74673c55af6034a4f757e60be9b381c"}], "stats": {"total": 2213, "additions": 1089, "deletions": 1124}, "files": [{"sha": "2656115dca2582ec8c5b9094eb0e635bad44d73c", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -112,8 +112,6 @@ pub mod streamp {\n \n     #[allow(non_camel_case_types)]\n     pub mod server {\n-        priv use core::kinds::Owned;\n-\n         #[allow(non_camel_case_types)]\n         pub type Open<T> = ::core::pipes::RecvPacket<super::Open<T>>;\n     }\n@@ -388,8 +386,6 @@ pub mod oneshot {\n \n     #[allow(non_camel_case_types)]\n     pub mod server {\n-        priv use core::kinds::Owned;\n-\n         #[allow(non_camel_case_types)]\n         pub type Oneshot<T> =\n             ::core::pipes::RecvPacketBuffered<super::Oneshot<T>,"}, {"sha": "77fbadf0bb7bb169ef9f85c6b96e79c468e656f1", "filename": "src/libcore/rt/sched/local_sched.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -66,18 +66,16 @@ pub fn borrow(f: &fn(&mut Scheduler)) {\n /// Because this leaves the Scheduler in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n pub unsafe fn unsafe_borrow() -> &mut Scheduler {\n-    unsafe {\n-        let key = tls_key();\n-        let mut void_sched: *mut c_void = tls::get(key);\n-        assert!(void_sched.is_not_null());\n-        {\n-            let void_sched_ptr = &mut void_sched;\n-            let sched: &mut ~Scheduler = {\n-                transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n-            };\n-            let sched: &mut Scheduler = &mut **sched;\n-            return sched;\n-        }\n+    let key = tls_key();\n+    let mut void_sched: *mut c_void = tls::get(key);\n+    assert!(void_sched.is_not_null());\n+    {\n+        let void_sched_ptr = &mut void_sched;\n+        let sched: &mut ~Scheduler = {\n+            transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n+        };\n+        let sched: &mut Scheduler = &mut **sched;\n+        return sched;\n     }\n }\n "}, {"sha": "b4a08c1492894d91d9559552ec12467fac1d14b5", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -388,7 +388,7 @@ fn connect_read() {\n                 vec_to_uv_buf(vec::from_elem(size, 0))\n             };\n             do stream_watcher.read_start(alloc)\n-                |stream_watcher, nread, buf, status| {\n+                |stream_watcher, _nread, buf, status| {\n \n                 let buf = vec_from_uv_buf(buf);\n                 rtdebug!(\"read cb!\");"}, {"sha": "21e75354e740c77087549fa4d483305be27958eb", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -64,9 +64,7 @@ fn test_simple_deep() {\n         if i == 0 { return }\n \n         for walk_stack |_frame| {\n-            unsafe {\n-                breakpoint();\n-            }\n+            breakpoint();\n         }\n         run(i - 1);\n     }"}, {"sha": "d72b4a71e2a6e0bbe010396c19ce8ea759f9bc8e", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -3346,15 +3346,15 @@ mod tests {\n     #[test]\n     fn test_shift_byte() {\n         let mut s = ~\"ABC\";\n-        let b = unsafe { raw::shift_byte(&mut s) };\n+        let b = raw::shift_byte(&mut s);\n         assert!((s == ~\"BC\"));\n         assert!((b == 65u8));\n     }\n \n     #[test]\n     fn test_pop_byte() {\n         let mut s = ~\"ABC\";\n-        let b = unsafe { raw::pop_byte(&mut s) };\n+        let b = raw::pop_byte(&mut s);\n         assert!((s == ~\"AB\"));\n         assert!((b == 67u8));\n     }"}, {"sha": "6050aca6dc1f5fc83e13f90b8c8bab90c78f2f84", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -150,32 +150,28 @@ fn test_tls_modify() {\n \n #[test]\n fn test_tls_crust_automorestack_memorial_bug() {\n-    unsafe {\n-        // This might result in a stack-canary clobber if the runtime fails to\n-        // set sp_limit to 0 when calling the cleanup extern - it might\n-        // automatically jump over to the rust stack, which causes next_c_sp\n-        // to get recorded as something within a rust stack segment. Then a\n-        // subsequent upcall (esp. for logging, think vsnprintf) would run on\n-        // a stack smaller than 1 MB.\n-        fn my_key(_x: @~str) { }\n-        do task::spawn {\n-            unsafe { local_data_set(my_key, @~\"hax\"); }\n-        }\n+    // This might result in a stack-canary clobber if the runtime fails to\n+    // set sp_limit to 0 when calling the cleanup extern - it might\n+    // automatically jump over to the rust stack, which causes next_c_sp\n+    // to get recorded as something within a rust stack segment. Then a\n+    // subsequent upcall (esp. for logging, think vsnprintf) would run on\n+    // a stack smaller than 1 MB.\n+    fn my_key(_x: @~str) { }\n+    do task::spawn {\n+        unsafe { local_data_set(my_key, @~\"hax\"); }\n     }\n }\n \n #[test]\n fn test_tls_multiple_types() {\n-    unsafe {\n-        fn str_key(_x: @~str) { }\n-        fn box_key(_x: @@()) { }\n-        fn int_key(_x: @int) { }\n-        do task::spawn {\n-            unsafe {\n-                local_data_set(str_key, @~\"string data\");\n-                local_data_set(box_key, @@());\n-                local_data_set(int_key, @42);\n-            }\n+    fn str_key(_x: @~str) { }\n+    fn box_key(_x: @@()) { }\n+    fn int_key(_x: @int) { }\n+    do task::spawn {\n+        unsafe {\n+            local_data_set(str_key, @~\"string data\");\n+            local_data_set(box_key, @@());\n+            local_data_set(int_key, @42);\n         }\n     }\n }"}, {"sha": "917ab3e8801a1060ad0ad6b1d97b233a756d9bef", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -160,7 +160,7 @@ pub fn stash_ty_if(c: @fn(@ast::Ty, test_mode)->bool,\n \n pub struct StolenStuff {exprs: ~[ast::expr], tys: ~[ast::Ty]}\n \n-pub fn steal(crate: ast::crate, tm: test_mode) -> StolenStuff {\n+pub fn steal(crate: @ast::crate, tm: test_mode) -> StolenStuff {\n     let exprs = @mut ~[];\n     let tys = @mut ~[];\n     let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n@@ -197,7 +197,7 @@ pub fn safe_to_replace_ty(t: &ast::ty_, _tm: test_mode) -> bool {\n }\n \n // Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-pub fn replace_expr_in_crate(crate: ast::crate, i: uint,\n+pub fn replace_expr_in_crate(crate: @ast::crate, i: uint,\n                              newexpr: ast::expr, tm: test_mode) ->\n    ast::crate {\n     let j: @mut uint = @mut 0u;\n@@ -222,13 +222,13 @@ pub fn replace_expr_in_crate(crate: ast::crate, i: uint,\n         .. *fold::default_ast_fold()\n     };\n     let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(&crate);\n+    let crate2: @ast::crate = @af.fold_crate(crate);\n     *crate2\n }\n \n \n // Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-pub fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n+pub fn replace_ty_in_crate(crate: @ast::crate, i: uint, newty: ast::Ty,\n                            tm: test_mode) -> ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_ty_rep(j_: @mut uint,\n@@ -248,7 +248,7 @@ pub fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n         .. *fold::default_ast_fold()\n     };\n     let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(&crate);\n+    let crate2: @ast::crate = @af.fold_crate(crate);\n     *crate2\n }\n \n@@ -261,7 +261,7 @@ pub fn as_str(f: @fn(+x: @io::Writer)) -> ~str {\n     io::with_str_writer(f)\n }\n \n-pub fn check_variants_of_ast(crate: ast::crate, codemap: @codemap::CodeMap,\n+pub fn check_variants_of_ast(crate: @ast::crate, codemap: @codemap::CodeMap,\n                              filename: &Path, cx: Context) {\n     let stolen = steal(crate, cx.mode);\n     let extra_exprs = do common_exprs().filtered |a| {\n@@ -275,13 +275,13 @@ pub fn check_variants_of_ast(crate: ast::crate, codemap: @codemap::CodeMap,\n }\n \n pub fn check_variants_T<T: Copy>(\n-  crate: ast::crate,\n+  crate: @ast::crate,\n   codemap: @codemap::CodeMap,\n   filename: &Path,\n   thing_label: ~str,\n   things: ~[T],\n   stringifier: @fn(@T, @syntax::parse::token::ident_interner) -> ~str,\n-  replacer: @fn(ast::crate, uint, T, test_mode) -> ast::crate,\n+  replacer: @fn(@ast::crate, uint, T, test_mode) -> ast::crate,\n   cx: Context\n   ) {\n     error!(\"%s contains %u %s objects\", filename.to_str(),\n@@ -323,7 +323,7 @@ pub fn check_variants_T<T: Copy>(\n                                           last_part(filename.to_str()),\n                                           thing_label, i, j);\n                     let safe_to_run = !(content_is_dangerous_to_run(*str3)\n-                                        || has_raw_pointers(*crate2));\n+                                        || has_raw_pointers(crate2));\n                     check_whole_compiler(*str3, &Path(file_label),\n                                          safe_to_run);\n                   }\n@@ -480,7 +480,7 @@ pub fn parse_and_print(code: @~str) -> ~str {\n     }\n }\n \n-pub fn has_raw_pointers(c: ast::crate) -> bool {\n+pub fn has_raw_pointers(c: @ast::crate) -> bool {\n     let has_rp = @mut false;\n     fn visit_ty(flag: @mut bool, t: @ast::Ty) {\n         match t.node {\n@@ -634,7 +634,7 @@ pub fn check_variants(files: &[Path], cx: Context) {\n                        pprust::no_ann(),\n                        false)))\n         });\n-        check_variants_of_ast(*crate, sess.cm, file, cx);\n+        check_variants_of_ast(crate, sess.cm, file, cx);\n     }\n }\n "}, {"sha": "3dfa318826b7bd8340031701ff20ec0b11e6b421", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -48,7 +48,7 @@ pub enum output_type {\n     output_type_exe,\n }\n \n-pub fn llvm_err(sess: Session, +msg: ~str) -> ! {\n+pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n@@ -153,7 +153,7 @@ pub mod jit {\n                     code: entry,\n                     env: ptr::null()\n                 };\n-                let func: &fn(++argv: ~[@~str]) = cast::transmute(closure);\n+                let func: &fn(argv: ~[@~str]) = cast::transmute(closure);\n \n                 func(~[sess.opts.binary]);\n             }\n@@ -519,7 +519,7 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n \n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(symbol_hasher: &hash::State,\n-                              +cmh_items: ~[@ast::meta_item],\n+                              cmh_items: ~[@ast::meta_item],\n                               dep_hashes: ~[~str]) -> @str {\n         fn len_and_str(s: &str) -> ~str {\n             fmt!(\"%u_%s\", s.len(), s)\n@@ -568,7 +568,7 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n                        name, default));\n     }\n \n-    fn crate_meta_name(sess: Session, output: &Path, +opt_name: Option<@str>)\n+    fn crate_meta_name(sess: Session, output: &Path, opt_name: Option<@str>)\n                     -> @str {\n         return match opt_name {\n               Some(v) => v,\n@@ -703,7 +703,7 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n }\n \n pub fn exported_name(sess: Session,\n-                     +path: path,\n+                     path: path,\n                      hash: &str,\n                      vers: &str) -> ~str {\n     return mangle(sess,\n@@ -713,7 +713,7 @@ pub fn exported_name(sess: Session,\n }\n \n pub fn mangle_exported_name(ccx: @CrateContext,\n-                            +path: path,\n+                            path: path,\n                             t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n     return exported_name(ccx.sess, path,\n@@ -733,17 +733,17 @@ pub fn mangle_internal_name_by_type_only(ccx: @CrateContext,\n }\n \n pub fn mangle_internal_name_by_path_and_seq(ccx: @CrateContext,\n-                                            +path: path,\n-                                            +flav: ~str) -> ~str {\n+                                            path: path,\n+                                            flav: ~str) -> ~str {\n     return mangle(ccx.sess,\n                   vec::append_one(path, path_name((ccx.names)(flav))));\n }\n \n-pub fn mangle_internal_name_by_path(ccx: @CrateContext, +path: path) -> ~str {\n+pub fn mangle_internal_name_by_path(ccx: @CrateContext, path: path) -> ~str {\n     return mangle(ccx.sess, path);\n }\n \n-pub fn mangle_internal_name_by_seq(ccx: @CrateContext, +flav: ~str) -> ~str {\n+pub fn mangle_internal_name_by_seq(ccx: @CrateContext, flav: ~str) -> ~str {\n     return fmt!(\"%s_%u\", flav, (ccx.names)(flav).repr);\n }\n \n@@ -768,7 +768,7 @@ pub fn link_binary(sess: Session,\n                    out_filename: &Path,\n                    lm: LinkMeta) {\n     // Converts a library file-stem into a cc -l argument\n-    fn unlib(config: @session::config, +stem: ~str) -> ~str {\n+    fn unlib(config: @session::config, stem: ~str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n             config.os != session::os_win32 {\n             stem.slice(3, stem.len()).to_owned()"}, {"sha": "fae73d7faf2d4965eef53de19bfbd2f77b136b8d", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -55,14 +55,14 @@ pub enum pp_mode {\n  */\n pub fn anon_src() -> ~str { ~\"<anon>\" }\n \n-pub fn source_name(input: input) -> ~str {\n-    match input {\n+pub fn source_name(input: &input) -> ~str {\n+    match *input {\n       file_input(ref ifile) => ifile.to_str(),\n       str_input(_) => anon_src()\n     }\n }\n \n-pub fn default_configuration(sess: Session, argv0: @~str, input: input) ->\n+pub fn default_configuration(sess: Session, argv0: @~str, input: &input) ->\n    ast::crate_cfg {\n     let libc = match sess.targ_cfg.os {\n       session::os_win32 => ~\"msvcrt.dll\",\n@@ -105,7 +105,7 @@ pub fn default_configuration(sess: Session, argv0: @~str, input: input) ->\n          mk(@~\"build_input\", @source_name(input))];\n }\n \n-pub fn append_configuration(+cfg: ast::crate_cfg, +name: ~str)\n+pub fn append_configuration(cfg: ast::crate_cfg, name: ~str)\n                          -> ast::crate_cfg {\n     if attr::contains_name(cfg, name) {\n         cfg\n@@ -114,7 +114,7 @@ pub fn append_configuration(+cfg: ast::crate_cfg, +name: ~str)\n     }\n }\n \n-pub fn build_configuration(sess: Session, argv0: @~str, input: input) ->\n+pub fn build_configuration(sess: Session, argv0: @~str, input: &input) ->\n    ast::crate_cfg {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n@@ -132,7 +132,7 @@ pub fn build_configuration(sess: Session, argv0: @~str, input: input) ->\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(+cfgspecs: ~[~str],\n+fn parse_cfgspecs(cfgspecs: ~[~str],\n                   demitter: diagnostic::Emitter) -> ast::crate_cfg {\n     do vec::map_consume(cfgspecs) |s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n@@ -147,9 +147,9 @@ pub enum input {\n     str_input(~str)\n }\n \n-pub fn parse_input(sess: Session, +cfg: ast::crate_cfg, input: input)\n+pub fn parse_input(sess: Session, cfg: ast::crate_cfg, input: &input)\n     -> @ast::crate {\n-    match input {\n+    match *input {\n       file_input(ref file) => {\n         parse::parse_crate_from_file_using_tts(&(*file), cfg, sess.parse_sess)\n       }\n@@ -207,10 +207,10 @@ pub fn compile_rest(sess: Session,\n         lint::build_settings_crate(sess, crate));\n \n     let ast_map = time(time_passes, ~\"ast indexing\", ||\n-            syntax::ast_map::map_crate(sess.diagnostic(), *crate));\n+            syntax::ast_map::map_crate(sess.diagnostic(), crate));\n \n     time(time_passes, ~\"external crate/lib resolution\", ||\n-        creader::read_crates(sess.diagnostic(), *crate, sess.cstore,\n+        creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n                              sess.filesearch,\n                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n                              sess.opts.is_static,\n@@ -344,8 +344,8 @@ pub fn compile_rest(sess: Session,\n     return (crate, None);\n }\n \n-pub fn compile_upto(sess: Session, +cfg: ast::crate_cfg,\n-                input: input, upto: compile_upto,\n+pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n+                input: &input, upto: compile_upto,\n                 outputs: Option<@OutputFilenames>)\n     -> (@ast::crate, Option<ty::ctxt>) {\n     let time_passes = sess.time_passes();\n@@ -356,7 +356,7 @@ pub fn compile_upto(sess: Session, +cfg: ast::crate_cfg,\n     compile_rest(sess, cfg, upto, outputs, Some(crate))\n }\n \n-pub fn compile_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n+pub fn compile_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n                      outdir: &Option<Path>, output: &Option<Path>) {\n     let upto = if sess.opts.parse_only { cu_parse }\n                else if sess.opts.no_trans { cu_no_trans }\n@@ -365,7 +365,7 @@ pub fn compile_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n     compile_upto(sess, cfg, input, upto, Some(outputs));\n }\n \n-pub fn pretty_print_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n+pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n                           ppm: pp_mode) {\n     fn ann_paren_for_expr(node: pprust::ann_node) {\n         match node {\n@@ -690,7 +690,7 @@ pub fn build_session_(sopts: @session::options,\n                                                     cm);\n     let cstore = @mut cstore::mk_cstore(p_s.interner);\n     let filesearch = filesearch::mk_filesearch(\n-        sopts.maybe_sysroot,\n+        &sopts.maybe_sysroot,\n         sopts.target_triple,\n         /*bad*/copy sopts.addl_lib_search_paths);\n     let lint_settings = lint::mk_lint_settings();\n@@ -711,13 +711,13 @@ pub fn build_session_(sopts: @session::options,\n     }\n }\n \n-pub fn parse_pretty(sess: Session, &&name: ~str) -> pp_mode {\n+pub fn parse_pretty(sess: Session, name: &str) -> pp_mode {\n     match name {\n-      ~\"normal\" => ppm_normal,\n-      ~\"expanded\" => ppm_expanded,\n-      ~\"typed\" => ppm_typed,\n-      ~\"expanded,identified\" => ppm_expanded_identified,\n-      ~\"identified\" => ppm_identified,\n+      &\"normal\" => ppm_normal,\n+      &\"expanded\" => ppm_expanded,\n+      &\"typed\" => ppm_typed,\n+      &\"expanded,identified\" => ppm_expanded_identified,\n+      &\"identified\" => ppm_identified,\n       _ => {\n         sess.fatal(~\"argument to `pretty` must be one of `normal`, \\\n                      `expanded`, `typed`, `identified`, \\\n@@ -790,7 +790,7 @@ pub struct OutputFilenames {\n     obj_filename: Path\n }\n \n-pub fn build_output_filenames(input: input,\n+pub fn build_output_filenames(input: &input,\n                               odir: &Option<Path>,\n                               ofile: &Option<Path>,\n                               sess: Session)\n@@ -820,13 +820,13 @@ pub fn build_output_filenames(input: input,\n         // We want to toss everything after the final '.'\n         let dirpath = match *odir {\n           Some(ref d) => (/*bad*/copy *d),\n-          None => match input {\n+          None => match *input {\n             str_input(_) => os::getcwd(),\n             file_input(ref ifile) => (*ifile).dir_path()\n           }\n         };\n \n-        let stem = match input {\n+        let stem = match *input {\n           file_input(ref ifile) => (*ifile).filestem().get(),\n           str_input(_) => ~\"rust_out\"\n         };\n@@ -903,7 +903,7 @@ mod test {\n         let sessopts = build_session_options(\n             @~\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n-        let cfg = build_configuration(sess, @~\"whatever\", str_input(~\"\"));\n+        let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n         assert!((attr::contains_name(cfg, ~\"test\")));\n     }\n \n@@ -922,7 +922,7 @@ mod test {\n         let sessopts = build_session_options(\n             @~\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n-        let cfg = build_configuration(sess, @~\"whatever\", str_input(~\"\"));\n+        let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n         let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");\n         assert!((vec::len(test_items) == 1u));\n     }"}, {"sha": "1912c922524fb34563c5feeb1e3410eeb726ba33", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -215,7 +215,7 @@ pub impl Session_ {\n     fn unimpl(@self, msg: ~str) -> ! {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n-    fn span_lint_level(@self, level: lint::level, sp: span, +msg: ~str) {\n+    fn span_lint_level(@self, level: lint::level, sp: span, msg: ~str) {\n         match level {\n           lint::allow => { },\n           lint::warn => self.span_warn(sp, msg),\n@@ -228,7 +228,7 @@ pub impl Session_ {\n                  expr_id: ast::node_id,\n                  item_id: ast::node_id,\n                  span: span,\n-                 +msg: ~str) {\n+                 msg: ~str) {\n         let level = lint::get_lint_settings_level(\n             self.lint_settings, lint_mode, expr_id, item_id);\n         self.span_lint_level(level, span, msg);\n@@ -278,7 +278,7 @@ pub impl Session_ {\n     fn str_of(@self, id: ast::ident) -> @~str {\n         self.parse_sess.interner.get(id)\n     }\n-    fn ident_of(@self, +st: ~str) -> ast::ident {\n+    fn ident_of(@self, st: ~str) -> ast::ident {\n         self.parse_sess.interner.intern(@st)\n     }\n     fn intr(@self) -> @syntax::parse::token::ident_interner {\n@@ -361,7 +361,7 @@ mod test {\n     use syntax::ast;\n     use syntax::codemap;\n \n-    fn make_crate_type_attr(+t: ~str) -> ast::attribute {\n+    fn make_crate_type_attr(t: ~str) -> ast::attribute {\n         codemap::respan(codemap::dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n             value: @codemap::respan(codemap::dummy_sp(),"}, {"sha": "966f2a4ac70f3de5111dfa271ac627e0859e6ee7", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -15,7 +15,7 @@ use syntax::{ast, fold, attr};\n use core::option;\n use core::vec;\n \n-type in_cfg_pred = @fn(+attrs: ~[ast::attribute]) -> bool;\n+type in_cfg_pred = @fn(attrs: ~[ast::attribute]) -> bool;\n \n struct Context {\n     in_cfg: in_cfg_pred\n@@ -49,12 +49,12 @@ pub fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n     return res;\n }\n \n-fn filter_item(cx: @Context, &&item: @ast::item) ->\n+fn filter_item(cx: @Context, item: @ast::item) ->\n    Option<@ast::item> {\n     if item_in_cfg(cx, item) { option::Some(item) } else { option::None }\n }\n \n-fn filter_view_item(cx: @Context, &&view_item: @ast::view_item\n+fn filter_view_item(cx: @Context, view_item: @ast::view_item\n                    )-> Option<@ast::view_item> {\n     if view_item_in_cfg(cx, view_item) {\n         option::Some(view_item)\n@@ -74,7 +74,7 @@ fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n     }\n }\n \n-fn filter_foreign_item(cx: @Context, &&item: @ast::foreign_item) ->\n+fn filter_foreign_item(cx: @Context, item: @ast::foreign_item) ->\n    Option<@ast::foreign_item> {\n     if foreign_item_in_cfg(cx, item) {\n         option::Some(item)\n@@ -115,7 +115,7 @@ fn fold_item_underscore(cx: @Context, item: &ast::item_,\n     fold::noop_fold_item_underscore(&item, fld)\n }\n \n-fn filter_stmt(cx: @Context, &&stmt: @ast::stmt) ->\n+fn filter_stmt(cx: @Context, stmt: @ast::stmt) ->\n    Option<@ast::stmt> {\n     match stmt.node {\n       ast::stmt_decl(decl, _) => {\n@@ -173,12 +173,12 @@ fn trait_method_in_cfg(cx: @Context, meth: &ast::trait_method) -> bool {\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(+cfg: ast::crate_cfg, +attrs: ~[ast::attribute]) -> bool {\n+fn in_cfg(cfg: ast::crate_cfg, attrs: ~[ast::attribute]) -> bool {\n     metas_in_cfg(cfg, attr::attr_metas(attrs))\n }\n \n pub fn metas_in_cfg(cfg: ast::crate_cfg,\n-                    +metas: ~[@ast::meta_item]) -> bool {\n+                    metas: ~[@ast::meta_item]) -> bool {\n     // The \"cfg\" attributes on the item\n     let cfg_metas = attr::find_meta_items_by_name(metas, ~\"cfg\");\n "}, {"sha": "4a122d238d496a717f834174b8500dd0fad1b865", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -138,7 +138,7 @@ fn fold_crate(cx: @mut TestCtxt,\n }\n \n \n-fn fold_item(cx: @mut TestCtxt, &&i: @ast::item, fld: @fold::ast_fold)\n+fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n           -> Option<@ast::item> {\n     cx.path.push(i.ident);\n     debug!(\"current path: %s\",\n@@ -336,15 +336,15 @@ fn nospan<T:Copy>(t: T) -> codemap::spanned<T> {\n     codemap::spanned { node: t, span: dummy_sp() }\n }\n \n-fn path_node(+ids: ~[ast::ident]) -> @ast::Path {\n+fn path_node(ids: ~[ast::ident]) -> @ast::Path {\n     @ast::Path { span: dummy_sp(),\n                 global: false,\n                 idents: ids,\n                 rp: None,\n                 types: ~[] }\n }\n \n-fn path_node_global(+ids: ~[ast::ident]) -> @ast::Path {\n+fn path_node_global(ids: ~[ast::ident]) -> @ast::Path {\n     @ast::Path { span: dummy_sp(),\n                  global: true,\n                  idents: ids,\n@@ -381,7 +381,7 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n     for cx.testfns.each |test| {\n-        descs.push(mk_test_desc_and_fn_rec(cx, *test));\n+        descs.push(mk_test_desc_and_fn_rec(cx, test));\n     }\n \n     let sess = cx.sess;\n@@ -400,7 +400,7 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     }\n }\n \n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: Test) -> @ast::expr {\n+fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n     let span = test.span;\n     let path = /*bad*/copy test.path;\n "}, {"sha": "369e6aeb4a5983db7d0e3d3ac55405e794ff52ff", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -1929,7 +1929,7 @@ pub fn type_to_str(names: @TypeNames, ty: TypeRef) -> @str {\n     return type_to_str_inner(names, [], ty);\n }\n \n-pub fn type_to_str_inner(names: @TypeNames, +outer0: &[TypeRef], ty: TypeRef)\n+pub fn type_to_str_inner(names: @TypeNames, outer0: &[TypeRef], ty: TypeRef)\n                       -> @str {\n     unsafe {\n         match type_has_name(names, ty) {"}, {"sha": "909e351acb1be97eb9bcf451d1ca36c5ed103589", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -30,7 +30,7 @@ use syntax::ast;\n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n pub fn read_crates(diag: @span_handler,\n-                   crate: ast::crate,\n+                   crate: @ast::crate,\n                    cstore: @mut cstore::CStore,\n                    filesearch: @FileSearch,\n                    os: loader::os,\n@@ -126,7 +126,7 @@ struct Env {\n     intr: @ident_interner\n }\n \n-fn visit_crate(e: @mut Env, c: ast::crate) {\n+fn visit_crate(e: @mut Env, c: &ast::crate) {\n     let cstore = e.cstore;\n     let link_args = attr::find_attrs_by_name(c.node.attrs, \"link_args\");\n \n@@ -204,7 +204,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: @~str, key: @~str, +metas: ~[@ast::meta_item])\n+fn metas_with(ident: @~str, key: @~str, metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n     let name_items = attr::find_meta_items_by_name(metas, *key);\n     if name_items.is_empty() {\n@@ -214,7 +214,7 @@ fn metas_with(ident: @~str, key: @~str, +metas: ~[@ast::meta_item])\n     }\n }\n \n-fn metas_with_ident(ident: @~str, +metas: ~[@ast::meta_item])\n+fn metas_with_ident(ident: @~str, metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n     metas_with(ident, @~\"name\", metas)\n }\n@@ -232,7 +232,7 @@ fn existing_match(e: @mut Env, metas: &[@ast::meta_item], hash: @~str)\n \n fn resolve_crate(e: @mut Env,\n                  ident: ast::ident,\n-                 +metas: ~[@ast::meta_item],\n+                 metas: ~[@ast::meta_item],\n                  hash: @~str,\n                  span: span)\n               -> ast::crate_num {\n@@ -251,7 +251,7 @@ fn resolve_crate(e: @mut Env,\n             is_static: e.statik,\n             intr: e.intr\n         };\n-        let (lident, ldata) = loader::load_library_crate(load_ctxt);\n+        let (lident, ldata) = loader::load_library_crate(&load_ctxt);\n \n         let cfilename = Path(lident);\n         let cdata = ldata;"}, {"sha": "aaafc7c18d6f3d923dd398cf60b3156e3e37e86d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -53,7 +53,7 @@ use writer = std::ebml::writer;\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n-                                   ebml_w: writer::Encoder,\n+                                   ebml_w: &writer::Encoder,\n                                    path: &[ast_map::path_elt],\n                                    ii: ast::inlined_item);\n \n@@ -101,31 +101,31 @@ pub fn reachable(ecx: @EncodeContext, id: node_id) -> bool {\n     ecx.reachable.contains(&id)\n }\n \n-fn encode_name(ecx: @EncodeContext, ebml_w: writer::Encoder, name: ident) {\n+fn encode_name(ecx: @EncodeContext, ebml_w: &writer::Encoder, name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_impl_type_basename(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_impl_type_basename(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n                          *ecx.tcx.sess.str_of(name));\n }\n \n-pub fn encode_def_id(ebml_w: writer::Encoder, id: def_id) {\n+pub fn encode_def_id(ebml_w: &writer::Encoder, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_region_param(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n     for opt_rp.each |rp| {\n         do ebml_w.wr_tag(tag_region_param) {\n-            (*rp).encode(&ebml_w);\n+            rp.encode(ebml_w);\n         }\n     }\n }\n \n-fn encode_mutability(ebml_w: writer::Encoder, mt: struct_mutability) {\n+fn encode_mutability(ebml_w: &writer::Encoder, mt: struct_mutability) {\n     do ebml_w.wr_tag(tag_struct_mut) {\n         let val = match mt {\n           struct_immutable => 'a',\n@@ -140,7 +140,7 @@ struct entry<T> {\n     pos: uint\n }\n \n-fn add_to_index(ecx: @EncodeContext, ebml_w: writer::Encoder, path: &[ident],\n+fn add_to_index(ecx: @EncodeContext, ebml_w: &writer::Encoder, path: &[ident],\n                 index: &mut ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n@@ -153,7 +153,7 @@ fn add_to_index(ecx: @EncodeContext, ebml_w: writer::Encoder, path: &[ident],\n         });\n }\n \n-fn encode_trait_ref(ebml_w: writer::Encoder,\n+fn encode_trait_ref(ebml_w: &writer::Encoder,\n                     ecx: @EncodeContext,\n                     trait_ref: &ty::TraitRef,\n                     tag: uint)\n@@ -171,15 +171,15 @@ fn encode_trait_ref(ebml_w: writer::Encoder,\n }\n \n // Item info table encoding\n-fn encode_family(ebml_w: writer::Encoder, c: char) {\n+fn encode_family(ebml_w: &writer::Encoder, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n     ebml_w.end_tag();\n }\n \n pub fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_defs(ebml_w: writer::Encoder,\n+fn encode_ty_type_param_defs(ebml_w: &writer::Encoder,\n                              ecx: @EncodeContext,\n                              params: @~[ty::TypeParameterDef],\n                              tag: uint) {\n@@ -196,7 +196,7 @@ fn encode_ty_type_param_defs(ebml_w: writer::Encoder,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: writer::Encoder,\n+fn encode_type_param_bounds(ebml_w: &writer::Encoder,\n                             ecx: @EncodeContext,\n                             params: &OptVec<TyParam>) {\n     let ty_param_defs =\n@@ -206,13 +206,13 @@ fn encode_type_param_bounds(ebml_w: writer::Encoder,\n }\n \n \n-fn encode_variant_id(ebml_w: writer::Encoder, vid: def_id) {\n+fn encode_variant_id(ebml_w: &writer::Encoder, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n     ebml_w.end_tag();\n }\n \n-pub fn write_type(ecx: @EncodeContext, ebml_w: writer::Encoder, typ: ty::t) {\n+pub fn write_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n@@ -222,7 +222,7 @@ pub fn write_type(ecx: @EncodeContext, ebml_w: writer::Encoder, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-pub fn write_vstore(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+pub fn write_vstore(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                     vstore: ty::vstore) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n@@ -233,14 +233,14 @@ pub fn write_vstore(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-fn encode_type(ecx: @EncodeContext, ebml_w: writer::Encoder, typ: ty::t) {\n+fn encode_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n fn encode_transformed_self_ty(ecx: @EncodeContext,\n-                              ebml_w: writer::Encoder,\n+                              ebml_w: &writer::Encoder,\n                               opt_typ: Option<ty::t>)\n {\n     for opt_typ.each |&typ| {\n@@ -251,7 +251,7 @@ fn encode_transformed_self_ty(ecx: @EncodeContext,\n }\n \n fn encode_method_fty(ecx: @EncodeContext,\n-                     ebml_w: writer::Encoder,\n+                     ebml_w: &writer::Encoder,\n                      typ: &ty::BareFnTy)\n {\n     ebml_w.start_tag(tag_item_method_fty);\n@@ -267,7 +267,7 @@ fn encode_method_fty(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @EncodeContext, ebml_w: writer::Encoder, id: node_id) {\n+fn encode_symbol(ecx: @EncodeContext, ebml_w: &writer::Encoder, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n         Some(x) => {\n@@ -282,27 +282,27 @@ fn encode_symbol(ecx: @EncodeContext, ebml_w: writer::Encoder, id: node_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_discriminant(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::to_bytes(**ecx.discrim_symbols.get(&id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_disr_val(_ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::to_bytes(int::to_str(disr_val)));\n     ebml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: writer::Encoder, id: def_id) {\n+fn encode_parent_item(ebml_w: &writer::Encoder, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                             id: node_id, variants: &[variant],\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<int>],\n@@ -343,9 +343,9 @@ fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     }\n }\n \n-fn encode_path(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_path(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                path: &[ast_map::path_elt], name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+    fn encode_path_elt(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n@@ -364,7 +364,7 @@ fn encode_path(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     }\n }\n \n-fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                        md: &_mod, id: node_id, path: &[ast_map::path_elt],\n                        name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n@@ -422,7 +422,7 @@ fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_struct_field_family(ebml_w: writer::Encoder,\n+fn encode_struct_field_family(ebml_w: &writer::Encoder,\n                               visibility: visibility) {\n     encode_family(ebml_w, match visibility {\n         public => 'g',\n@@ -431,7 +431,7 @@ fn encode_struct_field_family(ebml_w: writer::Encoder,\n     });\n }\n \n-fn encode_visibility(ebml_w: writer::Encoder, visibility: visibility) {\n+fn encode_visibility(ebml_w: &writer::Encoder, visibility: visibility) {\n     ebml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n         public => 'y',\n@@ -442,7 +442,7 @@ fn encode_visibility(ebml_w: writer::Encoder, visibility: visibility) {\n     ebml_w.end_tag();\n }\n \n-fn encode_self_type(ebml_w: writer::Encoder, self_type: ast::self_ty_) {\n+fn encode_self_type(ebml_w: &writer::Encoder, self_type: ast::self_ty_) {\n     ebml_w.start_tag(tag_item_trait_method_self_ty);\n \n     // Encode the base self type.\n@@ -470,7 +470,7 @@ fn encode_self_type(ebml_w: writer::Encoder, self_type: ast::self_ty_) {\n \n     ebml_w.end_tag();\n \n-    fn encode_mutability(ebml_w: writer::Encoder,\n+    fn encode_mutability(ebml_w: &writer::Encoder,\n                          m: ast::mutability) {\n         match m {\n             m_imm => {\n@@ -486,14 +486,14 @@ fn encode_self_type(ebml_w: writer::Encoder, self_type: ast::self_ty_) {\n     }\n }\n \n-fn encode_method_sort(ebml_w: writer::Encoder, sort: char) {\n+fn encode_method_sort(ebml_w: &writer::Encoder, sort: char) {\n     ebml_w.start_tag(tag_item_trait_method_sort);\n     ebml_w.writer.write(&[ sort as u8 ]);\n     ebml_w.end_tag();\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                          path: &[ast_map::path_elt],\n                          fields: &[@struct_field],\n                          global_index: @mut~[entry<int>]) -> ~[entry<int>] {\n@@ -532,7 +532,7 @@ fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: writer::Encoder,\n \n // This is for encoding info for ctors and dtors\n fn encode_info_for_ctor(ecx: @EncodeContext,\n-                        ebml_w: writer::Encoder,\n+                        ebml_w: &writer::Encoder,\n                         id: node_id,\n                         ident: ident,\n                         path: &[ast_map::path_elt],\n@@ -550,8 +550,8 @@ fn encode_info_for_ctor(ecx: @EncodeContext,\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n         match item {\n-           Some(ref it) => {\n-             (ecx.encode_inlined_item)(ecx, ebml_w, path, (*it));\n+           Some(it) => {\n+             (ecx.encode_inlined_item)(ecx, ebml_w, path, it);\n            }\n            None => {\n              encode_symbol(ecx, ebml_w, id);\n@@ -561,7 +561,7 @@ fn encode_info_for_ctor(ecx: @EncodeContext,\n }\n \n fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n-                               ebml_w: writer::Encoder,\n+                               ebml_w: &writer::Encoder,\n                                path: &[ast_map::path_elt],\n                                name: ast::ident,\n                                ctor_id: node_id,\n@@ -583,7 +583,7 @@ fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n }\n \n fn encode_method_ty_fields(ecx: @EncodeContext,\n-                           ebml_w: writer::Encoder,\n+                           ebml_w: &writer::Encoder,\n                            method_ty: &ty::method)\n {\n     encode_def_id(ebml_w, method_ty.def_id);\n@@ -598,7 +598,7 @@ fn encode_method_ty_fields(ecx: @EncodeContext,\n }\n \n fn encode_info_for_method(ecx: @EncodeContext,\n-                          ebml_w: writer::Encoder,\n+                          ebml_w: &writer::Encoder,\n                           impl_path: &[ast_map::path_elt],\n                           should_inline: bool,\n                           parent_id: node_id,\n@@ -669,7 +669,7 @@ fn should_inline(attrs: &[attribute]) -> bool {\n }\n \n \n-fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_info_for_item(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                         item: @item, index: @mut ~[entry<int>],\n                         path: &[ast_map::path_elt]) {\n \n@@ -682,7 +682,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n \n-    fn add_to_index_(item: @item, ebml_w: writer::Encoder,\n+    fn add_to_index_(item: @item, ebml_w: &writer::Encoder,\n                      index: @mut ~[entry<int>]) {\n         index.push(entry { val: item.id, pos: ebml_w.writer.tell() });\n     }\n@@ -998,10 +998,10 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n }\n \n fn encode_info_for_foreign_item(ecx: @EncodeContext,\n-                                ebml_w: writer::Encoder,\n+                                ebml_w: &writer::Encoder,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n-                                +path: ast_map::path,\n+                                path: ast_map::path,\n                                 abi: AbiSet) {\n     if !reachable(ecx, nitem.id) { return; }\n     index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n@@ -1031,36 +1031,36 @@ fn encode_info_for_foreign_item(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_info_for_items(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                          crate: &crate) -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n     index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n     encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n                         crate_node_id, ~[],\n                         syntax::parse::token::special_idents::invalid);\n-    visit::visit_crate(*crate, (), visit::mk_vt(@visit::Visitor {\n+    visit::visit_crate(crate, (), visit::mk_vt(@visit::Visitor {\n         visit_expr: |_e, _cx, _v| { },\n         visit_item: {\n-            let ebml_w = copy ebml_w;\n+            let ebml_w = copy *ebml_w;\n             |i, cx, v| {\n                 visit::visit_item(i, cx, v);\n                 match *ecx.tcx.items.get(&i.id) {\n                     ast_map::node_item(_, pt) => {\n-                        encode_info_for_item(ecx, ebml_w, i,\n+                        encode_info_for_item(ecx, &ebml_w, i,\n                                              index, *pt);\n                     }\n                     _ => fail!(~\"bad item\")\n                 }\n             }\n         },\n         visit_foreign_item: {\n-            let ebml_w = copy ebml_w;\n+            let ebml_w = copy *ebml_w;\n             |ni, cx, v| {\n                 visit::visit_foreign_item(ni, cx, v);\n                 match *ecx.tcx.items.get(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, _, pt) => {\n-                        encode_info_for_foreign_item(ecx, ebml_w, ni,\n+                        encode_info_for_foreign_item(ecx, &ebml_w, ni,\n                                                      index, /*bad*/copy *pt,\n                                                      abi);\n                     }\n@@ -1094,8 +1094,8 @@ fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n     return buckets_frozen;\n }\n \n-fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n-                   write_fn: &fn(@io::Writer, T)) {\n+fn encode_index<T>(ebml_w: &writer::Encoder, buckets: ~[@~[entry<T>]],\n+                   write_fn: &fn(@io::Writer, &T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: ~[uint] = ~[];\n@@ -1107,7 +1107,7 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             writer.write_be_u32(elt.pos as u32);\n-            write_fn(writer, elt.val);\n+            write_fn(writer, &elt.val);\n             ebml_w.end_tag();\n         }\n         ebml_w.end_tag();\n@@ -1122,14 +1122,14 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n     ebml_w.end_tag();\n }\n \n-fn write_str(writer: @io::Writer, &&s: ~str) { writer.write_str(s); }\n+fn write_str(writer: @io::Writer, s: ~str) { writer.write_str(s); }\n \n-fn write_int(writer: @io::Writer, &&n: int) {\n+fn write_int(writer: @io::Writer, &n: &int) {\n     assert!(n < 0x7fff_ffff);\n     writer.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: writer::Encoder, mi: @meta_item) {\n+fn encode_meta_item(ebml_w: &writer::Encoder, mi: @meta_item) {\n     match mi.node {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n@@ -1166,7 +1166,7 @@ fn encode_meta_item(ebml_w: writer::Encoder, mi: @meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: writer::Encoder, attrs: &[attribute]) {\n+fn encode_attributes(ebml_w: &writer::Encoder, attrs: &[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n         ebml_w.start_tag(tag_attribute);\n@@ -1183,7 +1183,7 @@ fn encode_attributes(ebml_w: writer::Encoder, attrs: &[attribute]) {\n fn synthesize_crate_attrs(ecx: @EncodeContext,\n                           crate: &crate) -> ~[attribute] {\n \n-    fn synthesize_link_attr(ecx: @EncodeContext, +items: ~[@meta_item]) ->\n+    fn synthesize_link_attr(ecx: @EncodeContext, items: ~[@meta_item]) ->\n        attribute {\n \n         assert!(!ecx.link_meta.name.is_empty());\n@@ -1231,7 +1231,7 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n }\n \n fn encode_crate_deps(ecx: @EncodeContext,\n-                     ebml_w: writer::Encoder,\n+                     ebml_w: &writer::Encoder,\n                      cstore: @mut cstore::CStore) {\n     fn get_ordered_deps(ecx: @EncodeContext, cstore: @mut cstore::CStore)\n                      -> ~[decoder::crate_dep] {\n@@ -1272,7 +1272,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_lang_items(ecx: @EncodeContext, ebml_w: writer::Encoder) {\n+fn encode_lang_items(ecx: @EncodeContext, ebml_w: &writer::Encoder) {\n     ebml_w.start_tag(tag_lang_items);\n \n     for ecx.tcx.lang_items.each_item |def_id, i| {\n@@ -1297,7 +1297,7 @@ fn encode_lang_items(ecx: @EncodeContext, ebml_w: writer::Encoder) {\n }\n \n fn encode_link_args(ecx: @EncodeContext,\n-                    ebml_w: writer::Encoder) {\n+                    ebml_w: &writer::Encoder) {\n     ebml_w.start_tag(tag_link_args);\n \n     let link_args = cstore::get_used_link_args(ecx.cstore);\n@@ -1310,7 +1310,7 @@ fn encode_link_args(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_crate_dep(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n@@ -1325,7 +1325,7 @@ fn encode_crate_dep(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: writer::Encoder, hash: &str) {\n+fn encode_hash(ebml_w: &writer::Encoder, hash: &str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n     ebml_w.end_tag();\n@@ -1339,7 +1339,7 @@ pub static metadata_encoding_version : &'static [u8] =\n       0x74, //'t' as u8,\n       0, 0, 0, 1 ];\n \n-pub fn encode_metadata(+parms: EncodeParams, crate: &crate) -> ~[u8] {\n+pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     let wr = @io::BytesWriter();\n     let mut stats = Stats {\n         inline_bytes: 0,\n@@ -1372,36 +1372,36 @@ pub fn encode_metadata(+parms: EncodeParams, crate: &crate) -> ~[u8] {\n \n     let ebml_w = writer::Encoder(wr as @io::Writer);\n \n-    encode_hash(ebml_w, ecx.link_meta.extras_hash);\n+    encode_hash(&ebml_w, ecx.link_meta.extras_hash);\n \n     let mut i = wr.pos;\n     let crate_attrs = synthesize_crate_attrs(ecx, crate);\n-    encode_attributes(ebml_w, crate_attrs);\n+    encode_attributes(&ebml_w, crate_attrs);\n     ecx.stats.attr_bytes = wr.pos - i;\n \n     i = wr.pos;\n-    encode_crate_deps(ecx, ebml_w, ecx.cstore);\n+    encode_crate_deps(ecx, &ebml_w, ecx.cstore);\n     ecx.stats.dep_bytes = wr.pos - i;\n \n     // Encode the language items.\n     i = wr.pos;\n-    encode_lang_items(ecx, ebml_w);\n+    encode_lang_items(ecx, &ebml_w);\n     ecx.stats.lang_item_bytes = wr.pos - i;\n \n     // Encode the link args.\n     i = wr.pos;\n-    encode_link_args(ecx, ebml_w);\n+    encode_link_args(ecx, &ebml_w);\n     ecx.stats.link_args_bytes = wr.pos - i;\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     i = wr.pos;\n-    let items_index = encode_info_for_items(ecx, ebml_w, crate);\n+    let items_index = encode_info_for_items(ecx, &ebml_w, crate);\n     ecx.stats.item_bytes = wr.pos - i;\n \n     i = wr.pos;\n     let items_buckets = create_index(items_index);\n-    encode_index(ebml_w, items_buckets, write_int);\n+    encode_index(&ebml_w, items_buckets, write_int);\n     ecx.stats.index_bytes = wr.pos - i;\n     ebml_w.end_tag();\n "}, {"sha": "25cbb97e39e123a87b5be2449e53d71e2d22ecfc", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -35,9 +35,9 @@ pub trait FileSearch {\n     fn get_target_lib_file_path(&self, file: &Path) -> Path;\n }\n \n-pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n+pub fn mk_filesearch(maybe_sysroot: &Option<Path>,\n                      target_triple: &str,\n-                     +addl_lib_search_paths: ~[Path])\n+                     addl_lib_search_paths: ~[Path])\n                   -> @FileSearch {\n     struct FileSearchImpl {\n         sysroot: Path,\n@@ -117,8 +117,8 @@ fn get_or_default_sysroot() -> Path {\n     }\n }\n \n-fn get_sysroot(maybe_sysroot: Option<Path>) -> Path {\n-    match maybe_sysroot {\n+fn get_sysroot(maybe_sysroot: &Option<Path>) -> Path {\n+    match *maybe_sysroot {\n       option::Some(ref sr) => (/*bad*/copy *sr),\n       option::None => get_or_default_sysroot()\n     }"}, {"sha": "b21b6b4983bd252f2d433cb8b9077e680d881723", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -55,7 +55,7 @@ pub struct Context {\n     intr: @ident_interner\n }\n \n-pub fn load_library_crate(cx: Context) -> (~str, @~[u8]) {\n+pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n     match find_library_crate(cx) {\n       Some(ref t) => return (/*bad*/copy *t),\n       None => {\n@@ -66,12 +66,12 @@ pub fn load_library_crate(cx: Context) -> (~str, @~[u8]) {\n     }\n }\n \n-fn find_library_crate(cx: Context) -> Option<(~str, @~[u8])> {\n+fn find_library_crate(cx: &Context) -> Option<(~str, @~[u8])> {\n     attr::require_unique_names(cx.diag, cx.metas);\n     find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n \n-fn libname(cx: Context) -> (~str, ~str) {\n+fn libname(cx: &Context) -> (~str, ~str) {\n     if cx.is_static { return (~\"lib\", ~\".rlib\"); }\n     let (dll_prefix, dll_suffix) = match cx.os {\n         os_win32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n@@ -85,7 +85,7 @@ fn libname(cx: Context) -> (~str, ~str) {\n }\n \n fn find_library_crate_aux(\n-    cx: Context,\n+    cx: &Context,\n     (prefix, suffix): (~str, ~str),\n     filesearch: @filesearch::FileSearch\n ) -> Option<(~str, @~[u8])> {"}, {"sha": "0c290ac08a78e3400f2edbf7dd0047456dfcdb63", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -116,16 +116,16 @@ fn enc_mt(w: @io::Writer, cx: @ctxt, mt: ty::mt) {\n }\n \n fn enc_opt<T>(w: @io::Writer, t: Option<T>, enc_f: &fn(T)) {\n-    match &t {\n-      &None => w.write_char('n'),\n-      &Some(ref v) => {\n+    match t {\n+      None => w.write_char('n'),\n+      Some(v) => {\n         w.write_char('s');\n-        enc_f((*v));\n+        enc_f(v);\n       }\n     }\n }\n \n-fn enc_substs(w: @io::Writer, cx: @ctxt, substs: ty::substs) {\n+fn enc_substs(w: @io::Writer, cx: @ctxt, substs: &ty::substs) {\n     do enc_opt(w, substs.self_r) |r| { enc_region(w, cx, r) }\n     do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n     w.write_char('[');\n@@ -210,7 +210,7 @@ pub fn enc_vstore(w: @io::Writer, cx: @ctxt, v: ty::vstore) {\n pub fn enc_trait_ref(w: @io::Writer, cx: @ctxt, s: &ty::TraitRef) {\n     w.write_str((cx.ds)(s.def_id));\n     w.write_char('|');\n-    enc_substs(w, cx, s.substs);\n+    enc_substs(w, cx, &s.substs);\n }\n \n pub fn enc_trait_store(w: @io::Writer, cx: @ctxt, s: ty::TraitStore) {\n@@ -224,7 +224,7 @@ pub fn enc_trait_store(w: @io::Writer, cx: @ctxt, s: ty::TraitStore) {\n     }\n }\n \n-fn enc_sty(w: @io::Writer, cx: @ctxt, +st: ty::sty) {\n+fn enc_sty(w: @io::Writer, cx: @ctxt, st: ty::sty) {\n     match st {\n       ty::ty_nil => w.write_char('n'),\n       ty::ty_bot => w.write_char('z'),\n@@ -259,14 +259,14 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, +st: ty::sty) {\n         w.write_str(&\"t[\");\n         w.write_str((cx.ds)(def));\n         w.write_char('|');\n-        enc_substs(w, cx, (*substs));\n+        enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n       ty::ty_trait(def, ref substs, store, mt) => {\n         w.write_str(&\"x[\");\n         w.write_str((cx.ds)(def));\n         w.write_char('|');\n-        enc_substs(w, cx, (*substs));\n+        enc_substs(w, cx, substs);\n         enc_trait_store(w, cx, store);\n         enc_mutability(w, mt);\n         w.write_char(']');\n@@ -330,7 +330,7 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, +st: ty::sty) {\n           w.write_str(s);\n           debug!(\"~~~~ %s\", ~\"|\");\n           w.write_char('|');\n-          enc_substs(w, cx, (*substs));\n+          enc_substs(w, cx, substs);\n           debug!(\"~~~~ %s\", ~\"]\");\n           w.write_char(']');\n       }"}, {"sha": "7d4cb015106075c85ddb0b969372d592e03176ec", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -80,7 +80,7 @@ trait tr_intern {\n // Top-level methods.\n \n pub fn encode_inlined_item(ecx: @e::EncodeContext,\n-                           ebml_w: writer::Encoder,\n+                           ebml_w: &writer::Encoder,\n                            path: &[ast_map::path_elt],\n                            ii: ast::inlined_item,\n                            maps: Maps) {\n@@ -89,11 +89,11 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n            *ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n \n-    let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n+    let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n     do ebml_w.wr_tag(c::tag_ast as uint) {\n-        id_range.encode(&ebml_w);\n-        encode_ast(ebml_w, simplify_ast(ii));\n-        encode_side_tables_for_ii(ecx, maps, ebml_w, ii);\n+        id_range.encode(ebml_w);\n+        encode_ast(ebml_w, simplify_ast(&ii));\n+        encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n     }\n \n     debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n@@ -105,7 +105,7 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n-                           +path: ast_map::path,\n+                           path: ast_map::path,\n                            par_doc: ebml::Doc)\n                         -> Option<ast::inlined_item> {\n     let dcx = @DecodeContext {\n@@ -133,7 +133,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner),\n                *tcx.sess.str_of(ii.ident()));\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n-                                  dcx.tcx.items, path, ii);\n+                                  dcx.tcx.items, path, &ii);\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n           ast::ii_item(i) => {\n@@ -275,9 +275,9 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: writer::Encoder, item: ast::inlined_item) {\n+fn encode_ast(ebml_w: &writer::Encoder, item: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n-        item.encode(&ebml_w)\n+        item.encode(ebml_w)\n     }\n }\n \n@@ -291,7 +291,7 @@ fn encode_ast(ebml_w: writer::Encoder, item: ast::inlined_item) {\n // As it happens, trans relies on the fact that we do not export\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n-fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n+fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n     fn drop_nested_items(blk: &ast::blk_, fld: @fold::ast_fold) -> ast::blk_ {\n         let stmts_sans_items = do blk.stmts.filtered |stmt| {\n             match stmt.node {\n@@ -319,7 +319,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         .. *fold::default_ast_fold()\n     });\n \n-    match ii {\n+    match *ii {\n       ast::ii_item(i) => {\n         ast::ii_item(fld.fold_item(i).get()) //hack: we're not dropping items\n       }\n@@ -388,8 +388,8 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn encode_def(ebml_w: writer::Encoder, def: ast::def) {\n-    def.encode(&ebml_w)\n+fn encode_def(ebml_w: &writer::Encoder, def: ast::def) {\n+    def.encode(ebml_w)\n }\n \n fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n@@ -499,8 +499,8 @@ impl tr for ty::bound_region {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: writer::Encoder, fv: @freevar_entry) {\n-    (*fv).encode(&ebml_w)\n+fn encode_freevar_entry(ebml_w: &writer::Encoder, fv: @freevar_entry) {\n+    (*fv).encode(ebml_w)\n }\n \n trait ebml_decoder_helper {\n@@ -561,17 +561,17 @@ trait read_method_map_entry_helper {\n \n #[cfg(stage0)]\n fn encode_method_map_entry(ecx: @e::EncodeContext,\n-                              ebml_w: writer::Encoder,\n+                              ebml_w: &writer::Encoder,\n                               mme: method_map_entry) {\n     do ebml_w.emit_struct(\"method_map_entry\", 3) {\n         do ebml_w.emit_field(~\"self_arg\", 0u) {\n             ebml_w.emit_arg(ecx, mme.self_arg);\n         }\n         do ebml_w.emit_field(~\"explicit_self\", 2u) {\n-            mme.explicit_self.encode(&ebml_w);\n+            mme.explicit_self.encode(ebml_w);\n         }\n         do ebml_w.emit_field(~\"origin\", 1u) {\n-            mme.origin.encode(&ebml_w);\n+            mme.origin.encode(ebml_w);\n         }\n     }\n }\n@@ -580,17 +580,17 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n #[cfg(stage2)]\n #[cfg(stage3)]\n fn encode_method_map_entry(ecx: @e::EncodeContext,\n-                              ebml_w: writer::Encoder,\n+                              ebml_w: &writer::Encoder,\n                               mme: method_map_entry) {\n     do ebml_w.emit_struct(\"method_map_entry\", 3) {\n         do ebml_w.emit_struct_field(\"self_arg\", 0u) {\n             ebml_w.emit_arg(ecx, mme.self_arg);\n         }\n         do ebml_w.emit_struct_field(\"explicit_self\", 2u) {\n-            mme.explicit_self.encode(&ebml_w);\n+            mme.explicit_self.encode(ebml_w);\n         }\n         do ebml_w.emit_struct_field(\"origin\", 1u) {\n-            mme.origin.encode(&ebml_w);\n+            mme.origin.encode(ebml_w);\n         }\n     }\n }\n@@ -672,22 +672,22 @@ impl tr for method_origin {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res(ecx: @e::EncodeContext,\n-                     ebml_w: writer::Encoder,\n+                     ebml_w: &writer::Encoder,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n     do ebml_w.emit_from_vec(*dr) |vtable_origin| {\n-        encode_vtable_origin(ecx, ebml_w, *vtable_origin)\n+        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n     }\n }\n \n fn encode_vtable_origin(ecx: @e::EncodeContext,\n-                      ebml_w: writer::Encoder,\n-                      vtable_origin: typeck::vtable_origin) {\n+                        ebml_w: &writer::Encoder,\n+                        vtable_origin: &typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n-        match vtable_origin {\n+        match *vtable_origin {\n           typeck::vtable_static(def_id, ref tys, vtable_res) => {\n             do ebml_w.emit_enum_variant(~\"vtable_static\", 0u, 3u) {\n                 do ebml_w.emit_enum_variant_arg(0u) {\n@@ -798,13 +798,13 @@ trait ebml_writer_helpers {\n impl ebml_writer_helpers for writer::Encoder {\n     fn emit_ty(&self, ecx: @e::EncodeContext, ty: ty::t) {\n         do self.emit_opaque {\n-            e::write_type(ecx, *self, ty)\n+            e::write_type(ecx, self, ty)\n         }\n     }\n \n     fn emit_vstore(&self, ecx: @e::EncodeContext, vstore: ty::vstore) {\n         do self.emit_opaque {\n-            e::write_vstore(ecx, *self, vstore)\n+            e::write_vstore(ecx, self, vstore)\n         }\n     }\n \n@@ -897,24 +897,25 @@ impl write_tag_and_id for writer::Encoder {\n \n fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n                              maps: Maps,\n-                             ebml_w: writer::Encoder,\n-                             ii: ast::inlined_item) {\n+                             ebml_w: &writer::Encoder,\n+                             ii: &ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_table as uint) {\n-        let ebml_w = copy ebml_w;\n+        let ebml_w = copy *ebml_w;\n         ast_util::visit_ids_for_inlined_item(\n             ii,\n             |id: ast::node_id| {\n                 // Note: this will cause a copy of ebml_w, which is bad as\n                 // it has mut fields.  But I believe it's harmless since\n                 // we generate balanced EBML.\n-                encode_side_tables_for_id(ecx, maps, ebml_w, id)\n+                /*let ebml_w = copy ebml_w;*/\n+                encode_side_tables_for_id(ecx, maps, &ebml_w, id)\n             });\n     }\n }\n \n fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n                              maps: Maps,\n-                             ebml_w: writer::Encoder,\n+                             ebml_w: &writer::Encoder,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n@@ -924,7 +925,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         do ebml_w.tag(c::tag_table_def) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                (*def).encode(&ebml_w)\n+                (*def).encode(ebml_w)\n             }\n         }\n     }\n@@ -1004,7 +1005,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n                 do ebml_w.emit_from_vec(/*bad*/ copy **m) |id| {\n-                    id.encode(&ebml_w);\n+                    id.encode(ebml_w);\n                 }\n             }\n         }\n@@ -1032,7 +1033,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         do ebml_w.tag(c::tag_table_adjustments) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                (**adj).encode(&ebml_w)\n+                (**adj).encode(ebml_w)\n             }\n         }\n     }\n@@ -1048,7 +1049,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n                 do ebml_w.emit_from_vec(*cap_vars) |cap_var| {\n-                    cap_var.encode(&ebml_w);\n+                    cap_var.encode(ebml_w);\n                 }\n             }\n         }\n@@ -1279,9 +1280,9 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: writer::Encoder, item: @ast::item) {\n+fn encode_item_ast(ebml_w: &writer::Encoder, item: @ast::item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n-        (*item).encode(&ebml_w)\n+        (*item).encode(ebml_w)\n     }\n }\n \n@@ -1297,7 +1298,7 @@ trait fake_ext_ctxt {\n     fn cfg(&self) -> ast::crate_cfg;\n     fn parse_sess(&self) -> @mut parse::ParseSess;\n     fn call_site(&self) -> span;\n-    fn ident_of(&self, +st: ~str) -> ast::ident;\n+    fn ident_of(&self, st: ~str) -> ast::ident;\n }\n \n #[cfg(test)]\n@@ -1314,7 +1315,7 @@ impl fake_ext_ctxt for fake_session {\n             expn_info: None\n         }\n     }\n-    fn ident_of(&self, +st: ~str) -> ast::ident {\n+    fn ident_of(&self, st: ~str) -> ast::ident {\n         self.interner.intern(@st)\n     }\n }\n@@ -1331,7 +1332,7 @@ fn roundtrip(in_item: Option<@ast::item>) {\n     let in_item = in_item.get();\n     let bytes = do io::with_bytes_writer |wr| {\n         let ebml_w = writer::Encoder(wr);\n-        encode_item_ast(ebml_w, in_item);\n+        encode_item_ast(&ebml_w, in_item);\n     };\n     let ebml_doc = reader::Doc(@bytes);\n     let out_item = decode_item_ast(ebml_doc);\n@@ -1375,7 +1376,7 @@ fn test_simplification() {\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n     ).get());\n-    let item_out = simplify_ast(item_in);\n+    let item_out = simplify_ast(&item_in);\n     let item_exp = ast::ii_item(quote_item!(\n         fn new_int_alist<B:Copy>() -> alist<int, B> {\n             return alist {eq_fn: eq_int, data: ~[]};"}, {"sha": "4766fe1fb94a985393d73c72c34985ac8389dec5", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -79,7 +79,7 @@ enum impurity_cause {\n }\n \n pub fn check_loans(bccx: @BorrowckCtxt,\n-                   +req_maps: ReqMaps,\n+                   req_maps: ReqMaps,\n                    crate: @ast::crate) {\n     let clcx = @mut CheckLoanCtxt {\n         bccx: bccx,\n@@ -94,7 +94,7 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n                                            visit_block: check_loans_in_block,\n                                            visit_fn: check_loans_in_fn,\n                                            .. *visit::default_visitor()});\n-    visit::visit_crate(*crate, clcx, vt);\n+    visit::visit_crate(crate, clcx, vt);\n }\n \n #[deriving(Eq)]\n@@ -619,7 +619,7 @@ fn check_loans_in_fn(fk: &visit::fn_kind,\n                      body: &ast::blk,\n                      sp: span,\n                      id: ast::node_id,\n-                     &&self: @mut CheckLoanCtxt,\n+                     self: @mut CheckLoanCtxt,\n                      visitor: visit::vt<@mut CheckLoanCtxt>) {\n     let is_stack_closure = self.is_stack_closure(id);\n     let fty = ty::node_id_to_type(self.tcx(), id);\n@@ -726,13 +726,13 @@ fn check_loans_in_fn(fk: &visit::fn_kind,\n }\n \n fn check_loans_in_local(local: @ast::local,\n-                        &&self: @mut CheckLoanCtxt,\n+                        self: @mut CheckLoanCtxt,\n                         vt: visit::vt<@mut CheckLoanCtxt>) {\n     visit::visit_local(local, self, vt);\n }\n \n fn check_loans_in_expr(expr: @ast::expr,\n-                       &&self: @mut CheckLoanCtxt,\n+                       self: @mut CheckLoanCtxt,\n                        vt: visit::vt<@mut CheckLoanCtxt>) {\n     debug!(\"check_loans_in_expr(expr=%?/%s)\",\n            expr.id, pprust::expr_to_str(expr, self.tcx().sess.intr()));\n@@ -794,7 +794,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n }\n \n fn check_loans_in_block(blk: &ast::blk,\n-                        &&self: @mut CheckLoanCtxt,\n+                        self: @mut CheckLoanCtxt,\n                         vt: visit::vt<@mut CheckLoanCtxt>) {\n     do save_and_restore_managed(self.declared_purity) {\n         self.check_for_conflicting_loans(blk.node.id);"}, {"sha": "4f2e41dca5c0473319d78559ebd4557f5a35987e", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -88,7 +88,7 @@ pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> ReqMaps {\n                                           visit_fn: req_loans_in_fn,\n                                           visit_stmt: add_stmt_to_map,\n                                           .. *visit::default_visitor()});\n-    visit::visit_crate(*crate, glcx, v);\n+    visit::visit_crate(crate, glcx, v);\n     let @GatherLoanCtxt{req_maps, _} = glcx;\n     return req_maps;\n }\n@@ -98,7 +98,7 @@ fn req_loans_in_fn(fk: &visit::fn_kind,\n                    body: &ast::blk,\n                    sp: span,\n                    id: ast::node_id,\n-                   &&self: @mut GatherLoanCtxt,\n+                   self: @mut GatherLoanCtxt,\n                    v: visit::vt<@mut GatherLoanCtxt>) {\n     // see explanation attached to the `root_ub` field:\n     let old_item_id = self.item_ub;\n@@ -119,7 +119,7 @@ fn req_loans_in_fn(fk: &visit::fn_kind,\n }\n \n fn req_loans_in_expr(ex: @ast::expr,\n-                     &&self: @mut GatherLoanCtxt,\n+                     self: @mut GatherLoanCtxt,\n                      vt: visit::vt<@mut GatherLoanCtxt>) {\n     let bccx = self.bccx;\n     let tcx = bccx.tcx;\n@@ -489,7 +489,7 @@ pub impl GatherLoanCtxt {\n                  cmt: cmt,\n                  loan_kind: LoanKind,\n                  scope_r: ty::Region,\n-                 +loans: ~[Loan]) {\n+                 loans: ~[Loan]) {\n         if loans.len() == 0 {\n             return;\n         }\n@@ -555,7 +555,7 @@ pub impl GatherLoanCtxt {\n \n     fn add_loans_to_scope_id(&mut self,\n                              scope_id: ast::node_id,\n-                             +loans: ~[Loan]) {\n+                             loans: ~[Loan]) {\n         debug!(\"adding %u loans to scope_id %?: %s\",\n                loans.len(), scope_id,\n                str::connect(loans.map(|l| self.bccx.loan_to_repr(l)), \", \"));\n@@ -665,7 +665,7 @@ pub impl GatherLoanCtxt {\n // Setting up info that preserve needs.\n // This is just the most convenient place to do it.\n fn add_stmt_to_map(stmt: @ast::stmt,\n-                   &&self: @mut GatherLoanCtxt,\n+                   self: @mut GatherLoanCtxt,\n                    vt: visit::vt<@mut GatherLoanCtxt>) {\n     match stmt.node {\n         ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {"}, {"sha": "15189a552fb0c4bed9e8c092bc734f4ff92d3f48", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -257,10 +257,10 @@ pub impl LoanContext {\n     }\n \n     fn issue_loan(&mut self,\n-                  +cmt: cmt,\n-                  +scope_ub: ty::Region,\n-                  +loan_kind: LoanKind,\n-                  +owns_lent_data: bool) -> bckres<()> {\n+                  cmt: cmt,\n+                  scope_ub: ty::Region,\n+                  loan_kind: LoanKind,\n+                  owns_lent_data: bool) -> bckres<()> {\n         // Subtle: the `scope_ub` is the maximal lifetime of `cmt`.\n         // Therefore, if `cmt` owns the data being lent, then the\n         // scope of the loan must be less than `scope_ub`, or else the"}, {"sha": "dec194aa8e3b950fa71dccca816c2336c13abd43", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -443,7 +443,7 @@ pub impl LoanKind {\n /// Creates and returns a new root_map\n \n impl to_bytes::IterBytes for root_map_key {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n     }\n }\n@@ -529,11 +529,11 @@ pub impl BorrowckCtxt {\n         self.note_and_explain_bckerr(err);\n     }\n \n-    fn span_err(&self, s: span, +m: ~str) {\n+    fn span_err(&self, s: span, m: ~str) {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    fn span_note(&self, s: span, +m: ~str) {\n+    fn span_note(&self, s: span, m: ~str) {\n         self.tcx.sess.span_note(s, m);\n     }\n "}, {"sha": "1953841e650814212fcca75402699ba3086446e4", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -26,7 +26,7 @@ pub fn check_crate(sess: Session,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::method_map,\n                    tcx: ty::ctxt) {\n-    visit::visit_crate(*crate, false, visit::mk_vt(@visit::Visitor {\n+    visit::visit_crate(crate, false, visit::mk_vt(@visit::Visitor {\n         visit_item: |a,b,c| check_item(sess, ast_map, def_map, a, b, c),\n         visit_pat: check_pat,\n         visit_expr: |a,b,c|\n@@ -40,7 +40,7 @@ pub fn check_item(sess: Session,\n                   ast_map: ast_map::map,\n                   def_map: resolve::DefMap,\n                   it: @item,\n-                  &&_is_const: bool,\n+                  _is_const: bool,\n                   v: visit::vt<bool>) {\n     match it.node {\n       item_const(_, ex) => {\n@@ -58,7 +58,7 @@ pub fn check_item(sess: Session,\n     }\n }\n \n-pub fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n+pub fn check_pat(p: @pat, _is_const: bool, v: visit::vt<bool>) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n             expr_vstore(\n@@ -87,7 +87,7 @@ pub fn check_expr(sess: Session,\n                   method_map: typeck::method_map,\n                   tcx: ty::ctxt,\n                   e: @expr,\n-                  &&is_const: bool,\n+                  is_const: bool,\n                   v: visit::vt<bool>) {\n     if is_const {\n         match e.node {\n@@ -224,7 +224,7 @@ pub fn check_item_recursion(sess: Session,\n     });\n     (visitor.visit_item)(it, env, visitor);\n \n-    fn visit_item(it: @item, &&env: env, v: visit::vt<env>) {\n+    fn visit_item(it: @item, env: env, v: visit::vt<env>) {\n         if env.idstack.contains(&(it.id)) {\n             env.sess.span_fatal(env.root_it.span, ~\"recursive constant\");\n         }\n@@ -233,7 +233,7 @@ pub fn check_item_recursion(sess: Session,\n         env.idstack.pop();\n     }\n \n-    fn visit_expr(e: @expr, &&env: env, v: visit::vt<env>) {\n+    fn visit_expr(e: @expr, env: env, v: visit::vt<env>) {\n         match e.node {\n           expr_path(*) => {\n             match env.def_map.find(&e.id) {"}, {"sha": "9f26f7f83724f0276d03789a92767a2d6c21a9a3", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -20,7 +20,7 @@ pub struct Context {\n }\n \n pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n-    visit::visit_crate(*crate,\n+    visit::visit_crate(crate,\n                        Context { in_loop: false, can_ret: true },\n                        visit::mk_vt(@visit::Visitor {\n         visit_item: |i, _cx, v| {"}, {"sha": "1db8f8cc8de8127f971a51a63fe000047fb1391d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -40,7 +40,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     let cx = @MatchCheckCtxt {tcx: tcx,\n                               method_map: method_map,\n                               moves_map: moves_map};\n-    visit::visit_crate(*crate, (), visit::mk_vt(@visit::Visitor {\n+    visit::visit_crate(crate, (), visit::mk_vt(@visit::Visitor {\n         visit_expr: |a,b,c| check_expr(cx, a, b, c),\n         visit_local: |a,b,c| check_local(cx, a, b, c),\n         visit_fn: |kind, decl, body, sp, id, e, v|\n@@ -58,7 +58,7 @@ pub fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n     !cx.moves_map.contains(&expr.id)\n }\n \n-pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n+pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n@@ -259,7 +259,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 not_useful\n               }\n               _ => {\n-                let arity = ctor_arity(cx, single, left_ty);\n+                let arity = ctor_arity(cx, &single, left_ty);\n                 is_useful_specialized(cx, m, v, single, arity, left_ty)\n               }\n             }\n@@ -268,14 +268,14 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n             match is_useful(cx,\n                             &m.filter_mapped(|r| default(cx, *r)),\n                             v.tail()) {\n-              useful_ => useful(left_ty, (/*bad*/copy *ctor)),\n+              useful_ => useful(left_ty, /*bad*/copy *ctor),\n               ref u => (/*bad*/copy *u)\n             }\n           }\n         }\n       }\n       Some(ref v0_ctor) => {\n-        let arity = ctor_arity(cx, (*v0_ctor), left_ty);\n+        let arity = ctor_arity(cx, v0_ctor, left_ty);\n         is_useful_specialized(cx, m, v, /*bad*/copy *v0_ctor, arity, left_ty)\n       }\n     }\n@@ -284,13 +284,13 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n                              m: &matrix,\n                              v: &[@pat],\n-                             +ctor: ctor,\n+                             ctor: ctor,\n                              arity: uint,\n                              lty: ty::t)\n                           -> useful {\n-    let ms = m.filter_mapped(|r| specialize(cx, *r, ctor, arity, lty));\n+    let ms = m.filter_mapped(|r| specialize(cx, *r, &ctor, arity, lty));\n     let could_be_useful = is_useful(\n-        cx, &ms, specialize(cx, v, ctor, arity, lty).get());\n+        cx, &ms, specialize(cx, v, &ctor, arity, lty).get());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n       ref u => (/*bad*/copy *u)\n@@ -447,12 +447,12 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n     }\n }\n \n-pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n+pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n     match ty::get(ty).sty {\n       ty::ty_tup(ref fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n       ty::ty_enum(eid, _) => {\n-          let id = match ctor { variant(id) => id,\n+          let id = match *ctor { variant(id) => id,\n           _ => fail!(~\"impossible case\") };\n         match vec::find(*ty::enum_variants(cx.tcx, eid), |v| v.id == id ) {\n             Some(v) => v.args.len(),\n@@ -461,7 +461,7 @@ pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n       }\n       ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n       ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n-        match ctor {\n+        match *ctor {\n           vec(n) => n,\n           _ => 0u\n         }\n@@ -476,7 +476,7 @@ pub fn wild() -> @pat {\n \n pub fn specialize(cx: @MatchCheckCtxt,\n                   r: &[@pat],\n-                  ctor_id: ctor,\n+                  ctor_id: &ctor,\n                   arity: uint,\n                   left_ty: ty::t)\n                -> Option<~[@pat]> {\n@@ -491,7 +491,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             pat_ident(_, _, _) => {\n                 match cx.tcx.def_map.find(&pat_id) {\n                     Some(&def_variant(_, id)) => {\n-                        if variant(id) == ctor_id {\n+                        if variant(id) == *ctor_id {\n                             Some(vec::from_slice(r.tail()))\n                         } else {\n                             None\n@@ -501,11 +501,11 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n-                        let match_ = match ctor_id {\n-                            val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n+                        let match_ = match *ctor_id {\n+                            val(ref v) => compare_const_vals(&e_v, v) == 0,\n                             range(ref c_lo, ref c_hi) => {\n-                                compare_const_vals((*c_lo), e_v) >= 0 &&\n-                                    compare_const_vals((*c_hi), e_v) <= 0\n+                                compare_const_vals(c_lo, &e_v) >= 0 &&\n+                                    compare_const_vals(c_hi, &e_v) <= 0\n                             }\n                             single => true,\n                             _ => fail!(~\"type error\")\n@@ -532,11 +532,11 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n-                        let match_ = match ctor_id {\n-                            val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n+                        let match_ = match *ctor_id {\n+                            val(ref v) => compare_const_vals(&e_v, v) == 0,\n                             range(ref c_lo, ref c_hi) => {\n-                                compare_const_vals((*c_lo), e_v) >= 0 &&\n-                                    compare_const_vals((*c_hi), e_v) <= 0\n+                                compare_const_vals(c_lo, &e_v) >= 0 &&\n+                                    compare_const_vals(c_hi, &e_v) <= 0\n                             }\n                             single => true,\n                             _ => fail!(~\"type error\")\n@@ -547,7 +547,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             None\n                         }\n                     }\n-                    def_variant(_, id) if variant(id) == ctor_id => {\n+                    def_variant(_, id) if variant(id) == *ctor_id => {\n                         let args = match args {\n                             Some(args) => args,\n                             None => vec::from_elem(arity, wild())\n@@ -571,7 +571,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 // Is this a struct or an enum variant?\n                 match *cx.tcx.def_map.get(&pat_id) {\n                     def_variant(_, variant_id) => {\n-                        if variant(variant_id) == ctor_id {\n+                        if variant(variant_id) == *ctor_id {\n                             // FIXME #4731: Is this right? --pcw\n                             let args = flds.map(|ty_field| {\n                                 match flds.find(|f|\n@@ -620,19 +620,19 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             }\n             pat_lit(expr) => {\n                 let e_v = eval_const_expr(cx.tcx, expr);\n-                let match_ = match ctor_id {\n-                    val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n+                let match_ = match *ctor_id {\n+                    val(ref v) => compare_const_vals(&e_v, v) == 0,\n                     range(ref c_lo, ref c_hi) => {\n-                        compare_const_vals((*c_lo), e_v) >= 0 &&\n-                            compare_const_vals((*c_hi), e_v) <= 0\n+                        compare_const_vals(c_lo, &e_v) >= 0 &&\n+                            compare_const_vals(c_hi, &e_v) <= 0\n                     }\n                     single => true,\n                     _ => fail!(~\"type error\")\n                 };\n                 if match_ { Some(vec::from_slice(r.tail())) } else { None }\n             }\n             pat_range(lo, hi) => {\n-                let (c_lo, c_hi) = match ctor_id {\n+                let (c_lo, c_hi) = match *ctor_id {\n                     val(ref v) => ((/*bad*/copy *v), (/*bad*/copy *v)),\n                     range(ref lo, ref hi) =>\n                         ((/*bad*/copy *lo), (/*bad*/copy *hi)),\n@@ -641,12 +641,12 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo),\n                 v_hi = eval_const_expr(cx.tcx, hi);\n-                let match_ = compare_const_vals(c_lo, v_lo) >= 0 &&\n-                    compare_const_vals(c_hi, v_hi) <= 0;\n+                let match_ = compare_const_vals(&c_lo, &v_lo) >= 0 &&\n+                    compare_const_vals(&c_hi, &v_hi) <= 0;\n           if match_ { Some(vec::from_slice(r.tail())) } else { None }\n       }\n             pat_vec(before, slice, after) => {\n-                match ctor_id {\n+                match *ctor_id {\n                     vec(_) => {\n                         let num_elements = before.len() + after.len();\n                         if num_elements < arity && slice.is_some() {\n@@ -682,7 +682,7 @@ pub fn default(cx: @MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n \n pub fn check_local(cx: @MatchCheckCtxt,\n                    loc: @local,\n-                   &&s: (),\n+                   s: (),\n                    v: visit::vt<()>) {\n     visit::visit_local(loc, s, v);\n     if is_refutable(cx, loc.node.pat) {\n@@ -704,7 +704,7 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n                 body: &blk,\n                 sp: span,\n                 id: node_id,\n-                &&s: (),\n+                s: (),\n                 v: visit::vt<()>) {\n     visit::visit_fn(kind, decl, body, sp, id, s, v);\n     for decl.inputs.each |input| {"}, {"sha": "5148ea7fba4030a9e060420323fcc7b83ff6a1e7", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -229,7 +229,7 @@ pub fn process_crate(crate: @ast::crate,\n         visit_expr_post: |e| { classify(e, tcx); },\n         .. *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(*crate, (), v);\n+    visit::visit_crate(crate, (), v);\n     tcx.sess.abort_if_errors();\n }\n \n@@ -426,8 +426,8 @@ pub fn lit_to_const(lit: @lit) -> const_val {\n     }\n }\n \n-pub fn compare_const_vals(a: const_val, b: const_val) -> int {\n-  match (&a, &b) {\n+pub fn compare_const_vals(a: &const_val, b: &const_val) -> int {\n+  match (a, b) {\n     (&const_int(a), &const_int(b)) => {\n         if a == b {\n             0\n@@ -478,15 +478,15 @@ pub fn compare_const_vals(a: const_val, b: const_val) -> int {\n }\n \n pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> int {\n-  compare_const_vals(eval_const_expr(tcx, a), eval_const_expr(tcx, b))\n+  compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n }\n \n pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> bool {\n     compare_lit_exprs(tcx, a, b) == 0\n }\n \n pub fn lit_eq(a: @lit, b: @lit) -> bool {\n-    compare_const_vals(lit_to_const(a), lit_to_const(b)) == 0\n+    compare_const_vals(&lit_to_const(a), &lit_to_const(b)) == 0\n }\n \n "}, {"sha": "b25c3be0d683df7aad519dc09947cb009d44d02d", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -42,9 +42,9 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n     let seen = @mut HashMap::new();\n     let refs = @mut ~[];\n \n-    fn ignore_item(_i: @ast::item, &&_depth: int, _v: visit::vt<int>) { }\n+    fn ignore_item(_i: @ast::item, _depth: int, _v: visit::vt<int>) { }\n \n-    let walk_expr: @fn(expr: @ast::expr, &&depth: int, v: visit::vt<int>) =\n+    let walk_expr: @fn(expr: @ast::expr, depth: int, v: visit::vt<int>) =\n         |expr, depth, v| {\n             match expr.node {\n               ast::expr_fn_block(*) => visit::visit_expr(expr, depth + 1, v),\n@@ -107,7 +107,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_fn: walk_fn,\n             .. *visit::default_simple_visitor()});\n-    visit::visit_crate(*crate, (), visitor);\n+    visit::visit_crate(crate, (), visitor);\n \n     return freevars;\n }"}, {"sha": "390ffded2fe36f10183add36869ed86b98f5cfde", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -81,7 +81,7 @@ pub fn check_crate(tcx: ty::ctxt,\n         visit_block: check_block,\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(*crate, ctx, visit);\n+    visit::visit_crate(crate, ctx, visit);\n     tcx.sess.abort_if_errors();\n }\n \n@@ -573,7 +573,7 @@ pub fn check_cast_for_escaping_regions(\n             true\n         });\n \n-    fn is_re_scope(+r: ty::Region) -> bool {\n+    fn is_re_scope(r: ty::Region) -> bool {\n         match r {\n             ty::re_scope(*) => true,\n             _ => false"}, {"sha": "435cb896ac7a18ddcdfe16006300d471159b6862", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -370,7 +370,7 @@ pub impl<'self> LanguageItemCollector<'self> {\n \n     fn collect_local_language_items(&self) {\n         let this = ptr::addr_of(&self);\n-        visit_crate(*self.crate, (), mk_simple_visitor(@SimpleVisitor {\n+        visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n                 for item.attrs.each |attribute| {\n                     unsafe {"}, {"sha": "39144d46c83c48d7c99d526271c6936fc94a189b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -348,7 +348,7 @@ pub impl Context {\n         }\n     }\n \n-    fn span_lint(&self, level: level, span: span, +msg: ~str) {\n+    fn span_lint(&self, level: level, span: span, msg: ~str) {\n         self.sess.span_lint_level(level, span, msg);\n     }\n \n@@ -438,7 +438,7 @@ pub impl Context {\n }\n \n \n-fn build_settings_item(i: @ast::item, &&cx: Context, v: visit::vt<Context>) {\n+fn build_settings_item(i: @ast::item, cx: Context, v: visit::vt<Context>) {\n     do cx.with_lint_attrs(/*bad*/copy i.attrs) |cx| {\n         if !cx.is_default {\n             cx.sess.lint_settings.settings_map.insert(i.id, cx.curr);\n@@ -481,7 +481,7 @@ pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n             visit_item: build_settings_item,\n             .. *visit::default_visitor()\n         });\n-        visit::visit_crate(*crate, cx, visit);\n+        visit::visit_crate(crate, cx, visit);\n     }\n \n     sess.abort_if_errors();\n@@ -1088,7 +1088,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n             check_fn(tcx, fk, decl, body, span, id),\n         .. *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(*crate, (), v);\n+    visit::visit_crate(crate, (), v);\n \n     tcx.sess.abort_if_errors();\n }"}, {"sha": "3136d7bf4e4ac345ae33bb8afd8780304d62c9a1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -182,7 +182,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                                    capture_map,\n                                    last_use_map,\n                                    0);\n-    visit::visit_crate(*crate, initial_maps, visitor);\n+    visit::visit_crate(crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n     return last_use_map;\n }\n@@ -358,7 +358,7 @@ pub impl IrMaps {\n         }\n     }\n \n-    fn set_captures(&mut self, node_id: node_id, +cs: ~[CaptureInfo]) {\n+    fn set_captures(&mut self, node_id: node_id, cs: ~[CaptureInfo]) {\n         self.capture_info_map.insert(node_id, @cs);\n     }\n \n@@ -402,7 +402,7 @@ pub impl IrMaps {\n     }\n }\n \n-fn visit_item(item: @item, &&self: @mut IrMaps, v: vt<@mut IrMaps>) {\n+fn visit_item(item: @item, self: @mut IrMaps, v: vt<@mut IrMaps>) {\n     do with(&mut self.cur_item, item.id) {\n         visit::visit_item(item, self, v)\n     }\n@@ -413,7 +413,7 @@ fn visit_fn(fk: &visit::fn_kind,\n             body: &blk,\n             sp: span,\n             id: node_id,\n-            &&self: @mut IrMaps,\n+            self: @mut IrMaps,\n             v: vt<@mut IrMaps>) {\n     debug!(\"visit_fn: id=%d\", id);\n     let _i = ::util::common::indenter();\n@@ -489,7 +489,7 @@ fn visit_fn(fk: &visit::fn_kind,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(local: @local, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_local(local: @local, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     let def_map = self.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.node.pat) |_bm, p_id, sp, path| {\n         debug!(\"adding local variable %d\", p_id);\n@@ -509,7 +509,7 @@ fn visit_local(local: @local, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn visit_arm(arm: &arm, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_arm(arm: &arm, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     let def_map = self.tcx.def_map;\n     for arm.pats.each |pat| {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n@@ -528,7 +528,7 @@ fn visit_arm(arm: &arm, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     visit::visit_arm(arm, self, vt);\n }\n \n-fn visit_expr(expr: @expr, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_expr(expr: @expr, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) => {\n@@ -1510,7 +1510,7 @@ pub impl Liveness {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(local: @local, &&self: @Liveness, vt: vt<@Liveness>) {\n+fn check_local(local: @local, self: @Liveness, vt: vt<@Liveness>) {\n     match local.node.init {\n       Some(_) => {\n \n@@ -1544,14 +1544,14 @@ fn check_local(local: @local, &&self: @Liveness, vt: vt<@Liveness>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn check_arm(arm: &arm, &&self: @Liveness, vt: vt<@Liveness>) {\n+fn check_arm(arm: &arm, self: @Liveness, vt: vt<@Liveness>) {\n     do self.arm_pats_bindings(arm.pats) |ln, var, sp, id| {\n         self.warn_about_unused(sp, id, ln, var);\n     }\n     visit::visit_arm(arm, self, vt);\n }\n \n-fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n+fn check_expr(expr: @expr, self: @Liveness, vt: vt<@Liveness>) {\n     match expr.node {\n       expr_path(_) => {\n         for self.variable_from_def_map(expr.id, expr.span).each |var| {\n@@ -1632,7 +1632,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n \n fn check_fn(_fk: &visit::fn_kind, _decl: &fn_decl,\n             _body: &blk, _sp: span, _id: node_id,\n-            &&_self: @Liveness, _v: vt<@Liveness>) {\n+            _self: @Liveness, _v: vt<@Liveness>) {\n     // do not check contents of nested fns\n }\n "}, {"sha": "66ce4d16d4bc273ab251109e187e29adce9f7054", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -285,15 +285,15 @@ pub fn compute_moves(tcx: ty::ctxt,\n             capture_map: @mut HashMap::new()\n         }\n     };\n-    visit::visit_crate(*crate, visit_cx, visitor);\n+    visit::visit_crate(crate, visit_cx, visitor);\n     return visit_cx.move_maps;\n }\n \n // ______________________________________________________________________\n // Expressions\n \n fn compute_modes_for_expr(expr: @expr,\n-                          &&cx: VisitContext,\n+                          cx: VisitContext,\n                           v: vt<VisitContext>)\n {\n     cx.consume_expr(expr, v);\n@@ -760,7 +760,7 @@ pub impl VisitContext {\n \n     fn arms_have_by_move_bindings(&self,\n                                   moves_map: MovesMap,\n-                                  +arms: &[arm]) -> bool\n+                                  arms: &[arm]) -> bool\n     {\n         for arms.each |arm| {\n             for arm.pats.each |pat| {"}, {"sha": "89dad7fc01c10f787abcebb15517b59e90fe59c6", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -604,6 +604,6 @@ pub fn check_crate(tcx: ty::ctxt,\n         },\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(*crate, method_map, visitor);\n+    visit::visit_crate(crate, method_map, visitor);\n }\n "}, {"sha": "043aa8d2533fa7a8b22b50eda86025b9bbb3923a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -496,7 +496,7 @@ pub fn resolve_crate(sess: Session,\n         visit_local: resolve_local,\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(*crate, cx, visitor);\n+    visit::visit_crate(crate, cx, visitor);\n     return region_maps;\n }\n \n@@ -549,8 +549,8 @@ pub struct DetermineRpCtxt {\n     ambient_variance: region_variance,\n }\n \n-pub fn join_variance(++variance1: region_variance,\n-                     ++variance2: region_variance)\n+pub fn join_variance(variance1: region_variance,\n+                     variance2: region_variance)\n                   -> region_variance {\n     match (variance1, variance2) {\n       (rv_invariant, _) => {rv_invariant}\n@@ -570,8 +570,8 @@ pub fn join_variance(++variance1: region_variance,\n /// appears in a co-variant position.  This implies that this\n /// occurrence of `r` is contra-variant with respect to the current\n /// item, and hence the function returns `rv_contravariant`.\n-pub fn add_variance(+ambient_variance: region_variance,\n-                    +variance: region_variance)\n+pub fn add_variance(ambient_variance: region_variance,\n+                    variance: region_variance)\n                  -> region_variance {\n     match (ambient_variance, variance) {\n       (rv_invariant, _) => rv_invariant,\n@@ -719,7 +719,7 @@ pub impl DetermineRpCtxt {\n }\n \n pub fn determine_rp_in_item(item: @ast::item,\n-                            &&cx: @mut DetermineRpCtxt,\n+                            cx: @mut DetermineRpCtxt,\n                             visitor: visit::vt<@mut DetermineRpCtxt>) {\n     do cx.with(item.id, true) {\n         visit::visit_item(item, cx, visitor);\n@@ -731,7 +731,7 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n                           body: &ast::blk,\n                           _: span,\n                           _: ast::node_id,\n-                          &&cx: @mut DetermineRpCtxt,\n+                          cx: @mut DetermineRpCtxt,\n                           visitor: visit::vt<@mut DetermineRpCtxt>) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n@@ -747,15 +747,15 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n }\n \n pub fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n-                                 &&cx: @mut DetermineRpCtxt,\n+                                 cx: @mut DetermineRpCtxt,\n                                  visitor: visit::vt<@mut DetermineRpCtxt>) {\n     do cx.with(cx.item_id, false) {\n         visit::visit_ty_method(ty_m, cx, visitor);\n     }\n }\n \n pub fn determine_rp_in_ty(ty: @ast::Ty,\n-                          &&cx: @mut DetermineRpCtxt,\n+                          cx: @mut DetermineRpCtxt,\n                           visitor: visit::vt<@mut DetermineRpCtxt>) {\n     // we are only interested in types that will require an item to\n     // be region-parameterized.  if cx.item_id is zero, then this type\n@@ -871,7 +871,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     }\n \n     fn visit_mt(mt: ast::mt,\n-                &&cx: @mut DetermineRpCtxt,\n+                cx: @mut DetermineRpCtxt,\n                 visitor: visit::vt<@mut DetermineRpCtxt>) {\n         // mutability is invariant\n         if mt.mutbl == ast::m_mutbl {\n@@ -886,7 +886,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n \n pub fn determine_rp_in_struct_field(\n         cm: @ast::struct_field,\n-        &&cx: @mut DetermineRpCtxt,\n+        cx: @mut DetermineRpCtxt,\n         visitor: visit::vt<@mut DetermineRpCtxt>) {\n     match cm.node.kind {\n       ast::named_field(_, ast::struct_mutable, _) => {\n@@ -903,7 +903,7 @@ pub fn determine_rp_in_struct_field(\n \n pub fn determine_rp_in_crate(sess: Session,\n                              ast_map: ast_map::map,\n-                             +def_map: resolve::DefMap,\n+                             def_map: resolve::DefMap,\n                              crate: @ast::crate)\n                           -> region_paramd_items {\n     let cx = @mut DetermineRpCtxt {\n@@ -927,7 +927,7 @@ pub fn determine_rp_in_crate(sess: Session,\n         visit_struct_field: determine_rp_in_struct_field,\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(*crate, cx, visitor);\n+    visit::visit_crate(crate, cx, visitor);\n \n     // Propagate indirect dependencies\n     //"}, {"sha": "3c158c0d081f8621376c6034e086c7e0902de749", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -351,7 +351,7 @@ pub struct ImportDirective {\n }\n \n pub fn ImportDirective(privacy: Privacy,\n-                       +module_path: ~[ident],\n+                       module_path: ~[ident],\n                        subclass: @ImportDirectiveSubclass,\n                        span: span)\n                     -> ImportDirective {\n@@ -401,7 +401,7 @@ pub struct ImportResolution {\n }\n \n pub fn ImportResolution(privacy: Privacy,\n-                        +span: span,\n+                        span: span,\n                         state: @mut ImportState) -> ImportResolution {\n     ImportResolution {\n         privacy: privacy,\n@@ -904,7 +904,7 @@ pub impl Resolver {\n     fn build_reduced_graph(@mut self) {\n         let initial_parent =\n             ModuleReducedGraphParent(self.graph_root.get_module());\n-        visit_crate(*self.crate, initial_parent, mk_vt(@Visitor {\n+        visit_crate(self.crate, initial_parent, mk_vt(@Visitor {\n             visit_item: |item, context, visitor|\n                 self.build_reduced_graph_for_item(item, context, visitor),\n \n@@ -1088,7 +1088,7 @@ pub impl Resolver {\n     fn build_reduced_graph_for_item(@mut self,\n                                     item: @item,\n                                     parent: ReducedGraphParent,\n-                                    &&visitor: vt<ReducedGraphParent>) {\n+                                    visitor: vt<ReducedGraphParent>) {\n         let ident = item.ident;\n         let sp = item.span;\n         let privacy = visibility_to_privacy(item.vis);\n@@ -1173,7 +1173,7 @@ pub impl Resolver {\n                     (privacy, def_ty(local_def(item.id)), sp);\n \n                 for (*enum_definition).variants.each |variant| {\n-                    self.build_reduced_graph_for_variant(*variant,\n+                    self.build_reduced_graph_for_variant(variant,\n                         local_def(item.id),\n                         // inherited => privacy of the enum item\n                         variant_visibility_to_privacy(variant.node.vis,\n@@ -1362,11 +1362,11 @@ pub impl Resolver {\n     // Constructs the reduced graph for one variant. Variants exist in the\n     // type and/or value namespaces.\n     fn build_reduced_graph_for_variant(@mut self,\n-                                       variant: variant,\n+                                       variant: &variant,\n                                        item_id: def_id,\n-                                       +parent_privacy: Privacy,\n+                                       parent_privacy: Privacy,\n                                        parent: ReducedGraphParent,\n-                                       &&_visitor: vt<ReducedGraphParent>) {\n+                                       _visitor: vt<ReducedGraphParent>) {\n         let ident = variant.node.name;\n         let (child, _) = self.add_child(ident, parent, ForbidDuplicateValues,\n                                         variant.span);\n@@ -1402,7 +1402,7 @@ pub impl Resolver {\n     fn build_reduced_graph_for_view_item(@mut self,\n                                          view_item: @view_item,\n                                          parent: ReducedGraphParent,\n-                                         &&_visitor: vt<ReducedGraphParent>) {\n+                                         _visitor: vt<ReducedGraphParent>) {\n         let privacy = visibility_to_privacy(view_item.vis);\n         match view_item.node {\n             view_item_use(ref view_paths) => {\n@@ -1495,7 +1495,7 @@ pub impl Resolver {\n     fn build_reduced_graph_for_foreign_item(@mut self,\n                                             foreign_item: @foreign_item,\n                                             parent: ReducedGraphParent,\n-                                            &&visitor:\n+                                            visitor:\n                                                 vt<ReducedGraphParent>) {\n         let name = foreign_item.ident;\n         let (name_bindings, new_parent) =\n@@ -1526,7 +1526,7 @@ pub impl Resolver {\n     fn build_reduced_graph_for_block(@mut self,\n                                      block: &blk,\n                                      parent: ReducedGraphParent,\n-                                     &&visitor: vt<ReducedGraphParent>) {\n+                                     visitor: vt<ReducedGraphParent>) {\n         let mut new_parent;\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.node.id;\n@@ -1849,7 +1849,7 @@ pub impl Resolver {\n     fn build_import_directive(@mut self,\n                               privacy: Privacy,\n                               module_: @mut Module,\n-                              +module_path: ~[ident],\n+                              module_path: ~[ident],\n                               subclass: @ImportDirectiveSubclass,\n                               span: span) {\n         let directive = @ImportDirective(privacy, module_path,\n@@ -2912,7 +2912,7 @@ pub impl Resolver {\n                               module_: @mut Module,\n                               name: ident,\n                               namespace: Namespace,\n-                              +name_search_type: NameSearchType)\n+                              name_search_type: NameSearchType)\n                            -> ResolveResult<Target> {\n         debug!(\"(resolving name in module) resolving `%s` in `%s`\",\n                *self.session.str_of(name),\n@@ -3352,7 +3352,7 @@ pub impl Resolver {\n     fn resolve_crate(@mut self) {\n         debug!(\"(resolving crate) starting\");\n \n-        visit_crate(*self.crate, (), mk_vt(@Visitor {\n+        visit_crate(self.crate, (), mk_vt(@Visitor {\n             visit_item: |item, _context, visitor|\n                 self.resolve_item(item, visitor),\n             visit_arm: |arm, _context, visitor|\n@@ -3509,7 +3509,7 @@ pub impl Resolver {\n                 self.resolve_struct(item.id,\n                                     generics,\n                                     struct_def.fields,\n-                                    struct_def.dtor,\n+                                    &struct_def.dtor,\n                                     visitor);\n             }\n \n@@ -3768,7 +3768,7 @@ pub impl Resolver {\n                       id: node_id,\n                       generics: &Generics,\n                       fields: &[@struct_field],\n-                      optional_destructor: Option<struct_dtor>,\n+                      optional_destructor: &Option<struct_dtor>,\n                       visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n         do self.with_type_parameter_rib(HasTypeParameters\n@@ -3784,7 +3784,7 @@ pub impl Resolver {\n             }\n \n             // Resolve the destructor, if applicable.\n-            match optional_destructor {\n+            match *optional_destructor {\n                 None => {\n                     // Nothing to do.\n                 }\n@@ -4525,7 +4525,7 @@ pub impl Resolver {\n \n     fn resolve_module_relative_path(@mut self,\n                                     path: @Path,\n-                                    +xray: XrayFlag,\n+                                    xray: XrayFlag,\n                                     namespace: Namespace)\n                                  -> Option<def> {\n         let module_path_idents = self.intern_module_part_of_path(path);\n@@ -4571,7 +4571,7 @@ pub impl Resolver {\n     /// import resolution.\n     fn resolve_crate_relative_path(@mut self,\n                                    path: @Path,\n-                                   +xray: XrayFlag,\n+                                   xray: XrayFlag,\n                                    namespace: Namespace)\n                                 -> Option<def> {\n         let module_path_idents = self.intern_module_part_of_path(path);\n@@ -5076,7 +5076,7 @@ pub impl Resolver {\n \n     fn add_fixed_trait_for_expr(@mut self,\n                                 expr_id: node_id,\n-                                +trait_id: def_id) {\n+                                trait_id: def_id) {\n         self.trait_map.insert(expr_id, @mut ~[trait_id]);\n     }\n "}, {"sha": "7339003c6143ac1f4a06b82973e71fa346c21e0c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -785,7 +785,7 @@ pub fn enter_region<'r>(bcx: block,\n // on a set of enum variants or a literal.\n pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n-    fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], +val: Opt) {\n+    fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n         if set.any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }"}, {"sha": "e1c60234f0ff04e634442be1078abdfc4eb4bfe2", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -136,7 +136,7 @@ fn fcx_has_nonzero_span(fcx: fn_ctxt) -> bool {\n     }\n }\n \n-pub fn log_fn_time(ccx: @CrateContext, +name: ~str, start: time::Timespec,\n+pub fn log_fn_time(ccx: @CrateContext, name: ~str, start: time::Timespec,\n                    end: time::Timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.nsec as int) - (start.nsec as int)) / 1000000;\n@@ -165,7 +165,7 @@ pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, llty: TypeRef)\n \n // Only use this if you are going to actually define the function. It's\n // not valid to simply declare a function as internal.\n-pub fn decl_internal_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef) ->\n+pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: ~str, llty: TypeRef) ->\n    ValueRef {\n     let llfn = decl_cdecl_fn(llmod, name, llty);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n@@ -828,7 +828,7 @@ pub fn trans_external_path(ccx: @CrateContext, did: ast::def_id, t: ty::t)\n     };\n }\n \n-pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef])\n+pub fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef])\n            -> (ValueRef, block) {\n     let _icx = bcx.insn_ctxt(\"invoke_\");\n     if bcx.unreachable {\n@@ -924,7 +924,7 @@ pub fn have_cached_lpad(bcx: block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: block, f: &fn(+si: &mut scope_info)) {\n+pub fn in_lpad_scope_cx(bcx: block, f: &fn(si: &mut scope_info)) {\n     let mut bcx = bcx;\n     loop {\n         {\n@@ -1057,10 +1057,7 @@ pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n \n // Since this function does *not* root, it is the caller's responsibility to\n // ensure that the referent is pointed to by a root.\n-// [Note-arg-mode]\n-// ++ mode is temporary, due to how borrowck treats enums. With hope,\n-// will go away anyway when we get rid of modes.\n-pub fn do_spill_noroot(++cx: block, v: ValueRef) -> ValueRef {\n+pub fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v));\n     Store(cx, v, llptr);\n     return llptr;\n@@ -1163,7 +1160,7 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n                                        _match::BindLocal);\n }\n \n-pub fn trans_stmt(cx: block, s: ast::stmt) -> block {\n+pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n     let _icx = cx.insn_ctxt(\"trans_stmt\");\n     debug!(\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n@@ -1189,7 +1186,7 @@ pub fn trans_stmt(cx: block, s: ast::stmt) -> block {\n                         }\n                     }\n                 }\n-                ast::decl_item(i) => trans_item(*cx.fcx.ccx, *i)\n+                ast::decl_item(i) => trans_item(*cx.fcx.ccx, i)\n             }\n         }\n         ast::stmt_mac(*) => cx.tcx().sess.bug(~\"unexpanded macro\")\n@@ -1200,8 +1197,8 @@ pub fn trans_stmt(cx: block, s: ast::stmt) -> block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-pub fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n-                 is_lpad: bool, +name: ~str, opt_node_info: Option<NodeInfo>)\n+pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n+                 is_lpad: bool, name: ~str, opt_node_info: Option<NodeInfo>)\n     -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n@@ -1245,15 +1242,15 @@ pub fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<NodeInfo>)\n \n pub fn scope_block(bcx: block,\n                    opt_node_info: Option<NodeInfo>,\n-                   +n: ~str) -> block {\n+                   n: ~str) -> block {\n     return new_block(bcx.fcx, Some(bcx), simple_block_scope(), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n pub fn loop_scope_block(bcx: block,\n                         loop_break: block,\n                         loop_label: Option<ident>,\n-                        +n: ~str,\n+                        n: ~str,\n                         opt_node_info: Option<NodeInfo>) -> block {\n     return new_block(bcx.fcx, Some(bcx), block_scope(scope_info {\n         loop_break: Some(loop_break),\n@@ -1265,12 +1262,12 @@ pub fn loop_scope_block(bcx: block,\n }\n \n // Use this when creating a block for the inside of a landing pad.\n-pub fn lpad_block(bcx: block, +n: ~str) -> block {\n+pub fn lpad_block(bcx: block, n: ~str) -> block {\n     new_block(bcx.fcx, Some(bcx), block_non_scope, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n-pub fn sub_block(bcx: block, +n: ~str) -> block {\n+pub fn sub_block(bcx: block, n: ~str) -> block {\n     new_block(bcx.fcx, Some(bcx), block_non_scope, bcx.is_lpad, n, None)\n }\n \n@@ -1286,12 +1283,12 @@ pub fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n // need to make sure those variables go out of scope when the block ends.  We\n // do that by running a 'cleanup' function for each variable.\n // trans_block_cleanups runs all the cleanup functions for the block.\n-pub fn trans_block_cleanups(bcx: block, +cleanups: ~[cleanup]) -> block {\n+pub fn trans_block_cleanups(bcx: block, cleanups: ~[cleanup]) -> block {\n     trans_block_cleanups_(bcx, cleanups, false)\n }\n \n pub fn trans_block_cleanups_(bcx: block,\n-                             +cleanups: ~[cleanup],\n+                             cleanups: ~[cleanup],\n                              /* cleanup_cx: block, */\n                              is_lpad: bool) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_block_cleanups\");\n@@ -1387,7 +1384,7 @@ pub fn leave_block(bcx: block, out_of: block) -> block {\n \n pub fn with_scope(bcx: block,\n                   opt_node_info: Option<NodeInfo>,\n-                  +name: ~str,\n+                  name: ~str,\n                   f: &fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_scope\");\n \n@@ -1402,7 +1399,7 @@ pub fn with_scope(bcx: block,\n \n pub fn with_scope_result(bcx: block,\n                          opt_node_info: Option<NodeInfo>,\n-                         +name: ~str,\n+                         name: ~str,\n                          f: &fn(block) -> Result) -> Result {\n     let _icx = bcx.insn_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n@@ -1412,7 +1409,7 @@ pub fn with_scope_result(bcx: block,\n }\n \n pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n-                             +name: ~str, f: &fn(block) -> datum::DatumBlock)\n+                             name: ~str, f: &fn(block) -> datum::DatumBlock)\n                           -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n@@ -1620,7 +1617,7 @@ pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n //  - new_fn_ctxt\n //  - trans_args\n pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n-                        +path: path,\n+                        path: path,\n                         llfndecl: ValueRef,\n                         id: ast::node_id,\n                         output_type: ty::t,\n@@ -1674,7 +1671,7 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n }\n \n pub fn new_fn_ctxt(ccx: @CrateContext,\n-                   +path: path,\n+                   path: path,\n                    llfndecl: ValueRef,\n                    output_type: ty::t,\n                    sp: Option<span>)\n@@ -1839,7 +1836,7 @@ pub enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n // If the function closes over its environment a closure will be\n // returned.\n pub fn trans_closure(ccx: @CrateContext,\n-                     +path: path,\n+                     path: path,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n                      llfndecl: ValueRef,\n@@ -1920,7 +1917,7 @@ pub fn trans_closure(ccx: @CrateContext,\n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n pub fn trans_fn(ccx: @CrateContext,\n-                +path: path,\n+                path: path,\n                 decl: &ast::fn_decl,\n                 body: &ast::blk,\n                 llfndecl: ValueRef,\n@@ -1965,7 +1962,7 @@ pub fn trans_fn(ccx: @CrateContext,\n \n pub fn trans_enum_variant(ccx: @CrateContext,\n                           enum_id: ast::node_id,\n-                          variant: ast::variant,\n+                          variant: &ast::variant,\n                           args: &[ast::variant_arg],\n                           disr: int,\n                           param_substs: Option<@param_substs>,\n@@ -2108,7 +2105,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n }\n \n pub fn trans_struct_dtor(ccx: @CrateContext,\n-                         +path: path,\n+                         path: path,\n                          body: &ast::blk,\n                          dtor_id: ast::node_id,\n                          psubsts: Option<@param_substs>,\n@@ -2154,7 +2151,7 @@ pub fn trans_struct_dtor(ccx: @CrateContext,\n   lldecl\n }\n \n-pub fn trans_enum_def(ccx: @CrateContext, enum_definition: ast::enum_def,\n+pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n                       id: ast::node_id,\n                       path: @ast_map::path, vi: @~[ty::VariantInfo],\n                       i: &mut uint) {\n@@ -2165,7 +2162,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: ast::enum_def,\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n-                trans_enum_variant(ccx, id, *variant, *args,\n+                trans_enum_variant(ccx, id, variant, *args,\n                                    disr_val, None, llfn);\n             }\n             ast::tuple_variant_kind(_) => {\n@@ -2179,7 +2176,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: ast::enum_def,\n     }\n }\n \n-pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n+pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_item\");\n     let path = match *ccx.tcx.items.get(&item.id) {\n         ast_map::node_item(_, p) => p,\n@@ -2214,7 +2211,7 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n                 match stmt.node {\n                   ast::stmt_decl(@codemap::spanned { node: ast::decl_item(i),\n                                                  _ }, _) => {\n-                    trans_item(ccx, *i);\n+                    trans_item(ccx, i);\n                   }\n                   _ => ()\n                 }\n@@ -2232,7 +2229,7 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n         if !generics.is_type_parameterized() {\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let mut i = 0;\n-            trans_enum_def(ccx, (*enum_definition), item.id,\n+            trans_enum_def(ccx, enum_definition, item.id,\n                            path, vi, &mut i);\n         }\n       }\n@@ -2279,13 +2276,13 @@ pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def,\n pub fn trans_mod(ccx: @CrateContext, m: &ast::_mod) {\n     let _icx = ccx.insn_ctxt(\"trans_mod\");\n     for m.items.each |item| {\n-        trans_item(ccx, **item);\n+        trans_item(ccx, *item);\n     }\n }\n \n pub fn register_fn(ccx: @CrateContext,\n                    sp: span,\n-                   +path: path,\n+                   path: path,\n                    node_id: ast::node_id,\n                    attrs: &[ast::attribute])\n                 -> ValueRef {\n@@ -2295,7 +2292,7 @@ pub fn register_fn(ccx: @CrateContext,\n \n pub fn register_fn_full(ccx: @CrateContext,\n                         sp: span,\n-                        +path: path,\n+                        path: path,\n                         node_id: ast::node_id,\n                         attrs: &[ast::attribute],\n                         node_type: ty::t)\n@@ -2307,7 +2304,7 @@ pub fn register_fn_full(ccx: @CrateContext,\n \n pub fn register_fn_fuller(ccx: @CrateContext,\n                           sp: span,\n-                          +path: path,\n+                          path: path,\n                           node_id: ast::node_id,\n                           attrs: &[ast::attribute],\n                           node_type: ty::t,\n@@ -2495,7 +2492,7 @@ pub fn item_path(ccx: @CrateContext, i: @ast::item) -> path {\n /* If there's already a symbol for the dtor with <id> and substs <substs>,\n    return it; otherwise, create one and register it, returning it as well */\n pub fn get_dtor_symbol(ccx: @CrateContext,\n-                       +path: path,\n+                       path: path,\n                        id: ast::node_id,\n                        substs: Option<@param_substs>)\n                     -> ~str {\n@@ -2749,7 +2746,7 @@ pub fn trans_constant(ccx: @CrateContext, it: @ast::item) {\n \n pub fn trans_constants(ccx: @CrateContext, crate: &ast::crate) {\n     visit::visit_crate(\n-        *crate, (),\n+        crate, (),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_item: |a| trans_constant(ccx, a),\n             ..*visit::default_simple_visitor()\n@@ -3146,7 +3143,7 @@ pub fn trans_crate(sess: session::Session,\n                    tcx: ty::ctxt,\n                    output: &Path,\n                    emap2: resolve::ExportMap2,\n-                   +maps: astencode::Maps) -> (ModuleRef, LinkMeta) {\n+                   maps: astencode::Maps) -> (ModuleRef, LinkMeta) {\n \n     let symbol_hasher = @hash::default_state();\n     let link_meta ="}, {"sha": "ecde50f34707276ea016a94d3086d2d6500fcf7d", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -41,7 +41,7 @@ enum x86_64_reg_class {\n     memory_class\n }\n \n-fn is_sse(++c: x86_64_reg_class) -> bool {\n+fn is_sse(c: x86_64_reg_class) -> bool {\n     return match c {\n         sse_fs_class | sse_fv_class |\n         sse_ds_class | sse_dv_class => true,"}, {"sha": "3301ed62cbe1f57112f9fe9c1db7fd7822a2cb5c", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -444,7 +444,7 @@ pub fn body_contains_ret(body: &ast::blk) -> bool {\n }\n \n // See [Note-arg-mode]\n-pub fn trans_call_inner(++in_cx: block,\n+pub fn trans_call_inner(in_cx: block,\n                         call_info: Option<NodeInfo>,\n                         fn_expr_ty: ty::t,\n                         ret_ty: ty::t,\n@@ -592,7 +592,7 @@ pub enum CallArgs<'self> {\n     ArgVals(&'self [ValueRef])\n }\n \n-pub fn trans_ret_slot(+bcx: block, +fn_ty: ty::t, +dest: expr::Dest)\n+pub fn trans_ret_slot(bcx: block, fn_ty: ty::t, dest: expr::Dest)\n                       -> ValueRef {\n     let retty = ty::ty_fn_ret(fn_ty);\n \n@@ -610,12 +610,12 @@ pub fn trans_ret_slot(+bcx: block, +fn_ty: ty::t, +dest: expr::Dest)\n     }\n }\n \n-pub fn trans_args(+cx: block,\n-                  +args: CallArgs,\n-                  +fn_ty: ty::t,\n-                  +ret_flag: Option<ValueRef>,\n-                  +autoref_arg: AutorefArg,\n-                  +llargs: &mut ~[ValueRef]) -> block\n+pub fn trans_args(cx: block,\n+                  args: CallArgs,\n+                  fn_ty: ty::t,\n+                  ret_flag: Option<ValueRef>,\n+                  autoref_arg: AutorefArg,\n+                  llargs: &mut ~[ValueRef]) -> block\n {\n     let _icx = cx.insn_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n@@ -663,9 +663,9 @@ pub enum AutorefArg {\n pub fn trans_arg_expr(bcx: block,\n                       formal_ty: ty::arg,\n                       arg_expr: @ast::expr,\n-                      +temp_cleanups: &mut ~[ValueRef],\n-                      +ret_flag: Option<ValueRef>,\n-                      +autoref_arg: AutorefArg) -> Result {\n+                      temp_cleanups: &mut ~[ValueRef],\n+                      ret_flag: Option<ValueRef>,\n+                      autoref_arg: AutorefArg) -> Result {\n     let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n "}, {"sha": "a2ce83c45c2e70affa31cb7a22e1b4c57c36aa95", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -59,9 +59,9 @@ use syntax::parse::token::ident_interner;\n use syntax::{ast, ast_map};\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n-pub type namegen = @fn(+s: ~str) -> ident;\n+pub type namegen = @fn(s: ~str) -> ident;\n pub fn new_namegen(intr: @ident_interner) -> namegen {\n-    let f: @fn(+s: ~str) -> ident = |prefix| {\n+    let f: @fn(s: ~str) -> ident = |prefix| {\n         intr.gensym(@fmt!(\"%s_%u\",\n                           prefix,\n                           intr.gensym(@prefix).repr))\n@@ -395,7 +395,7 @@ pub struct cleanup_path {\n     dest: BasicBlockRef\n }\n \n-pub fn scope_clean_changed(+scope_info: &mut scope_info) {\n+pub fn scope_clean_changed(scope_info: &mut scope_info) {\n     if scope_info.cleanup_paths.len() > 0u { scope_info.cleanup_paths = ~[]; }\n     scope_info.landing_pad = None;\n }\n@@ -626,7 +626,7 @@ pub struct block_ {\n     fcx: fn_ctxt\n }\n \n-pub fn block_(llbb: BasicBlockRef, parent: Option<block>, +kind: block_kind,\n+pub fn block_(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n               is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block_ {\n \n@@ -644,7 +644,7 @@ pub fn block_(llbb: BasicBlockRef, parent: Option<block>, +kind: block_kind,\n \n pub type block = @mut block_;\n \n-pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>, +kind: block_kind,\n+pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n             is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block {\n     @mut block_(llbb, parent, kind, is_lpad, node_info, fcx)\n@@ -663,7 +663,7 @@ pub fn rslt(bcx: block, val: ValueRef) -> Result {\n }\n \n pub impl Result {\n-    fn unpack(&self, +bcx: &mut block) -> ValueRef {\n+    fn unpack(&self, bcx: &mut block) -> ValueRef {\n         *bcx = self.bcx;\n         return self.val;\n     }\n@@ -683,7 +683,7 @@ pub fn val_str(tn: @TypeNames, v: ValueRef) -> @str {\n     return ty_str(tn, val_ty(v));\n }\n \n-pub fn in_scope_cx(cx: block, f: &fn(+si: &mut scope_info)) {\n+pub fn in_scope_cx(cx: block, f: &fn(si: &mut scope_info)) {\n     let mut cur = cx;\n     loop {\n         {\n@@ -1252,7 +1252,7 @@ pub fn C_bytes_plus_null(bytes: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn C_shape(ccx: @CrateContext, +bytes: ~[u8]) -> ValueRef {\n+pub fn C_shape(ccx: @CrateContext, bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         let llshape = C_bytes_plus_null(bytes);\n         let name = fmt!(\"shape%u\", (ccx.names)(~\"shape\").repr);\n@@ -1325,7 +1325,7 @@ pub struct mono_id_ {\n pub type mono_id = @mono_id_;\n \n impl to_bytes::IterBytes for mono_param_id {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n             mono_precise(t, ref mids) =>\n                 to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), mids, lsb0, f),\n@@ -1339,7 +1339,7 @@ impl to_bytes::IterBytes for mono_param_id {\n }\n \n impl to_bytes::IterBytes for mono_id_ {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n     }\n }\n@@ -1433,7 +1433,7 @@ pub fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n \n // Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n // eliminate any vtable_params.\n-pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, +vt: typeck::vtable_origin)\n+pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n     -> typeck::vtable_origin {\n     let tcx = fcx.ccx.tcx;\n     match vt {\n@@ -1479,7 +1479,7 @@ pub fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n     /*bad*/ copy ps.vtables.get()[vtable_off]\n }\n \n-pub fn dummy_substs(+tps: ~[ty::t]) -> ty::substs {\n+pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n     substs {\n         self_r: Some(ty::re_bound(ty::br_self)),\n         self_ty: None,"}, {"sha": "4f51e32f7732a07e69b73d387312fdd59aad26b6", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -39,7 +39,7 @@ pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n     };\n     for vec::each(b.node.stmts) |s| {\n         debuginfo::update_source_pos(bcx, b.span);\n-        bcx = trans_stmt(bcx, **s);\n+        bcx = trans_stmt(bcx, *s);\n     }\n     match b.node.expr {\n         Some(e) => {"}, {"sha": "ac0cf7064538c8f5ad0ad941043c3845ac4fb254", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -159,7 +159,7 @@ pub impl DatumMode {\n }\n \n impl to_bytes::IterBytes for DatumMode {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n@@ -811,7 +811,7 @@ pub impl Datum {\n }\n \n pub impl DatumBlock {\n-    fn unpack(&self, +bcx: &mut block) -> Datum {\n+    fn unpack(&self, bcx: &mut block) -> Datum {\n         *bcx = self.bcx;\n         return self.datum;\n     }"}, {"sha": "fdd978fea3d7dd9d0b4f989a0073e02f5f170d0e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -104,7 +104,7 @@ pub struct DebugContext {\n     crate_file: ~str\n }\n \n-pub fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> DebugContext {\n+pub fn mk_ctxt(crate: ~str, intr: @ident_interner) -> DebugContext {\n     DebugContext {\n         llmetadata: @mut HashMap::new(),\n         names: new_namegen(intr),\n@@ -249,7 +249,7 @@ fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n     }, work_dir.to_owned())\n }\n \n-fn create_file(cx: @CrateContext, +full_path: ~str)\n+fn create_file(cx: @CrateContext, full_path: ~str)\n     -> @Metadata<FileMetadata> {\n     let cache = get_cache(cx);;\n     let tg = FileDescriptorTag;\n@@ -589,7 +589,7 @@ fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n fn create_composite_type(type_tag: int, name: &str, file: ValueRef,\n                          line: int, size: int, align: int, offset: int,\n                          derived: Option<ValueRef>,\n-                         +members: Option<~[ValueRef]>)\n+                         members: Option<~[ValueRef]>)\n     -> ValueRef {\n     let lldata = ~[lltag(type_tag),\n                   file,"}, {"sha": "ba6965f0eaea3d245c2526d367258b7d74cab968", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -1572,7 +1572,7 @@ fn trans_binary(bcx: block,\n fn trans_overloaded_op(bcx: block,\n                        expr: @ast::expr,\n                        rcvr: @ast::expr,\n-                       +args: ~[@ast::expr],\n+                       args: ~[@ast::expr],\n                        ret_ty: ty::t,\n                        dest: Dest)\n                        -> block {\n@@ -1746,6 +1746,6 @@ fn trans_assign_op(bcx: block,\n     return result_datum.copy_to_datum(bcx, DROP_EXISTING, dst_datum);\n }\n \n-fn shorten(+x: ~str) -> ~str {\n+fn shorten(x: ~str) -> ~str {\n     if x.len() > 60 { x.substr(0, 60).to_owned() } else { x }\n }"}, {"sha": "854ec585d5cc2f3267a225e097737ee73ebdbe47", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -39,7 +39,7 @@ use syntax::{ast, ast_util};\n use syntax::{attr, ast_map};\n use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n-use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n+use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall,\n                   Cdecl, Aapcs, C};\n \n@@ -139,7 +139,7 @@ type shim_ret_builder<'self> =\n               llretval: ValueRef);\n \n fn build_shim_fn_(ccx: @CrateContext,\n-                  +shim_name: ~str,\n+                  shim_name: ~str,\n                   llbasefn: ValueRef,\n                   tys: &ShimTypes,\n                   cc: lib::llvm::CallConv,\n@@ -544,7 +544,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n pub fn trans_intrinsic(ccx: @CrateContext,\n                        decl: ValueRef,\n                        item: @ast::foreign_item,\n-                       +path: ast_map::path,\n+                       path: ast_map::path,\n                        substs: @param_substs,\n                        ref_id: Option<ast::node_id>) {\n     debug!(\"trans_intrinsic(item.ident=%s)\", *ccx.sess.str_of(item.ident));\n@@ -1089,15 +1089,15 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n  *     }\n  */\n pub fn trans_foreign_fn(ccx: @CrateContext,\n-                        +path: ast_map::path,\n+                        path: ast_map::path,\n                         decl: &ast::fn_decl,\n                         body: &ast::blk,\n                         llwrapfn: ValueRef,\n                         id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n     fn build_rust_fn(ccx: @CrateContext,\n-                     +path: ast_map::path,\n+                     path: ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n                      id: ast::node_id)\n@@ -1125,7 +1125,7 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n     }\n \n     fn build_shim_fn(ccx: @CrateContext,\n-                     +path: ast_map::path,\n+                     path: ast_map::path,\n                      llrustfn: ValueRef,\n                      tys: &ShimTypes)\n                      -> ValueRef {\n@@ -1266,7 +1266,7 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n \n pub fn register_foreign_fn(ccx: @CrateContext,\n                            sp: span,\n-                           +path: ast_map::path,\n+                           path: ast_map::path,\n                            node_id: ast::node_id,\n                            attrs: &[ast::attribute])\n                            -> ValueRef {"}, {"sha": "9031871de560d708d87d315cc0cca302077efee4", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -321,7 +321,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue_full(++bcx: block,\n+pub fn call_tydesc_glue_full(bcx: block,\n                              v: ValueRef,\n                              tydesc: ValueRef,\n                              field: uint,\n@@ -388,7 +388,7 @@ pub fn call_tydesc_glue_full(++bcx: block,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n+pub fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint)\n     -> block {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n@@ -713,7 +713,7 @@ pub fn declare_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n pub type glue_helper = @fn(block, ValueRef, ty::t);\n \n pub fn declare_generic_glue(ccx: @CrateContext, t: ty::t, llfnty: TypeRef,\n-                            +name: ~str) -> ValueRef {\n+                            name: ~str) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n     let name = name;\n     //XXX this triggers duplicate LLVM symbols"}, {"sha": "6e8a782fd421fa42ce060965f8a7ebdfe2a5dc22", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -54,7 +54,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n           csearch::found(ast::ii_item(item)) => {\n             ccx.external.insert(fn_id, Some(item.id));\n             ccx.stats.n_inlines += 1;\n-            if translate { trans_item(ccx, *item); }\n+            if translate { trans_item(ccx, item); }\n             local_def(item.id)\n           }\n           csearch::found(ast::ii_foreign(item)) => {\n@@ -76,7 +76,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n               _ => ccx.sess.bug(~\"maybe_instantiate_inline: item has a \\\n                     non-enum parent\")\n             }\n-            if translate { trans_item(ccx, *item); }\n+            if translate { trans_item(ccx, item); }\n             local_def(my_id)\n           }\n           csearch::found_parent(_, _) => {"}, {"sha": "acb6353aa8b39632f0f947c24b26d25465183dc9", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -42,7 +42,7 @@ for non-monomorphized methods only.  Other methods will\n be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n-pub fn trans_impl(ccx: @CrateContext, +path: path, name: ast::ident,\n+pub fn trans_impl(ccx: @CrateContext, path: path, name: ast::ident,\n                   methods: &[@ast::method], generics: &ast::Generics,\n                   self_ty: Option<ty::t>, id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n@@ -89,7 +89,7 @@ Translates a (possibly monomorphized) method body.\n - `impl_id`: the node ID of the impl this method is inside\n */\n pub fn trans_method(ccx: @CrateContext,\n-                    +path: path,\n+                    path: path,\n                     method: &ast::method,\n                     param_substs: Option<@param_substs>,\n                     base_self_ty: Option<ty::t>,\n@@ -443,7 +443,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n                                   mentry: typeck::method_map_entry,\n                                   trait_id: ast::def_id,\n                                   n_method: uint,\n-                                  +vtbl: typeck::vtable_origin)\n+                                  vtbl: typeck::vtable_origin)\n                                -> Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     return match vtbl {\n@@ -724,7 +724,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n }\n \n pub fn vtable_id(ccx: @CrateContext,\n-                 +origin: typeck::vtable_origin)\n+                 origin: typeck::vtable_origin)\n               -> mono_id {\n     match origin {\n         typeck::vtable_static(impl_id, substs, sub_vtables) => {\n@@ -747,7 +747,7 @@ pub fn vtable_id(ccx: @CrateContext,\n }\n \n pub fn get_vtable(ccx: @CrateContext,\n-                  +origin: typeck::vtable_origin)\n+                  origin: typeck::vtable_origin)\n                -> ValueRef {\n     // XXX: Bad copy.\n     let hash_id = vtable_id(ccx, copy origin);"}, {"sha": "9d63ac854a90cb24432b6ae355ee07836933d1b9", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -221,9 +221,9 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         let this_tv = vec::find(*tvs, |tv| { tv.id.node == fn_id.node}).get();\n         let d = mk_lldecl();\n         set_inline_hint(d);\n-        match (*v).node.kind {\n+        match v.node.kind {\n             ast::tuple_variant_kind(ref args) => {\n-                trans_enum_variant(ccx, enum_item.id, *v, /*bad*/copy *args,\n+                trans_enum_variant(ccx, enum_item.id, v, /*bad*/copy *args,\n                                    this_tv.disr_val, psubsts, d);\n             }\n             ast::struct_variant_kind(_) =>"}, {"sha": "d7ca346dd20ee140017fff6cefd752579211c663", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -49,13 +49,13 @@ pub fn find_reachable(crate_mod: &_mod, exp_map2: resolve::ExportMap2,\n             method_map: method_map,\n             rmap: &mut rmap\n         };\n-        traverse_public_mod(cx, ast::crate_node_id, crate_mod);\n-        traverse_all_resources_and_impls(cx, crate_mod);\n+        traverse_public_mod(&cx, ast::crate_node_id, crate_mod);\n+        traverse_all_resources_and_impls(&cx, crate_mod);\n     }\n     return @rmap;\n }\n \n-fn traverse_exports(cx: ctx, mod_id: node_id) -> bool {\n+fn traverse_exports(cx: &ctx, mod_id: node_id) -> bool {\n     let mut found_export = false;\n     match cx.exp_map2.find(&mod_id) {\n       Some(ref exp2s) => {\n@@ -69,7 +69,7 @@ fn traverse_exports(cx: ctx, mod_id: node_id) -> bool {\n     return found_export;\n }\n \n-fn traverse_def_id(cx: ctx, did: def_id) {\n+fn traverse_def_id(cx: &ctx, did: def_id) {\n     if did.crate != local_crate { return; }\n     match cx.tcx.items.find(&did.node) {\n         None => (), // This can happen for self, for example\n@@ -85,7 +85,7 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n     }\n }\n \n-fn traverse_public_mod(cx: ctx, mod_id: node_id, m: &_mod) {\n+fn traverse_public_mod(cx: &ctx, mod_id: node_id, m: &_mod) {\n     if !traverse_exports(cx, mod_id) {\n         // No exports, so every local item is exported\n         for m.items.each |item| {\n@@ -94,7 +94,7 @@ fn traverse_public_mod(cx: ctx, mod_id: node_id, m: &_mod) {\n     }\n }\n \n-fn traverse_public_item(cx: ctx, item: @item) {\n+fn traverse_public_item(cx: &ctx, item: @item) {\n     // XXX: it shouldn't be necessary to do this\n     let rmap: &mut HashSet<node_id> = cx.rmap;\n     if rmap.contains(&item.id) { return; }\n@@ -139,20 +139,17 @@ fn traverse_public_item(cx: ctx, item: @item) {\n         }\n       }\n       item_ty(t, _) => {\n-        traverse_ty(t, cx, mk_ty_visitor());\n+        traverse_ty(t, cx,\n+                    visit::mk_vt(@visit::Visitor {visit_ty: traverse_ty,\n+                                                  ..*visit::default_visitor()}))\n       }\n       item_const(*) |\n       item_enum(*) | item_trait(*) => (),\n       item_mac(*) => fail!(~\"item macros unimplemented\")\n     }\n }\n \n-fn mk_ty_visitor() -> visit::vt<ctx> {\n-    visit::mk_vt(@visit::Visitor {visit_ty: traverse_ty,\n-                                  ..*visit::default_visitor()})\n-}\n-\n-fn traverse_ty<'a>(ty: @Ty, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n+fn traverse_ty<'a, 'b>(ty: @Ty, cx: &'b ctx<'a>, v: visit::vt<&'b ctx<'a>>) {\n     // XXX: it shouldn't be necessary to do this\n     let rmap: &mut HashSet<node_id> = cx.rmap;\n     if rmap.contains(&ty.id) { return; }\n@@ -175,8 +172,9 @@ fn traverse_ty<'a>(ty: @Ty, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n     }\n }\n \n-fn traverse_inline_body(cx: ctx, body: &blk) {\n-    fn traverse_expr<'a>(e: @expr, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n+fn traverse_inline_body(cx: &ctx, body: &blk) {\n+    fn traverse_expr<'a, 'b>(e: @expr, cx: &'b ctx<'a>,\n+                             v: visit::vt<&'b ctx<'a>>) {\n         match e.node {\n           expr_path(_) => {\n             match cx.tcx.def_map.find(&e.id) {\n@@ -221,7 +219,7 @@ fn traverse_inline_body(cx: ctx, body: &blk) {\n     // Don't ignore nested items: for example if a generic fn contains a\n     // generic impl (as in deque::create), we need to monomorphize the\n     // impl as well\n-    fn traverse_item(i: @item, cx: ctx, _v: visit::vt<ctx>) {\n+    fn traverse_item(i: @item, cx: &ctx, _v: visit::vt<&ctx>) {\n       traverse_public_item(cx, i);\n     }\n     visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n@@ -231,7 +229,7 @@ fn traverse_inline_body(cx: ctx, body: &blk) {\n     }));\n }\n \n-fn traverse_all_resources_and_impls(cx: ctx, crate_mod: &_mod) {\n+fn traverse_all_resources_and_impls(cx: &ctx, crate_mod: &_mod) {\n     visit::visit_mod(\n         crate_mod,\n         codemap::dummy_sp(),"}, {"sha": "ffb2cc01ab2491f6fbab5c934ae47a60d976ce46", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -121,7 +121,7 @@ pub impl Reflector {\n \n     fn bracketed(&mut self,\n                  bracket_name: ~str,\n-                 +extra: ~[ValueRef],\n+                 extra: ~[ValueRef],\n                  inner: &fn(&mut Reflector)) {\n         // XXX: Bad copy.\n         self.visit(~\"enter_\" + bracket_name, copy extra);\n@@ -145,7 +145,7 @@ pub impl Reflector {\n         }\n     }\n \n-    fn leaf(&mut self, +name: ~str) {\n+    fn leaf(&mut self, name: ~str) {\n         self.visit(name, ~[]);\n     }\n "}, {"sha": "32ea381c020a31d43dccca6bf6af6ecd19366d9c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -126,7 +126,7 @@ pub struct creader_cache_key {\n type creader_cache = @mut HashMap<creader_cache_key, t>;\n \n impl to_bytes::IterBytes for creader_cache_key {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n     }\n }\n@@ -150,7 +150,7 @@ impl cmp::Eq for intern_key {\n }\n \n impl to_bytes::IterBytes for intern_key {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         unsafe {\n             (*self.sty).iter_bytes(lsb0, f);\n         }\n@@ -390,13 +390,13 @@ pub struct FnSig {\n }\n \n impl to_bytes::IterBytes for BareFnTy {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.purity, &self.abis, &self.sig, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for ClosureTy {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n                                &self.region, &self.sig, lsb0, f)\n     }\n@@ -685,7 +685,7 @@ pub enum InferTy {\n }\n \n impl to_bytes::IterBytes for InferTy {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n           IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n@@ -702,7 +702,7 @@ pub enum InferRegion {\n }\n \n impl to_bytes::IterBytes for InferRegion {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n             ReVar(ref rv) => to_bytes::iter_bytes_2(&0u8, rv, lsb0, f),\n             ReSkolemized(ref v, _) => to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n@@ -790,25 +790,25 @@ impl ToStr for IntVarValue {\n }\n \n impl to_bytes::IterBytes for TyVid {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for IntVid {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for FloatVid {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for RegionVid {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n@@ -877,7 +877,7 @@ pub fn mk_ctxt(s: session::Session,\n                freevars: freevars::freevar_map,\n                region_maps: @mut middle::region::RegionMaps,\n                region_paramd_items: middle::region::region_paramd_items,\n-               +lang_items: middle::lang_items::LanguageItems,\n+               lang_items: middle::lang_items::LanguageItems,\n                crate: @ast::crate)\n             -> ctxt {\n     let mut legacy_modes = false;\n@@ -942,7 +942,7 @@ pub fn mk_ctxt(s: session::Session,\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n-fn mk_t(cx: ctxt, +st: sty) -> t {\n+fn mk_t(cx: ctxt, st: sty) -> t {\n     // Check for primitive types.\n     match st {\n         ty_nil => return mk_nil(cx),\n@@ -1141,7 +1141,7 @@ pub fn mk_estr(cx: ctxt, t: vstore) -> t {\n     mk_t(cx, ty_estr(t))\n }\n \n-pub fn mk_enum(cx: ctxt, did: ast::def_id, +substs: substs) -> t {\n+pub fn mk_enum(cx: ctxt, did: ast::def_id, substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_enum(did, substs))\n }\n@@ -1192,13 +1192,13 @@ pub fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::m_imm}))\n }\n \n-pub fn mk_tup(cx: ctxt, +ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n+pub fn mk_tup(cx: ctxt, ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n-pub fn mk_closure(cx: ctxt, +fty: ClosureTy) -> t {\n+pub fn mk_closure(cx: ctxt, fty: ClosureTy) -> t {\n     mk_t(cx, ty_closure(fty))\n }\n \n-pub fn mk_bare_fn(cx: ctxt, +fty: BareFnTy) -> t {\n+pub fn mk_bare_fn(cx: ctxt, fty: BareFnTy) -> t {\n     mk_t(cx, ty_bare_fn(fty))\n }\n \n@@ -1217,15 +1217,15 @@ pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n \n pub fn mk_trait(cx: ctxt,\n                 did: ast::def_id,\n-                +substs: substs,\n+                substs: substs,\n                 store: TraitStore,\n                 mutability: ast::mutability)\n              -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_trait(did, substs, store, mutability))\n }\n \n-pub fn mk_struct(cx: ctxt, struct_id: ast::def_id, +substs: substs) -> t {\n+pub fn mk_struct(cx: ctxt, struct_id: ast::def_id, substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n@@ -1236,7 +1236,7 @@ pub fn mk_int_var(cx: ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n \n pub fn mk_float_var(cx: ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n \n-pub fn mk_infer(cx: ctxt, +it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n+pub fn mk_infer(cx: ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n \n pub fn mk_self(cx: ctxt, did: ast::def_id) -> t { mk_t(cx, ty_self(did)) }\n \n@@ -2672,7 +2672,7 @@ impl cmp::TotalEq for bound_region {\n }\n \n impl to_bytes::IterBytes for vstore {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           vstore_fixed(ref u) =>\n           to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n@@ -2687,44 +2687,44 @@ impl to_bytes::IterBytes for vstore {\n }\n \n impl to_bytes::IterBytes for substs {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_3(&self.self_r,\n                                  &self.self_ty,\n                                  &self.tps, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for mt {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ty,\n                                  &self.mutbl, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for field {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ident,\n                                  &self.mt, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for arg {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.mode,\n                                &self.ty, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for FnSig {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.inputs,\n                                &self.output,\n                                lsb0, f);\n     }\n }\n \n impl to_bytes::IterBytes for sty {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           ty_nil => 0u8.iter_bytes(lsb0, f),\n           ty_bool => 1u8.iter_bytes(lsb0, f),\n@@ -3383,7 +3383,7 @@ pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n // Maintains a little union-set tree for inferred modes.  `canon()` returns\n // the current head value for `m0`.\n fn canon<T:Copy + cmp::Eq>(tbl: &mut HashMap<ast::node_id, ast::inferable<T>>,\n-                         +m0: ast::inferable<T>) -> ast::inferable<T> {\n+                           m0: ast::inferable<T>) -> ast::inferable<T> {\n     match m0 {\n         ast::infer(id) => {\n             let m1 = match tbl.find(&id) {"}, {"sha": "10acea1291f923e3a010599ddc01f77d2328e73c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -248,7 +248,7 @@ pub static NO_TPS: uint = 2;\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n-    self: &AC, rscope: &RS, &&ast_ty: @ast::Ty) -> ty::t {\n+    self: &AC, rscope: &RS, ast_ty: @ast::Ty) -> ty::t {\n \n     fn ast_mt_to_mt<AC:AstConv, RS:region_scope + Copy + Durable>(\n         self: &AC, rscope: &RS, mt: &ast::mt) -> ty::mt {"}, {"sha": "c58ad0bfa3b34a885425193736243d2e5d4fe15e", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -44,7 +44,7 @@ pub fn check_match(fcx: @mut FnCtxt,\n             block_region: ty::re_scope(arm.body.node.id)\n         };\n \n-        for arm.pats.each |p| { check_pat(pcx, *p, pattern_ty);}\n+        for arm.pats.each |p| { check_pat(&pcx, *p, pattern_ty);}\n     }\n \n     // Now typecheck the blocks.\n@@ -99,7 +99,7 @@ pub struct pat_ctxt {\n     block_region: ty::Region, // Region for the block of the arm\n }\n \n-pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::Path,\n+pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n                          subpats: &Option<~[@ast::pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n@@ -247,7 +247,7 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::Path,\n /// `substitutions` are the type substitutions applied to this struct type\n /// (e.g. K,V in HashMap<K,V>).\n /// `etc` is true if the pattern said '...' and false otherwise.\n-pub fn check_struct_pat_fields(pcx: pat_ctxt,\n+pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                span: span,\n                                path: @ast::Path,\n                                fields: &[ast::field_pat],\n@@ -299,7 +299,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n     }\n }\n \n-pub fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n+pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::node_id, span: span,\n                         expected: ty::t, path: @ast::Path,\n                         fields: &[ast::field_pat], etc: bool,\n                         class_id: ast::def_id, substitutions: &ty::substs) {\n@@ -337,7 +337,7 @@ pub fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n                             substitutions, etc);\n }\n \n-pub fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n+pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                           pat_id: ast::node_id,\n                                           span: span,\n                                           expected: ty::t,\n@@ -375,7 +375,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n \n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n-pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n+pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n "}, {"sha": "9d8a1145f22eb294e31e7bb1653d5c1b4c13c98a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -1298,7 +1298,7 @@ pub impl<'self> LookupContext<'self> {\n         ty::item_path_str(self.tcx(), did)\n     }\n \n-    fn bug(&self, +s: ~str) -> ! {\n+    fn bug(&self, s: ~str) -> ! {\n         self.tcx().sess.bug(s)\n     }\n }"}, {"sha": "d6f892cac3c318023129c2284d403cbca4876bc2", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -257,7 +257,7 @@ pub fn check_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n         visit_item: |a| check_item(ccx, a),\n         .. *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(*crate, (), visit);\n+    visit::visit_crate(crate, (), visit);\n }\n \n pub fn check_bare_fn(ccx: @mut CrateCtxt,\n@@ -430,11 +430,11 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 match_region: region,\n                 block_region: region,\n             };\n-            _match::check_pat(pcx, input.pat, *arg_ty);\n+            _match::check_pat(&pcx, input.pat, *arg_ty);\n         }\n \n         // Add explicitly-declared locals.\n-        let visit_local: @fn(@ast::local, &&e: (), visit::vt<()>) =\n+        let visit_local: @fn(@ast::local, e: (), visit::vt<()>) =\n                 |local, e, v| {\n             let o_ty = match local.node.ty.node {\n               ast::ty_infer => None,\n@@ -449,7 +449,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         // Add pattern bindings.\n-        let visit_pat: @fn(@ast::pat, &&e: (), visit::vt<()>) = |p, e, v| {\n+        let visit_pat: @fn(@ast::pat, e: (), visit::vt<()>) = |p, e, v| {\n             match p.node {\n               ast::pat_ident(_, path, _)\n                   if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n@@ -464,7 +464,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             visit::visit_pat(p, e, v);\n         };\n \n-        let visit_block: @fn(&ast::blk, &&e: (), visit::vt<()>) = |b, e, v| {\n+        let visit_block: @fn(&ast::blk, e: (), visit::vt<()>) = |b, e, v| {\n             // non-obvious: the `blk` variable maps to region lb, so\n             // we have to keep this up-to-date.  This\n             // is... unfortunate.  It'd be nice to not need this.\n@@ -476,9 +476,9 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Don't descend into fns and items\n         fn visit_fn(_fk: &visit::fn_kind, _decl: &ast::fn_decl,\n                     _body: &ast::blk, _sp: span,\n-                    _id: ast::node_id, &&_t: (), _v: visit::vt<()>) {\n+                    _id: ast::node_id, _t: (), _v: visit::vt<()>) {\n         }\n-        fn visit_item(_i: @ast::item, &&_e: (), _v: visit::vt<()>) { }\n+        fn visit_item(_i: @ast::item, _e: (), _v: visit::vt<()>) { }\n \n         let visit = visit::mk_vt(\n             @visit::Visitor {visit_local: visit_local,\n@@ -714,7 +714,7 @@ pub impl FnCtxt {\n         self.inh.node_types.insert(node_id, ty);\n     }\n \n-    fn write_substs(&self, node_id: ast::node_id, +substs: ty::substs) {\n+    fn write_substs(&self, node_id: ast::node_id, substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n             debug!(\"write_substs(%d, %s) in fcx %s\",\n                    node_id,\n@@ -727,7 +727,7 @@ pub impl FnCtxt {\n     fn write_ty_substs(&self,\n                        node_id: ast::node_id,\n                        ty: ty::t,\n-                       +substs: ty::substs) {\n+                       substs: ty::substs) {\n         let ty = ty::subst(self.tcx(), &substs, ty);\n         self.write_ty(node_id, ty);\n         self.write_substs(node_id, substs);\n@@ -1429,9 +1429,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         self_ex: @ast::expr,\n                         self_t: ty::t,\n                         opname: ast::ident,\n-                        +args: ~[@ast::expr],\n-                        +deref_args: DerefArgs,\n-                        +autoderef_receiver: AutoderefReceiverFlag,\n+                        args: ~[@ast::expr],\n+                        deref_args: DerefArgs,\n+                        autoderef_receiver: AutoderefReceiverFlag,\n                         unbound_method: &fn(),\n                         _expected_result: Option<ty::t>\n                        )\n@@ -1570,7 +1570,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     fn check_user_unop(fcx: @mut FnCtxt,\n                        op_str: ~str,\n-                       +mname: ~str,\n+                       mname: ~str,\n                        ex: @ast::expr,\n                        rhs_expr: @ast::expr,\n                        rhs_t: ty::t,\n@@ -1775,7 +1775,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                       span: span,\n                                       class_id: ast::def_id,\n                                       node_id: ast::node_id,\n-                                      +substitutions: ty::substs,\n+                                      substitutions: ty::substs,\n                                       field_types: &[ty::field_ty],\n                                       ast_fields: &[ast::field],\n                                       check_completeness: bool)  {\n@@ -2859,7 +2859,7 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local)  {\n         match_region: region,\n         block_region: region,\n     };\n-    _match::check_pat(pcx, local.node.pat, t);\n+    _match::check_pat(&pcx, local.node.pat, t);\n     let pat_ty = fcx.node_ty(local.node.pat.id);\n     if ty::type_is_error(pat_ty) || ty::type_is_bot(pat_ty) {\n         fcx.write_ty(local.node.id, pat_ty);\n@@ -2947,7 +2947,7 @@ pub fn check_block_with_expected(fcx0: @mut FnCtxt,\n         let mut any_err = false;\n         for blk.node.stmts.each |s| {\n             check_stmt(fcx, *s);\n-            let s_ty = fcx.node_ty(ast_util::stmt_id(**s));\n+            let s_ty = fcx.node_ty(ast_util::stmt_id(*s));\n             if last_was_bot && !warned && match s.node {\n                   ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n                                                  _}, _) |\n@@ -3350,7 +3350,7 @@ pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: &ast::blk) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(b, |e| {\n-        match e {\n+        match *e {\n             ast::expr_break(_) => true,\n             _ => false\n         }"}, {"sha": "aec7399d5eb97f8bb0fdfd11e7948cd1f25dc39e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -159,11 +159,11 @@ fn regionck_visitor() -> rvt {\n                                   .. *visit::default_visitor()})\n }\n \n-fn visit_item(_item: @ast::item, &&_rcx: @mut Rcx, _v: rvt) {\n+fn visit_item(_item: @ast::item, _rcx: @mut Rcx, _v: rvt) {\n     // Ignore items\n }\n \n-fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_local(l: @ast::local, rcx: @mut Rcx, v: rvt) {\n     // Check to make sure that the regions in all local variables are\n     // within scope.\n     //\n@@ -194,11 +194,11 @@ fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n     }\n }\n \n-fn visit_block(b: &ast::blk, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_block(b: &ast::blk, rcx: @mut Rcx, v: rvt) {\n     visit::visit_block(b, rcx, v);\n }\n \n-fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n     debug!(\"regionck::visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n     for rcx.fcx.inh.adjustments.find(&expr.id).each |&adjustment| {\n@@ -333,7 +333,7 @@ fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_expr(expr, rcx, v);\n }\n \n-fn visit_stmt(s: @ast::stmt, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_stmt(s: @ast::stmt, rcx: @mut Rcx, v: rvt) {\n     visit::visit_stmt(s, rcx, v);\n }\n \n@@ -973,10 +973,10 @@ pub mod guarantor {\n     }\n \n     fn apply_autoderefs(\n-        +rcx: @mut Rcx,\n-        +expr: @ast::expr,\n-        +autoderefs: uint,\n-        +ct: ExprCategorizationType)\n+        rcx: @mut Rcx,\n+        expr: @ast::expr,\n+        autoderefs: uint,\n+        ct: ExprCategorizationType)\n      -> ExprCategorizationType {\n         let mut ct = ct;\n         let tcx = rcx.fcx.ccx.tcx;"}, {"sha": "39715f295ade962d4e8d56addeaceeb467b04cd4", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -135,7 +135,7 @@ fn lookup_vtables(vcx: &VtableContext,\n }\n \n fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n-                id: ast::def_id, +substs: ty::substs,\n+                id: ast::def_id, substs: ty::substs,\n                 is_early: bool) -> Option<ty::substs> {\n     let tcx = vcx.tcx();\n     // use a dummy type just to package up the substs that need fixing up\n@@ -480,7 +480,7 @@ pub fn location_info_for_expr(expr: @ast::expr) -> LocationInfo {\n }\n \n pub fn early_resolve_expr(ex: @ast::expr,\n-                          &&fcx: @mut FnCtxt,\n+                          fcx: @mut FnCtxt,\n                           is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id %? (early: %b): %s\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n@@ -656,7 +656,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n }\n \n fn resolve_expr(ex: @ast::expr,\n-                &&fcx: @mut FnCtxt,\n+                fcx: @mut FnCtxt,\n                 v: visit::vt<@mut FnCtxt>) {\n     early_resolve_expr(ex, fcx, false);\n     visit::visit_expr(ex, fcx, v);"}, {"sha": "0dba55b4e72cfb50a6c68a360386d621433a01e0", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -212,12 +212,12 @@ struct WbCtxt {\n \n type wb_vt = visit::vt<@mut WbCtxt>;\n \n-fn visit_stmt(s: @ast::stmt, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_stmt(s: @ast::stmt, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n     visit::visit_stmt(s, wbcx, v);\n }\n-fn visit_expr(e: @ast::expr, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_expr(e: @ast::expr, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n@@ -256,12 +256,12 @@ fn visit_expr(e: @ast::expr, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     }\n     visit::visit_expr(e, wbcx, v);\n }\n-fn visit_block(b: &ast::blk, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_block(b: &ast::blk, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, b.span, b.node.id);\n     visit::visit_block(b, wbcx, v);\n }\n-fn visit_pat(p: @ast::pat, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_pat(p: @ast::pat, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n     debug!(\"Type for pattern binding %s (id %d) resolved to %s\",\n@@ -271,7 +271,7 @@ fn visit_pat(p: @ast::pat, &&wbcx: @mut WbCtxt, v: wb_vt) {\n                                    p.id)));\n     visit::visit_pat(p, wbcx, v);\n }\n-fn visit_local(l: @ast::local, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_local(l: @ast::local, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     let var_ty = wbcx.fcx.local_ty(l.span, l.node.id);\n     match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n@@ -293,7 +293,7 @@ fn visit_local(l: @ast::local, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     }\n     visit::visit_local(l, wbcx, v);\n }\n-fn visit_item(_item: @ast::item, &&_wbcx: @mut WbCtxt, _v: wb_vt) {\n+fn visit_item(_item: @ast::item, _wbcx: @mut WbCtxt, _v: wb_vt) {\n     // Ignore items\n }\n "}, {"sha": "4225b5da418de1d13e1a5ab46806edb0595e17d4", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -203,7 +203,7 @@ pub impl CoherenceChecker {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        visit_crate(*crate, (), mk_simple_visitor(@SimpleVisitor {\n+        visit_crate(crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n //                debug!(\"(checking coherence) item '%s'\",\n //                       self.crate_context.tcx.sess.str_of(item.ident));\n@@ -655,7 +655,7 @@ pub impl CoherenceChecker {\n \n     // Privileged scope checking\n     fn check_privileged_scopes(self, crate: @crate) {\n-        visit_crate(*crate, (), mk_vt(@Visitor {\n+        visit_crate(crate, (), mk_vt(@Visitor {\n             visit_item: |item, _context, visitor| {\n                 match item.node {\n                     item_mod(ref module_) => {"}, {"sha": "8356b06e8a6c90bbab91ed510a4691e4109057e5", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -111,7 +111,7 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n     }\n \n     visit::visit_crate(\n-        *crate, (),\n+        crate, (),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_item: |a| convert(ccx, a),\n             visit_foreign_item: |a|convert_foreign(ccx, a),"}, {"sha": "fdc96a21b8b5cade4580a1c493208180d7ef8b6d", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -124,7 +124,7 @@ pub struct CombineFields {\n }\n \n pub fn expected_found<C:Combine,T>(\n-        self: &C, +a: T, +b: T) -> ty::expected_found<T> {\n+        self: &C, a: T, b: T) -> ty::expected_found<T> {\n     if self.a_is_expected() {\n         ty::expected_found {expected: a, found: b}\n     } else {"}, {"sha": "db229a407b39a94d1522a53fdc3769768ad98916", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -77,8 +77,8 @@ pub impl CombineFields {\n     fn var_sub_var<T:Copy + InferStr + LatticeValue,\n                    V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n         &self,\n-        +a_id: V,\n-        +b_id: V) -> ures\n+        a_id: V,\n+        b_id: V) -> ures\n     {\n         /*!\n          *\n@@ -130,8 +130,8 @@ pub impl CombineFields {\n     fn var_sub_t<T:Copy + InferStr + LatticeValue,\n                  V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n         &self,\n-        +a_id: V,\n-        +b: T) -> ures\n+        a_id: V,\n+        b: T) -> ures\n     {\n         /*!\n          *\n@@ -154,8 +154,8 @@ pub impl CombineFields {\n     fn t_sub_var<T:Copy + InferStr + LatticeValue,\n                  V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n         &self,\n-        +a: T,\n-        +b_id: V) -> ures\n+        a: T,\n+        b_id: V) -> ures\n     {\n         /*!\n          *\n@@ -206,7 +206,7 @@ pub impl CombineFields {\n     fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n                                 V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n         &self,\n-        +v_id: V,\n+        v_id: V,\n         a: &Bounds<T>,\n         b: &Bounds<T>,\n         rank: uint) -> ures\n@@ -296,7 +296,7 @@ pub impl CombineFields {\n pub trait LatticeDir {\n     fn combine_fields(&self) -> CombineFields;\n     fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T>;\n-    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, +t: T) -> Bounds<T>;\n+    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T>;\n }\n \n pub trait TyLatticeDir {\n@@ -306,7 +306,7 @@ pub trait TyLatticeDir {\n impl LatticeDir for Lub {\n     fn combine_fields(&self) -> CombineFields { **self }\n     fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.ub }\n-    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, +t: T) -> Bounds<T> {\n+    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { ub: Some(t), ..*b }\n     }\n }\n@@ -320,7 +320,7 @@ impl TyLatticeDir for Lub {\n impl LatticeDir for Glb {\n     fn combine_fields(&self) -> CombineFields { **self }\n     fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.lb }\n-    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, +t: T) -> Bounds<T> {\n+    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { lb: Some(t), ..*b }\n     }\n }\n@@ -401,8 +401,8 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n                     T:Copy + InferStr + LatticeValue,\n                     V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n     self: &L,                           // defines whether we want LUB or GLB\n-    +a_vid: V,                          // first variable\n-    +b_vid: V,                          // second variable\n+    a_vid: V,                          // first variable\n+    b_vid: V,                          // second variable\n     lattice_dir_op: LatticeDirOp<T>)    // LUB or GLB operation on types\n     -> cres<LatticeVarResult<V,T>> {\n     let nde_a = self.infcx().get(a_vid);\n@@ -447,7 +447,7 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n                          T:Copy + InferStr + LatticeValue,\n                          V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n     self: &L,\n-    +a_id: V,\n+    a_id: V,\n     b: &T,\n     lattice_dir_op: LatticeDirOp<T>)\n     -> cres<T> {"}, {"sha": "a4a48cf5b788af0845e0ba3e26463d8a677f0cdc", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -643,8 +643,8 @@ pub impl InferCtxt {\n }\n \n fn next_simple_var<V:Copy,T:Copy>(\n-        +counter: &mut uint,\n-        +bindings: &mut ValsAndBindings<V,Option<T>>)\n+        counter: &mut uint,\n+        bindings: &mut ValsAndBindings<V,Option<T>>)\n      -> uint {\n     let id = *counter;\n     *counter += 1;"}, {"sha": "f34a990977ebe07d15128955b11cf34399f93cce", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -563,7 +563,7 @@ enum Constraint {\n }\n \n impl to_bytes::IterBytes for Constraint {\n-   fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+   fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           ConstrainVarSubVar(ref v0, ref v1) =>\n           to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n@@ -584,7 +584,7 @@ struct TwoRegions {\n }\n \n impl to_bytes::IterBytes for TwoRegions {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)\n     }\n }\n@@ -729,7 +729,7 @@ pub impl RegionVarBindings {\n         re_bound(br_fresh(sc))\n     }\n \n-    fn add_constraint(&mut self, +constraint: Constraint, span: span) {\n+    fn add_constraint(&mut self, constraint: Constraint, span: span) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n@@ -995,7 +995,7 @@ pub impl RegionVarBindings {\n \n         return result_set;\n \n-        fn consider_adding_edge(+result_set: ~[Region],\n+        fn consider_adding_edge(result_set: ~[Region],\n                                 r: &Region,\n                                 r1: &Region,\n                                 r2: &Region) -> ~[Region]\n@@ -1030,7 +1030,7 @@ priv impl RegionVarBindings {\n         rm.is_subregion_of(sub, sup)\n     }\n \n-    fn lub_concrete_regions(&self, +a: Region, +b: Region) -> Region {\n+    fn lub_concrete_regions(&self, a: Region, b: Region) -> Region {\n         match (a, b) {\n           (re_static, _) | (_, re_static) => {\n             re_static // nothing lives longer than static\n@@ -1122,8 +1122,8 @@ priv impl RegionVarBindings {\n     }\n \n     fn glb_concrete_regions(&self,\n-                            +a: Region,\n-                            +b: Region)\n+                            a: Region,\n+                            b: Region)\n                          -> cres<Region> {\n         debug!(\"glb_concrete_regions(%?, %?)\", a, b);\n         match (a, b) {\n@@ -1330,7 +1330,7 @@ pub impl RegionVarBindings {\n \n         return (graph);\n \n-        fn insert_edge(+graph: &mut Graph,\n+        fn insert_edge(graph: &mut Graph,\n                        node_id: RegionVid,\n                        edge_dir: Direction,\n                        edge_idx: uint) {\n@@ -1457,9 +1457,9 @@ pub impl RegionVarBindings {\n             }\n         };\n \n-        fn check_node(+self: &mut RegionVarBindings,\n+        fn check_node(self: &mut RegionVarBindings,\n                       a_vid: RegionVid,\n-                      +a_node: &mut GraphNode,\n+                      a_node: &mut GraphNode,\n                       a_region: Region,\n                       b_region: Region)\n                    -> bool {\n@@ -1471,9 +1471,9 @@ pub impl RegionVarBindings {\n             false\n         }\n \n-        fn adjust_node(+self: &mut RegionVarBindings,\n+        fn adjust_node(self: &mut RegionVarBindings,\n                        a_vid: RegionVid,\n-                       +a_node: &mut GraphNode,\n+                       a_node: &mut GraphNode,\n                        a_region: Region,\n                        b_region: Region)\n                     -> bool {"}, {"sha": "220cc91dfdb4b93c95df3d234816cc4a2c36e897", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -42,7 +42,7 @@ pub trait UnifyVid<T> {\n pub impl InferCtxt {\n     fn get<T:Copy, V:Copy+Eq+Vid+UnifyVid<T>>(\n         &mut self,\n-        +vid: V) -> Node<V, T>\n+        vid: V) -> Node<V, T>\n     {\n         /*!\n          *\n@@ -88,8 +88,8 @@ pub impl InferCtxt {\n \n     fn set<T:Copy + InferStr,V:Copy + Vid + ToStr + UnifyVid<T>>(\n             &mut self,\n-            +vid: V,\n-            +new_v: VarValue<V, T>) {\n+            vid: V,\n+            new_v: VarValue<V, T>) {\n         /*!\n          *\n          * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n@@ -147,9 +147,9 @@ pub trait SimplyUnifiable {\n     fn to_type_err(expected_found<Self>) -> ty::type_err;\n }\n \n-pub fn mk_err<T:SimplyUnifiable>(+a_is_expected: bool,\n-                                  +a_t: T,\n-                                  +b_t: T) -> ures {\n+pub fn mk_err<T:SimplyUnifiable>(a_is_expected: bool,\n+                                 a_t: T,\n+                                 b_t: T) -> ures {\n     if a_is_expected {\n         Err(SimplyUnifiable::to_type_err(\n             ty::expected_found {expected: a_t, found: b_t}))\n@@ -163,9 +163,9 @@ pub impl InferCtxt {\n     fn simple_vars<T:Copy + Eq + InferStr + SimplyUnifiable,\n                    V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n             &mut self,\n-            +a_is_expected: bool,\n-            +a_id: V,\n-            +b_id: V)\n+            a_is_expected: bool,\n+            a_id: V,\n+            b_id: V)\n          -> ures {\n         /*!\n          *\n@@ -201,9 +201,9 @@ pub impl InferCtxt {\n     fn simple_var_t<T:Copy + Eq + InferStr + SimplyUnifiable,\n                     V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n             &mut self,\n-            +a_is_expected: bool,\n-            +a_id: V,\n-            +b: T)\n+            a_is_expected: bool,\n+            a_id: V,\n+            b: T)\n          -> ures {\n         /*!\n          *"}, {"sha": "f87c0dad5a9936842c0d37afa2b811b94e4e12a2", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -194,7 +194,7 @@ pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n                            node_id: ast::node_id,\n-                           +substs: ~[ty::t]) {\n+                           substs: ~[ty::t]) {\n     if substs.len() > 0u {\n         debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n@@ -397,7 +397,7 @@ fn check_for_entry_fn(ccx: @mut CrateCtxt) {\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n-                   +trait_map: resolve::TraitMap,\n+                   trait_map: resolve::TraitMap,\n                    crate: @ast::crate)\n                 -> (method_map, vtable_map) {\n     let time_passes = tcx.sess.time_passes();"}, {"sha": "62320a1d34d562e80b120df6c5954a69e8e95f0b", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -272,7 +272,7 @@ pub struct binding_rscope {\n \n pub fn in_binding_rscope<RS:region_scope + Copy + Durable>(\n         self: &RS,\n-        +region_param_names: RegionParamNames)\n+        region_param_names: RegionParamNames)\n      -> binding_rscope {\n     let base = @copy *self;\n     let base = base as @region_scope;"}, {"sha": "573ba4ca41175e584c00606f29a5d1b8eda58ece", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -18,12 +18,10 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[legacy_modes];\n-\n #[allow(non_implicitly_copyable_typarams)];\n #[allow(non_camel_case_types)];\n-#[allow(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n+#[deny(deprecated_pattern)];\n+#[deny(deprecated_mode)];\n \n #[no_core];\n \n@@ -259,12 +257,12 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     let odir = odir.map(|o| Path(*o));\n     let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n     let ofile = ofile.map(|o| Path(*o));\n-    let cfg = build_configuration(sess, binary, input);\n+    let cfg = build_configuration(sess, binary, &input);\n     let pretty = getopts::opt_default(matches, ~\"pretty\", \"normal\").map(\n                     |a| parse_pretty(sess, *a));\n     match pretty {\n       Some::<pp_mode>(ppm) => {\n-        pretty_print_input(sess, cfg, input, ppm);\n+        pretty_print_input(sess, cfg, &input, ppm);\n         return;\n       }\n       None::<pp_mode> => {/* continue */ }\n@@ -282,7 +280,7 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n         return;\n     }\n \n-    compile_input(sess, cfg, input, &odir, &ofile);\n+    compile_input(sess, cfg, &input, &odir, &ofile);\n }\n \n #[deriving(Eq)]\n@@ -303,7 +301,7 @@ diagnostic emitter which records when we hit a fatal error. If the task\n fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n-pub fn monitor(+f: ~fn(diagnostic::Emitter)) {\n+pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n     use core::comm::*;\n     let (p, ch) = stream();\n     let ch = SharedChan::new(ch);"}, {"sha": "93deeecc101064987f4efa59302ec851316a2c9e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -63,12 +63,12 @@ pub fn field_exprs(fields: ~[ast::field]) -> ~[@ast::expr] {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: &ast::blk, p: @fn(ast::expr_) -> bool) -> bool {\n+pub fn loop_query(b: &ast::blk, p: @fn(&ast::expr_) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n-                        &&flag: @mut bool,\n-                        v: visit::vt<@mut bool>) = |e, &&flag, v| {\n-        *flag |= p(e.node);\n+                        flag: @mut bool,\n+                        v: visit::vt<@mut bool>) = |e, flag, v| {\n+        *flag |= p(&e.node);\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n@@ -89,8 +89,8 @@ pub fn loop_query(b: &ast::blk, p: @fn(ast::expr_) -> bool) -> bool {\n pub fn block_query(b: &ast::blk, p: @fn(@ast::expr) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n-                        &&flag: @mut bool,\n-                        v: visit::vt<@mut bool>) = |e, &&flag, v| {\n+                        flag: @mut bool,\n+                        v: visit::vt<@mut bool>) = |e, flag, v| {\n         *flag |= p(e);\n         visit::visit_expr(e, flag, v)\n     };\n@@ -108,7 +108,7 @@ pub fn local_rhs_span(l: @ast::local, def: span) -> span {\n     }\n }\n \n-pub fn pluralize(n: uint, +s: ~str) -> ~str {\n+pub fn pluralize(n: uint, s: ~str) -> ~str {\n     if n == 1 { s }\n     else { str::concat([s, ~\"s\"]) }\n }"}, {"sha": "5e103d6848aa57f4ef3b3386c8122be5041eab2e", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -117,7 +117,7 @@ fn build_ctxt(sess: Session,\n     let ast = syntax::ext::expand::expand_crate(sess.parse_sess,\n                                                 copy sess.opts.cfg, ast);\n     let ast = front::test::modify_for_testing(sess, ast);\n-    let ast_map = ast_map::map_crate(sess.diagnostic(), *ast);\n+    let ast_map = ast_map::map_crate(sess.diagnostic(), ast);\n \n     Ctxt {\n         ast: ast,"}, {"sha": "455720f47ef9071d6d4aa70051d966198254376b", "filename": "src/librustdoc/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fparse.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -39,5 +39,5 @@ pub fn from_str_sess(sess: session::Session, source: ~str) -> @ast::crate {\n }\n \n fn cfg(sess: session::Session, input: driver::input) -> ast::crate_cfg {\n-    driver::build_configuration(sess, @~\"rustdoc\", input)\n+    driver::build_configuration(sess, @~\"rustdoc\", &input)\n }"}, {"sha": "53912e7c947129508cb68b3d355fb52473c92331", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -93,15 +93,15 @@ fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n             for blk.node.stmts.each |stmt| {\n                 match stmt.node {\n                     ast::stmt_decl(*) | ast::stmt_mac(*) => {\n-                        pprust::print_stmt(pp, **stmt);\n+                        pprust::print_stmt(pp, *stmt);\n                         writer.write_line(~\"\");\n                     }\n                     ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n                         match expr.node {\n                             ast::expr_assign(*) |\n                             ast::expr_assign_op(*) |\n                             ast::expr_swap(*) => {\n-                                pprust::print_stmt(pp, **stmt);\n+                                pprust::print_stmt(pp, *stmt);\n                                 writer.write_line(~\"\");\n                             }\n                             _ => {}\n@@ -147,13 +147,13 @@ fn run(repl: Repl, input: ~str) -> Repl {\n     debug!(\"building driver configuration\");\n     let cfg = driver::build_configuration(sess,\n                                           @repl.binary,\n-                                          wrapped);\n+                                          &wrapped);\n \n-    let outputs = driver::build_output_filenames(wrapped, &None, &None, sess);\n+    let outputs = driver::build_output_filenames(&wrapped, &None, &None, sess);\n     debug!(\"calling compile_upto\");\n-    let (crate, _) = driver::compile_upto(sess, cfg, wrapped,\n-                                                 driver::cu_everything,\n-                                                 Some(outputs));\n+    let (crate, _) = driver::compile_upto(sess, cfg, &wrapped,\n+                                          driver::cu_everything,\n+                                          Some(outputs));\n \n     let mut opt = None;\n \n@@ -198,9 +198,9 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n         let input = driver::file_input(src_path);\n         let sess = driver::build_session(options, diagnostic::emit);\n         *sess.building_library = true;\n-        let cfg = driver::build_configuration(sess, @binary, input);\n+        let cfg = driver::build_configuration(sess, @binary, &input);\n         let outputs = driver::build_output_filenames(\n-            input, &None, &None, sess);\n+            &input, &None, &None, sess);\n         // If the library already exists and is newer than the source\n         // file, skip compilation and return None.\n         let mut should_compile = true;\n@@ -228,7 +228,7 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n         }\n         if (should_compile) {\n             io::println(fmt!(\"compiling %s...\", src_filename));\n-            driver::compile_upto(sess, cfg, input, driver::cu_everything,\n+            driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n                                  Some(outputs));\n             true\n         } else { false }"}, {"sha": "705bcc824275049ecf4bace9cd247b387fbdf22b", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -37,7 +37,7 @@ use std::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n use path_util::{dest_dir, normalize};\n-use rustc::driver::session::{lib_crate, bin_crate, unknown_crate, crate_type};\n+use rustc::driver::session::{lib_crate, bin_crate, crate_type};\n \n mod conditions;\n mod usage;\n@@ -82,8 +82,8 @@ impl PkgScript {\n         };\n         let input = driver::file_input(script);\n         let sess = driver::build_session(options, diagnostic::emit);\n-        let cfg = driver::build_configuration(sess, @binary, input);\n-        let (crate, _) = driver::compile_upto(sess, cfg, input,\n+        let cfg = driver::build_configuration(sess, @binary, &input);\n+        let (crate, _) = driver::compile_upto(sess, cfg, &input,\n                                               driver::cu_parse, None);\n         let work_dir = dest_dir(id);\n \n@@ -112,7 +112,7 @@ impl PkgScript {\n         // Collect together any user-defined commands in the package script\n         let crate = util::ready_crate(sess, self.crate);\n         debug!(\"Building output filenames with script name %s\",\n-               driver::source_name(self.input));\n+               driver::source_name(&self.input));\n         match filesearch::get_rustpkg_sysroot() {\n             Ok(r) => {\n                 let root = r.pop().pop().pop().pop(); // :-\\"}, {"sha": "2ab1ea1e7d2ea4ec4e25c7b9070c06237225649d", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -12,7 +12,7 @@ use core::*;\n use core::cmp::Ord;\n use core::hash::Streaming;\n use rustc::driver::{driver, session};\n-use rustc::driver::session::{lib_crate, bin_crate, unknown_crate};\n+use rustc::driver::session::{lib_crate, unknown_crate};\n use rustc::metadata::filesearch;\n use std::getopts::groups::getopts;\n use std::semver;\n@@ -25,7 +25,7 @@ use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::ast::{meta_name_value, meta_list, attribute, crate_};\n use syntax::attr::{mk_attr};\n use rustc::back::link::output_type_exe;\n-use rustc::driver::session::{lib_crate, bin_crate, unknown_crate, crate_type};\n+use rustc::driver::session::{lib_crate, unknown_crate, crate_type};\n \n pub type ExitCode = int; // For now\n \n@@ -516,9 +516,9 @@ pub fn compile_crate_from_input(input: driver::input,\n                                 binary: ~str,\n                                 what: driver::compile_upto) -> @ast::crate {\n     debug!(\"Calling build_output_filenames with %?\", build_dir_opt);\n-    let outputs = driver::build_output_filenames(input, &build_dir_opt, &Some(out_file), sess);\n+    let outputs = driver::build_output_filenames(&input, &build_dir_opt, &Some(out_file), sess);\n     debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n-    let cfg = driver::build_configuration(sess, @binary, input);\n+    let cfg = driver::build_configuration(sess, @binary, &input);\n     match crate_opt {\n         Some(c) => {\n             debug!(\"Calling compile_rest, outputs = %?\", outputs);\n@@ -528,7 +528,7 @@ pub fn compile_crate_from_input(input: driver::input,\n         }\n         None => {\n             debug!(\"Calling compile_upto, outputs = %?\", outputs);\n-            let (crate, _) = driver::compile_upto(sess, cfg, input,\n+            let (crate, _) = driver::compile_upto(sess, cfg, &input,\n                                                   driver::cu_parse, Some(outputs));\n \n             // Inject the inferred link_meta info if it's not already there"}, {"sha": "dd85e886b1ec6160e591d21201f7fbba038ec3e7", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -159,8 +159,8 @@ mod tests {\n \n             assert!(mem as int != 0);\n \n-            return unsafe { c_vec_with_dtor(mem as *mut u8, n as uint,\n-                                         || unsafe { free(mem) }) };\n+            return c_vec_with_dtor(mem as *mut u8, n as uint,\n+                                   || unsafe { free(mem) });\n         }\n     }\n \n@@ -196,7 +196,7 @@ mod tests {\n     #[test]\n     fn test_and_I_mean_it() {\n         let cv = malloc(16u as size_t);\n-        let p = unsafe { ptr(cv) };\n+        let p = ptr(cv);\n \n         set(cv, 0u, 32u8);\n         set(cv, 1u, 33u8);"}, {"sha": "890712a97085b9061990fe4e65804e5744f8e8cc", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -1287,18 +1287,16 @@ mod tests {\n           node::Content(x) => {\n             let str = @mut ~\"\";\n             fn aux(str: @mut ~str, node: @node::Node) {\n-                unsafe {\n-                    match (*node) {\n-                      node::Leaf(x) => {\n-                        *str += str::slice(\n-                            *x.content, x.byte_offset,\n-                            x.byte_offset + x.byte_len).to_owned();\n-                      }\n-                      node::Concat(ref x) => {\n-                        aux(str, x.left);\n-                        aux(str, x.right);\n-                      }\n-                    }\n+                match (*node) {\n+                  node::Leaf(x) => {\n+                    *str += str::slice(\n+                        *x.content, x.byte_offset,\n+                        x.byte_offset + x.byte_len).to_owned();\n+                  }\n+                  node::Concat(ref x) => {\n+                    aux(str, x.left);\n+                    aux(str, x.right);\n+                  }\n                 }\n             }\n             aux(str, x);"}, {"sha": "7e1c9d858ce0c8243c4cbbc56088de644d20bb2c", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 53, "deletions": 61, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -224,36 +224,32 @@ struct AhData {\n \n #[cfg(test)]\n fn impl_uv_iotask_async(iotask: &IoTask) {\n-    unsafe {\n-        let async_handle = ll::async_t();\n-        let ah_ptr = ptr::addr_of(&async_handle);\n-        let (exit_po, exit_ch) = stream::<()>();\n-        let ah_data = AhData {\n-            iotask: iotask.clone(),\n-            exit_ch: SharedChan::new(exit_ch)\n-        };\n-        let ah_data_ptr: *AhData = unsafe {\n-            ptr::to_unsafe_ptr(&ah_data)\n-        };\n-        debug!(\"about to interact\");\n-        do interact(iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\"interacting\");\n-                ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n-                ll::set_data_for_uv_handle(\n-                    ah_ptr, ah_data_ptr as *libc::c_void);\n-                ll::async_send(ah_ptr);\n-            }\n-        };\n-        debug!(\"waiting for async close\");\n-        exit_po.recv();\n-    }\n+    let async_handle = ll::async_t();\n+    let ah_ptr = ptr::addr_of(&async_handle);\n+    let (exit_po, exit_ch) = stream::<()>();\n+    let ah_data = AhData {\n+        iotask: iotask.clone(),\n+        exit_ch: SharedChan::new(exit_ch)\n+    };\n+    let ah_data_ptr: *AhData = ptr::to_unsafe_ptr(&ah_data);\n+    debug!(\"about to interact\");\n+    do interact(iotask) |loop_ptr| {\n+        unsafe {\n+            debug!(\"interacting\");\n+            ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n+            ll::set_data_for_uv_handle(\n+                ah_ptr, ah_data_ptr as *libc::c_void);\n+            ll::async_send(ah_ptr);\n+        }\n+    };\n+    debug!(\"waiting for async close\");\n+    exit_po.recv();\n }\n \n // this fn documents the bear minimum neccesary to roll your own\n // high_level_loop\n #[cfg(test)]\n-unsafe fn spawn_test_loop(exit_ch: ~Chan<()>) -> IoTask {\n+fn spawn_test_loop(exit_ch: ~Chan<()>) -> IoTask {\n     let (iotask_port, iotask_ch) = stream::<IoTask>();\n     do task::spawn_sched(task::ManualThreads(1u)) {\n         debug!(\"about to run a test loop\");\n@@ -265,9 +261,7 @@ unsafe fn spawn_test_loop(exit_ch: ~Chan<()>) -> IoTask {\n \n #[cfg(test)]\n extern fn lifetime_handle_close(handle: *libc::c_void) {\n-    unsafe {\n-        debug!(\"lifetime_handle_close ptr %?\", handle);\n-    }\n+    debug!(\"lifetime_handle_close ptr %?\", handle);\n }\n \n #[cfg(test)]\n@@ -279,38 +273,36 @@ extern fn lifetime_async_callback(handle: *libc::c_void,\n \n #[test]\n fn test_uv_iotask_async() {\n-    unsafe {\n-        let (exit_po, exit_ch) = stream::<()>();\n-        let iotask = &spawn_test_loop(~exit_ch);\n-\n-        debug!(\"spawned iotask\");\n-\n-        // using this handle to manage the lifetime of the\n-        // high_level_loop, as it will exit the first time one of\n-        // the impl_uv_hl_async() is cleaned up with no one ref'd\n-        // handles on the loop (Which can happen under\n-        // race-condition type situations.. this ensures that the\n-        // loop lives until, at least, all of the\n-        // impl_uv_hl_async() runs have been called, at least.\n-        let (work_exit_po, work_exit_ch) = stream::<()>();\n-        let work_exit_ch = SharedChan::new(work_exit_ch);\n-        for iter::repeat(7u) {\n-            let iotask_clone = iotask.clone();\n-            let work_exit_ch_clone = work_exit_ch.clone();\n-            do task::spawn_sched(task::ManualThreads(1u)) {\n-                debug!(\"async\");\n-                impl_uv_iotask_async(&iotask_clone);\n-                debug!(\"done async\");\n-                work_exit_ch_clone.send(());\n-            };\n+    let (exit_po, exit_ch) = stream::<()>();\n+    let iotask = &spawn_test_loop(~exit_ch);\n+\n+    debug!(\"spawned iotask\");\n+\n+    // using this handle to manage the lifetime of the\n+    // high_level_loop, as it will exit the first time one of\n+    // the impl_uv_hl_async() is cleaned up with no one ref'd\n+    // handles on the loop (Which can happen under\n+    // race-condition type situations.. this ensures that the\n+    // loop lives until, at least, all of the\n+    // impl_uv_hl_async() runs have been called, at least.\n+    let (work_exit_po, work_exit_ch) = stream::<()>();\n+    let work_exit_ch = SharedChan::new(work_exit_ch);\n+    for iter::repeat(7u) {\n+        let iotask_clone = iotask.clone();\n+        let work_exit_ch_clone = work_exit_ch.clone();\n+        do task::spawn_sched(task::ManualThreads(1u)) {\n+            debug!(\"async\");\n+            impl_uv_iotask_async(&iotask_clone);\n+            debug!(\"done async\");\n+            work_exit_ch_clone.send(());\n         };\n-        for iter::repeat(7u) {\n-            debug!(\"waiting\");\n-            work_exit_po.recv();\n-        };\n-        debug!(~\"sending teardown_loop msg..\");\n-        exit(iotask);\n-        exit_po.recv();\n-        debug!(~\"after recv on exit_po.. exiting..\");\n-    }\n+    };\n+    for iter::repeat(7u) {\n+        debug!(\"waiting\");\n+        work_exit_po.recv();\n+    };\n+    debug!(~\"sending teardown_loop msg..\");\n+    exit(iotask);\n+    exit_po.recv();\n+    debug!(~\"after recv on exit_po.. exiting..\");\n }"}, {"sha": "a5c531004003abcbff3f018e1234d978a8e372dd", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 50, "deletions": 56, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -1422,10 +1422,8 @@ mod test {\n     }\n \n     extern fn server_after_close_cb(handle: *libc::c_void) {\n-        unsafe {\n-            debug!(\"SERVER server stream closed, should exit. h: %?\",\n-                       handle);\n-        }\n+        debug!(\"SERVER server stream closed, should exit. h: %?\",\n+                   handle);\n     }\n \n     extern fn client_stream_after_close_cb(handle: *libc::c_void) {\n@@ -1709,48 +1707,46 @@ mod test {\n     // this is the impl for a test that is (maybe) ran on a\n     // per-platform/arch basis below\n     pub fn impl_uv_tcp_server_and_request() {\n-        unsafe {\n-            let bind_ip = ~\"0.0.0.0\";\n-            let request_ip = ~\"127.0.0.1\";\n-            let port = 8886;\n-            let kill_server_msg = ~\"does a dog have buddha nature?\";\n-            let server_resp_msg = ~\"mu!\";\n-            let (client_port, client_chan) = stream::<~str>();\n-            let client_chan = SharedChan::new(client_chan);\n-            let (server_port, server_chan) = stream::<~str>();\n-            let server_chan = SharedChan::new(server_chan);\n-\n-            let (continue_port, continue_chan) = stream::<bool>();\n-            let continue_chan = SharedChan::new(continue_chan);\n-\n-            let kill_server_msg_copy = copy kill_server_msg;\n-            let server_resp_msg_copy = copy server_resp_msg;\n-            do task::spawn_sched(task::ManualThreads(1)) {\n-                impl_uv_tcp_server(bind_ip, port,\n-                                   copy kill_server_msg_copy,\n-                                   copy server_resp_msg_copy,\n-                                   server_chan.clone(),\n-                                   continue_chan.clone());\n-            };\n-\n-            // block until the server up is.. possibly a race?\n-            debug!(~\"before receiving on server continue_port\");\n-            continue_port.recv();\n-            debug!(~\"received on continue port, set up tcp client\");\n-\n-            let kill_server_msg_copy = copy kill_server_msg;\n-            do task::spawn_sched(task::ManualThreads(1u)) {\n-                impl_uv_tcp_request(request_ip, port,\n-                                   kill_server_msg_copy,\n-                                   client_chan.clone());\n-            };\n-\n-            let msg_from_client = server_port.recv();\n-            let msg_from_server = client_port.recv();\n-\n-            assert!(str::contains(msg_from_client, kill_server_msg));\n-            assert!(str::contains(msg_from_server, server_resp_msg));\n-        }\n+        let bind_ip = ~\"0.0.0.0\";\n+        let request_ip = ~\"127.0.0.1\";\n+        let port = 8886;\n+        let kill_server_msg = ~\"does a dog have buddha nature?\";\n+        let server_resp_msg = ~\"mu!\";\n+        let (client_port, client_chan) = stream::<~str>();\n+        let client_chan = SharedChan::new(client_chan);\n+        let (server_port, server_chan) = stream::<~str>();\n+        let server_chan = SharedChan::new(server_chan);\n+\n+        let (continue_port, continue_chan) = stream::<bool>();\n+        let continue_chan = SharedChan::new(continue_chan);\n+\n+        let kill_server_msg_copy = copy kill_server_msg;\n+        let server_resp_msg_copy = copy server_resp_msg;\n+        do task::spawn_sched(task::ManualThreads(1)) {\n+            impl_uv_tcp_server(bind_ip, port,\n+                               copy kill_server_msg_copy,\n+                               copy server_resp_msg_copy,\n+                               server_chan.clone(),\n+                               continue_chan.clone());\n+        };\n+\n+        // block until the server up is.. possibly a race?\n+        debug!(~\"before receiving on server continue_port\");\n+        continue_port.recv();\n+        debug!(~\"received on continue port, set up tcp client\");\n+\n+        let kill_server_msg_copy = copy kill_server_msg;\n+        do task::spawn_sched(task::ManualThreads(1u)) {\n+            impl_uv_tcp_request(request_ip, port,\n+                               kill_server_msg_copy,\n+                               client_chan.clone());\n+        };\n+\n+        let msg_from_client = server_port.recv();\n+        let msg_from_server = client_port.recv();\n+\n+        assert!(str::contains(msg_from_client, kill_server_msg));\n+        assert!(str::contains(msg_from_server, server_resp_msg));\n     }\n \n     // FIXME don't run on fbsd or linux 32 bit(#2064)\n@@ -1784,17 +1780,15 @@ mod test {\n \n     fn struct_size_check_common<TStruct>(t_name: ~str,\n                                          foreign_size: libc::c_uint) {\n-        unsafe {\n-            let rust_size = sys::size_of::<TStruct>();\n-            let sizes_match = foreign_size as uint == rust_size;\n-            if !sizes_match {\n-                let output = fmt!(\n-                    \"STRUCT_SIZE FAILURE: %s -- actual: %u expected: %u\",\n-                    t_name, rust_size, foreign_size as uint);\n-                debug!(output);\n-            }\n-            assert!(sizes_match);\n+        let rust_size = sys::size_of::<TStruct>();\n+        let sizes_match = foreign_size as uint == rust_size;\n+        if !sizes_match {\n+            let output = fmt!(\n+                \"STRUCT_SIZE FAILURE: %s -- actual: %u expected: %u\",\n+                t_name, rust_size, foreign_size as uint);\n+            debug!(output);\n         }\n+        assert!(sizes_match);\n     }\n \n     // struct size tests"}, {"sha": "b6580b4c5a1b2bde74311c9dc994c0c74c119104", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -255,13 +255,13 @@ pub impl AbiSet {\n }\n \n impl to_bytes::IterBytes for Abi {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.index().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for AbiSet {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.bits.iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "b0b3e45abe501203965eb5c53e6eac5e4d2b2aad", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -97,7 +97,7 @@ impl<D:Decoder> Decodable<D> for ident {\n }\n \n impl to_bytes::IterBytes for ident {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }\n@@ -284,7 +284,7 @@ pub enum binding_mode {\n }\n \n impl to_bytes::IterBytes for binding_mode {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           bind_by_copy => 0u8.iter_bytes(lsb0, f),\n \n@@ -330,7 +330,7 @@ pub enum pat_ {\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n impl to_bytes::IterBytes for mutability {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -345,7 +345,7 @@ pub enum Sigil {\n }\n \n impl to_bytes::IterBytes for Sigil {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n@@ -428,7 +428,7 @@ pub enum inferable<T> {\n }\n \n impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           expl(ref t) =>\n           to_bytes::iter_bytes_2(&0u8, t, lsb0, f),\n@@ -446,7 +446,7 @@ impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n pub enum rmode { by_ref, by_copy }\n \n impl to_bytes::IterBytes for rmode {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -781,7 +781,7 @@ impl ToStr for int_ty {\n }\n \n impl to_bytes::IterBytes for int_ty {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -798,7 +798,7 @@ impl ToStr for uint_ty {\n }\n \n impl to_bytes::IterBytes for uint_ty {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -815,7 +815,7 @@ impl ToStr for float_ty {\n }\n \n impl to_bytes::IterBytes for float_ty {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -860,7 +860,7 @@ impl ToStr for Onceness {\n }\n \n impl to_bytes::IterBytes for Onceness {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n@@ -911,7 +911,7 @@ pub enum ty_ {\n }\n \n impl to_bytes::IterBytes for Ty {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n }\n@@ -979,7 +979,7 @@ impl ToStr for purity {\n }\n \n impl to_bytes::IterBytes for purity {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -994,7 +994,7 @@ pub enum ret_style {\n }\n \n impl to_bytes::IterBytes for ret_style {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -1268,7 +1268,7 @@ pub enum item_ {\n pub enum struct_mutability { struct_mutable, struct_immutable }\n \n impl to_bytes::IterBytes for struct_mutability {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "05e67196b4c15d3b9de063ff4e7c72f8132ac522", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -115,7 +115,7 @@ pub struct Ctx {\n \n pub type vt = visit::vt<@mut Ctx>;\n \n-pub fn extend(cx: @mut Ctx, +elt: ident) -> @path {\n+pub fn extend(cx: @mut Ctx, elt: ident) -> @path {\n     @(vec::append(copy cx.path, ~[path_name(elt)]))\n }\n \n@@ -132,7 +132,7 @@ pub fn mk_ast_map_visitor() -> vt {\n     });\n }\n \n-pub fn map_crate(diag: @span_handler, c: crate) -> map {\n+pub fn map_crate(diag: @span_handler, c: @crate) -> map {\n     let cx = @mut Ctx {\n         map: @mut HashMap::new(),\n         path: ~[],\n@@ -148,8 +148,8 @@ pub fn map_crate(diag: @span_handler, c: crate) -> map {\n // the item itself.\n pub fn map_decoded_item(diag: @span_handler,\n                         map: map,\n-                        +path: path,\n-                        ii: inlined_item) {\n+                        path: path,\n+                        ii: &inlined_item) {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.  (In particular, I think these ids are only used in\n@@ -167,7 +167,7 @@ pub fn map_decoded_item(diag: @span_handler,\n     // methods get added to the AST map when their impl is visited.  Since we\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now:\n-    match ii {\n+    match *ii {\n       ii_item(*) | ii_dtor(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n         cx.map.insert(i.id, node_foreign_item(i,\n@@ -190,7 +190,7 @@ pub fn map_fn(\n     body: &blk,\n     sp: codemap::span,\n     id: node_id,\n-    &&cx: @mut Ctx,\n+    cx: @mut Ctx,\n     v: visit::vt<@mut Ctx>\n ) {\n     for decl.inputs.each |a| {\n@@ -222,7 +222,7 @@ pub fn map_fn(\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n-pub fn map_block(b: &blk, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_block(b: &blk, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy *b));\n     visit::visit_block(b, cx, v);\n }\n@@ -239,24 +239,24 @@ pub fn number_pat(cx: @mut Ctx, pat: @pat) {\n     };\n }\n \n-pub fn map_local(loc: @local, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_local(loc: @local, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     number_pat(cx, loc.node.pat);\n     visit::visit_local(loc, cx, v);\n }\n \n-pub fn map_arm(arm: &arm, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_arm(arm: &arm, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     number_pat(cx, arm.pats[0]);\n     visit::visit_arm(arm, cx, v);\n }\n \n pub fn map_method(impl_did: def_id, impl_path: @path,\n-                  m: @method, &&cx: @mut Ctx) {\n+                  m: @method, cx: @mut Ctx) {\n     cx.map.insert(m.id, node_method(m, impl_did, impl_path));\n     cx.map.insert(m.self_id, node_local(cx.local_id));\n     cx.local_id += 1u;\n }\n \n-pub fn map_item(i: @item, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_item(i: @item, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     match i.node {\n@@ -355,13 +355,13 @@ pub fn map_struct_def(\n     }\n }\n \n-pub fn map_expr(ex: @expr, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_expr(ex: @expr, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, cx, v);\n }\n \n-pub fn map_stmt(stmt: @stmt, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n-    cx.map.insert(stmt_id(*stmt), node_stmt(stmt));\n+pub fn map_stmt(stmt: @stmt, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+    cx.map.insert(stmt_id(stmt), node_stmt(stmt));\n     visit::visit_stmt(stmt, cx, v);\n }\n \n@@ -408,7 +408,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       }\n       Some(&node_stmt(stmt)) => {\n         fmt!(\"stmt %s (id=%?)\",\n-             pprust::stmt_to_str(*stmt, itr), id)\n+             pprust::stmt_to_str(stmt, itr), id)\n       }\n       Some(&node_arg(_, _)) => { // add more info here\n         fmt!(\"arg (id=%?)\", id)\n@@ -430,7 +430,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n \n pub fn node_item_query<Result>(items: map, id: node_id,\n                                query: &fn(@item) -> Result,\n-                               +error_msg: ~str) -> Result {\n+                               error_msg: ~str) -> Result {\n     match items.find(&id) {\n         Some(&node_item(it, _)) => query(it),\n         _ => fail!(error_msg)"}, {"sha": "910c9857d2d635888efbff6a390b11cc5fc363db", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -39,7 +39,7 @@ pub fn local_def(id: node_id) -> def_id {\n \n pub fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n \n-pub fn stmt_id(s: stmt) -> node_id {\n+pub fn stmt_id(s: &stmt) -> node_id {\n     match s.node {\n       stmt_decl(_, id) => id,\n       stmt_expr(_, id) => id,\n@@ -200,7 +200,7 @@ pub fn is_call_expr(e: @expr) -> bool {\n // This makes def_id hashable\n impl to_bytes::IterBytes for def_id {\n     #[inline(always)]\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n     }\n }\n@@ -211,7 +211,7 @@ pub fn block_from_expr(e: @expr) -> blk {\n }\n \n pub fn default_block(\n-    +stmts1: ~[@stmt],\n+    stmts1: ~[@stmt],\n     expr1: Option<@expr>,\n     id1: node_id\n ) -> blk_ {\n@@ -224,15 +224,15 @@ pub fn default_block(\n     }\n }\n \n-pub fn ident_to_path(s: span, +i: ident) -> @Path {\n+pub fn ident_to_path(s: span, i: ident) -> @Path {\n     @ast::Path { span: s,\n                  global: false,\n                  idents: ~[i],\n                  rp: None,\n                  types: ~[] }\n }\n \n-pub fn ident_to_pat(id: node_id, s: span, +i: ident) -> @pat {\n+pub fn ident_to_pat(id: node_id, s: span, i: ident) -> @pat {\n     @ast::pat { id: id,\n                 node: pat_ident(bind_by_copy, ident_to_path(s, i), None),\n                 span: s }\n@@ -300,7 +300,7 @@ pub fn struct_field_visibility(field: ast::struct_field) -> visibility {\n pub trait inlined_item_utils {\n     fn ident(&self) -> ident;\n     fn id(&self) -> ast::node_id;\n-    fn accept<E>(&self, e: E, v: visit::vt<E>);\n+    fn accept<E: Copy>(&self, e: E, v: visit::vt<E>);\n }\n \n impl inlined_item_utils for inlined_item {\n@@ -322,7 +322,7 @@ impl inlined_item_utils for inlined_item {\n         }\n     }\n \n-    fn accept<E>(&self, e: E, v: visit::vt<E>) {\n+    fn accept<E: Copy>(&self, e: E, v: visit::vt<E>) {\n         match *self {\n             ii_item(i) => (v.visit_item)(i, e, v),\n             ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n@@ -435,7 +435,7 @@ pub fn id_visitor(vfn: @fn(node_id)) -> visit::vt<()> {\n \n         visit_local: |l| vfn(l.node.id),\n         visit_block: |b| vfn(b.node.id),\n-        visit_stmt: |s| vfn(ast_util::stmt_id(*s)),\n+        visit_stmt: |s| vfn(ast_util::stmt_id(s)),\n         visit_arm: |_| {},\n         visit_pat: |p| vfn(p.id),\n         visit_decl: |_| {},\n@@ -491,7 +491,7 @@ pub fn id_visitor(vfn: @fn(node_id)) -> visit::vt<()> {\n     })\n }\n \n-pub fn visit_ids_for_inlined_item(item: inlined_item, vfn: @fn(node_id)) {\n+pub fn visit_ids_for_inlined_item(item: &inlined_item, vfn: @fn(node_id)) {\n     item.accept((), id_visitor(vfn));\n }\n \n@@ -505,7 +505,7 @@ pub fn compute_id_range(visit_ids_fn: &fn(@fn(node_id))) -> id_range {\n     id_range { min: *min, max: *max }\n }\n \n-pub fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {\n+pub fn compute_id_range_for_inlined_item(item: &inlined_item) -> id_range {\n     compute_id_range(|f| visit_ids_for_inlined_item(item, f))\n }\n \n@@ -609,7 +609,7 @@ pub fn mk_rename (id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n pub fn mk_sctable() -> SCTable { ~[EmptyCtxt] }\n \n /// Add a value to the end of a vec, return its index\n-fn idx_push<T>(vec: &mut ~[T], +val: T) -> uint {\n+fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n     vec.push(val);\n     vec.len() - 1\n }"}, {"sha": "98cfdd33ef6b64ce25558ddd118feef3e041a85d", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -31,12 +31,12 @@ pub fn mk_name_value_item_str(name: @~str, value: @~str)\n     mk_name_value_item(name, value_lit)\n }\n \n-pub fn mk_name_value_item(name: @~str, +value: ast::lit)\n+pub fn mk_name_value_item(name: @~str, value: ast::lit)\n         -> @ast::meta_item {\n     @dummy_spanned(ast::meta_name_value(name, value))\n }\n \n-pub fn mk_list_item(name: @~str, +items: ~[@ast::meta_item]) ->\n+pub fn mk_list_item(name: @~str, items: ~[@ast::meta_item]) ->\n    @ast::meta_item {\n     @dummy_spanned(ast::meta_list(name, items))\n }\n@@ -51,8 +51,8 @@ pub fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n                                     is_sugared_doc: false })\n }\n \n-pub fn mk_sugared_doc_attr(+text: ~str,\n-                           +lo: BytePos, +hi: BytePos) -> ast::attribute {\n+pub fn mk_sugared_doc_attr(text: ~str,\n+                           lo: BytePos, hi: BytePos) -> ast::attribute {\n     let style = doc_comment_style(text);\n     let lit = spanned(lo, hi, ast::lit_str(@text));\n     let attr = ast::attribute_ {"}, {"sha": "bd8aa7011b7b7f993f546f4ef469867cfebaa7ea", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -71,7 +71,7 @@ impl Sub<BytePos, BytePos> for BytePos {\n }\n \n impl to_bytes::IterBytes for BytePos {\n-    fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n@@ -89,7 +89,7 @@ impl cmp::Ord for CharPos {\n }\n \n impl to_bytes::IterBytes for CharPos {\n-    fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n@@ -141,20 +141,20 @@ impl<D:Decoder> Decodable<D> for span {\n     }\n }\n \n-pub fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n+pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }\n \n-pub fn respan<T>(sp: span, +t: T) -> spanned<T> {\n+pub fn respan<T>(sp: span, t: T) -> spanned<T> {\n     spanned {node: t, span: sp}\n }\n \n-pub fn dummy_spanned<T>(+t: T) -> spanned<T> {\n+pub fn dummy_spanned<T>(t: T) -> spanned<T> {\n     respan(dummy_sp(), t)\n }\n \n /* assuming that we're not in macro expansion */\n-pub fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n+pub fn mk_sp(lo: BytePos, hi: BytePos) -> span {\n     span {lo: lo, hi: hi, expn_info: None}\n }\n \n@@ -247,7 +247,7 @@ pub impl FileMap {\n     // UNCHECKED INVARIANT: these offsets must be added in the right\n     // order and must be in the right places; there is shared knowledge\n     // about what ends a line between this file and parse.rs\n-    fn next_line(&self, +pos: BytePos) {\n+    fn next_line(&self, pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n         let lines = &mut *self.lines;\n         assert!((lines.len() == 0) || (lines[lines.len() - 1] < pos));\n@@ -287,14 +287,14 @@ pub impl CodeMap {\n     }\n \n     /// Add a new FileMap to the CodeMap and return it\n-    fn new_filemap(&self, +filename: FileName, src: @~str) -> @FileMap {\n+    fn new_filemap(&self, filename: FileName, src: @~str) -> @FileMap {\n         return self.new_filemap_w_substr(filename, FssNone, src);\n     }\n \n     fn new_filemap_w_substr(\n         &self,\n-        +filename: FileName,\n-        +substr: FileSubstr,\n+        filename: FileName,\n+        substr: FileSubstr,\n         src: @~str\n     ) -> @FileMap {\n         let files = &mut *self.files;\n@@ -325,11 +325,11 @@ pub impl CodeMap {\n     }\n \n     /// Lookup source information about a BytePos\n-    pub fn lookup_char_pos(&self, +pos: BytePos) -> Loc {\n+    pub fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n         return self.lookup_pos(pos);\n     }\n \n-    pub fn lookup_char_pos_adj(&self, +pos: BytePos) -> LocWithOpt\n+    pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt\n     {\n         let loc = self.lookup_char_pos(pos);\n         match (loc.file.substr) {\n@@ -405,7 +405,7 @@ pub impl CodeMap {\n \n priv impl CodeMap {\n \n-    fn lookup_filemap_idx(&self, +pos: BytePos) -> uint {\n+    fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n         let files = &*self.files;\n         let len = files.len();\n         let mut a = 0u;\n@@ -440,7 +440,7 @@ priv impl CodeMap {\n         return FileMapAndLine {fm: f, line: a};\n     }\n \n-    fn lookup_pos(&self, +pos: BytePos) -> Loc {\n+    fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_local_charpos(pos);\n@@ -466,7 +466,7 @@ priv impl CodeMap {\n                     lo.line, lo.col.to_uint(), hi.line, hi.col.to_uint())\n     }\n \n-    fn lookup_byte_offset(&self, +bpos: BytePos)\n+    fn lookup_byte_offset(&self, bpos: BytePos)\n         -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let fm = self.files[idx];\n@@ -476,7 +476,7 @@ priv impl CodeMap {\n \n     // Converts an absolute BytePos to a CharPos relative to the file it is\n     // located in\n-    fn bytepos_to_local_charpos(&self, +bpos: BytePos) -> CharPos {\n+    fn bytepos_to_local_charpos(&self, bpos: BytePos) -> CharPos {\n         debug!(\"codemap: converting %? to char pos\", bpos);\n         let idx = self.lookup_filemap_idx(bpos);\n         let map = self.files[idx];"}, {"sha": "67c09c00733f8fa88dc2d4ad25e979d42a8f7484", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -239,7 +239,7 @@ priv impl @ext_ctxt {\n         }\n     }\n \n-    fn expr(&self, span: span, +node: ast::expr_) -> @ast::expr {\n+    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr {\n         @ast::expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -248,7 +248,7 @@ priv impl @ext_ctxt {\n         }\n     }\n \n-    fn path(&self, span: span, +strs: ~[ast::ident]) -> @ast::Path {\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n         @ast::Path {\n             span: span,\n             global: false,\n@@ -258,7 +258,7 @@ priv impl @ext_ctxt {\n         }\n     }\n \n-    fn path_global(&self, span: span, +strs: ~[ast::ident]) -> @ast::Path {\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n         @ast::Path {\n             span: span,\n             global: true,\n@@ -271,8 +271,8 @@ priv impl @ext_ctxt {\n     fn path_tps(\n         &self,\n         span: span,\n-        +strs: ~[ast::ident],\n-        +tps: ~[@ast::Ty]\n+        strs: ~[ast::ident],\n+        tps: ~[@ast::Ty]\n     ) -> @ast::Path {\n         @ast::Path {\n             span: span,\n@@ -286,8 +286,8 @@ priv impl @ext_ctxt {\n     fn path_tps_global(\n         &self,\n         span: span,\n-        +strs: ~[ast::ident],\n-        +tps: ~[@ast::Ty]\n+        strs: ~[ast::ident],\n+        tps: ~[@ast::Ty]\n     ) -> @ast::Path {\n         @ast::Path {\n             span: span,\n@@ -301,8 +301,8 @@ priv impl @ext_ctxt {\n     fn ty_path(\n         &self,\n         span: span,\n-        +strs: ~[ast::ident],\n-        +tps: ~[@ast::Ty]\n+        strs: ~[ast::ident],\n+        tps: ~[@ast::Ty]\n     ) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n@@ -349,13 +349,13 @@ priv impl @ext_ctxt {\n                                 span: span}))\n     }\n \n-    fn lambda(&self, +blk: ast::blk) -> @ast::expr {\n+    fn lambda(&self, blk: ast::blk) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n         quote_expr!( || $blk_e )\n     }\n \n-    fn blk(&self, span: span, +stmts: ~[@ast::stmt]) -> ast::blk {\n+    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n         codemap::spanned {\n             node: ast::blk_ {\n                 view_items: ~[],\n@@ -381,19 +381,19 @@ priv impl @ext_ctxt {\n         }\n     }\n \n-    fn expr_path(&self, span: span, +strs: ~[ast::ident]) -> @ast::expr {\n+    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr {\n         self.expr(span, ast::expr_path(self.path(span, strs)))\n     }\n \n     fn expr_path_global(\n         &self,\n         span: span,\n-        +strs: ~[ast::ident]\n+        strs: ~[ast::ident]\n     ) -> @ast::expr {\n         self.expr(span, ast::expr_path(self.path_global(span, strs)))\n     }\n \n-    fn expr_var(&self, span: span, +var: ~str) -> @ast::expr {\n+    fn expr_var(&self, span: span, var: ~str) -> @ast::expr {\n         self.expr_path(span, ~[self.ident_of(var)])\n     }\n \n@@ -410,7 +410,7 @@ priv impl @ext_ctxt {\n         &self,\n         span: span,\n         expr: @ast::expr,\n-        +args: ~[@ast::expr]\n+        args: ~[@ast::expr]\n     ) -> @ast::expr {\n         self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n     }\n@@ -420,7 +420,7 @@ priv impl @ext_ctxt {\n         span: span,\n         expr: @ast::expr,\n         ident: ast::ident,\n-        +args: ~[@ast::expr]\n+        args: ~[@ast::expr]\n     ) -> @ast::expr {\n         self.expr(span, ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n     }\n@@ -429,7 +429,7 @@ priv impl @ext_ctxt {\n         self.lambda(self.expr_blk(expr))\n     }\n \n-    fn lambda_stmts(&self, span: span, +stmts: ~[@ast::stmt]) -> @ast::expr {\n+    fn lambda_stmts(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n         self.lambda(self.blk(span, stmts))\n     }\n }\n@@ -597,7 +597,7 @@ fn mk_deser_impl(\n fn mk_ser_method(\n     cx: @ext_ctxt,\n     span: span,\n-    +ser_body: ast::blk\n+    ser_body: ast::blk\n ) -> @ast::method {\n     let ty_s = @ast::Ty {\n         id: cx.next_id(),\n@@ -660,7 +660,7 @@ fn mk_deser_method(\n     cx: @ext_ctxt,\n     span: span,\n     ty: @ast::Ty,\n-    +deser_body: ast::blk\n+    deser_body: ast::blk\n ) -> @ast::method {\n     let ty_d = @ast::Ty {\n         id: cx.next_id(),\n@@ -864,7 +864,7 @@ fn mk_enum_ser_impl(\n     cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    +enum_def: ast::enum_def,\n+    enum_def: ast::enum_def,\n     generics: &ast::Generics\n ) -> @ast::item {\n     let body = mk_enum_ser_body(\n@@ -881,7 +881,7 @@ fn mk_enum_deser_impl(\n     cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    +enum_def: ast::enum_def,\n+    enum_def: ast::enum_def,\n     generics: &ast::Generics\n ) -> @ast::item {\n     let body = mk_enum_deser_body(\n@@ -974,7 +974,7 @@ fn mk_enum_ser_body(\n     cx: @ext_ctxt,\n     span: span,\n     name: ast::ident,\n-    +variants: ~[ast::variant]\n+    variants: ~[ast::variant]\n ) -> @ast::expr {\n     let arms = do variants.mapi |v_idx, variant| {\n         match variant.node.kind {\n@@ -1219,37 +1219,37 @@ mod test {\n     impl Encoder for TestEncoder {\n         fn emit_nil(&self) { self.add_to_log(CallToEmitNil) }\n \n-        fn emit_uint(&self, +v: uint) {self.add_to_log(CallToEmitUint(v)); }\n-        fn emit_u64(&self, +_v: u64) { self.add_unknown_to_log(); }\n-        fn emit_u32(&self, +_v: u32) { self.add_unknown_to_log(); }\n-        fn emit_u16(&self, +_v: u16) { self.add_unknown_to_log(); }\n-        fn emit_u8(&self, +_v: u8)   { self.add_unknown_to_log(); }\n+        fn emit_uint(&self, v: uint) {self.add_to_log(CallToEmitUint(v)); }\n+        fn emit_u64(&self, _v: u64) { self.add_unknown_to_log(); }\n+        fn emit_u32(&self, _v: u32) { self.add_unknown_to_log(); }\n+        fn emit_u16(&self, _v: u16) { self.add_unknown_to_log(); }\n+        fn emit_u8(&self, _v: u8)   { self.add_unknown_to_log(); }\n \n-        fn emit_int(&self, +_v: int) { self.add_unknown_to_log(); }\n-        fn emit_i64(&self, +_v: i64) { self.add_unknown_to_log(); }\n-        fn emit_i32(&self, +_v: i32) { self.add_unknown_to_log(); }\n-        fn emit_i16(&self, +_v: i16) { self.add_unknown_to_log(); }\n-        fn emit_i8(&self, +_v: i8)   { self.add_unknown_to_log(); }\n+        fn emit_int(&self, _v: int) { self.add_unknown_to_log(); }\n+        fn emit_i64(&self, _v: i64) { self.add_unknown_to_log(); }\n+        fn emit_i32(&self, _v: i32) { self.add_unknown_to_log(); }\n+        fn emit_i16(&self, _v: i16) { self.add_unknown_to_log(); }\n+        fn emit_i8(&self, _v: i8)   { self.add_unknown_to_log(); }\n \n-        fn emit_bool(&self, +_v: bool) { self.add_unknown_to_log(); }\n+        fn emit_bool(&self, _v: bool) { self.add_unknown_to_log(); }\n \n-        fn emit_f64(&self, +_v: f64) { self.add_unknown_to_log(); }\n-        fn emit_f32(&self, +_v: f32) { self.add_unknown_to_log(); }\n-        fn emit_float(&self, +_v: float) { self.add_unknown_to_log(); }\n+        fn emit_f64(&self, _v: f64) { self.add_unknown_to_log(); }\n+        fn emit_f32(&self, _v: f32) { self.add_unknown_to_log(); }\n+        fn emit_float(&self, _v: float) { self.add_unknown_to_log(); }\n \n-        fn emit_char(&self, +_v: char) { self.add_unknown_to_log(); }\n-        fn emit_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n+        fn emit_char(&self, _v: char) { self.add_unknown_to_log(); }\n+        fn emit_str(&self, _v: &str) { self.add_unknown_to_log(); }\n \n         fn emit_enum(&self, name: &str, f: &fn()) {\n             self.add_to_log(CallToEmitEnum(name.to_str())); f(); }\n \n-        fn emit_enum_variant(&self, name: &str, +id: uint,\n-                             +cnt: uint, f: &fn()) {\n+        fn emit_enum_variant(&self, name: &str, id: uint,\n+                             cnt: uint, f: &fn()) {\n             self.add_to_log(CallToEmitEnumVariant (name.to_str(),id,cnt));\n             f();\n         }\n \n-        fn emit_enum_variant_arg(&self, +idx: uint, f: &fn()) {\n+        fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n             self.add_to_log(CallToEmitEnumVariantArg (idx)); f();\n         }\n \n@@ -1261,10 +1261,10 @@ mod test {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&self, name: &str, +len: uint, f: &fn()) {\n+        fn emit_struct(&self, name: &str, len: uint, f: &fn()) {\n             self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n         }\n-        fn emit_struct_field(&self, name: &str, +idx: uint, f: &fn()) {\n+        fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n             self.add_to_log(CallToEmitField (name.to_str(),idx)); f();\n         }\n \n@@ -1294,10 +1294,10 @@ mod test {\n             f();\n         }\n \n-        fn emit_seq(&self, +_len: uint, f: &fn()) {\n+        fn emit_seq(&self, _len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_seq_elt(&self, +_idx: uint, f: &fn()) {\n+        fn emit_seq_elt(&self, _idx: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n "}, {"sha": "4eb48d12bfeab67c9f86f3886115ce4153bf60f0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -238,7 +238,7 @@ pub trait ext_ctxt {\n     fn ident_of(@mut self, st: ~str) -> ast::ident;\n }\n \n-pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, +cfg: ast::crate_cfg)\n+pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n             -> @ext_ctxt {\n     struct CtxtRepr {\n         parse_sess: @mut parse::ParseSess,\n@@ -439,7 +439,7 @@ pub enum MapChain<K,V> {\n impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n \n     // Constructor. I don't think we need a zero-arg one.\n-    fn new(+init: ~HashMap<K,@V>) -> @mut MapChain<K,V> {\n+    fn new(init: ~HashMap<K,@V>) -> @mut MapChain<K,V> {\n         @mut BaseMapChain(init)\n     }\n \n@@ -509,7 +509,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n     }\n \n     // insert the binding into the top-level map\n-    fn insert (&mut self, +key: K, +ext: @V) -> bool {\n+    fn insert (&mut self, key: K, ext: @V) -> bool {\n         // can't abstract over get_map because of flow sensitivity...\n         match *self {\n             BaseMapChain (~ref mut map) => map.insert(key, ext),"}, {"sha": "ff78ddb803cde0eab25f1e8f97168f64ccf6e8b5", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -27,7 +27,7 @@ pub struct Field {\n \n pub fn mk_expr(cx: @ext_ctxt,\n                sp: codemap::span,\n-               +expr: ast::expr_)\n+               expr: ast::expr_)\n             -> @ast::expr {\n     @ast::expr {\n         id: cx.next_id(),\n@@ -63,44 +63,44 @@ pub fn mk_unary(cx: @ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n }\n-pub fn mk_raw_path(sp: span, +idents: ~[ast::ident]) -> @ast::Path {\n+pub fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::Path {\n     mk_raw_path_(sp, idents, ~[])\n }\n pub fn mk_raw_path_(sp: span,\n-                    +idents: ~[ast::ident],\n-                    +types: ~[@ast::Ty])\n+                    idents: ~[ast::ident],\n+                    types: ~[@ast::Ty])\n                  -> @ast::Path {\n     @ast::Path { span: sp,\n                  global: false,\n                  idents: idents,\n                  rp: None,\n                  types: types }\n }\n-pub fn mk_raw_path_global(sp: span, +idents: ~[ast::ident]) -> @ast::Path {\n+pub fn mk_raw_path_global(sp: span, idents: ~[ast::ident]) -> @ast::Path {\n     mk_raw_path_global_(sp, idents, ~[])\n }\n pub fn mk_raw_path_global_(sp: span,\n-                           +idents: ~[ast::ident],\n-                           +types: ~[@ast::Ty]) -> @ast::Path {\n+                           idents: ~[ast::ident],\n+                           types: ~[@ast::Ty]) -> @ast::Path {\n     @ast::Path { span: sp,\n                  global: true,\n                  idents: idents,\n                  rp: None,\n                  types: types }\n }\n-pub fn mk_path(cx: @ext_ctxt, sp: span, +idents: ~[ast::ident])\n+pub fn mk_path(cx: @ext_ctxt, sp: span, idents: ~[ast::ident])\n             -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path(sp, idents)))\n }\n-pub fn mk_path_global(cx: @ext_ctxt, sp: span, +idents: ~[ast::ident])\n+pub fn mk_path_global(cx: @ext_ctxt, sp: span, idents: ~[ast::ident])\n                    -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path_global(sp, idents)))\n }\n pub fn mk_access_(cx: @ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n                -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_field(p, m, ~[]))\n }\n-pub fn mk_access(cx: @ext_ctxt, sp: span, +p: ~[ast::ident], m: ast::ident)\n+pub fn mk_access(cx: @ext_ctxt, sp: span, p: ~[ast::ident], m: ast::ident)\n               -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, p);\n     return mk_access_(cx, sp, pathexpr, m);\n@@ -115,25 +115,25 @@ pub fn mk_method_call(cx: @ext_ctxt,\n                       sp: span,\n                       rcvr_expr: @ast::expr,\n                       method_ident: ast::ident,\n-                      +args: ~[@ast::expr]) -> @ast::expr {\n+                      args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_method_call(rcvr_expr, method_ident, ~[], args, ast::NoSugar))\n }\n pub fn mk_call_(cx: @ext_ctxt, sp: span, fn_expr: @ast::expr,\n-                +args: ~[@ast::expr]) -> @ast::expr {\n+                args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n }\n-pub fn mk_call(cx: @ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n-               +args: ~[@ast::expr]) -> @ast::expr {\n+pub fn mk_call(cx: @ext_ctxt, sp: span, fn_path: ~[ast::ident],\n+               args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n-pub fn mk_call_global(cx: @ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n-                      +args: ~[@ast::expr]) -> @ast::expr {\n+pub fn mk_call_global(cx: @ext_ctxt, sp: span, fn_path: ~[ast::ident],\n+                      args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path_global(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n // e = expr, t = type\n-pub fn mk_base_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n+pub fn mk_base_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n     mk_expr(cx, sp, vecexpr)\n@@ -143,20 +143,20 @@ pub fn mk_vstore_e(cx: @ext_ctxt, sp: span, expr: @ast::expr,\n    @ast::expr {\n     mk_expr(cx, sp, ast::expr_vstore(expr, vst))\n }\n-pub fn mk_uniq_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n+pub fn mk_uniq_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::expr_vstore_uniq)\n }\n-pub fn mk_slice_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n+pub fn mk_slice_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n                    -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_slice)\n }\n-pub fn mk_base_str(cx: @ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n+pub fn mk_base_str(cx: @ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     let lit = ast::lit_str(@s);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_uniq_str(cx: @ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n+pub fn mk_uniq_str(cx: @ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n }\n pub fn mk_field(sp: span, f: &Field) -> ast::field {\n@@ -170,8 +170,8 @@ pub fn mk_fields(sp: span, fields: ~[Field]) -> ~[ast::field] {\n }\n pub fn mk_struct_e(cx: @ext_ctxt,\n                    sp: span,\n-                   +ctor_path: ~[ast::ident],\n-                   +fields: ~[Field])\n+                   ctor_path: ~[ast::ident],\n+                   fields: ~[Field])\n                 -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path(sp, ctor_path),\n@@ -180,8 +180,8 @@ pub fn mk_struct_e(cx: @ext_ctxt,\n }\n pub fn mk_global_struct_e(cx: @ext_ctxt,\n                           sp: span,\n-                          +ctor_path: ~[ast::ident],\n-                          +fields: ~[Field])\n+                          ctor_path: ~[ast::ident],\n+                          fields: ~[Field])\n                        -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path_global(sp, ctor_path),\n@@ -190,7 +190,7 @@ pub fn mk_global_struct_e(cx: @ext_ctxt,\n }\n pub fn mk_glob_use(cx: @ext_ctxt,\n                    sp: span,\n-                   +path: ~[ast::ident]) -> @ast::view_item {\n+                   path: ~[ast::ident]) -> @ast::view_item {\n     let glob = @codemap::spanned {\n         node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n         span: sp,\n@@ -226,8 +226,8 @@ pub fn mk_local(cx: @ext_ctxt, sp: span, mutbl: bool,\n     @codemap::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n pub fn mk_block(cx: @ext_ctxt, span: span,\n-                +view_items: ~[@ast::view_item],\n-                +stmts: ~[@ast::stmt],\n+                view_items: ~[@ast::view_item],\n+                stmts: ~[@ast::stmt],\n                 expr: Option<@ast::expr>) -> @ast::expr {\n     let blk = codemap::spanned {\n         node: ast::blk_ {\n@@ -243,7 +243,7 @@ pub fn mk_block(cx: @ext_ctxt, span: span,\n }\n pub fn mk_block_(cx: @ext_ctxt,\n                  span: span,\n-                 +stmts: ~[@ast::stmt])\n+                 stmts: ~[@ast::stmt])\n               -> ast::blk {\n     codemap::spanned {\n         node: ast::blk_ {\n@@ -307,7 +307,7 @@ pub fn mk_copy(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n pub fn mk_managed(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n }\n-pub fn mk_pat(cx: @ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n+pub fn mk_pat(cx: @ext_ctxt, span: span, pat: ast::pat_) -> @ast::pat {\n     @ast::pat { id: cx.next_id(), node: pat, span: span }\n }\n pub fn mk_pat_wild(cx: @ext_ctxt, span: span) -> @ast::pat {\n@@ -335,15 +335,15 @@ pub fn mk_pat_ident_with_binding_mode(cx: @ext_ctxt,\n pub fn mk_pat_enum(cx: @ext_ctxt,\n                    span: span,\n                    path: @ast::Path,\n-                   +subpats: ~[@ast::pat])\n+                   subpats: ~[@ast::pat])\n                 -> @ast::pat {\n     let pat = ast::pat_enum(path, Some(subpats));\n     mk_pat(cx, span, pat)\n }\n pub fn mk_pat_struct(cx: @ext_ctxt,\n                      span: span,\n                      path: @ast::Path,\n-                     +field_pats: ~[ast::field_pat])\n+                     field_pats: ~[ast::field_pat])\n                   -> @ast::pat {\n     let pat = ast::pat_struct(path, field_pats, false);\n     mk_pat(cx, span, pat)\n@@ -360,7 +360,7 @@ pub fn mk_stmt(cx: @ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n }\n pub fn mk_ty_path(cx: @ext_ctxt,\n                   span: span,\n-                  +idents: ~[ ast::ident ])\n+                  idents: ~[ ast::ident ])\n                -> @ast::Ty {\n     let ty = build::mk_raw_path(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n@@ -369,7 +369,7 @@ pub fn mk_ty_path(cx: @ext_ctxt,\n }\n pub fn mk_ty_path_global(cx: @ext_ctxt,\n                          span: span,\n-                         +idents: ~[ ast::ident ])\n+                         idents: ~[ ast::ident ])\n                       -> @ast::Ty {\n     let ty = build::mk_raw_path_global(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n@@ -399,7 +399,7 @@ pub fn mk_ty_infer(cx: @ext_ctxt, span: span) -> @ast::Ty {\n }\n pub fn mk_trait_ref_global(cx: @ext_ctxt,\n                            span: span,\n-                           +idents: ~[ ast::ident ])\n+                           idents: ~[ ast::ident ])\n     -> @ast::trait_ref\n {\n     mk_trait_ref_(cx, build::mk_raw_path_global(span, idents))\n@@ -430,12 +430,12 @@ pub fn mk_arg(cx: @ext_ctxt,\n         id: cx.next_id()\n     }\n }\n-pub fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n+pub fn mk_fn_decl(inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n     ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n }\n pub fn mk_trait_ty_param_bound_global(cx: @ext_ctxt,\n                                       span: span,\n-                                      +idents: ~[ast::ident])\n+                                      idents: ~[ast::ident])\n                                    -> ast::TyParamBound {\n     ast::TraitTyParamBound(mk_trait_ref_global(cx, span, idents))\n }"}, {"sha": "6fd27c5f3d732ed5de61754f3d4593dcad2f395e", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -91,7 +91,7 @@ fn create_derived_encodable_impl(\n fn create_encode_method(\n     cx: @ext_ctxt,\n     span: span,\n-    +statements: ~[@stmt]\n+    statements: ~[@stmt]\n ) -> @method {\n     // Create the `e` parameter.\n     let e_arg_type = build::mk_ty_rptr("}, {"sha": "85592d142abcfbddd5c8068e339d31e3a9baa210", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -64,7 +64,7 @@ fn create_derived_iter_bytes_impl(cx: @ext_ctxt,\n // signature of the `iter_bytes` method.\n fn create_iter_bytes_method(cx: @ext_ctxt,\n                             span: span,\n-                            +statements: ~[@stmt])\n+                            statements: ~[@stmt])\n                          -> @method {\n     // Create the `lsb0` parameter.\n     let bool_ident = cx.ident_of(~\"bool\");"}, {"sha": "577cf4c01cfde167696cf4c5600de8f942d741df", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -142,7 +142,7 @@ pub fn expand_deriving(cx: @ext_ctxt,\n     result\n }\n \n-fn create_impl_item(cx: @ext_ctxt, span: span, +item: item_) -> @item {\n+fn create_impl_item(cx: @ext_ctxt, span: span, item: item_) -> @item {\n     let doc_attr = respan(span,\n                           ast::lit_str(@~\"Automatically derived.\"));\n     let doc_attr = respan(span, ast::meta_name_value(@~\"doc\", doc_attr));"}, {"sha": "61032429c93a7b4e19e207c57e587515979ffffa", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -237,8 +237,8 @@ macro_rules! without_macro_scoping(\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(+extsbox: @mut SyntaxEnv,\n-                       cx: @ext_ctxt, &&it: @ast::item,\n+pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n+                       cx: @ext_ctxt, it: @ast::item,\n                        fld: @ast_fold)\n                     -> Option<@ast::item> {\n     let (pth, tts) = match it.node {"}, {"sha": "e0f6c90f5b378c424ab7faba2e7ecb950d1b3922", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -34,15 +34,15 @@ mod syntax {\n     pub use parse;\n }\n \n-pub fn path(+ids: ~[ident], span: span) -> @ast::Path {\n+pub fn path(ids: ~[ident], span: span) -> @ast::Path {\n     @ast::Path { span: span,\n                  global: false,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n-pub fn path_global(+ids: ~[ident], span: span) -> @ast::Path {\n+pub fn path_global(ids: ~[ident], span: span) -> @ast::Path {\n     @ast::Path { span: span,\n                  global: true,\n                  idents: ids,\n@@ -52,7 +52,7 @@ pub fn path_global(+ids: ~[ident], span: span) -> @ast::Path {\n \n pub trait append_types {\n     fn add_ty(&self, ty: @ast::Ty) -> @ast::Path;\n-    fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::Path;\n+    fn add_tys(&self, tys: ~[@ast::Ty]) -> @ast::Path;\n }\n \n impl append_types for @ast::Path {\n@@ -63,7 +63,7 @@ impl append_types for @ast::Path {\n         }\n     }\n \n-    fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::Path {\n+    fn add_tys(&self, tys: ~[@ast::Ty]) -> @ast::Path {\n         @ast::Path {\n             types: vec::append(copy self.types, tys),\n             .. copy **self\n@@ -76,63 +76,63 @@ pub trait ext_ctxt_ast_builder {\n         -> ast::TyParam;\n     fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg;\n     fn expr_block(&self, e: @ast::expr) -> ast::blk;\n-    fn fn_decl(&self, +inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n-    fn item(&self, name: ident, span: span, +node: ast::item_) -> @ast::item;\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n+    fn item(&self, name: ident, span: span, node: ast::item_) -> @ast::item;\n     fn item_fn_poly(&self,\n                     ame: ident,\n-                    +inputs: ~[ast::arg],\n+                    inputs: ~[ast::arg],\n                     output: @ast::Ty,\n-                    +generics: Generics,\n-                    +body: ast::blk) -> @ast::item;\n+                    generics: Generics,\n+                    body: ast::blk) -> @ast::item;\n     fn item_fn(&self,\n                name: ident,\n-               +inputs: ~[ast::arg],\n+               inputs: ~[ast::arg],\n                output: @ast::Ty,\n-               +body: ast::blk) -> @ast::item;\n+               body: ast::blk) -> @ast::item;\n     fn item_enum_poly(&self,\n                       name: ident,\n                       span: span,\n-                      +enum_definition: ast::enum_def,\n-                      +generics: Generics) -> @ast::item;\n+                      enum_definition: ast::enum_def,\n+                      generics: Generics) -> @ast::item;\n     fn item_enum(&self,\n                  name: ident,\n                  span: span,\n-                 +enum_definition: ast::enum_def) -> @ast::item;\n+                 enum_definition: ast::enum_def) -> @ast::item;\n     fn item_struct_poly(&self,\n                         name: ident,\n                         span: span,\n-                        +struct_def: ast::struct_def,\n-                        +generics: Generics) -> @ast::item;\n+                        struct_def: ast::struct_def,\n+                        generics: Generics) -> @ast::item;\n     fn item_struct(&self,\n                    name: ident,\n                    span: span,\n-                   +struct_def: ast::struct_def) -> @ast::item;\n+                   struct_def: ast::struct_def) -> @ast::item;\n     fn struct_expr(&self,\n                    path: @ast::Path,\n-                   +fields: ~[ast::field]) -> @ast::expr;\n+                   fields: ~[ast::field]) -> @ast::expr;\n     fn variant(&self,\n                name: ident,\n                span: span,\n-               +tys: ~[@ast::Ty]) -> ast::variant;\n+               tys: ~[@ast::Ty]) -> ast::variant;\n     fn item_mod(&self,\n                 name: ident,\n                 span: span,\n-                +items: ~[@ast::item]) -> @ast::item;\n+                items: ~[@ast::item]) -> @ast::item;\n     fn ty_path_ast_builder(&self, path: @ast::Path) -> @ast::Ty;\n     fn item_ty_poly(&self,\n                     name: ident,\n                     span: span,\n                     ty: @ast::Ty,\n-                    +generics: Generics) -> @ast::item;\n+                    generics: Generics) -> @ast::item;\n     fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n     fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n     fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n     fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field;\n     fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field;\n-    fn block(&self, +stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n+    fn block(&self, stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n     fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt;\n     fn stmt_expr(&self, e: @ast::expr) -> @ast::stmt;\n-    fn block_expr(&self, +b: ast::blk) -> @ast::expr;\n+    fn block_expr(&self, b: ast::blk) -> @ast::expr;\n     fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n     fn ty_infer(&self) -> @ast::Ty;\n     fn ty_nil_ast_builder(&self) -> @ast::Ty;\n@@ -148,7 +148,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n         ], dummy_sp()).add_ty(ty))\n     }\n \n-    fn block_expr(&self, +b: ast::blk) -> @ast::expr {\n+    fn block_expr(&self, b: ast::blk) -> @ast::expr {\n         @expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -215,7 +215,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n         }\n     }\n \n-    fn block(&self, +stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n+    fn block(&self, stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n         let blk = ast::blk_ {\n             view_items: ~[],\n             stmts: stmts,\n@@ -231,7 +231,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n         self.block(~[], e)\n     }\n \n-    fn fn_decl(&self, +inputs: ~[ast::arg],\n+    fn fn_decl(&self, inputs: ~[ast::arg],\n                output: @ast::Ty) -> ast::fn_decl {\n         ast::fn_decl {\n             inputs: inputs,\n@@ -241,7 +241,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn item(&self, name: ident, span: span,\n-            +node: ast::item_) -> @ast::item {\n+            node: ast::item_) -> @ast::item {\n \n         // XXX: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n@@ -265,10 +265,10 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn item_fn_poly(&self, name: ident,\n-                    +inputs: ~[ast::arg],\n+                    inputs: ~[ast::arg],\n                     output: @ast::Ty,\n-                    +generics: Generics,\n-                    +body: ast::blk) -> @ast::item {\n+                    generics: Generics,\n+                    body: ast::blk) -> @ast::item {\n         self.item(name,\n                   dummy_sp(),\n                   ast::item_fn(self.fn_decl(inputs, output),\n@@ -280,9 +280,9 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n \n     fn item_fn(&self,\n                name: ident,\n-               +inputs: ~[ast::arg],\n+               inputs: ~[ast::arg],\n                output: @ast::Ty,\n-               +body: ast::blk\n+               body: ast::blk\n     ) -> @ast::item {\n         self.item_fn_poly(\n             name,\n@@ -294,21 +294,21 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn item_enum_poly(&self, name: ident, span: span,\n-                      +enum_definition: ast::enum_def,\n-                      +generics: Generics) -> @ast::item {\n+                      enum_definition: ast::enum_def,\n+                      generics: Generics) -> @ast::item {\n         self.item(name, span, ast::item_enum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, name: ident, span: span,\n-                 +enum_definition: ast::enum_def) -> @ast::item {\n+                 enum_definition: ast::enum_def) -> @ast::item {\n         self.item_enum_poly(name, span, enum_definition,\n                             ast_util::empty_generics())\n     }\n \n     fn item_struct(\n         &self, name: ident,\n         span: span,\n-        +struct_def: ast::struct_def\n+        struct_def: ast::struct_def\n     ) -> @ast::item {\n         self.item_struct_poly(\n             name,\n@@ -322,14 +322,14 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n         &self,\n         name: ident,\n         span: span,\n-        +struct_def: ast::struct_def,\n-        +generics: Generics\n+        struct_def: ast::struct_def,\n+        generics: Generics\n     ) -> @ast::item {\n         self.item(name, span, ast::item_struct(@struct_def, generics))\n     }\n \n     fn struct_expr(&self, path: @ast::Path,\n-                   +fields: ~[ast::field]) -> @ast::expr {\n+                   fields: ~[ast::field]) -> @ast::expr {\n         @ast::expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -339,7 +339,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn variant(&self, name: ident, span: span,\n-               +tys: ~[@ast::Ty]) -> ast::variant {\n+               tys: ~[@ast::Ty]) -> ast::variant {\n         let args = do tys.map |ty| {\n             ast::variant_arg { ty: *ty, id: self.next_id() }\n         };\n@@ -358,7 +358,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn item_mod(&self, name: ident, span: span,\n-                +items: ~[@ast::item]) -> @ast::item {\n+                items: ~[@ast::item]) -> @ast::item {\n \n         // XXX: Total hack: import `core::kinds::Owned` to work around a\n         // parser bug whereby `fn f<T:::kinds::Owned>` doesn't parse.\n@@ -425,7 +425,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn item_ty_poly(&self, name: ident, span: span, ty: @ast::Ty,\n-                    +generics: Generics) -> @ast::item {\n+                    generics: Generics) -> @ast::item {\n         self.item(name, span, ast::item_ty(ty, generics))\n     }\n "}, {"sha": "7339ebdaa98fac349ba41f8518193fa3af6ec60c", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -19,13 +19,13 @@ use parse::token;\n use core::prelude::*;\n \n pub trait proto_parser {\n-    fn parse_proto(&self, +id: ~str) -> protocol;\n+    fn parse_proto(&self, id: ~str) -> protocol;\n     fn parse_state(&self, proto: protocol);\n     fn parse_message(&self, state: state);\n }\n \n impl proto_parser for parser::Parser {\n-    fn parse_proto(&self, +id: ~str) -> protocol {\n+    fn parse_proto(&self, id: ~str) -> protocol {\n         let proto = protocol(id, *self.span);\n \n         self.parse_seq_to_before_end("}, {"sha": "6495750f93b75b18a11ad8c25922dbb803bede5f", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -81,8 +81,8 @@ pub struct state_ {\n }\n \n pub impl state_ {\n-    fn add_message(@self, +name: ~str, span: span,\n-                   +data: ~[@ast::Ty], +next: Option<next_state>) {\n+    fn add_message(@self, name: ~str, span: span,\n+                   data: ~[@ast::Ty], next: Option<next_state>) {\n         self.messages.push(message(name, span, data, self,\n                                    next));\n     }\n@@ -119,11 +119,11 @@ pub impl state_ {\n \n pub type protocol = @mut protocol_;\n \n-pub fn protocol(+name: ~str, +span: span) -> protocol {\n+pub fn protocol(name: ~str, span: span) -> protocol {\n     @mut protocol_(name, span)\n }\n \n-pub fn protocol_(+name: ~str, span: span) -> protocol_ {\n+pub fn protocol_(name: ~str, span: span) -> protocol_ {\n     protocol_ {\n         name: name,\n         span: span,\n@@ -177,10 +177,10 @@ pub impl protocol_ {\n \n pub impl protocol_ {\n     fn add_state_poly(@mut self,\n-                      +name: ~str,\n+                      name: ~str,\n                       ident: ast::ident,\n                       dir: direction,\n-                      +generics: ast::Generics)\n+                      generics: ast::Generics)\n                    -> state {\n         let messages = @mut ~[];\n         let states = &*self.states;"}, {"sha": "f355d327d4fa02689809afc22fa175191a094896", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -419,7 +419,7 @@ fn ids_ext(cx: @ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n     strs.map(|str| cx.parse_sess().interner.intern(@copy *str))\n }\n \n-fn id_ext(cx: @ext_ctxt, +str: ~str) -> ast::ident {\n+fn id_ext(cx: @ext_ctxt, str: ~str) -> ast::ident {\n     cx.parse_sess().interner.intern(@str)\n }\n \n@@ -734,8 +734,8 @@ fn expand_tts(cx: @ext_ctxt,\n \n fn expand_parse_call(cx: @ext_ctxt,\n                      sp: span,\n-                     +parse_method: ~str,\n-                     +arg_exprs: ~[@ast::expr],\n+                     parse_method: ~str,\n+                     arg_exprs: ~[@ast::expr],\n                      tts: &[ast::token_tree]) -> @ast::expr {\n     let tts_expr = expand_tts(cx, sp, tts);\n "}, {"sha": "9df7a8e7e1db7b40842f22a09d31b5411beeb3e5", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -98,9 +98,9 @@ pub enum matcher_pos_up { /* to break a circularity */\n     matcher_pos_up(Option<~MatcherPos>)\n }\n \n-pub fn is_some(&&mpu: matcher_pos_up) -> bool {\n-    match &mpu {\n-      &matcher_pos_up(None) => false,\n+pub fn is_some(mpu: &matcher_pos_up) -> bool {\n+    match *mpu {\n+      matcher_pos_up(None) => false,\n       _ => true\n     }\n }\n@@ -115,9 +115,9 @@ pub struct MatcherPos {\n     sp_lo: BytePos,\n }\n \n-pub fn copy_up(&& mpu: matcher_pos_up) -> ~MatcherPos {\n-    match &mpu {\n-      &matcher_pos_up(Some(ref mp)) => copy (*mp),\n+pub fn copy_up(mpu: &matcher_pos_up) -> ~MatcherPos {\n+    match *mpu {\n+      matcher_pos_up(Some(ref mp)) => copy (*mp),\n       _ => fail!()\n     }\n }\n@@ -132,7 +132,7 @@ pub fn count_names(ms: &[matcher]) -> uint {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-pub fn initial_matcher_pos(+ms: ~[matcher], +sep: Option<Token>, lo: BytePos)\n+pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n     for ms.each |elt| {\n@@ -220,7 +220,7 @@ pub enum parse_result {\n \n pub fn parse_or_else(\n     sess: @mut ParseSess,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     rdr: @reader,\n     ms: ~[matcher]\n ) -> HashMap<ident, @named_match> {\n@@ -257,7 +257,7 @@ pub fn parse(\n             /* at end of sequence */\n             if idx >= len {\n                 // can't move out of `match`es, so:\n-                if is_some(ei.up) {\n+                if is_some(&ei.up) {\n                     // hack: a matcher sequence is repeating iff it has a\n                     // parent (the top level is just a container)\n \n@@ -267,7 +267,7 @@ pub fn parse(\n                     if idx == len {\n                         // pop from the matcher position\n \n-                        let mut new_pos = copy_up(ei.up);\n+                        let mut new_pos = copy_up(&ei.up);\n \n                         // update matches (the MBE \"parse tree\") by appending\n                         // each tree as a subtree.\n@@ -394,7 +394,7 @@ pub fn parse(\n                 match ei.elts[ei.idx].node {\n                   match_nonterminal(_, name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal(\n-                        parse_nt(rust_parser, *sess.interner.get(name))));\n+                        parse_nt(&rust_parser, *sess.interner.get(name))));\n                     ei.idx += 1u;\n                   }\n                   _ => fail!()\n@@ -411,7 +411,7 @@ pub fn parse(\n     }\n }\n \n-pub fn parse_nt(p: Parser, name: ~str) -> nonterminal {\n+pub fn parse_nt(p: &Parser, name: ~str) -> nonterminal {\n     match name {\n       ~\"item\" => match p.parse_item(~[]) {\n         Some(i) => token::nt_item(i),"}, {"sha": "482e7b80339becfa6836fcc6974edd0125b734b9", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -53,7 +53,7 @@ pub struct TtReader {\n pub fn new_tt_reader(sp_diag: @span_handler,\n                      itr: @ident_interner,\n                      interp: Option<HashMap<ident,@named_match>>,\n-                     +src: ~[ast::token_tree])\n+                     src: ~[ast::token_tree])\n                   -> @mut TtReader {\n     let r = @mut TtReader {\n         sp_diag: sp_diag,\n@@ -109,7 +109,7 @@ pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n fn lookup_cur_matched_by_matched(r: &mut TtReader,\n                                       start: @named_match)\n                                    -> @named_match {\n-    fn red(+ad: @named_match, idx: &uint) -> @named_match {\n+    fn red(ad: @named_match, idx: &uint) -> @named_match {\n         match *ad {\n           matched_nonterminal(_) => {\n             // end of the line; duplicate henceforth"}, {"sha": "c7ca9eba5124ed4259e80caf1752dbc6d4e7c727", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -27,11 +27,11 @@ pub enum OptVec<T> {\n     Vec(~[T])\n }\n \n-pub fn with<T>(+t: T) -> OptVec<T> {\n+pub fn with<T>(t: T) -> OptVec<T> {\n     Vec(~[t])\n }\n \n-pub fn from<T>(+t: ~[T]) -> OptVec<T> {\n+pub fn from<T>(t: ~[T]) -> OptVec<T> {\n     if t.len() == 0 {\n         Empty\n     } else {\n@@ -40,7 +40,7 @@ pub fn from<T>(+t: ~[T]) -> OptVec<T> {\n }\n \n impl<T> OptVec<T> {\n-    fn push(&mut self, +t: T) {\n+    fn push(&mut self, t: T) {\n         match *self {\n             Vec(ref mut v) => {\n                 v.push(t);\n@@ -91,15 +91,15 @@ impl<T> OptVec<T> {\n     }\n }\n \n-pub fn take_vec<T>(+v: OptVec<T>) -> ~[T] {\n+pub fn take_vec<T>(v: OptVec<T>) -> ~[T] {\n     match v {\n         Empty => ~[],\n         Vec(v) => v\n     }\n }\n \n impl<T:Copy> OptVec<T> {\n-    fn prepend(&self, +t: T) -> OptVec<T> {\n+    fn prepend(&self, t: T) -> OptVec<T> {\n         let mut v0 = ~[t];\n         match *self {\n             Empty => {}\n@@ -157,7 +157,7 @@ impl<A> BaseIter<A> for OptVec<A> {\n \n impl<A> iter::ExtendedIter<A> for OptVec<A> {\n     #[inline(always)]\n-    fn eachi(&self, blk: &fn(+v: uint, v: &A) -> bool) {\n+    fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n     #[inline(always)]\n@@ -169,7 +169,7 @@ impl<A> iter::ExtendedIter<A> for OptVec<A> {\n         iter::any(self, blk)\n     }\n     #[inline(always)]\n-    fn foldl<B>(&self, +b0: B, blk: &fn(&B, &A) -> B) -> B {\n+    fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n     #[inline(always)]"}, {"sha": "840fb891bff2c5eee85efd17b276ea6fab0f6a81", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -40,7 +40,7 @@ pub fn expr_is_simple_block(e: @ast::expr) -> bool {\n     }\n }\n \n-pub fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n+pub fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n     return match stmt.node {\n         ast::stmt_decl(d, _) => {\n             match d.node {"}, {"sha": "2f6bfd4cfc53b23715e805546bbf33b6b94405c5", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -319,7 +319,7 @@ pub struct lit {\n \n pub fn gather_comments_and_literals(span_diagnostic:\n                                     @diagnostic::span_handler,\n-                                    +path: ~str,\n+                                    path: ~str,\n                                     srdr: @io::Reader)\n                                  -> (~[cmnt], ~[lit]) {\n     let src = @str::from_bytes(srdr.read_whole_stream());"}, {"sha": "2d4a6d47eaa58c3b340021ec3793b4229fb3a5f1", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -28,13 +28,13 @@ pub struct SeqSep {\n     trailing_sep_allowed: bool\n }\n \n-pub fn seq_sep_trailing_disallowed(+t: token::Token) -> SeqSep {\n+pub fn seq_sep_trailing_disallowed(t: token::Token) -> SeqSep {\n     SeqSep {\n         sep: Some(t),\n         trailing_sep_allowed: false,\n     }\n }\n-pub fn seq_sep_trailing_allowed(+t: token::Token) -> SeqSep {\n+pub fn seq_sep_trailing_allowed(t: token::Token) -> SeqSep {\n     SeqSep {\n         sep: Some(t),\n         trailing_sep_allowed: true,"}, {"sha": "4d8fdcfe617cc8428e688dd0fed014785e411206", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -126,7 +126,7 @@ pub fn parse_crate_from_source_str(\n pub fn parse_expr_from_source_str(\n     name: ~str,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> @ast::expr {\n     let p = new_parser_from_source_str(\n@@ -142,8 +142,8 @@ pub fn parse_expr_from_source_str(\n pub fn parse_item_from_source_str(\n     name: ~str,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n-    +attrs: ~[ast::attribute],\n+    cfg: ast::crate_cfg,\n+    attrs: ~[ast::attribute],\n     sess: @mut ParseSess\n ) -> Option<@ast::item> {\n     let p = new_parser_from_source_str(\n@@ -159,7 +159,7 @@ pub fn parse_item_from_source_str(\n pub fn parse_meta_from_source_str(\n     name: ~str,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> @ast::meta_item {\n     let p = new_parser_from_source_str(\n@@ -175,8 +175,8 @@ pub fn parse_meta_from_source_str(\n pub fn parse_stmt_from_source_str(\n     name: ~str,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n-    +attrs: ~[ast::attribute],\n+    cfg: ast::crate_cfg,\n+    attrs: ~[ast::attribute],\n     sess: @mut ParseSess\n ) -> @ast::stmt {\n     let p = new_parser_from_source_str(\n@@ -192,7 +192,7 @@ pub fn parse_stmt_from_source_str(\n pub fn parse_tts_from_source_str(\n     name: ~str,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> ~[ast::token_tree] {\n     let p = new_parser_from_source_str(\n@@ -207,20 +207,20 @@ pub fn parse_tts_from_source_str(\n }\n \n pub fn parse_from_source_str<T>(\n-    f: &fn (Parser) -> T,\n+    f: &fn(&Parser) -> T,\n     name: ~str, ss: codemap::FileSubstr,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> T {\n     let p = new_parser_from_source_str(\n         sess,\n         cfg,\n-        /*bad*/ copy name,\n-        /*bad*/ copy ss,\n+        name,\n+        ss,\n         source\n     );\n-    let r = f(p);\n+    let r = f(&p);\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");\n     }\n@@ -236,9 +236,9 @@ pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n }\n \n pub fn new_parser_from_source_str(sess: @mut ParseSess,\n-                                  +cfg: ast::crate_cfg,\n-                                  +name: ~str,\n-                                  +ss: codemap::FileSubstr,\n+                                  cfg: ast::crate_cfg,\n+                                  name: ~str,\n+                                  ss: codemap::FileSubstr,\n                                   source: @~str)\n                                -> Parser {\n     let filemap = sess.cm.new_filemap_w_substr(name, ss, source);\n@@ -254,7 +254,7 @@ pub fn new_parser_from_source_str(sess: @mut ParseSess,\n /// that draws from that string\n pub fn new_parser_result_from_file(\n     sess: @mut ParseSess,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     path: &Path\n ) -> Result<Parser, ~str> {\n     match io::read_whole_file_str(path) {\n@@ -274,7 +274,7 @@ pub fn new_parser_result_from_file(\n /// if the file doesn't exist\n pub fn new_parser_from_file(\n     sess: @mut ParseSess,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     path: &Path\n ) -> Parser {\n     match new_parser_result_from_file(sess, cfg, path) {\n@@ -289,7 +289,7 @@ pub fn new_parser_from_file(\n /// error messages correctly when the file does not exist.\n pub fn new_sub_parser_from_file(\n     sess: @mut ParseSess,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     path: &Path,\n     sp: span\n ) -> Parser {\n@@ -303,8 +303,8 @@ pub fn new_sub_parser_from_file(\n \n pub fn new_parser_from_tts(\n     sess: @mut ParseSess,\n-    +cfg: ast::crate_cfg,\n-    +tts: ~[ast::token_tree]\n+    cfg: ast::crate_cfg,\n+    tts: ~[ast::token_tree]\n ) -> Parser {\n     let trdr = lexer::new_tt_reader(\n         copy sess.span_diagnostic,\n@@ -316,7 +316,7 @@ pub fn new_parser_from_tts(\n }\n \n // abort if necessary\n-pub fn maybe_aborted<T>(+result : T, p: Parser) -> T {\n+pub fn maybe_aborted<T>(result : T, p: Parser) -> T {\n     p.abort_if_errors();\n     result\n }"}, {"sha": "423fc6dca6d809c78a28b750a04e89d876b67bda", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -66,7 +66,7 @@ pub enum ObsoleteSyntax {\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n     #[inline(always)]\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }"}, {"sha": "e892f212b0577b3f9e2a9874659e1a9f7293059d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -201,7 +201,7 @@ macro_rules! maybe_whole (\n )\n \n \n-fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n+fn maybe_append(lhs: ~[attribute], rhs: Option<~[attribute]>)\n              -> ~[attribute] {\n     match rhs {\n         None => lhs,\n@@ -220,8 +220,8 @@ struct ParsedItemsAndViewItems {\n /* ident is handled by common.rs */\n \n pub fn Parser(sess: @mut ParseSess,\n-              +cfg: ast::crate_cfg,\n-              +rdr: @reader)\n+              cfg: ast::crate_cfg,\n+              rdr: @reader)\n            -> Parser {\n     let tok0 = copy rdr.next_token();\n     let interner = rdr.interner();\n@@ -299,7 +299,7 @@ pub impl Parser {\n         *self.tokens_consumed += 1u;\n     }\n     // EFFECT: replace the current token and span with the given one\n-    fn replace_token(&self, +next: token::Token, +lo: BytePos, +hi: BytePos) {\n+    fn replace_token(&self, next: token::Token, lo: BytePos, hi: BytePos) {\n         *self.token = next;\n         *self.span = mk_sp(lo, hi);\n     }\n@@ -713,7 +713,7 @@ pub impl Parser {\n     fn parse_box_or_uniq_pointee(\n         &self,\n         sigil: ast::Sigil,\n-        ctor: &fn(+v: mt) -> ty_) -> ty_\n+        ctor: &fn(v: mt) -> ty_) -> ty_\n     {\n         // @'foo fn() or @foo/fn() or @fn() are parsed directly as fn types:\n         match *self.token {\n@@ -1112,7 +1112,7 @@ pub impl Parser {\n         spanned(lo, e.span.hi, ast::field_ { mutbl: m, ident: i, expr: e })\n     }\n \n-    fn mk_expr(&self, +lo: BytePos, +hi: BytePos, +node: expr_) -> @expr {\n+    fn mk_expr(&self, lo: BytePos, hi: BytePos, node: expr_) -> @expr {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n@@ -1121,7 +1121,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn mk_mac_expr(&self, +lo: BytePos, +hi: BytePos, +m: mac_) -> @expr {\n+    fn mk_mac_expr(&self, lo: BytePos, hi: BytePos, m: mac_) -> @expr {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n@@ -1897,7 +1897,7 @@ pub impl Parser {\n \n     fn parse_sugary_call_expr(&self, keyword: ~str,\n                               sugar: CallSugar,\n-                              ctor: &fn(+v: @expr) -> expr_) -> @expr {\n+                              ctor: &fn(v: @expr) -> expr_) -> @expr {\n         let lo = self.last_span;\n         // Parse the callee `foo` in\n         //    for foo || {\n@@ -2472,7 +2472,7 @@ pub impl Parser {\n         })\n     }\n \n-    fn parse_stmt(&self, +first_item_attrs: ~[attribute]) -> @stmt {\n+    fn parse_stmt(&self, first_item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n         fn check_expected_item(p: &Parser, current_attrs: &[attribute]) {\n@@ -2612,7 +2612,7 @@ pub impl Parser {\n \n     // parse the rest of a block expression or function body\n     fn parse_block_tail_(&self, lo: BytePos, s: blk_check_mode,\n-                         +first_item_attrs: ~[attribute]) -> blk {\n+                         first_item_attrs: ~[attribute]) -> blk {\n         let mut stmts = ~[];\n         let mut expr = None;\n \n@@ -2658,7 +2658,7 @@ pub impl Parser {\n                                     expr = Some(e);\n                                 }\n                                 copy t => {\n-                                    if classify::stmt_ends_with_semi(*stmt) {\n+                                    if classify::stmt_ends_with_semi(stmt) {\n                                         self.fatal(\n                                             fmt!(\n                                                 \"expected `;` or `}` after \\\n@@ -2696,7 +2696,7 @@ pub impl Parser {\n                         _ => { // All other kinds of statements:\n                             stmts.push(stmt);\n \n-                            if classify::stmt_ends_with_semi(*stmt) {\n+                            if classify::stmt_ends_with_semi(stmt) {\n                                 self.expect(&token::SEMI);\n                             }\n                         }\n@@ -2891,7 +2891,7 @@ pub impl Parser {\n         &fn(&Parser) -> arg_or_capture_item\n     ) -> (self_ty, fn_decl) {\n         fn maybe_parse_self_ty(\n-            cnstr: &fn(+v: mutability) -> ast::self_ty_,\n+            cnstr: &fn(v: mutability) -> ast::self_ty_,\n             p: &Parser\n         ) -> ast::self_ty_ {\n             // We need to make sure it isn't a mode or a type\n@@ -3064,9 +3064,9 @@ pub impl Parser {\n         (id, generics)\n     }\n \n-    fn mk_item(&self, +lo: BytePos, +hi: BytePos, +ident: ident,\n-               +node: item_, vis: visibility,\n-               +attrs: ~[attribute]) -> @item {\n+    fn mk_item(&self, lo: BytePos, hi: BytePos, ident: ident,\n+               node: item_, vis: visibility,\n+               attrs: ~[attribute]) -> @item {\n         @ast::item { ident: ident,\n                      attrs: attrs,\n                      id: self.get_id(),\n@@ -3305,7 +3305,7 @@ pub impl Parser {\n          None)\n     }\n \n-    fn token_is_pound_or_doc_comment(&self, ++tok: token::Token) -> bool {\n+    fn token_is_pound_or_doc_comment(&self, tok: token::Token) -> bool {\n         match tok {\n             token::POUND | token::DOC_COMMENT(_) => true,\n             _ => false\n@@ -3340,7 +3340,7 @@ pub impl Parser {\n         a_var\n     }\n \n-    fn parse_dtor(&self, +attrs: ~[attribute]) -> class_contents {\n+    fn parse_dtor(&self, attrs: ~[attribute]) -> class_contents {\n         let lo = self.last_span.lo;\n         let body = self.parse_block();\n         dtor_decl(body, attrs, mk_sp(lo, self.last_span.hi))\n@@ -3392,7 +3392,7 @@ pub impl Parser {\n     // given a termination token and a vector of already-parsed\n     // attributes (of length 0 or 1), parse all of the items in a module\n     fn parse_mod_items(&self, term: token::Token,\n-                       +first_item_attrs: ~[attribute]) -> _mod {\n+                       first_item_attrs: ~[attribute]) -> _mod {\n         // parse all of the items up to closing or an attribute.\n         // view items are legal here.\n         let ParsedItemsAndViewItems {\n@@ -3553,7 +3553,7 @@ pub impl Parser {\n                                     outer_attrs, id_sp)\n     }\n \n-    fn eval_src_mod_from_path(&self, prefix: Path, +path: Path,\n+    fn eval_src_mod_from_path(&self, prefix: Path, path: Path,\n                               outer_attrs: ~[ast::attribute],\n                               id_sp: span\n                              ) -> (ast::item_, ~[ast::attribute]) {\n@@ -3576,15 +3576,15 @@ pub impl Parser {\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n         return (ast::item_mod(m0), mod_attrs);\n \n-        fn cdir_path_opt(+default: ~str, attrs: ~[ast::attribute]) -> ~str {\n+        fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n             match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n                 Some(d) => copy *d,\n                 None => default\n             }\n         }\n     }\n \n-    fn parse_item_foreign_fn(&self,  +attrs: ~[attribute]) -> @foreign_item {\n+    fn parse_item_foreign_fn(&self,  attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n         let vis = self.parse_visibility();\n         let purity = self.parse_fn_purity();\n@@ -3601,7 +3601,7 @@ pub impl Parser {\n     }\n \n     fn parse_item_foreign_const(&self, vis: ast::visibility,\n-                                +attrs: ~[attribute]) -> @foreign_item {\n+                                attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n \n         // XXX: Obsolete; remove after snap.\n@@ -3638,7 +3638,7 @@ pub impl Parser {\n         else { self.unexpected(); }\n     }\n \n-    fn parse_foreign_item(&self, +attrs: ~[attribute]) -> @foreign_item {\n+    fn parse_foreign_item(&self, attrs: ~[attribute]) -> @foreign_item {\n         let vis = self.parse_visibility();\n         if self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\") {\n             self.parse_item_foreign_const(vis, attrs)\n@@ -3648,8 +3648,8 @@ pub impl Parser {\n     }\n \n     fn parse_foreign_mod_items(&self, sort: ast::foreign_mod_sort,\n-                               +abis: AbiSet,\n-                               +first_item_attrs: ~[attribute])\n+                               abis: AbiSet,\n+                               first_item_attrs: ~[attribute])\n                             -> foreign_mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n         let ParsedItemsAndViewItems {\n@@ -3987,7 +3987,7 @@ pub impl Parser {\n     // flags; on failure, return iovi_none.\n     fn parse_item_or_view_item(\n         &self,\n-        +attrs: ~[attribute],\n+        attrs: ~[attribute],\n         items_allowed: bool,\n         foreign_items_allowed: bool,\n         macros_allowed: bool\n@@ -4198,7 +4198,7 @@ pub impl Parser {\n         return iovi_none;\n     }\n \n-    fn parse_item(&self, +attrs: ~[attribute]) -> Option<@ast::item> {\n+    fn parse_item(&self, attrs: ~[attribute]) -> Option<@ast::item> {\n         match self.parse_item_or_view_item(attrs, true, false, true) {\n             iovi_none =>\n                 None,\n@@ -4337,7 +4337,7 @@ pub impl Parser {\n     // parse a view item.\n     fn parse_view_item(\n         &self,\n-        +attrs: ~[attribute],\n+        attrs: ~[attribute],\n         vis: visibility\n     ) -> @view_item {\n         let lo = self.span.lo;\n@@ -4363,7 +4363,7 @@ pub impl Parser {\n     // - mod_items uses VIEW_ITEMS_AND_ITEMS_ALLOWED\n     // - block_tail_ uses IMPORTS_AND_ITEMS_ALLOWED\n     // - foreign_mod_items uses FOREIGN_ITEMS_ALLOWED\n-    fn parse_items_and_view_items(&self, +first_item_attrs: ~[attribute],\n+    fn parse_items_and_view_items(&self, first_item_attrs: ~[attribute],\n                                   mode: view_item_parse_mode,\n                                   macros_allowed: bool)\n                                 -> ParsedItemsAndViewItems {"}, {"sha": "eff7524e194ae7a83b2910c7d7e6226b0b36e460", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -104,7 +104,7 @@ pub impl token {\n     }\n }\n \n-pub fn tok_str(++t: token) -> ~str {\n+pub fn tok_str(t: token) -> ~str {\n     match t {\n         STRING(s, len) => return fmt!(\"STR(%s,%d)\", *s, len),\n         BREAK(_) => return ~\"BREAK\",\n@@ -398,7 +398,7 @@ pub impl Printer {\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n-    fn advance_left(&mut self, ++x: token, L: int) {\n+    fn advance_left(&mut self, x: token, L: int) {\n         debug!(\"advnce_left ~[%u,%u], sizeof(%u)=%d\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {"}, {"sha": "8cf7359956283666a5625fe3eea76c50ac346ef9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -134,7 +134,7 @@ pub fn print_crate(cm: @CodeMap,\n     print_crate_(s, crate);\n }\n \n-pub fn print_crate_(s: @ps, &&crate: @ast::crate) {\n+pub fn print_crate_(s: @ps, crate: @ast::crate) {\n     print_mod(s, &crate.node.module, crate.node.attrs);\n     print_remaining_comments(s);\n     eof(s.s);\n@@ -164,7 +164,7 @@ pub fn tts_to_str(tts: &[ast::token_tree], intr: @ident_interner) -> ~str {\n     to_str(tts, print_tts, intr)\n }\n \n-pub fn stmt_to_str(s: ast::stmt, intr: @ident_interner) -> ~str {\n+pub fn stmt_to_str(s: &ast::stmt, intr: @ident_interner) -> ~str {\n     to_str(s, print_stmt, intr)\n }\n \n@@ -177,7 +177,7 @@ pub fn generics_to_str(generics: &ast::Generics,\n     to_str(generics, print_generics, intr)\n }\n \n-pub fn path_to_str(&&p: @ast::Path, intr: @ident_interner) -> ~str {\n+pub fn path_to_str(p: @ast::Path, intr: @ident_interner) -> ~str {\n     to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n@@ -312,7 +312,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, ~\"*/\");\n }\n \n-pub fn commasep<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n+pub fn commasep<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.each |elt| {\n@@ -323,8 +323,8 @@ pub fn commasep<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n }\n \n \n-pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n-                         get_span: &fn(IN) -> codemap::span) {\n+pub fn commasep_cmnt<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n+                               get_span: &fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n@@ -343,7 +343,7 @@ pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n }\n \n pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n-    fn expr_span(&&expr: @ast::expr) -> codemap::span { return expr.span; }\n+    fn expr_span(expr: @ast::expr) -> codemap::span { return expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n@@ -371,7 +371,7 @@ pub fn print_opt_lifetime(s: @ps, lifetime: Option<@ast::Lifetime>) {\n     }\n }\n \n-pub fn print_type(s: @ps, &&ty: @ast::Ty) {\n+pub fn print_type(s: @ps, ty: @ast::Ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     match ty.node {\n@@ -465,7 +465,7 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     }\n }\n \n-pub fn print_item(s: @ps, &&item: @ast::item) {\n+pub fn print_item(s: @ps, item: @ast::item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -760,7 +760,7 @@ pub fn print_tt(s: @ps, tt: ast::token_tree) {\n     }\n }\n \n-pub fn print_tts(s: @ps, &&tts: &[ast::token_tree]) {\n+pub fn print_tts(s: @ps, tts: &[ast::token_tree]) {\n     ibox(s, 0);\n     for tts.eachi |i, tt| {\n         if i != 0 {\n@@ -872,7 +872,7 @@ pub fn print_attribute(s: @ps, attr: ast::attribute) {\n }\n \n \n-pub fn print_stmt(s: @ps, st: ast::stmt) {\n+pub fn print_stmt(s: @ps, st: &ast::stmt) {\n     maybe_print_comment(s, st.span.lo);\n     match st.node {\n       ast::stmt_decl(decl, _) => {\n@@ -950,7 +950,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n \n     for blk.node.view_items.each |vi| { print_view_item(s, *vi); }\n     for blk.node.stmts.each |st| {\n-        print_stmt(s, **st);\n+        print_stmt(s, *st);\n     }\n     match blk.node.expr {\n       Some(expr) => {\n@@ -1089,7 +1089,7 @@ pub fn print_call_post(s: @ps,\n     }\n }\n \n-pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n+pub fn print_expr(s: @ps, expr: @ast::expr) {\n     fn print_field(s: @ps, field: ast::field) {\n         ibox(s, indent_unit);\n         if field.node.mutbl == ast::m_mutbl { word_nbsp(s, ~\"mut\"); }\n@@ -1454,7 +1454,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n             word_nbsp(s, ~\"mut\");\n         }\n \n-        fn print_local(s: @ps, &&loc: @ast::local) {\n+        fn print_local(s: @ps, loc: @ast::local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n             end(s);\n@@ -1485,7 +1485,7 @@ pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n     print_expr(s, coll);\n }\n \n-pub fn print_path(s: @ps, &&path: @ast::Path, colons_before_params: bool) {\n+pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, ~\"::\"); }\n     let mut first = true;\n@@ -1513,15 +1513,15 @@ pub fn print_path(s: @ps, &&path: @ast::Path, colons_before_params: bool) {\n     }\n }\n \n-pub fn print_irrefutable_pat(s: @ps, &&pat: @ast::pat) {\n+pub fn print_irrefutable_pat(s: @ps, pat: @ast::pat) {\n     print_pat(s, pat, false)\n }\n \n-pub fn print_refutable_pat(s: @ps, &&pat: @ast::pat) {\n+pub fn print_refutable_pat(s: @ps, pat: @ast::pat) {\n     print_pat(s, pat, true)\n }\n \n-pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n+pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     (s.ann.pre)(ann_node);\n@@ -1758,12 +1758,12 @@ pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n     }\n }\n \n-pub fn print_lifetime(s: @ps, &&lifetime: &ast::Lifetime) {\n+pub fn print_lifetime(s: @ps, lifetime: &ast::Lifetime) {\n     word(s.s, ~\"'\");\n     print_ident(s, lifetime.ident);\n }\n \n-pub fn print_generics(s: @ps, &&generics: &ast::Generics) {\n+pub fn print_generics(s: @ps, generics: &ast::Generics) {\n     let total = generics.lifetimes.len() + generics.ty_params.len();\n     if total > 0 {\n         word(s.s, ~\"<\");\n@@ -1790,7 +1790,7 @@ pub fn print_generics(s: @ps, &&generics: &ast::Generics) {\n     }\n }\n \n-pub fn print_meta_item(s: @ps, &&item: @ast::meta_item) {\n+pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n       ast::meta_word(name) => word(s.s, *name),\n@@ -1814,7 +1814,7 @@ pub fn print_meta_item(s: @ps, &&item: @ast::meta_item) {\n     end(s);\n }\n \n-pub fn print_view_path(s: @ps, &&vp: @ast::view_path) {\n+pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, path, namespace, _) => {\n         if namespace == ast::module_ns {\n@@ -2006,7 +2006,7 @@ pub fn print_remaining_comments(s: @ps) {\n     }\n }\n \n-pub fn print_literal(s: @ps, &&lit: @ast::lit) {\n+pub fn print_literal(s: @ps, lit: @ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     match next_lit(s, lit.span.lo) {\n       Some(ref ltrl) => {\n@@ -2137,7 +2137,7 @@ pub fn print_string(s: @ps, st: &str) {\n     word(s.s, ~\"\\\"\");\n }\n \n-pub fn to_str<T>(t: T, f: @fn(@ps, T), intr: @ident_interner) -> ~str {\n+pub fn to_str<T: Copy>(t: T, f: @fn(@ps, T), intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n         f(s, t);"}, {"sha": "6e70bd22b4fa321eba4db3ab6528417003189c1e", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -17,11 +17,10 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[legacy_modes];\n-\n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n-#[allow(deprecated_mode)];\n+#[deny(deprecated_mode)];\n+#[deny(deprecated_pattern)];\n \n #[no_core];\n "}, {"sha": "0aaa08f2e78f6883067cdced4941966c1f1d715b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff701b7db609cabe59832d47779832a16627b5f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4ff701b7db609cabe59832d47779832a16627b5f", "patch": "@@ -101,7 +101,7 @@ pub struct Visitor<E> {\n \n pub type visitor<E> = @Visitor<E>;\n \n-pub fn default_visitor<E>() -> visitor<E> {\n+pub fn default_visitor<E: Copy>() -> visitor<E> {\n     return @Visitor {\n         visit_mod: |a,b,c,d,e|visit_mod::<E>(a, b, c, d, e),\n         visit_view_item: |a,b,c|visit_view_item::<E>(a, b, c),\n@@ -127,18 +127,18 @@ pub fn default_visitor<E>() -> visitor<E> {\n     };\n }\n \n-pub fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n+pub fn visit_crate<E: Copy>(c: &crate, e: E, v: vt<E>) {\n     (v.visit_mod)(&c.node.module, c.span, crate_node_id, e, v);\n }\n \n-pub fn visit_mod<E>(m: &_mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n+pub fn visit_mod<E: Copy>(m: &_mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n     for m.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n     for m.items.each |i| { (v.visit_item)(*i, e, v); }\n }\n \n pub fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n \n-pub fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n+pub fn visit_local<E: Copy>(loc: @local, e: E, v: vt<E>) {\n     (v.visit_pat)(loc.node.pat, e, v);\n     (v.visit_ty)(loc.node.ty, e, v);\n     match loc.node.init {\n@@ -147,11 +147,11 @@ pub fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_trait_ref<E>(tref: @ast::trait_ref, e: E, v: vt<E>) {\n+fn visit_trait_ref<E: Copy>(tref: @ast::trait_ref, e: E, v: vt<E>) {\n     visit_path(tref.path, e, v);\n }\n \n-pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n+pub fn visit_item<E: Copy>(i: @item, e: E, v: vt<E>) {\n     match i.node {\n         item_const(t, ex) => {\n             (v.visit_ty)(t, e, v);\n@@ -216,10 +216,10 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_enum_def<E>(enum_definition: ast::enum_def,\n-                         tps: &Generics,\n-                         e: E,\n-                         v: vt<E>) {\n+pub fn visit_enum_def<E: Copy>(enum_definition: ast::enum_def,\n+                               tps: &Generics,\n+                               e: E,\n+                               v: vt<E>) {\n     for enum_definition.variants.each |vr| {\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n@@ -237,7 +237,7 @@ pub fn visit_enum_def<E>(enum_definition: ast::enum_def,\n \n pub fn skip_ty<E>(_t: @Ty, _e: E, _v: vt<E>) {}\n \n-pub fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n+pub fn visit_ty<E: Copy>(t: @Ty, e: E, v: vt<E>) {\n     match t.node {\n         ty_box(mt) | ty_uniq(mt) |\n         ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n@@ -265,11 +265,11 @@ pub fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_path<E>(p: @Path, e: E, v: vt<E>) {\n+pub fn visit_path<E: Copy>(p: @Path, e: E, v: vt<E>) {\n     for p.types.each |tp| { (v.visit_ty)(*tp, e, v); }\n }\n \n-pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n+pub fn visit_pat<E: Copy>(p: @pat, e: E, v: vt<E>) {\n     match p.node {\n         pat_enum(path, ref children) => {\n             visit_path(path, e, v);\n@@ -315,7 +315,7 @@ pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n+pub fn visit_foreign_item<E: Copy>(ni: @foreign_item, e: E, v: vt<E>) {\n     match ni.node {\n         foreign_item_fn(ref fd, _, ref generics) => {\n             visit_fn_decl(fd, e, v);\n@@ -327,8 +327,8 @@ pub fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_ty_param_bounds<E>(bounds: @OptVec<TyParamBound>,\n-                                e: E, v: vt<E>) {\n+pub fn visit_ty_param_bounds<E: Copy>(bounds: @OptVec<TyParamBound>,\n+                                      e: E, v: vt<E>) {\n     for bounds.each |bound| {\n         match *bound {\n             TraitTyParamBound(ty) => visit_trait_ref(ty, e, v),\n@@ -337,13 +337,13 @@ pub fn visit_ty_param_bounds<E>(bounds: @OptVec<TyParamBound>,\n     }\n }\n \n-pub fn visit_generics<E>(generics: &Generics, e: E, v: vt<E>) {\n+pub fn visit_generics<E: Copy>(generics: &Generics, e: E, v: vt<E>) {\n     for generics.ty_params.each |tp| {\n         visit_ty_param_bounds(tp.bounds, e, v);\n     }\n }\n \n-pub fn visit_fn_decl<E>(fd: &fn_decl, e: E, v: vt<E>) {\n+pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, e: E, v: vt<E>) {\n     for fd.inputs.each |a| {\n         (v.visit_pat)(a.pat, e, v);\n         (v.visit_ty)(a.ty, e, v);\n@@ -355,7 +355,7 @@ pub fn visit_fn_decl<E>(fd: &fn_decl, e: E, v: vt<E>) {\n // visit_fn() and check for fk_method().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n-pub fn visit_method_helper<E>(m: &method, e: E, v: vt<E>) {\n+pub fn visit_method_helper<E: Copy>(m: &method, e: E, v: vt<E>) {\n     (v.visit_fn)(\n         &fk_method(\n             /* FIXME (#2543) */ copy m.ident,\n@@ -390,28 +390,28 @@ pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, generics: &Generics,\n \n }\n \n-pub fn visit_fn<E>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n-                   _id: node_id, e: E, v: vt<E>) {\n+pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n+                         _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n     let generics = generics_of_fn(fk);\n     (v.visit_generics)(&generics, e, v);\n     (v.visit_block)(body, e, v);\n }\n \n-pub fn visit_ty_method<E>(m: &ty_method, e: E, v: vt<E>) {\n+pub fn visit_ty_method<E: Copy>(m: &ty_method, e: E, v: vt<E>) {\n     for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n     (v.visit_generics)(&m.generics, e, v);\n     (v.visit_ty)(m.decl.output, e, v);\n }\n \n-pub fn visit_trait_method<E>(m: &trait_method, e: E, v: vt<E>) {\n+pub fn visit_trait_method<E: Copy>(m: &trait_method, e: E, v: vt<E>) {\n     match *m {\n       required(ref ty_m) => (v.visit_ty_method)(ty_m, e, v),\n       provided(m) => visit_method_helper(m, e, v)\n     }\n }\n \n-pub fn visit_struct_def<E>(\n+pub fn visit_struct_def<E: Copy>(\n     sd: @struct_def,\n     _nm: ast::ident,\n     generics: &Generics,\n@@ -433,15 +433,15 @@ pub fn visit_struct_def<E>(\n     }\n }\n \n-pub fn visit_struct_field<E>(sf: @struct_field, e: E, v: vt<E>) {\n+pub fn visit_struct_field<E: Copy>(sf: @struct_field, e: E, v: vt<E>) {\n     (v.visit_ty)(sf.node.ty, e, v);\n }\n \n-pub fn visit_struct_method<E>(m: @method, e: E, v: vt<E>) {\n+pub fn visit_struct_method<E: Copy>(m: @method, e: E, v: vt<E>) {\n     visit_method_helper(m, e, v);\n }\n \n-pub fn visit_block<E>(b: &blk, e: E, v: vt<E>) {\n+pub fn visit_block<E: Copy>(b: &blk, e: E, v: vt<E>) {\n     for b.node.view_items.each |vi| {\n         (v.visit_view_item)(*vi, e, v);\n     }\n@@ -460,7 +460,7 @@ pub fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n+pub fn visit_decl<E: Copy>(d: @decl, e: E, v: vt<E>) {\n     match d.node {\n         decl_local(ref locs) => {\n             for locs.each |loc| {\n@@ -475,15 +475,15 @@ pub fn visit_expr_opt<E>(eo: Option<@expr>, e: E, v: vt<E>) {\n     match eo { None => (), Some(ex) => (v.visit_expr)(ex, e, v) }\n }\n \n-pub fn visit_exprs<E>(exprs: &[@expr], e: E, v: vt<E>) {\n+pub fn visit_exprs<E: Copy>(exprs: &[@expr], e: E, v: vt<E>) {\n     for exprs.each |ex| { (v.visit_expr)(*ex, e, v); }\n }\n \n pub fn visit_mac<E>(_m: mac, _e: E, _v: vt<E>) {\n     /* no user-serviceable parts inside */\n }\n \n-pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n+pub fn visit_expr<E: Copy>(ex: @expr, e: E, v: vt<E>) {\n     match ex.node {\n         expr_vstore(x, _) => (v.visit_expr)(x, e, v),\n         expr_vec(ref es, _) => visit_exprs(*es, e, v),\n@@ -588,7 +588,7 @@ pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n     (v.visit_expr_post)(ex, e, v);\n }\n \n-pub fn visit_arm<E>(a: &arm, e: E, v: vt<E>) {\n+pub fn visit_arm<E: Copy>(a: &arm, e: E, v: vt<E>) {\n     for a.pats.each |p| { (v.visit_pat)(*p, e, v); }\n     visit_expr_opt(a.guard, e, v);\n     (v.visit_block)(&a.body, e, v);\n@@ -655,67 +655,67 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         m: &_mod,\n         sp: span,\n         id: node_id,\n-        &&e: (),\n+        e: (),\n         v: vt<()>\n     ) {\n         f(m, sp, id);\n         visit_mod(m, sp, id, e, v);\n     }\n-    fn v_view_item(f: @fn(@view_item), vi: @view_item, &&e: (), v: vt<()>) {\n+    fn v_view_item(f: @fn(@view_item), vi: @view_item, e: (), v: vt<()>) {\n         f(vi);\n         visit_view_item(vi, e, v);\n     }\n-    fn v_foreign_item(f: @fn(@foreign_item), ni: @foreign_item, &&e: (),\n+    fn v_foreign_item(f: @fn(@foreign_item), ni: @foreign_item, e: (),\n                       v: vt<()>) {\n         f(ni);\n         visit_foreign_item(ni, e, v);\n     }\n-    fn v_item(f: @fn(@item), i: @item, &&e: (), v: vt<()>) {\n+    fn v_item(f: @fn(@item), i: @item, e: (), v: vt<()>) {\n         f(i);\n         visit_item(i, e, v);\n     }\n-    fn v_local(f: @fn(@local), l: @local, &&e: (), v: vt<()>) {\n+    fn v_local(f: @fn(@local), l: @local, e: (), v: vt<()>) {\n         f(l);\n         visit_local(l, e, v);\n     }\n-    fn v_block(f: @fn(&ast::blk), bl: &ast::blk, &&e: (), v: vt<()>) {\n+    fn v_block(f: @fn(&ast::blk), bl: &ast::blk, e: (), v: vt<()>) {\n         f(bl);\n         visit_block(bl, e, v);\n     }\n-    fn v_stmt(f: @fn(@stmt), st: @stmt, &&e: (), v: vt<()>) {\n+    fn v_stmt(f: @fn(@stmt), st: @stmt, e: (), v: vt<()>) {\n         f(st);\n         visit_stmt(st, e, v);\n     }\n-    fn v_arm(f: @fn(&arm), a: &arm, &&e: (), v: vt<()>) {\n+    fn v_arm(f: @fn(&arm), a: &arm, e: (), v: vt<()>) {\n         f(a);\n         visit_arm(a, e, v);\n     }\n-    fn v_pat(f: @fn(@pat), p: @pat, &&e: (), v: vt<()>) {\n+    fn v_pat(f: @fn(@pat), p: @pat, e: (), v: vt<()>) {\n         f(p);\n         visit_pat(p, e, v);\n     }\n-    fn v_decl(f: @fn(@decl), d: @decl, &&e: (), v: vt<()>) {\n+    fn v_decl(f: @fn(@decl), d: @decl, e: (), v: vt<()>) {\n         f(d);\n         visit_decl(d, e, v);\n     }\n-    fn v_expr(f: @fn(@expr), ex: @expr, &&e: (), v: vt<()>) {\n+    fn v_expr(f: @fn(@expr), ex: @expr, e: (), v: vt<()>) {\n         f(ex);\n         visit_expr(ex, e, v);\n     }\n-    fn v_expr_post(f: @fn(@expr), ex: @expr, &&_e: (), _v: vt<()>) {\n+    fn v_expr_post(f: @fn(@expr), ex: @expr, _e: (), _v: vt<()>) {\n         f(ex);\n     }\n-    fn v_ty(f: @fn(@Ty), ty: @Ty, &&e: (), v: vt<()>) {\n+    fn v_ty(f: @fn(@Ty), ty: @Ty, e: (), v: vt<()>) {\n         f(ty);\n         visit_ty(ty, e, v);\n     }\n-    fn v_ty_method(f: @fn(&ty_method), ty: &ty_method, &&e: (), v: vt<()>) {\n+    fn v_ty_method(f: @fn(&ty_method), ty: &ty_method, e: (), v: vt<()>) {\n         f(ty);\n         visit_ty_method(ty, e, v);\n     }\n     fn v_trait_method(f: @fn(&trait_method),\n                       m: &trait_method,\n-                      &&e: (),\n+                      e: (),\n                       v: vt<()>) {\n         f(m);\n         visit_trait_method(m, e, v);\n@@ -726,7 +726,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         nm: ident,\n         generics: &Generics,\n         id: node_id,\n-        &&e: (),\n+        e: (),\n         v: vt<()>\n     ) {\n         f(sd, nm, generics, id);\n@@ -735,7 +735,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     fn v_generics(\n         f: @fn(&Generics),\n         ps: &Generics,\n-        &&e: (),\n+        e: (),\n         v: vt<()>\n     ) {\n         f(ps);\n@@ -748,20 +748,20 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         body: &blk,\n         sp: span,\n         id: node_id,\n-        &&e: (),\n+        e: (),\n         v: vt<()>\n     ) {\n         f(fk, decl, body, sp, id);\n         visit_fn(fk, decl, body, sp, id, e, v);\n     }\n-    let visit_ty: @fn(@Ty, &&x: (), vt<()>) =\n+    let visit_ty: @fn(@Ty, x: (), vt<()>) =\n         |a,b,c| v_ty(v.visit_ty, a, b, c);\n-    fn v_struct_field(f: @fn(@struct_field), sf: @struct_field, &&e: (),\n+    fn v_struct_field(f: @fn(@struct_field), sf: @struct_field, e: (),\n                       v: vt<()>) {\n         f(sf);\n         visit_struct_field(sf, e, v);\n     }\n-    fn v_struct_method(f: @fn(@method), m: @method, &&e: (), v: vt<()>) {\n+    fn v_struct_method(f: @fn(@method), m: @method, e: (), v: vt<()>) {\n         f(m);\n         visit_struct_method(m, e, v);\n     }"}]}