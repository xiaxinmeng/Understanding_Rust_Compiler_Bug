{"sha": "8fc2eeb1c81aef42855257adc11791dcffe803cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmYzJlZWIxYzgxYWVmNDI4NTUyNTdhZGMxMTc5MWRjZmZlODAzY2I=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-06-10T21:24:28Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-06-19T17:33:09Z"}, "message": "Use newtype to map from `Local` to `GeneratorSavedLocal`", "tree": {"sha": "b264e358cf7dc507a1f8cb605f31d6d3ae5e90ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b264e358cf7dc507a1f8cb605f31d6d3ae5e90ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fc2eeb1c81aef42855257adc11791dcffe803cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc2eeb1c81aef42855257adc11791dcffe803cb", "html_url": "https://github.com/rust-lang/rust/commit/8fc2eeb1c81aef42855257adc11791dcffe803cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fc2eeb1c81aef42855257adc11791dcffe803cb/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72417d84fb51495a4f1d007fb2397a0b2609ab63", "url": "https://api.github.com/repos/rust-lang/rust/commits/72417d84fb51495a4f1d007fb2397a0b2609ab63", "html_url": "https://github.com/rust-lang/rust/commit/72417d84fb51495a4f1d007fb2397a0b2609ab63"}], "stats": {"total": 108, "additions": 64, "deletions": 44}, "files": [{"sha": "1445315c6b18d21e240fc640f0cbf390f4b9cb5f", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 64, "deletions": 44, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8fc2eeb1c81aef42855257adc11791dcffe803cb/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc2eeb1c81aef42855257adc11791dcffe803cb/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=8fc2eeb1c81aef42855257adc11791dcffe803cb", "patch": "@@ -72,7 +72,7 @@ use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::PanicStrategy;\n use std::borrow::Cow;\n-use std::iter;\n+use std::{iter, ops};\n \n pub struct StateTransform;\n \n@@ -417,11 +417,7 @@ fn replace_local<'tcx>(\n \n struct LivenessInfo {\n     /// Which locals are live across any suspension point.\n-    ///\n-    /// GeneratorSavedLocal is indexed in terms of the elements in this set;\n-    /// i.e. GeneratorSavedLocal::new(1) corresponds to the second local\n-    /// included in this set.\n-    live_locals: BitSet<Local>,\n+    saved_locals: GeneratorSavedLocals,\n \n     /// The set of saved locals live at each suspension point.\n     live_locals_at_suspension_points: Vec<BitSet<GeneratorSavedLocal>>,\n@@ -524,49 +520,75 @@ fn locals_live_across_suspend_points(\n             live_locals_at_suspension_points.push(live_locals);\n         }\n     }\n+\n     debug!(\"live_locals_anywhere = {:?}\", live_locals_at_any_suspension_point);\n+    let saved_locals = GeneratorSavedLocals(live_locals_at_any_suspension_point);\n \n     // Renumber our liveness_map bitsets to include only the locals we are\n     // saving.\n     let live_locals_at_suspension_points = live_locals_at_suspension_points\n         .iter()\n-        .map(|live_here| renumber_bitset(&live_here, &live_locals_at_any_suspension_point))\n+        .map(|live_here| saved_locals.renumber_bitset(&live_here))\n         .collect();\n \n     let storage_conflicts = compute_storage_conflicts(\n         body_ref,\n-        &live_locals_at_any_suspension_point,\n+        &saved_locals,\n         always_live_locals.clone(),\n         requires_storage_results,\n     );\n \n     LivenessInfo {\n-        live_locals: live_locals_at_any_suspension_point,\n+        saved_locals,\n         live_locals_at_suspension_points,\n         storage_conflicts,\n         storage_liveness: storage_liveness_map,\n     }\n }\n \n-/// Renumbers the items present in `stored_locals` and applies the renumbering\n-/// to 'input`.\n+/// The set of `Local`s that must be saved across yield points.\n ///\n-/// For example, if `stored_locals = [1, 3, 5]`, this would be renumbered to\n-/// `[0, 1, 2]`. Thus, if `input = [3, 5]` we would return `[1, 2]`.\n-fn renumber_bitset(\n-    input: &BitSet<Local>,\n-    stored_locals: &BitSet<Local>,\n-) -> BitSet<GeneratorSavedLocal> {\n-    assert!(stored_locals.superset(&input), \"{:?} not a superset of {:?}\", stored_locals, input);\n-    let mut out = BitSet::new_empty(stored_locals.count());\n-    for (idx, local) in stored_locals.iter().enumerate() {\n-        let saved_local = GeneratorSavedLocal::from(idx);\n-        if input.contains(local) {\n-            out.insert(saved_local);\n+/// `GeneratorSavedLocal` is indexed in terms of the elements in this set;\n+/// i.e. `GeneratorSavedLocal::new(1)` corresponds to the second local\n+/// included in this set.\n+struct GeneratorSavedLocals(BitSet<Local>);\n+\n+impl GeneratorSavedLocals {\n+    /// Returns an iterator over each `GeneratorSavedLocal` along with the `Local` it corresponds\n+    /// to.\n+    fn iter_enumerated(&self) -> impl '_ + Iterator<Item = (GeneratorSavedLocal, Local)> {\n+        self.iter().enumerate().map(|(i, l)| (GeneratorSavedLocal::from(i), l))\n+    }\n+\n+    /// Transforms a `BitSet<Local>` that contains only locals saved across yield points to the\n+    /// equivalent `BitSet<GeneratorSavedLocal>`.\n+    fn renumber_bitset(&self, input: &BitSet<Local>) -> BitSet<GeneratorSavedLocal> {\n+        assert!(self.superset(&input), \"{:?} not a superset of {:?}\", self.0, input);\n+        let mut out = BitSet::new_empty(self.count());\n+        for (saved_local, local) in self.iter_enumerated() {\n+            if input.contains(local) {\n+                out.insert(saved_local);\n+            }\n+        }\n+        out\n+    }\n+\n+    fn get(&self, local: Local) -> Option<GeneratorSavedLocal> {\n+        if !self.contains(local) {\n+            return None;\n         }\n+\n+        let idx = self.iter().take_while(|&l| l < local).count();\n+        Some(GeneratorSavedLocal::new(idx))\n+    }\n+}\n+\n+impl ops::Deref for GeneratorSavedLocals {\n+    type Target = BitSet<Local>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n     }\n-    debug!(\"renumber_bitset({:?}, {:?}) => {:?}\", input, stored_locals, out);\n-    out\n }\n \n /// For every saved local, looks for which locals are StorageLive at the same\n@@ -575,24 +597,24 @@ fn renumber_bitset(\n /// computation; see `GeneratorLayout` for more.\n fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n-    stored_locals: &BitSet<Local>,\n+    saved_locals: &GeneratorSavedLocals,\n     always_live_locals: storage::AlwaysLiveLocals,\n     requires_storage: dataflow::Results<'tcx, MaybeRequiresStorage<'mir, 'tcx>>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n-    assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n+    assert_eq!(body.local_decls.len(), saved_locals.domain_size());\n \n     debug!(\"compute_storage_conflicts({:?})\", body.span);\n     debug!(\"always_live = {:?}\", always_live_locals);\n \n     // Locals that are always live or ones that need to be stored across\n     // suspension points are not eligible for overlap.\n     let mut ineligible_locals = always_live_locals.into_inner();\n-    ineligible_locals.intersect(stored_locals);\n+    ineligible_locals.intersect(saved_locals);\n \n     // Compute the storage conflicts for all eligible locals.\n     let mut visitor = StorageConflictVisitor {\n         body,\n-        stored_locals: &stored_locals,\n+        saved_locals: &saved_locals,\n         local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n     };\n \n@@ -609,16 +631,14 @@ fn compute_storage_conflicts(\n     // However, in practice these bitsets are not usually large. The layout code\n     // also needs to keep track of how many conflicts each local has, so it's\n     // simpler to keep it this way for now.\n-    let mut storage_conflicts = BitMatrix::new(stored_locals.count(), stored_locals.count());\n-    for (idx_a, local_a) in stored_locals.iter().enumerate() {\n-        let saved_local_a = GeneratorSavedLocal::new(idx_a);\n+    let mut storage_conflicts = BitMatrix::new(saved_locals.count(), saved_locals.count());\n+    for (saved_local_a, local_a) in saved_locals.iter_enumerated() {\n         if ineligible_locals.contains(local_a) {\n             // Conflicts with everything.\n             storage_conflicts.insert_all_into_row(saved_local_a);\n         } else {\n             // Keep overlap information only for stored locals.\n-            for (idx_b, local_b) in stored_locals.iter().enumerate() {\n-                let saved_local_b = GeneratorSavedLocal::new(idx_b);\n+            for (saved_local_b, local_b) in saved_locals.iter_enumerated() {\n                 if local_conflicts.contains(local_a, local_b) {\n                     storage_conflicts.insert(saved_local_a, saved_local_b);\n                 }\n@@ -630,7 +650,7 @@ fn compute_storage_conflicts(\n \n struct StorageConflictVisitor<'mir, 'tcx, 's> {\n     body: &'mir Body<'tcx>,\n-    stored_locals: &'s BitSet<Local>,\n+    saved_locals: &'s GeneratorSavedLocals,\n     // FIXME(tmandry): Consider using sparse bitsets here once we have good\n     // benchmarks for generators.\n     local_conflicts: BitMatrix<Local, Local>,\n@@ -666,7 +686,7 @@ impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n         }\n \n         let mut eligible_storage_live = flow_state.clone();\n-        eligible_storage_live.intersect(&self.stored_locals);\n+        eligible_storage_live.intersect(&self.saved_locals);\n \n         for local in eligible_storage_live.iter() {\n             self.local_conflicts.union_row_with(&eligible_storage_live, local);\n@@ -678,15 +698,15 @@ impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n     }\n }\n \n-/// Validates the typeck view of the generator against the actual set of types retained between\n+/// Validates the typeck view of the generator against the actual set of types saved between\n /// yield points.\n fn sanitize_witness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     did: DefId,\n     witness: Ty<'tcx>,\n     upvars: &Vec<Ty<'tcx>>,\n-    retained: &BitSet<Local>,\n+    saved_locals: &GeneratorSavedLocals,\n ) {\n     let allowed_upvars = tcx.erase_regions(upvars);\n     let allowed = match witness.kind {\n@@ -703,8 +723,8 @@ fn sanitize_witness<'tcx>(\n     let param_env = tcx.param_env(did);\n \n     for (local, decl) in body.local_decls.iter_enumerated() {\n-        // Ignore locals which are internal or not retained between yields.\n-        if !retained.contains(local) || decl.internal {\n+        // Ignore locals which are internal or not saved between yields.\n+        if !saved_locals.contains(local) || decl.internal {\n             continue;\n         }\n         let decl_ty = tcx.normalize_erasing_regions(param_env, decl.ty);\n@@ -738,21 +758,21 @@ fn compute_layout<'tcx>(\n ) {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {\n-        live_locals,\n+        saved_locals,\n         live_locals_at_suspension_points,\n         storage_conflicts,\n         storage_liveness,\n     } = locals_live_across_suspend_points(tcx, body, source, always_live_locals, movable);\n \n-    sanitize_witness(tcx, body, source.def_id(), interior, upvars, &live_locals);\n+    sanitize_witness(tcx, body, source.def_id(), interior, upvars, &saved_locals);\n \n     // Gather live local types and their indices.\n     let mut locals = IndexVec::<GeneratorSavedLocal, _>::new();\n     let mut tys = IndexVec::<GeneratorSavedLocal, _>::new();\n-    for (idx, local) in live_locals.iter().enumerate() {\n+    for (saved_local, local) in saved_locals.iter_enumerated() {\n         locals.push(local);\n         tys.push(body.local_decls[local].ty);\n-        debug!(\"generator saved local {:?} => {:?}\", GeneratorSavedLocal::from(idx), local);\n+        debug!(\"generator saved local {:?} => {:?}\", saved_local, local);\n     }\n \n     // Leave empty variants for the UNRESUMED, RETURNED, and POISONED states."}]}