{"sha": "0366f5ae23fa1268e95ffeff787c4eeb19d02a2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNjZmNWFlMjNmYTEyNjhlOTVmZmVmZjc4N2M0ZWViMTlkMDJhMmE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-21T17:21:09Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-21T17:24:00Z"}, "message": "Add some C99 and C++ compatibility headers for MSVC", "tree": {"sha": "d8d048718146778e7005e83b72db51983cf4f72e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8d048718146778e7005e83b72db51983cf4f72e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a", "html_url": "https://github.com/rust-lang/rust/commit/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e687dd5ce7fe22faa7c93f9a3ed9391e78991c0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e687dd5ce7fe22faa7c93f9a3ed9391e78991c0e", "html_url": "https://github.com/rust-lang/rust/commit/e687dd5ce7fe22faa7c93f9a3ed9391e78991c0e"}], "stats": {"total": 649, "additions": 649, "deletions": 0}, "files": [{"sha": "4b3828a216298df33899652a1574db70ded3f082", "filename": "src/rt/msvc/inttypes.h", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a/src%2Frt%2Fmsvc%2Finttypes.h", "raw_url": "https://github.com/rust-lang/rust/raw/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a/src%2Frt%2Fmsvc%2Finttypes.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmsvc%2Finttypes.h?ref=0366f5ae23fa1268e95ffeff787c4eeb19d02a2a", "patch": "@@ -0,0 +1,305 @@\n+// ISO C9x  compliant inttypes.h for Microsoft Visual Studio\n+// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 \n+// \n+//  Copyright (c) 2006 Alexander Chemeris\n+// \n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+// \n+//   1. Redistributions of source code must retain the above copyright notice,\n+//      this list of conditions and the following disclaimer.\n+// \n+//   2. Redistributions in binary form must reproduce the above copyright\n+//      notice, this list of conditions and the following disclaimer in the\n+//      documentation and/or other materials provided with the distribution.\n+// \n+//   3. The name of the author may be used to endorse or promote products\n+//      derived from this software without specific prior written permission.\n+// \n+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n+// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n+// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n+// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n+// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+// \n+///////////////////////////////////////////////////////////////////////////////\n+\n+#ifndef _MSC_VER // [\n+#error \"Use this header only with Microsoft Visual C++ compilers!\"\n+#endif // _MSC_VER ]\n+\n+#ifndef _MSC_INTTYPES_H_ // [\n+#define _MSC_INTTYPES_H_\n+\n+#if _MSC_VER > 1000\n+#pragma once\n+#endif\n+\n+#include \"stdint.h\"\n+\n+// 7.8 Format conversion of integer types\n+\n+typedef struct {\n+   intmax_t quot;\n+   intmax_t rem;\n+} imaxdiv_t;\n+\n+// 7.8.1 Macros for format specifiers\n+\n+#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) // [   See footnote 185 at page 198\n+\n+// The fprintf macros for signed integers are:\n+#define PRId8       \"d\"\n+#define PRIi8       \"i\"\n+#define PRIdLEAST8  \"d\"\n+#define PRIiLEAST8  \"i\"\n+#define PRIdFAST8   \"d\"\n+#define PRIiFAST8   \"i\"\n+\n+#define PRId16       \"hd\"\n+#define PRIi16       \"hi\"\n+#define PRIdLEAST16  \"hd\"\n+#define PRIiLEAST16  \"hi\"\n+#define PRIdFAST16   \"hd\"\n+#define PRIiFAST16   \"hi\"\n+\n+#define PRId32       \"I32d\"\n+#define PRIi32       \"I32i\"\n+#define PRIdLEAST32  \"I32d\"\n+#define PRIiLEAST32  \"I32i\"\n+#define PRIdFAST32   \"I32d\"\n+#define PRIiFAST32   \"I32i\"\n+\n+#define PRId64       \"I64d\"\n+#define PRIi64       \"I64i\"\n+#define PRIdLEAST64  \"I64d\"\n+#define PRIiLEAST64  \"I64i\"\n+#define PRIdFAST64   \"I64d\"\n+#define PRIiFAST64   \"I64i\"\n+\n+#define PRIdMAX     \"I64d\"\n+#define PRIiMAX     \"I64i\"\n+\n+#define PRIdPTR     \"Id\"\n+#define PRIiPTR     \"Ii\"\n+\n+// The fprintf macros for unsigned integers are:\n+#define PRIo8       \"o\"\n+#define PRIu8       \"u\"\n+#define PRIx8       \"x\"\n+#define PRIX8       \"X\"\n+#define PRIoLEAST8  \"o\"\n+#define PRIuLEAST8  \"u\"\n+#define PRIxLEAST8  \"x\"\n+#define PRIXLEAST8  \"X\"\n+#define PRIoFAST8   \"o\"\n+#define PRIuFAST8   \"u\"\n+#define PRIxFAST8   \"x\"\n+#define PRIXFAST8   \"X\"\n+\n+#define PRIo16       \"ho\"\n+#define PRIu16       \"hu\"\n+#define PRIx16       \"hx\"\n+#define PRIX16       \"hX\"\n+#define PRIoLEAST16  \"ho\"\n+#define PRIuLEAST16  \"hu\"\n+#define PRIxLEAST16  \"hx\"\n+#define PRIXLEAST16  \"hX\"\n+#define PRIoFAST16   \"ho\"\n+#define PRIuFAST16   \"hu\"\n+#define PRIxFAST16   \"hx\"\n+#define PRIXFAST16   \"hX\"\n+\n+#define PRIo32       \"I32o\"\n+#define PRIu32       \"I32u\"\n+#define PRIx32       \"I32x\"\n+#define PRIX32       \"I32X\"\n+#define PRIoLEAST32  \"I32o\"\n+#define PRIuLEAST32  \"I32u\"\n+#define PRIxLEAST32  \"I32x\"\n+#define PRIXLEAST32  \"I32X\"\n+#define PRIoFAST32   \"I32o\"\n+#define PRIuFAST32   \"I32u\"\n+#define PRIxFAST32   \"I32x\"\n+#define PRIXFAST32   \"I32X\"\n+\n+#define PRIo64       \"I64o\"\n+#define PRIu64       \"I64u\"\n+#define PRIx64       \"I64x\"\n+#define PRIX64       \"I64X\"\n+#define PRIoLEAST64  \"I64o\"\n+#define PRIuLEAST64  \"I64u\"\n+#define PRIxLEAST64  \"I64x\"\n+#define PRIXLEAST64  \"I64X\"\n+#define PRIoFAST64   \"I64o\"\n+#define PRIuFAST64   \"I64u\"\n+#define PRIxFAST64   \"I64x\"\n+#define PRIXFAST64   \"I64X\"\n+\n+#define PRIoMAX     \"I64o\"\n+#define PRIuMAX     \"I64u\"\n+#define PRIxMAX     \"I64x\"\n+#define PRIXMAX     \"I64X\"\n+\n+#define PRIoPTR     \"Io\"\n+#define PRIuPTR     \"Iu\"\n+#define PRIxPTR     \"Ix\"\n+#define PRIXPTR     \"IX\"\n+\n+// The fscanf macros for signed integers are:\n+#define SCNd8       \"d\"\n+#define SCNi8       \"i\"\n+#define SCNdLEAST8  \"d\"\n+#define SCNiLEAST8  \"i\"\n+#define SCNdFAST8   \"d\"\n+#define SCNiFAST8   \"i\"\n+\n+#define SCNd16       \"hd\"\n+#define SCNi16       \"hi\"\n+#define SCNdLEAST16  \"hd\"\n+#define SCNiLEAST16  \"hi\"\n+#define SCNdFAST16   \"hd\"\n+#define SCNiFAST16   \"hi\"\n+\n+#define SCNd32       \"ld\"\n+#define SCNi32       \"li\"\n+#define SCNdLEAST32  \"ld\"\n+#define SCNiLEAST32  \"li\"\n+#define SCNdFAST32   \"ld\"\n+#define SCNiFAST32   \"li\"\n+\n+#define SCNd64       \"I64d\"\n+#define SCNi64       \"I64i\"\n+#define SCNdLEAST64  \"I64d\"\n+#define SCNiLEAST64  \"I64i\"\n+#define SCNdFAST64   \"I64d\"\n+#define SCNiFAST64   \"I64i\"\n+\n+#define SCNdMAX     \"I64d\"\n+#define SCNiMAX     \"I64i\"\n+\n+#ifdef _WIN64 // [\n+#  define SCNdPTR     \"I64d\"\n+#  define SCNiPTR     \"I64i\"\n+#else  // _WIN64 ][\n+#  define SCNdPTR     \"ld\"\n+#  define SCNiPTR     \"li\"\n+#endif  // _WIN64 ]\n+\n+// The fscanf macros for unsigned integers are:\n+#define SCNo8       \"o\"\n+#define SCNu8       \"u\"\n+#define SCNx8       \"x\"\n+#define SCNX8       \"X\"\n+#define SCNoLEAST8  \"o\"\n+#define SCNuLEAST8  \"u\"\n+#define SCNxLEAST8  \"x\"\n+#define SCNXLEAST8  \"X\"\n+#define SCNoFAST8   \"o\"\n+#define SCNuFAST8   \"u\"\n+#define SCNxFAST8   \"x\"\n+#define SCNXFAST8   \"X\"\n+\n+#define SCNo16       \"ho\"\n+#define SCNu16       \"hu\"\n+#define SCNx16       \"hx\"\n+#define SCNX16       \"hX\"\n+#define SCNoLEAST16  \"ho\"\n+#define SCNuLEAST16  \"hu\"\n+#define SCNxLEAST16  \"hx\"\n+#define SCNXLEAST16  \"hX\"\n+#define SCNoFAST16   \"ho\"\n+#define SCNuFAST16   \"hu\"\n+#define SCNxFAST16   \"hx\"\n+#define SCNXFAST16   \"hX\"\n+\n+#define SCNo32       \"lo\"\n+#define SCNu32       \"lu\"\n+#define SCNx32       \"lx\"\n+#define SCNX32       \"lX\"\n+#define SCNoLEAST32  \"lo\"\n+#define SCNuLEAST32  \"lu\"\n+#define SCNxLEAST32  \"lx\"\n+#define SCNXLEAST32  \"lX\"\n+#define SCNoFAST32   \"lo\"\n+#define SCNuFAST32   \"lu\"\n+#define SCNxFAST32   \"lx\"\n+#define SCNXFAST32   \"lX\"\n+\n+#define SCNo64       \"I64o\"\n+#define SCNu64       \"I64u\"\n+#define SCNx64       \"I64x\"\n+#define SCNX64       \"I64X\"\n+#define SCNoLEAST64  \"I64o\"\n+#define SCNuLEAST64  \"I64u\"\n+#define SCNxLEAST64  \"I64x\"\n+#define SCNXLEAST64  \"I64X\"\n+#define SCNoFAST64   \"I64o\"\n+#define SCNuFAST64   \"I64u\"\n+#define SCNxFAST64   \"I64x\"\n+#define SCNXFAST64   \"I64X\"\n+\n+#define SCNoMAX     \"I64o\"\n+#define SCNuMAX     \"I64u\"\n+#define SCNxMAX     \"I64x\"\n+#define SCNXMAX     \"I64X\"\n+\n+#ifdef _WIN64 // [\n+#  define SCNoPTR     \"I64o\"\n+#  define SCNuPTR     \"I64u\"\n+#  define SCNxPTR     \"I64x\"\n+#  define SCNXPTR     \"I64X\"\n+#else  // _WIN64 ][\n+#  define SCNoPTR     \"lo\"\n+#  define SCNuPTR     \"lu\"\n+#  define SCNxPTR     \"lx\"\n+#  define SCNXPTR     \"lX\"\n+#endif  // _WIN64 ]\n+\n+#endif // __STDC_FORMAT_MACROS ]\n+\n+// 7.8.2 Functions for greatest-width integer types\n+\n+// 7.8.2.1 The imaxabs function\n+#define imaxabs _abs64\n+\n+// 7.8.2.2 The imaxdiv function\n+\n+// This is modified version of div() function from Microsoft's div.c found\n+// in %MSVC.NET%\\crt\\src\\div.c\n+#ifdef STATIC_IMAXDIV // [\n+static\n+#else // STATIC_IMAXDIV ][\n+_inline\n+#endif // STATIC_IMAXDIV ]\n+imaxdiv_t __cdecl imaxdiv(intmax_t numer, intmax_t denom)\n+{\n+   imaxdiv_t result;\n+\n+   result.quot = numer / denom;\n+   result.rem = numer % denom;\n+\n+   if (numer < 0 && result.rem > 0) {\n+      // did division wrong; must fix up\n+      ++result.quot;\n+      result.rem -= denom;\n+   }\n+\n+   return result;\n+}\n+\n+// 7.8.2.3 The strtoimax and strtoumax functions\n+#define strtoimax _strtoi64\n+#define strtoumax _strtoui64\n+\n+// 7.8.2.4 The wcstoimax and wcstoumax functions\n+#define wcstoimax _wcstoi64\n+#define wcstoumax _wcstoui64\n+\n+\n+#endif // _MSC_INTTYPES_H_ ]"}, {"sha": "d02608a5972642c7b7a13b987f21e2502a5af3ea", "filename": "src/rt/msvc/stdint.h", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a/src%2Frt%2Fmsvc%2Fstdint.h", "raw_url": "https://github.com/rust-lang/rust/raw/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a/src%2Frt%2Fmsvc%2Fstdint.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmsvc%2Fstdint.h?ref=0366f5ae23fa1268e95ffeff787c4eeb19d02a2a", "patch": "@@ -0,0 +1,247 @@\n+// ISO C9x  compliant stdint.h for Microsoft Visual Studio\n+// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 \n+// \n+//  Copyright (c) 2006-2008 Alexander Chemeris\n+// \n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+// \n+//   1. Redistributions of source code must retain the above copyright notice,\n+//      this list of conditions and the following disclaimer.\n+// \n+//   2. Redistributions in binary form must reproduce the above copyright\n+//      notice, this list of conditions and the following disclaimer in the\n+//      documentation and/or other materials provided with the distribution.\n+// \n+//   3. The name of the author may be used to endorse or promote products\n+//      derived from this software without specific prior written permission.\n+// \n+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n+// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n+// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n+// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n+// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+// \n+///////////////////////////////////////////////////////////////////////////////\n+\n+#ifndef _MSC_VER // [\n+#error \"Use this header only with Microsoft Visual C++ compilers!\"\n+#endif // _MSC_VER ]\n+\n+#ifndef _MSC_STDINT_H_ // [\n+#define _MSC_STDINT_H_\n+\n+#if _MSC_VER > 1000\n+#pragma once\n+#endif\n+\n+#include <limits.h>\n+\n+// For Visual Studio 6 in C++ mode and for many Visual Studio versions when\n+// compiling for ARM we should wrap <wchar.h> include with 'extern \"C++\" {}'\n+// or compiler give many errors like this:\n+//   error C2733: second C linkage of overloaded function 'wmemchr' not allowed\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+#  include <wchar.h>\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+// Define _W64 macros to mark types changing their size, like intptr_t.\n+#ifndef _W64\n+#  if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300\n+#     define _W64 __w64\n+#  else\n+#     define _W64\n+#  endif\n+#endif\n+\n+\n+// 7.18.1 Integer types\n+\n+// 7.18.1.1 Exact-width integer types\n+\n+// Visual Studio 6 and Embedded Visual C++ 4 doesn't\n+// realize that, e.g. char has the same size as __int8\n+// so we give up on __intX for them.\n+#if (_MSC_VER < 1300)\n+   typedef signed char       int8_t;\n+   typedef signed short      int16_t;\n+   typedef signed int        int32_t;\n+   typedef unsigned char     uint8_t;\n+   typedef unsigned short    uint16_t;\n+   typedef unsigned int      uint32_t;\n+#else\n+   typedef signed __int8     int8_t;\n+   typedef signed __int16    int16_t;\n+   typedef signed __int32    int32_t;\n+   typedef unsigned __int8   uint8_t;\n+   typedef unsigned __int16  uint16_t;\n+   typedef unsigned __int32  uint32_t;\n+#endif\n+typedef signed __int64       int64_t;\n+typedef unsigned __int64     uint64_t;\n+\n+\n+// 7.18.1.2 Minimum-width integer types\n+typedef int8_t    int_least8_t;\n+typedef int16_t   int_least16_t;\n+typedef int32_t   int_least32_t;\n+typedef int64_t   int_least64_t;\n+typedef uint8_t   uint_least8_t;\n+typedef uint16_t  uint_least16_t;\n+typedef uint32_t  uint_least32_t;\n+typedef uint64_t  uint_least64_t;\n+\n+// 7.18.1.3 Fastest minimum-width integer types\n+typedef int8_t    int_fast8_t;\n+typedef int16_t   int_fast16_t;\n+typedef int32_t   int_fast32_t;\n+typedef int64_t   int_fast64_t;\n+typedef uint8_t   uint_fast8_t;\n+typedef uint16_t  uint_fast16_t;\n+typedef uint32_t  uint_fast32_t;\n+typedef uint64_t  uint_fast64_t;\n+\n+// 7.18.1.4 Integer types capable of holding object pointers\n+#ifdef _WIN64 // [\n+   typedef signed __int64    intptr_t;\n+   typedef unsigned __int64  uintptr_t;\n+#else // _WIN64 ][\n+   typedef _W64 signed int   intptr_t;\n+   typedef _W64 unsigned int uintptr_t;\n+#endif // _WIN64 ]\n+\n+// 7.18.1.5 Greatest-width integer types\n+typedef int64_t   intmax_t;\n+typedef uint64_t  uintmax_t;\n+\n+\n+// 7.18.2 Limits of specified-width integer types\n+\n+#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) // [   See footnote 220 at page 257 and footnote 221 at page 259\n+\n+// 7.18.2.1 Limits of exact-width integer types\n+#define INT8_MIN     ((int8_t)_I8_MIN)\n+#define INT8_MAX     _I8_MAX\n+#define INT16_MIN    ((int16_t)_I16_MIN)\n+#define INT16_MAX    _I16_MAX\n+#define INT32_MIN    ((int32_t)_I32_MIN)\n+#define INT32_MAX    _I32_MAX\n+#define INT64_MIN    ((int64_t)_I64_MIN)\n+#define INT64_MAX    _I64_MAX\n+#define UINT8_MAX    _UI8_MAX\n+#define UINT16_MAX   _UI16_MAX\n+#define UINT32_MAX   _UI32_MAX\n+#define UINT64_MAX   _UI64_MAX\n+\n+// 7.18.2.2 Limits of minimum-width integer types\n+#define INT_LEAST8_MIN    INT8_MIN\n+#define INT_LEAST8_MAX    INT8_MAX\n+#define INT_LEAST16_MIN   INT16_MIN\n+#define INT_LEAST16_MAX   INT16_MAX\n+#define INT_LEAST32_MIN   INT32_MIN\n+#define INT_LEAST32_MAX   INT32_MAX\n+#define INT_LEAST64_MIN   INT64_MIN\n+#define INT_LEAST64_MAX   INT64_MAX\n+#define UINT_LEAST8_MAX   UINT8_MAX\n+#define UINT_LEAST16_MAX  UINT16_MAX\n+#define UINT_LEAST32_MAX  UINT32_MAX\n+#define UINT_LEAST64_MAX  UINT64_MAX\n+\n+// 7.18.2.3 Limits of fastest minimum-width integer types\n+#define INT_FAST8_MIN    INT8_MIN\n+#define INT_FAST8_MAX    INT8_MAX\n+#define INT_FAST16_MIN   INT16_MIN\n+#define INT_FAST16_MAX   INT16_MAX\n+#define INT_FAST32_MIN   INT32_MIN\n+#define INT_FAST32_MAX   INT32_MAX\n+#define INT_FAST64_MIN   INT64_MIN\n+#define INT_FAST64_MAX   INT64_MAX\n+#define UINT_FAST8_MAX   UINT8_MAX\n+#define UINT_FAST16_MAX  UINT16_MAX\n+#define UINT_FAST32_MAX  UINT32_MAX\n+#define UINT_FAST64_MAX  UINT64_MAX\n+\n+// 7.18.2.4 Limits of integer types capable of holding object pointers\n+#ifdef _WIN64 // [\n+#  define INTPTR_MIN   INT64_MIN\n+#  define INTPTR_MAX   INT64_MAX\n+#  define UINTPTR_MAX  UINT64_MAX\n+#else // _WIN64 ][\n+#  define INTPTR_MIN   INT32_MIN\n+#  define INTPTR_MAX   INT32_MAX\n+#  define UINTPTR_MAX  UINT32_MAX\n+#endif // _WIN64 ]\n+\n+// 7.18.2.5 Limits of greatest-width integer types\n+#define INTMAX_MIN   INT64_MIN\n+#define INTMAX_MAX   INT64_MAX\n+#define UINTMAX_MAX  UINT64_MAX\n+\n+// 7.18.3 Limits of other integer types\n+\n+#ifdef _WIN64 // [\n+#  define PTRDIFF_MIN  _I64_MIN\n+#  define PTRDIFF_MAX  _I64_MAX\n+#else  // _WIN64 ][\n+#  define PTRDIFF_MIN  _I32_MIN\n+#  define PTRDIFF_MAX  _I32_MAX\n+#endif  // _WIN64 ]\n+\n+#define SIG_ATOMIC_MIN  INT_MIN\n+#define SIG_ATOMIC_MAX  INT_MAX\n+\n+#ifndef SIZE_MAX // [\n+#  ifdef _WIN64 // [\n+#     define SIZE_MAX  _UI64_MAX\n+#  else // _WIN64 ][\n+#     define SIZE_MAX  _UI32_MAX\n+#  endif // _WIN64 ]\n+#endif // SIZE_MAX ]\n+\n+// WCHAR_MIN and WCHAR_MAX are also defined in <wchar.h>\n+#ifndef WCHAR_MIN // [\n+#  define WCHAR_MIN  0\n+#endif  // WCHAR_MIN ]\n+#ifndef WCHAR_MAX // [\n+#  define WCHAR_MAX  _UI16_MAX\n+#endif  // WCHAR_MAX ]\n+\n+#define WINT_MIN  0\n+#define WINT_MAX  _UI16_MAX\n+\n+#endif // __STDC_LIMIT_MACROS ]\n+\n+\n+// 7.18.4 Limits of other integer types\n+\n+#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) // [   See footnote 224 at page 260\n+\n+// 7.18.4.1 Macros for minimum-width integer constants\n+\n+#define INT8_C(val)  val##i8\n+#define INT16_C(val) val##i16\n+#define INT32_C(val) val##i32\n+#define INT64_C(val) val##i64\n+\n+#define UINT8_C(val)  val##ui8\n+#define UINT16_C(val) val##ui16\n+#define UINT32_C(val) val##ui32\n+#define UINT64_C(val) val##ui64\n+\n+// 7.18.4.2 Macros for greatest-width integer constants\n+#define INTMAX_C   INT64_C\n+#define UINTMAX_C  UINT64_C\n+\n+#endif // __STDC_CONSTANT_MACROS ]\n+\n+\n+#endif // _MSC_STDINT_H_ ]"}, {"sha": "b83f530b0e9bccf1a7e392263446d5a7c6070d8d", "filename": "src/rt/msvc/typeof.h", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a/src%2Frt%2Fmsvc%2Ftypeof.h", "raw_url": "https://github.com/rust-lang/rust/raw/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a/src%2Frt%2Fmsvc%2Ftypeof.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmsvc%2Ftypeof.h?ref=0366f5ae23fa1268e95ffeff787c4eeb19d02a2a", "patch": "@@ -0,0 +1,97 @@\n+// This piece of magic brought to you by:\n+//     http://www.nedproductions.biz/blog/\n+//     implementing-typeof-in-microsofts-c-compiler \n+\n+#ifndef MSVC_TYPEOF_H\n+#define MSVC_TYPEOF_H\n+\n+#if defined(_MSC_VER) && _MSC_VER>=1400\n+namespace msvc_typeof_impl {\n+\t/* This is a fusion of Igor Chesnokov's method (http://rsdn.ru/forum/src/1094305.aspx)\n+\tand Steven Watanabe's method (http://lists.boost.org/Archives/boost/2006/12/115006.php)\n+\n+\tHow it works:\n+\tC++ allows template type inference for templated function parameters but nothing else.\n+\tWhat we do is to pass the expression sent to typeof() into the templated function vartypeID()\n+\tas its parameter, thus extracting its type. The big problem traditionally now is how to get\n+\tthat type out of the vartypeID() instance, and here's how we do it:\n+\t\t1. unique_type_id() returns a monotonically increasing integer for every unique type\n+\t\t   passed to it during this compilation unit. It also specialises an instance of\n+\t\t   msvc_extract_type<unique_type_id, type>::id2type_impl<true>.\n+\t\t2. vartypeID() returns a sized<unique_type_id> for the type where\n+\t\t   sizeof(sized<unique_type_id>)==unique_type_id. We vector through sized as a means\n+\t\t   of returning the unique_type_id at compile time rather than runtime.\n+\t\t3. msvc_extract_type<unique_type_id> then extracts the type by using a bug in MSVC to\n+\t\t   reselect the specialised child type (id2type_impl<true>) from within the specialisation\n+\t\t   of itself originally performed by the above instance of unique_type_id. This bug works\n+\t\t   because when MSVC calculated the signature of the specialised\n+\t\t   msvc_extract_type<unique_type_id, type>::id2type_impl<true>, it does not include the\n+\t\t   value of type in the signature of id2type_impl<true>. Therefore when we reselect\n+\t\t   msvc_extract_type<unique_type_id>::id2type_impl<true> it erroneously returns the one\n+\t\t   already in its list of instantiated types rather than correctly generating a newly\n+\t\t   specialised msvc_extract_type<unique_type_id, msvc_extract_type_default_param>::id2type_impl<true>\n+\n+\tThis bug allows the impossible and gives us a working typeof() in MSVC. Hopefully Microsoft\n+\twon't fix this bug until they implement a native typeof.\n+\t*/\n+\n+\tstruct msvc_extract_type_default_param {};\n+\ttemplate<int ID, typename T = msvc_extract_type_default_param> struct msvc_extract_type;\n+\n+\ttemplate<int ID> struct msvc_extract_type<ID, msvc_extract_type_default_param>\n+\t{\n+\t\ttemplate<bool> struct id2type_impl; \n+\n+\t\ttypedef id2type_impl<true> id2type; \n+\t};\n+\n+\ttemplate<int ID, typename T> struct msvc_extract_type : msvc_extract_type<ID, msvc_extract_type_default_param> \n+\t{ \n+\t\ttemplate<> struct id2type_impl<true> //VC8.0 specific bugfeature \n+\t\t{ \n+\t\t\ttypedef T type; \n+\t\t}; \n+\t\ttemplate<bool> struct id2type_impl; \n+\n+\t\ttypedef id2type_impl<true> id2type; \n+\t}; \n+\n+\n+\ttemplate<int N> class CCounter;\n+\n+\t// TUnused is required to force compiler to recompile CCountOf class\n+\ttemplate<typename TUnused, int NTested = 0> struct CCountOf\n+\t{\n+\t\tenum\n+\t\t{\n+\t\t\t__if_exists(CCounter<NTested>) { count = CCountOf<TUnused, NTested + 1>::count }\n+\t\t\t__if_not_exists(CCounter<NTested>) { count = NTested }\n+\t\t};\n+\t};\n+\n+\ttemplate<class TTypeReg, class TUnused, int NValue> struct CProvideCounterValue { enum { value = NValue }; };\n+\n+\t// type_id\n+\t#define unique_type_id(type) \\\n+\t\t(CProvideCounterValue< \\\n+\t\t\t/*register TYPE--ID*/ typename msvc_extract_type<CCountOf<type >::count, type>::id2type, \\\n+\t\t\t/*increment compile-time Counter*/ CCounter<CCountOf<type >::count>, \\\n+\t\t\t/*pass value of Counter*/CCountOf<type >::count \\\n+\t\t >::value)\n+\n+\t// Lets type_id() be > than 0\n+\tclass __Increment_type_id { enum { value = unique_type_id(__Increment_type_id) }; };\n+\n+\t// vartypeID() returns a type with sizeof(type_id)\n+\ttemplate<int NSize>\tclass sized { char m_pad[NSize]; };\n+\ttemplate<typename T> typename sized<unique_type_id(T)> vartypeID(T&);\n+\ttemplate<typename T> typename sized<unique_type_id(const T)> vartypeID(const T&);\n+\ttemplate<typename T> typename sized<unique_type_id(volatile  T)> vartypeID(volatile T&);\n+\ttemplate<typename T> typename sized<unique_type_id(const volatile T)> vartypeID(const volatile T&);\n+}\n+\n+#define typeof(expression) msvc_typeof_impl::msvc_extract_type<sizeof(msvc_typeof_impl::vartypeID(expression))>::id2type::type\n+#endif\n+\n+#endif\n+"}]}