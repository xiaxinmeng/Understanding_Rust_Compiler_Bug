{"sha": "3bf41dafcfb6c979efb4e2438e047e1a54045eec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiZjQxZGFmY2ZiNmM5NzllZmI0ZTI0MzhlMDQ3ZTFhNTQwNDVlZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-20T06:45:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-20T06:45:02Z"}, "message": "Auto merge of #21304 - lifthrasiir:htmldocck, r=alexcrichton\n\nThe script is intended as a tool for doing every sort of verifications amenable to Rustdoc's HTML output. For example, link checkers would go to this script. It already parses HTML into a document tree form (with a slight caveat), so future tests can make use of it.\r\n\r\nAs an example, relevant `rustdoc-*` run-make tests have been updated to use `htmldocck.py` and got their `verify.sh` removed. In the future they may go to a dedicated directory with htmldocck running by default. The detailed explanation of test scripts is provided as a docstring of htmldocck.\r\n\r\ncc #19723", "tree": {"sha": "46883a9bec57ec670561487b7a17c1e6fa655a3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46883a9bec57ec670561487b7a17c1e6fa655a3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bf41dafcfb6c979efb4e2438e047e1a54045eec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf41dafcfb6c979efb4e2438e047e1a54045eec", "html_url": "https://github.com/rust-lang/rust/commit/3bf41dafcfb6c979efb4e2438e047e1a54045eec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bf41dafcfb6c979efb4e2438e047e1a54045eec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9006c3c0f14be45da8ffeba43d354d088e366c83", "url": "https://api.github.com/repos/rust-lang/rust/commits/9006c3c0f14be45da8ffeba43d354d088e366c83", "html_url": "https://github.com/rust-lang/rust/commit/9006c3c0f14be45da8ffeba43d354d088e366c83"}, {"sha": "2c1d1fbdf96b4eb90fa48a3602cf869acf054d6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1d1fbdf96b4eb90fa48a3602cf869acf054d6c", "html_url": "https://github.com/rust-lang/rust/commit/2c1d1fbdf96b4eb90fa48a3602cf869acf054d6c"}], "stats": {"total": 488, "additions": 389, "deletions": 99}, "files": [{"sha": "10452d9127501c85e51368f77c3871afe5a23962", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -1011,7 +1011,8 @@ $(3)/test/run-make/%-$(1)-T-$(2)-H-$(3).ok: \\\n \t    $$(LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3)) \\\n \t    \"$$(LD_LIBRARY_PATH_ENV_HOSTDIR$(1)_T_$(2)_H_$(3))\" \\\n \t    \"$$(LD_LIBRARY_PATH_ENV_TARGETDIR$(1)_T_$(2)_H_$(3))\" \\\n-\t    $(1)\n+\t    $(1) \\\n+\t    $$(S)\n \t@touch $$@\n else\n # FIXME #11094 - The above rule doesn't work right for multiple targets"}, {"sha": "ad78e13ca259b0ca0dbd9b414423f0f3008418fe", "filename": "src/etc/htmldocck.py", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -0,0 +1,351 @@\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+r\"\"\"\n+htmldocck.py is a custom checker script for Rustdoc HTML outputs.\n+\n+# How and why?\n+\n+The principle is simple: This script receives a path to generated HTML\n+documentation and a \"template\" script, which has a series of check\n+commands like `@has` or `@matches`. Each command can be used to check if\n+some pattern is present or not present in the particular file or in\n+the particular node of HTML tree. In many cases, the template script\n+happens to be a source code given to rustdoc.\n+\n+While it indeed is possible to test in smaller portions, it has been\n+hard to construct tests in this fashion and major rendering errors were\n+discovered much later. This script is designed for making the black-box\n+and regression testing of Rustdoc easy. This does not preclude the needs\n+for unit testing, but can be used to complement related tests by quickly\n+showing the expected renderings.\n+\n+In order to avoid one-off dependencies for this task, this script uses\n+a reasonably working HTML parser and the existing XPath implementation\n+from Python 2's standard library. Hopefully we won't render\n+non-well-formed HTML.\n+\n+# Commands\n+\n+Commands start with an `@` followed by a command name (letters and\n+hyphens), and zero or more arguments separated by one or more whitespace\n+and optionally delimited with single or double quotes. The `@` mark\n+cannot be preceded by a non-whitespace character. Other lines (including\n+every text up to the first `@`) are ignored, but it is recommended to\n+avoid the use of `@` in the template file.\n+\n+There are a number of supported commands:\n+\n+* `@has PATH` checks for the existence of given file.\n+\n+  `PATH` is relative to the output directory. It can be given as `-`\n+  which repeats the most recently used `PATH`.\n+\n+* `@has PATH PATTERN` and `@matches PATH PATTERN` checks for\n+  the occurrence of given `PATTERN` in the given file. Only one\n+  occurrence of given pattern is enough.\n+\n+  For `@has`, `PATTERN` is a whitespace-normalized (every consecutive\n+  whitespace being replaced by one single space character) string.\n+  The entire file is also whitespace-normalized including newlines.\n+\n+  For `@matches`, `PATTERN` is a Python-supported regular expression.\n+  The file remains intact but the regexp is matched with no `MULTILINE`\n+  and `IGNORECASE` option. You can still use a prefix `(?m)` or `(?i)`\n+  to override them, and `\\A` and `\\Z` for definitely matching\n+  the beginning and end of the file.\n+\n+  (The same distinction goes to other variants of these commands.)\n+\n+* `@has PATH XPATH PATTERN` and `@matches PATH XPATH PATTERN` checks for\n+  the presence of given `XPATH` in the given HTML file, and also\n+  the occurrence of given `PATTERN` in the matching node or attribute.\n+  Only one occurrence of given pattern in the match is enough.\n+\n+  `PATH` should be a valid and well-formed HTML file. It does *not*\n+  accept arbitrary HTML5; it should have matching open and close tags\n+  and correct entity references at least.\n+\n+  `XPATH` is an XPath expression to match. This is fairly limited:\n+  `tag`, `*`, `.`, `//`, `..`, `[@attr]`, `[@attr='value']`, `[tag]`,\n+  `[POS]` (element located in given `POS`), `[last()-POS]`, `text()`\n+  and `@attr` (both as the last segment) are supported. Some examples:\n+\n+  - `//pre` or `.//pre` matches any element with a name `pre`.\n+  - `//a[@href]` matches any element with an `href` attribute.\n+  - `//*[@class=\"impl\"]//code` matches any element with a name `code`,\n+    which is an ancestor of some element which `class` attr is `impl`.\n+  - `//h1[@class=\"fqn\"]/span[1]/a[last()]/@class` matches a value of\n+    `class` attribute in the last `a` element (can be followed by more\n+    elements that are not `a`) inside the first `span` in the `h1` with\n+    a class of `fqn`. Note that there cannot be no additional elements\n+    between them due to the use of `/` instead of `//`.\n+\n+  Do not try to use non-absolute paths, it won't work due to the flawed\n+  ElementTree implementation. The script rejects them.\n+\n+  For the text matches (i.e. paths not ending with `@attr`), any\n+  subelements are flattened into one string; this is handy for ignoring\n+  highlights for example. If you want to simply check the presence of\n+  given node or attribute, use an empty string (`\"\"`) as a `PATTERN`.\n+\n+All conditions can be negated with `!`. `@!has foo/type.NoSuch.html`\n+checks if the given file does not exist, for example.\n+\n+\"\"\"\n+\n+import sys\n+import os.path\n+import re\n+import shlex\n+from collections import namedtuple\n+from HTMLParser import HTMLParser\n+from xml.etree import cElementTree as ET\n+\n+# &larrb;/&rarrb; are not in HTML 4 but are in HTML 5\n+from htmlentitydefs import entitydefs\n+entitydefs['larrb'] = u'\\u21e4'\n+entitydefs['rarrb'] = u'\\u21e5'\n+\n+# \"void elements\" (no closing tag) from the HTML Standard section 12.1.2\n+VOID_ELEMENTS = set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',\n+                     'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'])\n+\n+# simplified HTML parser.\n+# this is possible because we are dealing with very regular HTML from rustdoc;\n+# we only have to deal with i) void elements and ii) empty attributes.\n+class CustomHTMLParser(HTMLParser):\n+    def __init__(self, target=None):\n+        HTMLParser.__init__(self)\n+        self.__builder = target or ET.TreeBuilder()\n+    def handle_starttag(self, tag, attrs):\n+        attrs = dict((k, v or '') for k, v in attrs)\n+        self.__builder.start(tag, attrs)\n+        if tag in VOID_ELEMENTS: self.__builder.end(tag)\n+    def handle_endtag(self, tag):\n+        self.__builder.end(tag)\n+    def handle_startendtag(self, tag, attrs):\n+        attrs = dict((k, v or '') for k, v in attrs)\n+        self.__builder.start(tag, attrs)\n+        self.__builder.end(tag)\n+    def handle_data(self, data):\n+        self.__builder.data(data)\n+    def handle_entityref(self, name):\n+        self.__builder.data(entitydefs[name])\n+    def handle_charref(self, name):\n+        code = int(name[1:], 16) if name.startswith(('x', 'X')) else int(name, 10)\n+        self.__builder.data(unichr(code).encode('utf-8'))\n+    def close(self):\n+        HTMLParser.close(self)\n+        return self.__builder.close()\n+\n+Command = namedtuple('Command', 'negated cmd args lineno')\n+\n+# returns a generator out of the file object, which\n+# - removes `\\\\` then `\\n` then a shared prefix with the previous line then optional whitespace;\n+# - keeps a line number (starting from 0) of the first line being concatenated.\n+def concat_multi_lines(f):\n+    lastline = None # set to the last line when the last line has a backslash\n+    firstlineno = None\n+    catenated = ''\n+    for lineno, line in enumerate(f):\n+        line = line.rstrip('\\r\\n')\n+\n+        # strip the common prefix from the current line if needed\n+        if lastline is not None:\n+            maxprefix = 0\n+            for i in xrange(min(len(line), len(lastline))):\n+                if line[i] != lastline[i]: break\n+                maxprefix += 1\n+            line = line[maxprefix:].lstrip()\n+\n+        firstlineno = firstlineno or lineno\n+        if line.endswith('\\\\'):\n+            lastline = line[:-1]\n+            catenated += line[:-1]\n+        else:\n+            yield firstlineno, catenated + line\n+            lastline = None\n+            firstlineno = None\n+            catenated = ''\n+\n+    if lastline is not None:\n+        raise RuntimeError('Trailing backslash in the end of file')\n+\n+LINE_PATTERN = re.compile(r'''\n+    (?<=(?<!\\S)@)(?P<negated>!?)\n+    (?P<cmd>[A-Za-z]+(?:-[A-Za-z]+)*)\n+    (?P<args>.*)$\n+''', re.X)\n+def get_commands(template):\n+    with open(template, 'rUb') as f:\n+        for lineno, line in concat_multi_lines(f):\n+            m = LINE_PATTERN.search(line)\n+            if not m: continue\n+\n+            negated = (m.group('negated') == '!')\n+            cmd = m.group('cmd')\n+            args = m.group('args')\n+            if args and not args[:1].isspace():\n+                raise RuntimeError('Invalid template syntax at line {}'.format(lineno+1))\n+            args = shlex.split(args)\n+            yield Command(negated=negated, cmd=cmd, args=args, lineno=lineno+1)\n+\n+def _flatten(node, acc):\n+    if node.text: acc.append(node.text)\n+    for e in node:\n+        _flatten(e, acc)\n+        if e.tail: acc.append(e.tail)\n+\n+def flatten(node):\n+    acc = []\n+    _flatten(node, acc)\n+    return ''.join(acc)\n+\n+def normalize_xpath(path):\n+    if path.startswith('//'):\n+        return '.' + path # avoid warnings\n+    elif path.startswith('.//'):\n+        return path\n+    else:\n+        raise RuntimeError('Non-absolute XPath is not supported due to \\\n+                            the implementation issue.')\n+\n+class CachedFiles(object):\n+    def __init__(self, root):\n+        self.root = root\n+        self.files = {}\n+        self.trees = {}\n+        self.last_path = None\n+\n+    def resolve_path(self, path):\n+        if path != '-':\n+            path = os.path.normpath(path)\n+            self.last_path = path\n+            return path\n+        elif self.last_path is None:\n+            raise RuntimeError('Tried to use the previous path in the first command')\n+        else:\n+            return self.last_path\n+\n+    def get_file(self, path):\n+        path = self.resolve_path(path)\n+        try:\n+            return self.files[path]\n+        except KeyError:\n+            try:\n+                with open(os.path.join(self.root, path)) as f:\n+                    data = f.read()\n+            except Exception as e:\n+                raise RuntimeError('Cannot open file {!r}: {}'.format(path, e))\n+            else:\n+                self.files[path] = data\n+                return data\n+\n+    def get_tree(self, path):\n+        path = self.resolve_path(path)\n+        try:\n+            return self.trees[path]\n+        except KeyError:\n+            try:\n+                f = open(os.path.join(self.root, path))\n+            except Exception as e:\n+                raise RuntimeError('Cannot open file {!r}: {}'.format(path, e))\n+            try:\n+                with f:\n+                    tree = ET.parse(f, CustomHTMLParser())\n+            except Exception as e:\n+                raise RuntimeError('Cannot parse an HTML file {!r}: {}'.format(path, e))\n+            else:\n+                self.trees[path] = tree\n+                return self.trees[path]\n+\n+def check_string(data, pat, regexp):\n+    if not pat:\n+        return True # special case a presence testing\n+    elif regexp:\n+        return re.search(pat, data) is not None\n+    else:\n+        data = ' '.join(data.split())\n+        pat = ' '.join(pat.split())\n+        return pat in data\n+\n+def check_tree_attr(tree, path, attr, pat, regexp):\n+    path = normalize_xpath(path)\n+    ret = False\n+    for e in tree.findall(path):\n+        try:\n+            value = e.attrib[attr]\n+        except KeyError:\n+            continue\n+        else:\n+            ret = check_string(value, pat, regexp)\n+            if ret: break\n+    return ret\n+\n+def check_tree_text(tree, path, pat, regexp):\n+    path = normalize_xpath(path)\n+    ret = False\n+    for e in tree.findall(path):\n+        try:\n+            value = flatten(e)\n+        except KeyError:\n+            continue\n+        else:\n+            ret = check_string(value, pat, regexp)\n+            if ret: break\n+    return ret\n+\n+def check(target, commands):\n+    cache = CachedFiles(target)\n+    for c in commands:\n+        if c.cmd == 'has' or c.cmd == 'matches': # string test\n+            regexp = (c.cmd == 'matches')\n+            if len(c.args) == 1 and not regexp: # @has <path> = file existence\n+                try:\n+                    cache.get_file(c.args[0])\n+                    ret = True\n+                except RuntimeError:\n+                    ret = False\n+            elif len(c.args) == 2: # @has/matches <path> <pat> = string test\n+                ret = check_string(cache.get_file(c.args[0]), c.args[1], regexp)\n+            elif len(c.args) == 3: # @has/matches <path> <pat> <match> = XML tree test\n+                tree = cache.get_tree(c.args[0])\n+                pat, sep, attr = c.args[1].partition('/@')\n+                if sep: # attribute\n+                    ret = check_tree_attr(cache.get_tree(c.args[0]), pat, attr, c.args[2], regexp)\n+                else: # normalized text\n+                    pat = c.args[1]\n+                    if pat.endswith('/text()'): pat = pat[:-7]\n+                    ret = check_tree_text(cache.get_tree(c.args[0]), pat, c.args[2], regexp)\n+            else:\n+                raise RuntimeError('Invalid number of @{} arguments \\\n+                                    at line {}'.format(c.cmd, c.lineno))\n+\n+        elif c.cmd == 'valid-html':\n+            raise RuntimeError('Unimplemented @valid-html at line {}'.format(c.lineno))\n+\n+        elif c.cmd == 'valid-links':\n+            raise RuntimeError('Unimplemented @valid-links at line {}'.format(c.lineno))\n+\n+        else:\n+            raise RuntimeError('Unrecognized @{} at line {}'.format(c.cmd, c.lineno))\n+\n+        if ret == c.negated:\n+            raise RuntimeError('@{}{} check failed at line {}'.format('!' if c.negated else '',\n+                                                                      c.cmd, c.lineno))\n+\n+if __name__ == '__main__':\n+    if len(sys.argv) < 3:\n+        print >>sys.stderr, 'Usage: {} <doc dir> <template>'.format(sys.argv[0])\n+        raise SystemExit(1)\n+    else:\n+        check(sys.argv[1], get_commands(sys.argv[2]))\n+"}, {"sha": "3f29c0b2f12ff1a83c43108802216f97f4fb790e", "filename": "src/etc/maketest.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Fetc%2Fmaketest.py", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Fetc%2Fmaketest.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmaketest.py?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -46,6 +46,8 @@ def convert_path_spec(name, value):\n putenv('HOST_RPATH_DIR', os.path.abspath(sys.argv[9]));\n putenv('TARGET_RPATH_DIR', os.path.abspath(sys.argv[10]));\n putenv('RUST_BUILD_STAGE', sys.argv[11])\n+putenv('S', os.path.abspath(sys.argv[12]))\n+putenv('PYTHON', sys.executable)\n \n if not filt in sys.argv[1]:\n     sys.exit(0)"}, {"sha": "3ac7b6d2fae0ef96dbdc611886da4b90eb57d50e", "filename": "src/test/run-make/rustdoc-hidden-line/Makefile", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2FMakefile?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -7,8 +7,7 @@ all:\n \t@echo $(RUSTDOC)\n \t$(HOST_RPATH_ENV) $(RUSTDOC) --test foo.rs\n \t$(HOST_RPATH_ENV) $(RUSTDOC) -w html -o $(TMPDIR)/doc foo.rs\n-\tcp verify.sh $(TMPDIR)\n-\t$(call RUN,verify.sh) $(TMPDIR)\n+\t$(HTMLDOCCK) $(TMPDIR)/doc foo.rs\n \n else\n all:"}, {"sha": "c538a132fb1bcc2e5ff379f8d8346f8abf0a8334", "filename": "src/test/run-make/rustdoc-hidden-line/foo.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -30,3 +30,7 @@\n /// }\n /// ```\n pub fn foo() {}\n+\n+// @!has foo/fn.foo.html invisible\n+// @matches - //pre '#.*\\[.*derive.*\\(.*Eq.*\\).*\\].*//.*Bar'\n+"}, {"sha": "9f28b55b13396b4d794dea30091dd4f77a1dc275", "filename": "src/test/run-make/rustdoc-hidden-line/verify.sh", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9006c3c0f14be45da8ffeba43d354d088e366c83/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Fverify.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9006c3c0f14be45da8ffeba43d354d088e366c83/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Fverify.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Fverify.sh?ref=9006c3c0f14be45da8ffeba43d354d088e366c83", "patch": "@@ -1,8 +0,0 @@\n-#!/bin/sh\n-\n-file=\"$1/doc/foo/fn.foo.html\"\n-\n-grep -v 'invisible' $file &&\n-grep '#.*\\[.*derive.*(.*Eq.*).*\\].*//.*Bar' $file\n-\n-exit $?"}, {"sha": "e7e8f0c35a7e5662d68e38872469289095e51695", "filename": "src/test/run-make/rustdoc-search-index/Makefile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-search-index%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-search-index%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-search-index%2FMakefile?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -7,9 +7,7 @@ source=index.rs\n \n all:\n \t$(HOST_RPATH_ENV) $(RUSTDOC) -w html -o $(TMPDIR)/doc $(source)\n-\tcp $(source) $(TMPDIR)\n-\tcp verify.sh $(TMPDIR)\n-\t$(call RUN,verify.sh) $(TMPDIR)\n+\t$(HTMLDOCCK) $(TMPDIR)/doc $(source)\n \n else\n all:"}, {"sha": "dd68f2d6f1dee4c512c26d5c103e13511e1f5b88", "filename": "src/test/run-make/rustdoc-search-index/index.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-search-index%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-search-index%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-search-index%2Findex.rs?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -10,20 +10,17 @@\n \n #![crate_name = \"rustdoc_test\"]\n \n-// In: Foo\n+// @has search-index.js Foo\n pub use private::Foo;\n \n mod private {\n     pub struct Foo;\n     impl Foo {\n-        // In: test_method\n-        pub fn test_method() {}\n-        // Out: priv_method\n-        fn priv_method() {}\n+        pub fn test_method() {} // @has - test_method\n+        fn priv_method() {} // @!has - priv_method\n     }\n \n     pub trait PrivateTrait {\n-        // Out: priv_method\n-        fn trait_method() {}\n+        fn trait_method() {} // @!has - priv_method\n     }\n }"}, {"sha": "af5033adf6bcd6fc8feffa91fa0afcd6630540e8", "filename": "src/test/run-make/rustdoc-search-index/verify.sh", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9006c3c0f14be45da8ffeba43d354d088e366c83/src%2Ftest%2Frun-make%2Frustdoc-search-index%2Fverify.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9006c3c0f14be45da8ffeba43d354d088e366c83/src%2Ftest%2Frun-make%2Frustdoc-search-index%2Fverify.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-search-index%2Fverify.sh?ref=9006c3c0f14be45da8ffeba43d354d088e366c83", "patch": "@@ -1,33 +0,0 @@\n-#!/bin/sh\n-\n-source=\"$1/index.rs\"\n-index=\"$1/doc/search-index.js\"\n-\n-if ! [ -e $index ]\n-then\n-    echo \"Could not find the search index (looked for $index)\"\n-    exit 1\n-fi\n-\n-ins=$(grep -o 'In: .*' $source | sed 's/In: \\(.*\\)/\\1/g')\n-outs=$(grep -o 'Out: .*' $source | sed 's/Out: \\(.*\\)/\\1/g')\n-\n-for p in $ins\n-do\n-    if ! grep -q $p $index\n-    then\n-        echo \"'$p' was erroneously excluded from search index.\"\n-        exit 1\n-    fi\n-done\n-\n-for p in $outs\n-do\n-    if grep -q $p $index\n-    then\n-        echo \"'$p' was erroneously included in search index.\"\n-        exit 1\n-    fi\n-done\n-\n-exit 0"}, {"sha": "7a1ad761b3d6aa9922d6ffc20ce19ef0ec4a3496", "filename": "src/test/run-make/rustdoc-smoke/Makefile", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-smoke%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-smoke%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-smoke%2FMakefile?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -1,5 +1,4 @@\n -include ../tools.mk\n all:\n \t$(HOST_RPATH_ENV) $(RUSTDOC) -w html -o $(TMPDIR)/doc foo.rs\n-\tcp verify.sh $(TMPDIR)\n-\t$(call RUN,verify.sh) $(TMPDIR)\n+\t$(HTMLDOCCK) $(TMPDIR)/doc foo.rs"}, {"sha": "0438c9aba3599f8238586fa75078f08759c15ede", "filename": "src/test/run-make/rustdoc-smoke/foo.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -8,22 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// @has foo/index.html\n #![crate_name = \"foo\"]\n \n //! Very docs\n \n+// @has foo/bar/index.html\n pub mod bar {\n \n     /// So correct\n+    // @has foo/bar/baz/index.html\n     pub mod baz {\n         /// Much detail\n+        // @has foo/bar/baz/fn.baz.html\n         pub fn baz() { }\n     }\n \n     /// *wow*\n+    // @has foo/bar/trait.Doge.html\n     pub trait Doge { }\n \n+    // @has foo/bar/struct.Foo.html\n     pub struct Foo { x: int, y: uint }\n \n+    // @has foo/bar/fn.prawns.html\n     pub fn prawns((a, b): (int, uint), Foo { x, y }: Foo) { }\n }"}, {"sha": "18f3939794e47d5ed1b2a6f00d5248510e4fb71e", "filename": "src/test/run-make/rustdoc-smoke/verify.sh", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9006c3c0f14be45da8ffeba43d354d088e366c83/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Fverify.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9006c3c0f14be45da8ffeba43d354d088e366c83/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Fverify.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Fverify.sh?ref=9006c3c0f14be45da8ffeba43d354d088e366c83", "patch": "@@ -1,17 +0,0 @@\n-#!/bin/sh\n-\n-# $1 is the TMPDIR\n-\n-dirs=\"doc doc/foo doc/foo/bar doc/foo/bar/baz doc/src doc/src/foo\"\n-\n-for dir in $dirs; do if [ ! -d $1/$dir ]; then\n-\techo \"$1/$dir is not a directory!\"\n-\texit 1\n-fi done\n-\n-files=\"doc/foo/index.html doc/foo/bar/index.html doc/foo/bar/baz/fn.baz.html doc/foo/bar/trait.Doge.html doc/src/foo/foo.rs.html\"\n-\n-for file in $files; do if [ ! -f $1/$file ]; then\n-\techo \"$1/$file is not a file!\"\n-\texit 1\n-fi done"}, {"sha": "1316ee256e147d8e5eedbd72572910dc58b88e00", "filename": "src/test/run-make/rustdoc-where/Makefile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-where%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-where%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-where%2FMakefile?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -1,6 +1,6 @@\n -include ../tools.mk\n \n-all: verify.sh foo.rs\n+all: foo.rs\n \t$(HOST_RPATH_ENV) $(RUSTDOC) -w html -o $(TMPDIR)/doc foo.rs\n-\tcp verify.sh $(TMPDIR)\n-\t$(call RUN,verify.sh) $(TMPDIR)\n+\t$(HTMLDOCCK) $(TMPDIR)/doc foo.rs\n+"}, {"sha": "9f38ff138051c81a39da2a24e25158e087d196e4", "filename": "src/test/run-make/rustdoc-where/foo.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-where%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Frustdoc-where%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-where%2Ffoo.rs?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -10,17 +10,29 @@\n \n pub trait MyTrait {}\n \n+// @matches foo/struct.Alpha.html '//pre' \"Alpha.*where.*A:.*MyTrait\"\n pub struct Alpha<A> where A: MyTrait;\n+// @matches foo/trait.Bravo.html '//pre' \"Bravo.*where.*B:.*MyTrait\"\n pub trait Bravo<B> where B: MyTrait {}\n+// @matches foo/fn.charlie.html '//pre' \"charlie.*where.*C:.*MyTrait\"\n pub fn charlie<C>() where C: MyTrait {}\n \n pub struct Delta<D>;\n+// @matches foo/struct.Delta.html '//*[@class=\"impl\"]//code' \"impl.*Delta.*where.*D:.*MyTrait\"\n impl<D> Delta<D> where D: MyTrait {\n     pub fn delta() {}\n }\n \n pub struct Echo<E>;\n+// @matches foo/struct.Echo.html '//*[@class=\"impl\"]//code' \\\n+//          \"impl.*MyTrait.*for.*Echo.*where.*E:.*MyTrait\"\n+// @matches foo/trait.MyTrait.html '//*[@id=\"implementors-list\"]//code' \\\n+//          \"impl.*MyTrait.*for.*Echo.*where.*E:.*MyTrait\"\n impl<E> MyTrait for Echo<E> where E: MyTrait {}\n \n pub enum Foxtrot<F> {}\n+// @matches foo/enum.Foxtrot.html '//*[@class=\"impl\"]//code' \\\n+//          \"impl.*MyTrait.*for.*Foxtrot.*where.*F:.*MyTrait\"\n+// @matches foo/trait.MyTrait.html '//*[@id=\"implementors-list\"]//code' \\\n+//          \"impl.*MyTrait.*for.*Foxtrot.*where.*F:.*MyTrait\"\n impl<F> MyTrait for Foxtrot<F> where F: MyTrait {}"}, {"sha": "1d49823101855b150c31c83fcde616243a09ad47", "filename": "src/test/run-make/rustdoc-where/verify.sh", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9006c3c0f14be45da8ffeba43d354d088e366c83/src%2Ftest%2Frun-make%2Frustdoc-where%2Fverify.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9006c3c0f14be45da8ffeba43d354d088e366c83/src%2Ftest%2Frun-make%2Frustdoc-where%2Fverify.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-where%2Fverify.sh?ref=9006c3c0f14be45da8ffeba43d354d088e366c83", "patch": "@@ -1,23 +0,0 @@\n-#!/bin/sh\n-set -e\n-\n-# $1 is the TMPDIR\n-DOC=$1/doc/foo\n-\n-grep \"Alpha.*where.*A:.*MyTrait\" $DOC/struct.Alpha.html > /dev/null\n-echo \"Alpha\"\n-grep \"Bravo.*where.*B:.*MyTrait\" $DOC/trait.Bravo.html > /dev/null\n-echo \"Bravo\"\n-grep \"charlie.*where.*C:.*MyTrait\" $DOC/fn.charlie.html > /dev/null\n-echo \"Charlie\"\n-grep \"impl.*Delta.*where.*D:.*MyTrait\" $DOC/struct.Delta.html > /dev/null\n-echo \"Delta\"\n-grep \"impl.*MyTrait.*for.*Echo.*where.*E:.*MyTrait\" $DOC/struct.Echo.html > /dev/null\n-echo \"Echo\"\n-grep \"impl.*MyTrait.*for.*Foxtrot.*where.*F:.*MyTrait\" $DOC/enum.Foxtrot.html > /dev/null\n-echo \"Foxtrot\"\n-\n-# check \"Implementors\" section of MyTrait\n-grep \"impl.*MyTrait.*for.*Echo.*where.*E:.*MyTrait\" $DOC/trait.MyTrait.html > /dev/null\n-grep \"impl.*MyTrait.*for.*Foxtrot.*where.*F:.*MyTrait\" $DOC/trait.MyTrait.html > /dev/null\n-echo \"Implementors OK\""}, {"sha": "971295405aae2d646075ca2034649928f711a1f3", "filename": "src/test/run-make/tools.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3bf41dafcfb6c979efb4e2438e047e1a54045eec/src%2Ftest%2Frun-make%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftools.mk?ref=3bf41dafcfb6c979efb4e2438e047e1a54045eec", "patch": "@@ -7,6 +7,7 @@ TARGET_RPATH_ENV = \\\n \n RUSTC := $(HOST_RPATH_ENV) $(RUSTC) --out-dir $(TMPDIR) -L $(TMPDIR)\n CC := $(CC) -L $(TMPDIR)\n+HTMLDOCCK := $(PYTHON) $(S)/src/etc/htmldocck.py\n \n # This is the name of the binary we will generate and run; use this\n # e.g. for `$(CC) -o $(RUN_BINFILE)`."}]}