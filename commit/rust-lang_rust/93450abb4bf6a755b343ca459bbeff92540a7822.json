{"sha": "93450abb4bf6a755b343ca459bbeff92540a7822", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNDUwYWJiNGJmNmE3NTViMzQzY2E0NTliYmVmZjkyNTQwYTc4MjI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-02-08T02:55:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-02-08T03:57:03Z"}, "message": "Make process-spawning take environments and working directories, remove procsrv task from compiletest.", "tree": {"sha": "ee49c759c04ab7efb83025b9ed6b04878711ea39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee49c759c04ab7efb83025b9ed6b04878711ea39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93450abb4bf6a755b343ca459bbeff92540a7822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93450abb4bf6a755b343ca459bbeff92540a7822", "html_url": "https://github.com/rust-lang/rust/commit/93450abb4bf6a755b343ca459bbeff92540a7822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93450abb4bf6a755b343ca459bbeff92540a7822/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5131216fa6826509bb31672e5fde15b18eeff5d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5131216fa6826509bb31672e5fde15b18eeff5d7", "html_url": "https://github.com/rust-lang/rust/commit/5131216fa6826509bb31672e5fde15b18eeff5d7"}], "stats": {"total": 614, "additions": 328, "deletions": 286}, "files": [{"sha": "7f2c46bef483ff061f6b51f820be967c765b7629", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -28,5 +28,3 @@ type config =\n      runtool: option<str>,\n      rustcflags: option<str>,\n      verbose: bool};\n-\n-type cx = {config: config, procsrv: procsrv::handle};"}, {"sha": "4fc510e9c62f053bf8935ad48554520bb1ff3763", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -17,7 +17,6 @@ import comm::chan;\n import comm::send;\n import comm::recv;\n \n-import common::cx;\n import common::config;\n import common::mode_run_pass;\n import common::mode_run_fail;\n@@ -113,10 +112,8 @@ fn mode_str(mode: mode) -> str {\n \n fn run_tests(config: config) {\n     let opts = test_opts(config);\n-    let cx = {config: config, procsrv: procsrv::mk()};\n-    let tests = make_tests(cx);\n+    let tests = make_tests(config);\n     let res = test::run_tests_console(opts, tests);\n-    procsrv::close(cx.procsrv);\n     if !res { fail \"Some tests failed\"; }\n }\n \n@@ -129,14 +126,14 @@ fn test_opts(config: config) -> test::test_opts {\n      run_ignored: config.run_ignored}\n }\n \n-fn make_tests(cx: cx) -> [test::test_desc] {\n-    #debug(\"making tests from %s\", cx.config.src_base);\n+fn make_tests(config: config) -> [test::test_desc] {\n+    #debug(\"making tests from %s\", config.src_base);\n     let tests = [];\n-    for file: str in fs::list_dir(cx.config.src_base) {\n+    for file: str in fs::list_dir(config.src_base) {\n         let file = file;\n         #debug(\"inspecting file %s\", file);\n-        if is_test(cx.config, file) {\n-            tests += [make_test(cx, file)]\n+        if is_test(config, file) {\n+            tests += [make_test(config, file)]\n         }\n     }\n     ret tests;\n@@ -162,12 +159,12 @@ fn is_test(config: config, testfile: str) -> bool {\n     ret valid;\n }\n \n-fn make_test(cx: cx, testfile: str) ->\n+fn make_test(config: config, testfile: str) ->\n    test::test_desc {\n     {\n-        name: make_test_name(cx.config, testfile),\n-        fn: make_test_closure(cx, testfile),\n-        ignore: header::is_test_ignored(cx.config, testfile),\n+        name: make_test_name(config, testfile),\n+        fn: make_test_closure(config, testfile),\n+        ignore: header::is_test_ignored(config, testfile),\n         should_fail: false\n     }\n }\n@@ -176,24 +173,12 @@ fn make_test_name(config: config, testfile: str) -> str {\n     #fmt[\"[%s] %s\", mode_str(config.mode), testfile]\n }\n \n-fn make_test_closure(cx: cx, testfile: str) -> test::test_fn {\n-    let config = cx.config;\n-    let chan = cx.procsrv.chan;\n+fn make_test_closure(config: config, testfile: str) -> test::test_fn {\n     ret {||\n-        run_test_task(config, chan, testfile);\n+        runtest::run(config, copy testfile);\n     };\n }\n \n-fn run_test_task(config: common::config,\n-                 procsrv_chan: procsrv::reqchan,\n-                 testfile: str) {\n-\n-    let procsrv = procsrv::from_chan(procsrv_chan);\n-    let cx = {config: config, procsrv: procsrv};\n-\n-    runtest::run(cx, copy testfile);\n-}\n-\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "892ed15fb331102f38e9735c20f11aca4071eb49", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 41, "deletions": 155, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -1,71 +1,60 @@\n-// So when running tests in parallel there's a potential race on environment\n-// variables if we let each task spawn its own children - between the time the\n-// environment is set and the process is spawned another task could spawn its\n-// child process. Because of that we have to use a complicated scheme with a\n-// dedicated server for spawning processes.\n-\n-import std::generic_os::setenv;\n-import std::generic_os::getenv;\n-import std::os;\n import std::run;\n+import std::run::spawn_process;\n import std::io;\n+import std::os;\n import io::writer_util;\n-import comm::chan;\n-import comm::port;\n-import comm::send;\n-import comm::recv;\n import ctypes::{pid_t, fd_t};\n \n-export handle;\n-export mk;\n-export from_chan;\n export run;\n-export close;\n-export reqchan;\n \n-type reqchan = chan<request>;\n-\n-type handle =\n-    {task: option<(task::task, port<task::task_notification>)>,\n-     chan: reqchan};\n-\n-enum request { exec([u8], [u8], [[u8]], chan<response>), stop, }\n+#[cfg(target_os = \"win32\")]\n+fn target_env(lib_path: str, prog: str) -> option<[(str,str)]> {\n \n-type response = {pid: pid_t, infd: fd_t,\n-                 outfd: fd_t, errfd: fd_t};\n+    let env = std::generic_os::env();\n \n-fn mk() -> handle {\n-    let setupport = port();\n-    let setupchan = chan(setupport);\n-    let task = task::spawn_joinable {||\n-        let reqport = port();\n-        let reqchan = chan(reqport);\n-        send(setupchan, reqchan);\n-        worker(reqport);\n+    env = vec::map(env) {|pair|\n+        let (k,v) = pair;\n+        if k == \"PATH\" { (\"PATH\", v + \";\" + lib_path) }\n+        else { (k,v) }\n     };\n-    ret {task: option::some(task), chan: recv(setupport)};\n+    if str::ends_with(prog, \"rustc.exe\") {\n+        env += [(\"RUST_THREADS\", \"1\")]\n+    }\n+    ret some(env);\n }\n \n-fn from_chan(ch: reqchan) -> handle { {task: option::none, chan: ch} }\n-\n-fn close(handle: handle) {\n-    send(handle.chan, stop);\n-    task::join(option::get(handle.task));\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+fn target_env(lib_path: str, prog: str) -> option<[(str,str)]> {\n+    none\n }\n \n-fn run(handle: handle, lib_path: str, prog: str, args: [str],\n+\n+fn run(lib_path: str, prog: str, args: [str],\n        input: option<str>) -> {status: int, out: str, err: str} {\n-    let p = port();\n-    let ch = chan(p);\n-    send(handle.chan,\n-         exec(str::bytes(lib_path), str::bytes(prog), clone_vecstr(args),\n-              ch));\n-    let resp = recv(p);\n \n-    writeclose(resp.infd, input);\n-    let output = readclose(resp.outfd);\n-    let errput = readclose(resp.errfd);\n-    let status = run::waitpid(resp.pid);\n+    let pipe_in = os::pipe();\n+    let pipe_out = os::pipe();\n+    let pipe_err = os::pipe();\n+    let pid = spawn_process(prog, args, target_env(lib_path, prog), none,\n+                            pipe_in.in, pipe_out.out, pipe_err.out);\n+\n+    os::close(pipe_in.in);\n+    os::close(pipe_out.out);\n+    os::close(pipe_err.out);\n+    if pid == -1i32 {\n+        os::close(pipe_in.out);\n+        os::close(pipe_out.in);\n+        os::close(pipe_err.in);\n+        fail;\n+    }\n+\n+\n+    writeclose(pipe_in.out, input);\n+    let output = readclose(pipe_out.in);\n+    let errput = readclose(pipe_err.in);\n+    let status = run::waitpid(pid);\n     ret {status: status, out: output, err: errput};\n }\n \n@@ -90,106 +79,3 @@ fn readclose(fd: fd_t) -> str {\n     os::fclose(file);\n     ret buf;\n }\n-\n-fn worker(p: port<request>) {\n-\n-    // FIXME (787): If we declare this inside of the while loop and then\n-    // break out of it before it's ever initialized (i.e. we don't run\n-    // any tests), then the cleanups will puke.\n-    let execparms;\n-\n-    while true {\n-        // FIXME: Sending strings across channels seems to still\n-        // leave them refed on the sender's end, which causes problems if\n-        // the receiver's poniters outlive the sender's. Here we clone\n-        // everything and let the originals go out of scope before sending\n-        // a response.\n-        execparms =\n-            {\n-\n-                // FIXME (785): The 'discriminant' of an alt expression has\n-                // the same scope as the alt expression itself, so we have to\n-                // put the entire alt in another block to make sure the exec\n-                // message goes out of scope. Seems like the scoping rules for\n-                // the alt discriminant are wrong.\n-                alt recv(p) {\n-                  exec(lib_path, prog, args, respchan) {\n-                    {lib_path: str::from_bytes(lib_path),\n-                     prog: str::from_bytes(prog),\n-                     args: clone_vecu8str(args),\n-                     respchan: respchan}\n-                  }\n-                  stop { ret }\n-                }\n-            };\n-\n-        // This is copied from run::start_program\n-        let pipe_in = os::pipe();\n-        let pipe_out = os::pipe();\n-        let pipe_err = os::pipe();\n-        let spawnproc =\n-            bind run::spawn_process(execparms.prog, execparms.args,\n-                                    pipe_in.in, pipe_out.out, pipe_err.out);\n-        let pid = maybe_with_lib_path(execparms.lib_path, spawnproc);\n-\n-        os::close(pipe_in.in);\n-        os::close(pipe_out.out);\n-        os::close(pipe_err.out);\n-        if pid == -1i32 {\n-            os::close(pipe_in.out);\n-            os::close(pipe_out.in);\n-            os::close(pipe_err.in);\n-            fail;\n-        }\n-\n-        send(execparms.respchan,\n-             {pid: pid,\n-              infd: pipe_in.out,\n-              outfd: pipe_out.in,\n-              errfd: pipe_err.in});\n-    }\n-}\n-\n-// Only windows needs to set the library path\n-#[cfg(target_os = \"win32\")]\n-fn maybe_with_lib_path<T>(path: str, f: fn@() -> T) -> T {\n-    with_lib_path(path, f)\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-fn maybe_with_lib_path<T>(_path: str, f: fn@() -> T) -> T {\n-    f()\n-}\n-\n-fn with_lib_path<T>(path: str, f: fn@() -> T) -> T {\n-    let maybe_oldpath = getenv(util::lib_path_env_var());\n-    append_lib_path(path);\n-    let res = f();\n-    if option::is_some(maybe_oldpath) {\n-        export_lib_path(option::get(maybe_oldpath));\n-    } else {\n-        // FIXME: This should really be unset but we don't have that yet\n-        export_lib_path(\"\");\n-    }\n-    ret res;\n-}\n-\n-fn append_lib_path(path: str) { export_lib_path(util::make_new_path(path)); }\n-\n-fn export_lib_path(path: str) { setenv(util::lib_path_env_var(), path); }\n-\n-fn clone_vecstr(v: [str]) -> [[u8]] {\n-    let r = [];\n-    for t: str in vec::slice(v, 0u, vec::len(v)) { r += [str::bytes(t)]; }\n-    ret r;\n-}\n-\n-fn clone_vecu8str(v: [[u8]]) -> [str] {\n-    let r = [];\n-    for t in vec::slice(v, 0u, vec::len(v)) {\n-        r += [str::from_bytes(t)];\n-    }\n-    ret r;\n-}"}, {"sha": "68b821bc1c94f85c749dde61ac908fabf03a8945", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -7,31 +7,30 @@ import common::mode_run_pass;\n import common::mode_run_fail;\n import common::mode_compile_fail;\n import common::mode_pretty;\n-import common::cx;\n import common::config;\n import header::load_props;\n import header::test_props;\n import util::logv;\n \n export run;\n \n-fn run(cx: cx, testfile: str) {\n-    if cx.config.verbose {\n+fn run(config: config, testfile: str) {\n+    if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(\"\\n\\n\");\n     }\n     #debug(\"running %s\", testfile);\n     let props = load_props(testfile);\n-    alt cx.config.mode {\n-      mode_compile_fail { run_cfail_test(cx, props, testfile); }\n-      mode_run_fail { run_rfail_test(cx, props, testfile); }\n-      mode_run_pass { run_rpass_test(cx, props, testfile); }\n-      mode_pretty { run_pretty_test(cx, props, testfile); }\n+    alt config.mode {\n+      mode_compile_fail { run_cfail_test(config, props, testfile); }\n+      mode_run_fail { run_rfail_test(config, props, testfile); }\n+      mode_run_pass { run_rpass_test(config, props, testfile); }\n+      mode_pretty { run_pretty_test(config, props, testfile); }\n     }\n }\n \n-fn run_cfail_test(cx: cx, props: test_props, testfile: str) {\n-    let procres = compile_test(cx, props, testfile);\n+fn run_cfail_test(config: config, props: test_props, testfile: str) {\n+    let procres = compile_test(config, props, testfile);\n \n     if procres.status == 0 {\n         fatal_procres(\"compile-fail test compiled successfully!\", procres);\n@@ -50,12 +49,12 @@ fn run_cfail_test(cx: cx, props: test_props, testfile: str) {\n     }\n }\n \n-fn run_rfail_test(cx: cx, props: test_props, testfile: str) {\n-    let procres = compile_test(cx, props, testfile);\n+fn run_rfail_test(config: config, props: test_props, testfile: str) {\n+    let procres = compile_test(config, props, testfile);\n \n     if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n \n-    procres = exec_compiled_test(cx, props, testfile);\n+    procres = exec_compiled_test(config, props, testfile);\n \n     // The value our Makefile configures valgrind to return on failure\n     const valgrind_err: int = 100;\n@@ -78,21 +77,21 @@ fn check_correct_failure_status(procres: procres) {\n     }\n }\n \n-fn run_rpass_test(cx: cx, props: test_props, testfile: str) {\n-    let procres = compile_test(cx, props, testfile);\n+fn run_rpass_test(config: config, props: test_props, testfile: str) {\n+    let procres = compile_test(config, props, testfile);\n \n     if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n \n-    procres = exec_compiled_test(cx, props, testfile);\n+    procres = exec_compiled_test(config, props, testfile);\n \n \n     if procres.status != 0 { fatal_procres(\"test run failed!\", procres); }\n }\n \n-fn run_pretty_test(cx: cx, props: test_props, testfile: str) {\n+fn run_pretty_test(config: config, props: test_props, testfile: str) {\n     if option::is_some(props.pp_exact) {\n-        logv(cx.config, \"testing for exact pretty-printing\");\n-    } else { logv(cx.config, \"testing for converging pretty-printing\"); }\n+        logv(config, \"testing for exact pretty-printing\");\n+    } else { logv(config, \"testing for converging pretty-printing\"); }\n \n     let rounds =\n         alt props.pp_exact { option::some(_) { 1 } option::none { 2 } };\n@@ -101,8 +100,8 @@ fn run_pretty_test(cx: cx, props: test_props, testfile: str) {\n \n     let round = 0;\n     while round < rounds {\n-        logv(cx.config, #fmt[\"pretty-printing round %d\", round]);\n-        let procres = print_source(cx, testfile, srcs[round]);\n+        logv(config, #fmt[\"pretty-printing round %d\", round]);\n+        let procres = print_source(config, testfile, srcs[round]);\n \n         if procres.status != 0 {\n             fatal_procres(#fmt[\"pretty-printing failed in round %d\", round],\n@@ -134,17 +133,17 @@ fn run_pretty_test(cx: cx, props: test_props, testfile: str) {\n     compare_source(expected, actual);\n \n     // Finally, let's make sure it actually appears to remain valid code\n-    let procres = typecheck_source(cx, testfile, actual);\n+    let procres = typecheck_source(config, testfile, actual);\n \n     if procres.status != 0 {\n         fatal_procres(\"pretty-printed source does not typecheck\", procres);\n     }\n \n     ret;\n \n-    fn print_source(cx: cx, testfile: str, src: str) -> procres {\n-        compose_and_run(cx, testfile, make_pp_args,\n-                        cx.config.compile_lib_path, option::some(src))\n+    fn print_source(config: config, testfile: str, src: str) -> procres {\n+        compose_and_run(config, testfile, make_pp_args,\n+                        config.compile_lib_path, option::some(src))\n     }\n \n     fn make_pp_args(config: config, _testfile: str) -> procargs {\n@@ -173,9 +172,9 @@ actual:\\n\\\n         }\n     }\n \n-    fn typecheck_source(cx: cx, testfile: str, src: str) -> procres {\n-        compose_and_run(cx, testfile, make_typecheck_args,\n-                        cx.config.compile_lib_path, option::some(src))\n+    fn typecheck_source(config: config, testfile: str, src: str) -> procres {\n+        compose_and_run(config, testfile, make_typecheck_args,\n+                        config.compile_lib_path, option::some(src))\n     }\n \n     fn make_typecheck_args(config: config, _testfile: str) -> procargs {\n@@ -286,22 +285,24 @@ type procargs = {prog: str, args: [str]};\n \n type procres = {status: int, stdout: str, stderr: str, cmdline: str};\n \n-fn compile_test(cx: cx, props: test_props, testfile: str) -> procres {\n-    compose_and_run(cx, testfile, bind make_compile_args(_, props, _),\n-                    cx.config.compile_lib_path, option::none)\n+fn compile_test(config: config, props: test_props,\n+                testfile: str) -> procres {\n+    compose_and_run(config, testfile, bind make_compile_args(_, props, _),\n+                    config.compile_lib_path, option::none)\n }\n \n-fn exec_compiled_test(cx: cx, props: test_props, testfile: str) -> procres {\n-    compose_and_run(cx, testfile, bind make_run_args(_, props, _),\n-                    cx.config.run_lib_path, option::none)\n+fn exec_compiled_test(config: config, props: test_props,\n+                      testfile: str) -> procres {\n+    compose_and_run(config, testfile, bind make_run_args(_, props, _),\n+                    config.run_lib_path, option::none)\n }\n \n-fn compose_and_run(cx: cx, testfile: str,\n+fn compose_and_run(config: config, testfile: str,\n                    make_args: fn@(config, str) -> procargs, lib_path: str,\n                    input: option<str>) -> procres {\n-    let procargs = make_args(cx.config, testfile);\n-    ret program_output(cx, testfile, lib_path, procargs.prog, procargs.args,\n-                       input);\n+    let procargs = make_args(config, testfile);\n+    ret program_output(config, testfile, lib_path,\n+                       procargs.prog, procargs.args, input);\n }\n \n fn make_compile_args(config: config, props: test_props, testfile: str) ->\n@@ -354,16 +355,16 @@ fn split_maybe_args(argstr: option<str>) -> [str] {\n     }\n }\n \n-fn program_output(cx: cx, testfile: str, lib_path: str, prog: str,\n+fn program_output(config: config, testfile: str, lib_path: str, prog: str,\n                   args: [str], input: option<str>) -> procres {\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);\n-            logv(cx.config, #fmt[\"executing %s\", cmdline]);\n+            logv(config, #fmt[\"executing %s\", cmdline]);\n             cmdline\n         };\n-    let res = procsrv::run(cx.procsrv, lib_path, prog, args, input);\n-    dump_output(cx.config, testfile, res.out, res.err);\n+    let res = procsrv::run(lib_path, prog, args, input);\n+    dump_output(config, testfile, res.out, res.err);\n     ret {status: res.status,\n          stdout: res.out,\n          stderr: res.err,"}, {"sha": "7af87f77ecff7a72bdd7c91b8d2d91401410dae5", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -1298,15 +1298,6 @@ const tag_five_b: uint = 248u;\n const max_five_b: uint = 67108864u;\n const tag_six_b: uint = 252u;\n \n-// NB: This is intentionally unexported because it's easy to misuse (there's\n-// no guarantee that the string is rooted). Instead, use as_buf below.\n-unsafe fn buf(s: str) -> sbuf {\n-    let saddr = ptr::addr_of(s);\n-    let vaddr: *[u8] = ::unsafe::reinterpret_cast(saddr);\n-    let buf = vec::to_ptr(*vaddr);\n-    ret buf;\n-}\n-\n /*\n Function: as_buf\n \n@@ -1319,7 +1310,10 @@ Example:\n \n */\n fn as_buf<T>(s: str, f: fn(sbuf) -> T) -> T unsafe {\n-    let buf = buf(s); f(buf)\n+    let v: [u8] = ::unsafe::reinterpret_cast(s);\n+    let r = vec::as_buf(v, f);\n+    ::unsafe::leak(v);\n+    r\n }\n \n /*"}, {"sha": "28c93718e5b211e66faf680cdd4ac016a24fc1f7", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -1077,6 +1077,18 @@ FIXME: We don't need this wrapper\n */\n unsafe fn to_ptr<T>(v: [T]) -> *T { ret unsafe::to_ptr(v); }\n \n+/*\n+Function: as_buf\n+\n+Work with the buffer of a vector. Allows for unsafe manipulation\n+of vector contents, which is useful for native interop.\n+\n+*/\n+fn as_buf<E,T>(v: [const E], f: fn(*E) -> T) -> T unsafe {\n+    let buf = unsafe::to_ptr(v); f(buf)\n+}\n+\n+\n /*\n Module: unsafe\n */"}, {"sha": "d7ca27b550b0681e4ec62bf627039ca636456632", "filename": "src/libstd/freebsd_os.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Ffreebsd_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Ffreebsd_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffreebsd_os.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -20,6 +20,7 @@ export target_os;\n export dylib_filename;\n export get_exe_path;\n export fsync_fd;\n+export rustrt;\n \n // FIXME Somehow merge stuff duplicated here and macosx_os.rs. Made difficult\n // by https://github.com/graydon/rust/issues#issue/268\n@@ -116,6 +117,7 @@ fn waitpid(pid: pid_t) -> i32 {\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n+    fn rust_env_pairs() -> [str];\n     fn rust_getcwd() -> str;\n }\n "}, {"sha": "0f9f8a58410af3d204f4fdd597f1806fa2ca95d9", "filename": "src/libstd/generic_os.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgeneric_os.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -11,21 +11,23 @@ import core::option;\n // Wow, this is an ugly way to write doc comments\n \n #[cfg(bogus)]\n-/*\n-Function: getenv\n-\n-Get the value of an environment variable\n-*/\n+#[doc = \"Get the value of an environment variable\"]\n fn getenv(n: str) -> option<str> { }\n \n #[cfg(bogus)]\n-/*\n-Function: setenv\n-\n-Set the value of an environment variable\n-*/\n+#[doc = \"Set the value of an environment variable\"]\n fn setenv(n: str, v: str) { }\n \n+fn env() -> [(str,str)] {\n+    let pairs = [];\n+    for p in os::rustrt::rust_env_pairs() {\n+        let vs = str::split(p, '=' as u8);\n+        assert vec::len(vs) == 2u;\n+        pairs += [(vs[0], vs[1])];\n+    }\n+    ret pairs;\n+}\n+\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]"}, {"sha": "0231add3cd405b778e5f82331943dc3bd956b865", "filename": "src/libstd/linux_os.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flinux_os.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -20,6 +20,7 @@ export target_os;\n export dylib_filename;\n export get_exe_path;\n export fsync_fd;\n+export rustrt;\n \n // FIXME Somehow merge stuff duplicated here and macosx_os.rs. Made difficult\n // by https://github.com/graydon/rust/issues#issue/268\n@@ -112,6 +113,7 @@ fn waitpid(pid: pid_t) -> i32 {\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n+    fn rust_env_pairs() -> [str];\n     fn rust_getcwd() -> str;\n }\n "}, {"sha": "e44bc4c20e2df269599972a23964a2eb72409041", "filename": "src/libstd/macos_os.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacos_os.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -14,6 +14,7 @@ export target_os;\n export dylib_filename;\n export get_exe_path;\n export fsync_fd;\n+export rustrt;\n \n // FIXME Refactor into unix_os module or some such. Doesn't\n // seem to work right now.\n@@ -115,6 +116,7 @@ fn fsync_fd(fd: fd_t, level: io::fsync::level) -> c_int {\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n+    fn rust_env_pairs() -> [str];\n     fn rust_getcwd() -> str;\n }\n "}, {"sha": "fa827c96f2fa56330074eb80c688a18682afbe88", "filename": "src/libstd/run_program.rs", "status": "modified", "additions": 98, "deletions": 25, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun_program.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -5,7 +5,7 @@ Process spawning\n */\n import option::{some, none};\n import str::sbuf;\n-import ctypes::{fd_t, pid_t};\n+import ctypes::{fd_t, pid_t, void};\n \n export program;\n export run_program;\n@@ -16,8 +16,9 @@ export waitpid;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn rust_run_program(argv: *sbuf, in_fd: fd_t,\n-                        out_fd: fd_t, err_fd: fd_t) -> pid_t;\n+    fn rust_run_program(argv: *sbuf, envp: *void, dir: sbuf,\n+                        in_fd: fd_t, out_fd: fd_t, err_fd: fd_t)\n+        -> pid_t;\n }\n \n /* Section: Types */\n@@ -82,13 +83,6 @@ iface program {\n \n /* Section: Operations */\n \n-fn arg_vec(prog: str, args: [@str]) -> [sbuf] {\n-    let argptrs = str::as_buf(prog, {|buf| [buf] });\n-    for arg in args { argptrs += str::as_buf(*arg, {|buf| [buf] }); }\n-    argptrs += [ptr::null()];\n-    ret argptrs;\n-}\n-\n /*\n Function: spawn_process\n \n@@ -98,6 +92,8 @@ Parameters:\n \n prog - The path to an executable\n args - Vector of arguments to pass to the child process\n+env - optional env-modification for child\n+dir - optional dir to run child in (default current dir)\n in_fd - A file descriptor for the child to use as std input\n out_fd - A file descriptor for the child to use as std output\n err_fd - A file descriptor for the child to use as std error\n@@ -106,18 +102,90 @@ Returns:\n \n The process id of the spawned process\n */\n-fn spawn_process(prog: str, args: [str], in_fd: fd_t,\n-                 out_fd: fd_t, err_fd: fd_t)\n+fn spawn_process(prog: str, args: [str],\n+                 env: option<[(str,str)]>,\n+                 dir: option<str>,\n+                 in_fd: fd_t, out_fd: fd_t, err_fd: fd_t)\n    -> pid_t unsafe {\n-    // Note: we have to hold on to these vector references while we hold a\n-    // pointer to their buffers\n-    let prog = prog;\n-    let args = vec::map(args, {|arg| @arg });\n-    let argv = arg_vec(prog, args);\n-    let pid =\n-        rustrt::rust_run_program(vec::unsafe::to_ptr(argv), in_fd, out_fd,\n-                                 err_fd);\n-    ret pid;\n+    with_argv(prog, args) {|argv|\n+        with_envp(env) { |envp|\n+            with_dirp(dir) { |dirp|\n+                rustrt::rust_run_program(argv, envp, dirp,\n+                                         in_fd, out_fd, err_fd)\n+            }\n+        }\n+    }\n+}\n+\n+fn with_argv<T>(prog: str, args: [str],\n+                cb: fn(*sbuf) -> T) -> T unsafe {\n+    let argptrs = str::as_buf(prog) {|b| [b] };\n+    let tmps = [];\n+    for arg in args {\n+        let t = @arg;\n+        tmps += [t];\n+        argptrs += str::as_buf(*t) {|b| [b] };\n+    }\n+    argptrs += [ptr::null()];\n+    vec::as_buf(argptrs, cb)\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"freebsd\")]\n+fn with_envp<T>(env: option<[(str,str)]>,\n+                cb: fn(*void) -> T) -> T unsafe {\n+    // On posixy systems we can pass a char** for envp, which is\n+    // a null-terminated array of \"k=v\\n\" strings.\n+    alt env {\n+      some (es) {\n+        let tmps = [];\n+        let ptrs = [];\n+\n+        for (k,v) in es {\n+            let t = @(#fmt(\"%s=%s\", k, v));\n+            vec::push(tmps, t);\n+            ptrs += str::as_buf(*t) {|b| [b]};\n+        }\n+        ptrs += [ptr::null()];\n+        vec::as_buf(ptrs) { |p| cb(::unsafe::reinterpret_cast(p)) }\n+      }\n+      none {\n+        cb(ptr::null())\n+      }\n+    }\n+}\n+\n+#[cfg(target_os = \"win32\")]\n+fn with_envp<T>(env: option<[(str,str)]>,\n+                cb: fn(*void) -> T) -> T unsafe {\n+    // On win32 we pass an \"environment block\" which is not a char**, but\n+    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n+    // \\0 to terminate.\n+    alt env {\n+      some (es) {\n+        let blk : [u8] = [];\n+        for (k,v) in es {\n+            let t = #fmt(\"%s=%s\", k, v);\n+            let v : [u8] = ::unsafe::reinterpret_cast(t);\n+            blk += v;\n+            ::unsafe::leak(v);\n+        }\n+        blk += [0_u8];\n+        vec::as_buf(blk) {|p| cb(::unsafe::reinterpret_cast(p)) }\n+      }\n+      none {\n+        cb(ptr::null())\n+      }\n+    }\n+}\n+\n+fn with_dirp<T>(d: option<str>,\n+                cb: fn(sbuf) -> T) -> T unsafe {\n+    alt d {\n+      some(dir) { str::as_buf(dir, cb) }\n+      none { cb(ptr::null()) }\n+    }\n }\n \n /*\n@@ -135,7 +203,8 @@ Returns:\n The process id\n */\n fn run_program(prog: str, args: [str]) -> int {\n-    ret waitpid(spawn_process(prog, args, 0i32, 0i32, 0i32));\n+    ret waitpid(spawn_process(prog, args, none, none,\n+                              0i32, 0i32, 0i32));\n }\n \n /*\n@@ -161,7 +230,8 @@ fn start_program(prog: str, args: [str]) -> program {\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n     let pid =\n-        spawn_process(prog, args, pipe_input.in, pipe_output.out,\n+        spawn_process(prog, args, none, none,\n+                      pipe_input.in, pipe_output.out,\n                       pipe_err.out);\n \n     if pid == -1i32 { fail; }\n@@ -316,7 +386,8 @@ mod tests {\n \n         let pid =\n             run::spawn_process(\n-                \"cat\", [], pipe_in.in, pipe_out.out, pipe_err.out);\n+                \"cat\", [], none, none,\n+                pipe_in.in, pipe_out.out, pipe_err.out);\n         os::close(pipe_in.in);\n         os::close(pipe_out.out);\n         os::close(pipe_err.out);\n@@ -356,7 +427,9 @@ mod tests {\n \n     #[test]\n     fn waitpid() {\n-        let pid = run::spawn_process(\"false\", [], 0i32, 0i32, 0i32);\n+        let pid = run::spawn_process(\"false\", [],\n+                                     none, none,\n+                                     0i32, 0i32, 0i32);\n         let status = run::waitpid(pid);\n         assert status == 1;\n     }"}, {"sha": "8d5ecda2c48f44745828ad8d36f2bed6b1534d7a", "filename": "src/libstd/test.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -227,10 +227,19 @@ fn run_tests(opts: test_opts, tests: [test_desc],\n     }\n }\n \n+// Windows tends to dislike being overloaded with threads.\n+#[cfg(target_os = \"win32\")]\n+const sched_overcommit : uint = 1u;\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"macos\")]\n+const sched_overcommit : uint = 4u;\n+\n fn get_concurrency() -> uint {\n     let threads = rustrt::sched_threads();\n     if threads == 1u { 1u }\n-    else { threads * 4u }\n+    else { threads * sched_overcommit }\n }\n \n fn filter_tests(opts: test_opts,"}, {"sha": "aa589cf3c32d83099afec43e249322b4cc358ac0", "filename": "src/libstd/win32_os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Flibstd%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fwin32_os.rs?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -106,6 +106,7 @@ fn fsync_fd(_fd: fd_t, _level: io::fsync::level) -> c_int {\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n+    fn rust_env_pairs() -> [str];\n     fn rust_process_wait(handle: c_int) -> c_int;\n     fn rust_getcwd() -> str;\n }"}, {"sha": "dacbcee1045f1ac4df3274f6cc7fffb8bb23d321", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -41,16 +41,7 @@ command_line_args : public kernel_owned<command_line_args>\n         LocalFree(wargv);\n #endif\n \n-        args = (rust_vec *)\n-            kernel->malloc(vec_size<rust_vec*>(argc),\n-                           \"command line arg interior\");\n-        args->fill = args->alloc = sizeof(rust_vec*) * argc;\n-        for (int i = 0; i < argc; ++i) {\n-            rust_str *str = make_str(kernel, argv[i],\n-                                     strlen(argv[i]),\n-                                     \"command line arg\");\n-            ((rust_str**)&args->data)[i] = str;\n-        }\n+        args = make_str_vec(kernel, argc, argv);\n     }\n \n     ~command_line_args() {"}, {"sha": "76f80192e89b0dd1368bbb40513502ca5619e749", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -7,6 +7,10 @@\n #include \"rust_scheduler.h\"\n #include \"sync/timer.h\"\n \n+#ifdef __APPLE__\n+#include <crt_externs.h>\n+#endif\n+\n #if !defined(__WIN32__)\n #include <sys/time.h>\n #endif\n@@ -73,6 +77,49 @@ rust_getcwd() {\n     return make_str(task->kernel, cbuf, strlen(cbuf), \"rust_str(getcwd\");\n }\n \n+\n+#if defined(__WIN32__)\n+extern \"C\" CDECL rust_vec *\n+rust_env_pairs() {\n+    rust_task *task = rust_task_thread::get_task();\n+    size_t envc = 0;\n+    LPTCH ch = GetEnvironmentStringsA();\n+    LPTCH c;\n+    for (c = ch; *c; c += strlen(c) + 1) {\n+        ++envc;\n+    }\n+    c = ch;\n+    rust_vec *v = (rust_vec *)\n+        task->kernel->malloc(vec_size<rust_vec*>(envc),\n+                       \"str vec interior\");\n+    v->fill = v->alloc = sizeof(rust_vec*) * envc;\n+    for (size_t i = 0; i < envc; ++i) {\n+        size_t n = strlen(c);\n+        rust_str *str = make_str(task->kernel, c, n, \"str\");\n+        ((rust_str**)&v->data)[i] = str;\n+        c += n + 1;\n+    }\n+    if (ch) {\n+        FreeEnvironmentStrings(ch);\n+    }\n+    return v;\n+}\n+#else\n+extern \"C\" CDECL rust_vec *\n+rust_env_pairs() {\n+    rust_task *task = rust_task_thread::get_task();\n+#ifdef __APPLE__\n+    char **environ = *_NSGetEnviron();\n+#endif\n+    char **e = environ;\n+    size_t envc = 0;\n+    while (*e) {\n+        ++envc; ++e;\n+    }\n+    return make_str_vec(task->kernel, envc, environ);\n+}\n+#endif\n+\n // TODO: Allow calling native functions that return double results.\n extern \"C\" CDECL\n void squareroot(double *input, double *output) {"}, {"sha": "848b015dd6c8393fd9c4bd613a98ed013bdd38fd", "filename": "src/rt/rust_run_program.cpp", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Frt%2Frust_run_program.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Frt%2Frust_run_program.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_run_program.cpp?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -1,5 +1,9 @@\n #include \"rust_internal.h\"\n \n+#ifdef __APPLE__\n+#include <crt_externs.h>\n+#endif\n+\n #if defined(__WIN32__)\n \n #include <process.h>\n@@ -64,7 +68,10 @@ void append_arg(char *& buf, char const *arg, bool last) {\n }\n \n extern \"C\" CDECL int\n-rust_run_program(const char* argv[], int in_fd, int out_fd, int err_fd) {\n+rust_run_program(const char* argv[],\n+                 void* envp,\n+                 const char* dir,\n+                 int in_fd, int out_fd, int err_fd) {\n     STARTUPINFO si;\n     ZeroMemory(&si, sizeof(STARTUPINFO));\n     si.cb = sizeof(STARTUPINFO);\n@@ -99,7 +106,7 @@ rust_run_program(const char* argv[], int in_fd, int out_fd, int err_fd) {\n \n     PROCESS_INFORMATION pi;\n     BOOL created = CreateProcess(NULL, cmd, NULL, NULL, TRUE,\n-                                 0, NULL, NULL, &si, &pi);\n+                                 0, envp, dir, &si, &pi);\n \n     CloseHandle(si.hStdInput);\n     CloseHandle(si.hStdOutput);\n@@ -130,7 +137,10 @@ rust_process_wait(int proc) {\n #include <termios.h>\n \n extern \"C\" CDECL int\n-rust_run_program(char* argv[], int in_fd, int out_fd, int err_fd) {\n+rust_run_program(const char* argv[],\n+                 void* envp,\n+                 const char* dir,\n+                 int in_fd, int out_fd, int err_fd) {\n     int pid = fork();\n     if (pid != 0) return pid;\n \n@@ -143,7 +153,18 @@ rust_run_program(char* argv[], int in_fd, int out_fd, int err_fd) {\n     if (err_fd) dup2(err_fd, 2);\n     /* Close all other fds. */\n     for (int fd = getdtablesize() - 1; fd >= 3; fd--) close(fd);\n-    execvp(argv[0], argv);\n+    if (dir) { chdir(dir); }\n+\n+#ifdef __APPLE__\n+    if (envp) {\n+        *_NSGetEnviron() = (char **)envp;\n+    }\n+    execvp(argv[0], (char * const *)argv);\n+#else\n+    if (!envp) { envp = environ; }\n+    execvpe(argv[0], (char * const *)argv, (char * const *)envp);\n+#endif\n+\n     exit(1);\n }\n "}, {"sha": "1b611dd0be695acc9174f45c48966212ada19360", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -204,6 +204,21 @@ make_str(rust_kernel* kernel, const char* c, size_t strlen, const char* name) {\n     return str;\n }\n \n+inline rust_vec *\n+make_str_vec(rust_kernel* kernel, size_t nstrs, char **strs) {\n+    rust_vec *v = (rust_vec *)\n+        kernel->malloc(vec_size<rust_vec*>(nstrs),\n+                       \"str vec interior\");\n+    v->fill = v->alloc = sizeof(rust_vec*) * nstrs;\n+    for (size_t i = 0; i < nstrs; ++i) {\n+        rust_str *str = make_str(kernel, strs[i],\n+                                 strlen(strs[i]),\n+                                 \"str\");\n+        ((rust_str**)&v->data)[i] = str;\n+    }\n+    return v;\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "81f8a9c25f787b3169e24711fbe877ea094e2662", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/93450abb4bf6a755b343ca459bbeff92540a7822/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=93450abb4bf6a755b343ca459bbeff92540a7822", "patch": "@@ -42,6 +42,7 @@ rust_run_program\n rust_set_exit_status\n rust_start\n rust_getcwd\n+rust_env_pairs\n rust_task_yield\n rust_task_is_unwinding\n rust_get_task"}]}