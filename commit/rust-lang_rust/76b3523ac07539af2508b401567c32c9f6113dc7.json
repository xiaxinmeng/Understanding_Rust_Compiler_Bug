{"sha": "76b3523ac07539af2508b401567c32c9f6113dc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YjM1MjNhYzA3NTM5YWYyNTA4YjQwMTU2N2MzMmM5ZjYxMTNkYzc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-16T19:13:36Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-17T02:41:44Z"}, "message": "Re-add double underscores in derive (fixes #32292)", "tree": {"sha": "2a8a2d824cba80ec79fafda469609fed582c8e2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a8a2d824cba80ec79fafda469609fed582c8e2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76b3523ac07539af2508b401567c32c9f6113dc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76b3523ac07539af2508b401567c32c9f6113dc7", "html_url": "https://github.com/rust-lang/rust/commit/76b3523ac07539af2508b401567c32c9f6113dc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76b3523ac07539af2508b401567c32c9f6113dc7/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd5603b6fc8c130da50c2fd49bcd1188ef10a19e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd5603b6fc8c130da50c2fd49bcd1188ef10a19e", "html_url": "https://github.com/rust-lang/rust/commit/fd5603b6fc8c130da50c2fd49bcd1188ef10a19e"}], "stats": {"total": 86, "additions": 43, "deletions": 43}, "files": [{"sha": "74706c470872a0dbe767b34e79643fc90fdb67da", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76b3523ac07539af2508b401567c32c9f6113dc7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b3523ac07539af2508b401567c32c9f6113dc7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=76b3523ac07539af2508b401567c32c9f6113dc7", "patch": "@@ -64,7 +64,7 @@ pub fn ordering_collapsed(cx: &mut ExtCtxt,\n \n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> P<Expr> {\n-    let test_id = cx.ident_of(\"cmp\");\n+    let test_id = cx.ident_of(\"__cmp\");\n     let equals_path = cx.path_global(span,\n                                      cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n \n@@ -79,9 +79,9 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n                 ::std::cmp::Ordering::Equal => {\n                     ...\n                 }\n-                cmp => cmp\n+                __cmp => __cmp\n             },\n-        cmp => cmp\n+        __cmp => __cmp\n     }\n     */\n     cs_fold(\n@@ -91,7 +91,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n         |cx, span, old, self_f, other_fs| {\n             // match new {\n             //     ::std::cmp::Ordering::Equal => old,\n-            //     cmp => cmp\n+            //     __cmp => __cmp\n             // }\n \n             let new = {"}, {"sha": "c864ce0db5142144297e35b66ef0fafaec8560fd", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76b3523ac07539af2508b401567c32c9f6113dc7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b3523ac07539af2508b401567c32c9f6113dc7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=76b3523ac07539af2508b401567c32c9f6113dc7", "patch": "@@ -107,7 +107,7 @@ pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> P<Expr> {\n-    let test_id = cx.ident_of(\"cmp\");\n+    let test_id = cx.ident_of(\"__cmp\");\n     let ordering = cx.path_global(span,\n                                   cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n@@ -124,9 +124,9 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n                 ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {\n                     ...\n                 }\n-                cmp => cmp\n+                __cmp => __cmp\n             },\n-        cmp => cmp\n+        __cmp => __cmp\n     }\n     */\n     cs_fold(\n@@ -136,7 +136,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n         |cx, span, old, self_f, other_fs| {\n             // match new {\n             //     Some(::std::cmp::Ordering::Equal) => old,\n-            //     cmp => cmp\n+            //     __cmp => __cmp\n             // }\n \n             let new = {"}, {"sha": "ef7f455632c73e01ecca6cb010ee940118e7c2d9", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/76b3523ac07539af2508b401567c32c9f6113dc7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b3523ac07539af2508b401567c32c9f6113dc7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=76b3523ac07539af2508b401567c32c9f6113dc7", "patch": "@@ -156,14 +156,14 @@\n //!\n //! ```{.text}\n //! EnumNonMatchingCollapsed(\n-//!     vec![<ident of self>, <ident of arg_1>],\n+//!     vec![<ident of self>, <ident of __arg_1>],\n //!     &[<ast::Variant for C0>, <ast::Variant for C1>],\n-//!     &[<ident for self index value>, <ident of arg_1 index value>])\n+//!     &[<ident for self index value>, <ident of __arg_1 index value>])\n //! ```\n //!\n //! It is the same for when the arguments are flipped to `C1 {x}` and\n //! `C0(a)`; the only difference is what the values of the identifiers\n-//! <ident for self index value> and <ident of arg_1 index value> will\n+//! <ident for self index value> and <ident of __arg_1 index value> will\n //! be in the generated code.\n //!\n //! `EnumNonMatchingCollapsed` deliberately provides far less information\n@@ -843,7 +843,7 @@ impl<'a> MethodDef<'a> {\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(&format!(\"arg_{}\", i));\n+            let ident = cx.ident_of(&format!(\"__arg_{}\", i));\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -929,12 +929,12 @@ impl<'a> MethodDef<'a> {\n     ///\n     /// // equivalent to:\n     /// impl PartialEq for A {\n-    ///     fn eq(&self, arg_1: &A) -> bool {\n+    ///     fn eq(&self, __arg_1: &A) -> bool {\n     ///         match *self {\n-    ///             A {x: ref self_0_0, y: ref self_0_1} => {\n-    ///                 match *arg_1 {\n-    ///                     A {x: ref self_1_0, y: ref self_1_1} => {\n-    ///                         self_0_0.eq(self_1_0) && self_0_1.eq(self_1_1)\n+    ///             A {x: ref __self_0_0, y: ref __self_0_1} => {\n+    ///                 match *__arg_1 {\n+    ///                     A {x: ref __self_1_0, y: ref __self_1_1} => {\n+    ///                         __self_0_0.eq(__self_1_0) && __self_0_1.eq(__self_1_1)\n     ///                     }\n     ///                 }\n     ///             }\n@@ -960,7 +960,7 @@ impl<'a> MethodDef<'a> {\n                 trait_.create_struct_pattern(cx,\n                                              struct_path,\n                                              struct_def,\n-                                             &format!(\"self_{}\",\n+                                             &format!(\"__self_{}\",\n                                                      i),\n                                              ast::Mutability::Immutable);\n             patterns.push(pat);\n@@ -1038,25 +1038,25 @@ impl<'a> MethodDef<'a> {\n     /// // is equivalent to\n     ///\n     /// impl PartialEq for A {\n-    ///     fn eq(&self, arg_1: &A) -> ::bool {\n-    ///         match (&*self, &*arg_1) {\n+    ///     fn eq(&self, __arg_1: &A) -> ::bool {\n+    ///         match (&*self, &*__arg_1) {\n     ///             (&A1, &A1) => true,\n     ///             (&A2(ref self_0),\n-    ///              &A2(ref arg_1_0)) => (*self_0).eq(&(*arg_1_0)),\n+    ///              &A2(ref __arg_1_0)) => (*self_0).eq(&(*__arg_1_0)),\n     ///             _ => {\n-    ///                 let self_vi = match *self { A1(..) => 0, A2(..) => 1 };\n-    ///                 let arg_1_vi = match *arg_1 { A1(..) => 0, A2(..) => 1 };\n+    ///                 let __self_vi = match *self { A1(..) => 0, A2(..) => 1 };\n+    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0, A2(..) => 1 };\n     ///                 false\n     ///             }\n     ///         }\n     ///     }\n     /// }\n     /// ```\n     ///\n-    /// (Of course `self_vi` and `arg_1_vi` are unused for\n+    /// (Of course `__self_vi` and `__arg_1_vi` are unused for\n     /// `PartialEq`, and those subcomputations will hopefully be removed\n-    /// as their results are unused.  The point of `self_vi` and\n-    /// `arg_1_vi` is for `PartialOrd`; see #15503.)\n+    /// as their results are unused.  The point of `__self_vi` and\n+    /// `__arg_1_vi` is for `PartialOrd`; see #15503.)\n     fn expand_enum_method_body<'b>(&self,\n                                cx: &mut ExtCtxt,\n                                trait_: &TraitDef<'b>,\n@@ -1087,14 +1087,14 @@ impl<'a> MethodDef<'a> {\n     /// for each of the self-args, carried in precomputed variables.\n \n     /// ```{.text}\n-    /// let self0_vi = unsafe {\n+    /// let __self0_vi = unsafe {\n     ///     std::intrinsics::discriminant_value(&self) } as i32;\n-    /// let self1_vi = unsafe {\n+    /// let __self1_vi = unsafe {\n     ///     std::intrinsics::discriminant_value(&arg1) } as i32;\n-    /// let self2_vi = unsafe {\n+    /// let __self2_vi = unsafe {\n     ///     std::intrinsics::discriminant_value(&arg2) } as i32;\n     ///\n-    /// if self0_vi == self1_vi && self0_vi == self2_vi && ... {\n+    /// if __self0_vi == __self1_vi && __self0_vi == __self2_vi && ... {\n     ///     match (...) {\n     ///         (Variant1, Variant1, ...) => Body1\n     ///         (Variant2, Variant2, ...) => Body2,\n@@ -1122,9 +1122,9 @@ impl<'a> MethodDef<'a> {\n         let self_arg_names = self_args.iter().enumerate()\n             .map(|(arg_count, _self_arg)| {\n                 if arg_count == 0 {\n-                    \"self\".to_string()\n+                    \"__self\".to_string()\n                 } else {\n-                    format!(\"arg_{}\", arg_count)\n+                    format!(\"__arg_{}\", arg_count)\n                 }\n             })\n             .collect::<Vec<String>>();\n@@ -1261,17 +1261,17 @@ impl<'a> MethodDef<'a> {\n             // with three Self args, builds three statements:\n             //\n             // ```\n-            // let self0_vi = unsafe {\n+            // let __self0_vi = unsafe {\n             //     std::intrinsics::discriminant_value(&self) } as i32;\n-            // let self1_vi = unsafe {\n+            // let __self1_vi = unsafe {\n             //     std::intrinsics::discriminant_value(&arg1) } as i32;\n-            // let self2_vi = unsafe {\n+            // let __self2_vi = unsafe {\n             //     std::intrinsics::discriminant_value(&arg2) } as i32;\n             // ```\n             let mut index_let_stmts: Vec<ast::Stmt> = Vec::new();\n \n             //We also build an expression which checks whether all discriminants are equal\n-            // discriminant_test = self0_vi == self1_vi && self0_vi == self2_vi && ...\n+            // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n             let mut discriminant_test = cx.expr_bool(sp, true);\n \n             let target_type_name =\n@@ -1321,7 +1321,7 @@ impl<'a> MethodDef<'a> {\n             // down to desired l-values, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n-            // `(*self, *arg_0, ...)` into `(&*self, &*arg_0, ...)`.\n+            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n             let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n             let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n \n@@ -1335,7 +1335,7 @@ impl<'a> MethodDef<'a> {\n             //      }\n             //  }\n             //  else {\n-            //      <delegated expression referring to self0_vi, et al.>\n+            //      <delegated expression referring to __self0_vi, et al.>\n             //  }\n             let all_match = cx.expr_match(sp, match_arg, match_arms);\n             let arm_expr = cx.expr_if(sp, discriminant_test, all_match, Some(arm_expr));\n@@ -1359,8 +1359,8 @@ impl<'a> MethodDef<'a> {\n             // error-prone, since the catch-all as defined above would\n             // generate code like this:\n             //\n-            //     _ => { let self0 = match *self { };\n-            //            let self1 = match *arg_0 { };\n+            //     _ => { let __self0 = match *self { };\n+            //            let __self1 = match *__arg_0 { };\n             //            <catch-all-expr> }\n             //\n             // Which is yields bindings for variables which type\n@@ -1399,7 +1399,7 @@ impl<'a> MethodDef<'a> {\n             // down to desired l-values, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n-            // `(*self, *arg_0, ...)` into `(&*self, &*arg_0, ...)`.\n+            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n             let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n             let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n             cx.expr_match(sp, match_arg, match_arms)\n@@ -1613,8 +1613,8 @@ pub fn cs_fold<F>(use_foldl: bool,\n /// process the collected results. i.e.\n ///\n /// ```ignore\n-/// f(cx, span, vec![self_1.method(arg_1_1, arg_2_1),\n-///                  self_2.method(arg_1_2, arg_2_2)])\n+/// f(cx, span, vec![self_1.method(__arg_1_1, __arg_2_1),\n+///                  self_2.method(__arg_1_2, __arg_2_2)])\n /// ```\n #[inline]\n pub fn cs_same_method<F>(f: F,"}]}