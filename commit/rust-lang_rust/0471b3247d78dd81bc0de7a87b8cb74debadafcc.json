{"sha": "0471b3247d78dd81bc0de7a87b8cb74debadafcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NzFiMzI0N2Q3OGRkODFiYzBkZTdhODdiOGNiNzRkZWJhZGFmY2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-10T22:11:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-11T03:18:06Z"}, "message": "Reorganize match construction to be O(n) instead of O(n^2). Whereas\nbefore we iterated over the test and each outcome thereof, and then\nchecked processed every candidate against this outcome, we now organize\nthe walk differently. Instead, we visit each candidate and say \"Here is\nthe test being performed. Figure out the resulting candidates for each\npossible outcome and add yourself into the appropriate places.\"", "tree": {"sha": "877970cb10b182a2be89a739e76a7f95a9b20d64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/877970cb10b182a2be89a739e76a7f95a9b20d64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0471b3247d78dd81bc0de7a87b8cb74debadafcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0471b3247d78dd81bc0de7a87b8cb74debadafcc", "html_url": "https://github.com/rust-lang/rust/commit/0471b3247d78dd81bc0de7a87b8cb74debadafcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0471b3247d78dd81bc0de7a87b8cb74debadafcc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61884e5543a68e7b99e33fc40afef1515b1a216d", "url": "https://api.github.com/repos/rust-lang/rust/commits/61884e5543a68e7b99e33fc40afef1515b1a216d", "html_url": "https://github.com/rust-lang/rust/commit/61884e5543a68e7b99e33fc40afef1515b1a216d"}], "stats": {"total": 393, "additions": 160, "deletions": 233}, "files": [{"sha": "4eda6961a1921f5ca4c7de10291322e4362a2d0e", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0471b3247d78dd81bc0de7a87b8cb74debadafcc/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0471b3247d78dd81bc0de7a87b8cb74debadafcc/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=0471b3247d78dd81bc0de7a87b8cb74debadafcc", "patch": "@@ -345,17 +345,20 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n         let target_blocks = self.perform_test(block, &match_pair.lvalue, &test);\n \n-        for (outcome, target_block) in target_blocks.into_iter().enumerate() {\n-            let applicable_candidates: Vec<_> =\n-                candidates.iter()\n-                          .filter_map(|candidate| {\n-                              self.candidate_under_assumption(&match_pair.lvalue,\n-                                                              &test.kind,\n-                                                              outcome,\n-                                                              candidate)\n-                          })\n-                          .collect();\n-            self.match_candidates(span, arm_blocks, applicable_candidates, target_block);\n+        let mut target_candidates: Vec<_> = (0..target_blocks.len()).map(|_| vec![]).collect();\n+\n+        for candidate in &candidates {\n+            self.sort_candidate(&match_pair.lvalue,\n+                                &test,\n+                                candidate,\n+                                &mut target_candidates);\n+        }\n+\n+        for (target_block, target_candidates) in\n+            target_blocks.into_iter()\n+                         .zip(target_candidates.into_iter())\n+        {\n+            self.match_candidates(span, arm_blocks, target_candidates, target_block);\n         }\n     }\n "}, {"sha": "8a7722872e7990e953d2764961b0f7fb5bbf9b9c", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 146, "deletions": 222, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/0471b3247d78dd81bc0de7a87b8cb74debadafcc/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0471b3247d78dd81bc0de7a87b8cb74debadafcc/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=0471b3247d78dd81bc0de7a87b8cb74debadafcc", "patch": "@@ -21,7 +21,7 @@ use hair::*;\n use repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::middle::const_eval::ConstVal;\n-use rustc::middle::ty::Ty;\n+use rustc::middle::ty::{self, Ty};\n use syntax::codemap::Span;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n@@ -271,248 +271,172 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         target_blocks\n     }\n \n-    /// Given a candidate and the outcome of a test we have performed,\n-    /// transforms the candidate into a new candidate that reflects\n-    /// further tests still needed. Returns `None` if this candidate\n-    /// has now been ruled out.\n+    /// Given that we are performing `test` against `test_lvalue`,\n+    /// this job sorts out what the status of `candidate` will be\n+    /// after the test. The `resulting_candidates` vector stores, for\n+    /// each possible outcome of `test`, a vector of the candidates\n+    /// that will result. This fn should add a (possibly modified)\n+    /// clone of candidate into `resulting_candidates` wherever\n+    /// appropriate.\n     ///\n-    /// For example, if a candidate included the patterns `[x.0 @\n-    /// Ok(P1), x.1 @ 22]`, and we did a switch test on `x.0` and\n-    /// found the variant `Err` (as indicated by the `test_outcome`\n-    /// parameter), we would return `None`. But if the test_outcome\n-    /// were `Ok`, we would return `Some([x.0.downcast<Ok>.0 @ P1, x.1\n-    /// @ 22])`.\n-    pub fn candidate_under_assumption<'pat>(&mut self,\n-                                            test_lvalue: &Lvalue<'tcx>,\n-                                            test_kind: &TestKind<'tcx>,\n-                                            test_outcome: usize,\n-                                            candidate: &Candidate<'pat, 'tcx>)\n-                                            -> Option<Candidate<'pat, 'tcx>> {\n-        let result = self.match_pairs_under_assumption(test_lvalue,\n-                                                       test_kind,\n-                                                       test_outcome,\n-                                                       &candidate.match_pairs);\n-        match result {\n-            Some(match_pairs) => Some(Candidate { match_pairs: match_pairs,\n-                                                  bindings: candidate.bindings.clone(),\n-                                                  guard: candidate.guard.clone(),\n-                                                  arm_index: candidate.arm_index }),\n-            None => None,\n-        }\n-    }\n-\n-    /// Helper for candidate_under_assumption that does the actual\n-    /// work of transforming the list of match pairs.\n-    fn match_pairs_under_assumption<'pat>(&mut self,\n-                                          test_lvalue: &Lvalue<'tcx>,\n-                                          test_kind: &TestKind<'tcx>,\n-                                          test_outcome: usize,\n-                                          match_pairs: &[MatchPair<'pat, 'tcx>])\n-                                          -> Option<Vec<MatchPair<'pat, 'tcx>>> {\n-        let mut result = vec![];\n-\n-        for match_pair in match_pairs {\n-            // If the match pair is either:\n-            // (1) testing a different lvalue; or,\n-            // (2) the test doesn't tell us anything about this match-pair,\n-            // then we have to retain it as for after the test is complete.\n-            if\n-                match_pair.lvalue != *test_lvalue || // (1)\n-                !self.test_informs_match_pair(match_pair, test_kind, test_outcome) // (2)\n-            {\n-                result.push(match_pair.clone());\n-                continue;\n-            }\n-\n-            // otherwise, build up the consequence match pairs\n-            let opt_consequent_match_pairs =\n-                self.consequent_match_pairs_under_assumption(match_pair,\n-                                                             test_kind,\n-                                                             test_outcome);\n-            match opt_consequent_match_pairs {\n-                None => {\n-                    // Right kind of test, but wrong outcome. That\n-                    // means this **entire candidate** is\n-                    // inapplicable, since the candidate is only\n-                    // applicable if all of its match-pairs apply (and\n-                    // this one doesn't).\n-                    return None;\n-                }\n-\n-                Some(consequent_match_pairs) => {\n-                    // Test passed; add any new patterns we have to test to the final result.\n-                    result.extend(consequent_match_pairs)\n-                }\n+    /// So, for example, if this candidate is `x @ Some(P0)` and the\n+    /// test is a variant test, then we would add `(x as Option).0 @\n+    /// P0` to the `resulting_candidates` entry corresponding to the\n+    /// variant `Some`.\n+    ///\n+    /// In many cases we will add the `candidate` to more than one\n+    /// outcome. For example, say that the test is `x == 22`, but the\n+    /// candidate is `x @ 13..55`. In that case, if the test is true,\n+    /// then we know that the candidate applies (without this match\n+    /// pair, potentially, though we don't optimize this due to\n+    /// #29623). If the test is false, the candidate may also apply\n+    /// (with the match pair, still).\n+    pub fn sort_candidate<'pat>(&mut self,\n+                                test_lvalue: &Lvalue<'tcx>,\n+                                test: &Test<'tcx>,\n+                                candidate: &Candidate<'pat, 'tcx>,\n+                                resulting_candidates: &mut Vec<Vec<Candidate<'pat, 'tcx>>>) {\n+        // Find the match_pair for this lvalue (if any). At present,\n+        // afaik, there can be at most one. (In the future, if we\n+        // adopted a more general `@` operator, there might be more\n+        // than one, but it'd be very unusual to have two sides that\n+        // both require tests; you'd expect one side to be simplified\n+        // away.)\n+        let tested_match_pair = candidate.match_pairs.iter()\n+                                                     .enumerate()\n+                                                     .filter(|&(_, mp)| mp.lvalue == *test_lvalue)\n+                                                     .next();\n+        let (match_pair_index, match_pair) = match tested_match_pair {\n+            Some(pair) => pair,\n+            None => {\n+                // We are not testing this lvalue. Therefore, this\n+                // candidate applies to ALL outcomes.\n+                return self.add_to_all_candidate_sets(candidate, resulting_candidates);\n             }\n-        }\n-\n-        Some(result)\n-    }\n+        };\n \n-    /// Given that we executed `test` to `match_pair.lvalue` with\n-    /// outcome `test_outcome`, does that tell us anything about\n-    /// whether `match_pair` applies?\n-    ///\n-    /// Often it does not. For example, if we are testing whether\n-    /// the discriminant equals 4, and we find that it does not,\n-    /// but the `match_pair` is testing if the discriminant equals 5,\n-    /// that does not help us.\n-    fn test_informs_match_pair<'pat>(&mut self,\n-                                     match_pair: &MatchPair<'pat, 'tcx>,\n-                                     test_kind: &TestKind<'tcx>,\n-                                     _test_outcome: usize)\n-                                     -> bool {\n-        match *match_pair.pattern.kind {\n-            PatternKind::Variant { .. } => {\n-                match *test_kind {\n-                    TestKind::Switch { .. } => true,\n-                    _ => false,\n+        match test.kind {\n+            // If we are performing a variant switch, then this\n+            // informs variant patterns, but nothing else.\n+            TestKind::Switch { adt_def: tested_adt_def } => {\n+                match *match_pair.pattern.kind {\n+                    PatternKind::Variant { adt_def, variant_index, ref subpatterns } => {\n+                        assert_eq!(adt_def, tested_adt_def);\n+                        let new_candidate =\n+                            self.candidate_after_variant_switch(match_pair_index,\n+                                                                adt_def,\n+                                                                variant_index,\n+                                                                subpatterns,\n+                                                                candidate);\n+                        resulting_candidates[variant_index].push(new_candidate);\n+                    }\n+                    _ => {\n+                        self.add_to_all_candidate_sets(candidate, resulting_candidates);\n+                    }\n                 }\n             }\n \n-            PatternKind::Constant { value: Literal::Value { .. } }\n-            if is_switch_ty(match_pair.pattern.ty) => {\n-                match *test_kind {\n-                    TestKind::SwitchInt { .. } => true,\n-\n-                    // Did not do an integer equality test (which is always a SwitchInt).\n-                    // So we learned nothing relevant to this match-pair.\n-                    //\n-                    // FIXME(#29623) we could use TestKind::Range to rule\n-                    // things out here, in some cases.\n-                    _ => false,\n+            // If we are performing a switch over integers, then this informs integer\n+            // equality, but nothing else.\n+            //\n+            // FIXME(#29623) we could use TestKind::Range to rule\n+            // things out here, in some cases.\n+            TestKind::SwitchInt { switch_ty: _, options: _, ref indices } => {\n+                match *match_pair.pattern.kind {\n+                    PatternKind::Constant { value: Literal::Value { ref value } }\n+                    if is_switch_ty(match_pair.pattern.ty) => {\n+                        let index = indices[value];\n+                        let new_candidate = self.candidate_without_match_pair(match_pair_index,\n+                                                                              candidate);\n+                        resulting_candidates[index].push(new_candidate);\n+                    }\n+                    _ => {\n+                        self.add_to_all_candidate_sets(candidate, resulting_candidates);\n+                    }\n                 }\n             }\n \n-            PatternKind::Constant { .. } |\n-            PatternKind::Range { .. } |\n-            PatternKind::Slice { .. } => {\n+            TestKind::Eq { .. } |\n+            TestKind::Range { .. } |\n+            TestKind::Len { .. } => {\n+                // These are all binary tests.\n+                //\n+                // FIXME(#29623) we can be more clever here\n                 let pattern_test = self.test(&match_pair);\n-                if pattern_test.kind == *test_kind {\n-                    true\n+                if pattern_test.kind == test.kind {\n+                    let new_candidate = self.candidate_without_match_pair(match_pair_index,\n+                                                                          candidate);\n+                    resulting_candidates[0].push(new_candidate);\n                 } else {\n-                    // FIXME(#29623) in all 3 cases, we could sometimes do\n-                    // better here. For example, if we are checking\n-                    // whether the value is equal to X, and we find\n-                    // that it is, that (may) imply value is not equal\n-                    // to Y. Or, if the range tested is `3..5`, and\n-                    // our range is `4..5`, then we know that our\n-                    // range also does not apply. Similarly, if we\n-                    // test that length is >= 5, and it fails, we also\n-                    // know that length is not >= 7. etc.\n-                    false\n+                    self.add_to_all_candidate_sets(candidate, resulting_candidates);\n                 }\n             }\n-\n-            PatternKind::Array { .. } |\n-            PatternKind::Wild |\n-            PatternKind::Binding { .. } |\n-            PatternKind::Leaf { .. } |\n-            PatternKind::Deref { .. } => {\n-                self.error_simplifyable(&match_pair)\n-            }\n         }\n     }\n \n-    /// Given that we executed `test` with outcome `test_outcome`,\n-    /// what are the resulting match pairs? This can return either:\n-    ///\n-    /// - None, meaning that the test indicated that this outcome\n-    ///   means that this match-pair is not the current one for the\n-    ///   current discriminant (which rules out the enclosing\n-    ///   candidate);\n-    /// - Some(...), meaning that either the test didn't tell us whether this\n-    ///   match-pair is correct or not, or that we DID match and now have\n-    ///   subsequent matches to perform.\n-    ///\n-    /// As an example, consider:\n-    ///\n-    /// ```\n-    /// match option {\n-    ///     Ok(<pattern>) => ...,\n-    ///     Err(_) => ...,\n-    /// }\n-    /// ```\n-    ///\n-    /// Suppose that the `test` is a `Switch` and the outcome is\n-    /// `Ok`. Then in that case, the first arm will have a match-pair\n-    /// of `option @ Ok(<pattern>)`. In that case we will return\n-    /// `Some(vec![(option as Ok) @ <pattern>])`. The `Some` reuslt\n-    /// indicates that the match-pair still applies, and we now have\n-    /// to test `(option as Ok) @ <pattern>`.\n-    ///\n-    /// On the second arm, a `None` will be returned, because if we\n-    /// observed that `option` has the discriminant `Ok`, then the\n-    /// second arm cannot apply.\n-    pub fn consequent_match_pairs_under_assumption<'pat>(&mut self,\n-                                                         match_pair: &MatchPair<'pat, 'tcx>,\n-                                                         test_kind: &TestKind<'tcx>,\n-                                                         test_outcome: usize)\n-                                                         -> Option<Vec<MatchPair<'pat, 'tcx>>> {\n-        match *match_pair.pattern.kind {\n-            PatternKind::Variant { adt_def, variant_index, ref subpatterns } => {\n-                assert!(match *test_kind { TestKind::Switch { .. } => true,\n-                                           _ => false });\n-\n-                if test_outcome != variant_index {\n-                    return None; // Tested, but found the wrong variant.\n-                }\n+    fn candidate_without_match_pair<'pat>(&mut self,\n+                                          match_pair_index: usize,\n+                                          candidate: &Candidate<'pat, 'tcx>)\n+                                          -> Candidate<'pat, 'tcx> {\n+        let other_match_pairs =\n+            candidate.match_pairs.iter()\n+                                 .enumerate()\n+                                 .filter(|&(index, _)| index != match_pair_index)\n+                                 .map(|(_, mp)| mp.clone())\n+                                 .collect();\n+        Candidate {\n+            match_pairs: other_match_pairs,\n+            bindings: candidate.bindings.clone(),\n+            guard: candidate.guard.clone(),\n+            arm_index: candidate.arm_index,\n+        }\n+    }\n \n-                // Correct variant. Extract the subitems and match\n-                // those. The lvalue goes gets downcast, so\n-                // e.g. `foo.bar` becomes `foo.bar as Variant`.\n-                let elem = ProjectionElem::Downcast(adt_def, variant_index);\n-                let downcast_lvalue = match_pair.lvalue.clone().elem(elem);\n-                let consequent_match_pairs =\n-                    subpatterns.iter()\n-                               .map(|subpattern| {\n-                                   let lvalue =\n-                                       downcast_lvalue.clone().field(\n-                                           subpattern.field);\n-                                   MatchPair::new(lvalue, &subpattern.pattern)\n-                               })\n-                               .collect();\n-                Some(consequent_match_pairs)\n-            }\n+    fn add_to_all_candidate_sets<'pat>(&mut self,\n+                                       candidate: &Candidate<'pat, 'tcx>,\n+                                       resulting_candidates: &mut Vec<Vec<Candidate<'pat, 'tcx>>>) {\n+        for resulting_candidate in resulting_candidates {\n+            resulting_candidate.push(candidate.clone());\n+        }\n+    }\n \n-            PatternKind::Constant { value: Literal::Value { ref value } }\n-            if is_switch_ty(match_pair.pattern.ty) => {\n-                match *test_kind {\n-                    TestKind::SwitchInt { switch_ty: _, options: _, ref indices } => {\n-                        let index = indices[value];\n-                        if index == test_outcome {\n-                            Some(vec![]) // this value, nothing left to test\n-                        } else {\n-                            None // some other value, candidate is inapplicable\n-                        }\n-                    }\n+    fn candidate_after_variant_switch<'pat>(&mut self,\n+                                            match_pair_index: usize,\n+                                            adt_def: ty::AdtDef<'tcx>,\n+                                            variant_index: usize,\n+                                            subpatterns: &'pat [FieldPattern<'tcx>],\n+                                            candidate: &Candidate<'pat, 'tcx>)\n+                                            -> Candidate<'pat, 'tcx> {\n+        let match_pair = &candidate.match_pairs[match_pair_index];\n+\n+        // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n+        // we want to create a set of derived match-patterns like\n+        // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n+        let elem = ProjectionElem::Downcast(adt_def, variant_index);\n+        let downcast_lvalue = match_pair.lvalue.clone().elem(elem); // `(x as Variant)`\n+        let consequent_match_pairs =\n+            subpatterns.iter()\n+                       .map(|subpattern| {\n+                           // e.g., `(x as Variant).0`\n+                           let lvalue = downcast_lvalue.clone().field(subpattern.field);\n+                           // e.g., `(x as Variant).0 @ P1`\n+                           MatchPair::new(lvalue, &subpattern.pattern)\n+                       });\n \n-                    _ => {\n-                        self.hir.span_bug(\n-                            match_pair.pattern.span,\n-                            &format!(\"did a switch-int, but value {:?} not found in cases\",\n-                                     value));\n-                    }\n-                }\n-            }\n+        // In addition, we need all the other match pairs from the old candidate.\n+        let other_match_pairs =\n+            candidate.match_pairs.iter()\n+                                 .enumerate()\n+                                 .filter(|&(index, _)| index != match_pair_index)\n+                                 .map(|(_, mp)| mp.clone());\n \n-            PatternKind::Constant { .. } |\n-            PatternKind::Range { .. } |\n-            PatternKind::Slice { .. } => {\n-                if test_outcome == 0 {\n-                    Some(vec![])\n-                } else {\n-                    None\n-                }\n-            }\n+        let all_match_pairs = consequent_match_pairs.chain(other_match_pairs).collect();\n \n-            PatternKind::Array { .. } |\n-            PatternKind::Wild |\n-            PatternKind::Binding { .. } |\n-            PatternKind::Leaf { .. } |\n-            PatternKind::Deref { .. } => {\n-                self.error_simplifyable(match_pair)\n-            }\n+        Candidate {\n+            match_pairs: all_match_pairs,\n+            bindings: candidate.bindings.clone(),\n+            guard: candidate.guard.clone(),\n+            arm_index: candidate.arm_index,\n         }\n     }\n "}]}