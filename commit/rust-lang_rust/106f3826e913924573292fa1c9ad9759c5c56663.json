{"sha": "106f3826e913924573292fa1c9ad9759c5c56663", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNmYzODI2ZTkxMzkyNDU3MzI5MmZhMWM5YWQ5NzU5YzVjNTY2NjM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git1984941651981@oli-obk.de", "date": "2015-07-03T09:34:19Z"}, "committer": {"name": "Oliver Schneider", "email": "git1984941651981@oli-obk.de", "date": "2015-07-06T08:08:27Z"}, "message": "lower blanket unsafe block to actual cases of unsafe and adjust indents", "tree": {"sha": "16224d35a78050866f05b4da6031c516076dc4a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16224d35a78050866f05b4da6031c516076dc4a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/106f3826e913924573292fa1c9ad9759c5c56663", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/106f3826e913924573292fa1c9ad9759c5c56663", "html_url": "https://github.com/rust-lang/rust/commit/106f3826e913924573292fa1c9ad9759c5c56663", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/106f3826e913924573292fa1c9ad9759c5c56663/comments", "author": null, "committer": null, "parents": [{"sha": "a2b927c5a41ded169a0919ff8193b5357c850217", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2b927c5a41ded169a0919ff8193b5357c850217", "html_url": "https://github.com/rust-lang/rust/commit/a2b927c5a41ded169a0919ff8193b5357c850217"}], "stats": {"total": 594, "additions": 284, "deletions": 310}, "files": [{"sha": "ece52b3ad4d6d732adb584f6b14210540e949613", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 284, "deletions": 310, "changes": 594, "blob_url": "https://github.com/rust-lang/rust/blob/106f3826e913924573292fa1c9ad9759c5c56663/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106f3826e913924573292fa1c9ad9759c5c56663/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=106f3826e913924573292fa1c9ad9759c5c56663", "patch": "@@ -486,13 +486,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n              .map(|e| const_expr(cx, &**e, param_substs, fn_args).0)\n              .collect()\n     };\n-    unsafe {\n-        let _icx = push_ctxt(\"const_expr\");\n-        match e.node {\n-          ast::ExprLit(ref lit) => {\n-              const_lit(cx, e, &**lit)\n-          }\n-          ast::ExprBinary(b, ref e1, ref e2) => {\n+    let _icx = push_ctxt(\"const_expr\");\n+    match e.node {\n+        ast::ExprLit(ref lit) => {\n+            const_lit(cx, e, &**lit)\n+        },\n+        ast::ExprBinary(b, ref e1, ref e2) => {\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n             let (te1, ty) = const_expr(cx, &**e1, param_substs, fn_args);\n@@ -512,145 +511,136 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             check_binary_expr_validity(cx, e, ty, te1, te2);\n \n-            match b.node {\n-              ast::BiAdd   => {\n-                if is_float { llvm::LLVMConstFAdd(te1, te2) }\n-                else        { llvm::LLVMConstAdd(te1, te2) }\n-              }\n-              ast::BiSub => {\n-                if is_float { llvm::LLVMConstFSub(te1, te2) }\n-                else        { llvm::LLVMConstSub(te1, te2) }\n-              }\n-              ast::BiMul    => {\n-                if is_float { llvm::LLVMConstFMul(te1, te2) }\n-                else        { llvm::LLVMConstMul(te1, te2) }\n-              }\n-              ast::BiDiv    => {\n-                if is_float    { llvm::LLVMConstFDiv(te1, te2) }\n-                else if signed { llvm::LLVMConstSDiv(te1, te2) }\n-                else           { llvm::LLVMConstUDiv(te1, te2) }\n-              }\n-              ast::BiRem    => {\n-                if is_float    { llvm::LLVMConstFRem(te1, te2) }\n-                else if signed { llvm::LLVMConstSRem(te1, te2) }\n-                else           { llvm::LLVMConstURem(te1, te2) }\n-              }\n-              ast::BiAnd    => llvm::LLVMConstAnd(te1, te2),\n-              ast::BiOr     => llvm::LLVMConstOr(te1, te2),\n-              ast::BiBitXor => llvm::LLVMConstXor(te1, te2),\n-              ast::BiBitAnd => llvm::LLVMConstAnd(te1, te2),\n-              ast::BiBitOr  => llvm::LLVMConstOr(te1, te2),\n-              ast::BiShl    => {\n-                let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n-                llvm::LLVMConstShl(te1, te2)\n-              }\n-              ast::BiShr    => {\n-                let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n-                if signed { llvm::LLVMConstAShr(te1, te2) }\n-                else      { llvm::LLVMConstLShr(te1, te2) }\n-              }\n-              ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGt | ast::BiGe => {\n-                  if is_float {\n-                      let cmp = base::bin_op_to_fcmp_predicate(cx, b.node);\n-                      ConstFCmp(cmp, te1, te2)\n-                  } else {\n-                      let cmp = base::bin_op_to_icmp_predicate(cx, b.node, signed);\n-                      let bool_val = ConstICmp(cmp, te1, te2);\n-                      if is_simd {\n-                          // LLVM outputs an `< size x i1 >`, so we need to perform\n-                          // a sign extension to get the correctly sized type.\n-                          llvm::LLVMConstIntCast(bool_val, val_ty(te1).to_ref(), True)\n-                      } else {\n-                          bool_val\n-                      }\n-                  }\n-              }\n-            }\n-          },\n-          ast::ExprUnary(u, ref inner_e) => {\n+            unsafe { match b.node {\n+                ast::BiAdd if is_float => llvm::LLVMConstFAdd(te1, te2),\n+                ast::BiAdd             => llvm::LLVMConstAdd(te1, te2),\n+\n+                ast::BiSub if is_float => llvm::LLVMConstFSub(te1, te2),\n+                ast::BiSub             => llvm::LLVMConstSub(te1, te2),\n+\n+                ast::BiMul if is_float => llvm::LLVMConstFMul(te1, te2),\n+                ast::BiMul             => llvm::LLVMConstMul(te1, te2),\n+\n+                ast::BiDiv if is_float => llvm::LLVMConstFDiv(te1, te2),\n+                ast::BiDiv if signed   => llvm::LLVMConstSDiv(te1, te2),\n+                ast::BiDiv             => llvm::LLVMConstUDiv(te1, te2),\n+\n+                ast::BiRem if is_float => llvm::LLVMConstFRem(te1, te2),\n+                ast::BiRem if signed   => llvm::LLVMConstSRem(te1, te2),\n+                ast::BiRem             => llvm::LLVMConstURem(te1, te2),\n+\n+                ast::BiAnd    => llvm::LLVMConstAnd(te1, te2),\n+                ast::BiOr     => llvm::LLVMConstOr(te1, te2),\n+                ast::BiBitXor => llvm::LLVMConstXor(te1, te2),\n+                ast::BiBitAnd => llvm::LLVMConstAnd(te1, te2),\n+                ast::BiBitOr  => llvm::LLVMConstOr(te1, te2),\n+                ast::BiShl    => {\n+                    let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n+                    llvm::LLVMConstShl(te1, te2)\n+                },\n+                ast::BiShr    => {\n+                    let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n+                    if signed { llvm::LLVMConstAShr(te1, te2) }\n+                    else      { llvm::LLVMConstLShr(te1, te2) }\n+                },\n+                ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGt | ast::BiGe => {\n+                    if is_float {\n+                        let cmp = base::bin_op_to_fcmp_predicate(cx, b.node);\n+                        ConstFCmp(cmp, te1, te2)\n+                    } else {\n+                        let cmp = base::bin_op_to_icmp_predicate(cx, b.node, signed);\n+                        let bool_val = ConstICmp(cmp, te1, te2);\n+                        if is_simd {\n+                            // LLVM outputs an `< size x i1 >`, so we need to perform\n+                            // a sign extension to get the correctly sized type.\n+                            llvm::LLVMConstIntCast(bool_val, val_ty(te1).to_ref(), True)\n+                        } else {\n+                            bool_val\n+                        }\n+                    }\n+                },\n+            } } // unsafe { match b.node {\n+        },\n+        ast::ExprUnary(u, ref inner_e) => {\n             let (te, ty) = const_expr(cx, &**inner_e, param_substs, fn_args);\n \n             check_unary_expr_validity(cx, e, ty, te);\n \n             let is_float = ty.is_fp();\n-            match u {\n-              ast::UnUniq | ast::UnDeref => {\n-                const_deref(cx, te, ty).0\n-              }\n-              ast::UnNot    => llvm::LLVMConstNot(te),\n-              ast::UnNeg    => {\n-                if is_float { llvm::LLVMConstFNeg(te) }\n-                else        { llvm::LLVMConstNeg(te) }\n-              }\n+            unsafe { match u {\n+                ast::UnUniq | ast::UnDeref => const_deref(cx, te, ty).0,\n+                ast::UnNot                 => llvm::LLVMConstNot(te),\n+                ast::UnNeg if is_float     => llvm::LLVMConstFNeg(te),\n+                ast::UnNeg                 => llvm::LLVMConstNeg(te),\n+            } }\n+        },\n+        ast::ExprField(ref base, field) => {\n+            let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n+            let brepr = adt::represent_type(cx, bt);\n+            expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n+                let ix = cx.tcx().field_idx_strict(field.node.name, field_tys);\n+                adt::const_get_field(cx, &*brepr, bv, discr, ix)\n+            })\n+        },\n+        ast::ExprTupField(ref base, idx) => {\n+            let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n+            let brepr = adt::represent_type(cx, bt);\n+            expr::with_field_tys(cx.tcx(), bt, None, |discr, _| {\n+                adt::const_get_field(cx, &*brepr, bv, discr, idx.node)\n+            })\n+        },\n+\n+        ast::ExprIndex(ref base, ref index) => {\n+            let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n+            let iv = match const_eval::eval_const_expr_partial(cx.tcx(), &**index, None) {\n+                Ok(ConstVal::Int(i)) => i as u64,\n+                Ok(ConstVal::Uint(u)) => u,\n+                _ => cx.sess().span_bug(index.span,\n+                                        \"index is not an integer-constant expression\")\n+            };\n+            let (arr, len) = match bt.sty {\n+                ty::TyArray(_, u) => (bv, C_uint(cx, u)),\n+                ty::TySlice(_) | ty::TyStr => {\n+                    let e1 = const_get_elt(cx, bv, &[0]);\n+                    (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n+                },\n+                ty::TyRef(_, mt) => match mt.ty.sty {\n+                    ty::TyArray(_, u) => {\n+                        (const_deref_ptr(cx, bv), C_uint(cx, u))\n+                    },\n+                    _ => cx.sess().span_bug(base.span,\n+                                            &format!(\"index-expr base must be a vector \\\n+                                                      or string type, found {:?}\",\n+                                                     bt)),\n+                },\n+                _ => cx.sess().span_bug(base.span,\n+                                        &format!(\"index-expr base must be a vector \\\n+                                                  or string type, found {:?}\",\n+                                                 bt)),\n+            };\n+\n+            let len = unsafe { llvm::LLVMConstIntGetZExtValue(len) as u64 };\n+            let len = match bt.sty {\n+                ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) => match ty.sty {\n+                    ty::TyStr => {\n+                        assert!(len > 0);\n+                        len - 1\n+                    },\n+                    _ => len,\n+                },\n+                _ => len,\n+            };\n+            if iv >= len {\n+                // FIXME #3170: report this earlier on in the const-eval\n+                // pass. Reporting here is a bit late.\n+                cx.sess().span_err(e.span,\n+                                   \"const index-expr is out of bounds\");\n+                C_undef(type_of::type_of(cx, bt).element_type())\n+            } else {\n+                const_get_elt(cx, arr, &[iv as c_uint])\n             }\n-          }\n-          ast::ExprField(ref base, field) => {\n-              let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n-              let brepr = adt::represent_type(cx, bt);\n-              expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n-                  let ix = cx.tcx().field_idx_strict(field.node.name, field_tys);\n-                  adt::const_get_field(cx, &*brepr, bv, discr, ix)\n-              })\n-          }\n-          ast::ExprTupField(ref base, idx) => {\n-              let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n-              let brepr = adt::represent_type(cx, bt);\n-              expr::with_field_tys(cx.tcx(), bt, None, |discr, _| {\n-                  adt::const_get_field(cx, &*brepr, bv, discr, idx.node)\n-              })\n-          }\n-\n-          ast::ExprIndex(ref base, ref index) => {\n-              let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n-              let iv = match const_eval::eval_const_expr_partial(cx.tcx(), &**index, None) {\n-                  Ok(ConstVal::Int(i)) => i as u64,\n-                  Ok(ConstVal::Uint(u)) => u,\n-                  _ => cx.sess().span_bug(index.span,\n-                                          \"index is not an integer-constant expression\")\n-              };\n-              let (arr, len) = match bt.sty {\n-                  ty::TyArray(_, u) => (bv, C_uint(cx, u)),\n-                  ty::TySlice(_) | ty::TyStr => {\n-                      let e1 = const_get_elt(cx, bv, &[0]);\n-                      (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n-                  }\n-                  ty::TyRef(_, mt) => match mt.ty.sty {\n-                      ty::TyArray(_, u) => {\n-                          (const_deref_ptr(cx, bv), C_uint(cx, u))\n-                      },\n-                      _ => cx.sess().span_bug(base.span,\n-                                              &format!(\"index-expr base must be a vector \\\n-                                                       or string type, found {:?}\",\n-                                                      bt))\n-                  },\n-                  _ => cx.sess().span_bug(base.span,\n-                                          &format!(\"index-expr base must be a vector \\\n-                                                   or string type, found {:?}\",\n-                                                  bt))\n-              };\n-\n-              let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n-              let len = match bt.sty {\n-                  ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) => match ty.sty {\n-                      ty::TyStr => {\n-                          assert!(len > 0);\n-                          len - 1\n-                      }\n-                      _ => len\n-                  },\n-                  _ => len\n-              };\n-              if iv >= len {\n-                  // FIXME #3170: report this earlier on in the const-eval\n-                  // pass. Reporting here is a bit late.\n-                  cx.sess().span_err(e.span,\n-                                     \"const index-expr is out of bounds\");\n-                  C_undef(type_of::type_of(cx, bt).element_type())\n-              } else {\n-                  const_get_elt(cx, arr, &[iv as c_uint])\n-              }\n-          }\n-          ast::ExprCast(ref base, _) => {\n+        },\n+        ast::ExprCast(ref base, _) => {\n             let t_cast = ety;\n             let llty = type_of::type_of(cx, t_cast);\n             let (v, t_expr) = const_expr(cx, &**base, param_substs, fn_args);\n@@ -671,136 +661,121 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     return addr;\n                 }\n             }\n-            match (CastTy::from_ty(cx.tcx(), t_expr).expect(\"bad input type for cast\"),\n-                   CastTy::from_ty(cx.tcx(), t_cast).expect(\"bad output type for cast\")) {\n-              (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n-                let repr = adt::represent_type(cx, t_expr);\n-                let discr = adt::const_get_discrim(cx, &*repr, v);\n-                let iv = C_integral(cx.int_type(), discr, false);\n-                let s = adt::is_discr_signed(&*repr) as Bool;\n-                llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n-              }\n-              (CastTy::Int(_), CastTy::Int(_)) => {\n-                let s = t_expr.is_signed() as Bool;\n-                llvm::LLVMConstIntCast(v, llty.to_ref(), s)\n-              }\n-              (CastTy::Int(_), CastTy::Float) => {\n-                if t_expr.is_signed() {\n-                    llvm::LLVMConstSIToFP(v, llty.to_ref())\n-                } else {\n-                    llvm::LLVMConstUIToFP(v, llty.to_ref())\n-                }\n-              }\n-              (CastTy::Float, CastTy::Float) => {\n-                llvm::LLVMConstFPCast(v, llty.to_ref())\n-              }\n-              (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                llvm::LLVMConstFPToSI(v, llty.to_ref())\n-              }\n-              (CastTy::Float, CastTy::Int(_)) => {\n-                llvm::LLVMConstFPToUI(v, llty.to_ref())\n-              }\n-              (CastTy::Ptr(_), CastTy::Ptr(_)) | (CastTy::FnPtr, CastTy::Ptr(_))\n-                    | (CastTy::RPtr(_), CastTy::Ptr(_)) => {\n-                ptrcast(v, llty)\n-              }\n-              (CastTy::FnPtr, CastTy::FnPtr) => ptrcast(v, llty), // isn't this a coercion?\n-              (CastTy::Int(_), CastTy::Ptr(_)) => {\n-                llvm::LLVMConstIntToPtr(v, llty.to_ref())\n-              }\n-              (CastTy::Ptr(_), CastTy::Int(_)) | (CastTy::FnPtr, CastTy::Int(_)) => {\n-                llvm::LLVMConstPtrToInt(v, llty.to_ref())\n-              }\n-              _ => {\n-                cx.sess().impossible_case(e.span,\n-                                          \"bad combination of types for cast\")\n-              }\n-            }\n-          }\n-          ast::ExprAddrOf(ast::MutImmutable, ref sub) => {\n-              // If this is the address of some static, then we need to return\n-              // the actual address of the static itself (short circuit the rest\n-              // of const eval).\n-              let mut cur = sub;\n-              loop {\n-                  match cur.node {\n-                      ast::ExprParen(ref sub) => cur = sub,\n-                      ast::ExprBlock(ref blk) => {\n+            unsafe { match (\n+                CastTy::from_ty(cx.tcx(), t_expr).expect(\"bad input type for cast\"),\n+                CastTy::from_ty(cx.tcx(), t_cast).expect(\"bad output type for cast\"),\n+            ) {\n+                (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n+                    let repr = adt::represent_type(cx, t_expr);\n+                    let discr = adt::const_get_discrim(cx, &*repr, v);\n+                    let iv = C_integral(cx.int_type(), discr, false);\n+                    let s = adt::is_discr_signed(&*repr) as Bool;\n+                    llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n+                },\n+                (CastTy::Int(_), CastTy::Int(_)) => {\n+                    let s = t_expr.is_signed() as Bool;\n+                    llvm::LLVMConstIntCast(v, llty.to_ref(), s)\n+                },\n+                (CastTy::Int(_), CastTy::Float) => {\n+                    if t_expr.is_signed() {\n+                        llvm::LLVMConstSIToFP(v, llty.to_ref())\n+                    } else {\n+                        llvm::LLVMConstUIToFP(v, llty.to_ref())\n+                    }\n+                },\n+                (CastTy::Float, CastTy::Float) => llvm::LLVMConstFPCast(v, llty.to_ref()),\n+                (CastTy::Float, CastTy::Int(IntTy::I)) => llvm::LLVMConstFPToSI(v, llty.to_ref()),\n+                (CastTy::Float, CastTy::Int(_)) => llvm::LLVMConstFPToUI(v, llty.to_ref()),\n+                (CastTy::Ptr(_), CastTy::Ptr(_)) | (CastTy::FnPtr, CastTy::Ptr(_))\n+                | (CastTy::RPtr(_), CastTy::Ptr(_)) => {\n+                    ptrcast(v, llty)\n+                },\n+                (CastTy::FnPtr, CastTy::FnPtr) => ptrcast(v, llty), // isn't this a coercion?\n+                (CastTy::Int(_), CastTy::Ptr(_)) => llvm::LLVMConstIntToPtr(v, llty.to_ref()),\n+                (CastTy::Ptr(_), CastTy::Int(_)) | (CastTy::FnPtr, CastTy::Int(_)) => {\n+                  llvm::LLVMConstPtrToInt(v, llty.to_ref())\n+                },\n+                _ => {\n+                  cx.sess().impossible_case(e.span,\n+                                            \"bad combination of types for cast\")\n+                },\n+            } } // unsafe { match ( ... ) {\n+        },\n+        ast::ExprAddrOf(ast::MutImmutable, ref sub) => {\n+            // If this is the address of some static, then we need to return\n+            // the actual address of the static itself (short circuit the rest\n+            // of const eval).\n+            let mut cur = sub;\n+            loop {\n+                match cur.node {\n+                    ast::ExprParen(ref sub) => cur = sub,\n+                    ast::ExprBlock(ref blk) => {\n                         if let Some(ref sub) = blk.expr {\n                             cur = sub;\n                         } else {\n                             break;\n                         }\n-                      }\n-                      _ => break,\n-                  }\n-              }\n-              let opt_def = cx.tcx().def_map.borrow().get(&cur.id).map(|d| d.full_def());\n-              if let Some(def::DefStatic(def_id, _)) = opt_def {\n-                  get_static_val(cx, def_id, ety)\n-              } else {\n-                  // If this isn't the address of a static, then keep going through\n-                  // normal constant evaluation.\n-                  let (v, _) = const_expr(cx, &**sub, param_substs, fn_args);\n-                  addr_of(cx, v, \"ref\")\n-              }\n-          }\n-          ast::ExprAddrOf(ast::MutMutable, ref sub) => {\n-              let (v, _) = const_expr(cx, &**sub, param_substs, fn_args);\n-              addr_of_mut(cx, v, \"ref_mut_slice\")\n-          }\n-          ast::ExprTup(ref es) => {\n-              let repr = adt::represent_type(cx, ety);\n-              let vals = map_list(&es[..]);\n-              adt::trans_const(cx, &*repr, 0, &vals[..])\n-          }\n-          ast::ExprStruct(_, ref fs, ref base_opt) => {\n-              let repr = adt::represent_type(cx, ety);\n-\n-              let base_val = match *base_opt {\n+                    },\n+                    _ => break,\n+                }\n+            }\n+            let opt_def = cx.tcx().def_map.borrow().get(&cur.id).map(|d| d.full_def());\n+            if let Some(def::DefStatic(def_id, _)) = opt_def {\n+                get_static_val(cx, def_id, ety)\n+            } else {\n+                // If this isn't the address of a static, then keep going through\n+                // normal constant evaluation.\n+                let (v, _) = const_expr(cx, &**sub, param_substs, fn_args);\n+                addr_of(cx, v, \"ref\")\n+            }\n+        },\n+        ast::ExprAddrOf(ast::MutMutable, ref sub) => {\n+            let (v, _) = const_expr(cx, &**sub, param_substs, fn_args);\n+            addr_of_mut(cx, v, \"ref_mut_slice\")\n+        },\n+        ast::ExprTup(ref es) => {\n+            let repr = adt::represent_type(cx, ety);\n+            let vals = map_list(&es[..]);\n+            adt::trans_const(cx, &*repr, 0, &vals[..])\n+        },\n+        ast::ExprStruct(_, ref fs, ref base_opt) => {\n+            let repr = adt::represent_type(cx, ety);\n+\n+            let base_val = match *base_opt {\n                 Some(ref base) => Some(const_expr(cx, &**base, param_substs, fn_args)),\n                 None => None\n-              };\n-\n-              expr::with_field_tys(cx.tcx(), ety, Some(e.id), |discr, field_tys| {\n-                  let cs = field_tys.iter().enumerate()\n-                                    .map(|(ix, &field_ty)| {\n-                      match fs.iter().find(|f| field_ty.name == f.ident.node.name) {\n-                          Some(ref f) => const_expr(cx, &*f.expr, param_substs, fn_args).0,\n-                          None => {\n-                              match base_val {\n-                                  Some((bv, _)) => {\n-                                      adt::const_get_field(cx, &*repr, bv,\n-                                                           discr, ix)\n-                                  }\n-                                  None => {\n-                                      cx.sess().span_bug(e.span,\n-                                                         \"missing struct field\")\n-                                  }\n-                              }\n-                          }\n-                      }\n-                  }).collect::<Vec<_>>();\n-                  if ety.is_simd(cx.tcx()) {\n-                      C_vector(&cs[..])\n-                  } else {\n-                      adt::trans_const(cx, &*repr, discr, &cs[..])\n-                  }\n-              })\n-          }\n-          ast::ExprVec(ref es) => {\n+            };\n+\n+            expr::with_field_tys(cx.tcx(), ety, Some(e.id), |discr, field_tys| {\n+                let cs = field_tys.iter().enumerate()\n+                                  .map(|(ix, &field_ty)| {\n+                    match (fs.iter().find(|f| field_ty.name == f.ident.node.name), base_val) {\n+                        (Some(ref f), _) => const_expr(cx, &*f.expr, param_substs, fn_args).0,\n+                        (_, Some((bv, _))) => adt::const_get_field(cx, &*repr, bv, discr, ix),\n+                        (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),\n+                    }\n+                }).collect::<Vec<_>>();\n+                if ety.is_simd(cx.tcx()) {\n+                    C_vector(&cs[..])\n+                } else {\n+                    adt::trans_const(cx, &*repr, discr, &cs[..])\n+                }\n+            })\n+        },\n+        ast::ExprVec(ref es) => {\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let vs = es.iter().map(|e| const_expr(cx, &**e, param_substs, fn_args).0)\n-                              .collect::<Vec<_>>();\n+            let vs = es.iter()\n+                       .map(|e| const_expr(cx, &**e, param_substs, fn_args).0)\n+                       .collect::<Vec<_>>();\n             // If the vector contains enums, an LLVM array won't work.\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, &vs[..], false)\n             } else {\n                 C_array(llunitty, &vs[..])\n             }\n-          }\n-          ast::ExprRepeat(ref elem, ref count) => {\n+        },\n+        ast::ExprRepeat(ref elem, ref count) => {\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = cx.tcx().eval_repeat_count(count);\n@@ -811,8 +786,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } else {\n                 C_array(llunitty, &vs[..])\n             }\n-          }\n-          ast::ExprPath(..) => {\n+        },\n+        ast::ExprPath(..) => {\n             let def = cx.tcx().def_map.borrow().get(&e.id).unwrap().full_def();\n             match def {\n                 def::DefLocal(id) => {\n@@ -853,69 +828,68 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                 or variant def\")\n                 }\n             }\n-          }\n-          ast::ExprCall(ref callee, ref args) => {\n-              let mut callee = &**callee;\n-              loop {\n-                  callee = match callee.node {\n-                      ast::ExprParen(ref inner) => &**inner,\n-                      ast::ExprBlock(ref block) => match block.expr {\n-                          Some(ref tail) => &**tail,\n-                          None => break\n-                      },\n-                      _ => break\n-                  };\n-              }\n-              let def = cx.tcx().def_map.borrow()[&callee.id].full_def();\n-              let arg_vals = map_list(args);\n-              match def {\n-                  def::DefFn(did, _) | def::DefMethod(did, _) => {\n-                      const_fn_call(cx, ExprId(callee.id), did, &arg_vals, param_substs)\n-                  }\n-                  def::DefStruct(_) => {\n-                      if ety.is_simd(cx.tcx()) {\n-                          C_vector(&arg_vals[..])\n-                      } else {\n-                          let repr = adt::represent_type(cx, ety);\n-                          adt::trans_const(cx, &*repr, 0, &arg_vals[..])\n-                      }\n-                  }\n-                  def::DefVariant(enum_did, variant_did, _) => {\n-                      let repr = adt::represent_type(cx, ety);\n-                      let vinfo = cx.tcx().enum_variant_with_id(enum_did, variant_did);\n-                      adt::trans_const(cx,\n-                                       &*repr,\n-                                       vinfo.disr_val,\n-                                       &arg_vals[..])\n-                  }\n-                  _ => cx.sess().span_bug(e.span, \"expected a struct, variant, or const fn def\")\n-              }\n-          }\n-          ast::ExprMethodCall(_, _, ref args) => {\n-              let arg_vals = map_list(args);\n-              let method_call = ty::MethodCall::expr(e.id);\n+        },\n+        ast::ExprCall(ref callee, ref args) => {\n+            let mut callee = &**callee;\n+            loop {\n+                callee = match callee.node {\n+                    ast::ExprParen(ref inner) => &**inner,\n+                    ast::ExprBlock(ref block) => match block.expr {\n+                        Some(ref tail) => &**tail,\n+                        None => break,\n+                    },\n+                    _ => break,\n+                };\n+            }\n+            let def = cx.tcx().def_map.borrow()[&callee.id].full_def();\n+            let arg_vals = map_list(args);\n+            match def {\n+                def::DefFn(did, _) | def::DefMethod(did, _) => {\n+                    const_fn_call(cx, ExprId(callee.id), did, &arg_vals, param_substs)\n+                },\n+                def::DefStruct(_) => {\n+                    if ety.is_simd(cx.tcx()) {\n+                        C_vector(&arg_vals[..])\n+                    } else {\n+                        let repr = adt::represent_type(cx, ety);\n+                        adt::trans_const(cx, &*repr, 0, &arg_vals[..])\n+                    }\n+                },\n+                def::DefVariant(enum_did, variant_did, _) => {\n+                    let repr = adt::represent_type(cx, ety);\n+                    let vinfo = cx.tcx().enum_variant_with_id(enum_did, variant_did);\n+                    adt::trans_const(cx,\n+                                     &*repr,\n+                                     vinfo.disr_val,\n+                                     &arg_vals[..])\n+                },\n+                _ => cx.sess().span_bug(e.span, \"expected a struct, variant, or const fn def\"),\n+            }\n+        },\n+        ast::ExprMethodCall(_, _, ref args) => {\n+            let arg_vals = map_list(args);\n+            let method_call = ty::MethodCall::expr(e.id);\n               let method_did = cx.tcx().tables.borrow().method_map[&method_call].def_id;\n-              const_fn_call(cx, MethodCallKey(method_call),\n-                            method_did, &arg_vals, param_substs)\n-          }\n-          ast::ExprParen(ref e) => const_expr(cx, &**e, param_substs, fn_args).0,\n-          ast::ExprBlock(ref block) => {\n+            const_fn_call(cx, MethodCallKey(method_call),\n+                          method_did, &arg_vals, param_substs)\n+        },\n+        ast::ExprParen(ref e) => const_expr(cx, &**e, param_substs, fn_args).0,\n+        ast::ExprBlock(ref block) => {\n             match block.expr {\n                 Some(ref expr) => const_expr(cx, &**expr, param_substs, fn_args).0,\n-                None => C_nil(cx)\n+                None => C_nil(cx),\n             }\n-          }\n-          ast::ExprClosure(_, ref decl, ref body) => {\n+        },\n+        ast::ExprClosure(_, ref decl, ref body) => {\n             closure::trans_closure_expr(closure::Dest::Ignore(cx),\n                                         decl,\n                                         body,\n                                         e.id,\n                                         param_substs);\n             C_null(type_of::type_of(cx, ety))\n-          }\n-          _ => cx.sess().span_bug(e.span,\n-                  \"bad constant expression type in consts::const_expr\")\n-        }\n+        },\n+        _ => cx.sess().span_bug(e.span,\n+                                \"bad constant expression type in consts::const_expr\"),\n     }\n }\n "}]}