{"sha": "a0d2f71e8e64d7994f20932caedab1b8dccc5539", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZDJmNzFlOGU2NGQ3OTk0ZjIwOTMyY2FlZGFiMWI4ZGNjYzU1Mzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-06T20:22:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-09T18:24:15Z"}, "message": "Implement io::native::process", "tree": {"sha": "1c67912fd5a9a1484d353a6180d81cc471a4db65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c67912fd5a9a1484d353a6180d81cc471a4db65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0d2f71e8e64d7994f20932caedab1b8dccc5539", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0d2f71e8e64d7994f20932caedab1b8dccc5539", "html_url": "https://github.com/rust-lang/rust/commit/a0d2f71e8e64d7994f20932caedab1b8dccc5539", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0d2f71e8e64d7994f20932caedab1b8dccc5539/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edf4c16997af6af08ef734ad34eccc5aa279595a", "url": "https://api.github.com/repos/rust-lang/rust/commits/edf4c16997af6af08ef734ad34eccc5aa279595a", "html_url": "https://github.com/rust-lang/rust/commit/edf4c16997af6af08ef734ad34eccc5aa279595a"}], "stats": {"total": 754, "additions": 753, "deletions": 1}, "files": [{"sha": "829916117d2667142d41d6a242970398da1b650f", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2f71e8e64d7994f20932caedab1b8dccc5539/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2f71e8e64d7994f20932caedab1b8dccc5539/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=a0d2f71e8e64d7994f20932caedab1b8dccc5539", "patch": "@@ -57,7 +57,7 @@ pub fn run(lib_path: &str,\n     });\n \n     for input in input.iter() {\n-        proc.input().write_str(*input);\n+        proc.input().write(input.as_bytes());\n     }\n     let output = proc.finish_with_output();\n "}, {"sha": "d338192c664bca23cf57abfca8d7a8c0fb8da5ad", "filename": "src/libstd/rt/io/native/process.rs", "status": "added", "additions": 745, "deletions": 0, "changes": 745, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2f71e8e64d7994f20932caedab1b8dccc5539/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2f71e8e64d7994f20932caedab1b8dccc5539/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs?ref=a0d2f71e8e64d7994f20932caedab1b8dccc5539", "patch": "@@ -0,0 +1,745 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast;\n+use libc::{pid_t, c_void, c_int};\n+use libc;\n+use os;\n+use prelude::*;\n+use ptr;\n+use rt::io;\n+use super::file;\n+\n+/**\n+ * A value representing a child process.\n+ *\n+ * The lifetime of this value is linked to the lifetime of the actual\n+ * process - the Process destructor calls self.finish() which waits\n+ * for the process to terminate.\n+ */\n+pub struct Process {\n+    /// The unique id of the process (this should never be negative).\n+    priv pid: pid_t,\n+\n+    /// A handle to the process - on unix this will always be NULL, but on\n+    /// windows it will be a HANDLE to the process, which will prevent the\n+    /// pid being re-used until the handle is closed.\n+    priv handle: *(),\n+\n+    /// Currently known stdin of the child, if any\n+    priv input: Option<file::FileDesc>,\n+    /// Currently known stdout of the child, if any\n+    priv output: Option<file::FileDesc>,\n+    /// Currently known stderr of the child, if any\n+    priv error: Option<file::FileDesc>,\n+\n+    /// None until finish() is called.\n+    priv exit_code: Option<int>,\n+}\n+\n+impl Process {\n+    /// Creates a new process using native process-spawning abilities provided\n+    /// by the OS. Operations on this process will be blocking instead of using\n+    /// the runtime for sleeping just this current task.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * prog - the program to run\n+    /// * args - the arguments to pass to the program, not including the program\n+    ///          itself\n+    /// * env - an optional envrionment to specify for the child process. If\n+    ///         this value is `None`, then the child will inherit the parent's\n+    ///         environment\n+    /// * cwd - an optionally specified current working directory of the child,\n+    ///         defaulting to the parent's current working directory\n+    /// * stdin, stdout, stderr - These optionally specified file descriptors\n+    ///     dictate where the stdin/out/err of the child process will go. If\n+    ///     these are `None`, then this module will bind the input/output to an\n+    ///     os pipe instead. This process takes ownership of these file\n+    ///     descriptors, closing them upon destruction of the process.\n+    pub fn new(prog: &str, args: &[~str], env: Option<~[(~str, ~str)]>,\n+               cwd: Option<&Path>,\n+               stdin: Option<file::fd_t>,\n+               stdout: Option<file::fd_t>,\n+               stderr: Option<file::fd_t>) -> Process {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        let (in_pipe, in_fd) = match stdin {\n+            None => {\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.input)\n+            },\n+            Some(fd) => (None, fd)\n+        };\n+        let (out_pipe, out_fd) = match stdout {\n+            None => {\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.out)\n+            },\n+            Some(fd) => (None, fd)\n+        };\n+        let (err_pipe, err_fd) = match stderr {\n+            None => {\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.out)\n+            },\n+            Some(fd) => (None, fd)\n+        };\n+\n+        let res = spawn_process_os(prog, args, env, cwd,\n+                                   in_fd, out_fd, err_fd);\n+\n+        unsafe {\n+            for pipe in in_pipe.iter() { libc::close(pipe.input); }\n+            for pipe in out_pipe.iter() { libc::close(pipe.out); }\n+            for pipe in err_pipe.iter() { libc::close(pipe.out); }\n+        }\n+\n+        Process {\n+            pid: res.pid,\n+            handle: res.handle,\n+            input: in_pipe.map(|pipe| file::FileDesc::new(pipe.out)),\n+            output: out_pipe.map(|pipe| file::FileDesc::new(pipe.input)),\n+            error: err_pipe.map(|pipe| file::FileDesc::new(pipe.input)),\n+            exit_code: None,\n+        }\n+    }\n+\n+    /// Returns the unique id of the process\n+    pub fn id(&self) -> pid_t { self.pid }\n+\n+    /**\n+     * Returns an io::Writer that can be used to write to this Process's stdin.\n+     *\n+     * Fails if there is no stdinavailable (it's already been removed by\n+     * take_input)\n+     */\n+    pub fn input<'a>(&'a mut self) -> &'a mut io::Writer {\n+        match self.input {\n+            Some(ref mut fd) => fd as &mut io::Writer,\n+            None => fail2!(\"This process has no stdin\")\n+        }\n+    }\n+\n+    /**\n+     * Returns an io::Reader that can be used to read from this Process's\n+     * stdout.\n+     *\n+     * Fails if there is no stdin available (it's already been removed by\n+     * take_output)\n+     */\n+    pub fn output<'a>(&'a mut self) -> &'a mut io::Reader {\n+        match self.input {\n+            Some(ref mut fd) => fd as &mut io::Reader,\n+            None => fail2!(\"This process has no stdout\")\n+        }\n+    }\n+\n+    /**\n+     * Returns an io::Reader that can be used to read from this Process's\n+     * stderr.\n+     *\n+     * Fails if there is no stdin available (it's already been removed by\n+     * take_error)\n+     */\n+    pub fn error<'a>(&'a mut self) -> &'a mut io::Reader {\n+        match self.error {\n+            Some(ref mut fd) => fd as &mut io::Reader,\n+            None => fail2!(\"This process has no stderr\")\n+        }\n+    }\n+\n+    /**\n+     * Takes the stdin of this process, transferring ownership to the caller.\n+     * Note that when the return value is destroyed, the handle will be closed\n+     * for the child process.\n+     */\n+    pub fn take_input(&mut self) -> Option<~io::Writer> {\n+        self.input.take().map(|fd| ~fd as ~io::Writer)\n+    }\n+\n+    /**\n+     * Takes the stdout of this process, transferring ownership to the caller.\n+     * Note that when the return value is destroyed, the handle will be closed\n+     * for the child process.\n+     */\n+    pub fn take_output(&mut self) -> Option<~io::Reader> {\n+        self.output.take().map(|fd| ~fd as ~io::Reader)\n+    }\n+\n+    /**\n+     * Takes the stderr of this process, transferring ownership to the caller.\n+     * Note that when the return value is destroyed, the handle will be closed\n+     * for the child process.\n+     */\n+    pub fn take_error(&mut self) -> Option<~io::Reader> {\n+        self.error.take().map(|fd| ~fd as ~io::Reader)\n+    }\n+\n+    pub fn wait(&mut self) -> int {\n+        for &code in self.exit_code.iter() {\n+            return code;\n+        }\n+        let code = waitpid(self.pid);\n+        self.exit_code = Some(code);\n+        return code;\n+    }\n+\n+    pub fn signal(&mut self, signum: int) -> Result<(), io::IoError> {\n+        // if the process has finished, and therefore had waitpid called,\n+        // and we kill it, then on unix we might ending up killing a\n+        // newer process that happens to have the same (re-used) id\n+        match self.exit_code {\n+            Some(*) => return Err(io::IoError {\n+                kind: io::OtherIoError,\n+                desc: \"can't kill an exited process\",\n+                detail: None,\n+            }),\n+            None => {}\n+        }\n+        return unsafe { killpid(self.pid, signum) };\n+\n+        #[cfg(windows)]\n+        unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            match signal {\n+                io::process::PleaseExitSignal |\n+                io::process::MustDieSignal => {\n+                    libc::funcs::extra::kernel32::TerminateProcess(\n+                        cast::transmute(pid), 1);\n+                    Ok(())\n+                }\n+                _ => Err(io::IoError {\n+                    kind: io::OtherIoError,\n+                    desc: \"unsupported signal on windows\",\n+                    detail: None,\n+                })\n+            }\n+        }\n+\n+        #[cfg(not(windows))]\n+        unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            libc::funcs::posix88::signal::kill(pid, signal as c_int);\n+            Ok(())\n+        }\n+    }\n+}\n+\n+impl Drop for Process {\n+    fn drop(&mut self) {\n+        // close all these handles\n+        self.take_input();\n+        self.take_output();\n+        self.take_error();\n+        self.wait();\n+        free_handle(self.handle);\n+    }\n+}\n+\n+struct SpawnProcessResult {\n+    pid: pid_t,\n+    handle: *(),\n+}\n+\n+#[cfg(windows)]\n+fn spawn_process_os(prog: &str, args: &[~str],\n+                    env: Option<~[(~str, ~str)]>,\n+                    dir: Option<&Path>,\n+                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n+    use libc::consts::os::extra::{\n+        TRUE, FALSE,\n+        STARTF_USESTDHANDLES,\n+        INVALID_HANDLE_VALUE,\n+        DUPLICATE_SAME_ACCESS\n+    };\n+    use libc::funcs::extra::kernel32::{\n+        GetCurrentProcess,\n+        DuplicateHandle,\n+        CloseHandle,\n+        CreateProcessA\n+    };\n+    use libc::funcs::extra::msvcrt::get_osfhandle;\n+\n+    use sys;\n+\n+    unsafe {\n+\n+        let mut si = zeroed_startupinfo();\n+        si.cb = sys::size_of::<STARTUPINFO>() as DWORD;\n+        si.dwFlags = STARTF_USESTDHANDLES;\n+\n+        let cur_proc = GetCurrentProcess();\n+\n+        let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n+        if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n+            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+        }\n+\n+        let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n+        if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n+            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+        }\n+\n+        let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n+        if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n+            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+        }\n+\n+        let cmd = make_command_line(prog, args);\n+        let mut pi = zeroed_process_information();\n+        let mut create_err = None;\n+\n+        do with_envp(env) |envp| {\n+            do with_dirp(dir) |dirp| {\n+                do cmd.with_c_str |cmdp| {\n+                    let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n+                                                 ptr::mut_null(), ptr::mut_null(), TRUE,\n+                                                 0, envp, dirp, &mut si, &mut pi);\n+                    if created == FALSE {\n+                        create_err = Some(os::last_os_error());\n+                    }\n+                }\n+            }\n+        }\n+\n+        CloseHandle(si.hStdInput);\n+        CloseHandle(si.hStdOutput);\n+        CloseHandle(si.hStdError);\n+\n+        for msg in create_err.iter() {\n+            fail2!(\"failure in CreateProcess: {}\", *msg);\n+        }\n+\n+        // We close the thread handle because we don't care about keeping the\n+        // thread id valid, and we aren't keeping the thread handle around to be\n+        // able to close it later. We don't close the process handle however\n+        // because we want the process id to stay valid at least until the\n+        // calling code closes the process handle.\n+        CloseHandle(pi.hThread);\n+\n+        SpawnProcessResult {\n+            pid: pi.dwProcessId as pid_t,\n+            handle: pi.hProcess as *()\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n+    libc::types::os::arch::extra::STARTUPINFO {\n+        cb: 0,\n+        lpReserved: ptr::mut_null(),\n+        lpDesktop: ptr::mut_null(),\n+        lpTitle: ptr::mut_null(),\n+        dwX: 0,\n+        dwY: 0,\n+        dwXSize: 0,\n+        dwYSize: 0,\n+        dwXCountChars: 0,\n+        dwYCountCharts: 0,\n+        dwFillAttribute: 0,\n+        dwFlags: 0,\n+        wShowWindow: 0,\n+        cbReserved2: 0,\n+        lpReserved2: ptr::mut_null(),\n+        hStdInput: ptr::mut_null(),\n+        hStdOutput: ptr::mut_null(),\n+        hStdError: ptr::mut_null()\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n+    libc::types::os::arch::extra::PROCESS_INFORMATION {\n+        hProcess: ptr::mut_null(),\n+        hThread: ptr::mut_null(),\n+        dwProcessId: 0,\n+        dwThreadId: 0\n+    }\n+}\n+\n+// FIXME: this is only pub so it can be tested (see issue #4536)\n+#[cfg(windows)]\n+pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n+    let mut cmd = ~\"\";\n+    append_arg(&mut cmd, prog);\n+    for arg in args.iter() {\n+        cmd.push_char(' ');\n+        append_arg(&mut cmd, *arg);\n+    }\n+    return cmd;\n+\n+    fn append_arg(cmd: &mut ~str, arg: &str) {\n+        let quote = arg.iter().any(|c| c == ' ' || c == '\\t');\n+        if quote {\n+            cmd.push_char('\"');\n+        }\n+        for i in range(0u, arg.len()) {\n+            append_char_at(cmd, arg, i);\n+        }\n+        if quote {\n+            cmd.push_char('\"');\n+        }\n+    }\n+\n+    fn append_char_at(cmd: &mut ~str, arg: &str, i: uint) {\n+        match arg[i] as char {\n+            '\"' => {\n+                // Escape quotes.\n+                cmd.push_str(\"\\\\\\\"\");\n+            }\n+            '\\\\' => {\n+                if backslash_run_ends_in_quote(arg, i) {\n+                    // Double all backslashes that are in runs before quotes.\n+                    cmd.push_str(\"\\\\\\\\\");\n+                } else {\n+                    // Pass other backslashes through unescaped.\n+                    cmd.push_char('\\\\');\n+                }\n+            }\n+            c => {\n+                cmd.push_char(c);\n+            }\n+        }\n+    }\n+\n+    fn backslash_run_ends_in_quote(s: &str, mut i: uint) -> bool {\n+        while i < s.len() && s[i] as char == '\\\\' {\n+            i += 1;\n+        }\n+        return i < s.len() && s[i] as char == '\"';\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn spawn_process_os(prog: &str, args: &[~str],\n+                    env: Option<~[(~str, ~str)]>,\n+                    dir: Option<&Path>,\n+                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n+    use libc::funcs::bsd44::getdtablesize;\n+\n+    mod rustrt {\n+        #[abi = \"cdecl\"]\n+        extern {\n+            pub fn rust_unset_sigprocmask();\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    unsafe fn set_environ(_envp: *c_void) {}\n+    #[cfg(target_os = \"macos\")]\n+    unsafe fn set_environ(envp: *c_void) {\n+        externfn!(fn _NSGetEnviron() -> *mut *c_void);\n+\n+        *_NSGetEnviron() = envp;\n+    }\n+    #[cfg(not(target_os = \"macos\"), not(windows))]\n+    unsafe fn set_environ(envp: *c_void) {\n+        extern {\n+            static mut environ: *c_void;\n+        }\n+        environ = envp;\n+    }\n+\n+    unsafe {\n+\n+        let pid = fork();\n+        if pid < 0 {\n+            fail2!(\"failure in fork: {}\", os::last_os_error());\n+        } else if pid > 0 {\n+            return SpawnProcessResult {pid: pid, handle: ptr::null()};\n+        }\n+\n+        rustrt::rust_unset_sigprocmask();\n+\n+        if dup2(in_fd, 0) == -1 {\n+            fail2!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n+        }\n+        if dup2(out_fd, 1) == -1 {\n+            fail2!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n+        }\n+        if dup2(err_fd, 2) == -1 {\n+            fail2!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n+        }\n+        // close all other fds\n+        for fd in range(3, getdtablesize()).invert() {\n+            close(fd as c_int);\n+        }\n+\n+        do with_dirp(dir) |dirp| {\n+            if !dirp.is_null() && chdir(dirp) == -1 {\n+                fail2!(\"failure in chdir: {}\", os::last_os_error());\n+            }\n+        }\n+\n+        do with_envp(env) |envp| {\n+            if !envp.is_null() {\n+                set_environ(envp);\n+            }\n+            do with_argv(prog, args) |argv| {\n+                execvp(*argv, argv);\n+                // execvp only returns if an error occurred\n+                fail2!(\"failure in execvp: {}\", os::last_os_error());\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n+    use vec;\n+\n+    // We can't directly convert `str`s into `*char`s, as someone needs to hold\n+    // a reference to the intermediary byte buffers. So first build an array to\n+    // hold all the ~[u8] byte strings.\n+    let mut tmps = vec::with_capacity(args.len() + 1);\n+\n+    tmps.push(prog.to_c_str());\n+\n+    for arg in args.iter() {\n+        tmps.push(arg.to_c_str());\n+    }\n+\n+    // Next, convert each of the byte strings into a pointer. This is\n+    // technically unsafe as the caller could leak these pointers out of our\n+    // scope.\n+    let mut ptrs = do tmps.map |tmp| {\n+        tmp.with_ref(|buf| buf)\n+    };\n+\n+    // Finally, make sure we add a null pointer.\n+    ptrs.push(ptr::null());\n+\n+    ptrs.as_imm_buf(|buf, _| cb(buf))\n+}\n+\n+#[cfg(unix)]\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n+    use vec;\n+\n+    // On posixy systems we can pass a char** for envp, which is a\n+    // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n+    // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n+    match env {\n+        Some(env) => {\n+            let mut tmps = vec::with_capacity(env.len());\n+\n+            for pair in env.iter() {\n+                let kv = format!(\"{}={}\", pair.first(), pair.second());\n+                tmps.push(kv.to_c_str());\n+            }\n+\n+            // Once again, this is unsafe.\n+            let mut ptrs = do tmps.map |tmp| {\n+                tmp.with_ref(|buf| buf)\n+            };\n+            ptrs.push(ptr::null());\n+\n+            do ptrs.as_imm_buf |buf, _| {\n+                unsafe { cb(cast::transmute(buf)) }\n+            }\n+        }\n+        _ => cb(ptr::null())\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n+    // On win32 we pass an \"environment block\" which is not a char**, but\n+    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n+    // \\0 to terminate.\n+    match env {\n+        Some(env) => {\n+            let mut blk = ~[];\n+\n+            for pair in env.iter() {\n+                let kv = format!(\"{}={}\", pair.first(), pair.second());\n+                blk.push_all(kv.as_bytes());\n+                blk.push(0);\n+            }\n+\n+            blk.push(0);\n+\n+            do blk.as_imm_buf |p, _len| {\n+                unsafe { cb(cast::transmute(p)) }\n+            }\n+        }\n+        _ => cb(ptr::mut_null())\n+    }\n+}\n+\n+fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n+    match d {\n+      Some(dir) => dir.with_c_str(|buf| cb(buf)),\n+      None => cb(ptr::null())\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn free_handle(handle: *()) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    unsafe {\n+        libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn free_handle(_handle: *()) {\n+    // unix has no process handle object, just a pid\n+}\n+\n+/**\n+ * Waits for a process to exit and returns the exit code, failing\n+ * if there is no process with the specified id.\n+ *\n+ * Note that this is private to avoid race conditions on unix where if\n+ * a user calls waitpid(some_process.get_id()) then some_process.finish()\n+ * and some_process.destroy() and some_process.finalize() will then either\n+ * operate on a none-existent process or, even worse, on a newer process\n+ * with the same id.\n+ */\n+fn waitpid(pid: pid_t) -> int {\n+    return waitpid_os(pid);\n+\n+    #[cfg(windows)]\n+    fn waitpid_os(pid: pid_t) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        use libc::types::os::arch::extra::DWORD;\n+        use libc::consts::os::extra::{\n+            SYNCHRONIZE,\n+            PROCESS_QUERY_INFORMATION,\n+            FALSE,\n+            STILL_ACTIVE,\n+            INFINITE,\n+            WAIT_FAILED\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            OpenProcess,\n+            GetExitCodeProcess,\n+            CloseHandle,\n+            WaitForSingleObject\n+        };\n+\n+        unsafe {\n+\n+            let proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n+            if proc.is_null() {\n+                fail2!(\"failure in OpenProcess: {}\", os::last_os_error());\n+            }\n+\n+            loop {\n+                let mut status = 0;\n+                if GetExitCodeProcess(proc, &mut status) == FALSE {\n+                    CloseHandle(proc);\n+                    fail2!(\"failure in GetExitCodeProcess: {}\", os::last_os_error());\n+                }\n+                if status != STILL_ACTIVE {\n+                    CloseHandle(proc);\n+                    return status as int;\n+                }\n+                if WaitForSingleObject(proc, INFINITE) == WAIT_FAILED {\n+                    CloseHandle(proc);\n+                    fail2!(\"failure in WaitForSingleObject: {}\", os::last_os_error());\n+                }\n+            }\n+        }\n+    }\n+\n+    #[cfg(unix)]\n+    fn waitpid_os(pid: pid_t) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        use libc::funcs::posix01::wait::*;\n+\n+        #[cfg(target_os = \"linux\")]\n+        #[cfg(target_os = \"android\")]\n+        fn WIFEXITED(status: i32) -> bool {\n+            (status & 0xffi32) == 0i32\n+        }\n+\n+        #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"freebsd\")]\n+        fn WIFEXITED(status: i32) -> bool {\n+            (status & 0x7fi32) == 0i32\n+        }\n+\n+        #[cfg(target_os = \"linux\")]\n+        #[cfg(target_os = \"android\")]\n+        fn WEXITSTATUS(status: i32) -> i32 {\n+            (status >> 8i32) & 0xffi32\n+        }\n+\n+        #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"freebsd\")]\n+        fn WEXITSTATUS(status: i32) -> i32 {\n+            status >> 8i32\n+        }\n+\n+        let mut status = 0 as c_int;\n+        if unsafe { waitpid(pid, &mut status, 0) } == -1 {\n+            fail2!(\"failure in waitpid: {}\", os::last_os_error());\n+        }\n+\n+        return if WIFEXITED(status) {\n+            WEXITSTATUS(status) as int\n+        } else {\n+            1\n+        };\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test] #[cfg(windows)]\n+    fn test_make_command_line() {\n+        use super::make_command_line;\n+        assert_eq!(\n+            make_command_line(\"prog\", [~\"aaa\", ~\"bbb\", ~\"ccc\"]),\n+            ~\"prog aaa bbb ccc\"\n+        );\n+        assert_eq!(\n+            make_command_line(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [~\"aaa\"]),\n+            ~\"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n+        );\n+        assert_eq!(\n+            make_command_line(\"C:\\\\Program Files\\\\test\", [~\"aa\\\"bb\"]),\n+            ~\"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n+        );\n+        assert_eq!(\n+            make_command_line(\"echo\", [~\"a b c\"]),\n+            ~\"echo \\\"a b c\\\"\"\n+        );\n+    }\n+\n+    // Currently most of the tests of this functionality live inside std::run,\n+    // but they may move here eventually as a non-blocking backend is added to\n+    // std::run\n+}"}, {"sha": "5f2453852ee7fe9a82704d64ecde3ae9efbf1274", "filename": "src/libstd/rt/io/process.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2f71e8e64d7994f20932caedab1b8dccc5539/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2f71e8e64d7994f20932caedab1b8dccc5539/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fprocess.rs?ref=a0d2f71e8e64d7994f20932caedab1b8dccc5539", "patch": "@@ -18,6 +18,13 @@ use rt::io::io_error;\n use rt::local::Local;\n use rt::rtio::{RtioProcess, RtioProcessObject, IoFactoryObject, IoFactory};\n \n+// windows values don't matter as long as they're at least one of unix's\n+// TERM/KILL/INT signals\n+#[cfg(windows)] pub static PleaseExitSignal: int = 15;\n+#[cfg(windows)] pub static MustDieSignal: int = 9;\n+#[cfg(not(windows))] pub static PleaseExitSignal: int = libc::SIGTERM as int;\n+#[cfg(not(windows))] pub static MustDieSignal: int = libc::SIGKILL as int;\n+\n pub struct Process {\n     priv handle: ~RtioProcessObject,\n     io: ~[Option<io::PipeStream>],"}]}