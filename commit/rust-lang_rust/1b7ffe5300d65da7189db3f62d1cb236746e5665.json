{"sha": "1b7ffe5300d65da7189db3f62d1cb236746e5665", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiN2ZmZTUzMDBkNjVkYTcxODlkYjNmNjJkMWNiMjM2NzQ2ZTU2NjU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-07-04T20:53:46Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-07-04T20:53:46Z"}, "message": "Break out of the correct number of scopes in loops\n\nWe were incorrectly breaking out of one too many drop scopes when\ngenerating MIR for loops and breakable blocks, resulting in use after\nfree and associated borrow checker warnings.\n\nThis wasn't noticed because the scope that we're breaking out of twice\nis only used for temporaries that are created for adjustments applied to\nthe loop. Since loops generally propagate coercions to the `break`\nexpressions, the only case we see this is when the type of the loop is a\nsmart pointer to a trait object.", "tree": {"sha": "f762568110e80ef9808534838876070d81a57bdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f762568110e80ef9808534838876070d81a57bdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b7ffe5300d65da7189db3f62d1cb236746e5665", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b7ffe5300d65da7189db3f62d1cb236746e5665", "html_url": "https://github.com/rust-lang/rust/commit/1b7ffe5300d65da7189db3f62d1cb236746e5665", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b7ffe5300d65da7189db3f62d1cb236746e5665/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "html_url": "https://github.com/rust-lang/rust/commit/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1"}], "stats": {"total": 73, "additions": 52, "deletions": 21}, "files": [{"sha": "75c64bb2644c1611809dd00dfe9a56221c862f50", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b7ffe5300d65da7189db3f62d1cb236746e5665/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7ffe5300d65da7189db3f62d1cb236746e5665/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=1b7ffe5300d65da7189db3f62d1cb236746e5665", "patch": "@@ -228,10 +228,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         };\n \n         // Step 5. Create everything else: the guards and the arms.\n+        let match_scope = self.scopes.topmost();\n+\n         let arm_end_blocks: Vec<_> = arm_candidates.into_iter().map(|(arm, mut candidates)| {\n             let arm_source_info = self.source_info(arm.span);\n-            let region_scope = (arm.scope, arm_source_info);\n-            self.in_scope(region_scope, arm.lint_level, |this| {\n+            let arm_scope = (arm.scope, arm_source_info);\n+            self.in_scope(arm_scope, arm.lint_level, |this| {\n                 let body = this.hir.mirror(arm.body.clone());\n                 let scope = this.declare_bindings(\n                     None,\n@@ -248,7 +250,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         arm.guard.clone(),\n                         &fake_borrow_temps,\n                         scrutinee_span,\n-                        region_scope,\n+                        match_scope,\n                     );\n                 } else {\n                     arm_block = this.cfg.start_new_block();\n@@ -259,7 +261,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             arm.guard.clone(),\n                             &fake_borrow_temps,\n                             scrutinee_span,\n-                            region_scope,\n+                            match_scope,\n                         );\n                         this.cfg.terminate(\n                             binding_end,\n@@ -1339,7 +1341,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         guard: Option<Guard<'tcx>>,\n         fake_borrows: &Vec<(&Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n-        region_scope: (region::Scope, SourceInfo),\n+        region_scope: region::Scope,\n     ) -> BasicBlock {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n "}, {"sha": "a5f9d1f99ccd01943f835d5acecae2fa963a1016", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1b7ffe5300d65da7189db3f62d1cb236746e5665/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7ffe5300d65da7189db3f62d1cb236746e5665/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1b7ffe5300d65da7189db3f62d1cb236746e5665", "patch": "@@ -604,9 +604,18 @@ where\n         }\n \n         let arg_scope_s = (arg_scope, source_info);\n-        unpack!(block = builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n-            builder.args_and_body(block, &arguments, arg_scope, &body.value)\n-        }));\n+        // `return_block` is called when we evaluate a `return` expression, so\n+        // we just use `START_BLOCK` here.\n+        unpack!(block = builder.in_breakable_scope(\n+            None,\n+            START_BLOCK,\n+            Place::RETURN_PLACE,\n+            |builder| {\n+                builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n+                    builder.args_and_body(block, &arguments, arg_scope, &body.value)\n+                })\n+            },\n+        ));\n         // Attribute epilogue to function's closing brace\n         let fn_end = span.shrink_to_hi();\n         let source_info = builder.source_info(fn_end);\n@@ -860,11 +869,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        // `return_block` is called when we evaluate a `return` expression, so\n-        // we just use `START_BLOCK` here.\n-        self.in_breakable_scope(None, START_BLOCK, Place::RETURN_PLACE, |this| {\n-            this.into(&Place::RETURN_PLACE, block, body)\n-        })\n+        self.into(&Place::RETURN_PLACE, block, body)\n     }\n \n     fn get_unit_temp(&mut self) -> Place<'tcx> {"}, {"sha": "a74d5d7ab2de3347ac8a6251cdb8a2655e072617", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b7ffe5300d65da7189db3f62d1cb236746e5665/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7ffe5300d65da7189db3f62d1cb236746e5665/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=1b7ffe5300d65da7189db3f62d1cb236746e5665", "patch": "@@ -332,9 +332,9 @@ impl<'tcx> Scopes<'tcx> {\n         }\n     }\n \n-    fn num_scopes_to(&self, region_scope: (region::Scope, SourceInfo), span: Span) -> usize {\n-        let scope_count = 1 + self.scopes.iter().rev()\n-            .position(|scope| scope.region_scope == region_scope.0)\n+    fn num_scopes_above(&self, region_scope: region::Scope, span: Span) -> usize {\n+        let scope_count = self.scopes.iter().rev()\n+            .position(|scope| scope.region_scope == region_scope)\n             .unwrap_or_else(|| {\n                 span_bug!(span, \"region_scope {:?} does not enclose\", region_scope)\n             });\n@@ -354,7 +354,7 @@ impl<'tcx> Scopes<'tcx> {\n \n     /// Returns the topmost active scope, which is known to be alive until\n     /// the next scope expression.\n-    fn topmost(&self) -> region::Scope {\n+    pub(super) fn topmost(&self) -> region::Scope {\n         self.scopes.last().expect(\"topmost_scope: no scopes present\").region_scope\n     }\n \n@@ -514,7 +514,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             assert!(value.is_none(), \"`return` and `break` should have a destination\");\n         }\n-        self.exit_scope(source_info.span, (region_scope, source_info), block, target_block);\n+        self.exit_scope(source_info.span, region_scope, block, target_block);\n         self.cfg.start_new_block().unit()\n     }\n \n@@ -523,12 +523,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// needed. See module comment for details.\n     pub fn exit_scope(&mut self,\n                       span: Span,\n-                      region_scope: (region::Scope, SourceInfo),\n+                      region_scope: region::Scope,\n                       mut block: BasicBlock,\n                       target: BasicBlock) {\n         debug!(\"exit_scope(region_scope={:?}, block={:?}, target={:?})\",\n                region_scope, block, target);\n-        let scope_count = self.scopes.num_scopes_to(region_scope, span);\n+        let scope_count = self.scopes.num_scopes_above(region_scope, span);\n \n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n@@ -545,7 +545,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 continue;\n             }\n             let source_info = scope.source_info(span);\n-            block = match scope.cached_exits.entry((target, region_scope.0)) {\n+            block = match scope.cached_exits.entry((target, region_scope)) {\n                 Entry::Occupied(e) => {\n                     self.cfg.terminate(block, source_info,\n                                     TerminatorKind::Goto { target: *e.get() });"}, {"sha": "d5e21257f4f7df118d3d03d97b931e8b38e2deb2", "filename": "src/test/ui/async-await/await-unsize.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b7ffe5300d65da7189db3f62d1cb236746e5665/src%2Ftest%2Fui%2Fasync-await%2Fawait-unsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7ffe5300d65da7189db3f62d1cb236746e5665/src%2Ftest%2Fui%2Fasync-await%2Fawait-unsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-unsize.rs?ref=1b7ffe5300d65da7189db3f62d1cb236746e5665", "patch": "@@ -0,0 +1,16 @@\n+// Regression test for #62312\n+\n+// check-pass\n+// edition:2018\n+\n+#![feature(async_await)]\n+\n+async fn make_boxed_object() -> Box<dyn Send> {\n+    Box::new(()) as _\n+}\n+\n+async fn await_object() {\n+    let _ = make_boxed_object().await;\n+}\n+\n+fn main() {}"}, {"sha": "974c63cea85e4ae9f0096e7833f30918ec538091", "filename": "src/test/ui/loops/loop-break-unsize.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b7ffe5300d65da7189db3f62d1cb236746e5665/src%2Ftest%2Fui%2Floops%2Floop-break-unsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7ffe5300d65da7189db3f62d1cb236746e5665/src%2Ftest%2Fui%2Floops%2Floop-break-unsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-break-unsize.rs?ref=1b7ffe5300d65da7189db3f62d1cb236746e5665", "patch": "@@ -0,0 +1,8 @@\n+// Regression test for #62312\n+// check-pass\n+\n+fn main() {\n+    let _ = loop {\n+        break Box::new(()) as Box<dyn Send>;\n+    };\n+}"}]}