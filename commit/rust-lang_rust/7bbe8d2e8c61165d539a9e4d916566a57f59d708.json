{"sha": "7bbe8d2e8c61165d539a9e4d916566a57f59d708", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYmU4ZDJlOGM2MTE2NWQ1MzlhOWU0ZDkxNjU2NmE1N2Y1OWQ3MDg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-30T15:03:00Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-30T15:03:00Z"}, "message": "Stop relying on klunky hack in alias.rs\n\nIt assumed node_ids increased monotonically for locals, but macros\nmake this no longer the case, and it was a dubious assumption anyway.\nIt now numbers locals itself and uses that to determine which precede\nwhich.", "tree": {"sha": "264529fc65cd4056ce5f31e06ea36bae2cc91b3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/264529fc65cd4056ce5f31e06ea36bae2cc91b3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bbe8d2e8c61165d539a9e4d916566a57f59d708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bbe8d2e8c61165d539a9e4d916566a57f59d708", "html_url": "https://github.com/rust-lang/rust/commit/7bbe8d2e8c61165d539a9e4d916566a57f59d708", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bbe8d2e8c61165d539a9e4d916566a57f59d708/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61392f9f8295bc770487389d3240caed13bfd3d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/61392f9f8295bc770487389d3240caed13bfd3d0", "html_url": "https://github.com/rust-lang/rust/commit/61392f9f8295bc770487389d3240caed13bfd3d0"}], "stats": {"total": 70, "additions": 41, "deletions": 29}, "files": [{"sha": "9548cad21daf91929289ff9df61511d291d2e910", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7bbe8d2e8c61165d539a9e4d916566a57f59d708/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbe8d2e8c61165d539a9e4d916566a57f59d708/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=7bbe8d2e8c61165d539a9e4d916566a57f59d708", "patch": "@@ -28,26 +28,32 @@ tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n \n type restrict =\n     @{root_vars: [node_id],\n-      block_defnum: node_id,\n+      local_id: uint,\n       bindings: [node_id],\n       tys: [ty::t],\n       depends_on: [uint],\n       mutable ok: valid};\n \n type scope = @[restrict];\n \n-tag local_info { arg(ast::mode); objfield(ast::mutability); }\n+tag local_info {\n+    arg(ast::mode);\n+    objfield(ast::mutability);\n+    local(uint);\n+}\n \n type mut_map = std::map::hashmap<node_id, ()>;\n type ctx = {tcx: ty::ctxt,\n             local_map: std::map::hashmap<node_id, local_info>,\n+            mutable next_local: uint,\n             mut_map: mut_map};\n \n fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) -> mut_map {\n     // Stores information about object fields and function\n     // arguments that's otherwise not easily available.\n     let cx = @{tcx: tcx,\n                local_map: std::map::new_int_hash(),\n+               mutable next_local: 0u,\n                mut_map: std::map::new_int_hash()};\n     let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n               visit_item: bind visit_item(cx, _, _, _),\n@@ -83,7 +89,7 @@ fn visit_fn(cx: &@ctx, f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n             @[\n               // I'm not sure if there is anything sensical to put here\n               @{root_vars: [],\n-                block_defnum: 0,\n+                local_id: cx.next_local,\n                 bindings: dnums,\n                 tys: [],\n                 depends_on: [],\n@@ -162,6 +168,13 @@ fn visit_expr(cx: &@ctx, ex: &@ast::expr, sc: &scope, v: &vt<scope>) {\n     if !handled { visit::visit_expr(ex, sc, v); }\n }\n \n+fn register_locals(cx: &ctx, pat: &@ast::pat) {\n+    for each pat in ast_util::pat_bindings(pat) {\n+        cx.local_map.insert(pat.id, local(cx.next_local));\n+        cx.next_local += 1u;\n+    }\n+}\n+\n fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt<scope>) {\n     visit::visit_decl(d, sc, v);\n     alt d.node {\n@@ -175,6 +188,7 @@ fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt<scope>) {\n               }\n               none. { }\n             }\n+            register_locals(*cx, loc.node.pat);\n         }\n       }\n       _ { }\n@@ -331,55 +345,51 @@ fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n \n fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n              v: &vt<scope>) {\n-    visit::visit_expr(input, sc, v);\n+    v.visit_expr(input, sc, v);\n     let root = expr_root(cx, input, true);\n     let roots =\n         alt path_def_id(cx, root.ex) { some(did) { [did.node] } _ { [] } };\n     let forbidden_tp: [ty::t] =\n         alt inner_mut(root.ds) { some(t) { [t] } _ { [] } };\n     for a: ast::arm in arms {\n-        let dnums = arm_defnums(a);\n+        let dnums = ast_util::pat_binding_ids(a.pats[0]);\n         let new_sc = sc;\n         if vec::len(dnums) > 0u {\n-            new_sc =\n-                @(*sc +\n-                      [@{root_vars: roots,\n-                         block_defnum: dnums[vec::len(dnums) - 1u],\n-                         bindings: dnums,\n-                         tys: forbidden_tp,\n-                         depends_on: deps(sc, roots),\n-                         mutable ok: valid}]);\n+            new_sc = @(*sc + [@{root_vars: roots,\n+                                local_id: cx.next_local,\n+                                bindings: dnums,\n+                                tys: forbidden_tp,\n+                                depends_on: deps(sc, roots),\n+                                mutable ok: valid}]);\n         }\n+        register_locals(cx, a.pats[0]);\n         visit::visit_arm(a, new_sc, v);\n     }\n }\n \n-fn arm_defnums(arm: &ast::arm) -> [node_id] {\n-    ret ast_util::pat_binding_ids(arm.pats[0]);\n-}\n-\n fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n                   blk: &ast::blk, sc: &scope, v: &vt<scope>) {\n-    visit::visit_expr(call, sc, v);\n+    v.visit_expr(call, sc, v);\n     alt call.node {\n       ast::expr_call(f, args) {\n         let data = check_call(cx, f, args, sc);\n         let bindings = ast_util::pat_binding_ids(local.node.pat);\n         let new_sc =\n             @{root_vars: data.root_vars,\n-              block_defnum: bindings[vec::len(bindings) - 1u],\n+              local_id: cx.next_local,\n               bindings: bindings,\n               tys: data.unsafe_ts,\n               depends_on: deps(sc, data.root_vars),\n               mutable ok: valid};\n+        register_locals(cx, local.node.pat);\n         visit::visit_block(blk, @(*sc + [new_sc]), v);\n       }\n     }\n }\n \n fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n              sc: &scope, v: &vt<scope>) {\n-    visit::visit_expr(seq, sc, v);\n+    v.visit_expr(seq, sc, v);\n     let root = expr_root(cx, seq, false);\n     let root_def =\n         alt path_def_id(cx, root.ex) { some(did) { [did.node] } _ { [] } };\n@@ -400,11 +410,12 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n     let bindings = ast_util::pat_binding_ids(local.node.pat);\n     let new_sc =\n         @{root_vars: root_def,\n-          block_defnum: bindings[vec::len(bindings) - 1u],\n+          local_id: cx.next_local,\n           bindings: bindings,\n           tys: unsafe,\n           depends_on: deps(sc, root_def),\n           mutable ok: valid};\n+    register_locals(cx, local.node.pat);\n     visit::visit_block(blk, @(*sc + [new_sc]), v);\n }\n \n@@ -413,12 +424,14 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n     let def = cx.tcx.def_map.get(id);\n     if !def_is_local(def, true) { ret; }\n     let my_defnum = ast_util::def_id_of_def(def).node;\n+    let my_local_id = alt cx.local_map.find(my_defnum) {\n+      some(local(id)) { id }\n+      _ { 0u }\n+    };\n     let var_t = ty::expr_ty(cx.tcx, ex);\n     for r: restrict in *sc {\n-\n         // excludes variables introduced since the alias was made\n-        // FIXME This does not work anymore, now that we have macros.\n-        if my_defnum < r.block_defnum {\n+        if my_local_id < r.local_id {\n             for t: ty::t in r.tys {\n                 if ty_can_unsafely_include(cx, t, var_t, assign) {\n                     r.ok = val_taken(ex.span, p);"}, {"sha": "c51e7b3192d32d21ad4ff5682903a09f0012e5d1", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbe8d2e8c61165d539a9e4d916566a57f59d708/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbe8d2e8c61165d539a9e4d916566a57f59d708/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=7bbe8d2e8c61165d539a9e4d916566a57f59d708", "patch": "@@ -246,8 +246,8 @@ fn visit_expr<E>(ex: &@expr, e: &E, v: &vt<E>) {\n       }\n       expr_tup(elts) { for el in elts { v.visit_expr(el, e, v); } }\n       expr_call(callee, args) {\n-        v.visit_expr(callee, e, v);\n         visit_exprs(args, e, v);\n+        v.visit_expr(callee, e, v);\n       }\n       expr_self_method(_) { }\n       expr_bind(callee, args) {"}, {"sha": "8323bcfa67a590bb17ff9d26604dd858b7a25807", "filename": "src/lib/treemap.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bbe8d2e8c61165d539a9e4d916566a57f59d708/src%2Flib%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbe8d2e8c61165d539a9e4d916566a57f59d708/src%2Flib%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftreemap.rs?ref=7bbe8d2e8c61165d539a9e4d916566a57f59d708", "patch": "@@ -80,15 +80,14 @@ fn find<@K, @V>(m : &treemap<K, V>, k : &K) -> option<V> {\n fn traverse<@K, @V>(m : &treemap<K, V>, f : fn(&K, &V)) {\n   alt *m {\n     empty. { }\n-    node(@k, @v, _, _) {\n-      // copy v to make aliases work out\n-      let v1 = v;\n+    node(k, v, _, _) {\n+      let k1 = k, v1 = v;\n       alt *m {\n         node(_, _, left, _) {\n           traverse(left, f);\n         }\n       }\n-      f(k, v1);\n+      f(*k1, *v1);\n       alt *m {\n         node(_, _, _, right) {\n           traverse(right, f);"}]}