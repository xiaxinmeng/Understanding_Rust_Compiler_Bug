{"sha": "8e714fa8d8d02bf6a892a65a7b91c0e352a285fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNzE0ZmE4ZDhkMDJiZjZhODkyYTY1YTdiOTFjMGUzNTJhMjg1ZmQ=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-16T23:28:33Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-18T20:56:14Z"}, "message": "Refactor a handful of stuff in the metadata encoder.", "tree": {"sha": "8db8e1fdce742780beba7c236d95cfb225a95327", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8db8e1fdce742780beba7c236d95cfb225a95327"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e714fa8d8d02bf6a892a65a7b91c0e352a285fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e714fa8d8d02bf6a892a65a7b91c0e352a285fd", "html_url": "https://github.com/rust-lang/rust/commit/8e714fa8d8d02bf6a892a65a7b91c0e352a285fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e714fa8d8d02bf6a892a65a7b91c0e352a285fd/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "585e283769faaef8898f82b37224e0a16a4f5e2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/585e283769faaef8898f82b37224e0a16a4f5e2b", "html_url": "https://github.com/rust-lang/rust/commit/585e283769faaef8898f82b37224e0a16a4f5e2b"}], "stats": {"total": 212, "additions": 87, "deletions": 125}, "files": [{"sha": "645188ce5a4d997f9f5990a84211ad49874c96ee", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e714fa8d8d02bf6a892a65a7b91c0e352a285fd/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e714fa8d8d02bf6a892a65a7b91c0e352a285fd/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=8e714fa8d8d02bf6a892a65a7b91c0e352a285fd", "patch": "@@ -179,6 +179,8 @@ pub static tag_mod_child: uint = 0x7e;\n pub static tag_misc_info: uint = 0x7f;\n pub static tag_misc_info_crate_items: uint = 0x80;\n \n+pub static tag_item_method_provided_source: uint = 0x81;\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "8fda0fff27d60ba62c096da9de0a80b63f70f169", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 85, "deletions": 125, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/8e714fa8d8d02bf6a892a65a7b91c0e352a285fd/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e714fa8d8d02bf6a892a65a7b91c0e352a285fd/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8e714fa8d8d02bf6a892a65a7b91c0e352a285fd", "patch": "@@ -15,10 +15,9 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n-use middle::ty::node_id_to_type;\n+use middle::ty::{node_id_to_type, lookup_item_type};\n use middle::ty;\n use middle;\n-use util::ppaux::ty_to_str;\n \n use std::hash::HashUtil;\n use std::hashmap::{HashMap, HashSet};\n@@ -37,8 +36,6 @@ use syntax::ast_map;\n use syntax::ast_util::*;\n use syntax::attr;\n use syntax::diagnostic::span_handler;\n-use syntax::opt_vec::OptVec;\n-use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n use syntax::{ast_util, visit};\n use syntax::parse::token;\n@@ -192,13 +189,12 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: &mut writer::Encoder,\n-                            ecx: &EncodeContext,\n-                            params: &OptVec<TyParam>) {\n-    let ty_param_defs =\n-        @params.map_to_vec(|param| ecx.tcx.ty_param_defs.get_copy(&param.id));\n-    encode_ty_type_param_defs(ebml_w, ecx, ty_param_defs,\n+fn encode_bounds_and_type(ebml_w: &mut writer::Encoder,\n+                          ecx: &EncodeContext,\n+                          tpt: &ty::ty_param_bounds_and_ty) {\n+    encode_ty_type_param_defs(ebml_w, ecx, tpt.generics.type_param_defs,\n                               tag_items_data_item_ty_param_bounds);\n+    encode_type(ecx, ebml_w, tpt.ty);\n }\n \n fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: def_id) {\n@@ -321,15 +317,14 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let vi = ty::enum_variants(ecx.tcx,\n                                ast::def_id { crate: local_crate, node: id });\n     for variants.iter().advance |variant| {\n+        let def_id = local_def(variant.node.id);\n         index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(variant.node.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'v');\n         encode_name(ecx, ebml_w, variant.node.name);\n         encode_parent_item(ebml_w, local_def(id));\n         encode_visibility(ebml_w, variant.node.vis);\n-        encode_type(ecx, ebml_w,\n-                    node_id_to_type(ecx.tcx, variant.node.id));\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args)\n                     if args.len() > 0 && generics.ty_params.len() == 0 => {\n@@ -342,7 +337,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             encode_disr_val(ecx, ebml_w, vi[i].disr_val);\n             disr_val = vi[i].disr_val;\n         }\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        encode_bounds_and_type(ebml_w, ecx,\n+                               &lookup_item_type(ecx.tcx, def_id));\n         encode_path(ecx, ebml_w, path,\n                     ast_map::path_name(variant.node.name));\n         ebml_w.end_tag();\n@@ -689,36 +685,6 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n     index\n }\n \n-// This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: &EncodeContext,\n-                        ebml_w: &mut writer::Encoder,\n-                        id: node_id,\n-                        ident: ident,\n-                        path: &[ast_map::path_elt],\n-                        item: Option<inlined_item>,\n-                        generics: &ast::Generics) {\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_name(ecx, ebml_w, ident);\n-        encode_def_id(ebml_w, local_def(id));\n-        encode_family(ebml_w, purity_fn_family(ast::impure_fn));\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        let its_ty = node_id_to_type(ecx.tcx, id);\n-        debug!(\"fn name = %s ty = %s its node id = %d\",\n-               ecx.tcx.sess.str_of(ident),\n-               ty_to_str(ecx.tcx, its_ty), id);\n-        encode_type(ecx, ebml_w, its_ty);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n-        match item {\n-           Some(it) => {\n-             (ecx.encode_inlined_item)(ecx, ebml_w, path, it);\n-           }\n-           None => {\n-             encode_symbol(ecx, ebml_w, id);\n-           }\n-        }\n-        ebml_w.end_tag();\n-}\n-\n fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut writer::Encoder,\n                                path: &[ast_map::path_elt],\n@@ -753,53 +719,46 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n     encode_method_fty(ecx, ebml_w, &method_ty.fty);\n     encode_visibility(ebml_w, method_ty.vis);\n     encode_explicit_self(ebml_w, method_ty.explicit_self);\n+    let purity = method_ty.fty.purity;\n+    match method_ty.explicit_self {\n+        ast::sty_static => {\n+            encode_family(ebml_w, purity_static_method_family(purity));\n+        }\n+        _ => encode_family(ebml_w, purity_fn_family(purity))\n+    }\n }\n \n fn encode_info_for_method(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n+                          m: &ty::Method,\n                           impl_path: &[ast_map::path_elt],\n-                          should_inline: bool,\n+                          is_default_impl: bool,\n                           parent_id: node_id,\n-                          m: @method,\n-                          owner_generics: &ast::Generics,\n-                          method_generics: &ast::Generics) {\n-    debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n-           ecx.tcx.sess.str_of(m.ident),\n-           owner_generics.ty_params.len(),\n-           method_generics.ty_params.len());\n+                          ast_method_opt: Option<@method>) {\n+\n+    debug!(\"encode_info_for_method: %? %s\", m.def_id,\n+           ecx.tcx.sess.str_of(m.ident));\n     ebml_w.start_tag(tag_items_data_item);\n \n-    let method_def_id = local_def(m.id);\n-    let method_ty = ty::method(ecx.tcx, method_def_id);\n-    encode_method_ty_fields(ecx, ebml_w, method_ty);\n+    encode_method_ty_fields(ecx, ebml_w, m);\n     encode_parent_item(ebml_w, local_def(parent_id));\n \n-    match m.explicit_self.node {\n-        ast::sty_static => {\n-            encode_family(ebml_w, purity_static_method_family(m.purity));\n-        }\n-        _ => encode_family(ebml_w, purity_fn_family(m.purity))\n-    }\n+    // The type for methods gets encoded twice, which is unfortunate.\n+    let tpt = lookup_item_type(ecx.tcx, m.def_id);\n+    encode_bounds_and_type(ebml_w, ecx, &tpt);\n \n-    let mut combined_ty_params = opt_vec::Empty;\n-    for owner_generics.ty_params.iter().advance |x| {\n-        combined_ty_params.push((*x).clone())\n-    }\n-    for method_generics.ty_params.iter().advance |x| {\n-        combined_ty_params.push((*x).clone())\n-    }\n-    let len = combined_ty_params.len();\n-    encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n-\n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n     encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n \n-    if len > 0u || should_inline {\n-        (ecx.encode_inlined_item)(\n-           ecx, ebml_w, impl_path,\n-           ii_method(local_def(parent_id), false, m));\n-    } else {\n-        encode_symbol(ecx, ebml_w, m.id);\n+    for ast_method_opt.iter().advance |ast_method| {\n+        let num_params = tpt.generics.type_param_defs.len();\n+        if num_params > 0u || is_default_impl\n+            || should_inline(ast_method.attrs) {\n+            (ecx.encode_inlined_item)(\n+                ecx, ebml_w, impl_path,\n+                ii_method(local_def(parent_id), false, *ast_method));\n+        } else {\n+            encode_symbol(ecx, ebml_w, m.def_id.node);\n+        }\n     }\n \n     ebml_w.end_tag();\n@@ -845,11 +804,12 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     debug!(\"encoding info for item at %s\",\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n \n+    let def_id = local_def(item.id);\n     match item.node {\n       item_static(_, m, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         if m == ast::m_mutbl {\n             encode_family(ebml_w, 'b');\n         } else {\n@@ -865,11 +825,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n       item_fn(_, purity, _, ref generics, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, purity_fn_family(purity));\n         let tps_len = generics.ty_params.len();\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_attributes(ebml_w, item.attrs);\n@@ -893,7 +852,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n       item_foreign_mod(ref fm) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'n');\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n@@ -907,13 +866,12 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         ebml_w.end_tag();\n       }\n-      item_ty(_, ref generics) => {\n+      item_ty(*) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'y');\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n@@ -923,10 +881,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         add_to_index();\n \n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 't');\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         for (*enum_definition).variants.iter().advance |v| {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n@@ -944,7 +901,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  index,\n                                  generics);\n       }\n-      item_struct(struct_def, ref generics) => {\n+      item_struct(struct_def, _) => {\n         /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n@@ -957,10 +914,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         /* Now, make an item for the class itself */\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'S');\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n \n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n@@ -1009,14 +965,17 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                         index);\n         }\n       }\n-      item_impl(ref generics, ref opt_trait, ref ty, ref methods) => {\n+      item_impl(_, ref opt_trait, ref ty, ref ast_methods) => {\n+        // We need to encode information about the default methods we\n+        // have inherited, so we drive this based on the impl structure.\n+        let imp = tcx.impls.get(&def_id);\n+\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'i');\n         encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n@@ -1027,15 +986,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             _ => {}\n         }\n-        for methods.iter().advance |m| {\n+        for imp.methods.iter().advance |method| {\n+            if method.provided_source.is_some() { loop; }\n             ebml_w.start_tag(tag_item_impl_method);\n-            let method_def_id = local_def(m.id);\n-            let s = def_to_str(method_def_id);\n+            let s = def_to_str(method.def_id);\n             ebml_w.writer.write(s.as_bytes());\n             ebml_w.end_tag();\n         }\n         for opt_trait.iter().advance |ast_trait_ref| {\n-            let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n+            let trait_ref = ty::node_id_to_trait_ref(\n+                tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n@@ -1045,30 +1005,32 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let mut impl_path = vec::append(~[], path);\n         impl_path.push(ast_map::path_name(item.ident));\n \n-        for methods.iter().advance |m| {\n-            index.push(entry {val: m.id, pos: ebml_w.writer.tell()});\n+        for ast_methods.iter().advance |ast_method| {\n+            let m = ty::method(ecx.tcx, local_def(ast_method.id));\n+            index.push(entry {val: m.def_id.node, pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx,\n                                    ebml_w,\n+                                   m,\n                                    impl_path,\n-                                   should_inline(m.attrs),\n+                                   false,\n                                    item.id,\n-                                   *m,\n-                                   generics,\n-                                   &m.generics);\n+                                   Some(*ast_method));\n         }\n       }\n-      item_trait(ref generics, ref super_traits, ref ms) => {\n+      item_trait(_, ref super_traits, ref ms) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'I');\n         encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        let trait_def = ty::lookup_trait_def(tcx, local_def(item.id));\n+        let trait_def = ty::lookup_trait_def(tcx, def_id);\n+        encode_ty_type_param_defs(ebml_w, ecx,\n+                                  trait_def.generics.type_param_defs,\n+                                  tag_items_data_item_ty_param_bounds);\n         encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n-        for ty::trait_method_def_ids(tcx, local_def(item.id)).iter().advance |&method_def_id| {\n+        for ty::trait_method_def_ids(tcx, def_id).iter().advance |&method_def_id| {\n             ebml_w.start_tag(tag_item_trait_method);\n             encode_def_id(ebml_w, method_def_id);\n             ebml_w.end_tag();\n@@ -1085,7 +1047,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.end_tag();\n \n         // Now output the method info for each method.\n-        let r = ty::trait_method_def_ids(tcx, local_def(item.id));\n+        let r = ty::trait_method_def_ids(tcx, def_id);\n         for r.iter().enumerate().advance |(i, &method_def_id)| {\n             assert_eq!(method_def_id.crate, ast::local_crate);\n \n@@ -1097,7 +1059,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             encode_method_ty_fields(ecx, ebml_w, method_ty);\n \n-            encode_parent_item(ebml_w, local_def(item.id));\n+            encode_parent_item(ebml_w, def_id);\n \n             let mut trait_path = vec::append(~[], path);\n             trait_path.push(ast_map::path_name(item.ident));\n@@ -1110,10 +1072,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                       method_ty.fty.purity));\n \n                     let tpt = ty::lookup_item_type(tcx, method_def_id);\n-                    encode_ty_type_param_defs(ebml_w, ecx,\n-                                              tpt.generics.type_param_defs,\n-                                              tag_items_data_item_ty_param_bounds);\n-                    encode_type(ecx, ebml_w, tpt.ty);\n+                    encode_bounds_and_type(ebml_w, ecx, &tpt);\n                 }\n \n                 _ => {\n@@ -1132,13 +1091,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     // If this is a static method, we've already encoded\n                     // this.\n                     if method_ty.explicit_self != sty_static {\n-                        encode_type_param_bounds(ebml_w, ecx,\n-                                                 &m.generics.ty_params);\n+                        // XXX: I feel like there is something funny going on.\n+                        let tpt = ty::lookup_item_type(tcx, method_def_id);\n+                        encode_bounds_and_type(ebml_w, ecx, &tpt);\n                     }\n                     encode_method_sort(ebml_w, 'p');\n                     (ecx.encode_inlined_item)(\n                         ecx, ebml_w, path,\n-                        ii_method(local_def(item.id), true, m));\n+                        ii_method(def_id, true, m));\n                 }\n             }\n \n@@ -1159,11 +1119,11 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n \n     ebml_w.start_tag(tag_items_data_item);\n     match nitem.node {\n-      foreign_item_fn(_, purity, ref generics) => {\n+      foreign_item_fn(_, purity, _) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(purity));\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n+        encode_bounds_and_type(ebml_w, ecx,\n+                               &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n         encode_name(ecx, ebml_w, nitem.ident);\n         if abi.is_intrinsic() {\n             (ecx.encode_inlined_item)(ecx, ebml_w, *path, ii_foreign(nitem));"}]}