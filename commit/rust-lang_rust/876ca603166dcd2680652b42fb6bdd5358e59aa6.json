{"sha": "876ca603166dcd2680652b42fb6bdd5358e59aa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NmNhNjAzMTY2ZGNkMjY4MDY1MmI0MmZiNmJkZDUzNThlNTlhYTY=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-05T01:35:41Z"}, "committer": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-05T01:35:41Z"}, "message": "allow transitive `&mut` access for fields in extract_function", "tree": {"sha": "074c5f4abd125ce2f8ac9d245090f636b6a7e7aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/074c5f4abd125ce2f8ac9d245090f636b6a7e7aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/876ca603166dcd2680652b42fb6bdd5358e59aa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/876ca603166dcd2680652b42fb6bdd5358e59aa6", "html_url": "https://github.com/rust-lang/rust/commit/876ca603166dcd2680652b42fb6bdd5358e59aa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/876ca603166dcd2680652b42fb6bdd5358e59aa6/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "271c1cb01325ac252b5153c3729462a4d96a0e0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/271c1cb01325ac252b5153c3729462a4d96a0e0a", "html_url": "https://github.com/rust-lang/rust/commit/271c1cb01325ac252b5153c3729462a4d96a0e0a"}], "stats": {"total": 119, "additions": 92, "deletions": 27}, "files": [{"sha": "49ea1c4b3b7c21488a630f5be044ed141dd8fe56", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "modified", "additions": 92, "deletions": 27, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/876ca603166dcd2680652b42fb6bdd5358e59aa6/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/876ca603166dcd2680652b42fb6bdd5358e59aa6/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=876ca603166dcd2680652b42fb6bdd5358e59aa6", "patch": "@@ -503,17 +503,42 @@ fn reference_is_exclusive(\n     }\n \n     // we take `&mut` reference to variable: `&mut v`\n-    let path = path_element_of_reference(body, reference);\n-    if is_mut_ref_expr(path.as_ref()).unwrap_or(false) {\n-        return true;\n+    let path = match path_element_of_reference(body, reference) {\n+        Some(path) => path,\n+        None => return false,\n+    };\n+\n+    expr_require_exclusive_access(ctx, &path).unwrap_or(false)\n+}\n+\n+/// checks if this expr requires `&mut` access, recurses on field access\n+fn expr_require_exclusive_access(ctx: &AssistContext, expr: &ast::Expr) -> Option<bool> {\n+    let parent = expr.syntax().parent()?;\n+\n+    if let Some(bin_expr) = ast::BinExpr::cast(parent.clone()) {\n+        if bin_expr.op_kind()?.is_assignment() {\n+            return Some(bin_expr.lhs()?.syntax() == expr.syntax());\n+        }\n+        return Some(false);\n     }\n \n-    // we call method with `&mut self` receiver\n-    if is_mut_method_call_receiver(ctx, path.as_ref()).unwrap_or(false) {\n-        return true;\n+    if let Some(ref_expr) = ast::RefExpr::cast(parent.clone()) {\n+        return Some(ref_expr.mut_token().is_some());\n+    }\n+\n+    if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n+        let func = ctx.sema.resolve_method_call(&method_call)?;\n+        let self_param = func.self_param(ctx.db())?;\n+        let access = self_param.access(ctx.db());\n+\n+        return Some(matches!(access, hir::Access::Exclusive));\n+    }\n+\n+    if let Some(field) = ast::FieldExpr::cast(parent) {\n+        return expr_require_exclusive_access(ctx, &field.into());\n     }\n \n-    false\n+    Some(false)\n }\n \n /// Container of local varaible usages\n@@ -567,24 +592,6 @@ fn path_element_of_reference(\n     Some(path)\n }\n \n-fn is_mut_ref_expr(path: Option<&ast::Expr>) -> Option<bool> {\n-    let path = path?;\n-    let ref_expr = path.syntax().parent().and_then(ast::RefExpr::cast)?;\n-    Some(ref_expr.mut_token().is_some())\n-}\n-\n-/// checks if `path` is the receiver in method call that requires `&mut self` access\n-fn is_mut_method_call_receiver(ctx: &AssistContext, path: Option<&ast::Expr>) -> Option<bool> {\n-    let path = path?;\n-    let method_call = path.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n-\n-    let func = ctx.sema.resolve_method_call(&method_call)?;\n-    let self_param = func.self_param(ctx.db())?;\n-    let access = self_param.access(ctx.db());\n-\n-    Some(matches!(access, hir::Access::Exclusive))\n-}\n-\n /// list local variables defined inside `body`\n fn vars_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n     // FIXME: this doesn't work well with macros\n@@ -872,7 +879,7 @@ fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode)\n             .filter_map(|reference| path_element_of_reference(syntax, reference));\n         for path in usages {\n             match path.syntax().ancestors().skip(1).find_map(ast::Expr::cast) {\n-                Some(ast::Expr::MethodCallExpr(_)) => {\n+                Some(ast::Expr::MethodCallExpr(_)) | Some(ast::Expr::FieldExpr(_)) => {\n                     // do nothing\n                 }\n                 Some(ast::Expr::RefExpr(node))\n@@ -1672,6 +1679,64 @@ fn $0fun_name(n: &mut i32) {\n         );\n     }\n \n+    #[test]\n+    fn mut_field_from_outer_scope() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct C { n: i32 }\n+fn foo() {\n+    let mut c = C { n: 0 };\n+    $0c.n += 1;$0\n+    let m = c.n + 1;\n+}\",\n+            r\"\n+struct C { n: i32 }\n+fn foo() {\n+    let mut c = C { n: 0 };\n+    fun_name(&mut c);\n+    let m = c.n + 1;\n+}\n+\n+fn $0fun_name(c: &mut C) {\n+    c.n += 1;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_nested_field_from_outer_scope() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct P { n: i32}\n+struct C { p: P }\n+fn foo() {\n+    let mut c = C { p: P { n: 0 } };\n+    let mut v = C { p: P { n: 0 } };\n+    let u = C { p: P { n: 0 } };\n+    $0c.p.n += u.p.n;\n+    let r = &mut v.p.n;$0\n+    let m = c.p.n + v.p.n + u.p.n;\n+}\",\n+            r\"\n+struct P { n: i32}\n+struct C { p: P }\n+fn foo() {\n+    let mut c = C { p: P { n: 0 } };\n+    let mut v = C { p: P { n: 0 } };\n+    let u = C { p: P { n: 0 } };\n+    fun_name(&mut c, &u, &mut v);\n+    let m = c.p.n + v.p.n + u.p.n;\n+}\n+\n+fn $0fun_name(c: &mut C, u: &C, v: &mut C) {\n+    c.p.n += u.p.n;\n+    let r = &mut v.p.n;\n+}\",\n+        );\n+    }\n+\n     #[test]\n     fn mut_param_many_usages_stmt() {\n         check_assist(\n@@ -1999,7 +2064,7 @@ fn foo() {\n }\n \n fn $0fun_name(c: &Counter) {\n-    let n = *c.0;\n+    let n = c.0;\n }\",\n         );\n     }"}]}