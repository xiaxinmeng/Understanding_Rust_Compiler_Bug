{"sha": "1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlZTJlNGZmZThhNGNhNDA2NzZmZTZiMzcyNTcwZDRlNTFjMmYzNzU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-06-01T13:09:17Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-06-01T13:09:17Z"}, "message": "Fixed block check, also added macro test to collapsible_if and inline_always", "tree": {"sha": "4206cad1d8085831e469da4af5d6c3aa96c58088", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4206cad1d8085831e469da4af5d6c3aa96c58088"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375", "html_url": "https://github.com/rust-lang/rust/commit/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f5891184d55c3d01f57cf480d718e19f9f8268d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5891184d55c3d01f57cf480d718e19f9f8268d", "html_url": "https://github.com/rust-lang/rust/commit/7f5891184d55c3d01f57cf480d718e19f9f8268d"}], "stats": {"total": 87, "additions": 54, "deletions": 33}, "files": [{"sha": "f056ac6ee8c4e7e5abf1f34196b4c6b9d96e8c5d", "filename": "src/attrs.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375", "patch": "@@ -4,8 +4,9 @@ use rustc::plugin::Registry;\n use rustc::lint::*;\n use syntax::ast::*;\n use syntax::ptr::P;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, ExpnInfo};\n use syntax::parse::token::InternedString;\n+use mut_mut::in_macro;\n \n declare_lint! { pub INLINE_ALWAYS, Warn,\n     \"#[inline(always)] is usually a bad idea.\"}\n@@ -20,19 +21,25 @@ impl LintPass for AttrPass {\n     }\n     \n     fn check_item(&mut self, cx: &Context, item: &Item) {\n-\t\tcheck_attrs(cx, &item.ident, &item.attrs)\n+\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n+\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n \t}\n     \n     fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) { \n-\t\tcheck_attrs(cx, &item.ident, &item.attrs)\n+\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n+\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n \t}\n         \n \tfn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n-\t\tcheck_attrs(cx, &item.ident, &item.attrs)\n+\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n+\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n \t}\n }\n \n-fn check_attrs(cx: &Context, ident: &Ident, attrs: &[Attribute]) {\n+fn check_attrs(cx: &Context, info: Option<&ExpnInfo>, ident: &Ident, \n+\t\tattrs: &[Attribute]) {\n+\tif in_macro(cx, info) { return; }\n+\t\t\t\n \tfor attr in attrs {\n \t\tif let MetaList(ref inline, ref values) = attr.node.value.node {\n \t\t\tif values.len() != 1 || inline != &\"inline\" { continue; }"}, {"sha": "b9ebeed01deee9ac449732fd4d1b62a2ec1e8f83", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375", "patch": "@@ -17,8 +17,9 @@ use rustc::lint::*;\n use rustc::middle::def::*;\n use syntax::ast::*;\n use syntax::ptr::P;\n-use syntax::codemap::{Span, Spanned};\n+use syntax::codemap::{Span, Spanned, ExpnInfo};\n use syntax::print::pprust::expr_to_string;\n+use mut_mut::in_macro;\n \n declare_lint! {\n     pub COLLAPSIBLE_IF,\n@@ -34,20 +35,23 @@ impl LintPass for CollapsibleIf {\n         lint_array!(COLLAPSIBLE_IF)\n     }\n     \n-    fn check_expr(&mut self, cx: &Context, e: &Expr) {\n-        if let ExprIf(ref check, ref then_block, None) = e.node {\n-            let expr = check_block(then_block);\n-            let expr = match expr {\n-                Some(e) => e,\n-                None => return\n-            };\n-            if let ExprIf(ref check_inner, _, None) = expr.node {\n-                let (check, check_inner) = (check_to_string(check), check_to_string(check_inner));\n-                cx.span_lint(COLLAPSIBLE_IF, e.span,\n-                             &format!(\"This if statement can be collapsed. Try: if {} && {}\", check, check_inner));\n-            }\n-\t\t    }\n-    }\n+\tfn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+\t\tcx.sess().codemap().with_expn_info(expr.span.expn_id, \n+\t\t\t|info| check_expr_expd(cx, expr, info))\n+\t}\n+}\n+\n+fn check_expr_expd(cx: &Context, e: &Expr, info: Option<&ExpnInfo>) {\n+\tif in_macro(cx, info) { return; }\n+\t\n+\tif let ExprIf(ref check, ref then, None) = e.node {\n+\t\tif let Some(&Expr{ node: ExprIf(ref check_inner, _, None), ..}) = \n+\t\t\t\tsingle_stmt_of_block(then) {\n+\t\t\tcx.span_lint(COLLAPSIBLE_IF, e.span, &format!(\n+\t\t\t\t\"This if statement can be collapsed. Try: if {} && {}\\n{:?}\", \n+\t\t\t\tcheck_to_string(check), check_to_string(check_inner), e));\n+\t\t}\n+\t}\n }\n \n fn requires_brackets(e: &Expr) -> bool {\n@@ -65,16 +69,20 @@ fn check_to_string(e: &Expr) -> String {\n     }\n }\n \n-fn check_block(b: &Block) -> Option<&P<Expr>> {\n-    if b.stmts.len() == 1 && b.expr.is_none() {\n-        let stmt = &b.stmts[0];\n-        return match stmt.node {\n-            StmtExpr(ref e, _) => Some(e),\n-            _ => None\n-        };\n-    }\n-    if let Some(ref e) = b.expr {\n-        return Some(e);\n+fn single_stmt_of_block(block: &Block) -> Option<&Expr> {\n+    if block.stmts.len() == 1 && block.expr.is_none() {\n+        if let StmtExpr(ref expr, _) = block.stmts[0].node {\n+            single_stmt_of_expr(expr)\n+        } else { None }\n+    } else {\n+        if block.stmts.is_empty() {\n+            if let Some(ref p) = block.expr { Some(&*p) } else { None }\n+        } else { None }\n     }\n-    None\n+}\n+\n+fn single_stmt_of_expr(expr: &Expr) -> Option<&Expr> {\n+    if let ExprBlock(ref block) = expr.node {\n+        single_stmt_of_block(block)\n+    } else { Some(expr) }\n }"}, {"sha": "3ba9c47e7fe91a391c025b7fdcf7f02d337cdc1e", "filename": "src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375", "patch": "@@ -51,7 +51,7 @@ fn check_expr_expd(cx: &Context, expr: &Expr, info: Option<&ExpnInfo>) {\n \t})\n }\n \n-fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n+pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n \topt_info.map_or(false, |info| {\n \t\tinfo.callee.span.map_or(true, |span| {\n \t\t\tcx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code| "}, {"sha": "7b7ff13f24badea9479aaa8816270b96c1155713", "filename": "tests/compile-fail/collapsible_if.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375/tests%2Fcompile-fail%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375/tests%2Fcompile-fail%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcollapsible_if.rs?ref=1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375", "patch": "@@ -34,4 +34,10 @@ fn main() {\n         }\n     }\n \n+\tif x == \"hello\" {\n+\t\tprint!(\"Hello \");\n+\t\tif y == \"world\" {\n+\t\t\tprintln!(\"world!\")\n+\t\t}\n+\t}\n }"}, {"sha": "04f3fc16b1b69e8ca8a7054852ebd3b46fef420e", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=1ee2e4ffe8a4ca40676fe6b372570d4e51c2f375", "patch": "@@ -5,7 +5,7 @@ use std::path::PathBuf;\n fn run_mode(mode: &'static str) {\n     let mut config = compiletest::default_config();\n     let cfg_mode = mode.parse().ok().expect(\"Invalid mode\");\n-    config.target_rustcflags = Some(\"-l regex_macros -L target/debug/\".to_string());\n+    config.target_rustcflags = Some(\"-L target/debug/\".to_string());\n \n     config.mode = cfg_mode;\n     config.src_base = PathBuf::from(format!(\"tests/{}\", mode));"}]}