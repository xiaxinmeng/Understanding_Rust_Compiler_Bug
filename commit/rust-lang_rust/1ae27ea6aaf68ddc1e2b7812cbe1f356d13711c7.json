{"sha": "1ae27ea6aaf68ddc1e2b7812cbe1f356d13711c7", "node_id": "C_kwDOAAsO6NoAKDFhZTI3ZWE2YWFmNjhkZGMxZTJiNzgxMmNiZTFmMzU2ZDEzNzExYzc", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-01-30T18:19:54Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-01-30T18:19:54Z"}, "message": "Remove simd_cmp macro\n\nThis reduces duplication in the codegened source file", "tree": {"sha": "c50b7954308b5f44d3f7112e85bd66cd1e72abbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c50b7954308b5f44d3f7112e85bd66cd1e72abbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ae27ea6aaf68ddc1e2b7812cbe1f356d13711c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ae27ea6aaf68ddc1e2b7812cbe1f356d13711c7", "html_url": "https://github.com/rust-lang/rust/commit/1ae27ea6aaf68ddc1e2b7812cbe1f356d13711c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ae27ea6aaf68ddc1e2b7812cbe1f356d13711c7/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "037aafbbaf2ee41a11807a1abdec24eb23f505c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/037aafbbaf2ee41a11807a1abdec24eb23f505c2", "html_url": "https://github.com/rust-lang/rust/commit/037aafbbaf2ee41a11807a1abdec24eb23f505c2"}], "stats": {"total": 100, "additions": 55, "deletions": 45}, "files": [{"sha": "e0687b1d4eff26e8475e62c7d21ed3ce7a92368e", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 55, "deletions": 45, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/1ae27ea6aaf68ddc1e2b7812cbe1f356d13711c7/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae27ea6aaf68ddc1e2b7812cbe1f356d13711c7/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=1ae27ea6aaf68ddc1e2b7812cbe1f356d13711c7", "patch": "@@ -17,28 +17,6 @@ fn report_simd_type_validation_error(\n     crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n }\n \n-macro simd_cmp($fx:expr, $intrinsic:ident, $span:ident, $cc_u:ident|$cc_s:ident|$cc_f:ident($x:ident, $y:ident) -> $ret:ident) {\n-    if !$x.layout().ty.is_simd() {\n-        report_simd_type_validation_error($fx, $intrinsic, $span, $x.layout().ty);\n-        return;\n-    }\n-\n-    // FIXME use vector instructions when possible\n-    simd_pair_for_each_lane($fx, $x, $y, $ret, &|fx, lane_ty, res_lane_ty, x_lane, y_lane| {\n-        let res_lane = match lane_ty.kind() {\n-            ty::Uint(_) => fx.bcx.ins().icmp(IntCC::$cc_u, x_lane, y_lane),\n-            ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc_s, x_lane, y_lane),\n-            ty::Float(_) => fx.bcx.ins().fcmp(FloatCC::$cc_f, x_lane, y_lane),\n-            _ => unreachable!(\"{:?}\", lane_ty),\n-        };\n-\n-        let ty = fx.clif_type(res_lane_ty).unwrap();\n-\n-        let res_lane = fx.bcx.ins().bint(ty, res_lane);\n-        fx.bcx.ins().ineg(res_lane)\n-    });\n-}\n-\n macro simd_int_binop($fx:expr, $intrinsic:ident, $span:ident, $op_u:ident|$op_s:ident($x:ident, $y:ident) -> $ret:ident) {\n     if !$x.layout().ty.is_simd() {\n         report_simd_type_validation_error($fx, $intrinsic, $span, $x.layout().ty);\n@@ -117,29 +95,61 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             });\n         };\n \n-        simd_eq, (c x, c y) {\n-            simd_cmp!(fx, intrinsic, span, Equal|Equal|Equal(x, y) -> ret);\n-        };\n-        simd_ne, (c x, c y) {\n-            simd_cmp!(fx, intrinsic, span, NotEqual|NotEqual|NotEqual(x, y) -> ret);\n-        };\n-        simd_lt, (c x, c y) {\n-            simd_cmp!(fx, intrinsic, span, UnsignedLessThan|SignedLessThan|LessThan(x, y) -> ret);\n-        };\n-        simd_le, (c x, c y) {\n-            simd_cmp!(fx, intrinsic, span, UnsignedLessThanOrEqual|SignedLessThanOrEqual|LessThanOrEqual(x, y) -> ret);\n-        };\n-        simd_gt, (c x, c y) {\n-            simd_cmp!(fx, intrinsic, span, UnsignedGreaterThan|SignedGreaterThan|GreaterThan(x, y) -> ret);\n-        };\n-        simd_ge, (c x, c y) {\n-            simd_cmp!(\n-                fx,\n-                intrinsic,\n-                span,\n-                UnsignedGreaterThanOrEqual|SignedGreaterThanOrEqual|GreaterThanOrEqual\n-                (x, y) -> ret\n-            );\n+        simd_eq | simd_ne | simd_lt | simd_le | simd_gt | simd_ge, (c x, c y) {\n+            if !x.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, x.layout().ty);\n+                return;\n+            }\n+\n+            // FIXME use vector instructions when possible\n+            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, res_lane_ty, x_lane, y_lane| {\n+                let res_lane = match (lane_ty.kind(), intrinsic) {\n+                    (ty::Uint(_), sym::simd_eq) => fx.bcx.ins().icmp(IntCC::Equal, x_lane, y_lane),\n+                    (ty::Uint(_), sym::simd_ne) => fx.bcx.ins().icmp(IntCC::NotEqual, x_lane, y_lane),\n+                    (ty::Uint(_), sym::simd_lt) => {\n+                        fx.bcx.ins().icmp(IntCC::UnsignedLessThan, x_lane, y_lane)\n+                    }\n+                    (ty::Uint(_), sym::simd_le) => {\n+                        fx.bcx.ins().icmp(IntCC::UnsignedLessThanOrEqual, x_lane, y_lane)\n+                    }\n+                    (ty::Uint(_), sym::simd_gt) => {\n+                        fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, x_lane, y_lane)\n+                    }\n+                    (ty::Uint(_), sym::simd_ge) => {\n+                        fx.bcx.ins().icmp(IntCC::UnsignedGreaterThanOrEqual, x_lane, y_lane)\n+                    }\n+\n+                    (ty::Int(_), sym::simd_eq) => fx.bcx.ins().icmp(IntCC::Equal, x_lane, y_lane),\n+                    (ty::Int(_), sym::simd_ne) => fx.bcx.ins().icmp(IntCC::NotEqual, x_lane, y_lane),\n+                    (ty::Int(_), sym::simd_lt) => fx.bcx.ins().icmp(IntCC::SignedLessThan, x_lane, y_lane),\n+                    (ty::Int(_), sym::simd_le) => {\n+                        fx.bcx.ins().icmp(IntCC::SignedLessThanOrEqual, x_lane, y_lane)\n+                    }\n+                    (ty::Int(_), sym::simd_gt) => {\n+                        fx.bcx.ins().icmp(IntCC::SignedGreaterThan, x_lane, y_lane)\n+                    }\n+                    (ty::Int(_), sym::simd_ge) => {\n+                        fx.bcx.ins().icmp(IntCC::SignedGreaterThanOrEqual, x_lane, y_lane)\n+                    }\n+\n+                    (ty::Float(_), sym::simd_eq) => fx.bcx.ins().fcmp(FloatCC::Equal, x_lane, y_lane),\n+                    (ty::Float(_), sym::simd_ne) => fx.bcx.ins().fcmp(FloatCC::NotEqual, x_lane, y_lane),\n+                    (ty::Float(_), sym::simd_lt) => fx.bcx.ins().fcmp(FloatCC::LessThan, x_lane, y_lane),\n+                    (ty::Float(_), sym::simd_le) => {\n+                        fx.bcx.ins().fcmp(FloatCC::LessThanOrEqual, x_lane, y_lane)\n+                    }\n+                    (ty::Float(_), sym::simd_gt) => fx.bcx.ins().fcmp(FloatCC::GreaterThan, x_lane, y_lane),\n+                    (ty::Float(_), sym::simd_ge) => {\n+                        fx.bcx.ins().fcmp(FloatCC::GreaterThanOrEqual, x_lane, y_lane)\n+                    }\n+                    _ => unreachable!(),\n+                };\n+\n+                let ty = fx.clif_type(res_lane_ty).unwrap();\n+\n+                let res_lane = fx.bcx.ins().bint(ty, res_lane);\n+                fx.bcx.ins().ineg(res_lane)\n+            });\n         };\n \n         // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U"}]}