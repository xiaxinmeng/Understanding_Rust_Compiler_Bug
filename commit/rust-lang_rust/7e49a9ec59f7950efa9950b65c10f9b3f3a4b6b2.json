{"sha": "7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNDlhOWVjNTlmNzk1MGVmYTk5NTBiNjVjMTBmOWIzZjNhNGI2YjI=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-08T02:35:15Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-15T23:50:10Z"}, "message": "moved to post_borrowck_cleanup & used MirPatch", "tree": {"sha": "9de3eef094db862b3777d844f865cdd226cbb466", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9de3eef094db862b3777d844f865cdd226cbb466"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2", "html_url": "https://github.com/rust-lang/rust/commit/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4df7e70466611a49d3ff6c49d162b2045173449", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4df7e70466611a49d3ff6c49d162b2045173449", "html_url": "https://github.com/rust-lang/rust/commit/e4df7e70466611a49d3ff6c49d162b2045173449"}], "stats": {"total": 123, "additions": 65, "deletions": 58}, "files": [{"sha": "4d8120794f88572222e3dbf82c92e3dfbe3e8b3b", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2", "patch": "@@ -389,6 +389,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n                 self.copy_op(self.operand_index(args[0], index)?, dest)?;\n             }\n+            sym::count_code_region => (),\n             _ => return Ok(false),\n         }\n "}, {"sha": "0604caadaea38cfb235fde0dc3e5e4397088c3e2", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 58, "deletions": 54, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2", "patch": "@@ -1,8 +1,7 @@\n use crate::transform::{MirPass, MirSource};\n-use rustc_index::vec::Idx;\n+use crate::util::patch::MirPatch;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::*;\n-use rustc_middle::mir::{Local, LocalDecl};\n use rustc_middle::ty;\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TyCtxt;\n@@ -16,69 +15,62 @@ pub struct InstrumentCoverage;\n  * the intrinsic llvm.instrprof.increment.\n  */\n \n-// FIXME(richkadel): As a first step, counters are only injected at the top of each function.\n-// The complete solution will inject counters at each conditional code branch.\n-\n impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.instrument_coverage {\n-            if let Some(callee_fn_def_id) = tcx.lang_items().count_code_region_fn() {\n-                debug!(\"instrumenting {:?}\", src.def_id());\n-                instrument_coverage(tcx, callee_fn_def_id, body);\n-            }\n+            debug!(\"instrumenting {:?}\", src.def_id());\n+            instrument_coverage(tcx, body);\n         }\n     }\n }\n \n-pub fn instrument_coverage<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    callee_fn_def_id: DefId,\n-    body: &mut Body<'tcx>,\n-) {\n+// The first counter (start of the function) is index zero.\n+const INIT_FUNCTION_COUNTER: u128 = 0;\n+\n+/// Injects calls to placeholder function `count_code_region()`.\n+// FIXME(richkadel): As a first step, counters are only injected at the top of each function.\n+// The complete solution will inject counters at each conditional code branch.\n+pub fn instrument_coverage<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let span = body.span.shrink_to_lo();\n \n-    let ret_ty = tcx.fn_sig(callee_fn_def_id).output();\n+    let count_code_region_fn =\n+        function_handle(tcx, span, tcx.lang_items().count_code_region_fn().unwrap());\n+    let counter_index = const_int_operand(tcx, span, tcx.types.u32, INIT_FUNCTION_COUNTER);\n+\n+    let mut patch = MirPatch::new(body);\n+\n+    let new_block = patch.new_block(placeholder_block(SourceInfo::outermost(body.span)));\n+    let next_block = START_BLOCK;\n+\n+    let temp = patch.new_temp(tcx.mk_unit(), body.span);\n+    patch.patch_terminator(\n+        new_block,\n+        TerminatorKind::Call {\n+            func: count_code_region_fn,\n+            args: vec![counter_index],\n+            // new_block will swapped with the next_block, after applying patch\n+            destination: Some((Place::from(temp), new_block)),\n+            cleanup: None,\n+            from_hir_call: false,\n+        },\n+    );\n+\n+    patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n+    patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n+\n+    patch.apply(body);\n+\n+    // To insert the `new_block` in front of the first block in the counted branch (for example,\n+    // the START_BLOCK, at the top of the function), just swap the indexes, leaving the rest of the\n+    // graph unchanged.\n+    body.basic_blocks_mut().swap(next_block, new_block);\n+}\n+\n+fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, span: Span, fn_def_id: DefId) -> Operand<'tcx> {\n+    let ret_ty = tcx.fn_sig(fn_def_id).output();\n     let ret_ty = ret_ty.no_bound_vars().unwrap();\n     let substs = tcx.mk_substs(::std::iter::once(ty::subst::GenericArg::from(ret_ty)));\n-\n-    let count_code_region_fn: Operand<'_> =\n-        Operand::function_handle(tcx, callee_fn_def_id, substs, span);\n-\n-    let index = const_int_operand(tcx, span.clone(), tcx.types.u32, 0);\n-\n-    let args = vec![index];\n-\n-    let source_info = SourceInfo { span: span, scope: OUTERMOST_SOURCE_SCOPE };\n-\n-    let new_block = START_BLOCK + body.basic_blocks().len();\n-\n-    let next_local = body.local_decls.len();\n-    let new_temp = Local::new(next_local);\n-    let unit_temp = Place::from(new_temp);\n-\n-    let storage_live = Statement { source_info, kind: StatementKind::StorageLive(new_temp) };\n-    let storage_dead = Statement { source_info, kind: StatementKind::StorageDead(new_temp) };\n-\n-    let count_code_region_call = TerminatorKind::Call {\n-        func: count_code_region_fn,\n-        args,\n-        destination: Some((unit_temp, new_block)),\n-        cleanup: None,\n-        from_hir_call: false,\n-    };\n-\n-    body.local_decls.push(LocalDecl::new(tcx.mk_unit(), body.span));\n-    body.basic_blocks_mut().push(BasicBlockData {\n-        statements: vec![storage_live],\n-        is_cleanup: false,\n-        terminator: Some(Terminator { source_info, kind: count_code_region_call }),\n-    });\n-\n-    body.basic_blocks_mut().swap(START_BLOCK, new_block);\n-    body[new_block].statements.push(storage_dead);\n-\n-    // FIXME(richkadel): ALSO add each computed Span for each conditional branch to the coverage map\n-    // and provide that map to LLVM to encode in the final binary.\n+    Operand::function_handle(tcx, fn_def_id, substs, span)\n }\n \n fn const_int_operand<'tcx>(\n@@ -98,3 +90,15 @@ fn const_int_operand<'tcx>(\n         literal: ty::Const::from_scalar(tcx, Scalar::from_uint(val, size), ty),\n     })\n }\n+\n+fn placeholder_block<'tcx>(source_info: SourceInfo) -> BasicBlockData<'tcx> {\n+    BasicBlockData {\n+        statements: vec![],\n+        terminator: Some(Terminator {\n+            source_info,\n+            // this gets overwritten by the counter Call\n+            kind: TerminatorKind::Unreachable,\n+        }),\n+        is_cleanup: false,\n+    }\n+}"}, {"sha": "956ddd2051bac39b6f4c216162c9e126f2d8b04b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2", "patch": "@@ -288,8 +288,6 @@ fn mir_validated(\n         &[&[\n             // What we need to run borrowck etc.\n             &promote_pass,\n-            // FIXME(richkadel): is this the best place for the InstrumentCoverage pass?\n-            &instrument_coverage::InstrumentCoverage,\n             &simplify::SimplifyCfg::new(\"qualify-consts\"),\n         ]],\n     );\n@@ -340,6 +338,10 @@ fn run_post_borrowck_cleanup_passes<'tcx>(\n         // `AddRetag` needs to run after `ElaborateDrops`. Otherwise it should run fairly late,\n         // but before optimizations begin.\n         &add_retag::AddRetag,\n+        // If the `instrument-coverage` option is enabled, analyze the CFG, identify each\n+        // conditional branch, construct a coverage map to be passed to LLVM, and inject counters\n+        // where needed.\n+        &instrument_coverage::InstrumentCoverage,\n         &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n     ];\n "}, {"sha": "2d231359057fd1669603e11f5337f6c21e74ba84", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=7e49a9ec59f7950efa9950b65c10f9b3f3a4b6b2", "patch": "@@ -877,8 +877,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         (such as entering an empty infinite loop) by inserting llvm.sideeffect \\\n         (default: no)\"),\n     instrument_coverage: bool = (false, parse_bool, [TRACKED],\n-        \"instrument the generated code with LLVM code region counters for \\\n-        generating coverage reports (default: no)\"),\n+        \"instrument the generated code with LLVM code region counters to \\\n+        (in the future) generate coverage reports (experimental; default: no)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}]}