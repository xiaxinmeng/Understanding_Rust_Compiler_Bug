{"sha": "3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMmRjNmU5NDAyODI0ZjVmZWNiYTRmMDc2ZDBiZjJiY2QwMWNiZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-12T15:38:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-12T15:38:13Z"}, "message": "Auto merge of #45753 - sinkuu:mir_copyprop_arg, r=arielb1\n\nFix MIR CopyPropagation errneously propagating assignments to function args\n\nCompiling this code with MIR CopyPropagation activated will result in printing `5`,\nbecause CopyProp errneously propagates the assignment of `5` to all `x`:\n\n```rust\nfn bar(mut x: u8) {\n    println!(\"{}\", x);\n    x = 5;\n}\n\nfn main() {\n    bar(123);\n}\n\n```\n\nIf a local is propagated, it will result in an ICE at trans due to an use-before-def:\n\n```rust\nfn dummy(x: u8) -> u8 { x }\n\nfn foo(mut x: u8) {\n    x = dummy(x); // this will assign a local to `x`\n}\n```\nCurrently CopyProp conservatively gives up if there are multiple assignments to a local,\nbut it is not took into account that arguments are already assigned from the beginning.\nThis PR fixes the problem by preventing propagation of assignments to function arguments.", "tree": {"sha": "ad24d3754466c77d700bb34e5a809400e702b2b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad24d3754466c77d700bb34e5a809400e702b2b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb", "html_url": "https://github.com/rust-lang/rust/commit/3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b6f7252a135a3fd1dba6f5e002b9d3d3af034b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b6f7252a135a3fd1dba6f5e002b9d3d3af034b9", "html_url": "https://github.com/rust-lang/rust/commit/4b6f7252a135a3fd1dba6f5e002b9d3d3af034b9"}, {"sha": "114252410d72b63bda4eefa62df77727d1f1cc41", "url": "https://api.github.com/repos/rust-lang/rust/commits/114252410d72b63bda4eefa62df77727d1f1cc41", "html_url": "https://github.com/rust-lang/rust/commit/114252410d72b63bda4eefa62df77727d1f1cc41"}], "stats": {"total": 188, "additions": 183, "deletions": 5}, "files": [{"sha": "a730fc30615b46bc42489581b4d861b9e524a799", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb", "patch": "@@ -69,10 +69,14 @@ impl MirPass for CopyPropagation {\n             return;\n         }\n \n+        let mut def_use_analysis = DefUseAnalysis::new(mir);\n         loop {\n-            let mut def_use_analysis = DefUseAnalysis::new(mir);\n             def_use_analysis.analyze(mir);\n \n+            if eliminate_self_assignments(mir, &def_use_analysis) {\n+                def_use_analysis.analyze(mir);\n+            }\n+\n             let mut changed = false;\n             for dest_local in mir.local_decls.indices() {\n                 debug!(\"Considering destination local: {:?}\", dest_local);\n@@ -99,9 +103,14 @@ impl MirPass for CopyPropagation {\n                                dest_local);\n                         continue\n                     }\n-                    let dest_lvalue_def = dest_use_info.defs_and_uses.iter().filter(|lvalue_def| {\n-                        lvalue_def.context.is_mutating_use() && !lvalue_def.context.is_drop()\n-                    }).next().unwrap();\n+                    // Conservatively gives up if the dest is an argument,\n+                    // because there may be uses of the original argument value.\n+                    if mir.local_kind(dest_local) == LocalKind::Arg {\n+                        debug!(\"  Can't copy-propagate local: dest {:?} (argument)\",\n+                            dest_local);\n+                        continue;\n+                    }\n+                    let dest_lvalue_def = dest_use_info.defs_not_including_drop().next().unwrap();\n                     location = dest_lvalue_def.location;\n \n                     let basic_block = &mir[location.block];\n@@ -151,6 +160,39 @@ impl MirPass for CopyPropagation {\n     }\n }\n \n+fn eliminate_self_assignments<'tcx>(\n+    mir: &mut Mir<'tcx>,\n+    def_use_analysis: &DefUseAnalysis<'tcx>,\n+) -> bool {\n+    let mut changed = false;\n+\n+    for dest_local in mir.local_decls.indices() {\n+        let dest_use_info = def_use_analysis.local_info(dest_local);\n+\n+        for def in dest_use_info.defs_not_including_drop() {\n+            let location = def.location;\n+            if let Some(stmt) = mir[location.block].statements.get(location.statement_index) {\n+                match stmt.kind {\n+                    StatementKind::Assign(\n+                        Lvalue::Local(local),\n+                        Rvalue::Use(Operand::Consume(Lvalue::Local(src_local))),\n+                    ) if local == dest_local && dest_local == src_local => {}\n+                    _ => {\n+                        continue;\n+                    }\n+                }\n+            } else {\n+                continue;\n+            }\n+            debug!(\"Deleting a self-assignment for {:?}\", dest_local);\n+            mir.make_statement_nop(location);\n+            changed = true;\n+        }\n+    }\n+\n+    changed\n+}\n+\n enum Action<'tcx> {\n     PropagateLocalCopy(Local),\n     PropagateConstant(Constant<'tcx>),"}, {"sha": "9ada8f2bebf706c1c56a65ff0b6e020a0eb178cc", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb", "patch": "@@ -15,6 +15,8 @@ use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::marker::PhantomData;\n use std::mem;\n+use std::slice;\n+use std::iter;\n \n pub struct DefUseAnalysis<'tcx> {\n     info: IndexVec<Local, Info<'tcx>>,\n@@ -39,13 +41,21 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n     }\n \n     pub fn analyze(&mut self, mir: &Mir<'tcx>) {\n+        self.clear();\n+\n         let mut finder = DefUseFinder {\n             info: mem::replace(&mut self.info, IndexVec::new()),\n         };\n         finder.visit_mir(mir);\n         self.info = finder.info\n     }\n \n+    fn clear(&mut self) {\n+        for info in &mut self.info {\n+            info.clear();\n+        }\n+    }\n+\n     pub fn local_info(&self, local: Local) -> &Info<'tcx> {\n         &self.info[local]\n     }\n@@ -93,14 +103,24 @@ impl<'tcx> Info<'tcx> {\n         }\n     }\n \n+    fn clear(&mut self) {\n+        self.defs_and_uses.clear();\n+    }\n+\n     pub fn def_count(&self) -> usize {\n         self.defs_and_uses.iter().filter(|lvalue_use| lvalue_use.context.is_mutating_use()).count()\n     }\n \n     pub fn def_count_not_including_drop(&self) -> usize {\n+        self.defs_not_including_drop().count()\n+    }\n+\n+    pub fn defs_not_including_drop(\n+        &self,\n+    ) -> iter::Filter<slice::Iter<Use<'tcx>>, fn(&&Use<'tcx>) -> bool> {\n         self.defs_and_uses.iter().filter(|lvalue_use| {\n             lvalue_use.context.is_mutating_use() && !lvalue_use.context.is_drop()\n-        }).count()\n+        })\n     }\n \n     pub fn use_count(&self) -> usize {"}, {"sha": "ae30b5fae88f8178ca37e51cb503810f8c6fc19f", "filename": "src/test/mir-opt/copy_propagation_arg.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs?ref=3d2dc6e9402824f5fecba4f076d0bf2bcd01cbeb", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that CopyPropagation does not propagate an assignment to a function argument\n+// (doing so can break usages of the original argument value)\n+\n+fn dummy(x: u8) -> u8 {\n+    x\n+}\n+\n+fn foo(mut x: u8) {\n+    // calling `dummy` to make an use of `x` that copyprop cannot eliminate\n+    x = dummy(x); // this will assign a local to `x`\n+}\n+\n+fn bar(mut x: u8) {\n+    dummy(x);\n+    x = 5;\n+}\n+\n+fn baz(mut x: i32) {\n+    // self-assignment to a function argument should be eliminated\n+    x = x;\n+}\n+\n+fn main() {\n+    // Make sure the function actually gets instantiated.\n+    foo(0);\n+    bar(0);\n+    baz(0);\n+}\n+\n+// END RUST SOURCE\n+// START rustc.foo.CopyPropagation.before.mir\n+// bb0: {\n+//     StorageLive(_2);\n+//     StorageLive(_3);\n+//     _3 = _1;\n+//     _2 = const dummy(_3) -> bb1;\n+// }\n+// bb1: {\n+//     StorageDead(_3);\n+//     _1 = _2;\n+//     StorageDead(_2);\n+//     _0 = ();\n+//     return;\n+// }\n+// END rustc.foo.CopyPropagation.before.mir\n+// START rustc.foo.CopyPropagation.after.mir\n+// bb0: {\n+//     StorageLive(_2);\n+//     nop;\n+//     nop;\n+//     _2 = const dummy(_1) -> bb1;\n+// }\n+// bb1: {\n+//     nop;\n+//     _1 = _2;\n+//     StorageDead(_2);\n+//     _0 = ();\n+//     return;\n+// }\n+// END rustc.foo.CopyPropagation.after.mir\n+// START rustc.bar.CopyPropagation.before.mir\n+// bb0: {\n+//     StorageLive(_3);\n+//     _3 = _1;\n+//     _2 = const dummy(_3) -> bb1;\n+// }\n+// bb1: {\n+//     StorageDead(_3);\n+//     _1 = const 5u8;\n+//     _0 = ();\n+//     return;\n+// }\n+// END rustc.bar.CopyPropagation.before.mir\n+// START rustc.bar.CopyPropagation.after.mir\n+// bb0: {\n+//     nop;\n+//     nop;\n+//     _2 = const dummy(_1) -> bb1;\n+// }\n+// bb1: {\n+//     nop;\n+//     _1 = const 5u8;\n+//     _0 = ();\n+//     return;\n+// }\n+// END rustc.bar.CopyPropagation.after.mir\n+// START rustc.baz.CopyPropagation.before.mir\n+// bb0: {\n+//     StorageLive(_2);\n+//     _2 = _1;\n+//     _1 = _2;\n+//     StorageDead(_2);\n+//     _0 = ();\n+//     return;\n+// }\n+// END rustc.baz.CopyPropagation.before.mir\n+// START rustc.baz.CopyPropagation.after.mir\n+// bb0: {\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     _0 = ();\n+//     return;\n+// }\n+// END rustc.baz.CopyPropagation.after.mir"}]}