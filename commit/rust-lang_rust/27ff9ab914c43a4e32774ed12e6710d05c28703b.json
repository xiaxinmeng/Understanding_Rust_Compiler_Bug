{"sha": "27ff9ab914c43a4e32774ed12e6710d05c28703b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZmY5YWI5MTRjNDNhNGUzMjc3NGVkMTJlNjcxMGQwNWMyODcwM2I=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-18T16:48:31Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-18T16:48:31Z"}, "message": "Add initial support for closures.", "tree": {"sha": "1ae363a78b98ee9680ac466e0d4b8698f1db66b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ae363a78b98ee9680ac466e0d4b8698f1db66b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27ff9ab914c43a4e32774ed12e6710d05c28703b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27ff9ab914c43a4e32774ed12e6710d05c28703b", "html_url": "https://github.com/rust-lang/rust/commit/27ff9ab914c43a4e32774ed12e6710d05c28703b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27ff9ab914c43a4e32774ed12e6710d05c28703b/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8f31ea5491ee282711b59b6bcbffc1140052a3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8f31ea5491ee282711b59b6bcbffc1140052a3f", "html_url": "https://github.com/rust-lang/rust/commit/f8f31ea5491ee282711b59b6bcbffc1140052a3f"}], "stats": {"total": 150, "additions": 100, "deletions": 50}, "files": [{"sha": "3e1444ad51640646264c1d3f4bda7f53f379644f", "filename": "src/interpreter.rs", "status": "modified", "additions": 62, "deletions": 50, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/27ff9ab914c43a4e32774ed12e6710d05c28703b/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ff9ab914c43a4e32774ed12e6710d05c28703b/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=27ff9ab914c43a4e32774ed12e6710d05c28703b", "patch": "@@ -145,29 +145,20 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         Ok(())\n     }\n \n-    fn push_stack_frame(&mut self, mir: CachedMir<'a, 'tcx>, args: &[mir::Operand<'tcx>],\n-                        return_ptr: Option<Pointer>) -> EvalResult<()> {\n-        let num_args = mir.arg_decls.len();\n-        let num_vars = mir.var_decls.len();\n-        let num_temps = mir.temp_decls.len();\n-        assert_eq!(args.len(), num_args);\n-\n-        let mut locals = Vec::with_capacity(num_args + num_vars + num_temps);\n-\n-        for (arg_decl, arg_operand) in mir.arg_decls.iter().zip(args) {\n-            let size = self.ty_size(arg_decl.ty);\n-            let dest = self.memory.allocate(size);\n-            let src = try!(self.eval_operand(arg_operand));\n-            try!(self.memory.copy(src, dest, size));\n-            locals.push(dest);\n-        }\n-\n+    fn push_stack_frame(&mut self, mir: CachedMir<'a, 'tcx>, return_ptr: Option<Pointer>)\n+        -> EvalResult<()>\n+    {\n+        let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n         let var_tys = mir.var_decls.iter().map(|v| v.ty);\n         let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n-        locals.extend(var_tys.chain(temp_tys).map(|ty| {\n+\n+        let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n             let size = self.ty_size(ty);\n             self.memory.allocate(size)\n-        }));\n+        }).collect();\n+\n+        let num_args = mir.arg_decls.len();\n+        let num_vars = mir.var_decls.len();\n \n         self.stack.push(Frame {\n             mir: mir.clone(),\n@@ -238,31 +229,60 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                     return_ptr = Some(try!(self.eval_lvalue(lv)));\n                 }\n \n-                let func_ty = self.current_frame().mir.operand_ty(self.tcx, func);\n-\n+                let func_ty = self.operand_ty(func);\n                 match func_ty.sty {\n                     ty::TyFnDef(def_id, substs, fn_ty) => {\n-                        let substs = self.tcx.mk_substs(\n-                            substs.subst(self.tcx, self.current_substs()));\n-\n                         use syntax::abi::Abi;\n                         match fn_ty.abi {\n                             Abi::RustIntrinsic => {\n                                 let name = self.tcx.item_name(def_id).as_str();\n                                 try!(self.call_intrinsic(&name, substs, args))\n                             }\n \n-                            Abi::Rust => {\n+                            Abi::Rust | Abi::RustCall => {\n+                                // TODO(tsion): Adjust the first argument when calling a Fn or\n+                                // FnMut closure via FnOnce::call_once.\n+\n                                 // Only trait methods can have a Self parameter.\n                                 let (def_id, substs) = if substs.self_ty().is_some() {\n                                     self.trait_method(def_id, substs)\n                                 } else {\n                                     (def_id, substs)\n                                 };\n \n+                                let mut arg_srcs = Vec::new();\n+                                for arg in args {\n+                                    let (src, repr) = try!(self.eval_operand_and_repr(arg));\n+                                    arg_srcs.push((src, repr.size()));\n+                                }\n+\n+                                if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n+                                    arg_srcs.pop();\n+                                    let last_arg = args.last().unwrap();\n+                                    let (last_src, last_repr) =\n+                                        try!(self.eval_operand_and_repr(last_arg));\n+                                    match *last_repr {\n+                                        Repr::Aggregate { discr_size: 0, ref variants, .. } => {\n+                                            assert_eq!(variants.len(), 1);\n+                                            for field in &variants[0] {\n+                                                let src = last_src.offset(field.offset as isize);\n+                                                arg_srcs.push((src, field.size));\n+                                            }\n+                                        }\n+\n+                                        _ => panic!(\"expected tuple as last argument in function with 'rust-call' ABI\"),\n+                                    }\n+                                }\n+\n                                 let mir = self.load_mir(def_id);\n                                 self.substs_stack.push(substs);\n-                                try!(self.push_stack_frame(mir, args, return_ptr));\n+                                try!(self.push_stack_frame(mir, return_ptr));\n+\n+                                for (i, (src, size)) in arg_srcs.into_iter().enumerate() {\n+                                    let dest = self.current_frame().locals[i];\n+                                    try!(self.memory.copy(src, dest, size));\n+                                }\n+\n                                 TerminatorTarget::Call\n                             }\n \n@@ -393,7 +413,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                         _ => panic!(\"expected Repr::Array target\"),\n                     },\n \n-                    Closure(..) => unimplemented!(),\n+                    Closure(..) => self.assign_to_aggregate(dest, &dest_repr, 0, operands),\n                 }\n             }\n \n@@ -422,7 +442,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                 }\n \n                 let src = try!(self.eval_operand(operand));\n-                let src_ty = self.current_frame().mir.operand_ty(self.tcx, operand);\n+                let src_ty = self.operand_ty(operand);\n \n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n@@ -465,7 +485,9 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n     }\n \n     fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> ty::Ty<'tcx> {\n-        self.current_frame().mir.operand_ty(self.tcx, operand)\n+        self.current_frame().mir\n+            .operand_ty(self.tcx, operand)\n+            .subst(self.tcx, self.current_substs())\n     }\n \n     fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<Pointer> {\n@@ -623,6 +645,9 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                 }\n             }\n \n+            ty::TyClosure(_, ref closure_substs) =>\n+                self.make_aggregate_repr(iter::once(closure_substs.upvar_tys.iter().cloned())),\n+\n             ref t => panic!(\"can't convert type to repr: {:?}\", t),\n         };\n \n@@ -736,32 +761,18 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             traits::VtableImpl(vtable_impl) => {\n                 let impl_did = vtable_impl.impl_def_id;\n                 let mname = self.tcx.item_name(def_id);\n-                // Create a concatenated set of substitutions which includes those from the\n-                // impl and those from the method:\n-                let impl_substs = vtable_impl.substs.with_method_from(&substs);\n+                // Create a concatenated set of substitutions which includes those from the impl\n+                // and those from the method:\n+                let impl_substs = vtable_impl.substs.with_method_from(substs);\n                 let substs = self.tcx.mk_substs(impl_substs);\n                 let mth = self.tcx.get_impl_method(impl_did, substs, mname);\n \n-                println!(\"{:?} {:?}\", mth.method.def_id, mth.substs);\n                 (mth.method.def_id, mth.substs)\n             }\n-            traits::VtableClosure(_vtable_closure) => {\n-                // The substitutions should have no type parameters remaining after passing\n-                // through fulfill_obligation\n-                let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                unimplemented!()\n-                // vtable_closure.closure_def_id\n-                // vtable_closure.substs\n-                // trait_closure_kind\n \n-                // let method_ty = def_ty(tcx, def_id, substs);\n-                // let fn_ptr_ty = match method_ty.sty {\n-                //     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n-                //     _ => unreachable!(\"expected fn item type, found {}\",\n-                //                       method_ty)\n-                // };\n-                // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n-            }\n+            traits::VtableClosure(vtable_closure) =>\n+                (vtable_closure.closure_def_id, vtable_closure.substs.func_substs),\n+\n             traits::VtableFnPointer(_fn_ty) => {\n                 let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n                 unimplemented!()\n@@ -775,6 +786,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                 // };\n                 // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n+\n             traits::VtableObject(ref _data) => {\n                 unimplemented!()\n                 // Callee {\n@@ -825,7 +837,7 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n                     }\n                     ty::FnDiverging => None,\n                 };\n-                miri.push_stack_frame(CachedMir::Ref(mir), &[], return_ptr).unwrap();\n+                miri.push_stack_frame(CachedMir::Ref(mir), return_ptr).unwrap();\n                 miri.run().unwrap();\n \n                 if let Some(ret) = return_ptr {"}, {"sha": "bff172d45b47969750f1665cad73f48d9539b9ad", "filename": "test/closures.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/27ff9ab914c43a4e32774ed12e6710d05c28703b/test%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ff9ab914c43a4e32774ed12e6710d05c28703b/test%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fclosures.rs?ref=27ff9ab914c43a4e32774ed12e6710d05c28703b", "patch": "@@ -0,0 +1,38 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+#[miri_run]\n+fn simple() -> i32 {\n+    let y = 10;\n+    let f = |x| x + y;\n+    f(2)\n+}\n+\n+#[miri_run]\n+fn crazy_closure() -> (i32, i32, i32) {\n+    fn inner<T: Copy>(t: T) -> (i32, T, T) {\n+        struct NonCopy;\n+        let x = NonCopy;\n+\n+        let a = 2;\n+        let b = 40;\n+        let f = move |y, z, asdf| {\n+            drop(x);\n+            (a + b + y + z, asdf, t)\n+        };\n+        f(a, b, t)\n+    }\n+\n+    inner(10)\n+}\n+\n+// #[miri_run]\n+// fn closure_arg_adjustment_problem() -> i64 {\n+//     fn once<F: FnOnce(i64)>(f: F) { f(2); }\n+//     let mut y = 1;\n+//     {\n+//         let f = |x| y += x;\n+//         once(f);\n+//     }\n+//     y\n+// }"}]}