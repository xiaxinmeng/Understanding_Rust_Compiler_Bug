{"sha": "ef3b88c5f936921fc3ba7968af3dcf1724a17551", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmM2I4OGM1ZjkzNjkyMWZjM2JhNzk2OGFmM2RjZjE3MjRhMTc1NTE=", "commit": {"author": {"name": "NODA, Kai", "email": "nodakai@gmail.com", "date": "2014-11-23T11:37:33Z"}, "committer": {"name": "NODA, Kai", "email": "nodakai@gmail.com", "date": "2014-11-23T12:05:58Z"}, "message": "libcollection: generalize StrVector to AsSlice<Str>.\n\nThe impl for [T] also works as impl for slices in general.\nBy generalizing the impl of StrVector for Vec<Str> to that for\nAsSlice<Str>, it becomes much more generic.\n\nOnce Iterable is implemented, we will prefer it to AsSlice.\nBut the with_capacity() part might become tricky.\n\nSigned-off-by: NODA, Kai <nodakai@gmail.com>", "tree": {"sha": "3725a34dfdf0b0df22a7c0290b7c1ddded77faa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3725a34dfdf0b0df22a7c0290b7c1ddded77faa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef3b88c5f936921fc3ba7968af3dcf1724a17551", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3b88c5f936921fc3ba7968af3dcf1724a17551", "html_url": "https://github.com/rust-lang/rust/commit/ef3b88c5f936921fc3ba7968af3dcf1724a17551", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef3b88c5f936921fc3ba7968af3dcf1724a17551/comments", "author": {"login": "nodakai", "id": 90726, "node_id": "MDQ6VXNlcjkwNzI2", "avatar_url": "https://avatars.githubusercontent.com/u/90726?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nodakai", "html_url": "https://github.com/nodakai", "followers_url": "https://api.github.com/users/nodakai/followers", "following_url": "https://api.github.com/users/nodakai/following{/other_user}", "gists_url": "https://api.github.com/users/nodakai/gists{/gist_id}", "starred_url": "https://api.github.com/users/nodakai/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nodakai/subscriptions", "organizations_url": "https://api.github.com/users/nodakai/orgs", "repos_url": "https://api.github.com/users/nodakai/repos", "events_url": "https://api.github.com/users/nodakai/events{/privacy}", "received_events_url": "https://api.github.com/users/nodakai/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nodakai", "id": 90726, "node_id": "MDQ6VXNlcjkwNzI2", "avatar_url": "https://avatars.githubusercontent.com/u/90726?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nodakai", "html_url": "https://github.com/nodakai", "followers_url": "https://api.github.com/users/nodakai/followers", "following_url": "https://api.github.com/users/nodakai/following{/other_user}", "gists_url": "https://api.github.com/users/nodakai/gists{/gist_id}", "starred_url": "https://api.github.com/users/nodakai/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nodakai/subscriptions", "organizations_url": "https://api.github.com/users/nodakai/orgs", "repos_url": "https://api.github.com/users/nodakai/repos", "events_url": "https://api.github.com/users/nodakai/events{/privacy}", "received_events_url": "https://api.github.com/users/nodakai/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ff10d5a230acde7e530ccee8cd4f805d6be7713", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ff10d5a230acde7e530ccee8cd4f805d6be7713", "html_url": "https://github.com/rust-lang/rust/commit/5ff10d5a230acde7e530ccee8cd4f805d6be7713"}], "stats": {"total": 111, "additions": 75, "deletions": 36}, "files": [{"sha": "9982eaefff8f8c6b09027859c9eb45dba44b13aa", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 75, "deletions": 36, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ef3b88c5f936921fc3ba7968af3dcf1724a17551/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3b88c5f936921fc3ba7968af3dcf1724a17551/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=ef3b88c5f936921fc3ba7968af3dcf1724a17551", "patch": "@@ -163,7 +163,7 @@ impl<S: Str> StrVector for [S] {\n     }\n }\n \n-impl<S: Str> StrVector for Vec<S> {\n+impl<S: Str, T: AsSlice<S>> StrVector for T {\n     #[inline]\n     fn concat(&self) -> String {\n         self.as_slice().concat()\n@@ -929,54 +929,93 @@ mod tests {\n         assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".slice_chars(2, 8));\n     }\n \n-    #[test]\n-    fn test_concat() {\n-        fn t(v: &[String], s: &str) {\n-            assert_eq!(v.concat().as_slice(), s);\n+    struct S {\n+        x: [String, .. 2]\n+    }\n+\n+    impl AsSlice<String> for S {\n+        fn as_slice<'a> (&'a self) -> &'a [String] {\n+            &self.x\n+        }\n+    }\n+\n+    fn s(x: &str) -> String { x.into_string() }\n+\n+    macro_rules! test_concat {\n+        ($expected: expr, $string: expr) => {\n+            {\n+                let s = $string.concat();\n+                assert_eq!($expected, s.as_slice());\n+            }\n         }\n-        t(&[String::from_str(\"you\"), String::from_str(\"know\"),\n-            String::from_str(\"I'm\"),\n-            String::from_str(\"no\"), String::from_str(\"good\")],\n-          \"youknowI'mnogood\");\n-        let v: &[String] = &[];\n-        t(v, \"\");\n-        t(&[String::from_str(\"hi\")], \"hi\");\n     }\n \n     #[test]\n-    fn test_connect() {\n-        fn t(v: &[String], sep: &str, s: &str) {\n-            assert_eq!(v.connect(sep).as_slice(), s);\n+    fn test_concat_for_different_types() {\n+        test_concat!(\"ab\", [\"a\", \"b\"]);\n+        test_concat!(\"ab\", [s(\"a\"), s(\"b\")]);\n+        test_concat!(\"ab\", vec![\"a\", \"b\"]);\n+        test_concat!(\"ab\", vec![\"a\", \"b\"].as_slice());\n+        test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n+\n+        let mut v0 = [\"a\", \"b\"];\n+        let mut v1 = [s(\"a\"), s(\"b\")];\n+        unsafe {\n+            use std::c_vec::CVec;\n+\n+            test_concat!(\"ab\", CVec::new(v0.as_mut_ptr(), v0.len()));\n+            test_concat!(\"ab\", CVec::new(v1.as_mut_ptr(), v1.len()));\n         }\n-        t(&[String::from_str(\"you\"), String::from_str(\"know\"),\n-            String::from_str(\"I'm\"),\n-            String::from_str(\"no\"), String::from_str(\"good\")],\n-          \" \", \"you know I'm no good\");\n-        let v: &[String] = &[];\n-        t(v, \" \", \"\");\n-        t(&[String::from_str(\"hi\")], \" \", \"hi\");\n+\n+        test_concat!(\"ab\", S { x: [s(\"a\"), s(\"b\")] });\n     }\n \n     #[test]\n-    fn test_concat_slices() {\n-        fn t(v: &[&str], s: &str) {\n-            assert_eq!(v.concat().as_slice(), s);\n+    fn test_concat_for_different_lengths() {\n+        let empty: &[&str] = &[];\n+        test_concat!(\"\", empty);\n+        test_concat!(\"a\", [\"a\"]);\n+        test_concat!(\"ab\", [\"a\", \"b\"]);\n+        test_concat!(\"abc\", [\"\", \"a\", \"bc\"]);\n+    }\n+\n+    macro_rules! test_connect {\n+        ($expected: expr, $string: expr, $delim: expr) => {\n+            {\n+                let s = $string.connect($delim);\n+                assert_eq!($expected, s.as_slice());\n+            }\n         }\n-        t(&[\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n-        let v: &[&str] = &[];\n-        t(v, \"\");\n-        t(&[\"hi\"], \"hi\");\n     }\n \n     #[test]\n-    fn test_connect_slices() {\n-        fn t(v: &[&str], sep: &str, s: &str) {\n-            assert_eq!(v.connect(sep).as_slice(), s);\n+    fn test_connect_for_different_types() {\n+        test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n+        let hyphen = \"-\".into_string();\n+        test_connect!(\"a-b\", [s(\"a\"), s(\"b\")], hyphen.as_slice());\n+        test_connect!(\"a-b\", vec![\"a\", \"b\"], hyphen.as_slice());\n+        test_connect!(\"a-b\", vec![\"a\", \"b\"].as_slice(), \"-\");\n+        test_connect!(\"a-b\", vec![s(\"a\"), s(\"b\")], \"-\");\n+\n+        let mut v0 = [\"a\", \"b\"];\n+        let mut v1 = [s(\"a\"), s(\"b\")];\n+        unsafe {\n+            use std::c_vec::CVec;\n+\n+            test_connect!(\"a-b\", CVec::new(v0.as_mut_ptr(), v0.len()), \"-\");\n+            test_connect!(\"a-b\", CVec::new(v1.as_mut_ptr(), v1.len()), hyphen.as_slice());\n         }\n-        t(&[\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n-          \" \", \"you know I'm no good\");\n-        t(&[], \" \", \"\");\n-        t(&[\"hi\"], \" \", \"hi\");\n+\n+        test_connect!(\"a-b\", S { x: [s(\"a\"), s(\"b\")] }, \"-\");\n+    }\n+\n+    #[test]\n+    fn test_connect_for_different_lengths() {\n+        let empty: &[&str] = &[];\n+        test_connect!(\"\", empty, \"-\");\n+        test_connect!(\"a\", [\"a\"], \"-\");\n+        test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n+        test_connect!(\"-a-bc\", [\"\", \"a\", \"bc\"], \"-\");\n     }\n \n     #[test]"}]}