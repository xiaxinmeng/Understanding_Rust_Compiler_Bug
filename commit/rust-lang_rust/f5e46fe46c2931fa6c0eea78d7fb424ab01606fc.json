{"sha": "f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZTQ2ZmU0NmMyOTMxZmE2YzBlZWE3OGQ3ZmI0MjRhYjAxNjA2ZmM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-23T20:10:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-23T20:10:05Z"}, "message": "Rollup merge of #73488 - richkadel:llvm-coverage-map-gen, r=tmandry\n\ncode coverage foundation for hash and num_counters\n\nThis PR is the next iteration after PR #73011 (which is still waiting on bors to merge).\n\n@wesleywiser - PTAL\nr? @tmandry\n\n(FYI, I'm also working on injecting the coverage maps, in another branch, while waiting for these to merge.)\n\nThanks!", "tree": {"sha": "6389a1cee58f52757d18def4ed319ddfc0e4d352", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6389a1cee58f52757d18def4ed319ddfc0e4d352"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe8mGeCRBK7hj4Ov3rIwAAdHIIAFGcNIquBqnEza8kZRHE3N1L\nm3vCBgvpQ4k4/+RRiEgmw06icDOuZ+WUZX7ESClaDLszTfFCQLl61ErcZRA+6T8v\np3oBEZNzPczfA/tdIrguOR/Q5CZmrJVJmrgE2u5Q0DFntG/yCusiRRkAQgl/Jtaf\n40D02F1h23mWmKJLkeObD4zRSFD6+Wjr1nP/09t27vYFlObKj7r5n88Qlj3JVLEX\nJjNQTrSfDZpSR9x0Cs433aDHLQsoWWqnLFiHJyypyKTq5BIr3pNsHZeZPhlAyEYg\n67sgfh0UZRkYRC/r9Fa78vNEolSo95wNu+0YI9SEEjewk98EWn0r9TXGxhzeoFg=\n=E4pF\n-----END PGP SIGNATURE-----\n", "payload": "tree 6389a1cee58f52757d18def4ed319ddfc0e4d352\nparent 781b5899970f08488a540392a5f48c03bbf98a1e\nparent 977ce57d915914139c4aa643e63f368913e5f437\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592943005 -0700\ncommitter GitHub <noreply@github.com> 1592943005 -0700\n\nRollup merge of #73488 - richkadel:llvm-coverage-map-gen, r=tmandry\n\ncode coverage foundation for hash and num_counters\n\nThis PR is the next iteration after PR #73011 (which is still waiting on bors to merge).\n\n@wesleywiser - PTAL\nr? @tmandry\n\n(FYI, I'm also working on injecting the coverage maps, in another branch, while waiting for these to merge.)\n\nThanks!\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "html_url": "https://github.com/rust-lang/rust/commit/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "781b5899970f08488a540392a5f48c03bbf98a1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/781b5899970f08488a540392a5f48c03bbf98a1e", "html_url": "https://github.com/rust-lang/rust/commit/781b5899970f08488a540392a5f48c03bbf98a1e"}, {"sha": "977ce57d915914139c4aa643e63f368913e5f437", "url": "https://api.github.com/repos/rust-lang/rust/commits/977ce57d915914139c4aa643e63f368913e5f437", "html_url": "https://github.com/rust-lang/rust/commit/977ce57d915914139c4aa643e63f368913e5f437"}], "stats": {"total": 324, "additions": 240, "deletions": 84}, "files": [{"sha": "0a1cc31044a228557ba0f64ef3287e0c1a6eb6ef", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "patch": "@@ -23,7 +23,6 @@ use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::Span;\n-use rustc_span::Symbol;\n use rustc_target::abi::{self, HasDataLayout, LayoutOf, Primitive};\n use rustc_target::spec::PanicStrategy;\n \n@@ -141,26 +140,20 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.call(llfn, &[], None)\n             }\n             \"count_code_region\" => {\n-                if let ty::InstanceDef::Item(fn_def_id) = caller_instance.def {\n-                    let caller_fn_path = tcx.def_path_str(fn_def_id);\n-                    debug!(\n-                        \"count_code_region to llvm.instrprof.increment(fn_name={})\",\n-                        caller_fn_path\n-                    );\n-\n-                    // FIXME(richkadel): (1) Replace raw function name with mangled function name;\n-                    // (2) Replace hardcoded `1234` in `hash` with a computed hash (as discussed in)\n-                    // the MCP (compiler-team/issues/278); and replace the hardcoded `1` for\n-                    // `num_counters` with the actual number of counters per function (when the\n-                    // changes are made to inject more than one counter per function).\n-                    let (fn_name, _len_val) = self.const_str(Symbol::intern(&caller_fn_path));\n-                    let index = args[0].immediate();\n-                    let hash = self.const_u64(1234);\n-                    let num_counters = self.const_u32(1);\n-                    self.instrprof_increment(fn_name, hash, num_counters, index)\n-                } else {\n-                    bug!(\"intrinsic count_code_region: no src.instance\");\n-                }\n+                // FIXME(richkadel): The current implementation assumes the MIR for the given\n+                // caller_instance represents a single function. Validate and/or correct if inlining\n+                // and/or monomorphization invalidates these assumptions.\n+                let coverage_data = tcx.coverage_data(caller_instance.def_id());\n+                let mangled_fn = tcx.symbol_name(caller_instance);\n+                let (mangled_fn_name, _len_val) = self.const_str(mangled_fn.name);\n+                let hash = self.const_u64(coverage_data.hash);\n+                let num_counters = self.const_u32(coverage_data.num_counters);\n+                let index = args[0].immediate();\n+                debug!(\n+                    \"count_code_region to LLVM intrinsic instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n+                    mangled_fn.name, hash, num_counters, index\n+                );\n+                self.instrprof_increment(mangled_fn_name, hash, num_counters, index)\n             }\n             \"va_start\" => self.va_start(args[0].immediate()),\n             \"va_end\" => self.va_end(args[0].immediate()),"}, {"sha": "1bdac1039b55a48e07bb179599993968857b0fdf", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "patch": "@@ -488,6 +488,8 @@ impl<'a> CrateLocator<'a> {\n                 && self.triple != TargetTriple::from_triple(config::host_triple())\n             {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n+            } else if self.crate_name == sym::profiler_builtins {\n+                err.note(&\"the compiler may have been built without the profiler runtime\");\n             }\n             err.span_label(self.span, \"can't find crate\");\n             err"}, {"sha": "3a4fc581f5f2607d91e1a34c5b199bdfc8532eb6", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "patch": "@@ -56,7 +56,7 @@ fn fn_sig<'hir>(node: Node<'hir>) -> Option<&'hir FnSig<'hir>> {\n     }\n }\n \n-fn associated_body<'hir>(node: Node<'hir>) -> Option<BodyId> {\n+pub fn associated_body<'hir>(node: Node<'hir>) -> Option<BodyId> {\n     match node {\n         Node::Item(Item {\n             kind: ItemKind::Const(_, body) | ItemKind::Static(.., body) | ItemKind::Fn(.., body),"}, {"sha": "f5b0b73c49de1cf7230f100bfd2e3d53a377d7c5", "filename": "src/librustc_middle/ich/hcx.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_middle%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_middle%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fhcx.rs?ref=f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "patch": "@@ -67,13 +67,15 @@ impl<'a> StableHashingContext<'a> {\n     /// Don't use it for anything else or you'll run the risk of\n     /// leaking data out of the tracking system.\n     #[inline]\n-    pub fn new(\n+    fn new_with_or_without_spans(\n         sess: &'a Session,\n         krate: &'a hir::Crate<'a>,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n+        always_ignore_spans: bool,\n     ) -> Self {\n-        let hash_spans_initial = !sess.opts.debugging_opts.incremental_ignore_spans;\n+        let hash_spans_initial =\n+            !always_ignore_spans && !sess.opts.debugging_opts.incremental_ignore_spans;\n \n         StableHashingContext {\n             sess,\n@@ -88,6 +90,33 @@ impl<'a> StableHashingContext<'a> {\n         }\n     }\n \n+    #[inline]\n+    pub fn new(\n+        sess: &'a Session,\n+        krate: &'a hir::Crate<'a>,\n+        definitions: &'a Definitions,\n+        cstore: &'a dyn CrateStore,\n+    ) -> Self {\n+        Self::new_with_or_without_spans(\n+            sess,\n+            krate,\n+            definitions,\n+            cstore,\n+            /*always_ignore_spans=*/ false,\n+        )\n+    }\n+\n+    #[inline]\n+    pub fn ignore_spans(\n+        sess: &'a Session,\n+        krate: &'a hir::Crate<'a>,\n+        definitions: &'a Definitions,\n+        cstore: &'a dyn CrateStore,\n+    ) -> Self {\n+        let always_ignore_spans = true;\n+        Self::new_with_or_without_spans(sess, krate, definitions, cstore, always_ignore_spans)\n+    }\n+\n     #[inline]\n     pub fn sess(&self) -> &'a Session {\n         self.sess"}, {"sha": "d89c35d313ca3c41d0c15d84867d167906b778fc", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "patch": "@@ -164,8 +164,8 @@ pub struct Body<'tcx> {\n     /// The user may be writing e.g. `&[(SOME_CELL, 42)][i].1` and this would get promoted, because\n     /// we'd statically know that no thing with interior mutability will ever be available to the\n     /// user without some serious unsafe code.  Now this means that our promoted is actually\n-    /// `&[(SOME_CELL, 42)]` and the MIR using it will do the `&promoted[i].1` projection because the\n-    /// index may be a runtime value. Such a promoted value is illegal because it has reachable\n+    /// `&[(SOME_CELL, 42)]` and the MIR using it will do the `&promoted[i].1` projection because\n+    /// the index may be a runtime value. Such a promoted value is illegal because it has reachable\n     /// interior mutability. This flag just makes this situation very obvious where the previous\n     /// implementation without the flag hid this situation silently.\n     /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n@@ -2921,3 +2921,18 @@ impl Location {\n         }\n     }\n }\n+\n+/// Coverage data associated with each function (MIR) instrumented with coverage counters, when\n+/// compiled with `-Zinstrument_coverage`. The query `tcx.coverage_data(DefId)` computes these\n+/// values on demand (during code generation). This query is only valid after executing the MIR pass\n+/// `InstrumentCoverage`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+pub struct CoverageData {\n+    /// A hash value that can be used by the consumer of the coverage profile data to detect\n+    /// changes to the instrumented source of the associated MIR body (typically, for an\n+    /// individual function).\n+    pub hash: u64,\n+\n+    /// The total number of coverage region counters added to the MIR `Body`.\n+    pub num_counters: u32,\n+}"}, {"sha": "2f51b98085b4eea4d1b1f7395c8484b1f34e2834", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "patch": "@@ -231,6 +231,12 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n+        query coverage_data(key: DefId) -> mir::CoverageData {\n+            desc { |tcx| \"retrieving coverage data from MIR for `{}`\", tcx.def_path_str(key) }\n+            storage(ArenaCacheSelector<'tcx>)\n+            cache_on_disk_if { key.is_local() }\n+        }\n+\n         query promoted_mir(key: DefId) -> IndexVec<mir::Promoted, mir::Body<'tcx>> {\n             desc { |tcx| \"optimizing promoted MIR for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)"}, {"sha": "df08e083d2cbb98ebbeab0e60a3dc73be98cface", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "patch": "@@ -1307,6 +1307,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         StableHashingContext::new(self.sess, krate, self.definitions, &*self.cstore)\n     }\n \n+    #[inline(always)]\n+    pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n+        let krate = self.gcx.untracked_crate;\n+\n+        StableHashingContext::ignore_spans(self.sess, krate, self.definitions, &*self.cstore)\n+    }\n+\n     // This method makes sure that we have a DepNode and a Fingerprint for\n     // every upstream crate. It needs to be called once right after the tcx is\n     // created."}, {"sha": "06b648ab5a908dd3710b02d5cbdde751cfdf4c11", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 157, "deletions": 56, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "patch": "@@ -1,75 +1,159 @@\n use crate::transform::{MirPass, MirSource};\n use crate::util::patch::MirPatch;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::lang_items;\n-use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::*;\n+use rustc_middle::hir;\n+use rustc_middle::ich::StableHashingContext;\n+use rustc_middle::mir::interpret::{ConstValue, Scalar};\n+use rustc_middle::mir::{\n+    self, traversal, BasicBlock, BasicBlockData, CoverageData, Operand, Place, SourceInfo,\n+    StatementKind, Terminator, TerminatorKind, START_BLOCK,\n+};\n use rustc_middle::ty;\n+use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{ConstKind, FnDef};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n \n /// Inserts call to count_code_region() as a placeholder to be replaced during code generation with\n /// the intrinsic llvm.instrprof.increment.\n pub struct InstrumentCoverage;\n \n+/// The `query` provider for `CoverageData`, requested by `codegen_intrinsic_call()` when\n+/// constructing the arguments for `llvm.instrprof.increment`.\n+pub(crate) fn provide(providers: &mut Providers<'_>) {\n+    providers.coverage_data = |tcx, def_id| {\n+        let mir_body = tcx.optimized_mir(def_id);\n+        // FIXME(richkadel): The current implementation assumes the MIR for the given DefId\n+        // represents a single function. Validate and/or correct if inlining and/or monomorphization\n+        // invalidates these assumptions.\n+        let count_code_region_fn =\n+            tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None);\n+        let mut num_counters: u32 = 0;\n+        // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n+        // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n+        // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n+        // not work; but computing the num_counters by adding `1` to the highest index (for a given\n+        // instrumented function) is valid.\n+        for (_, data) in traversal::preorder(mir_body) {\n+            if let Some(terminator) = &data.terminator {\n+                if let TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n+                    &terminator.kind\n+                {\n+                    if let FnDef(called_fn_def_id, _) = func.literal.ty.kind {\n+                        if called_fn_def_id == count_code_region_fn {\n+                            if let Operand::Constant(constant) =\n+                                args.get(0).expect(\"count_code_region has at least one arg\")\n+                            {\n+                                if let ConstKind::Value(ConstValue::Scalar(value)) =\n+                                    constant.literal.val\n+                                {\n+                                    let index = value\n+                                        .to_u32()\n+                                        .expect(\"count_code_region index at arg0 is u32\");\n+                                    num_counters = std::cmp::max(num_counters, index + 1);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        let hash = if num_counters > 0 { hash_mir_source(tcx, def_id) } else { 0 };\n+        CoverageData { num_counters, hash }\n+    };\n+}\n+\n+struct Instrumentor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    num_counters: u32,\n+}\n+\n impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, mir_body: &mut mir::Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.instrument_coverage {\n-            debug!(\"instrumenting {:?}\", src.def_id());\n-            instrument_coverage(tcx, body);\n+            // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n+            // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n+            if src.promoted.is_none() {\n+                debug!(\n+                    \"instrumenting {:?}, span: {}\",\n+                    src.def_id(),\n+                    tcx.sess.source_map().span_to_string(mir_body.span)\n+                );\n+                Instrumentor::new(tcx).inject_counters(mir_body);\n+            }\n         }\n     }\n }\n \n-// The first counter (start of the function) is index zero.\n-const INIT_FUNCTION_COUNTER: u32 = 0;\n-\n-/// Injects calls to placeholder function `count_code_region()`.\n-// FIXME(richkadel): As a first step, counters are only injected at the top of each function.\n-// The complete solution will inject counters at each conditional code branch.\n-pub fn instrument_coverage<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-    let span = body.span.shrink_to_lo();\n-\n-    let count_code_region_fn = function_handle(\n-        tcx,\n-        tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n-        span,\n-    );\n-    let counter_index = Operand::const_from_scalar(\n-        tcx,\n-        tcx.types.u32,\n-        Scalar::from_u32(INIT_FUNCTION_COUNTER),\n-        span,\n-    );\n-\n-    let mut patch = MirPatch::new(body);\n-\n-    let new_block = patch.new_block(placeholder_block(SourceInfo::outermost(body.span)));\n-    let next_block = START_BLOCK;\n-\n-    let temp = patch.new_temp(tcx.mk_unit(), body.span);\n-    patch.patch_terminator(\n-        new_block,\n-        TerminatorKind::Call {\n-            func: count_code_region_fn,\n-            args: vec![counter_index],\n-            // new_block will swapped with the next_block, after applying patch\n-            destination: Some((Place::from(temp), new_block)),\n-            cleanup: None,\n-            from_hir_call: false,\n-            fn_span: span,\n-        },\n-    );\n-\n-    patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n-    patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n-\n-    patch.apply(body);\n-\n-    // To insert the `new_block` in front of the first block in the counted branch (for example,\n-    // the START_BLOCK, at the top of the function), just swap the indexes, leaving the rest of the\n-    // graph unchanged.\n-    body.basic_blocks_mut().swap(next_block, new_block);\n+impl<'tcx> Instrumentor<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        Self { tcx, num_counters: 0 }\n+    }\n+\n+    fn next_counter(&mut self) -> u32 {\n+        let next = self.num_counters;\n+        self.num_counters += 1;\n+        next\n+    }\n+\n+    fn inject_counters(&mut self, mir_body: &mut mir::Body<'tcx>) {\n+        // FIXME(richkadel): As a first step, counters are only injected at the top of each\n+        // function. The complete solution will inject counters at each conditional code branch.\n+        let top_of_function = START_BLOCK;\n+        let entire_function = mir_body.span;\n+\n+        self.inject_counter(mir_body, top_of_function, entire_function);\n+    }\n+\n+    fn inject_counter(\n+        &mut self,\n+        mir_body: &mut mir::Body<'tcx>,\n+        next_block: BasicBlock,\n+        code_region: Span,\n+    ) {\n+        let injection_point = code_region.shrink_to_lo();\n+\n+        let count_code_region_fn = function_handle(\n+            self.tcx,\n+            self.tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n+            injection_point,\n+        );\n+        let counter_index = Operand::const_from_scalar(\n+            self.tcx,\n+            self.tcx.types.u32,\n+            Scalar::from_u32(self.next_counter()),\n+            injection_point,\n+        );\n+\n+        let mut patch = MirPatch::new(mir_body);\n+\n+        let temp = patch.new_temp(self.tcx.mk_unit(), code_region);\n+        let new_block = patch.new_block(placeholder_block(code_region));\n+        patch.patch_terminator(\n+            new_block,\n+            TerminatorKind::Call {\n+                func: count_code_region_fn,\n+                args: vec![counter_index],\n+                // new_block will swapped with the next_block, after applying patch\n+                destination: Some((Place::from(temp), new_block)),\n+                cleanup: None,\n+                from_hir_call: false,\n+                fn_span: injection_point,\n+            },\n+        );\n+\n+        patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n+        patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n+\n+        patch.apply(mir_body);\n+\n+        // To insert the `new_block` in front of the first block in the counted branch (the\n+        // `next_block`), just swap the indexes, leaving the rest of the graph unchanged.\n+        mir_body.basic_blocks_mut().swap(next_block, new_block);\n+    }\n }\n \n fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Operand<'tcx> {\n@@ -79,14 +163,31 @@ fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Ope\n     Operand::function_handle(tcx, fn_def_id, substs, span)\n }\n \n-fn placeholder_block<'tcx>(source_info: SourceInfo) -> BasicBlockData<'tcx> {\n+fn placeholder_block(span: Span) -> BasicBlockData<'tcx> {\n     BasicBlockData {\n         statements: vec![],\n         terminator: Some(Terminator {\n-            source_info,\n+            source_info: SourceInfo::outermost(span),\n             // this gets overwritten by the counter Call\n             kind: TerminatorKind::Unreachable,\n         }),\n         is_cleanup: false,\n     }\n }\n+\n+fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> u64 {\n+    let hir_node = tcx.hir().get_if_local(def_id).expect(\"DefId is local\");\n+    let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n+    let hir_body = tcx.hir().body(fn_body_id);\n+    let mut hcx = tcx.create_no_span_stable_hashing_context();\n+    hash(&mut hcx, &hir_body.value).to_smaller_hash()\n+}\n+\n+fn hash(\n+    hcx: &mut StableHashingContext<'tcx>,\n+    node: &impl HashStable<StableHashingContext<'tcx>>,\n+) -> Fingerprint {\n+    let mut stable_hasher = StableHasher::new();\n+    node.hash_stable(hcx, &mut stable_hasher);\n+    stable_hasher.finish()\n+}"}, {"sha": "8ca240d2c7da77eeffcc15137d77304ed3ba7706", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "patch": "@@ -56,6 +56,7 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n         promoted_mir,\n         ..*providers\n     };\n+    instrument_coverage::provide(providers);\n }\n \n fn is_mir_available(tcx: TyCtxt<'_>, def_id: DefId) -> bool {"}, {"sha": "973891eb84eda2006a56ad9b195d58c60520b5e0", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "patch": "@@ -880,8 +880,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         (such as entering an empty infinite loop) by inserting llvm.sideeffect \\\n         (default: no)\"),\n     instrument_coverage: bool = (false, parse_bool, [TRACKED],\n-        \"instrument the generated code with LLVM code region counters to \\\n-        (in the future) generate coverage reports (experimental; default: no)\"),\n+        \"instrument the generated code with LLVM code region counters to (in the \\\n+        future) generate coverage reports (default: no; note, the compiler build \\\n+        config must include `profiler = true`)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "5b1bafe3955cca090e65dadf89430c290cbac599", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e46fe46c2931fa6c0eea78d7fb424ab01606fc/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=f5e46fe46c2931fa6c0eea78d7fb424ab01606fc", "patch": "@@ -587,6 +587,7 @@ symbols! {\n         proc_macro_mod,\n         proc_macro_non_items,\n         proc_macro_path_invoc,\n+        profiler_builtins,\n         profiler_runtime,\n         ptr_guaranteed_eq,\n         ptr_guaranteed_ne,"}]}