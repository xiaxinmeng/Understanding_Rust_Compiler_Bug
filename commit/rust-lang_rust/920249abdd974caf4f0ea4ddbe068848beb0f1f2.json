{"sha": "920249abdd974caf4f0ea4ddbe068848beb0f1f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMDI0OWFiZGQ5NzRjYWY0ZjBlYTRkZGJlMDY4ODQ4YmViMGYxZjI=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-04-05T08:51:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-04-05T08:51:16Z"}, "message": "Rollup merge of #48658 - llogiq:no-more-cas, r=kennytm\n\nAdd a generic CAS loop to std::sync::Atomic*\n\nThis adds two new methods to both `AtomicIsize` and `AtomicUsize` with optimized safe compare-and-set loops, so users will no longer need to write their own, except in *very* strange circumstances.\n\n`update_and_fetch` will apply the function and return its result, whereas `fetch_and_update` will apply the function and return the previous value.\n\nThis solves #48384 with `x.update_and_fetch(|x| x.max(y))`. It also relates to #48655 (which I misuse as tracking issue for now)..\n\n*note* This *might* need a crater run because the functions could clash with third party extension traits.", "tree": {"sha": "bf453510c153d60b4c81a64829413ab5ead61e90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf453510c153d60b4c81a64829413ab5ead61e90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/920249abdd974caf4f0ea4ddbe068848beb0f1f2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaxeOFCRBK7hj4Ov3rIwAAdHIIAFUCHZ+834YW8KtVUapeOfoy\nyZh61nphzrv0sY/1069g9NQ8KPeZI76PMfR0fFy5pPoFVsoezKKMX4jYtN/vUpRo\n2msElNoDm91ar0B1sbl+s0i60Oi4QBxohIRTbXNwWksERVL3i5J2RgO8y5iTss81\nHlmDzT1b3bQVkzoDH7xsTuEm+L9rZQv3RMzAV+kJ9S2EJJYYe7RWUIuGaJg94CV4\nvgUvZmF5dDDe7UDjgDasUZKLaSzzXf9tRCmsTRTRymfQAp3h7u7noCj5fbjrfcix\ng11teVYhjhlKcjV1blDXu9Wdv1Z60tyPaldtV2JamhNNFRzlHt/hVJoZkE9Jjuk=\n=kIYy\n-----END PGP SIGNATURE-----\n", "payload": "tree bf453510c153d60b4c81a64829413ab5ead61e90\nparent 4bf76d6745046af32d0c0f33484aa15bab1c0e2c\nparent 0f5e4191632de4bbc1ef4ef2be26b517861cbff0\nauthor kennytm <kennytm@gmail.com> 1522918276 +0800\ncommitter GitHub <noreply@github.com> 1522918276 +0800\n\nRollup merge of #48658 - llogiq:no-more-cas, r=kennytm\n\nAdd a generic CAS loop to std::sync::Atomic*\n\nThis adds two new methods to both `AtomicIsize` and `AtomicUsize` with optimized safe compare-and-set loops, so users will no longer need to write their own, except in *very* strange circumstances.\n\n`update_and_fetch` will apply the function and return its result, whereas `fetch_and_update` will apply the function and return the previous value.\n\nThis solves #48384 with `x.update_and_fetch(|x| x.max(y))`. It also relates to #48655 (which I misuse as tracking issue for now)..\n\n*note* This *might* need a crater run because the functions could clash with third party extension traits.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/920249abdd974caf4f0ea4ddbe068848beb0f1f2", "html_url": "https://github.com/rust-lang/rust/commit/920249abdd974caf4f0ea4ddbe068848beb0f1f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/920249abdd974caf4f0ea4ddbe068848beb0f1f2/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bf76d6745046af32d0c0f33484aa15bab1c0e2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bf76d6745046af32d0c0f33484aa15bab1c0e2c", "html_url": "https://github.com/rust-lang/rust/commit/4bf76d6745046af32d0c0f33484aa15bab1c0e2c"}, {"sha": "0f5e4191632de4bbc1ef4ef2be26b517861cbff0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5e4191632de4bbc1ef4ef2be26b517861cbff0", "html_url": "https://github.com/rust-lang/rust/commit/0f5e4191632de4bbc1ef4ef2be26b517861cbff0"}], "stats": {"total": 185, "additions": 185, "deletions": 0}, "files": [{"sha": "d336934ec7214ad56668dae5428abfef74ee7514", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/920249abdd974caf4f0ea4ddbe068848beb0f1f2/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/920249abdd974caf4f0ea4ddbe068848beb0f1f2/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=920249abdd974caf4f0ea4ddbe068848beb0f1f2", "patch": "@@ -952,6 +952,7 @@ macro_rules! atomic_int {\n      $stable_nand:meta,\n      $s_int_type:expr, $int_ref:expr,\n      $extra_feature:expr,\n+     $min_fn:ident, $max_fn:ident,\n      $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n         /// An integer type which can be safely shared between threads.\n         ///\n@@ -1421,6 +1422,128 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n             }\n+\n+            doc_comment! {\n+                concat!(\"Fetches the value, and applies a function to it that returns an optional\n+new value. Returns a `Result` (`Ok(_)` if the function returned `Some(_)`, else `Err(_)`) of the\n+previous value.\n+\n+Note: This may call the function multiple times if the value has been changed from other threads in\n+the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n+but once to the stored value.\n+\n+# Examples\n+\n+```rust\n+#![feature(no_more_cas)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let x = \", stringify!($atomic_type), \"::new(7);\n+assert_eq!(x.fetch_update(|_| None, Ordering::SeqCst, Ordering::SeqCst), Err(7));\n+assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(7));\n+assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(8));\n+assert_eq!(x.load(Ordering::SeqCst), 9);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"no_more_cas\",\n+                       reason = \"no more CAS loops in user code\",\n+                       issue = \"48655\")]\n+                pub fn fetch_update<F>(&self,\n+                                       mut f: F,\n+                                       fetch_order: Ordering,\n+                                       set_order: Ordering) -> Result<$int_type, $int_type>\n+                where F: FnMut($int_type) -> Option<$int_type> {\n+                    let mut prev = self.load(fetch_order);\n+                    while let Some(next) = f(prev) {\n+                        match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n+                            x @ Ok(_) => return x,\n+                            Err(next_prev) => prev = next_prev\n+                        }\n+                    }\n+                    Err(prev)\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Maximum with the current value.\n+\n+Finds the maximum of the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+assert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\n+assert_eq!(foo.load(Ordering::SeqCst), 42);\n+```\n+\n+If you want to obtain the maximum value in one step, you can use the following:\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+let bar = 42;\n+let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n+assert!(max_foo == 42);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_min_max\",\n+                       reason = \"easier and faster min/max than writing manual CAS loop\",\n+                       issue = \"48655\")]\n+                pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { $max_fn(self.v.get(), val, order) }\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Minimum with the current value.\n+\n+Finds the minimum of the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+assert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\n+assert_eq!(foo.load(Ordering::Relaxed), 23);\n+assert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\n+assert_eq!(foo.load(Ordering::Relaxed), 22);\n+```\n+\n+If you want to obtain the minimum value in one step, you can use the following:\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+let bar = 12;\n+let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n+assert_eq!(min_foo, 12);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_min_max\",\n+                       reason = \"easier and faster min/max than writing manual CAS loop\",\n+                       issue = \"48655\")]\n+                pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { $min_fn(self.v.get(), val, order) }\n+                }\n+            }\n+\n         }\n     }\n }\n@@ -1435,6 +1558,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i8\", \"../../../std/primitive.i8.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n #[cfg(target_has_atomic = \"8\")]\n@@ -1447,6 +1571,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u8\", \"../../../std/primitive.u8.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1459,6 +1584,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i16\", \"../../../std/primitive.i16.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1471,6 +1597,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u16\", \"../../../std/primitive.u16.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1483,6 +1610,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i32\", \"../../../std/primitive.i32.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1495,6 +1623,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u32\", \"../../../std/primitive.u32.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1507,6 +1636,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i64\", \"../../../std/primitive.i64.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1519,6 +1649,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u64\", \"../../../std/primitive.u64.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1531,6 +1662,7 @@ atomic_int!{\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"isize\", \"../../../std/primitive.isize.html\",\n     \"\",\n+    atomic_min, atomic_max,\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1543,6 +1675,7 @@ atomic_int!{\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"usize\", \"../../../std/primitive.usize.html\",\n     \"\",\n+    atomic_umin, atomic_umax,\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }\n \n@@ -1720,6 +1853,58 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n+/// returns the max value (signed comparison)\n+#[inline]\n+unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_max_acq(dst, val),\n+        Release => intrinsics::atomic_max_rel(dst, val),\n+        AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_max(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the min value (signed comparison)\n+#[inline]\n+unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_min_acq(dst, val),\n+        Release => intrinsics::atomic_min_rel(dst, val),\n+        AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_min(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the max value (signed comparison)\n+#[inline]\n+unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_umax_acq(dst, val),\n+        Release => intrinsics::atomic_umax_rel(dst, val),\n+        AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_umax(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the min value (signed comparison)\n+#[inline]\n+unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_umin_acq(dst, val),\n+        Release => intrinsics::atomic_umin_rel(dst, val),\n+        AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_umin(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n /// An atomic fence.\n ///\n /// Depending on the specified order, a fence prevents the compiler and CPU from"}]}