{"sha": "89e52e2ca9e5bf63c197c2dfa7d062f409fbeec7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZTUyZTJjYTllNWJmNjNjMTk3YzJkZmE3ZDA2MmY0MDlmYmVlYzc=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-29T17:28:41Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-03T19:42:15Z"}, "message": "Address review comments", "tree": {"sha": "a71d0c04dac3366eff403068a5a7d98920c03f70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a71d0c04dac3366eff403068a5a7d98920c03f70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89e52e2ca9e5bf63c197c2dfa7d062f409fbeec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89e52e2ca9e5bf63c197c2dfa7d062f409fbeec7", "html_url": "https://github.com/rust-lang/rust/commit/89e52e2ca9e5bf63c197c2dfa7d062f409fbeec7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89e52e2ca9e5bf63c197c2dfa7d062f409fbeec7/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f90dbd5e86a5ba68ec03cef5dd2c2418f587dbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f90dbd5e86a5ba68ec03cef5dd2c2418f587dbb", "html_url": "https://github.com/rust-lang/rust/commit/5f90dbd5e86a5ba68ec03cef5dd2c2418f587dbb"}], "stats": {"total": 239, "additions": 143, "deletions": 96}, "files": [{"sha": "d5ac2a14129ce93695d66b2169a188e785973f39", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 140, "deletions": 81, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/89e52e2ca9e5bf63c197c2dfa7d062f409fbeec7/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89e52e2ca9e5bf63c197c2dfa7d062f409fbeec7/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=89e52e2ca9e5bf63c197c2dfa7d062f409fbeec7", "patch": "@@ -153,18 +153,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         arms.iter()\n             .map(|arm| {\n                 let arm_has_guard = arm.guard.is_some();\n-                let arm_candidate = Candidate {\n-                    span: arm.pattern.span,\n-                    match_pairs: smallvec![MatchPair::new(*scrutinee, &arm.pattern),],\n-                    bindings: vec![],\n-                    ascriptions: vec![],\n-                    has_guard: arm_has_guard,\n-                    needs_otherwise_block: arm_has_guard,\n-                    otherwise_block: None,\n-                    pre_binding_block: None,\n-                    next_candidate_pre_binding_block: None,\n-                    subcandidates: vec![],\n-                };\n+                let arm_candidate = Candidate::new(*scrutinee, &arm.pattern, arm_has_guard);\n                 (arm, arm_candidate)\n             })\n             .collect()\n@@ -195,10 +184,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.match_candidates(scrutinee_span, block, &mut otherwise, candidates, &mut fake_borrows);\n \n         if let Some(otherwise_block) = otherwise {\n+            // See the doc comment on `match_candidates` for why we may have an\n+            // otherwise block. Match checking will ensure this is actually\n+            // unreachable.\n             let source_info = self.source_info(scrutinee_span);\n             self.cfg.terminate(otherwise_block, source_info, TerminatorKind::Unreachable);\n         }\n \n+        // Link each leaf candidate to the `pre_binding_block` of the next one.\n         let mut previous_candidate: Option<&mut Candidate<'_, '_>> = None;\n \n         for candidate in candidates {\n@@ -449,29 +442,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         initializer: &Place<'tcx>,\n         set_match_place: bool,\n     ) -> BlockAnd<()> {\n-        // create a dummy candidate\n-        let mut candidate = Candidate {\n-            span: irrefutable_pat.span,\n-            has_guard: false,\n-            needs_otherwise_block: false,\n-            match_pairs: smallvec![MatchPair::new(*initializer, &irrefutable_pat)],\n-            bindings: vec![],\n-            ascriptions: vec![],\n-\n-            // since we don't call `match_candidates`, next fields are unused\n-            otherwise_block: None,\n-            pre_binding_block: None,\n-            next_candidate_pre_binding_block: None,\n-            subcandidates: vec![],\n-        };\n+        let mut candidate = Candidate::new(*initializer, &irrefutable_pat, false);\n \n         let fake_borrow_temps =\n             self.lower_match_tree(block, irrefutable_pat.span, false, &mut [&mut candidate]);\n \n-        // for matches and function arguments, the place that is being matched\n+        // For matches and function arguments, the place that is being matched\n         // can be set when creating the variables. But the place for\n         // let PATTERN = ... might not even exist until we do the assignment.\n-        // so we set it here instead\n+        // so we set it here instead.\n         if set_match_place {\n             let mut candidate_ref = &candidate;\n             while let Some(next) = {\n@@ -487,6 +466,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         bug!(\"Let binding to non-user variable.\")\n                     }\n                 }\n+                // All of the subcandidates should bind the same locals, so we\n+                // only visit the first one.\n                 candidate_ref.subcandidates.get(0)\n             } {\n                 candidate_ref = next;\n@@ -666,10 +647,6 @@ struct Candidate<'pat, 'tcx> {\n     /// This `Candidate` has a guard.\n     has_guard: bool,\n \n-    /// This `Candidate` needs and otherwise block, either because it has a\n-    /// guard or it has subcandidates.\n-    needs_otherwise_block: bool,\n-\n     /// All of these must be satisfied...\n     match_pairs: SmallVec<[MatchPair<'pat, 'tcx>; 1]>,\n \n@@ -690,7 +667,21 @@ struct Candidate<'pat, 'tcx> {\n     next_candidate_pre_binding_block: Option<BasicBlock>,\n }\n \n-impl Candidate<'_, '_> {\n+impl<'tcx, 'pat> Candidate<'pat, 'tcx> {\n+    fn new(place: Place<'tcx>, pattern: &'pat Pat<'tcx>, has_guard: bool) -> Self {\n+        Candidate {\n+            span: pattern.span,\n+            has_guard,\n+            match_pairs: smallvec![MatchPair { place, pattern }],\n+            bindings: Vec::new(),\n+            ascriptions: Vec::new(),\n+            subcandidates: Vec::new(),\n+            otherwise_block: None,\n+            pre_binding_block: None,\n+            next_candidate_pre_binding_block: None,\n+        }\n+    }\n+\n     /// Visit the leaf candidates (those with no subcandidates) contained in\n     /// this candidate.\n     fn visit_leaves<'a>(&'a mut self, mut visit_leaf: impl FnMut(&'a mut Self)) {\n@@ -839,6 +830,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// If `fake_borrows` is Some, then places which need fake borrows\n     /// will be added to it.\n+    ///\n+    /// For an example of a case where we set `otherwise_block`, even for an\n+    /// exhaustive match consider:\n+    ///\n+    /// match x {\n+    ///     (true, true) => (),\n+    ///     (_, false) => (),\n+    ///     (false, true) => (),\n+    /// }\n+    ///\n+    /// For this match we check if `x.0` matches `true` (for the first\n+    /// arm) if that's false we check `x.1`, if it's `true` we check if\n+    /// `x.0` matches `false` (for the third arm). In the (impossible at\n+    /// runtime) case when `x.0` is now `true` we branch to\n+    /// `otherwise_block`.\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n@@ -1009,7 +1015,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let fully_matched_with_guard = matched_candidates\n             .iter()\n-            .position(|c| !c.needs_otherwise_block)\n+            .position(|c| !c.has_guard)\n             .unwrap_or(matched_candidates.len() - 1);\n \n         let (reachable_candidates, unreachable_candidates) =\n@@ -1021,7 +1027,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             assert!(candidate.otherwise_block.is_none());\n             assert!(candidate.pre_binding_block.is_none());\n             candidate.pre_binding_block = Some(next_prebinding);\n-            if candidate.needs_otherwise_block {\n+            if candidate.has_guard {\n+                // Create the otherwise block for this candidate, which is the\n+                // pre-binding block for the next candidate.\n                 next_prebinding = self.cfg.start_new_block();\n                 candidate.otherwise_block = Some(next_prebinding);\n             }\n@@ -1039,6 +1047,53 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         reachable_candidates.last_mut().unwrap().otherwise_block\n     }\n \n+    /// Tests a candidate where there are only or-patterns left to test, or\n+    /// forwards to [Builder::test_candidates].\n+    ///\n+    /// Given a pattern `(P | Q, R | S)` we (in principle) generate a CFG like\n+    /// so\n+    ///\n+    /// ```text\n+    /// [ start ]\n+    ///      |\n+    /// [ match P, Q ]\n+    ///      |\n+    ///      +----------------------------------------+------------------------------------+\n+    ///      |                                        |                                    |\n+    /// [ P matches ]                           [ Q matches ]                        [ otherwise ]\n+    ///      |                                        |                                    |\n+    /// [ match R, S ]                          [ match R, S ]                             |\n+    ///      |                                        |                                    |\n+    ///      +--------------+------------+            +--------------+------------+        |\n+    ///      |              |            |            |              |            |        |\n+    /// [ R matches ] [ S matches ] [otherwise ] [ R matches ] [ S matches ] [otherwise ]  |\n+    ///      |              |            |            |              |            |        |\n+    ///      +--------------+------------|------------+--------------+            |        |\n+    ///      |                           |                                        |        |\n+    ///      |                           +----------------------------------------+--------+\n+    ///      |                           |\n+    /// [ Success ]                 [ Failure ]\n+    /// ```\n+    ///\n+    /// In practice there are some complications:\n+    ///\n+    /// * If there's a guard, then the otherwise branch of the first match on\n+    ///   `R | S` goes to a test for whether `Q` matches.\n+    /// * If neither `P` or `Q` has any bindings or type ascriptions and there\n+    ///   isn't a match guard, then we create a smaller CFG like:\n+    ///\n+    /// ```text\n+    ///     ...\n+    ///      +---------------+------------+\n+    ///      |               |            |\n+    /// [ P matches ] [ Q matches ] [ otherwise ]\n+    ///      |               |            |\n+    ///      +---------------+            |\n+    ///      |                           ...\n+    /// [ match R, S ]\n+    ///      |\n+    ///     ...\n+    /// ```\n     fn test_candidates_with_or(\n         &mut self,\n         span: Span,\n@@ -1049,42 +1104,53 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         let (first_candidate, remaining_candidates) = candidates.split_first_mut().unwrap();\n \n-        if let PatKind::Or { .. } = *first_candidate.match_pairs[0].pattern.kind {\n-            let match_pairs = mem::take(&mut first_candidate.match_pairs);\n-            first_candidate.needs_otherwise_block = true;\n-            first_candidate.pre_binding_block = Some(block);\n+        match *first_candidate.match_pairs[0].pattern.kind {\n+            PatKind::Or { .. } => (),\n+            _ => {\n+                self.test_candidates(span, candidates, block, otherwise_block, fake_borrows);\n+                return;\n+            }\n+        }\n \n-            // We sort or-patterns to the end in `simplify_candidate`, so all\n-            // the remaining match pairs are or-patterns.\n-            for match_pair in match_pairs {\n-                if let PatKind::Or { ref pats } = *match_pair.pattern.kind {\n-                    let or_span = match_pair.pattern.span;\n-                    let place = &match_pair.place;\n+        let match_pairs = mem::take(&mut first_candidate.match_pairs);\n+        first_candidate.pre_binding_block = Some(block);\n \n-                    first_candidate.visit_leaves(|leaf_candidate| {\n-                        self.test_or_pattern(leaf_candidate, pats, or_span, place, fake_borrows);\n-                    });\n-                } else {\n-                    bug!(\"Or patterns should have been sorted to the end\");\n-                }\n+        let mut otherwise = None;\n+        for match_pair in match_pairs {\n+            if let PatKind::Or { ref pats } = *match_pair.pattern.kind {\n+                let or_span = match_pair.pattern.span;\n+                let place = &match_pair.place;\n+\n+                first_candidate.visit_leaves(|leaf_candidate| {\n+                    self.test_or_pattern(\n+                        leaf_candidate,\n+                        &mut otherwise,\n+                        pats,\n+                        or_span,\n+                        place,\n+                        fake_borrows,\n+                    );\n+                });\n+            } else {\n+                bug!(\"Or-patterns should have been sorted to the end\");\n             }\n-            let remainder_start =\n-                first_candidate.otherwise_block.unwrap_or_else(|| self.cfg.start_new_block());\n-            self.match_candidates(\n-                span,\n-                remainder_start,\n-                otherwise_block,\n-                remaining_candidates,\n-                fake_borrows,\n-            )\n-        } else {\n-            self.test_candidates(span, candidates, block, otherwise_block, fake_borrows)\n         }\n+\n+        let remainder_start = otherwise.unwrap_or_else(|| self.cfg.start_new_block());\n+\n+        self.match_candidates(\n+            span,\n+            remainder_start,\n+            otherwise_block,\n+            remaining_candidates,\n+            fake_borrows,\n+        )\n     }\n \n     fn test_or_pattern<'pat>(\n         &mut self,\n         candidate: &mut Candidate<'pat, 'tcx>,\n+        otherwise: &mut Option<BasicBlock>,\n         pats: &'pat [Pat<'tcx>],\n         or_span: Span,\n         place: &Place<'tcx>,\n@@ -1093,27 +1159,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"test_or_pattern:\\ncandidate={:#?}\\npats={:#?}\", candidate, pats);\n         let mut or_candidates: Vec<_> = pats\n             .iter()\n-            .map(|pat| {\n-                let new_match_pair = smallvec![MatchPair { pattern: pat, place: place.clone() }];\n-                Candidate {\n-                    span: pat.span,\n-                    has_guard: candidate.has_guard,\n-                    needs_otherwise_block: candidate.needs_otherwise_block,\n-                    match_pairs: new_match_pair,\n-                    bindings: Vec::new(),\n-                    ascriptions: Vec::new(),\n-                    otherwise_block: None,\n-                    pre_binding_block: None,\n-                    next_candidate_pre_binding_block: None,\n-                    subcandidates: Vec::new(),\n-                }\n-            })\n+            .map(|pat| Candidate::new(place.clone(), pat, candidate.has_guard))\n             .collect();\n         let mut or_candidate_refs: Vec<_> = or_candidates.iter_mut().collect();\n+        let otherwise = if candidate.otherwise_block.is_some() {\n+            &mut candidate.otherwise_block\n+        } else {\n+            otherwise\n+        };\n         self.match_candidates(\n             or_span,\n             candidate.pre_binding_block.unwrap(),\n-            &mut candidate.otherwise_block,\n+            otherwise,\n             &mut or_candidate_refs,\n             fake_borrows,\n         );\n@@ -1128,10 +1185,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'_, 'tcx>,\n         source_info: SourceInfo,\n     ) {\n-        if candidate.subcandidates.is_empty() {\n+        if candidate.subcandidates.is_empty() || candidate.has_guard {\n+            // FIXME(or_patterns; matthewjasper) Don't give up if we have a guard.\n             return;\n         }\n-        let mut can_merge = !candidate.has_guard;\n+\n+        let mut can_merge = true;\n \n         // Not `Iterator::all` because we don't want to short-circuit.\n         for subcandidate in &mut candidate.subcandidates {"}, {"sha": "422a75a4f37a163a25b59ba199acca8ee8288b38", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/89e52e2ca9e5bf63c197c2dfa7d062f409fbeec7/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89e52e2ca9e5bf63c197c2dfa7d062f409fbeec7/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=89e52e2ca9e5bf63c197c2dfa7d062f409fbeec7", "patch": "@@ -22,7 +22,6 @@ use rustc::ty::layout::{Integer, IntegerExt, Size};\n use rustc_attr::{SignedInt, UnsignedInt};\n use rustc_hir::RangeEnd;\n \n-use smallvec::smallvec;\n use std::mem;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n@@ -49,7 +48,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if let [MatchPair { pattern: Pat { kind: box PatKind::Or { pats }, .. }, ref place }] =\n                 *match_pairs\n             {\n-                candidate.subcandidates = self.create_or_subcanidates(candidate, place, pats);\n+                candidate.subcandidates = self.create_or_subcandidates(candidate, place, pats);\n                 return true;\n             }\n \n@@ -76,26 +75,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    fn create_or_subcanidates<'pat>(\n+    fn create_or_subcandidates<'pat>(\n         &mut self,\n         candidate: &Candidate<'pat, 'tcx>,\n         place: &Place<'tcx>,\n         pats: &'pat [Pat<'tcx>],\n     ) -> Vec<Candidate<'pat, 'tcx>> {\n         pats.iter()\n             .map(|pat| {\n-                let mut candidate = Candidate {\n-                    span: pat.span,\n-                    has_guard: candidate.has_guard,\n-                    needs_otherwise_block: candidate.needs_otherwise_block,\n-                    match_pairs: smallvec![MatchPair { place: place.clone(), pattern: pat }],\n-                    bindings: vec![],\n-                    ascriptions: vec![],\n-                    subcandidates: vec![],\n-                    otherwise_block: None,\n-                    pre_binding_block: None,\n-                    next_candidate_pre_binding_block: None,\n-                };\n+                let mut candidate = Candidate::new(place.clone(), pat, candidate.has_guard);\n                 self.simplify_candidate(&mut candidate);\n                 candidate\n             })"}]}