{"sha": "7e79b9bbf5e16d3675fc3e14864779ad32f33059", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNzliOWJiZjVlMTZkMzY3NWZjM2UxNDg2NDc3OWFkMzJmMzMwNTk=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-11-20T17:27:53Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-11-20T20:18:48Z"}, "message": "Add tests for repr(C)-non-clike-enum layout", "tree": {"sha": "aab93376f1e4c4f35b6cf652300ac98726408316", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aab93376f1e4c4f35b6cf652300ac98726408316"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e79b9bbf5e16d3675fc3e14864779ad32f33059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e79b9bbf5e16d3675fc3e14864779ad32f33059", "html_url": "https://github.com/rust-lang/rust/commit/7e79b9bbf5e16d3675fc3e14864779ad32f33059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e79b9bbf5e16d3675fc3e14864779ad32f33059/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d7a6fee79a7a42ac69b185806733dbbd1fc664e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d7a6fee79a7a42ac69b185806733dbbd1fc664e", "html_url": "https://github.com/rust-lang/rust/commit/3d7a6fee79a7a42ac69b185806733dbbd1fc664e"}], "stats": {"total": 354, "additions": 354, "deletions": 0}, "files": [{"sha": "86453fdf6fae6903efc259472fba31aac627f83e", "filename": "src/test/run-pass/enum-non-c-like-repr-c-and-int.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/7e79b9bbf5e16d3675fc3e14864779ad32f33059/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c-and-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e79b9bbf5e16d3675fc3e14864779ad32f33059/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c-and-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c-and-int.rs?ref=7e79b9bbf5e16d3675fc3e14864779ad32f33059", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test deserializes an enum in-place by transmuting to a union that\n+// should have the same layout, and manipulating the tag and payloads\n+// independently. This verifies that `repr(some_int)` has a stable representation,\n+// and that we don't miscompile these kinds of manipulations.\n+\n+use std::time::Duration;\n+use std::mem;\n+\n+#[repr(C, u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+enum MyEnum {\n+    A(u32),                 // Single primitive value\n+    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n+    C,                      // Empty\n+    D(Option<u32>),         // Contains an enum\n+    E(Duration),            // Contains a struct\n+}\n+\n+#[repr(C)]\n+struct MyEnumRepr {\n+    tag: MyEnumTag,\n+    payload: MyEnumPayload,\n+}\n+\n+#[repr(C)]\n+#[allow(non_snake_case)]\n+union MyEnumPayload {\n+    A: MyEnumVariantA,\n+    B: MyEnumVariantB,\n+    D: MyEnumVariantD,\n+    E: MyEnumVariantE,\n+}\n+\n+#[repr(u8)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(u32);\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16 }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(Option<u32>);\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(Duration);\n+\n+fn main() {\n+    let result: Vec<Result<MyEnum, ()>> = vec![\n+        Ok(MyEnum::A(17)),\n+        Ok(MyEnum::B { x: 206, y: 1145 }),\n+        Ok(MyEnum::C),\n+        Err(()),\n+        Ok(MyEnum::D(Some(407))),\n+        Ok(MyEnum::D(None)),\n+        Ok(MyEnum::E(Duration::from_secs(100))),\n+        Err(()),\n+    ];\n+\n+    // Binary serialized version of the above (little-endian)\n+    let input: Vec<u8> = vec![\n+        0,  17, 0, 0, 0,\n+        1,  206,  121, 4,\n+        2,\n+        8,  /* invalid tag value */\n+        3,  0,  151, 1, 0, 0,\n+        3,  1,\n+        4,  100, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,\n+        0,  /* incomplete value */\n+    ];\n+\n+    let mut output = vec![];\n+    let mut buf = &input[..];\n+\n+    unsafe {\n+        // This should be safe, because we don't match on it unless it's fully formed,\n+        // and it doesn't have a destructor.\n+        let mut dest: MyEnum = mem::uninitialized();\n+        while buf.len() > 0 {\n+            match parse_my_enum(&mut dest, &mut buf) {\n+                Ok(()) => output.push(Ok(dest)),\n+                Err(()) => output.push(Err(())),\n+            }\n+        }\n+    }\n+\n+    assert_eq!(output, result);\n+}\n+\n+fn parse_my_enum<'a>(dest: &'a mut MyEnum, buf: &mut &[u8]) -> Result<(), ()> {\n+    unsafe {\n+        // Should be correct to do this transmute.\n+        let dest: &'a mut MyEnumRepr = mem::transmute(dest);\n+        let tag = read_u8(buf)?;\n+\n+        dest.tag = match tag {\n+            0 => MyEnumTag::A,\n+            1 => MyEnumTag::B,\n+            2 => MyEnumTag::C,\n+            3 => MyEnumTag::D,\n+            4 => MyEnumTag::E,\n+            _ => return Err(()),\n+        };\n+\n+        match dest.tag {\n+            MyEnumTag::A => {\n+                dest.payload.A.0 = read_u32_le(buf)?;\n+            }\n+            MyEnumTag::B => {\n+                dest.payload.B.x = read_u8(buf)?;\n+                dest.payload.B.y = read_u16_le(buf)? as i16;\n+            }\n+            MyEnumTag::C => {\n+                /* do nothing */\n+            }\n+            MyEnumTag::D => {\n+                let is_some = read_u8(buf)? == 0;\n+                if is_some {\n+                    dest.payload.D.0 = Some(read_u32_le(buf)?);\n+                } else {\n+                    dest.payload.D.0 = None;\n+                }\n+            }\n+            MyEnumTag::E => {\n+                let secs = read_u64_le(buf)?;\n+                let nanos = read_u32_le(buf)?;\n+                dest.payload.E.0 = Duration::new(secs, nanos);\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+\n+\n+// reader helpers\n+\n+fn read_u64_le(buf: &mut &[u8]) -> Result<u64, ()> {\n+    if buf.len() < 8 { return Err(()) }\n+    let val = (buf[0] as u64) << 0\n+            | (buf[1] as u64) << 8\n+            | (buf[2] as u64) << 16\n+            | (buf[3] as u64) << 24\n+            | (buf[4] as u64) << 32\n+            | (buf[5] as u64) << 40\n+            | (buf[6] as u64) << 48\n+            | (buf[7] as u64) << 56;\n+    *buf = &buf[8..];\n+    Ok(val)\n+}\n+\n+fn read_u32_le(buf: &mut &[u8]) -> Result<u32, ()> {\n+    if buf.len() < 4 { return Err(()) }\n+    let val = (buf[0] as u32) << 0\n+            | (buf[1] as u32) << 8\n+            | (buf[2] as u32) << 16\n+            | (buf[3] as u32) << 24;\n+    *buf = &buf[4..];\n+    Ok(val)\n+}\n+\n+fn read_u16_le(buf: &mut &[u8]) -> Result<u16, ()> {\n+    if buf.len() < 2 { return Err(()) }\n+    let val = (buf[0] as u16) << 0\n+            | (buf[1] as u16) << 8;\n+    *buf = &buf[2..];\n+    Ok(val)\n+}\n+\n+fn read_u8(buf: &mut &[u8]) -> Result<u8, ()> {\n+    if buf.len() < 1 { return Err(()) }\n+    let val = buf[0];\n+    *buf = &buf[1..];\n+    Ok(val)\n+}"}, {"sha": "b4e0fe8d4572a4271430b5804ef5dfbb5487e948", "filename": "src/test/run-pass/enum-non-c-like-repr-c.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/7e79b9bbf5e16d3675fc3e14864779ad32f33059/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e79b9bbf5e16d3675fc3e14864779ad32f33059/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c.rs?ref=7e79b9bbf5e16d3675fc3e14864779ad32f33059", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test deserializes an enum in-place by transmuting to a union that\n+// should have the same layout, and manipulating the tag and payloads\n+// independently. This verifies that `repr(some_int)` has a stable representation,\n+// and that we don't miscompile these kinds of manipulations.\n+\n+use std::time::Duration;\n+use std::mem;\n+\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+enum MyEnum {\n+    A(u32),                 // Single primitive value\n+    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n+    C,                      // Empty\n+    D(Option<u32>),         // Contains an enum\n+    E(Duration),            // Contains a struct\n+}\n+\n+#[repr(C)]\n+struct MyEnumRepr {\n+    tag: MyEnumTag,\n+    payload: MyEnumPayload,\n+}\n+\n+#[repr(C)]\n+#[allow(non_snake_case)]\n+union MyEnumPayload {\n+    A: MyEnumVariantA,\n+    B: MyEnumVariantB,\n+    D: MyEnumVariantD,\n+    E: MyEnumVariantE,\n+}\n+\n+#[repr(C)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(u32);\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16 }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(Option<u32>);\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(Duration);\n+\n+fn main() {\n+    let result: Vec<Result<MyEnum, ()>> = vec![\n+        Ok(MyEnum::A(17)),\n+        Ok(MyEnum::B { x: 206, y: 1145 }),\n+        Ok(MyEnum::C),\n+        Err(()),\n+        Ok(MyEnum::D(Some(407))),\n+        Ok(MyEnum::D(None)),\n+        Ok(MyEnum::E(Duration::from_secs(100))),\n+        Err(()),\n+    ];\n+\n+    // Binary serialized version of the above (little-endian)\n+    let input: Vec<u8> = vec![\n+        0,  17, 0, 0, 0,\n+        1,  206,  121, 4,\n+        2,\n+        8,  /* invalid tag value */\n+        3,  0,  151, 1, 0, 0,\n+        3,  1,\n+        4,  100, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,\n+        0,  /* incomplete value */\n+    ];\n+\n+    let mut output = vec![];\n+    let mut buf = &input[..];\n+\n+    unsafe {\n+        // This should be safe, because we don't match on it unless it's fully formed,\n+        // and it doesn't have a destructor.\n+        let mut dest: MyEnum = mem::uninitialized();\n+        while buf.len() > 0 {\n+            match parse_my_enum(&mut dest, &mut buf) {\n+                Ok(()) => output.push(Ok(dest)),\n+                Err(()) => output.push(Err(())),\n+            }\n+        }\n+    }\n+\n+    assert_eq!(output, result);\n+}\n+\n+fn parse_my_enum<'a>(dest: &'a mut MyEnum, buf: &mut &[u8]) -> Result<(), ()> {\n+    unsafe {\n+        // Should be correct to do this transmute.\n+        let dest: &'a mut MyEnumRepr = mem::transmute(dest);\n+        let tag = read_u8(buf)?;\n+\n+        dest.tag = match tag {\n+            0 => MyEnumTag::A,\n+            1 => MyEnumTag::B,\n+            2 => MyEnumTag::C,\n+            3 => MyEnumTag::D,\n+            4 => MyEnumTag::E,\n+            _ => return Err(()),\n+        };\n+\n+        match dest.tag {\n+            MyEnumTag::A => {\n+                dest.payload.A.0 = read_u32_le(buf)?;\n+            }\n+            MyEnumTag::B => {\n+                dest.payload.B.x = read_u8(buf)?;\n+                dest.payload.B.y = read_u16_le(buf)? as i16;\n+            }\n+            MyEnumTag::C => {\n+                /* do nothing */\n+            }\n+            MyEnumTag::D => {\n+                let is_some = read_u8(buf)? == 0;\n+                if is_some {\n+                    dest.payload.D.0 = Some(read_u32_le(buf)?);\n+                } else {\n+                    dest.payload.D.0 = None;\n+                }\n+            }\n+            MyEnumTag::E => {\n+                let secs = read_u64_le(buf)?;\n+                let nanos = read_u32_le(buf)?;\n+                dest.payload.E.0 = Duration::new(secs, nanos);\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+\n+\n+// reader helpers\n+\n+fn read_u64_le(buf: &mut &[u8]) -> Result<u64, ()> {\n+    if buf.len() < 8 { return Err(()) }\n+    let val = (buf[0] as u64) << 0\n+            | (buf[1] as u64) << 8\n+            | (buf[2] as u64) << 16\n+            | (buf[3] as u64) << 24\n+            | (buf[4] as u64) << 32\n+            | (buf[5] as u64) << 40\n+            | (buf[6] as u64) << 48\n+            | (buf[7] as u64) << 56;\n+    *buf = &buf[8..];\n+    Ok(val)\n+}\n+\n+fn read_u32_le(buf: &mut &[u8]) -> Result<u32, ()> {\n+    if buf.len() < 4 { return Err(()) }\n+    let val = (buf[0] as u32) << 0\n+            | (buf[1] as u32) << 8\n+            | (buf[2] as u32) << 16\n+            | (buf[3] as u32) << 24;\n+    *buf = &buf[4..];\n+    Ok(val)\n+}\n+\n+fn read_u16_le(buf: &mut &[u8]) -> Result<u16, ()> {\n+    if buf.len() < 2 { return Err(()) }\n+    let val = (buf[0] as u16) << 0\n+            | (buf[1] as u16) << 8;\n+    *buf = &buf[2..];\n+    Ok(val)\n+}\n+\n+fn read_u8(buf: &mut &[u8]) -> Result<u8, ()> {\n+    if buf.len() < 1 { return Err(()) }\n+    let val = buf[0];\n+    *buf = &buf[1..];\n+    Ok(val)\n+}"}]}