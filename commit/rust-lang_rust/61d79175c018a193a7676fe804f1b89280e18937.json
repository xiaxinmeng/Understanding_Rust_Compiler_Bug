{"sha": "61d79175c018a193a7676fe804f1b89280e18937", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZDc5MTc1YzAxOGExOTNhNzY3NmZlODA0ZjFiODkyODBlMTg5Mzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-06T19:17:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-06T19:17:10Z"}, "message": "auto merge of #14318 : zwarich/rust/check-loans-refactor, r=nikomatsakis\n\nI tried to split up the less mechanical changes into separate commits so they are easier to review. One thing I'm not quite sure of is whether `MoveReason` should just be replaced with `move_data::MoveKind`.", "tree": {"sha": "b5e5a56cd76643c7adab6e0990a79c5afc1533d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5e5a56cd76643c7adab6e0990a79c5afc1533d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61d79175c018a193a7676fe804f1b89280e18937", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61d79175c018a193a7676fe804f1b89280e18937", "html_url": "https://github.com/rust-lang/rust/commit/61d79175c018a193a7676fe804f1b89280e18937", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61d79175c018a193a7676fe804f1b89280e18937/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3744940706f58eea8185cab2987738a79d11098a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3744940706f58eea8185cab2987738a79d11098a", "html_url": "https://github.com/rust-lang/rust/commit/3744940706f58eea8185cab2987738a79d11098a"}, {"sha": "f1542a6a7da088f99bfe2963d29e6ea4b451b432", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1542a6a7da088f99bfe2963d29e6ea4b451b432", "html_url": "https://github.com/rust-lang/rust/commit/f1542a6a7da088f99bfe2963d29e6ea4b451b432"}], "stats": {"total": 997, "additions": 723, "deletions": 274}, "files": [{"sha": "fed1fb9c60992e687dc2228b3fe243c33df4d49f", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 248, "deletions": 233, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -20,15 +20,10 @@\n \n use middle::borrowck::*;\n use euv = middle::expr_use_visitor;\n-use middle::freevars;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use middle::typeck::MethodCall;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::codemap::Span;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n@@ -40,35 +35,104 @@ struct CheckLoanCtxt<'a> {\n     all_loans: &'a [Loan],\n }\n \n-impl<'a> Visitor<()> for CheckLoanCtxt<'a> {\n+impl<'a> euv::Delegate for CheckLoanCtxt<'a> {\n+    fn consume(&mut self,\n+               consume_id: ast::NodeId,\n+               consume_span: Span,\n+               cmt: mc::cmt,\n+               mode: euv::ConsumeMode) {\n+        debug!(\"consume(consume_id={}, cmt={}, mode={})\",\n+               consume_id, cmt.repr(self.tcx()), mode);\n \n-    fn visit_expr(&mut self, ex: &ast::Expr, _: ()) {\n-        check_loans_in_expr(self, ex);\n+        self.consume_common(consume_id, consume_span, cmt, mode);\n     }\n-    fn visit_local(&mut self, l: &ast::Local, _: ()) {\n-        check_loans_in_local(self, l);\n-    }\n-    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n-        check_loans_in_block(self, b);\n+\n+    fn consume_pat(&mut self,\n+                   consume_pat: &ast::Pat,\n+                   cmt: mc::cmt,\n+                   mode: euv::ConsumeMode) {\n+        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={})\",\n+               consume_pat.repr(self.tcx()),\n+               cmt.repr(self.tcx()),\n+               mode);\n+\n+        self.consume_common(consume_pat.id, consume_pat.span, cmt, mode);\n     }\n-    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n-        check_loans_in_pat(self, p);\n+\n+    fn borrow(&mut self,\n+              borrow_id: ast::NodeId,\n+              borrow_span: Span,\n+              cmt: mc::cmt,\n+              loan_region: ty::Region,\n+              bk: ty::BorrowKind,\n+              loan_cause: euv::LoanCause)\n+    {\n+        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={}, \\\n+               bk={}, loan_cause={:?})\",\n+               borrow_id, cmt.repr(self.tcx()), loan_region,\n+               bk, loan_cause);\n+\n+        match opt_loan_path(&cmt) {\n+            Some(lp) => {\n+                let moved_value_use_kind = match loan_cause {\n+                    euv::ClosureCapture(_) => MovedInCapture,\n+                    _ => MovedInUse,\n+                };\n+                self.check_if_path_is_moved(borrow_id, borrow_span, moved_value_use_kind, &lp);\n+            }\n+            None => { }\n+        }\n+\n+        self.check_for_conflicting_loans(borrow_id);\n     }\n-    fn visit_fn(&mut self, _fk: &visit::FnKind, _fd: &ast::FnDecl,\n-                _b: &ast::Block, _s: Span, _n: ast::NodeId, _: ()) {\n-        // Don't process nested items or closures here,\n-        // the outer loop will take care of it.\n-        return;\n+\n+    fn mutate(&mut self,\n+              assignment_id: ast::NodeId,\n+              assignment_span: Span,\n+              assignee_cmt: mc::cmt,\n+              mode: euv::MutateMode)\n+    {\n+        debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n+               assignment_id, assignee_cmt.repr(self.tcx()));\n+\n+        match opt_loan_path(&assignee_cmt) {\n+            Some(lp) => {\n+                match mode {\n+                    euv::Init | euv::JustWrite => {\n+                        // In a case like `path = 1`, then path does not\n+                        // have to be *FULLY* initialized, but we still\n+                        // must be careful lest it contains derefs of\n+                        // pointers.\n+                        self.check_if_assigned_path_is_moved(assignee_cmt.id,\n+                                                             assignment_span,\n+                                                             MovedInUse,\n+                                                             &lp);\n+                    }\n+                    euv::WriteAndRead => {\n+                        // In a case like `path += 1`, then path must be\n+                        // fully initialized, since we will read it before\n+                        // we write it.\n+                        self.check_if_path_is_moved(assignee_cmt.id,\n+                                                    assignment_span,\n+                                                    MovedInUse,\n+                                                    &lp);\n+                    }\n+                }\n+            }\n+            None => { }\n+        }\n+\n+        self.check_assignment(assignment_id, assignment_span, assignee_cmt, mode);\n     }\n \n-    // FIXME(#10894) should continue recursing\n-    fn visit_ty(&mut self, _t: &ast::Ty, _: ()) {}\n+    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n }\n \n pub fn check_loans(bccx: &BorrowckCtxt,\n                    dfcx_loans: &LoanDataFlow,\n                    move_data: move_data::FlowedMoveData,\n                    all_loans: &[Loan],\n+                   decl: &ast::FnDecl,\n                    body: &ast::Block) {\n     debug!(\"check_loans(body id={:?})\", body.id);\n \n@@ -79,7 +143,10 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n         all_loans: all_loans,\n     };\n \n-    clcx.visit_block(body, ());\n+    {\n+        let mut euv = euv::ExprUseVisitor::new(&mut clcx, bccx.tcx);\n+        euv.walk_fn(decl, body);\n+    }\n }\n \n #[deriving(PartialEq)]\n@@ -355,18 +422,130 @@ impl<'a> CheckLoanCtxt<'a> {\n         true\n     }\n \n-    pub fn is_local_variable(&self, cmt: mc::cmt) -> bool {\n+    pub fn is_local_variable_or_arg(&self, cmt: mc::cmt) -> bool {\n         match cmt.cat {\n-          mc::cat_local(_) => true,\n+          mc::cat_local(_) | mc::cat_arg(_) => true,\n           _ => false\n         }\n     }\n \n-    pub fn check_if_path_is_moved(&self,\n-                                  id: ast::NodeId,\n-                                  span: Span,\n-                                  use_kind: MovedValueUseKind,\n-                                  lp: &Rc<LoanPath>) {\n+    fn consume_common(&self,\n+                      id: ast::NodeId,\n+                      span: Span,\n+                      cmt: mc::cmt,\n+                      mode: euv::ConsumeMode) {\n+        match opt_loan_path(&cmt) {\n+            Some(lp) => {\n+                let moved_value_use_kind = match mode {\n+                    euv::Copy => {\n+                        // FIXME(#12624) -- If we are copying the value,\n+                        // we don't care if it's borrowed.\n+                        MovedInUse\n+                    }\n+                    euv::Move(_) => {\n+                        match self.move_data.kind_of_move_of_path(id, &lp) {\n+                            None => {\n+                                // Sometimes moves don't have a move kind;\n+                                // this either means that the original move\n+                                // was from something illegal to move,\n+                                // or was moved from referent of an unsafe\n+                                // pointer or something like that.\n+                                MovedInUse\n+                            }\n+                            Some(move_kind) => {\n+                                self.check_for_move_of_borrowed_path(id, span,\n+                                                                     &lp, move_kind);\n+                                if move_kind == move_data::Captured {\n+                                    MovedInCapture\n+                                } else {\n+                                    MovedInUse\n+                                }\n+                            }\n+                        }\n+                    }\n+                };\n+\n+                self.check_if_path_is_moved(id, span, moved_value_use_kind, &lp);\n+            }\n+            None => { }\n+        }\n+    }\n+\n+    fn check_for_move_of_borrowed_path(&self,\n+                                       id: ast::NodeId,\n+                                       span: Span,\n+                                       move_path: &Rc<LoanPath>,\n+                                       move_kind: move_data::MoveKind) {\n+        match self.analyze_move_out_from(id, &**move_path) {\n+            MoveOk => { }\n+            MoveWhileBorrowed(loan_path, loan_span) => {\n+                let err_message = match move_kind {\n+                    move_data::Captured =>\n+                        format!(\"cannot move `{}` into closure because it is borrowed\",\n+                                self.bccx.loan_path_to_str(&**move_path).as_slice()),\n+                    move_data::Declared |\n+                    move_data::MoveExpr |\n+                    move_data::MovePat =>\n+                        format!(\"cannot move out of `{}` because it is borrowed\",\n+                                self.bccx.loan_path_to_str(&**move_path).as_slice())\n+                };\n+\n+                self.bccx.span_err(span, err_message.as_slice());\n+                self.bccx.span_note(\n+                    loan_span,\n+                    format!(\"borrow of `{}` occurs here\",\n+                            self.bccx.loan_path_to_str(&*loan_path).as_slice())\n+                    .as_slice());\n+            }\n+        }\n+    }\n+\n+    fn check_if_assigned_path_is_moved(&self,\n+                                       id: ast::NodeId,\n+                                       span: Span,\n+                                       use_kind: MovedValueUseKind,\n+                                       lp: &Rc<LoanPath>)\n+    {\n+        /*!\n+         * Reports an error if assigning to `lp` will use a\n+         * moved/uninitialized value. Mainly this is concerned with\n+         * detecting derefs of uninitialized pointers.\n+         *\n+         * For example:\n+         *\n+         *     let a: int;\n+         *     a = 10; // ok, even though a is uninitialized\n+         *\n+         *     struct Point { x: uint, y: uint }\n+         *     let p: Point;\n+         *     p.x = 22; // ok, even though `p` is uninitialized\n+         *\n+         *     let p: ~Point;\n+         *     (*p).x = 22; // not ok, p is uninitialized, can't deref\n+         */\n+\n+        match **lp {\n+            LpVar(_) => {\n+                // assigning to `x` does not require that `x` is initialized\n+            }\n+            LpExtend(ref lp_base, _, LpInterior(_)) => {\n+                // assigning to `P.f` is ok if assigning to `P` is ok\n+                self.check_if_assigned_path_is_moved(id, span,\n+                                                     use_kind, lp_base);\n+            }\n+            LpExtend(ref lp_base, _, LpDeref(_)) => {\n+                // assigning to `(*P)` requires that `P` be initialized\n+                self.check_if_path_is_moved(id, span,\n+                                            use_kind, lp_base);\n+            }\n+        }\n+    }\n+\n+    fn check_if_path_is_moved(&self,\n+                              id: ast::NodeId,\n+                              span: Span,\n+                              use_kind: MovedValueUseKind,\n+                              lp: &Rc<LoanPath>) {\n         /*!\n          * Reports an error if `expr` (which should be a path)\n          * is using a moved/uninitialized value\n@@ -385,37 +564,36 @@ impl<'a> CheckLoanCtxt<'a> {\n         });\n     }\n \n-    pub fn check_assignment(&self, expr: &ast::Expr) {\n-        // We don't use cat_expr() here because we don't want to treat\n-        // auto-ref'd parameters in overloaded operators as rvalues.\n-        let cmt = match self.bccx.tcx.adjustments.borrow().find(&expr.id) {\n-            None => self.bccx.cat_expr_unadjusted(expr),\n-            Some(adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n-        };\n-\n-        debug!(\"check_assignment(cmt={})\", cmt.repr(self.tcx()));\n+    fn check_assignment(&self,\n+                        assignment_id: ast::NodeId,\n+                        assignment_span: Span,\n+                        assignee_cmt: mc::cmt,\n+                        mode: euv::MutateMode) {\n+        debug!(\"check_assignment(assignee_cmt={})\", assignee_cmt.repr(self.tcx()));\n \n         // Mutable values can be assigned, as long as they obey loans\n         // and aliasing restrictions:\n-        if cmt.mutbl.is_mutable() {\n-            if check_for_aliasable_mutable_writes(self, expr, cmt.clone()) {\n-                if check_for_assignment_to_restricted_or_frozen_location(\n-                    self, expr, cmt.clone()) {\n+        if assignee_cmt.mutbl.is_mutable() {\n+            if check_for_aliasable_mutable_writes(self, assignment_span, assignee_cmt.clone()) {\n+                if mode != euv::Init &&\n+                    check_for_assignment_to_restricted_or_frozen_location(\n+                        self, assignment_id, assignment_span, assignee_cmt.clone())\n+                {\n                     // Safe, but record for lint pass later:\n-                    mark_variable_as_used_mut(self, cmt);\n+                    mark_variable_as_used_mut(self, assignee_cmt);\n                 }\n             }\n             return;\n         }\n \n         // For immutable local variables, assignments are legal\n         // if they cannot already have been assigned\n-        if self.is_local_variable(cmt.clone()) {\n-            assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n-            let lp = opt_loan_path(&cmt).unwrap();\n-            self.move_data.each_assignment_of(expr.id, &lp, |assign| {\n+        if self.is_local_variable_or_arg(assignee_cmt.clone()) {\n+            assert!(assignee_cmt.mutbl.is_immutable()); // no \"const\" locals\n+            let lp = opt_loan_path(&assignee_cmt).unwrap();\n+            self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 self.bccx.report_reassigned_immutable_variable(\n-                    expr.span,\n+                    assignment_span,\n                     &*lp,\n                     assign);\n                 false\n@@ -424,21 +602,21 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n \n         // Otherwise, just a plain error.\n-        match opt_loan_path(&cmt) {\n+        match opt_loan_path(&assignee_cmt) {\n             Some(lp) => {\n                 self.bccx.span_err(\n-                    expr.span,\n+                    assignment_span,\n                     format!(\"cannot assign to {} {} `{}`\",\n-                            cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_str(&*cmt),\n+                            assignee_cmt.mutbl.to_user_str(),\n+                            self.bccx.cmt_to_str(&*assignee_cmt),\n                             self.bccx.loan_path_to_str(&*lp)).as_slice());\n             }\n             None => {\n                 self.bccx.span_err(\n-                    expr.span,\n+                    assignment_span,\n                     format!(\"cannot assign to {} {}\",\n-                            cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_str(&*cmt)).as_slice());\n+                            assignee_cmt.mutbl.to_user_str(),\n+                            self.bccx.cmt_to_str(&*assignee_cmt)).as_slice());\n             }\n         }\n         return;\n@@ -495,7 +673,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n \n         fn check_for_aliasable_mutable_writes(this: &CheckLoanCtxt,\n-                                              expr: &ast::Expr,\n+                                              span: Span,\n                                               cmt: mc::cmt) -> bool {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n@@ -506,7 +684,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 mc::cat_deref(ref b, _, mc::BorrowedPtr(ty::MutBorrow, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n-                    check_for_aliasability_violation(this, expr, b.clone());\n+                    check_for_aliasability_violation(this, span, b.clone());\n                 }\n \n                 _ => {}\n@@ -516,7 +694,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n \n         fn check_for_aliasability_violation(this: &CheckLoanCtxt,\n-                                            expr: &ast::Expr,\n+                                            span: Span,\n                                             cmt: mc::cmt)\n                                             -> bool {\n             match cmt.freely_aliasable(this.tcx()) {\n@@ -528,7 +706,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 }\n                 Some(cause) => {\n                     this.bccx.report_aliasability_violation(\n-                        expr.span,\n+                        span,\n                         MutabilityViolation,\n                         cause);\n                     return false;\n@@ -538,13 +716,14 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         fn check_for_assignment_to_restricted_or_frozen_location(\n             this: &CheckLoanCtxt,\n-            expr: &ast::Expr,\n-            cmt: mc::cmt) -> bool\n+            assignment_id: ast::NodeId,\n+            assignment_span: Span,\n+            assignee_cmt: mc::cmt) -> bool\n         {\n             //! Check for assignments that violate the terms of an\n             //! outstanding loan.\n \n-            let loan_path = match opt_loan_path(&cmt) {\n+            let loan_path = match opt_loan_path(&assignee_cmt) {\n                 Some(lp) => lp,\n                 None => { return true; /* no loan path, can't be any loans */ }\n             };\n@@ -579,11 +758,11 @@ impl<'a> CheckLoanCtxt<'a> {\n             // `RESTR_MUTATE` restriction whenever the contents of an\n             // owned pointer are borrowed, and hence while `v[*]` is not\n             // restricted from being written, `v` is.\n-            let cont = this.each_in_scope_restriction(expr.id,\n+            let cont = this.each_in_scope_restriction(assignment_id,\n                                                       &*loan_path,\n                                                       |loan, restr| {\n                 if restr.set.intersects(RESTR_MUTATE) {\n-                    this.report_illegal_mutation(expr, &*loan_path, loan);\n+                    this.report_illegal_mutation(assignment_span, &*loan_path, loan);\n                     false\n                 } else {\n                     true\n@@ -656,9 +835,9 @@ impl<'a> CheckLoanCtxt<'a> {\n                 };\n \n                 // Check for a non-const loan of `loan_path`\n-                let cont = this.each_in_scope_loan(expr.id, |loan| {\n+                let cont = this.each_in_scope_loan(assignment_id, |loan| {\n                     if loan.loan_path == loan_path {\n-                        this.report_illegal_mutation(expr, &*full_loan_path, loan);\n+                        this.report_illegal_mutation(assignment_span, &*full_loan_path, loan);\n                         false\n                     } else {\n                         true\n@@ -671,11 +850,11 @@ impl<'a> CheckLoanCtxt<'a> {\n     }\n \n     pub fn report_illegal_mutation(&self,\n-                                   expr: &ast::Expr,\n+                                   span: Span,\n                                    loan_path: &LoanPath,\n                                    loan: &Loan) {\n         self.bccx.span_err(\n-            expr.span,\n+            span,\n             format!(\"cannot assign to `{}` because it is borrowed\",\n                     self.bccx.loan_path_to_str(loan_path)).as_slice());\n         self.bccx.span_note(\n@@ -684,86 +863,6 @@ impl<'a> CheckLoanCtxt<'a> {\n                     self.bccx.loan_path_to_str(loan_path)).as_slice());\n     }\n \n-    fn check_move_out_from_expr(&self, expr: &ast::Expr) {\n-        match expr.node {\n-            ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-                // Moves due to captures are checked in\n-                // check_captured_variables() because it allows\n-                // us to give a more precise error message with\n-                // a more precise span.\n-            }\n-            _ => {\n-                self.check_move_out_from_id(expr.id, expr.span)\n-            }\n-        }\n-    }\n-\n-    fn check_move_out_from_id(&self, id: ast::NodeId, span: Span) {\n-        self.move_data.each_path_moved_by(id, |_, move_path| {\n-            match self.analyze_move_out_from(id, move_path) {\n-                MoveOk => {}\n-                MoveWhileBorrowed(loan_path, loan_span) => {\n-                    self.bccx.span_err(\n-                        span,\n-                        format!(\"cannot move out of `{}` \\\n-                                because it is borrowed\",\n-                                self.bccx.loan_path_to_str(\n-                                    move_path)).as_slice());\n-                    self.bccx.span_note(\n-                        loan_span,\n-                        format!(\"borrow of `{}` occurs here\",\n-                                self.bccx.loan_path_to_str(\n-                                    &*loan_path)).as_slice());\n-                }\n-            }\n-            true\n-        });\n-    }\n-\n-    fn check_captured_variables(&self,\n-                                closure_id: ast::NodeId,\n-                                span: Span) {\n-        let freevar_mode = freevars::get_capture_mode(self.tcx(), closure_id);\n-        freevars::with_freevars(self.tcx(), closure_id, |freevars| {\n-            for freevar in freevars.iter() {\n-                let var_id = ast_util::def_id_of_def(freevar.def).node;\n-                let var_path = Rc::new(LpVar(var_id));\n-                self.check_if_path_is_moved(closure_id, span,\n-                                            MovedInCapture, &var_path);\n-                match freevar_mode {\n-                    freevars::CaptureByRef => { }\n-                    freevars::CaptureByValue => {\n-                        check_by_move_capture(self, closure_id, freevar, &*var_path);\n-                    }\n-                }\n-            }\n-        });\n-        return;\n-\n-        fn check_by_move_capture(this: &CheckLoanCtxt,\n-                                 closure_id: ast::NodeId,\n-                                 freevar: &freevars::freevar_entry,\n-                                 move_path: &LoanPath) {\n-            let move_err = this.analyze_move_out_from(closure_id, move_path);\n-            match move_err {\n-                MoveOk => {}\n-                MoveWhileBorrowed(loan_path, loan_span) => {\n-                    this.bccx.span_err(\n-                        freevar.span,\n-                        format!(\"cannot move `{}` into closure \\\n-                                because it is borrowed\",\n-                                this.bccx.loan_path_to_str(\n-                                    move_path)).as_slice());\n-                    this.bccx.span_note(\n-                        loan_span,\n-                        format!(\"borrow of `{}` occurs here\",\n-                                this.bccx.loan_path_to_str(\n-                                    &*loan_path)).as_slice());\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn analyze_move_out_from(&self,\n                                  expr_id: ast::NodeId,\n                                  move_path: &LoanPath)\n@@ -794,89 +893,5 @@ impl<'a> CheckLoanCtxt<'a> {\n             }\n         }\n     }\n-\n-    pub fn check_call(&self,\n-                      _expr: &ast::Expr,\n-                      _callee: Option<@ast::Expr>,\n-                      _callee_span: Span,\n-                      _args: &[@ast::Expr]) {\n-        // NB: This call to check for conflicting loans is not truly\n-        // necessary, because the callee_id never issues new loans.\n-        // However, I added it for consistency and lest the system\n-        // should change in the future.\n-        //\n-        // FIXME(#6268) nested method calls\n-        // self.check_for_conflicting_loans(callee_id);\n-    }\n }\n \n-fn check_loans_in_local<'a>(this: &mut CheckLoanCtxt<'a>,\n-                            local: &ast::Local) {\n-    visit::walk_local(this, local, ());\n-}\n-\n-fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n-                           expr: &ast::Expr) {\n-    visit::walk_expr(this, expr, ());\n-\n-    debug!(\"check_loans_in_expr(expr={})\",\n-           expr.repr(this.tcx()));\n-\n-    this.check_for_conflicting_loans(expr.id);\n-    this.check_move_out_from_expr(expr);\n-\n-    let method_map = this.bccx.tcx.method_map.borrow();\n-    match expr.node {\n-      ast::ExprPath(..) => {\n-          if !this.move_data.is_assignee(expr.id) {\n-              let cmt = this.bccx.cat_expr_unadjusted(expr);\n-              debug!(\"path cmt={}\", cmt.repr(this.tcx()));\n-              for lp in opt_loan_path(&cmt).iter() {\n-                  this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);\n-              }\n-          }\n-      }\n-      ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-          this.check_captured_variables(expr.id, expr.span)\n-      }\n-      ast::ExprAssign(dest, _) |\n-      ast::ExprAssignOp(_, dest, _) => {\n-        this.check_assignment(dest);\n-      }\n-      ast::ExprCall(f, ref args) => {\n-        this.check_call(expr, Some(f), f.span, args.as_slice());\n-      }\n-      ast::ExprMethodCall(_, _, ref args) => {\n-        this.check_call(expr, None, expr.span, args.as_slice());\n-      }\n-      ast::ExprIndex(_, rval) | ast::ExprBinary(_, _, rval)\n-      if method_map.contains_key(&MethodCall::expr(expr.id)) => {\n-        this.check_call(expr, None, expr.span, [rval]);\n-      }\n-      ast::ExprUnary(_, _) | ast::ExprIndex(_, _)\n-      if method_map.contains_key(&MethodCall::expr(expr.id)) => {\n-        this.check_call(expr, None, expr.span, []);\n-      }\n-      ast::ExprInlineAsm(ref ia) => {\n-          for &(_, out) in ia.outputs.iter() {\n-              this.check_assignment(out);\n-          }\n-      }\n-      _ => {}\n-    }\n-}\n-\n-fn check_loans_in_pat<'a>(this: &mut CheckLoanCtxt<'a>,\n-                          pat: &ast::Pat)\n-{\n-    this.check_for_conflicting_loans(pat.id);\n-    this.check_move_out_from_id(pat.id, pat.span);\n-    visit::walk_pat(this, pat, ());\n-}\n-\n-fn check_loans_in_block<'a>(this: &mut CheckLoanCtxt<'a>,\n-                            blk: &ast::Block)\n-{\n-    visit::walk_block(this, blk, ());\n-    this.check_for_conflicting_loans(blk.id);\n-}"}, {"sha": "6df474809779ac37cd62eebe2b80a6c86f002b7b", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -45,10 +45,15 @@ pub fn gather_move_from_expr(bccx: &BorrowckCtxt,\n                              move_data: &MoveData,\n                              move_error_collector: &MoveErrorCollector,\n                              move_expr_id: ast::NodeId,\n-                             cmt: mc::cmt) {\n+                             cmt: mc::cmt,\n+                             move_reason: euv::MoveReason) {\n+    let kind = match move_reason {\n+        euv::DirectRefMove | euv::PatBindingMove => MoveExpr,\n+        euv::CaptureMove => Captured\n+    };\n     let move_info = GatherMoveInfo {\n         id: move_expr_id,\n-        kind: MoveExpr,\n+        kind: kind,\n         cmt: cmt,\n         span_path_opt: None,\n     };"}, {"sha": "003687e7b63f9e342c86074d2fd4e3c9fa346a2d", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -75,13 +75,13 @@ impl<'a> euv::Delegate for GatherLoanCtxt<'a> {\n                consume_id, cmt.repr(self.tcx()), mode);\n \n         match mode {\n-            euv::Copy => { return; }\n-            euv::Move => { }\n+            euv::Move(move_reason) => {\n+                gather_moves::gather_move_from_expr(\n+                    self.bccx, &self.move_data, &self.move_error_collector,\n+                    consume_id, cmt, move_reason);\n+            }\n+            euv::Copy => { }\n         }\n-\n-        gather_moves::gather_move_from_expr(\n-            self.bccx, &self.move_data, &self.move_error_collector,\n-            consume_id, cmt);\n     }\n \n     fn consume_pat(&mut self,\n@@ -95,7 +95,7 @@ impl<'a> euv::Delegate for GatherLoanCtxt<'a> {\n \n         match mode {\n             euv::Copy => { return; }\n-            euv::Move => { }\n+            euv::Move(_) => { }\n         }\n \n         gather_moves::gather_move_from_pat("}, {"sha": "0fbcf157dacad562721144b91a3680cb448fce46", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -142,7 +142,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                                                       body);\n \n     check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n-                             all_loans.as_slice(), body);\n+                             all_loans.as_slice(), decl, body);\n \n     visit::walk_fn(this, fk, decl, body, sp, ());\n }"}, {"sha": "f7c26292334841c6e20bb4b47dee8bfcc5191afd", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -115,6 +115,7 @@ pub struct MovePath {\n     pub next_sibling: MovePathIndex,\n }\n \n+#[deriving(PartialEq)]\n pub enum MoveKind {\n     Declared,   // When declared, variables start out \"moved\".\n     MoveExpr,   // Expression or binding that moves a variable\n@@ -356,7 +357,7 @@ impl MoveData {\n         let path_index = self.move_path(tcx, lp.clone());\n \n         match mode {\n-            euv::JustWrite => {\n+            euv::Init | euv::JustWrite => {\n                 self.assignee_ids.borrow_mut().insert(assignee_id);\n             }\n             euv::WriteAndRead => { }\n@@ -537,6 +538,28 @@ impl<'a> FlowedMoveData<'a> {\n         })\n     }\n \n+    pub fn kind_of_move_of_path(&self,\n+                                id: ast::NodeId,\n+                                loan_path: &Rc<LoanPath>)\n+                                -> Option<MoveKind> {\n+        //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n+\n+        let mut ret = None;\n+        for loan_path_index in self.move_data.path_map.borrow().find(&*loan_path).iter() {\n+            self.dfcx_moves.each_gen_bit_frozen(id, |move_index| {\n+                let move = self.move_data.moves.borrow();\n+                let move = move.get(move_index);\n+                if move.path == **loan_path_index {\n+                    ret = Some(move.kind);\n+                    false\n+                } else {\n+                    true\n+                }\n+            });\n+        }\n+        ret\n+    }\n+\n     pub fn each_move_of(&self,\n                         id: ast::NodeId,\n                         loan_path: &Rc<LoanPath>,"}, {"sha": "cd71d95bee9481f5744f1f604397a1f4ecc7c839", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -80,12 +80,20 @@ pub enum LoanCause {\n \n #[deriving(PartialEq,Show)]\n pub enum ConsumeMode {\n-    Copy,    // reference to x where x has a type that copies\n-    Move,    // reference to x where x has a type that moves\n+    Copy,                // reference to x where x has a type that copies\n+    Move(MoveReason),    // reference to x where x has a type that moves\n+}\n+\n+#[deriving(PartialEq,Show)]\n+pub enum MoveReason {\n+    DirectRefMove,\n+    PatBindingMove,\n+    CaptureMove,\n }\n \n #[deriving(PartialEq,Show)]\n pub enum MutateMode {\n+    Init,\n     JustWrite,    // x = y\n     WriteAndRead, // x += y\n }\n@@ -160,7 +168,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                         consume_id: ast::NodeId,\n                         consume_span: Span,\n                         cmt: mc::cmt) {\n-        let mode = copy_or_move(self.tcx(), cmt.ty);\n+        let mode = copy_or_move(self.tcx(), cmt.ty, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n@@ -712,7 +720,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 let def = def_map.borrow().get_copy(&pat.id);\n                 match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     Ok(binding_cmt) => {\n-                        delegate.mutate(pat.id, pat.span, binding_cmt, JustWrite);\n+                        delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n                     }\n                     Err(_) => { }\n                 }\n@@ -728,7 +736,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                                              r, bk, RefBinding);\n                     }\n                     ast::PatIdent(ast::BindByValue(_), _, _) => {\n-                        let mode = copy_or_move(typer.tcx(), cmt_pat.ty);\n+                        let mode = copy_or_move(typer.tcx(), cmt_pat.ty, PatBindingMove);\n                         delegate.consume_pat(pat, cmt_pat, mode);\n                     }\n                     _ => {\n@@ -834,7 +842,8 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n             let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                closure_expr.span,\n                                                                freevar.def));\n-            self.delegate_consume(closure_expr.id, freevar.span, cmt_var);\n+            let mode = copy_or_move(self.tcx(), cmt_var.ty, CaptureMove);\n+            self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n         }\n     }\n \n@@ -851,7 +860,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n     }\n }\n \n-fn copy_or_move(tcx: &ty::ctxt, ty: ty::t) -> ConsumeMode {\n-    if ty::type_moves_by_default(tcx, ty) { Move } else { Copy }\n+fn copy_or_move(tcx: &ty::ctxt, ty: ty::t, move_reason: MoveReason) -> ConsumeMode {\n+    if ty::type_moves_by_default(tcx, ty) { Move(move_reason) } else { Copy }\n }\n "}, {"sha": "240212699e4de314cc36063faae2f48c1061b448", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -390,12 +390,10 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             Some(adjustment) => {\n                 match *adjustment {\n                     ty::AutoObject(..) => {\n-                        // Implicity casts a concrete object to trait object\n-                        // so just patch up the type\n+                        // Implicity cast a concrete object to trait object.\n+                        // Result is an rvalue.\n                         let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n-                        let mut expr_cmt = (*if_ok!(self.cat_expr_unadjusted(expr))).clone();\n-                        expr_cmt.ty = expr_ty;\n-                        Ok(Rc::new(expr_cmt))\n+                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n                     ty::AutoAddEnv(..) => {"}, {"sha": "4363f85048f0e45fb77351328711a5754fe81e09", "filename": "src/test/compile-fail/borrowck-field-sensitivity.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A { a: int, b: Box<int> }\n+\n+fn borrow<T>(_: &T) { }\n+\n+fn use_after_move() {\n+    let x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    drop(*x.b); //~ ERROR use of partially moved value: `*x.b`\n+}\n+\n+fn use_after_fu_move() {\n+    let x = A { a: 1, b: box 2 };\n+    let y = A { a: 3, .. x };\n+    drop(*x.b); //~ ERROR use of partially moved value: `*x.b`\n+}\n+\n+fn borrow_after_move() {\n+    let x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    borrow(&x.b); //~ ERROR use of moved value: `x.b`\n+}\n+\n+fn borrow_after_fu_move() {\n+    let x = A { a: 1, b: box 2 };\n+    let _y = A { a: 3, .. x };\n+    borrow(&x.b); //~ ERROR use of moved value: `x.b`\n+}\n+\n+fn move_after_borrow() {\n+    let x = A { a: 1, b: box 2 };\n+    let y = &x.b;\n+    drop(x.b); //~ ERROR cannot move out of `x.b` because it is borrowed\n+    borrow(&*y);\n+}\n+\n+fn fu_move_after_borrow() {\n+    let x = A { a: 1, b: box 2 };\n+    let y = &x.b;\n+    let _z = A { a: 3, .. x }; //~ ERROR cannot move out of `x.b` because it is borrowed\n+    borrow(&*y);\n+}\n+\n+fn mut_borrow_after_mut_borrow() {\n+    let mut x = A { a: 1, b: box 2 };\n+    let y = &mut x.a;\n+    let z = &mut x.a; //~ ERROR cannot borrow `x.a` as mutable more than once at a time\n+    drop(*y);\n+    drop(*z);\n+}\n+\n+fn move_after_move() {\n+    let x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    drop(x.b);  //~ ERROR use of moved value: `x.b`\n+}\n+\n+fn move_after_fu_move() {\n+    let x = A { a: 1, b: box 2 };\n+    let _y = A { a: 3, .. x };\n+    drop(x.b);  //~ ERROR use of moved value: `x.b`\n+}\n+\n+fn fu_move_after_move() {\n+    let x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    let _z = A { a: 3, .. x };  //~ ERROR use of moved value: `x.b`\n+}\n+\n+fn fu_move_after_fu_move() {\n+    let x = A { a: 1, b: box 2 };\n+    let _y = A { a: 3, .. x };\n+    let _z = A { a: 4, .. x };  //~ ERROR use of moved value: `x.b`\n+}\n+\n+// The following functions aren't yet accepted, but they should be.\n+\n+fn use_after_field_assign_after_uninit() {\n+    let mut x: A;\n+    x.a = 1;\n+    drop(x.a); //~ ERROR use of possibly uninitialized variable: `x.a`\n+}\n+\n+fn borrow_after_field_assign_after_uninit() {\n+    let mut x: A;\n+    x.a = 1;\n+    borrow(&x.a); //~ ERROR use of possibly uninitialized variable: `x.a`\n+}\n+\n+fn move_after_field_assign_after_uninit() {\n+    let mut x: A;\n+    x.b = box 1;\n+    drop(x.b); //~ ERROR use of possibly uninitialized variable: `x.b`\n+}\n+\n+fn main() {\n+    use_after_move();\n+    use_after_fu_move();\n+\n+    borrow_after_move();\n+    borrow_after_fu_move();\n+    move_after_borrow();\n+    fu_move_after_borrow();\n+    mut_borrow_after_mut_borrow();\n+\n+    move_after_move();\n+    move_after_fu_move();\n+    fu_move_after_move();\n+    fu_move_after_fu_move();\n+\n+    use_after_field_assign_after_uninit();\n+    borrow_after_field_assign_after_uninit();\n+    move_after_field_assign_after_uninit();\n+}\n+"}, {"sha": "6a42989b47bba79dfa05ce0bc4bff9b0175d9dc4", "filename": "src/test/compile-fail/borrowck-init-in-fru.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fru.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -16,6 +16,6 @@ struct point {\n \n fn main() {\n     let mut origin: point;\n-    origin = point {x: 10,.. origin}; //~ ERROR use of possibly uninitialized variable: `origin`\n+    origin = point {x: 10,.. origin}; //~ ERROR use of possibly uninitialized variable: `origin.y`\n     origin.clone();\n }"}, {"sha": "e12d2b9147978cebd33936d4257a659d245962e0", "filename": "src/test/compile-fail/borrowck-multiple-captures.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::task;\n+\n+fn borrow<T>(_: &T) { }\n+\n+fn different_vars_after_borrows() {\n+    let x1 = box 1;\n+    let p1 = &x1;\n+    let x2 = box 2;\n+    let p2 = &x2;\n+    task::spawn(proc() {\n+        drop(x1); //~ ERROR cannot move `x1` into closure because it is borrowed\n+        drop(x2); //~ ERROR cannot move `x2` into closure because it is borrowed\n+    });\n+    borrow(&*p1);\n+    borrow(&*p2);\n+}\n+\n+fn different_vars_after_moves() {\n+    let x1 = box 1;\n+    drop(x1);\n+    let x2 = box 2;\n+    drop(x2);\n+    task::spawn(proc() {\n+        drop(x1); //~ ERROR capture of moved value: `x1`\n+        drop(x2); //~ ERROR capture of moved value: `x2`\n+    });\n+}\n+\n+fn same_var_after_borrow() {\n+    let x = box 1;\n+    let p = &x;\n+    task::spawn(proc() {\n+        drop(x); //~ ERROR cannot move `x` into closure because it is borrowed\n+        drop(x); //~ ERROR use of moved value: `x`\n+    });\n+    borrow(&*p);\n+}\n+\n+fn same_var_after_move() {\n+    let x = box 1;\n+    drop(x);\n+    task::spawn(proc() {\n+        drop(x); //~ ERROR capture of moved value: `x`\n+        drop(x); //~ ERROR use of moved value: `x`\n+    });\n+}\n+\n+fn main() {\n+    different_vars_after_borrows();\n+    different_vars_after_moves();\n+    same_var_after_borrow();\n+    same_var_after_move();\n+}\n+"}, {"sha": "4b578765f32f411ccbf0e287679aa0f42b4b7adc", "filename": "src/test/compile-fail/liveness-use-after-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -13,6 +13,6 @@ extern crate debug;\n fn main() {\n     let x = box 5;\n     let y = x;\n-    println!(\"{:?}\", *x); //~ ERROR use of moved value: `x`\n+    println!(\"{:?}\", *x); //~ ERROR use of partially moved value: `*x`\n     y.clone();\n }"}, {"sha": "f09e80974bd42d97d11745fc8d9ab277726ac9ab", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -17,12 +17,6 @@ struct Foo { f: String, y: int }\n fn consume(_s: String) {}\n fn touch<A>(_a: &A) {}\n \n-fn f10() {\n-    let x = Foo { f: \"hi\".to_string(), y: 3 };\n-    consume(x.f);\n-    touch(&x.y); //~ ERROR use of partially moved value: `x`\n-}\n-\n fn f20() {\n     let x = vec!(\"hi\".to_string());\n     consume(x.move_iter().next().unwrap());"}, {"sha": "8b02740497df8945cbfd3dbacc2da4b9c2c638ed", "filename": "src/test/compile-fail/moves-sru-moved-field.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -26,13 +26,7 @@ fn test0(f: Foo, g: Noncopyable, h: Noncopyable) {\n fn test1(f: Foo, g: Noncopyable, h: Noncopyable) {\n     // copying move-by-default fields from `f`, so move:\n     let _b = Foo {noncopyable: g, ..f};\n-    let _c = Foo {noncopyable: h, ..f}; //~ ERROR use of partially moved value: `f`\n-}\n-\n-fn test2(f: Foo, g: Noncopyable) {\n-    // move non-copyable field\n-    let _b = Foo {copied: 22, moved: box 23, ..f};\n-    let _c = Foo {noncopyable: g, ..f}; //~ ERROR use of partially moved value: `f`\n+    let _c = Foo {noncopyable: h, ..f}; //~ ERROR use of moved value: `f.moved`\n }\n \n fn main() {}"}, {"sha": "b11650a6a4f1fdb7dfcc981f0e6c1f2bf4c3198f", "filename": "src/test/compile-fail/use-after-move-self-based-on-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -19,7 +19,7 @@ impl Drop for S {\n impl S {\n     pub fn foo(self) -> int {\n         self.bar();\n-        return self.x;  //~ ERROR use of moved value: `self`\n+        return self.x;  //~ ERROR use of partially moved value: `self.x`\n     }\n \n     pub fn bar(self) {}"}, {"sha": "22c3ec7c3417ced1ddb9cc9269923be53f259a73", "filename": "src/test/compile-fail/use-after-move-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -16,7 +16,7 @@ struct S {\n impl S {\n     pub fn foo(self) -> int {\n         self.bar();\n-        return *self.x;  //~ ERROR use of moved value: `self`\n+        return *self.x;  //~ ERROR use of partially moved value: `*self.x`\n     }\n \n     pub fn bar(self) {}"}, {"sha": "3b82f51123f8d3b2bff4333ec0d8746dec001532", "filename": "src/test/run-pass/borrowck-field-sensitivity.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Frun-pass%2Fborrowck-field-sensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d79175c018a193a7676fe804f1b89280e18937/src%2Ftest%2Frun-pass%2Fborrowck-field-sensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-field-sensitivity.rs?ref=61d79175c018a193a7676fe804f1b89280e18937", "patch": "@@ -0,0 +1,223 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A { a: int, b: Box<int> }\n+struct B { a: Box<int>, b: Box<int> }\n+\n+fn borrow<T>(_: &T) { }\n+\n+fn move_after_use() {\n+    let x = A { a: 1, b: box 2 };\n+    drop(x.a);\n+    drop(x.b);\n+}\n+\n+fn move_after_fu_use() {\n+    let x = A { a: 1, b: box 2 };\n+    let _y = A { b: box 3, .. x };\n+    drop(x.b);\n+}\n+\n+fn fu_move_after_use() {\n+    let x = A { a: 1, b: box 2 };\n+    drop(x.a);\n+    let y = A { a: 3, .. x };\n+    drop(y.b);\n+}\n+\n+fn fu_move_after_fu_use() {\n+    let x = A { a: 1, b: box 2 };\n+    let _y = A { b: box 3, .. x };\n+    let z = A { a: 4, .. x };\n+    drop(z.b);\n+}\n+\n+fn use_after_move() {\n+    let x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    drop(x.a);\n+}\n+\n+fn use_after_fu_move() {\n+    let x = A { a: 1, b: box 2 };\n+    let y = A { a: 3, .. x };\n+    drop(x.a);\n+    drop(y.b);\n+}\n+\n+fn fu_use_after_move() {\n+    let x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    let _y = A { b: box 3, .. x };\n+}\n+\n+fn fu_use_after_fu_move() {\n+    let x = A { a: 1, b: box 2 };\n+    let y = A { a: 3, .. x };\n+    let _z = A { b: box 3, .. x };\n+    drop(y.b);\n+}\n+\n+fn borrow_after_move() {\n+    let x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    borrow(&x.a);\n+}\n+\n+fn borrow_after_fu_move() {\n+    let x = A { a: 1, b: box 2 };\n+    let y = A { a: 3, .. x };\n+    borrow(&x.a);\n+    drop(y.b);\n+}\n+\n+fn move_after_borrow() {\n+    let x = A { a: 1, b: box 2 };\n+    borrow(&x.a);\n+    drop(x.b);\n+}\n+\n+fn fu_move_after_borrow() {\n+    let x = A { a: 1, b: box 2 };\n+    borrow(&x.a);\n+    let y = A { a: 3, .. x };\n+    drop(y.b);\n+}\n+\n+fn mut_borrow_after_mut_borrow() {\n+    let mut x = A { a: 1, b: box 2 };\n+    let y = &mut x.a;\n+    let z = &mut x.b;\n+    drop(*y);\n+    drop(**z);\n+}\n+\n+fn move_after_move() {\n+    let x = B { a: box 1, b: box 2 };\n+    drop(x.a);\n+    drop(x.b);\n+}\n+\n+fn move_after_fu_move() {\n+    let x = B { a: box 1, b: box 2 };\n+    let y = B { a: box 3, .. x };\n+    drop(x.a);\n+    drop(y.b);\n+}\n+\n+fn fu_move_after_move() {\n+    let x = B { a: box 1, b: box 2 };\n+    drop(x.a);\n+    let z = B { a: box 3, .. x };\n+    drop(z.b);\n+}\n+\n+fn fu_move_after_fu_move() {\n+    let x = B { a: box 1, b: box 2 };\n+    let y = B { b: box 3, .. x };\n+    let z = B { a: box 4, .. x };\n+    drop(y.a);\n+    drop(z.b);\n+}\n+\n+fn use_after_assign_after_move() {\n+    let mut x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    x = A { a: 3, b: box 4 };\n+    drop(*x.b);\n+}\n+\n+fn use_after_field_assign_after_move() {\n+    let mut x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    x.b = box 3;\n+    drop(*x.b);\n+}\n+\n+fn borrow_after_assign_after_move() {\n+    let mut x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    x = A { a: 3, b: box 4 };\n+    borrow(&x.b);\n+}\n+\n+fn borrow_after_field_assign_after_move() {\n+    let mut x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    x.b = box 3;\n+    borrow(&x.b);\n+}\n+\n+fn move_after_assign_after_move() {\n+    let mut x = A { a: 1, b: box 2 };\n+    let y = x.b;\n+    x = A { a: 3, b: box 4 };\n+    drop(x.b);\n+    drop(y);\n+}\n+\n+fn move_after_field_assign_after_move() {\n+    let mut x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+    x.b = box 3;\n+    drop(x.b);\n+}\n+\n+fn use_after_assign_after_uninit() {\n+    let mut x: A;\n+    x = A { a: 1, b: box 2 };\n+    drop(x.a);\n+}\n+\n+fn borrow_after_assign_after_uninit() {\n+    let mut x: A;\n+    x = A { a: 1, b: box 2 };\n+    borrow(&x.a);\n+}\n+\n+fn move_after_assign_after_uninit() {\n+    let mut x: A;\n+    x = A { a: 1, b: box 2 };\n+    drop(x.b);\n+}\n+\n+fn main() {\n+    move_after_use();\n+    move_after_fu_use();\n+    fu_move_after_use();\n+    fu_move_after_fu_use();\n+    use_after_move();\n+    use_after_fu_move();\n+    fu_use_after_move();\n+    fu_use_after_fu_move();\n+\n+    borrow_after_move();\n+    borrow_after_fu_move();\n+    move_after_borrow();\n+    fu_move_after_borrow();\n+    mut_borrow_after_mut_borrow();\n+\n+    move_after_move();\n+    move_after_fu_move();\n+    fu_move_after_move();\n+    fu_move_after_fu_move();\n+\n+    use_after_assign_after_move();\n+    use_after_field_assign_after_move();\n+    borrow_after_assign_after_move();\n+    borrow_after_field_assign_after_move();\n+    move_after_assign_after_move();\n+    move_after_field_assign_after_move();\n+\n+    use_after_assign_after_uninit();\n+    borrow_after_assign_after_uninit();\n+    move_after_assign_after_uninit();\n+}\n+"}]}