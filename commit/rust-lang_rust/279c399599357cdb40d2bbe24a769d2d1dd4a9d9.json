{"sha": "279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OWMzOTk1OTkzNTdjZGI0MGQyYmJlMjRhNzY5ZDJkMWRkNGE5ZDk=", "commit": {"author": {"name": "Baoshan Pang", "email": "baoshan.pang@windriver.com", "date": "2019-07-22T01:22:29Z"}, "committer": {"name": "Baoshan Pang", "email": "baoshan.pang@windriver.com", "date": "2019-07-22T01:29:24Z"}, "message": "code cleanup", "tree": {"sha": "7f30ce18240c9b4819d74fe72c8525603a8f584c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f30ce18240c9b4819d74fe72c8525603a8f584c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "html_url": "https://github.com/rust-lang/rust/commit/279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/comments", "author": {"login": "bpangWR", "id": 53950092, "node_id": "MDQ6VXNlcjUzOTUwMDky", "avatar_url": "https://avatars.githubusercontent.com/u/53950092?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bpangWR", "html_url": "https://github.com/bpangWR", "followers_url": "https://api.github.com/users/bpangWR/followers", "following_url": "https://api.github.com/users/bpangWR/following{/other_user}", "gists_url": "https://api.github.com/users/bpangWR/gists{/gist_id}", "starred_url": "https://api.github.com/users/bpangWR/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bpangWR/subscriptions", "organizations_url": "https://api.github.com/users/bpangWR/orgs", "repos_url": "https://api.github.com/users/bpangWR/repos", "events_url": "https://api.github.com/users/bpangWR/events{/privacy}", "received_events_url": "https://api.github.com/users/bpangWR/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bpangWR", "id": 53950092, "node_id": "MDQ6VXNlcjUzOTUwMDky", "avatar_url": "https://avatars.githubusercontent.com/u/53950092?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bpangWR", "html_url": "https://github.com/bpangWR", "followers_url": "https://api.github.com/users/bpangWR/followers", "following_url": "https://api.github.com/users/bpangWR/following{/other_user}", "gists_url": "https://api.github.com/users/bpangWR/gists{/gist_id}", "starred_url": "https://api.github.com/users/bpangWR/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bpangWR/subscriptions", "organizations_url": "https://api.github.com/users/bpangWR/orgs", "repos_url": "https://api.github.com/users/bpangWR/repos", "events_url": "https://api.github.com/users/bpangWR/events{/privacy}", "received_events_url": "https://api.github.com/users/bpangWR/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "273f42b5964c29dda2c5a349dd4655529767b07f", "url": "https://api.github.com/repos/rust-lang/rust/commits/273f42b5964c29dda2c5a349dd4655529767b07f", "html_url": "https://github.com/rust-lang/rust/commit/273f42b5964c29dda2c5a349dd4655529767b07f"}], "stats": {"total": 1043, "additions": 1, "deletions": 1042}, "files": [{"sha": "e0c560b9214ea1e92b2b6b28137110d448179831", "filename": "src/libstd/sys/vxworks/alloc.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs?ref=279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "patch": "@@ -41,36 +41,6 @@ unsafe impl GlobalAlloc for System {\n     }\n }\n \n-#[cfg(any(target_os = \"android\",\n-          target_os = \"hermit\",\n-          target_os = \"redox\",\n-          target_os = \"solaris\"))]\n-#[inline]\n-unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-    // On android we currently target API level 9 which unfortunately\n-    // doesn't have the `posix_memalign` API used below. Instead we use\n-    // `memalign`, but this unfortunately has the property on some systems\n-    // where the memory returned cannot be deallocated by `free`!\n-    //\n-    // Upon closer inspection, however, this appears to work just fine with\n-    // Android, so for this platform we should be fine to call `memalign`\n-    // (which is present in API level 9). Some helpful references could\n-    // possibly be chromium using memalign [1], attempts at documenting that\n-    // memalign + free is ok [2] [3], or the current source of chromium\n-    // which still uses memalign on android [4].\n-    //\n-    // [1]: https://codereview.chromium.org/10796020/\n-    // [2]: https://code.google.com/p/android/issues/detail?id=35391\n-    // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n-    // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n-    //                                       /memory/aligned_memory.cc\n-    libc::memalign(layout.align(), layout.size()) as *mut u8\n-}\n-\n-#[cfg(not(any(target_os = \"android\",\n-              target_os = \"hermit\",\n-              target_os = \"redox\",\n-              target_os = \"solaris\")))]\n #[inline]\n unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n     let mut out = ptr::null_mut();"}, {"sha": "6774160bb2561596117de3b16800bd8e7ff31fcf", "filename": "src/libstd/sys/vxworks/android.rs", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/273f42b5964c29dda2c5a349dd4655529767b07f/src%2Flibstd%2Fsys%2Fvxworks%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273f42b5964c29dda2c5a349dd4655529767b07f/src%2Flibstd%2Fsys%2Fvxworks%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fandroid.rs?ref=273f42b5964c29dda2c5a349dd4655529767b07f", "patch": "@@ -1,160 +0,0 @@\n-//! Android ABI-compatibility module\n-//!\n-//! The ABI of Android has changed quite a bit over time, and libstd attempts to\n-//! be both forwards and backwards compatible as much as possible. We want to\n-//! always work with the most recent version of Android, but we also want to\n-//! work with older versions of Android for whenever projects need to.\n-//!\n-//! Our current minimum supported Android version is `android-9`, e.g., Android\n-//! with API level 9. We then in theory want to work on that and all future\n-//! versions of Android!\n-//!\n-//! Some of the detection here is done at runtime via `dlopen` and\n-//! introspection. Other times no detection is performed at all and we just\n-//! provide a fallback implementation as some versions of Android we support\n-//! don't have the function.\n-//!\n-//! You'll find more details below about why each compatibility shim is needed.\n-\n-#![cfg(target_os = \"android\")]\n-\n-use libc::{c_int, c_void, sighandler_t, size_t, ssize_t};\n-use libc::{ftruncate, pread, pwrite};\n-\n-use crate::io;\n-use super::{cvt, cvt_r};\n-\n-// The `log2` and `log2f` functions apparently appeared in android-18, or at\n-// least you can see they're not present in the android-17 header [1] and they\n-// are present in android-18 [2].\n-//\n-// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n-//                                       /android-17/arch-arm/usr/include/math.h\n-// [2]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n-//                                       /android-18/arch-arm/usr/include/math.h\n-//\n-// Note that these shims are likely less precise than directly calling `log2`,\n-// but hopefully that should be enough for now...\n-//\n-// Note that mathematically, for any arbitrary `y`:\n-//\n-//      log_2(x) = log_y(x) / log_y(2)\n-//               = log_y(x) / (1 / log_2(y))\n-//               = log_y(x) * log_2(y)\n-//\n-// Hence because `ln` (log_e) is available on all Android we just choose `y = e`\n-// and get:\n-//\n-//      log_2(x) = ln(x) * log_2(e)\n-\n-#[cfg(not(test))]\n-pub fn log2f32(f: f32) -> f32 {\n-    f.ln() * crate::f32::consts::LOG2_E\n-}\n-\n-#[cfg(not(test))]\n-pub fn log2f64(f: f64) -> f64 {\n-    f.ln() * crate::f64::consts::LOG2_E\n-}\n-\n-// Back in the day [1] the `signal` function was just an inline wrapper\n-// around `bsd_signal`, but starting in API level android-20 the `signal`\n-// symbols was introduced [2]. Finally, in android-21 the API `bsd_signal` was\n-// removed [3].\n-//\n-// Basically this means that if we want to be binary compatible with multiple\n-// Android releases (oldest being 9 and newest being 21) then we need to check\n-// for both symbols and not actually link against either.\n-//\n-// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n-//                                       /android-18/arch-arm/usr/include/signal.h\n-// [2]: https://chromium.googlesource.com/android_tools/+/fbd420/ndk_experimental\n-//                                       /platforms/android-20/arch-arm\n-//                                       /usr/include/signal.h\n-// [3]: https://chromium.googlesource.com/android_tools/+/20ee6d/ndk/platforms\n-//                                       /android-21/arch-arm/usr/include/signal.h\n-pub unsafe fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t {\n-    weak!(fn signal(c_int, sighandler_t) -> sighandler_t);\n-    weak!(fn bsd_signal(c_int, sighandler_t) -> sighandler_t);\n-\n-    let f = signal.get().or_else(|| bsd_signal.get());\n-    let f = f.expect(\"neither `signal` nor `bsd_signal` symbols found\");\n-    f(signum, handler)\n-}\n-\n-// The `ftruncate64` symbol apparently appeared in android-12, so we do some\n-// dynamic detection to see if we can figure out whether `ftruncate64` exists.\n-//\n-// If it doesn't we just fall back to `ftruncate`, generating an error for\n-// too-large values.\n-#[cfg(target_pointer_width = \"32\")]\n-pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n-    weak!(fn ftruncate64(c_int, i64) -> c_int);\n-\n-    unsafe {\n-        match ftruncate64.get() {\n-            Some(f) => cvt_r(|| f(fd, size as i64)).map(|_| ()),\n-            None => {\n-                if size > i32::max_value() as u64 {\n-                    Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                       \"cannot truncate >2GB\"))\n-                } else {\n-                    cvt_r(|| ftruncate(fd, size as i32)).map(|_| ())\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n-    unsafe {\n-        cvt_r(|| ftruncate(fd, size as i64)).map(|_| ())\n-    }\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-pub unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n-    use crate::convert::TryInto;\n-    weak!(fn pread64(c_int, *mut c_void, size_t, i64) -> ssize_t);\n-    pread64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n-        if let Ok(o) = offset.try_into() {\n-            cvt(pread(fd, buf, count, o))\n-        } else {\n-            Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                               \"cannot pread >2GB\"))\n-        }\n-    })\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-pub unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n-    use crate::convert::TryInto;\n-    weak!(fn pwrite64(c_int, *const c_void, size_t, i64) -> ssize_t);\n-    pwrite64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n-        if let Ok(o) = offset.try_into() {\n-            cvt(pwrite(fd, buf, count, o))\n-        } else {\n-            Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                               \"cannot pwrite >2GB\"))\n-        }\n-    })\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-pub unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n-    cvt(pread(fd, buf, count, offset))\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-pub unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n-    cvt(pwrite(fd, buf, count, offset))\n-}"}, {"sha": "783c3eb7c766f3b49537df462992c724fd24f18a", "filename": "src/libstd/sys/vxworks/condvar.rs", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs?ref=279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "patch": "@@ -62,10 +62,6 @@ impl Condvar {\n     // where we configure condition variable to use monotonic clock (instead of\n     // default system clock). This approach avoids all problems that result\n     // from changes made to the system time.\n-    #[cfg(not(any(target_os = \"macos\",\n-                  target_os = \"ios\",\n-                  target_os = \"android\",\n-                  target_os = \"hermit\")))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         use crate::mem;\n \n@@ -92,78 +88,9 @@ impl Condvar {\n     }\n \n \n-    // This implementation is modeled after libcxx's condition_variable\n-    // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n-    // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\", target_os = \"hermit\"))]\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n-        use crate::ptr;\n-        use crate::time::Instant;\n-\n-        // 1000 years\n-        let max_dur = Duration::from_secs(1000 * 365 * 86400);\n-\n-        if dur > max_dur {\n-            // OSX implementation of `pthread_cond_timedwait` is buggy\n-            // with super long durations. When duration is greater than\n-            // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n-            // in macOS Sierra return error 316.\n-            //\n-            // This program demonstrates the issue:\n-            // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n-            //\n-            // To work around this issue, and possible bugs of other OSes, timeout\n-            // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n-            // because of spurious wakeups.\n-\n-            dur = max_dur;\n-        }\n-\n-        // First, figure out what time it currently is, in both system and\n-        // stable time.  pthread_cond_timedwait uses system time, but we want to\n-        // report timeout based on stable time.\n-        let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n-        let stable_now = Instant::now();\n-        let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n-        debug_assert_eq!(r, 0);\n-\n-        let nsec = dur.subsec_nanos() as libc::c_long +\n-                   (sys_now.tv_usec * 1000) as libc::c_long;\n-        let extra = (nsec / 1_000_000_000) as libc::time_t;\n-        let nsec = nsec % 1_000_000_000;\n-        let seconds = saturating_cast_to_time_t(dur.as_secs());\n-\n-        let timeout = sys_now.tv_sec.checked_add(extra).and_then(|s| {\n-            s.checked_add(seconds)\n-        }).map(|s| {\n-            libc::timespec { tv_sec: s, tv_nsec: nsec }\n-        }).unwrap_or(TIMESPEC_MAX);\n-\n-        // And wait!\n-        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n-                                            &timeout);\n-        debug_assert!(r == libc::ETIMEDOUT || r == 0);\n-\n-        // ETIMEDOUT is not a totally reliable method of determining timeout due\n-        // to clock shifts, so do the check ourselves\n-        stable_now.elapsed() < dur\n-    }\n-\n     #[inline]\n-    #[cfg(not(target_os = \"dragonfly\"))]\n     pub unsafe fn destroy(&self) {\n         let r = libc::pthread_cond_destroy(self.inner.get());\n         debug_assert_eq!(r, 0);\n     }\n-\n-    #[inline]\n-    #[cfg(target_os = \"dragonfly\")]\n-    pub unsafe fn destroy(&self) {\n-        let r = libc::pthread_cond_destroy(self.inner.get());\n-        // On DragonFly pthread_cond_destroy() returns EINVAL if called on\n-        // a condvar that was just initialized with\n-        // libc::PTHREAD_COND_INITIALIZER. Once it is used or\n-        // pthread_cond_init() is called, this behaviour no longer occurs.\n-        debug_assert!(r == 0 || r == libc::EINVAL);\n-    }\n }"}, {"sha": "3f0a7e9e843199d9999bab826edce6e00a2da9a1", "filename": "src/libstd/sys/vxworks/ext/net.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs?ref=279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "patch": "@@ -5,16 +5,6 @@\n #[cfg(unix)]\n use libc;\n \n-// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n-#[cfg(not(unix))]\n-mod libc {\n-    pub use libc::c_int;\n-    pub type socklen_t = u32;\n-    pub struct sockaddr;\n-    #[derive(Clone)]\n-    pub struct sockaddr_un;\n-}\n-\n use crate::ascii;\n use crate::ffi::OsStr;\n use crate::fmt;\n@@ -29,15 +19,6 @@ use crate::sys::{self, cvt};\n use crate::sys::net::Socket;\n use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n \n-#[cfg(any(target_os = \"linux\", target_os = \"android\",\n-          target_os = \"dragonfly\", target_os = \"freebsd\",\n-          target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"haiku\"))]\n-use libc::MSG_NOSIGNAL;\n-#[cfg(not(any(target_os = \"linux\", target_os = \"android\",\n-              target_os = \"dragonfly\", target_os = \"freebsd\",\n-              target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"haiku\")))]\n const MSG_NOSIGNAL: libc::c_int = 0x0;\n \n fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n@@ -202,13 +183,7 @@ impl SocketAddr {\n         let len = self.len as usize - sun_path_offset(&self.addr);\n         let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n \n-        // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses\n-        if len == 0\n-            || (cfg!(not(any(target_os = \"linux\", target_os = \"android\")))\n-                && self.addr.sun_path[0] == 0)\n-        {\n-            AddressKind::Unnamed\n-        } else if self.addr.sun_path[0] == 0 {\n+        if self.addr.sun_path[0] == 0 {\n             AddressKind::Abstract(&path[1..len])\n         } else {\n             AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())"}, {"sha": "b3dd1cf6aaac7b8620ba75c26155810e1929adf7", "filename": "src/libstd/sys/vxworks/l4re.rs", "status": "removed", "additions": 0, "deletions": 469, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/273f42b5964c29dda2c5a349dd4655529767b07f/src%2Flibstd%2Fsys%2Fvxworks%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273f42b5964c29dda2c5a349dd4655529767b07f/src%2Flibstd%2Fsys%2Fvxworks%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fl4re.rs?ref=273f42b5964c29dda2c5a349dd4655529767b07f", "patch": "@@ -1,469 +0,0 @@\n-macro_rules! unimpl {\n-    () => (return Err(io::Error::new(io::ErrorKind::Other, \"No networking available on L4Re.\"));)\n-}\n-\n-pub mod net {\n-    #![allow(warnings)]\n-    use crate::fmt;\n-    use crate::io::{self, IoVec, IoVecMut};\n-    use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n-    use crate::sys_common::{AsInner, FromInner, IntoInner};\n-    use crate::sys::fd::FileDesc;\n-    use crate::time::Duration;\n-    use crate::convert::TryFrom;\n-\n-    #[allow(unused_extern_crates)]\n-    pub extern crate libc as netc;\n-\n-    pub struct Socket(FileDesc);\n-    impl Socket {\n-        pub fn new(_: &SocketAddr, _: libc::c_int) -> io::Result<Socket> {\n-            unimpl!();\n-        }\n-\n-        pub fn new_raw(_: libc::c_int, _: libc::c_int) -> io::Result<Socket> {\n-            unimpl!();\n-        }\n-\n-        pub fn new_pair(_: libc::c_int, _: libc::c_int) -> io::Result<(Socket, Socket)> {\n-            unimpl!();\n-        }\n-\n-        pub fn connect_timeout(&self, _: &SocketAddr, _: Duration) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn accept(&self, _: *mut libc::sockaddr, _: *mut libc::socklen_t)\n-                  -> io::Result<Socket> {\n-            unimpl!();\n-        }\n-\n-        pub fn duplicate(&self) -> io::Result<Socket> {\n-            unimpl!();\n-        }\n-\n-        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-            unimpl!();\n-        }\n-\n-        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-            unimpl!();\n-        }\n-\n-        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_timeout(&self, _: Option<Duration>, _: libc::c_int) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn timeout(&self, _: libc::c_int) -> io::Result<Option<Duration>> {\n-            unimpl!();\n-        }\n-\n-        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn nodelay(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-            unimpl!();\n-        }\n-    }\n-\n-    impl AsInner<libc::c_int> for Socket {\n-        fn as_inner(&self) -> &libc::c_int { self.0.as_inner() }\n-    }\n-\n-    impl FromInner<libc::c_int> for Socket {\n-        fn from_inner(fd: libc::c_int) -> Socket { Socket(FileDesc::new(fd)) }\n-    }\n-\n-    impl IntoInner<libc::c_int> for Socket {\n-        fn into_inner(self) -> libc::c_int { self.0.into_raw() }\n-    }\n-\n-    pub struct TcpStream {\n-        inner: Socket,\n-    }\n-\n-    impl TcpStream {\n-        pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n-            unimpl!();\n-        }\n-\n-        pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n-            unimpl!();\n-        }\n-\n-        pub fn socket(&self) -> &Socket { &self.inner }\n-\n-        pub fn into_socket(self) -> Socket { self.inner }\n-\n-        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-            unimpl!();\n-        }\n-\n-        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-            unimpl!();\n-        }\n-\n-        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-            unimpl!();\n-        }\n-\n-        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-            unimpl!();\n-        }\n-\n-        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn duplicate(&self) -> io::Result<TcpStream> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn nodelay(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn ttl(&self) -> io::Result<u32> {\n-            unimpl!();\n-        }\n-\n-        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-    }\n-\n-    impl FromInner<Socket> for TcpStream {\n-        fn from_inner(socket: Socket) -> TcpStream {\n-            TcpStream { inner: socket }\n-        }\n-    }\n-\n-    impl fmt::Debug for TcpStream {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            write!(f, \"No networking support available on L4Re\")\n-        }\n-    }\n-\n-    pub struct TcpListener {\n-        inner: Socket,\n-    }\n-\n-    impl TcpListener {\n-        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n-            unimpl!();\n-        }\n-\n-        pub fn socket(&self) -> &Socket { &self.inner }\n-\n-        pub fn into_socket(self) -> Socket { self.inner }\n-\n-        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-            unimpl!();\n-        }\n-\n-        pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n-            unimpl!();\n-        }\n-\n-        pub fn duplicate(&self) -> io::Result<TcpListener> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn ttl(&self) -> io::Result<u32> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn only_v6(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-    }\n-\n-    impl FromInner<Socket> for TcpListener {\n-        fn from_inner(socket: Socket) -> TcpListener {\n-            TcpListener { inner: socket }\n-        }\n-    }\n-\n-    impl fmt::Debug for TcpListener {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            write!(f, \"No networking support available on L4Re.\")\n-        }\n-    }\n-\n-    pub struct UdpSocket {\n-        inner: Socket,\n-    }\n-\n-    impl UdpSocket {\n-        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n-            unimpl!();\n-        }\n-\n-        pub fn socket(&self) -> &Socket { &self.inner }\n-\n-        pub fn into_socket(self) -> Socket { self.inner }\n-\n-        pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-            unimpl!();\n-        }\n-\n-        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-            unimpl!();\n-        }\n-\n-        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-            unimpl!();\n-        }\n-\n-        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-            unimpl!();\n-        }\n-\n-        pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn duplicate(&self) -> io::Result<UdpSocket> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-            unimpl!();\n-        }\n-\n-        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn broadcast(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n-            unimpl!();\n-        }\n-\n-        pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                             -> io::Result<()> {\n-                                 unimpl!();\n-        }\n-\n-        pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                             -> io::Result<()> {\n-                                 unimpl!();\n-        }\n-\n-        pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                              -> io::Result<()> {\n-                                  unimpl!();\n-        }\n-\n-        pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                              -> io::Result<()> {\n-                                  unimpl!();\n-        }\n-\n-        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn ttl(&self) -> io::Result<u32> {\n-            unimpl!();\n-        }\n-\n-        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-            unimpl!();\n-        }\n-\n-        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-            unimpl!();\n-        }\n-\n-        pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n-            unimpl!();\n-        }\n-\n-        pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n-            unimpl!();\n-        }\n-    }\n-\n-    impl FromInner<Socket> for UdpSocket {\n-        fn from_inner(socket: Socket) -> UdpSocket {\n-            UdpSocket { inner: socket }\n-        }\n-    }\n-\n-    impl fmt::Debug for UdpSocket {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            write!(f, \"No networking support on L4Re available.\")\n-        }\n-    }\n-\n-    pub struct LookupHost {\n-        original: *mut libc::addrinfo,\n-        cur: *mut libc::addrinfo,\n-    }\n-\n-    impl Iterator for LookupHost {\n-        type Item = SocketAddr;\n-        fn next(&mut self) -> Option<SocketAddr> {\n-            None\n-        }\n-    }\n-\n-    impl LookupHost {\n-        pub fn port(&self) -> u16 {\n-            unimpl!();\n-        }\n-    }\n-\n-    unsafe impl Sync for LookupHost {}\n-    unsafe impl Send for LookupHost {}\n-\n-\n-    impl TryFrom<&str> for LookupHost {\n-        type Error = io::Error;\n-\n-        fn try_from(_v: &str) -> io::Result<LookupHost> {\n-            unimpl!();\n-        }\n-    }\n-\n-    impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n-        type Error = io::Error;\n-\n-        fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n-            unimpl!();\n-        }\n-    }\n-}"}, {"sha": "b5b4e6d9c134ee2f5e22329535efb9f2c41993ad", "filename": "src/libstd/sys/vxworks/memchr.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs?ref=279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "patch": "@@ -16,25 +16,6 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n }\n \n pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n-\n-    #[cfg(target_os = \"linux\")]\n-    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n-        if haystack.is_empty() {return None}\n-        let p = unsafe {\n-            libc::memrchr(\n-                haystack.as_ptr() as *const libc::c_void,\n-                needle as libc::c_int,\n-                haystack.len())\n-        };\n-        if p.is_null() {\n-            None\n-        } else {\n-            Some(p as usize - (haystack.as_ptr() as usize))\n-        }\n-    }\n-\n-    #[cfg(not(target_os = \"linux\"))]\n     fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n         core::slice::memchr::memrchr(needle, haystack)\n     }"}, {"sha": "1eff4fbcd83b76f6fc73b32d145808ece1389f23", "filename": "src/libstd/sys/vxworks/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs?ref=279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "patch": "@@ -7,14 +7,8 @@ pub use crate::os::vxworks as platform;\n pub use self::rand::hashmap_random_keys;\n pub use libc::strlen;\n \n-#[macro_use]\n-pub mod weak;\n-\n pub mod alloc;\n pub mod args;\n-pub mod android;\n-//#[cfg(feature = \"backtrace\")]\n-//pub mod backtrace;\n pub mod cmath;\n pub mod condvar;\n pub mod env;\n@@ -25,12 +19,7 @@ pub mod fs;\n pub mod memchr;\n pub mod io;\n pub mod mutex;\n-#[cfg(not(target_os = \"l4re\"))]\n pub mod net;\n-#[cfg(target_os = \"l4re\")]\n-mod l4re;\n-#[cfg(target_os = \"l4re\")]\n-pub use self::l4re::net;\n pub mod os;\n pub mod path;\n pub mod pipe;\n@@ -61,9 +50,6 @@ pub fn init() {\n     unsafe fn reset_sigpipe() { }\n }\n \n-#[cfg(target_os = \"android\")]\n-pub use crate::sys::android::signal;\n-#[cfg(not(target_os = \"android\"))]\n pub use libc::signal;\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {"}, {"sha": "aa6b93c86006933e65dfbd01ce618b64a34df707", "filename": "src/libstd/sys/vxworks/net.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs?ref=279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "patch": "@@ -58,19 +58,6 @@ impl Socket {\n \n     pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n         unsafe {\n-            // On linux we first attempt to pass the SOCK_CLOEXEC flag to\n-            // atomically create the socket and set it as CLOEXEC. Support for\n-            // this option, however, was added in 2.6.27, and we still support\n-            // 2.6.18 as a kernel, so if the returned error is EINVAL we\n-            // fallthrough to the fallback.\n-            if cfg!(target_os = \"linux\") {\n-                match cvt(libc::socket(fam, ty | SOCK_CLOEXEC, 0)) {\n-                    Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n-                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n-                    Err(e) => return Err(e),\n-                }\n-            }\n-\n             let fd = cvt(libc::socket(fam, ty, 0))?;\n             let fd = FileDesc::new(fd);\n             fd.set_cloexec()?;"}, {"sha": "9fce5f5811f356bfd127e736cb68d5a3776017e7", "filename": "src/libstd/sys/vxworks/process/process_common.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "patch": "@@ -422,46 +422,12 @@ mod tests {\n         }\n     }\n \n-    // Android with api less than 21 define sig* functions inline, so it is not\n-    // available for dynamic link. Implementing sigemptyset and sigaddset allow us\n-    // to support older Android version (independent of libc version).\n-    // The following implementations are based on https://git.io/vSkNf\n-\n-    #[cfg(not(target_os = \"android\"))]\n     extern {\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigemptyset14\")]\n         fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int;\n-\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n         fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n     }\n \n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n-        libc::memset(set as *mut _, 0, mem::size_of::<libc::sigset_t>());\n-        return 0;\n-    }\n-\n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n-        use crate::slice;\n-\n-        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n-        let bit = (signum - 1) as usize;\n-        raw[bit / 8] |= 1 << (bit % 8);\n-        return 0;\n-    }\n-\n-    // See #14232 for more information, but it appears that signal delivery to a\n-    // newly spawned process may just be raced in the macOS, so to prevent this\n-    // test from being flaky we ignore it on macOS.\n     #[test]\n-    #[cfg_attr(target_os = \"macos\", ignore)]\n-    // When run under our current QEMU emulation test suite this test fails,\n-    // although the reason isn't very clear as to why. For now this test is\n-    // ignored there.\n-    #[cfg_attr(target_arch = \"arm\", ignore)]\n-    #[cfg_attr(target_arch = \"aarch64\", ignore)]\n     fn test_process_mask() {\n         unsafe {\n             // Test to make sure that a signal mask does not get inherited."}, {"sha": "08e7b310ca1b83ed753289b63bfa4568ddbe7c99", "filename": "src/libstd/sys/vxworks/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs?ref=279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "patch": "@@ -23,174 +23,6 @@ impl Drop for Handler {\n     }\n }\n \n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"macos\",\n-          target_os = \"bitrig\",\n-          target_os = \"dragonfly\",\n-          target_os = \"freebsd\",\n-          target_os = \"solaris\",\n-          all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-          target_os = \"openbsd\"))]\n-mod imp {\n-    use super::Handler;\n-    use crate::mem;\n-    use crate::ptr;\n-\n-    use libc::{sigaltstack, SIGSTKSZ, SS_DISABLE};\n-    use libc::{sigaction, SIGBUS, SIG_DFL,\n-               SA_SIGINFO, SA_ONSTACK, sighandler_t};\n-    use libc::{mmap, munmap};\n-    use libc::{SIGSEGV, PROT_READ, PROT_WRITE, MAP_PRIVATE, MAP_ANON};\n-    use libc::MAP_FAILED;\n-\n-    use crate::sys_common::thread_info;\n-\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n-        #[repr(C)]\n-        struct siginfo_t {\n-            a: [libc::c_int; 3], // si_signo, si_errno, si_code\n-            si_addr: *mut libc::c_void,\n-        }\n-\n-        (*(info as *const siginfo_t)).si_addr as usize\n-    }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n-        (*info).si_addr as usize\n-    }\n-\n-    // Signal handler for the SIGSEGV and SIGBUS handlers. We've got guard pages\n-    // (unmapped pages) at the end of every thread's stack, so if a thread ends\n-    // up running into the guard page it'll trigger this handler. We want to\n-    // detect these cases and print out a helpful error saying that the stack\n-    // has overflowed. All other signals, however, should go back to what they\n-    // were originally supposed to do.\n-    //\n-    // This handler currently exists purely to print an informative message\n-    // whenever a thread overflows its stack. We then abort to exit and\n-    // indicate a crash, but to avoid a misleading SIGSEGV that might lead\n-    // users to believe that unsafe code has accessed an invalid pointer; the\n-    // SIGSEGV encountered when overflowing the stack is expected and\n-    // well-defined.\n-    //\n-    // If this is not a stack overflow, the handler un-registers itself and\n-    // then returns (to allow the original signal to be delivered again).\n-    // Returning from this kind of signal handler is technically not defined\n-    // to work when reading the POSIX spec strictly, but in practice it turns\n-    // out many large systems and all implementations allow returning from a\n-    // signal handler to work. For a more detailed explanation see the\n-    // comments on #26458.\n-    unsafe extern fn signal_handler(signum: libc::c_int,\n-                                    info: *mut libc::siginfo_t,\n-                                    _data: *mut libc::c_void) {\n-        use crate::sys_common::util::report_overflow;\n-\n-        let guard = thread_info::stack_guard().unwrap_or(0..0);\n-        let addr = siginfo_si_addr(info);\n-\n-        // If the faulting address is within the guard page, then we print a\n-        // message saying so and abort.\n-        if guard.start <= addr && addr < guard.end {\n-            report_overflow();\n-            rtabort!(\"stack overflow\");\n-        } else {\n-            // Unregister ourselves by reverting back to the default behavior.\n-            let mut action: sigaction = mem::zeroed();\n-            action.sa_sigaction = SIG_DFL;\n-            sigaction(signum, &action, ptr::null_mut());\n-\n-            // See comment above for why this function returns.\n-        }\n-    }\n-\n-    static mut MAIN_ALTSTACK: *mut libc::c_void = ptr::null_mut();\n-\n-    pub unsafe fn init() {\n-        let mut action: sigaction = mem::zeroed();\n-        action.sa_flags = SA_SIGINFO | SA_ONSTACK;\n-        action.sa_sigaction = signal_handler as sighandler_t;\n-        sigaction(SIGSEGV, &action, ptr::null_mut());\n-        sigaction(SIGBUS, &action, ptr::null_mut());\n-\n-        let handler = make_handler();\n-        MAIN_ALTSTACK = handler._data;\n-        mem::forget(handler);\n-    }\n-\n-    pub unsafe fn cleanup() {\n-        Handler { _data: MAIN_ALTSTACK };\n-    }\n-\n-    unsafe fn get_stackp() -> *mut libc::c_void {\n-        let stackp = mmap(ptr::null_mut(),\n-                          SIGSTKSZ,\n-                          PROT_READ | PROT_WRITE,\n-                          MAP_PRIVATE | MAP_ANON,\n-                          -1,\n-                          0);\n-        if stackp == MAP_FAILED {\n-            panic!(\"failed to allocate an alternative stack\");\n-        }\n-        stackp\n-    }\n-\n-    #[cfg(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"bitrig\",\n-              target_os = \"freebsd\",\n-              target_os = \"netbsd\",\n-              target_os = \"openbsd\",\n-              target_os = \"solaris\"))]\n-    unsafe fn get_stack() -> libc::stack_t {\n-        libc::stack_t { ss_sp: get_stackp(), ss_flags: 0, ss_size: SIGSTKSZ }\n-    }\n-\n-    #[cfg(target_os = \"dragonfly\")]\n-    unsafe fn get_stack() -> libc::stack_t {\n-        libc::stack_t { ss_sp: get_stackp() as *mut i8, ss_flags: 0, ss_size: SIGSTKSZ }\n-    }\n-\n-    pub unsafe fn make_handler() -> Handler {\n-        let mut stack = mem::zeroed();\n-        sigaltstack(ptr::null(), &mut stack);\n-        // Configure alternate signal stack, if one is not already set.\n-        if stack.ss_flags & SS_DISABLE != 0 {\n-            stack = get_stack();\n-            sigaltstack(&stack, ptr::null_mut());\n-            Handler { _data: stack.ss_sp as *mut libc::c_void }\n-        } else {\n-            Handler { _data: ptr::null_mut() }\n-        }\n-    }\n-\n-    pub unsafe fn drop_handler(handler: &mut Handler) {\n-        if !handler._data.is_null() {\n-            let stack =  libc::stack_t {\n-                ss_sp: ptr::null_mut(),\n-                ss_flags: SS_DISABLE,\n-                // Workaround for bug in macOS implementation of sigaltstack\n-                // UNIX2003 which returns ENOMEM when disabling a stack while\n-                // passing ss_size smaller than MINSIGSTKSZ. According to POSIX\n-                // both ss_sp and ss_size should be ignored in this case.\n-                ss_size: SIGSTKSZ,\n-            };\n-            sigaltstack(&stack, ptr::null_mut());\n-            munmap(handler._data, SIGSTKSZ);\n-        }\n-    }\n-}\n-\n-#[cfg(not(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"bitrig\",\n-              target_os = \"dragonfly\",\n-              target_os = \"freebsd\",\n-              target_os = \"solaris\",\n-              all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-              target_os = \"openbsd\")))]\n mod imp {\n     use crate::ptr;\n "}, {"sha": "58af8cbe48e3626522f633cc02a56ad740739126", "filename": "src/libstd/sys/vxworks/thread.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279c399599357cdb40d2bbe24a769d2d1dd4a9d9/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs?ref=279c399599357cdb40d2bbe24a769d2d1dd4a9d9", "patch": "@@ -1,4 +1,3 @@\n-//use crate::boxed::FnBox;\n use crate::cmp;\n use crate::ffi::CStr;\n use crate::io;\n@@ -9,10 +8,7 @@ use crate::time::Duration;\n \n use crate::sys_common::thread::*;\n \n-#[cfg(not(target_os = \"l4re\"))]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n-#[cfg(target_os = \"l4re\")]\n-pub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;\n \n pub struct Thread {\n     id: libc::pthread_t,\n@@ -25,18 +21,11 @@ unsafe impl Sync for Thread {}\n \n // The pthread_attr_setstacksize symbol doesn't exist in the emscripten libc,\n // so we have to not link to it to satisfy emcc's ERROR_ON_UNDEFINED_SYMBOLS.\n-#[cfg(not(target_os = \"emscripten\"))]\n unsafe fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n                                     stack_size: libc::size_t) -> libc::c_int {\n     libc::pthread_attr_setstacksize(attr, stack_size)\n }\n \n-#[cfg(target_os = \"emscripten\")]\n-unsafe fn pthread_attr_setstacksize(_attr: *mut libc::pthread_attr_t,\n-                                    _stack_size: libc::size_t) -> libc::c_int {\n-    panic!()\n-}\n-\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n@@ -149,31 +138,6 @@ pub mod guard {\n     pub unsafe fn deinit() {}\n }\n \n-// glibc >= 2.15 has a __pthread_get_minstack() function that returns\n-// PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n-// storage.  We need that information to avoid blowing up when a small stack\n-// is created in an application with big thread-local storage requirements.\n-// See #6233 for rationale and details.\n-#[cfg(target_os = \"linux\")]\n-#[allow(deprecated)]\n-fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n-    weak!(fn __pthread_get_minstack(*const libc::pthread_attr_t) -> libc::size_t);\n-\n-    match __pthread_get_minstack.get() {\n-        None => libc::PTHREAD_STACK_MIN,\n-        Some(f) => unsafe { f(attr) },\n-    }\n-}\n-\n-// No point in looking up __pthread_get_minstack() on non-glibc\n-// platforms.\n-#[cfg(all(not(target_os = \"linux\"),\n-          not(target_os = \"netbsd\")))]\n fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n     libc::PTHREAD_STACK_MIN\n }\n-\n-#[cfg(target_os = \"netbsd\")]\n-fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n-    2048 // just a guess\n-}"}]}