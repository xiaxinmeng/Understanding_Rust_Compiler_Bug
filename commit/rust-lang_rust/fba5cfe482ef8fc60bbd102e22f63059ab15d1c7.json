{"sha": "fba5cfe482ef8fc60bbd102e22f63059ab15d1c7", "node_id": "C_kwDOAAsO6NoAKGZiYTVjZmU0ODJlZjhmYzYwYmJkMTAyZTIyZjYzMDU5YWIxNWQxYzc", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-04-26T19:02:29Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-04-26T19:02:29Z"}, "message": "Restructure and rename thread local things in std.", "tree": {"sha": "531ec06be92d675cd628ffd27a06e6d9692e72c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/531ec06be92d675cd628ffd27a06e6d9692e72c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7", "html_url": "https://github.com/rust-lang/rust/commit/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8763965a2c7b68a33af5fc55999f9eff26749fd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8763965a2c7b68a33af5fc55999f9eff26749fd6", "html_url": "https://github.com/rust-lang/rust/commit/8763965a2c7b68a33af5fc55999f9eff26749fd6"}], "stats": {"total": 594, "additions": 283, "deletions": 311}, "files": [{"sha": "914e017f7ffaf3a9e00dc6aa17ab862771f7d0fd", "filename": "library/std/src/sys/common/thread_local/fast_local.rs", "status": "modified", "additions": 124, "deletions": 131, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs?ref=fba5cfe482ef8fc60bbd102e22f63059ab15d1c7", "patch": "@@ -1,13 +1,14 @@\n+use super::lazy::LazyKeyInner;\n+use crate::cell::Cell;\n+use crate::sys::thread_local_dtor::register_dtor;\n+use crate::{fmt, mem, panic};\n+\n #[doc(hidden)]\n-#[macro_export]\n-#[allow_internal_unstable(\n-    thread_local_internals,\n-    cfg_target_thread_local,\n-    thread_local,\n-    libstd_thread_internals\n-)]\n+#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n #[allow_internal_unsafe]\n-macro_rules! __thread_local_inner {\n+#[unstable(feature = \"thread_local_internals\", issue = \"none\")]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro thread_local_inner {\n     // used to generate the `LocalKey` value for const-initialized thread locals\n     (@key $t:ty, const $init:expr) => {{\n         #[cfg_attr(not(bootstrap), inline)]\n@@ -49,7 +50,7 @@ macro_rules! __thread_local_inner {\n                     // 0 == we haven't registered a destructor, so do\n                     //   so now.\n                     0 => {\n-                        $crate::thread::__LocalKeyInner::<$t>::register_dtor(\n+                        $crate::thread::local_impl::Key::<$t>::register_dtor(\n                             $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,\n                             destroy,\n                         );\n@@ -69,7 +70,7 @@ macro_rules! __thread_local_inner {\n         unsafe {\n             $crate::thread::LocalKey::new(__getit)\n         }\n-    }};\n+    }},\n \n     // used to generate the `LocalKey` value for `thread_local!`\n     (@key $t:ty, $init:expr) => {\n@@ -82,8 +83,8 @@ macro_rules! __thread_local_inner {\n                 init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n             ) -> $crate::option::Option<&'static $t> {\n                 #[thread_local]\n-                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n-                    $crate::thread::__LocalKeyInner::<$t>::new();\n+                static __KEY: $crate::thread::local_impl::Key<$t> =\n+                    $crate::thread::local_impl::Key::<$t>::new();\n \n                 // FIXME: remove the #[allow(...)] marker when macros don't\n                 // raise warning for missing/extraneous unsafe blocks anymore.\n@@ -107,148 +108,140 @@ macro_rules! __thread_local_inner {\n                 $crate::thread::LocalKey::new(__getit)\n             }\n         }\n-    };\n+    },\n     ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n         $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n-            $crate::__thread_local_inner!(@key $t, $($init)*);\n-    }\n+            $crate::thread::local_impl::thread_local_inner!(@key $t, $($init)*);\n+    },\n }\n \n-#[doc(hidden)]\n-pub mod fast {\n-    use super::super::lazy::LazyKeyInner;\n-    use crate::cell::Cell;\n-    use crate::sys::thread_local_dtor::register_dtor;\n-    use crate::{fmt, mem, panic};\n-\n-    #[derive(Copy, Clone)]\n-    enum DtorState {\n-        Unregistered,\n-        Registered,\n-        RunningOrHasRun,\n-    }\n+#[derive(Copy, Clone)]\n+enum DtorState {\n+    Unregistered,\n+    Registered,\n+    RunningOrHasRun,\n+}\n \n-    // This data structure has been carefully constructed so that the fast path\n-    // only contains one branch on x86. That optimization is necessary to avoid\n-    // duplicated tls lookups on OSX.\n+// This data structure has been carefully constructed so that the fast path\n+// only contains one branch on x86. That optimization is necessary to avoid\n+// duplicated tls lookups on OSX.\n+//\n+// LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n+pub struct Key<T> {\n+    // If `LazyKeyInner::get` returns `None`, that indicates either:\n+    //   * The value has never been initialized\n+    //   * The value is being recursively initialized\n+    //   * The value has already been destroyed or is being destroyed\n+    // To determine which kind of `None`, check `dtor_state`.\n     //\n-    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n-    pub struct Key<T> {\n-        // If `LazyKeyInner::get` returns `None`, that indicates either:\n-        //   * The value has never been initialized\n-        //   * The value is being recursively initialized\n-        //   * The value has already been destroyed or is being destroyed\n-        // To determine which kind of `None`, check `dtor_state`.\n-        //\n-        // This is very optimizer friendly for the fast path - initialized but\n-        // not yet dropped.\n-        inner: LazyKeyInner<T>,\n+    // This is very optimizer friendly for the fast path - initialized but\n+    // not yet dropped.\n+    inner: LazyKeyInner<T>,\n \n-        // Metadata to keep track of the state of the destructor. Remember that\n-        // this variable is thread-local, not global.\n-        dtor_state: Cell<DtorState>,\n-    }\n+    // Metadata to keep track of the state of the destructor. Remember that\n+    // this variable is thread-local, not global.\n+    dtor_state: Cell<DtorState>,\n+}\n \n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n+impl<T> fmt::Debug for Key<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Key\").finish_non_exhaustive()\n     }\n+}\n \n-    impl<T> Key<T> {\n-        pub const fn new() -> Key<T> {\n-            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n-        }\n+impl<T> Key<T> {\n+    pub const fn new() -> Key<T> {\n+        Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n+    }\n \n-        // note that this is just a publicly-callable function only for the\n-        // const-initialized form of thread locals, basically a way to call the\n-        // free `register_dtor` function defined elsewhere in std.\n-        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n-            unsafe {\n-                register_dtor(a, dtor);\n-            }\n+    // note that this is just a publicly-callable function only for the\n+    // const-initialized form of thread locals, basically a way to call the\n+    // free `register_dtor` function defined elsewhere in std.\n+    pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n+        unsafe {\n+            register_dtor(a, dtor);\n         }\n+    }\n \n-        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n-            // SAFETY: See the definitions of `LazyKeyInner::get` and\n-            // `try_initialize` for more information.\n-            //\n-            // The caller must ensure no mutable references are ever active to\n-            // the inner cell or the inner T when this is called.\n-            // The `try_initialize` is dependant on the passed `init` function\n-            // for this.\n-            unsafe {\n-                match self.inner.get() {\n-                    Some(val) => Some(val),\n-                    None => self.try_initialize(init),\n-                }\n+    pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+        // SAFETY: See the definitions of `LazyKeyInner::get` and\n+        // `try_initialize` for more information.\n+        //\n+        // The caller must ensure no mutable references are ever active to\n+        // the inner cell or the inner T when this is called.\n+        // The `try_initialize` is dependant on the passed `init` function\n+        // for this.\n+        unsafe {\n+            match self.inner.get() {\n+                Some(val) => Some(val),\n+                None => self.try_initialize(init),\n             }\n         }\n+    }\n \n-        // `try_initialize` is only called once per fast thread local variable,\n-        // except in corner cases where thread_local dtors reference other\n-        // thread_local's, or it is being recursively initialized.\n-        //\n-        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n-        // be performed for every call to `Key::get`.\n-        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n-        #[inline(never)]\n-        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+    // `try_initialize` is only called once per fast thread local variable,\n+    // except in corner cases where thread_local dtors reference other\n+    // thread_local's, or it is being recursively initialized.\n+    //\n+    // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n+    // be performed for every call to `Key::get`.\n+    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n+    #[inline(never)]\n+    unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+        // SAFETY: See comment above (this function doc).\n+        if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n             // SAFETY: See comment above (this function doc).\n-            if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n-                // SAFETY: See comment above (this function doc).\n-                Some(unsafe { self.inner.initialize(init) })\n-            } else {\n-                None\n-            }\n+            Some(unsafe { self.inner.initialize(init) })\n+        } else {\n+            None\n         }\n+    }\n \n-        // `try_register_dtor` is only called once per fast thread local\n-        // variable, except in corner cases where thread_local dtors reference\n-        // other thread_local's, or it is being recursively initialized.\n-        unsafe fn try_register_dtor(&self) -> bool {\n-            match self.dtor_state.get() {\n-                DtorState::Unregistered => {\n-                    // SAFETY: dtor registration happens before initialization.\n-                    // Passing `self` as a pointer while using `destroy_value<T>`\n-                    // is safe because the function will build a pointer to a\n-                    // Key<T>, which is the type of self and so find the correct\n-                    // size.\n-                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n-                    self.dtor_state.set(DtorState::Registered);\n-                    true\n-                }\n-                DtorState::Registered => {\n-                    // recursively initialized\n-                    true\n-                }\n-                DtorState::RunningOrHasRun => false,\n+    // `try_register_dtor` is only called once per fast thread local\n+    // variable, except in corner cases where thread_local dtors reference\n+    // other thread_local's, or it is being recursively initialized.\n+    unsafe fn try_register_dtor(&self) -> bool {\n+        match self.dtor_state.get() {\n+            DtorState::Unregistered => {\n+                // SAFETY: dtor registration happens before initialization.\n+                // Passing `self` as a pointer while using `destroy_value<T>`\n+                // is safe because the function will build a pointer to a\n+                // Key<T>, which is the type of self and so find the correct\n+                // size.\n+                unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n+                self.dtor_state.set(DtorState::Registered);\n+                true\n             }\n+            DtorState::Registered => {\n+                // recursively initialized\n+                true\n+            }\n+            DtorState::RunningOrHasRun => false,\n         }\n     }\n+}\n \n-    unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n-        let ptr = ptr as *mut Key<T>;\n+unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n+    let ptr = ptr as *mut Key<T>;\n \n-        // SAFETY:\n-        //\n-        // The pointer `ptr` has been built just above and comes from\n-        // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n-        // making it non-NUL and of the correct type.\n-        //\n-        // Right before we run the user destructor be sure to set the\n-        // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n-        // causes future calls to `get` to run `try_initialize_drop` again,\n-        // which will now fail, and return `None`.\n-        //\n-        // Wrap the call in a catch to ensure unwinding is caught in the event\n-        // a panic takes place in a destructor.\n-        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| unsafe {\n-            let value = (*ptr).inner.take();\n-            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n-            drop(value);\n-        })) {\n-            rtabort!(\"thread local panicked on drop\");\n-        }\n+    // SAFETY:\n+    //\n+    // The pointer `ptr` has been built just above and comes from\n+    // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n+    // making it non-NUL and of the correct type.\n+    //\n+    // Right before we run the user destructor be sure to set the\n+    // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n+    // causes future calls to `get` to run `try_initialize_drop` again,\n+    // which will now fail, and return `None`.\n+    //\n+    // Wrap the call in a catch to ensure unwinding is caught in the event\n+    // a panic takes place in a destructor.\n+    if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| unsafe {\n+        let value = (*ptr).inner.take();\n+        (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n+        drop(value);\n+    })) {\n+        rtabort!(\"thread local panicked on drop\");\n     }\n }"}, {"sha": "a7528c06c9de2d1f562d0e6c13c1564bafeb3e6a", "filename": "library/std/src/sys/common/thread_local/mod.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs?ref=fba5cfe482ef8fc60bbd102e22f63059ab15d1c7", "patch": "@@ -1,35 +1,24 @@\n-//! The following module declarations are outside cfg_if because the internal\n-//! `__thread_local_internal` macro does not seem to be exported properly when using cfg_if\n #![unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n \n-#[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))]\n-mod fast_local;\n-#[cfg(all(\n-    not(target_thread_local),\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))\n-))]\n-mod os_local;\n-#[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-mod static_local;\n-\n-#[cfg(not(test))]\n cfg_if::cfg_if! {\n     if #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))] {\n         #[doc(hidden)]\n-        pub use static_local::statik::Key;\n-    } else if #[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))] {\n+        mod static_local;\n+        #[doc(hidden)]\n+        pub use static_local::{Key, thread_local_inner};\n+    } else if #[cfg(all(target_thread_local))] {\n+        #[doc(hidden)]\n+        mod fast_local;\n         #[doc(hidden)]\n-        pub use fast_local::fast::Key;\n-    } else if #[cfg(all(not(target_thread_local), not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))] {\n+        pub use fast_local::{Key, thread_local_inner};\n+    } else {\n         #[doc(hidden)]\n-        pub use os_local::os::Key;\n+        mod os_local;\n+        #[doc(hidden)]\n+        pub use os_local::{Key, thread_local_inner};\n     }\n }\n \n-#[doc(hidden)]\n-#[cfg(test)]\n-pub use realstd::thread::__LocalKeyInner as Key;\n-\n mod lazy {\n     use crate::cell::UnsafeCell;\n     use crate::hint;"}, {"sha": "e9516f9983f2abed97efdb5fd888b59d8cb2e939", "filename": "library/std/src/sys/common/thread_local/os_local.rs", "status": "modified", "additions": 102, "deletions": 109, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs?ref=fba5cfe482ef8fc60bbd102e22f63059ab15d1c7", "patch": "@@ -1,13 +1,14 @@\n+use super::lazy::LazyKeyInner;\n+use crate::cell::Cell;\n+use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;\n+use crate::{fmt, marker, panic, ptr};\n+\n #[doc(hidden)]\n-#[macro_export]\n-#[allow_internal_unstable(\n-    thread_local_internals,\n-    cfg_target_thread_local,\n-    thread_local,\n-    libstd_thread_internals\n-)]\n+#[allow_internal_unstable(thread_local_internals)]\n #[allow_internal_unsafe]\n-macro_rules! __thread_local_inner {\n+#[unstable(feature = \"thread_local_internals\", issue = \"none\")]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro thread_local_inner {\n     // used to generate the `LocalKey` value for const-initialized thread locals\n     (@key $t:ty, const $init:expr) => {{\n         #[cfg_attr(not(bootstrap), inline)]\n@@ -21,8 +22,8 @@ macro_rules! __thread_local_inner {\n             // same implementation as below for os thread locals.\n             #[inline]\n             const fn __init() -> $t { INIT_EXPR }\n-            static __KEY: $crate::thread::__LocalKeyInner<$t> =\n-                $crate::thread::__LocalKeyInner::new();\n+            static __KEY: $crate::thread::local_impl::Key<$t> =\n+                $crate::thread::local_impl::Key::new();\n             #[allow(unused_unsafe)]\n             unsafe {\n                 __KEY.get(move || {\n@@ -41,7 +42,7 @@ macro_rules! __thread_local_inner {\n         unsafe {\n             $crate::thread::LocalKey::new(__getit)\n         }\n-    }};\n+    }},\n \n     // used to generate the `LocalKey` value for `thread_local!`\n     (@key $t:ty, $init:expr) => {\n@@ -55,8 +56,8 @@ macro_rules! __thread_local_inner {\n             unsafe fn __getit(\n                 init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n             ) -> $crate::option::Option<&'static $t> {\n-                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n-                    $crate::thread::__LocalKeyInner::new();\n+                static __KEY: $crate::thread::local_impl::Key<$t> =\n+                    $crate::thread::local_impl::Key::new();\n \n                 // FIXME: remove the #[allow(...)] marker when macros don't\n                 // raise warning for missing/extraneous unsafe blocks anymore.\n@@ -80,118 +81,110 @@ macro_rules! __thread_local_inner {\n                 $crate::thread::LocalKey::new(__getit)\n             }\n         }\n-    };\n+    },\n     ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n         $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n-            $crate::__thread_local_inner!(@key $t, $($init)*);\n-    }\n+            $crate::thread::local_impl::thread_local_inner!(@key $t, $($init)*);\n+    },\n }\n \n-#[doc(hidden)]\n-pub mod os {\n-    use super::super::lazy::LazyKeyInner;\n-    use crate::cell::Cell;\n-    use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;\n-    use crate::{fmt, marker, panic, ptr};\n-\n-    /// Use a regular global static to store this key; the state provided will then be\n-    /// thread-local.\n-    pub struct Key<T> {\n-        // OS-TLS key that we'll use to key off.\n-        os: OsStaticKey,\n-        marker: marker::PhantomData<Cell<T>>,\n-    }\n+/// Use a regular global static to store this key; the state provided will then be\n+/// thread-local.\n+pub struct Key<T> {\n+    // OS-TLS key that we'll use to key off.\n+    os: OsStaticKey,\n+    marker: marker::PhantomData<Cell<T>>,\n+}\n \n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n+impl<T> fmt::Debug for Key<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Key\").finish_non_exhaustive()\n     }\n+}\n \n-    unsafe impl<T> Sync for Key<T> {}\n+unsafe impl<T> Sync for Key<T> {}\n \n-    struct Value<T: 'static> {\n-        inner: LazyKeyInner<T>,\n-        key: &'static Key<T>,\n+struct Value<T: 'static> {\n+    inner: LazyKeyInner<T>,\n+    key: &'static Key<T>,\n+}\n+\n+impl<T: 'static> Key<T> {\n+    #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n+    pub const fn new() -> Key<T> {\n+        Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n     }\n \n-    impl<T: 'static> Key<T> {\n-        #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n-        pub const fn new() -> Key<T> {\n-            Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n+    /// It is a requirement for the caller to ensure that no mutable\n+    /// reference is active when this method is called.\n+    pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+        // SAFETY: See the documentation for this method.\n+        let ptr = unsafe { self.os.get() as *mut Value<T> };\n+        if ptr.addr() > 1 {\n+            // SAFETY: the check ensured the pointer is safe (its destructor\n+            // is not running) + it is coming from a trusted source (self).\n+            if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n+                return Some(value);\n+            }\n         }\n+        // SAFETY: At this point we are sure we have no value and so\n+        // initializing (or trying to) is safe.\n+        unsafe { self.try_initialize(init) }\n+    }\n \n-        /// It is a requirement for the caller to ensure that no mutable\n-        /// reference is active when this method is called.\n-        pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: See the documentation for this method.\n-            let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr.addr() > 1 {\n-                // SAFETY: the check ensured the pointer is safe (its destructor\n-                // is not running) + it is coming from a trusted source (self).\n-                if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n-                    return Some(value);\n-                }\n-            }\n-            // SAFETY: At this point we are sure we have no value and so\n-            // initializing (or trying to) is safe.\n-            unsafe { self.try_initialize(init) }\n+    // `try_initialize` is only called once per os thread local variable,\n+    // except in corner cases where thread_local dtors reference other\n+    // thread_local's, or it is being recursively initialized.\n+    unsafe fn try_initialize(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+        // SAFETY: No mutable references are ever handed out meaning getting\n+        // the value is ok.\n+        let ptr = unsafe { self.os.get() as *mut Value<T> };\n+        if ptr.addr() == 1 {\n+            // destructor is running\n+            return None;\n         }\n \n-        // `try_initialize` is only called once per os thread local variable,\n-        // except in corner cases where thread_local dtors reference other\n-        // thread_local's, or it is being recursively initialized.\n-        unsafe fn try_initialize(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: No mutable references are ever handed out meaning getting\n-            // the value is ok.\n-            let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr.addr() == 1 {\n-                // destructor is running\n-                return None;\n+        let ptr = if ptr.is_null() {\n+            // If the lookup returned null, we haven't initialized our own\n+            // local copy, so do that now.\n+            let ptr = Box::into_raw(Box::new(Value { inner: LazyKeyInner::new(), key: self }));\n+            // SAFETY: At this point we are sure there is no value inside\n+            // ptr so setting it will not affect anyone else.\n+            unsafe {\n+                self.os.set(ptr as *mut u8);\n             }\n-\n-            let ptr = if ptr.is_null() {\n-                // If the lookup returned null, we haven't initialized our own\n-                // local copy, so do that now.\n-                let ptr = Box::into_raw(Box::new(Value { inner: LazyKeyInner::new(), key: self }));\n-                // SAFETY: At this point we are sure there is no value inside\n-                // ptr so setting it will not affect anyone else.\n-                unsafe {\n-                    self.os.set(ptr as *mut u8);\n-                }\n-                ptr\n-            } else {\n-                // recursive initialization\n-                ptr\n-            };\n-\n-            // SAFETY: ptr has been ensured as non-NUL just above an so can be\n-            // dereferenced safely.\n-            unsafe { Some((*ptr).inner.initialize(init)) }\n-        }\n+            ptr\n+        } else {\n+            // recursive initialization\n+            ptr\n+        };\n+\n+        // SAFETY: ptr has been ensured as non-NUL just above an so can be\n+        // dereferenced safely.\n+        unsafe { Some((*ptr).inner.initialize(init)) }\n     }\n+}\n \n-    unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n-        // SAFETY:\n-        //\n-        // The OS TLS ensures that this key contains a null value when this\n-        // destructor starts to run. We set it back to a sentinel value of 1 to\n-        // ensure that any future calls to `get` for this thread will return\n-        // `None`.\n-        //\n-        // Note that to prevent an infinite loop we reset it back to null right\n-        // before we return from the destructor ourselves.\n-        //\n-        // Wrap the call in a catch to ensure unwinding is caught in the event\n-        // a panic takes place in a destructor.\n-        if let Err(_) = panic::catch_unwind(|| unsafe {\n-            let ptr = Box::from_raw(ptr as *mut Value<T>);\n-            let key = ptr.key;\n-            key.os.set(ptr::invalid_mut(1));\n-            drop(ptr);\n-            key.os.set(ptr::null_mut());\n-        }) {\n-            rtabort!(\"thread local panicked on drop\");\n-        }\n+unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n+    // SAFETY:\n+    //\n+    // The OS TLS ensures that this key contains a null value when this\n+    // destructor starts to run. We set it back to a sentinel value of 1 to\n+    // ensure that any future calls to `get` for this thread will return\n+    // `None`.\n+    //\n+    // Note that to prevent an infinite loop we reset it back to null right\n+    // before we return from the destructor ourselves.\n+    //\n+    // Wrap the call in a catch to ensure unwinding is caught in the event\n+    // a panic takes place in a destructor.\n+    if let Err(_) = panic::catch_unwind(|| unsafe {\n+        let ptr = Box::from_raw(ptr as *mut Value<T>);\n+        let key = ptr.key;\n+        key.os.set(ptr::invalid_mut(1));\n+        drop(ptr);\n+        key.os.set(ptr::null_mut());\n+    }) {\n+        rtabort!(\"thread local panicked on drop\");\n     }\n }"}, {"sha": "80322a978646ba7983310bdf22691e14b3571f7d", "filename": "library/std/src/sys/common/thread_local/static_local.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs?ref=fba5cfe482ef8fc60bbd102e22f63059ab15d1c7", "patch": "@@ -1,13 +1,12 @@\n+use super::lazy::LazyKeyInner;\n+use crate::fmt;\n+\n #[doc(hidden)]\n-#[macro_export]\n-#[allow_internal_unstable(\n-    thread_local_internals,\n-    cfg_target_thread_local,\n-    thread_local,\n-    libstd_thread_internals\n-)]\n+#[allow_internal_unstable(thread_local_internals)]\n #[allow_internal_unsafe]\n-macro_rules! __thread_local_inner {\n+#[unstable(feature = \"thread_local_internals\", issue = \"none\")]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro thread_local_inner {\n     // used to generate the `LocalKey` value for const-initialized thread locals\n     (@key $t:ty, const $init:expr) => {{\n         #[inline] // see comments below\n@@ -30,7 +29,7 @@ macro_rules! __thread_local_inner {\n         unsafe {\n             $crate::thread::LocalKey::new(__getit)\n         }\n-    }};\n+    }},\n \n     // used to generate the `LocalKey` value for `thread_local!`\n     (@key $t:ty, $init:expr) => {\n@@ -41,8 +40,8 @@ macro_rules! __thread_local_inner {\n             unsafe fn __getit(\n                 init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n             ) -> $crate::option::Option<&'static $t> {\n-                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n-                    $crate::thread::__LocalKeyInner::new();\n+                static __KEY: $crate::thread::local_impl::Key<$t> =\n+                    $crate::thread::local_impl::Key::new();\n \n                 // FIXME: remove the #[allow(...)] marker when macros don't\n                 // raise warning for missing/extraneous unsafe blocks anymore.\n@@ -66,50 +65,45 @@ macro_rules! __thread_local_inner {\n                 $crate::thread::LocalKey::new(__getit)\n             }\n         }\n-    };\n+    },\n     ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n         $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n-            $crate::__thread_local_inner!(@key $t, $($init)*);\n-    }\n+            $crate::thread::local_impl::thread_local_inner!(@key $t, $($init)*);\n+    },\n }\n \n /// On some targets like wasm there's no threads, so no need to generate\n /// thread locals and we can instead just use plain statics!\n-#[doc(hidden)]\n-pub mod statik {\n-    use super::super::lazy::LazyKeyInner;\n-    use crate::fmt;\n \n-    pub struct Key<T> {\n-        inner: LazyKeyInner<T>,\n-    }\n+pub struct Key<T> {\n+    inner: LazyKeyInner<T>,\n+}\n \n-    unsafe impl<T> Sync for Key<T> {}\n+unsafe impl<T> Sync for Key<T> {}\n \n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n+impl<T> fmt::Debug for Key<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Key\").finish_non_exhaustive()\n     }\n+}\n \n-    impl<T> Key<T> {\n-        pub const fn new() -> Key<T> {\n-            Key { inner: LazyKeyInner::new() }\n-        }\n+impl<T> Key<T> {\n+    pub const fn new() -> Key<T> {\n+        Key { inner: LazyKeyInner::new() }\n+    }\n \n-        pub unsafe fn get(&self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: The caller must ensure no reference is ever handed out to\n-            // the inner cell nor mutable reference to the Option<T> inside said\n-            // cell. This make it safe to hand a reference, though the lifetime\n-            // of 'static is itself unsafe, making the get method unsafe.\n-            let value = unsafe {\n-                match self.inner.get() {\n-                    Some(ref value) => value,\n-                    None => self.inner.initialize(init),\n-                }\n-            };\n+    pub unsafe fn get(&self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+        // SAFETY: The caller must ensure no reference is ever handed out to\n+        // the inner cell nor mutable reference to the Option<T> inside said\n+        // cell. This make it safe to hand a reference, though the lifetime\n+        // of 'static is itself unsafe, making the get method unsafe.\n+        let value = unsafe {\n+            match self.inner.get() {\n+                Some(ref value) => value,\n+                None => self.inner.initialize(init),\n+            }\n+        };\n \n-            Some(value)\n-        }\n+        Some(value)\n     }\n }"}, {"sha": "fa08fdc16530bea0384b44fd722a3d9af00da595", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=fba5cfe482ef8fc60bbd102e22f63059ab15d1c7", "patch": "@@ -153,23 +153,23 @@ macro_rules! thread_local {\n     () => {};\n \n     ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }; $($rest:tt)*) => (\n-        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);\n+        $crate::thread::local_impl::thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);\n         $crate::thread_local!($($rest)*);\n     );\n \n     ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }) => (\n-        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);\n+        $crate::thread::local_impl::thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);\n     );\n \n     // process multiple declarations\n     ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; $($rest:tt)*) => (\n-        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n+        $crate::thread::local_impl::thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n         $crate::thread_local!($($rest)*);\n     );\n \n     // handle a single declaration\n     ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr) => (\n-        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n+        $crate::thread::local_impl::thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n     );\n }\n "}, {"sha": "e8dc7cf92810a20e0f0f3664bc1a9de3e4091225", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba5cfe482ef8fc60bbd102e22f63059ab15d1c7/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=fba5cfe482ef8fc60bbd102e22f63059ab15d1c7", "patch": "@@ -204,9 +204,12 @@ pub use self::local::{AccessError, LocalKey};\n // by the elf linker. \"static\" is for single-threaded platforms where a global\n // static is sufficient.\n \n+// Implementation details used by the thread_local!{} macro.\n #[doc(hidden)]\n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-pub use crate::sys::common::thread_local::Key as __LocalKeyInner;\n+#[unstable(feature = \"thread_local_internals\", issue = \"none\")]\n+pub mod local_impl {\n+    pub use crate::sys::common::thread_local::{thread_local_inner, Key};\n+}\n \n ////////////////////////////////////////////////////////////////////////////////\n // Builder"}]}