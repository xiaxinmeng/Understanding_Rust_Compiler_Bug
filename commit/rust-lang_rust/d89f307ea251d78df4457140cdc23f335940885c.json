{"sha": "d89f307ea251d78df4457140cdc23f335940885c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4OWYzMDdlYTI1MWQ3OGRmNDQ1NzE0MGNkYzIzZjMzNTk0MDg4NWM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-11-18T19:58:33Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-23T12:58:17Z"}, "message": "Move simd intrinsics to intrinsics/simd.rs", "tree": {"sha": "39c91a66636a5dd1060e7aa5500fe60d849d4b7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39c91a66636a5dd1060e7aa5500fe60d849d4b7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d89f307ea251d78df4457140cdc23f335940885c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d89f307ea251d78df4457140cdc23f335940885c", "html_url": "https://github.com/rust-lang/rust/commit/d89f307ea251d78df4457140cdc23f335940885c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d89f307ea251d78df4457140cdc23f335940885c/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67a0fdad19b3dacdc7f088b3fcec7e21d3a364d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/67a0fdad19b3dacdc7f088b3fcec7e21d3a364d8", "html_url": "https://github.com/rust-lang/rust/commit/67a0fdad19b3dacdc7f088b3fcec7e21d3a364d8"}], "stats": {"total": 417, "additions": 221, "deletions": 196}, "files": [{"sha": "ca10399cb9cb8f8a1aefee3b02ad2eea4363c454", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 50, "deletions": 196, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/d89f307ea251d78df4457140cdc23f335940885c/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d89f307ea251d78df4457140cdc23f335940885c/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=d89f307ea251d78df4457140cdc23f335940885c", "patch": "@@ -1,4 +1,5 @@\n pub mod llvm;\n+mod simd;\n \n use crate::prelude::*;\n \n@@ -70,7 +71,7 @@ macro intrinsic_match {\n     }\n }\n \n-macro_rules! call_intrinsic_match {\n+macro call_intrinsic_match {\n     ($fx:expr, $intrinsic:expr, $substs:expr, $ret:expr, $destination:expr, $args:expr, $(\n         $name:ident($($arg:ident),*) -> $ty:ident => $func:ident,\n     )*) => {\n@@ -102,32 +103,28 @@ macro_rules! call_intrinsic_match {\n     }\n }\n \n-macro_rules! atomic_binop_return_old {\n-    ($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident) => {\n-        let clif_ty = $fx.clif_type($T).unwrap();\n-        let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n-        let new = $fx.bcx.ins().$op(old, $src);\n-        $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n-        $ret.write_cvalue($fx, CValue::by_val(old, $fx.layout_of($T)));\n-    };\n+macro atomic_binop_return_old($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident)  {\n+    let clif_ty = $fx.clif_type($T).unwrap();\n+    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n+    let new = $fx.bcx.ins().$op(old, $src);\n+    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n+    $ret.write_cvalue($fx, CValue::by_val(old, $fx.layout_of($T)));\n }\n \n-macro_rules! atomic_minmax {\n-    ($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $ret:ident) => {\n-        // Read old\n-        let clif_ty = $fx.clif_type($T).unwrap();\n-        let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n+macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $ret:ident) {\n+    // Read old\n+    let clif_ty = $fx.clif_type($T).unwrap();\n+    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n \n-        // Compare\n-        let is_eq = codegen_icmp($fx, IntCC::SignedGreaterThan, old, $src);\n-        let new = $fx.bcx.ins().select(is_eq, old, $src);\n+    // Compare\n+    let is_eq = codegen_icmp($fx, IntCC::SignedGreaterThan, old, $src);\n+    let new = $fx.bcx.ins().select(is_eq, old, $src);\n \n-        // Write new\n-        $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n+    // Write new\n+    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n \n-        let ret_val = CValue::by_val(old, $ret.layout());\n-        $ret.write_cvalue($fx, ret_val);\n-    };\n+    let ret_val = CValue::by_val(old, $ret.layout());\n+    $ret.write_cvalue($fx, ret_val);\n }\n \n fn lane_type_and_count<'tcx>(\n@@ -206,7 +203,7 @@ fn bool_to_zero_or_max_uint<'tcx>(\n     CValue::by_val(res, layout)\n }\n \n-macro_rules! simd_cmp {\n+macro simd_cmp {\n     ($fx:expr, $intrinsic:expr, $cc:ident($x:ident, $y:ident) -> $ret:ident) => {\n         simd_for_each_lane(\n             $fx,\n@@ -222,7 +219,7 @@ macro_rules! simd_cmp {\n                 bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n             },\n         );\n-    };\n+    },\n     ($fx:expr, $intrinsic:expr, $cc_u:ident|$cc_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n         simd_for_each_lane(\n             $fx,\n@@ -239,10 +236,10 @@ macro_rules! simd_cmp {\n                 bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n             },\n         );\n-    };\n+    },\n }\n \n-macro_rules! simd_int_binop {\n+macro simd_int_binop {\n     ($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n         simd_for_each_lane(\n             $fx,\n@@ -258,7 +255,7 @@ macro_rules! simd_int_binop {\n                 CValue::by_val(res_lane, ret_lane_layout)\n             },\n         );\n-    };\n+    },\n     ($fx:expr, $intrinsic:expr, $op_u:ident|$op_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n         simd_for_each_lane(\n             $fx,\n@@ -275,10 +272,10 @@ macro_rules! simd_int_binop {\n                 CValue::by_val(res_lane, ret_lane_layout)\n             },\n         );\n-    };\n+    },\n }\n \n-macro_rules! simd_int_flt_binop {\n+macro simd_int_flt_binop {\n     ($fx:expr, $intrinsic:expr, $op:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n         simd_for_each_lane(\n             $fx,\n@@ -295,7 +292,7 @@ macro_rules! simd_int_flt_binop {\n                 CValue::by_val(res_lane, ret_lane_layout)\n             },\n         );\n-    };\n+    },\n     ($fx:expr, $intrinsic:expr, $op_u:ident|$op_s:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n         simd_for_each_lane(\n             $fx,\n@@ -313,26 +310,24 @@ macro_rules! simd_int_flt_binop {\n                 CValue::by_val(res_lane, ret_lane_layout)\n             },\n         );\n-    };\n+    },\n }\n \n-macro_rules! simd_flt_binop {\n-    ($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane(\n-            $fx,\n-            $intrinsic,\n-            $x,\n-            $y,\n-            $ret,\n-            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind {\n-                    ty::Float(_) => fx.bcx.ins().$op(x_lane, y_lane),\n-                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n-                };\n-                CValue::by_val(res_lane, ret_lane_layout)\n-            },\n-        );\n-    };\n+macro simd_flt_binop($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) {\n+    simd_for_each_lane(\n+        $fx,\n+        $intrinsic,\n+        $x,\n+        $y,\n+        $ret,\n+        |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.kind {\n+                ty::Float(_) => fx.bcx.ins().$op(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        },\n+    );\n }\n \n pub fn codegen_intrinsic_call<'tcx>(\n@@ -371,6 +366,13 @@ pub fn codegen_intrinsic_call<'tcx>(\n         }\n     };\n \n+    if intrinsic.starts_with(\"simd_\") {\n+        self::simd::codegen_simd_intrinsic_call(fx, instance, args, ret, span);\n+        let ret_ebb = fx.get_ebb(destination.expect(\"SIMD intrinsics don't diverge\").1);\n+        fx.bcx.ins().jump(ret_ebb, &[]);\n+        return;\n+    }\n+\n     let usize_layout = fx.layout_of(fx.tcx.types.usize);\n \n     call_intrinsic_match! {\n@@ -944,154 +946,6 @@ pub fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, val);\n         };\n \n-        simd_cast, (c a) {\n-            let (lane_layout, lane_count) = lane_type_and_count(fx, a.layout(), intrinsic);\n-            let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx, ret.layout(), intrinsic);\n-            assert_eq!(lane_count, ret_lane_count);\n-\n-            let ret_lane_ty = fx.clif_type(ret_lane_layout.ty).unwrap();\n-\n-            let from_signed = type_sign(lane_layout.ty);\n-            let to_signed = type_sign(ret_lane_layout.ty);\n-\n-            for lane in 0..lane_count {\n-                let lane = mir::Field::new(lane.try_into().unwrap());\n-\n-                let a_lane = a.value_field(fx, lane).load_scalar(fx);\n-                let res = clif_int_or_float_cast(fx, a_lane, from_signed, ret_lane_ty, to_signed);\n-                ret.place_field(fx, lane).write_cvalue(fx, CValue::by_val(res, ret_lane_layout));\n-            }\n-        };\n-\n-        simd_eq, (c x, c y) {\n-            simd_cmp!(fx, intrinsic, Equal(x, y) -> ret);\n-        };\n-        simd_ne, (c x, c y) {\n-            simd_cmp!(fx, intrinsic, NotEqual(x, y) -> ret);\n-        };\n-        simd_lt, (c x, c y) {\n-            simd_cmp!(fx, intrinsic, UnsignedLessThan|SignedLessThan(x, y) -> ret);\n-        };\n-        simd_le, (c x, c y) {\n-            simd_cmp!(fx, intrinsic, UnsignedLessThanOrEqual|SignedLessThanOrEqual(x, y) -> ret);\n-        };\n-        simd_gt, (c x, c y) {\n-            simd_cmp!(fx, intrinsic, UnsignedGreaterThan|SignedGreaterThan(x, y) -> ret);\n-        };\n-        simd_ge, (c x, c y) {\n-            simd_cmp!(fx, intrinsic, UnsignedGreaterThanOrEqual|SignedGreaterThanOrEqual(x, y) -> ret);\n-        };\n-\n-        // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U\n-        _ if intrinsic.starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n-            let n: u32 = intrinsic[\"simd_shuffle\".len()..].parse().unwrap();\n-\n-            assert_eq!(x.layout(), y.layout());\n-            let layout = x.layout();\n-\n-            let (lane_type, lane_count) = lane_type_and_count(fx, layout, intrinsic);\n-            let (ret_lane_type, ret_lane_count) = lane_type_and_count(fx, ret.layout(), intrinsic);\n-\n-            assert_eq!(lane_type, ret_lane_type);\n-            assert_eq!(n, ret_lane_count);\n-\n-            let total_len = lane_count * 2;\n-\n-            let indexes = {\n-                use rustc::mir::interpret::*;\n-                let idx_const = crate::constant::mir_operand_get_const_val(fx, idx).expect(\"simd_shuffle* idx not const\");\n-\n-                let idx_bytes = match idx_const.val {\n-                    ty::ConstKind::Value(ConstValue::ByRef { alloc, offset }) => {\n-                        let ptr = Pointer::new(AllocId(0 /* dummy */), offset);\n-                        let size = Size::from_bytes(4 * u64::from(ret_lane_count) /* size_of([u32; ret_lane_count]) */);\n-                        alloc.get_bytes(fx, ptr, size).unwrap()\n-                    }\n-                    _ => unreachable!(\"{:?}\", idx_const),\n-                };\n-\n-                (0..ret_lane_count).map(|i| {\n-                    let i = usize::try_from(i).unwrap();\n-                    let idx = rustc::mir::interpret::read_target_uint(\n-                        fx.tcx.data_layout.endian,\n-                        &idx_bytes[4*i.. 4*i + 4],\n-                    ).expect(\"read_target_uint\");\n-                    u32::try_from(idx).expect(\"try_from u32\")\n-                }).collect::<Vec<u32>>()\n-            };\n-\n-            for &idx in &indexes {\n-                assert!(idx < total_len, \"idx {} out of range 0..{}\", idx, total_len);\n-            }\n-\n-            for (out_idx, in_idx) in indexes.into_iter().enumerate() {\n-                let in_lane = if in_idx < lane_count {\n-                    x.value_field(fx, mir::Field::new(in_idx.try_into().unwrap()))\n-                } else {\n-                    y.value_field(fx, mir::Field::new((in_idx - lane_count).try_into().unwrap()))\n-                };\n-                let out_lane = ret.place_field(fx, mir::Field::new(out_idx));\n-                out_lane.write_cvalue(fx, in_lane);\n-            }\n-        };\n-\n-        simd_extract, (c v, o idx) {\n-            let idx_const = if let Some(idx_const) = crate::constant::mir_operand_get_const_val(fx, idx) {\n-                idx_const\n-            } else {\n-                fx.tcx.sess.span_warn(\n-                    fx.mir.span,\n-                    \"`#[rustc_arg_required_const(..)]` is not yet supported. Calling this function will panic.\",\n-                );\n-                crate::trap::trap_panic(fx, \"`#[rustc_arg_required_const(..)]` is not yet supported.\");\n-                return;\n-            };\n-\n-            let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).expect(&format!(\"kind not scalar: {:?}\", idx_const));\n-            let (_lane_type, lane_count) = lane_type_and_count(fx, v.layout(), intrinsic);\n-            if idx >= lane_count.into() {\n-                fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n-            }\n-\n-            let ret_lane = v.value_field(fx, mir::Field::new(idx.try_into().unwrap()));\n-            ret.write_cvalue(fx, ret_lane);\n-        };\n-\n-        simd_add, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, iadd|fadd(x, y) -> ret);\n-        };\n-        simd_sub, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, isub|fsub(x, y) -> ret);\n-        };\n-        simd_mul, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, imul|fmul(x, y) -> ret);\n-        };\n-        simd_div, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, udiv|sdiv|fdiv(x, y) -> ret);\n-        };\n-        simd_shl, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, ishl(x, y) -> ret);\n-        };\n-        simd_shr, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, ushr|sshr(x, y) -> ret);\n-        };\n-        simd_and, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, band(x, y) -> ret);\n-        };\n-        simd_or, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, bor(x, y) -> ret);\n-        };\n-        simd_xor, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, bxor(x, y) -> ret);\n-        };\n-\n-        simd_fmin, (c x, c y) {\n-            simd_flt_binop!(fx, intrinsic, fmin(x, y) -> ret);\n-        };\n-        simd_fmax, (c x, c y) {\n-            simd_flt_binop!(fx, intrinsic, fmax(x, y) -> ret);\n-        };\n-\n         try, (v f, v data, v _local_ptr) {\n             // FIXME once unwinding is supported, change this to actually catch panics\n             let f_sig = fx.bcx.func.import_signature(Signature {"}, {"sha": "2b6447de894f3583f556dcc57220f7c60a772a02", "filename": "src/intrinsics/simd.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/d89f307ea251d78df4457140cdc23f335940885c/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d89f307ea251d78df4457140cdc23f335940885c/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=d89f307ea251d78df4457140cdc23f335940885c", "patch": "@@ -0,0 +1,171 @@\n+use crate::prelude::*;\n+use super::*;\n+\n+pub fn codegen_simd_intrinsic_call<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    instance: Instance<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n+    ret: CPlace<'tcx>,\n+    span: Span,\n+) {\n+    let def_id = instance.def_id();\n+    let substs = instance.substs;\n+\n+    let intrinsic = fx.tcx.item_name(def_id).as_str();\n+    let intrinsic = &intrinsic[..];\n+\n+    intrinsic_match! {\n+        fx, intrinsic, substs, args,\n+        _ => {\n+            fx.tcx.sess.fatal(&format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n+        };\n+\n+        simd_cast, (c a) {\n+            let (lane_layout, lane_count) = lane_type_and_count(fx, a.layout(), intrinsic);\n+            let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx, ret.layout(), intrinsic);\n+            assert_eq!(lane_count, ret_lane_count);\n+\n+            let ret_lane_ty = fx.clif_type(ret_lane_layout.ty).unwrap();\n+\n+            let from_signed = type_sign(lane_layout.ty);\n+            let to_signed = type_sign(ret_lane_layout.ty);\n+\n+            for lane in 0..lane_count {\n+                let lane = mir::Field::new(lane.try_into().unwrap());\n+\n+                let a_lane = a.value_field(fx, lane).load_scalar(fx);\n+                let res = clif_int_or_float_cast(fx, a_lane, from_signed, ret_lane_ty, to_signed);\n+                ret.place_field(fx, lane).write_cvalue(fx, CValue::by_val(res, ret_lane_layout));\n+            }\n+        };\n+\n+        simd_eq, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, Equal(x, y) -> ret);\n+        };\n+        simd_ne, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, NotEqual(x, y) -> ret);\n+        };\n+        simd_lt, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, UnsignedLessThan|SignedLessThan(x, y) -> ret);\n+        };\n+        simd_le, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, UnsignedLessThanOrEqual|SignedLessThanOrEqual(x, y) -> ret);\n+        };\n+        simd_gt, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, UnsignedGreaterThan|SignedGreaterThan(x, y) -> ret);\n+        };\n+        simd_ge, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, UnsignedGreaterThanOrEqual|SignedGreaterThanOrEqual(x, y) -> ret);\n+        };\n+\n+        // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U\n+        _ if intrinsic.starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n+            let n: u32 = intrinsic[\"simd_shuffle\".len()..].parse().unwrap();\n+\n+            assert_eq!(x.layout(), y.layout());\n+            let layout = x.layout();\n+\n+            let (lane_type, lane_count) = lane_type_and_count(fx, layout, intrinsic);\n+            let (ret_lane_type, ret_lane_count) = lane_type_and_count(fx, ret.layout(), intrinsic);\n+\n+            assert_eq!(lane_type, ret_lane_type);\n+            assert_eq!(n, ret_lane_count);\n+\n+            let total_len = lane_count * 2;\n+\n+            let indexes = {\n+                use rustc::mir::interpret::*;\n+                let idx_const = crate::constant::mir_operand_get_const_val(fx, idx).expect(\"simd_shuffle* idx not const\");\n+\n+                let idx_bytes = match idx_const.val {\n+                    ty::ConstKind::Value(ConstValue::ByRef { alloc, offset }) => {\n+                        let ptr = Pointer::new(AllocId(0 /* dummy */), offset);\n+                        let size = Size::from_bytes(4 * u64::from(ret_lane_count) /* size_of([u32; ret_lane_count]) */);\n+                        alloc.get_bytes(fx, ptr, size).unwrap()\n+                    }\n+                    _ => unreachable!(\"{:?}\", idx_const),\n+                };\n+\n+                (0..ret_lane_count).map(|i| {\n+                    let i = usize::try_from(i).unwrap();\n+                    let idx = rustc::mir::interpret::read_target_uint(\n+                        fx.tcx.data_layout.endian,\n+                        &idx_bytes[4*i.. 4*i + 4],\n+                    ).expect(\"read_target_uint\");\n+                    u32::try_from(idx).expect(\"try_from u32\")\n+                }).collect::<Vec<u32>>()\n+            };\n+\n+            for &idx in &indexes {\n+                assert!(idx < total_len, \"idx {} out of range 0..{}\", idx, total_len);\n+            }\n+\n+            for (out_idx, in_idx) in indexes.into_iter().enumerate() {\n+                let in_lane = if in_idx < lane_count {\n+                    x.value_field(fx, mir::Field::new(in_idx.try_into().unwrap()))\n+                } else {\n+                    y.value_field(fx, mir::Field::new((in_idx - lane_count).try_into().unwrap()))\n+                };\n+                let out_lane = ret.place_field(fx, mir::Field::new(out_idx));\n+                out_lane.write_cvalue(fx, in_lane);\n+            }\n+        };\n+\n+        simd_extract, (c v, o idx) {\n+            let idx_const = if let Some(idx_const) = crate::constant::mir_operand_get_const_val(fx, idx) {\n+                idx_const\n+            } else {\n+                fx.tcx.sess.span_warn(\n+                    fx.mir.span,\n+                    \"`#[rustc_arg_required_const(..)]` is not yet supported. Calling this function will panic.\",\n+                );\n+                crate::trap::trap_panic(fx, \"`#[rustc_arg_required_const(..)]` is not yet supported.\");\n+                return;\n+            };\n+\n+            let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).expect(&format!(\"kind not scalar: {:?}\", idx_const));\n+            let (_lane_type, lane_count) = lane_type_and_count(fx, v.layout(), intrinsic);\n+            if idx >= lane_count.into() {\n+                fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n+            }\n+\n+            let ret_lane = v.value_field(fx, mir::Field::new(idx.try_into().unwrap()));\n+            ret.write_cvalue(fx, ret_lane);\n+        };\n+\n+        simd_add, (c x, c y) {\n+            simd_int_flt_binop!(fx, intrinsic, iadd|fadd(x, y) -> ret);\n+        };\n+        simd_sub, (c x, c y) {\n+            simd_int_flt_binop!(fx, intrinsic, isub|fsub(x, y) -> ret);\n+        };\n+        simd_mul, (c x, c y) {\n+            simd_int_flt_binop!(fx, intrinsic, imul|fmul(x, y) -> ret);\n+        };\n+        simd_div, (c x, c y) {\n+            simd_int_flt_binop!(fx, intrinsic, udiv|sdiv|fdiv(x, y) -> ret);\n+        };\n+        simd_shl, (c x, c y) {\n+            simd_int_binop!(fx, intrinsic, ishl(x, y) -> ret);\n+        };\n+        simd_shr, (c x, c y) {\n+            simd_int_binop!(fx, intrinsic, ushr|sshr(x, y) -> ret);\n+        };\n+        simd_and, (c x, c y) {\n+            simd_int_binop!(fx, intrinsic, band(x, y) -> ret);\n+        };\n+        simd_or, (c x, c y) {\n+            simd_int_binop!(fx, intrinsic, bor(x, y) -> ret);\n+        };\n+        simd_xor, (c x, c y) {\n+            simd_int_binop!(fx, intrinsic, bxor(x, y) -> ret);\n+        };\n+\n+        simd_fmin, (c x, c y) {\n+            simd_flt_binop!(fx, intrinsic, fmin(x, y) -> ret);\n+        };\n+        simd_fmax, (c x, c y) {\n+            simd_flt_binop!(fx, intrinsic, fmax(x, y) -> ret);\n+        };\n+    }\n+}"}]}