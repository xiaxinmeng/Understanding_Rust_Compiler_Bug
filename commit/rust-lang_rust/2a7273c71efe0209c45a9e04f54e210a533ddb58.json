{"sha": "2a7273c71efe0209c45a9e04f54e210a533ddb58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNzI3M2M3MWVmZTAyMDljNDVhOWUwNGY1NGUyMTBhNTMzZGRiNTg=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-12T02:14:54Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:08:57Z"}, "message": "Stash a spare kill flag inside tasks, to save two atomic xadds in the blocking fastpath.", "tree": {"sha": "064dc9f001d0c34f77353ac71a39eaaca5250661", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/064dc9f001d0c34f77353ac71a39eaaca5250661"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a7273c71efe0209c45a9e04f54e210a533ddb58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a7273c71efe0209c45a9e04f54e210a533ddb58", "html_url": "https://github.com/rust-lang/rust/commit/2a7273c71efe0209c45a9e04f54e210a533ddb58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a7273c71efe0209c45a9e04f54e210a533ddb58/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e283c4ddffad0ac4e2ebace590849ff46336ca0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e283c4ddffad0ac4e2ebace590849ff46336ca0e", "html_url": "https://github.com/rust-lang/rust/commit/e283c4ddffad0ac4e2ebace590849ff46336ca0e"}], "stats": {"total": 124, "additions": 87, "deletions": 37}, "files": [{"sha": "58e68cae2538a0a7da8d4b4efacce613d7f904e0", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 75, "deletions": 37, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2a7273c71efe0209c45a9e04f54e210a533ddb58/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7273c71efe0209c45a9e04f54e210a533ddb58/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=2a7273c71efe0209c45a9e04f54e210a533ddb58", "patch": "@@ -85,6 +85,9 @@ pub struct Death {\n     unkillable:      int,\n     // nesting level counter for task::atomically calls (0 == can yield).\n     wont_sleep:      int,\n+    // A \"spare\" handle to the kill flag inside the kill handle. Used during\n+    // blocking/waking as an optimization to avoid two xadds on the refcount.\n+    spare_kill_flag: Option<KillFlagHandle>,\n }\n \n impl Drop for KillFlag {\n@@ -98,38 +101,60 @@ impl Drop for KillFlag {\n     }\n }\n \n+// Whenever a task blocks, it swaps out its spare kill flag to use as the\n+// blocked task handle. So unblocking a task must restore that spare.\n+unsafe fn revive_task_ptr(task_ptr: uint, spare_flag: Option<KillFlagHandle>) -> ~Task {\n+    let mut task: ~Task = cast::transmute(task_ptr);\n+    rtassert!(task.death.spare_kill_flag.is_none());\n+    task.death.spare_kill_flag = spare_flag;\n+    task\n+}\n+\n impl BlockedTask {\n     /// Returns Some if the task was successfully woken; None if already killed.\n     pub fn wake(self) -> Option<~Task> {\n-        let mut this = self;\n-        match this {\n+        match self {\n             Unkillable(task) => Some(task),\n-            Killable(ref mut flag_arc) => {\n+            Killable(flag_arc) => {\n                 let flag = unsafe { &mut **flag_arc.get() };\n                 match flag.swap(KILL_RUNNING, SeqCst) {\n                     KILL_RUNNING => rtabort!(\"tried to wake an already-running task\"),\n                     KILL_KILLED  => None, // a killer stole it already\n-                    task_ptr     => Some(unsafe { cast::transmute(task_ptr) }),\n+                    task_ptr     =>\n+                        Some(unsafe { revive_task_ptr(task_ptr, Some(flag_arc)) })\n                 }\n             }\n         }\n     }\n \n     /// Create a blocked task, unless the task was already killed.\n-    pub fn try_block(task: ~Task) -> Either<~Task, BlockedTask> {\n+    pub fn try_block(mut task: ~Task) -> Either<~Task, BlockedTask> {\n         if task.death.unkillable > 0 { // FIXME(#7544): || self.indestructible\n             Right(Unkillable(task))\n         } else {\n             rtassert!(task.death.kill_handle.is_some());\n             unsafe {\n-                // FIXME(#7544) optimz\n-                let flag_arc = (*task.death.kill_handle.get_ref().get()).killed.clone();\n+                // The inverse of 'revive', above, occurs here.\n+                // The spare kill flag will usually be Some, unless the task was\n+                // already killed, in which case the killer will have deferred\n+                // creating a new one until whenever it blocks during unwinding.\n+                let flag_arc = match task.death.spare_kill_flag.take() {\n+                    Some(spare_flag) => spare_flag,\n+                    None => {\n+                        // FIXME(#7544): Uncomment this when terminate_current_task\n+                        // stops being *terrible*. That's the only place that violates\n+                        // the assumption of \"becoming unkillable will fail if the\n+                        // task was killed\".\n+                        // rtassert!(task.unwinder.unwinding);\n+                        (*task.death.kill_handle.get_ref().get()).killed.clone()\n+                    }\n+                };\n                 let flag     = &mut **flag_arc.get();\n                 let task_ptr = cast::transmute(task);\n                 // Expect flag to contain RUNNING. If KILLED, it should stay KILLED.\n                 match flag.compare_and_swap(KILL_RUNNING, task_ptr, SeqCst) {\n                     KILL_RUNNING => Right(Killable(flag_arc)),\n-                    KILL_KILLED  => Left(cast::transmute(task_ptr)),\n+                    KILL_KILLED  => Left(revive_task_ptr(task_ptr, Some(flag_arc))),\n                     x            => rtabort!(\"can't block task! kill flag = %?\", x),\n                 }\n             }\n@@ -170,16 +195,19 @@ impl BlockedTask {\n }\n \n impl KillHandle {\n-    pub fn new() -> KillHandle {\n-        KillHandle(UnsafeAtomicRcBox::new(KillHandleInner {\n+    pub fn new() -> (KillHandle, KillFlagHandle) {\n+        let (flag, flag_clone) =\n+            UnsafeAtomicRcBox::new2(KillFlag(AtomicUint::new(KILL_RUNNING)));\n+        let handle = KillHandle(UnsafeAtomicRcBox::new(KillHandleInner {\n             // Linked failure fields\n-            killed:     UnsafeAtomicRcBox::new(KillFlag(AtomicUint::new(KILL_RUNNING))),\n+            killed:     flag,\n             unkillable: AtomicUint::new(KILL_RUNNING),\n             // Exit code propagation fields\n             any_child_failed: false,\n             child_tombstones: None,\n             graveyard_lock:   LittleLock(),\n-        }))\n+        }));\n+        (handle, flag_clone)\n     }\n \n     // Will begin unwinding if a kill signal was received, unless already_failing.\n@@ -221,7 +249,10 @@ impl KillHandle {\n                 // Task either not blocked or already taken care of.\n                 KILL_RUNNING | KILL_KILLED => None,\n                 // Got ownership of the blocked task.\n-                task_ptr => Some(unsafe { cast::transmute(task_ptr) }),\n+                // While the usual 'wake' path can just pass back the flag\n+                // handle, we (the slower kill path) haven't an extra one lying\n+                // around. The task will wake up without a spare.\n+                task_ptr => Some(unsafe { revive_task_ptr(task_ptr, None) }),\n             }\n         } else {\n             // Otherwise it was either unkillable or already killed. Somebody\n@@ -320,23 +351,27 @@ impl KillHandle {\n \n impl Death {\n     pub fn new() -> Death {\n+        let (handle, spare) = KillHandle::new();\n         Death {\n-            kill_handle:     Some(KillHandle::new()),\n+            kill_handle:     Some(handle),\n             watching_parent: None,\n             on_exit:         None,\n             unkillable:      0,\n             wont_sleep:      0,\n+            spare_kill_flag: Some(spare),\n         }\n     }\n \n     pub fn new_child(&self) -> Death {\n         // FIXME(#7327)\n+        let (handle, spare) = KillHandle::new();\n         Death {\n-            kill_handle:     Some(KillHandle::new()),\n+            kill_handle:     Some(handle),\n             watching_parent: self.kill_handle.clone(),\n             on_exit:         None,\n             unkillable:      0,\n             wont_sleep:      0,\n+            spare_kill_flag: Some(spare),\n         }\n     }\n \n@@ -469,12 +504,15 @@ mod test {\n     use super::*;\n     use util;\n \n+    // Test cases don't care about the spare killed flag.\n+    fn make_kill_handle() -> KillHandle { let (h,_) = KillHandle::new(); h }\n+\n     #[test]\n     fn no_tombstone_success() {\n         do run_in_newsched_task {\n             // Tests case 4 of the 4-way match in reparent_children.\n-            let mut parent = KillHandle::new();\n-            let mut child  = KillHandle::new();\n+            let mut parent = make_kill_handle();\n+            let mut child  = make_kill_handle();\n \n             // Without another handle to child, the try unwrap should succeed.\n             child.reparent_children_to(&mut parent);\n@@ -487,8 +525,8 @@ mod test {\n     fn no_tombstone_failure() {\n         do run_in_newsched_task {\n             // Tests case 2 of the 4-way match in reparent_children.\n-            let mut parent = KillHandle::new();\n-            let mut child  = KillHandle::new();\n+            let mut parent = make_kill_handle();\n+            let mut child  = make_kill_handle();\n \n             child.notify_immediate_failure();\n             // Without another handle to child, the try unwrap should succeed.\n@@ -503,9 +541,9 @@ mod test {\n     fn no_tombstone_because_sibling_already_failed() {\n         do run_in_newsched_task {\n             // Tests \"case 0, the optimistic path in reparent_children.\n-            let mut parent = KillHandle::new();\n-            let mut child1 = KillHandle::new();\n-            let mut child2 = KillHandle::new();\n+            let mut parent = make_kill_handle();\n+            let mut child1 = make_kill_handle();\n+            let mut child2 = make_kill_handle();\n             let mut link   = child2.clone();\n \n             // Should set parent's child_failed flag\n@@ -525,8 +563,8 @@ mod test {\n     #[test]\n     fn one_tombstone_success() {\n         do run_in_newsched_task {\n-            let mut parent = KillHandle::new();\n-            let mut child  = KillHandle::new();\n+            let mut parent = make_kill_handle();\n+            let mut child  = make_kill_handle();\n             let mut link   = child.clone();\n \n             // Creates 1 tombstone. Existence of 'link' makes try-unwrap fail.\n@@ -542,8 +580,8 @@ mod test {\n     #[test]\n     fn one_tombstone_failure() {\n         do run_in_newsched_task {\n-            let mut parent = KillHandle::new();\n-            let mut child  = KillHandle::new();\n+            let mut parent = make_kill_handle();\n+            let mut child  = make_kill_handle();\n             let mut link   = child.clone();\n \n             // Creates 1 tombstone. Existence of 'link' makes try-unwrap fail.\n@@ -562,9 +600,9 @@ mod test {\n     #[test]\n     fn two_tombstones_success() {\n         do run_in_newsched_task {\n-            let mut parent = KillHandle::new();\n-            let mut middle = KillHandle::new();\n-            let mut child  = KillHandle::new();\n+            let mut parent = make_kill_handle();\n+            let mut middle = make_kill_handle();\n+            let mut child  = make_kill_handle();\n             let mut link   = child.clone();\n \n             child.reparent_children_to(&mut middle); // case 1 tombstone\n@@ -581,9 +619,9 @@ mod test {\n     #[test]\n     fn two_tombstones_failure() {\n         do run_in_newsched_task {\n-            let mut parent = KillHandle::new();\n-            let mut middle = KillHandle::new();\n-            let mut child  = KillHandle::new();\n+            let mut parent = make_kill_handle();\n+            let mut middle = make_kill_handle();\n+            let mut child  = make_kill_handle();\n             let mut link   = child.clone();\n \n             child.reparent_children_to(&mut middle); // case 1 tombstone\n@@ -606,7 +644,7 @@ mod test {\n     #[test]\n     fn kill_basic() {\n         do run_in_newsched_task {\n-            let mut handle = KillHandle::new();\n+            let mut handle = make_kill_handle();\n             assert!(!handle.killed());\n             assert!(handle.kill().is_none());\n             assert!(handle.killed());\n@@ -616,7 +654,7 @@ mod test {\n     #[test]\n     fn double_kill() {\n         do run_in_newsched_task {\n-            let mut handle = KillHandle::new();\n+            let mut handle = make_kill_handle();\n             assert!(!handle.killed());\n             assert!(handle.kill().is_none());\n             assert!(handle.killed());\n@@ -628,7 +666,7 @@ mod test {\n     #[test]\n     fn unkillable_after_kill() {\n         do run_in_newsched_task {\n-            let mut handle = KillHandle::new();\n+            let mut handle = make_kill_handle();\n             assert!(handle.kill().is_none());\n             assert!(handle.killed());\n             let handle_cell = Cell::new(handle);\n@@ -642,7 +680,7 @@ mod test {\n     #[test]\n     fn unkillable_during_kill() {\n         do run_in_newsched_task {\n-            let mut handle = KillHandle::new();\n+            let mut handle = make_kill_handle();\n             handle.inhibit_kill(false);\n             assert!(handle.kill().is_none());\n             assert!(!handle.killed());\n@@ -657,7 +695,7 @@ mod test {\n     #[test]\n     fn unkillable_before_kill() {\n         do run_in_newsched_task {\n-            let mut handle = KillHandle::new();\n+            let mut handle = make_kill_handle();\n             handle.inhibit_kill(false);\n             handle.allow_kill(false);\n             assert!(handle.kill().is_none());"}, {"sha": "66ad7dde6357c351e6d58349c44519ff69531348", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a7273c71efe0209c45a9e04f54e210a533ddb58/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7273c71efe0209c45a9e04f54e210a533ddb58/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=2a7273c71efe0209c45a9e04f54e210a533ddb58", "patch": "@@ -52,6 +52,18 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n         }\n     }\n \n+    /// As new(), but returns an extra pre-cloned handle.\n+    pub fn new2(data: T) -> (UnsafeAtomicRcBox<T>, UnsafeAtomicRcBox<T>) {\n+        unsafe {\n+            let data = ~AtomicRcBoxData { count: AtomicUint::new(2),\n+                                          unwrapper: AtomicOption::empty(),\n+                                          data: Some(data) };\n+            let ptr = cast::transmute(data);\n+            return (UnsafeAtomicRcBox { data: ptr },\n+                    UnsafeAtomicRcBox { data: ptr });\n+        }\n+    }\n+\n     #[inline]\n     pub unsafe fn get(&self) -> *mut T\n     {"}]}