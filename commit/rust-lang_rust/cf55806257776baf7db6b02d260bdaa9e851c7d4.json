{"sha": "cf55806257776baf7db6b02d260bdaa9e851c7d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNTU4MDYyNTc3NzZiYWY3ZGI2YjAyZDI2MGJkYWE5ZTg1MWM3ZDQ=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-29T01:44:01Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-29T05:06:58Z"}, "message": "SSR: Restrict to current selection if any\n\nThe selection is also used to avoid unnecessary work, but only to the\nfile level. Further restricting unnecessary work is left for later.", "tree": {"sha": "6827c094a4a27631ee9b1b97d98a8ac9c0a56aac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6827c094a4a27631ee9b1b97d98a8ac9c0a56aac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf55806257776baf7db6b02d260bdaa9e851c7d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf55806257776baf7db6b02d260bdaa9e851c7d4", "html_url": "https://github.com/rust-lang/rust/commit/cf55806257776baf7db6b02d260bdaa9e851c7d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf55806257776baf7db6b02d260bdaa9e851c7d4/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a8124273dd663f7f1ed43b53defc4a2c52dbc12", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a8124273dd663f7f1ed43b53defc4a2c52dbc12", "html_url": "https://github.com/rust-lang/rust/commit/5a8124273dd663f7f1ed43b53defc4a2c52dbc12"}], "stats": {"total": 231, "additions": 181, "deletions": 50}, "files": [{"sha": "0fede0d87952db10d6094b88d39cbfcb27d172d8", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=cf55806257776baf7db6b02d260bdaa9e851c7d4", "patch": "@@ -510,9 +510,10 @@ impl Analysis {\n         query: &str,\n         parse_only: bool,\n         position: FilePosition,\n+        selections: Vec<FileRange>,\n     ) -> Cancelable<Result<SourceChange, SsrError>> {\n         self.with_db(|db| {\n-            let edits = ssr::parse_search_replace(query, parse_only, db, position)?;\n+            let edits = ssr::parse_search_replace(query, parse_only, db, position, selections)?;\n             Ok(SourceChange::from(edits))\n         })\n     }"}, {"sha": "63010677ad5c56784d13011b3db79612de118d7f", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=cf55806257776baf7db6b02d260bdaa9e851c7d4", "patch": "@@ -1,4 +1,4 @@\n-use ra_db::FilePosition;\n+use ra_db::{FilePosition, FileRange};\n use ra_ide_db::RootDatabase;\n \n use crate::SourceFileEdit;\n@@ -24,6 +24,9 @@ use ra_ssr::{MatchFinder, SsrError, SsrRule};\n // Method calls should generally be written in UFCS form. e.g. `foo::Bar::baz($s, $a)` will match\n // `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`.\n //\n+// The scope of the search / replace will be restricted to the current selection if any, otherwise\n+// it will apply to the whole workspace.\n+//\n // Placeholders may be given constraints by writing them as `${<name>:<constraint1>:<constraint2>...}`.\n //\n // Supported constraints:\n@@ -57,9 +60,10 @@ pub fn parse_search_replace(\n     parse_only: bool,\n     db: &RootDatabase,\n     position: FilePosition,\n+    selections: Vec<FileRange>,\n ) -> Result<Vec<SourceFileEdit>, SsrError> {\n     let rule: SsrRule = rule.parse()?;\n-    let mut match_finder = MatchFinder::in_context(db, position);\n+    let mut match_finder = MatchFinder::in_context(db, position, selections);\n     match_finder.add_rule(rule)?;\n     if parse_only {\n         return Ok(Vec::new());"}, {"sha": "73abfecb2e1e2e8227a11a608e4d7cd6e5b3803f", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=cf55806257776baf7db6b02d260bdaa9e851c7d4", "patch": "@@ -52,6 +52,7 @@ pub struct MatchFinder<'db> {\n     sema: Semantics<'db, ra_ide_db::RootDatabase>,\n     rules: Vec<ResolvedRule>,\n     resolution_scope: resolving::ResolutionScope<'db>,\n+    restrict_ranges: Vec<FileRange>,\n }\n \n impl<'db> MatchFinder<'db> {\n@@ -60,10 +61,17 @@ impl<'db> MatchFinder<'db> {\n     pub fn in_context(\n         db: &'db ra_ide_db::RootDatabase,\n         lookup_context: FilePosition,\n+        mut restrict_ranges: Vec<FileRange>,\n     ) -> MatchFinder<'db> {\n+        restrict_ranges.retain(|range| !range.range.is_empty());\n         let sema = Semantics::new(db);\n         let resolution_scope = resolving::ResolutionScope::new(&sema, lookup_context);\n-        MatchFinder { sema: Semantics::new(db), rules: Vec::new(), resolution_scope }\n+        MatchFinder {\n+            sema: Semantics::new(db),\n+            rules: Vec::new(),\n+            resolution_scope,\n+            restrict_ranges,\n+        }\n     }\n \n     /// Constructs an instance using the start of the first file in `db` as the lookup context.\n@@ -79,6 +87,7 @@ impl<'db> MatchFinder<'db> {\n             Ok(MatchFinder::in_context(\n                 db,\n                 FilePosition { file_id: first_file_id, offset: 0.into() },\n+                vec![],\n             ))\n         } else {\n             bail!(\"No files to search\");"}, {"sha": "c1b66748ec0b0c06b72cd2b0c41c39f7432021b3", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=cf55806257776baf7db6b02d260bdaa9e851c7d4", "patch": "@@ -706,8 +706,8 @@ mod tests {\n         let rule: SsrRule = \"foo($x) ==>> bar($x)\".parse().unwrap();\n         let input = \"fn foo() {} fn bar() {} fn main() { foo(1+2); }\";\n \n-        let (db, position) = crate::tests::single_file(input);\n-        let mut match_finder = MatchFinder::in_context(&db, position);\n+        let (db, position, selections) = crate::tests::single_file(input);\n+        let mut match_finder = MatchFinder::in_context(&db, position, selections);\n         match_finder.add_rule(rule).unwrap();\n         let matches = match_finder.matches();\n         assert_eq!(matches.matches.len(), 1);"}, {"sha": "0f512cb62d03f7389c7ddd8bfc6a1599dab76727", "filename": "crates/ra_ssr/src/search.rs", "status": "modified", "additions": 64, "deletions": 23, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fsearch.rs?ref=cf55806257776baf7db6b02d260bdaa9e851c7d4", "patch": "@@ -5,12 +5,13 @@ use crate::{\n     resolving::{ResolvedPath, ResolvedPattern, ResolvedRule},\n     Match, MatchFinder,\n };\n-use ra_db::FileRange;\n+use ra_db::{FileId, FileRange};\n use ra_ide_db::{\n     defs::Definition,\n     search::{Reference, SearchScope},\n };\n use ra_syntax::{ast, AstNode, SyntaxKind, SyntaxNode};\n+use rustc_hash::FxHashSet;\n use test_utils::mark;\n \n /// A cache for the results of find_usages. This is for when we have multiple patterns that have the\n@@ -54,11 +55,7 @@ impl<'db> MatchFinder<'db> {\n                         mark::hit!(use_declaration_with_braces);\n                         continue;\n                     }\n-                    if let Ok(m) =\n-                        matching::get_match(false, rule, &node_to_match, &None, &self.sema)\n-                    {\n-                        matches_out.push(m);\n-                    }\n+                    self.try_add_match(rule, &node_to_match, &None, matches_out);\n                 }\n             }\n         }\n@@ -121,25 +118,39 @@ impl<'db> MatchFinder<'db> {\n         // FIXME: We should ideally have a test that checks that we edit local roots and not library\n         // roots. This probably would require some changes to fixtures, since currently everything\n         // seems to get put into a single source root.\n-        use ra_db::SourceDatabaseExt;\n-        use ra_ide_db::symbol_index::SymbolsDatabase;\n         let mut files = Vec::new();\n-        for &root in self.sema.db.local_roots().iter() {\n-            let sr = self.sema.db.source_root(root);\n-            files.extend(sr.iter());\n-        }\n+        self.search_files_do(|file_id| {\n+            files.push(file_id);\n+        });\n         SearchScope::files(&files)\n     }\n \n     fn slow_scan(&self, rule: &ResolvedRule, matches_out: &mut Vec<Match>) {\n-        use ra_db::SourceDatabaseExt;\n-        use ra_ide_db::symbol_index::SymbolsDatabase;\n-        for &root in self.sema.db.local_roots().iter() {\n-            let sr = self.sema.db.source_root(root);\n-            for file_id in sr.iter() {\n-                let file = self.sema.parse(file_id);\n-                let code = file.syntax();\n-                self.slow_scan_node(code, rule, &None, matches_out);\n+        self.search_files_do(|file_id| {\n+            let file = self.sema.parse(file_id);\n+            let code = file.syntax();\n+            self.slow_scan_node(code, rule, &None, matches_out);\n+        })\n+    }\n+\n+    fn search_files_do(&self, mut callback: impl FnMut(FileId)) {\n+        if self.restrict_ranges.is_empty() {\n+            // Unrestricted search.\n+            use ra_db::SourceDatabaseExt;\n+            use ra_ide_db::symbol_index::SymbolsDatabase;\n+            for &root in self.sema.db.local_roots().iter() {\n+                let sr = self.sema.db.source_root(root);\n+                for file_id in sr.iter() {\n+                    callback(file_id);\n+                }\n+            }\n+        } else {\n+            // Search is restricted, deduplicate file IDs (generally only one).\n+            let mut files = FxHashSet::default();\n+            for range in &self.restrict_ranges {\n+                if files.insert(range.file_id) {\n+                    callback(range.file_id);\n+                }\n             }\n         }\n     }\n@@ -154,9 +165,7 @@ impl<'db> MatchFinder<'db> {\n         if !is_search_permitted(code) {\n             return;\n         }\n-        if let Ok(m) = matching::get_match(false, rule, &code, restrict_range, &self.sema) {\n-            matches_out.push(m);\n-        }\n+        self.try_add_match(rule, &code, restrict_range, matches_out);\n         // If we've got a macro call, we already tried matching it pre-expansion, which is the only\n         // way to match the whole macro, now try expanding it and matching the expansion.\n         if let Some(macro_call) = ast::MacroCall::cast(code.clone()) {\n@@ -178,6 +187,38 @@ impl<'db> MatchFinder<'db> {\n             self.slow_scan_node(&child, rule, restrict_range, matches_out);\n         }\n     }\n+\n+    fn try_add_match(\n+        &self,\n+        rule: &ResolvedRule,\n+        code: &SyntaxNode,\n+        restrict_range: &Option<FileRange>,\n+        matches_out: &mut Vec<Match>,\n+    ) {\n+        if !self.within_range_restrictions(code) {\n+            mark::hit!(replace_nonpath_within_selection);\n+            return;\n+        }\n+        if let Ok(m) = matching::get_match(false, rule, code, restrict_range, &self.sema) {\n+            matches_out.push(m);\n+        }\n+    }\n+\n+    /// Returns whether `code` is within one of our range restrictions if we have any. No range\n+    /// restrictions is considered unrestricted and always returns true.\n+    fn within_range_restrictions(&self, code: &SyntaxNode) -> bool {\n+        if self.restrict_ranges.is_empty() {\n+            // There is no range restriction.\n+            return true;\n+        }\n+        let node_range = self.sema.original_range(code);\n+        for range in &self.restrict_ranges {\n+            if range.file_id == node_range.file_id && range.range.contains_range(node_range.range) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n }\n \n /// Returns whether we support matching within `node` and all of its ancestors."}, {"sha": "6a44ef378c48cea65aec4f85aa50d4e6d2aa60a9", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 79, "deletions": 17, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=cf55806257776baf7db6b02d260bdaa9e851c7d4", "patch": "@@ -1,9 +1,9 @@\n use crate::{MatchFinder, SsrRule};\n use expect::{expect, Expect};\n-use ra_db::{salsa::Durability, FileId, FilePosition, SourceDatabaseExt};\n+use ra_db::{salsa::Durability, FileId, FilePosition, FileRange, SourceDatabaseExt};\n use rustc_hash::FxHashSet;\n use std::sync::Arc;\n-use test_utils::mark;\n+use test_utils::{mark, RangeOrOffset};\n \n fn parse_error_text(query: &str) -> String {\n     format!(\"{}\", query.parse::<SsrRule>().unwrap_err())\n@@ -60,29 +60,41 @@ fn parser_undefined_placeholder_in_replacement() {\n }\n \n /// `code` may optionally contain a cursor marker `<|>`. If it doesn't, then the position will be\n-/// the start of the file.\n-pub(crate) fn single_file(code: &str) -> (ra_ide_db::RootDatabase, FilePosition) {\n+/// the start of the file. If there's a second cursor marker, then we'll return a single range.\n+pub(crate) fn single_file(code: &str) -> (ra_ide_db::RootDatabase, FilePosition, Vec<FileRange>) {\n     use ra_db::fixture::WithFixture;\n     use ra_ide_db::symbol_index::SymbolsDatabase;\n-    let (mut db, position) = if code.contains(test_utils::CURSOR_MARKER) {\n-        ra_ide_db::RootDatabase::with_position(code)\n+    let (mut db, file_id, range_or_offset) = if code.contains(test_utils::CURSOR_MARKER) {\n+        ra_ide_db::RootDatabase::with_range_or_offset(code)\n     } else {\n         let (db, file_id) = ra_ide_db::RootDatabase::with_single_file(code);\n-        (db, FilePosition { file_id, offset: 0.into() })\n+        (db, file_id, RangeOrOffset::Offset(0.into()))\n     };\n+    let selections;\n+    let position;\n+    match range_or_offset {\n+        RangeOrOffset::Range(range) => {\n+            position = FilePosition { file_id, offset: range.start() };\n+            selections = vec![FileRange { file_id, range: range }];\n+        }\n+        RangeOrOffset::Offset(offset) => {\n+            position = FilePosition { file_id, offset };\n+            selections = vec![];\n+        }\n+    }\n     let mut local_roots = FxHashSet::default();\n     local_roots.insert(ra_db::fixture::WORKSPACE);\n     db.set_local_roots_with_durability(Arc::new(local_roots), Durability::HIGH);\n-    (db, position)\n+    (db, position, selections)\n }\n \n fn assert_ssr_transform(rule: &str, input: &str, expected: Expect) {\n     assert_ssr_transforms(&[rule], input, expected);\n }\n \n fn assert_ssr_transforms(rules: &[&str], input: &str, expected: Expect) {\n-    let (db, position) = single_file(input);\n-    let mut match_finder = MatchFinder::in_context(&db, position);\n+    let (db, position, selections) = single_file(input);\n+    let mut match_finder = MatchFinder::in_context(&db, position, selections);\n     for rule in rules {\n         let rule: SsrRule = rule.parse().unwrap();\n         match_finder.add_rule(rule).unwrap();\n@@ -112,8 +124,8 @@ fn print_match_debug_info(match_finder: &MatchFinder, file_id: FileId, snippet:\n }\n \n fn assert_matches(pattern: &str, code: &str, expected: &[&str]) {\n-    let (db, position) = single_file(code);\n-    let mut match_finder = MatchFinder::in_context(&db, position);\n+    let (db, position, selections) = single_file(code);\n+    let mut match_finder = MatchFinder::in_context(&db, position, selections);\n     match_finder.add_search_pattern(pattern.parse().unwrap()).unwrap();\n     let matched_strings: Vec<String> =\n         match_finder.matches().flattened().matches.iter().map(|m| m.matched_text()).collect();\n@@ -124,8 +136,8 @@ fn assert_matches(pattern: &str, code: &str, expected: &[&str]) {\n }\n \n fn assert_no_match(pattern: &str, code: &str) {\n-    let (db, position) = single_file(code);\n-    let mut match_finder = MatchFinder::in_context(&db, position);\n+    let (db, position, selections) = single_file(code);\n+    let mut match_finder = MatchFinder::in_context(&db, position, selections);\n     match_finder.add_search_pattern(pattern.parse().unwrap()).unwrap();\n     let matches = match_finder.matches().flattened().matches;\n     if !matches.is_empty() {\n@@ -135,8 +147,8 @@ fn assert_no_match(pattern: &str, code: &str) {\n }\n \n fn assert_match_failure_reason(pattern: &str, code: &str, snippet: &str, expected_reason: &str) {\n-    let (db, position) = single_file(code);\n-    let mut match_finder = MatchFinder::in_context(&db, position);\n+    let (db, position, selections) = single_file(code);\n+    let mut match_finder = MatchFinder::in_context(&db, position, selections);\n     match_finder.add_search_pattern(pattern.parse().unwrap()).unwrap();\n     let mut reasons = Vec::new();\n     for d in match_finder.debug_where_text_equal(position.file_id, snippet) {\n@@ -490,9 +502,10 @@ fn no_match_split_expression() {\n \n #[test]\n fn replace_function_call() {\n+    // This test also makes sure that we ignore empty-ranges.\n     assert_ssr_transform(\n         \"foo() ==>> bar()\",\n-        \"fn foo() {} fn bar() {} fn f1() {foo(); foo();}\",\n+        \"fn foo() {<|><|>} fn bar() {} fn f1() {foo(); foo();}\",\n         expect![[\"fn foo() {} fn bar() {} fn f1() {bar(); bar();}\"]],\n     );\n }\n@@ -922,3 +935,52 @@ fn replace_local_variable_reference() {\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn replace_path_within_selection() {\n+    assert_ssr_transform(\n+        \"foo ==>> bar\",\n+        r#\"\n+        fn main() {\n+            let foo = 41;\n+            let bar = 42;\n+            do_stuff(foo);\n+            do_stuff(foo);<|>\n+            do_stuff(foo);\n+            do_stuff(foo);<|>\n+            do_stuff(foo);\n+        }\"#,\n+        expect![[r#\"\n+            fn main() {\n+                let foo = 41;\n+                let bar = 42;\n+                do_stuff(foo);\n+                do_stuff(foo);\n+                do_stuff(bar);\n+                do_stuff(bar);\n+                do_stuff(foo);\n+            }\"#]],\n+    );\n+}\n+\n+#[test]\n+fn replace_nonpath_within_selection() {\n+    mark::check!(replace_nonpath_within_selection);\n+    assert_ssr_transform(\n+        \"$a + $b ==>> $b * $a\",\n+        r#\"\n+        fn main() {\n+            let v = 1 + 2;<|>\n+            let v2 = 3 + 3;\n+            let v3 = 4 + 5;<|>\n+            let v4 = 6 + 7;\n+        }\"#,\n+        expect![[r#\"\n+            fn main() {\n+                let v = 1 + 2;\n+                let v2 = 3 * 3;\n+                let v3 = 5 * 4;\n+                let v4 = 6 + 7;\n+            }\"#]],\n+    );\n+}"}, {"sha": "1350bd4002cdcb172b25a5e8fe2f218b2c1bcb75", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=cf55806257776baf7db6b02d260bdaa9e851c7d4", "patch": "@@ -1026,9 +1026,18 @@ pub(crate) fn handle_ssr(\n     params: lsp_ext::SsrParams,\n ) -> Result<lsp_types::WorkspaceEdit> {\n     let _p = profile(\"handle_ssr\");\n+    let selections = params\n+        .selections\n+        .iter()\n+        .map(|range| from_proto::file_range(&snap, params.position.text_document.clone(), *range))\n+        .collect::<Result<Vec<_>, _>>()?;\n     let position = from_proto::file_position(&snap, params.position)?;\n-    let source_change =\n-        snap.analysis.structural_search_replace(&params.query, params.parse_only, position)??;\n+    let source_change = snap.analysis.structural_search_replace(\n+        &params.query,\n+        params.parse_only,\n+        position,\n+        selections,\n+    )??;\n     to_proto::workspace_edit(&snap, source_change)\n }\n "}, {"sha": "3976b6529ee3554ceb3f06b89f0f5258b871dbf4", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf55806257776baf7db6b02d260bdaa9e851c7d4/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=cf55806257776baf7db6b02d260bdaa9e851c7d4", "patch": "@@ -221,6 +221,9 @@ pub struct SsrParams {\n     /// position.\n     #[serde(flatten)]\n     pub position: lsp_types::TextDocumentPositionParams,\n+\n+    /// Current selections. Search/replace will be restricted to these if non-empty.\n+    pub selections: Vec<lsp_types::Range>,\n }\n \n pub enum StatusNotification {}"}, {"sha": "d0faf4745a2ccfe5e83707e687af7773c10f55e6", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf55806257776baf7db6b02d260bdaa9e851c7d4/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cf55806257776baf7db6b02d260bdaa9e851c7d4/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=cf55806257776baf7db6b02d260bdaa9e851c7d4", "patch": "@@ -190,6 +190,7 @@ export function ssr(ctx: Ctx): Cmd {\n         if (!editor || !client) return;\n \n         const position = editor.selection.active;\n+        const selections = editor.selections;\n         const textDocument = { uri: editor.document.uri.toString() };\n \n         const options: vscode.InputBoxOptions = {\n@@ -198,7 +199,7 @@ export function ssr(ctx: Ctx): Cmd {\n             validateInput: async (x: string) => {\n                 try {\n                     await client.sendRequest(ra.ssr, {\n-                        query: x, parseOnly: true, textDocument, position,\n+                        query: x, parseOnly: true, textDocument, position, selections,\n                     });\n                 } catch (e) {\n                     return e.toString();\n@@ -215,7 +216,7 @@ export function ssr(ctx: Ctx): Cmd {\n             cancellable: false,\n         }, async (_progress, _token) => {\n             const edit = await client.sendRequest(ra.ssr, {\n-                query: request, parseOnly: false, textDocument, position\n+                query: request, parseOnly: false, textDocument, position, selections,\n             });\n \n             await vscode.workspace.applyEdit(client.protocol2CodeConverter.asWorkspaceEdit(edit));"}, {"sha": "494d51c83a1c3a2d3b94446bae866759ce5ddbc9", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf55806257776baf7db6b02d260bdaa9e851c7d4/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/cf55806257776baf7db6b02d260bdaa9e851c7d4/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=cf55806257776baf7db6b02d260bdaa9e851c7d4", "patch": "@@ -95,6 +95,7 @@ export interface SsrParams {\n     parseOnly: boolean;\n     textDocument: lc.TextDocumentIdentifier;\n     position: lc.Position;\n+    selections: lc.Range[];\n }\n export const ssr = new lc.RequestType<SsrParams, lc.WorkspaceEdit, void>('experimental/ssr');\n "}]}