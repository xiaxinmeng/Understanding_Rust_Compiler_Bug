{"sha": "2840d58dab0144c5589b60322c4f681bd8052aba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NDBkNThkYWIwMTQ0YzU1ODliNjAzMjJjNGY2ODFiZDgwNTJhYmE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-21T05:14:05Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-03T15:41:42Z"}, "message": "Overload the `==` operator\n\n- String == &str == CowString\n- Vec ==  &[T] ==  &mut [T] == [T, ..N] == CowVec\n- InternedString == &str", "tree": {"sha": "0c48a16b8c12222544acc8f2e7289381bd5af631", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c48a16b8c12222544acc8f2e7289381bd5af631"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2840d58dab0144c5589b60322c4f681bd8052aba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2840d58dab0144c5589b60322c4f681bd8052aba", "html_url": "https://github.com/rust-lang/rust/commit/2840d58dab0144c5589b60322c4f681bd8052aba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2840d58dab0144c5589b60322c4f681bd8052aba/comments", "author": null, "committer": null, "parents": [{"sha": "2578de9d6090210d9e94fd013190f387c8a88048", "url": "https://api.github.com/repos/rust-lang/rust/commits/2578de9d6090210d9e94fd013190f387c8a88048", "html_url": "https://github.com/rust-lang/rust/commit/2578de9d6090210d9e94fd013190f387c8a88048"}], "stats": {"total": 208, "additions": 187, "deletions": 21}, "files": [{"sha": "180978b3d77b6f8cba6a7290fbdd6701623f62aa", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=2840d58dab0144c5589b60322c4f681bd8052aba", "patch": "@@ -30,7 +30,7 @@ use str::{CharRange, CowString, FromStr, StrAllocating, Owned};\n use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n+#[deriving(Clone, PartialOrd, Eq, Ord)]\n #[stable]\n pub struct String {\n     vec: Vec<u8>,\n@@ -738,6 +738,49 @@ impl Extend<char> for String {\n     }\n }\n \n+impl PartialEq for String {\n+    #[inline]\n+    fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &String) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq {\n+    ($lhs:ty, $rhs: ty) => {\n+        impl<'a> PartialEq<$rhs> for $lhs {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'a> PartialEq<$lhs> for $rhs {\n+            #[inline]\n+            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+    }\n+}\n+\n+impl_eq!(String, &'a str)\n+impl_eq!(CowString<'a>, String)\n+\n+impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n+    #[inline]\n+    fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n+    #[inline]\n+    fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &CowString<'a>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n #[experimental = \"waiting on Str stabilization\"]\n impl Str for String {\n     #[inline]"}, {"sha": "8d98df8b200624f28428bfc356ad89b9d24c69ee", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 59, "deletions": 4, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=2840d58dab0144c5589b60322c4f681bd8052aba", "patch": "@@ -535,14 +535,69 @@ impl<T> Extend<T> for Vec<T> {\n     }\n }\n \n-#[unstable = \"waiting on PartialEq stability\"]\n-impl<T: PartialEq> PartialEq for Vec<T> {\n+impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n     #[inline]\n-    fn eq(&self, other: &Vec<T>) -> bool {\n-        self.as_slice() == other.as_slice()\n+    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq {\n+    ($lhs:ty, $rhs:ty) => {\n+        impl<'b, A, B> PartialEq<$rhs> for $lhs where A: PartialEq<B> {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'b, A, B> PartialEq<$lhs> for $rhs where B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+    }\n+}\n+\n+impl_eq!(Vec<A>, &'b [B])\n+impl_eq!(Vec<A>, &'b mut [B])\n+\n+impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+    #[inline]\n+    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> {\n+    #[inline]\n+    fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq_for_cowvec {\n+    ($rhs:ty) => {\n+        impl<'a, 'b, A, B> PartialEq<$rhs> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for $rhs where A: Clone, B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n     }\n }\n \n+impl_eq_for_cowvec!(&'b [B])\n+impl_eq_for_cowvec!(&'b mut [B])\n+\n #[unstable = \"waiting on PartialOrd stability\"]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]"}, {"sha": "ffaf35414ea0c41d0b3453510b8641da8fee479e", "filename": "src/libcore/array.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=2840d58dab0144c5589b60322c4f681bd8052aba", "patch": "@@ -18,6 +18,7 @@ use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n use kinds::Copy;\n+use ops::Deref;\n use option::Option;\n \n // macro for implementing n-ary tuple functions and operations\n@@ -39,17 +40,37 @@ macro_rules! array_impls {\n             }\n \n             #[unstable = \"waiting for PartialEq to stabilize\"]\n-            impl<T:PartialEq> PartialEq for [T, ..$N] {\n+            impl<A, B> PartialEq<[B, ..$N]> for [A, ..$N] where A: PartialEq<B> {\n                 #[inline]\n-                fn eq(&self, other: &[T, ..$N]) -> bool {\n+                fn eq(&self, other: &[B, ..$N]) -> bool {\n                     self[] == other[]\n                 }\n                 #[inline]\n-                fn ne(&self, other: &[T, ..$N]) -> bool {\n+                fn ne(&self, other: &[B, ..$N]) -> bool {\n                     self[] != other[]\n                 }\n             }\n \n+            impl<'a, A, B, Rhs> PartialEq<Rhs> for [A, ..$N] where\n+                A: PartialEq<B>,\n+                Rhs: Deref<[B]>,\n+            {\n+                #[inline(always)]\n+                fn eq(&self, other: &Rhs) -> bool { PartialEq::eq(self[], &**other) }\n+                #[inline(always)]\n+                fn ne(&self, other: &Rhs) -> bool { PartialEq::ne(self[], &**other) }\n+            }\n+\n+            impl<'a, A, B, Lhs> PartialEq<[B, ..$N]> for Lhs where\n+                A: PartialEq<B>,\n+                Lhs: Deref<[A]>\n+            {\n+                #[inline(always)]\n+                fn eq(&self, other: &[B, ..$N]) -> bool { PartialEq::eq(&**self, other[]) }\n+                #[inline(always)]\n+                fn ne(&self, other: &[B, ..$N]) -> bool { PartialEq::ne(&**self, other[]) }\n+            }\n+\n             #[unstable = \"waiting for Eq to stabilize\"]\n             impl<T:Eq> Eq for [T, ..$N] { }\n "}, {"sha": "b88fb914dd8b03a0bf915acf96e2b63da111a745", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=2840d58dab0144c5589b60322c4f681bd8052aba", "patch": "@@ -196,9 +196,12 @@ impl<'a, T, Sized? B> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n     }\n }\n \n-impl<'a, T, Sized? B> PartialEq for Cow<'a, T, B> where B: PartialEq + ToOwned<T> {\n+impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n+    B: PartialEq<C> + ToOwned<T>,\n+    C: ToOwned<U>,\n+{\n     #[inline]\n-    fn eq(&self, other: &Cow<'a, T, B>) -> bool {\n+    fn eq(&self, other: &Cow<'b, U, C>) -> bool {\n         PartialEq::eq(&**self, &**other)\n     }\n }"}, {"sha": "d5001a08b1dc5d7ee4084cefe93500f7b2dc782d", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=2840d58dab0144c5589b60322c4f681bd8052aba", "patch": "@@ -400,11 +400,11 @@ mod impls {\n     // & pointers\n \n     #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: PartialEq> PartialEq for &'a T {\n+    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: & &'a T) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: & &'a T) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: PartialOrd> PartialOrd for &'a T {\n@@ -432,11 +432,11 @@ mod impls {\n     // &mut pointers\n \n     #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: PartialEq> PartialEq for &'a mut T {\n+    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: &&'a mut T) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: &&'a mut T) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: PartialOrd> PartialOrd for &'a mut T {\n@@ -460,4 +460,18 @@ mod impls {\n     }\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: Eq> Eq for &'a mut T {}\n+\n+    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n+        #[inline]\n+        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n+        #[inline]\n+        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n+    }\n+\n+    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n+        #[inline]\n+        fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }\n+        #[inline]\n+        fn ne(&self, other: &&'b B) -> bool { PartialEq::ne(*self, *other) }\n+    }\n }"}, {"sha": "f9595f0663d57a5e94f4cc1ab72cc322ccda11d0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=2840d58dab0144c5589b60322c4f681bd8052aba", "patch": "@@ -2473,7 +2473,11 @@ pub mod order {\n     }\n \n     /// Compare `a` and `b` for equality (Using partial equality, `PartialEq`)\n-    pub fn eq<A: PartialEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn eq<A, B, L, R>(mut a: L, mut b: R) -> bool where\n+        A: PartialEq<B>,\n+        L: Iterator<A>,\n+        R: Iterator<B>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2484,7 +2488,11 @@ pub mod order {\n     }\n \n     /// Compare `a` and `b` for nonequality (Using partial equality, `PartialEq`)\n-    pub fn ne<A: PartialEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn ne<A, B, L, R>(mut a: L, mut b: R) -> bool where\n+        A: PartialEq<B>,\n+        L: Iterator<A>,\n+        R: Iterator<B>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,"}, {"sha": "b445dba611797920b3b9069bb7e95d27d3daec8c", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=2840d58dab0144c5589b60322c4f681bd8052aba", "patch": "@@ -1802,12 +1802,12 @@ pub mod bytes {\n //\n \n #[unstable = \"waiting for DST\"]\n-impl<T: PartialEq> PartialEq for [T] {\n-    fn eq(&self, other: &[T]) -> bool {\n+impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n+    fn eq(&self, other: &[B]) -> bool {\n         self.len() == other.len() &&\n             order::eq(self.iter(), other.iter())\n     }\n-    fn ne(&self, other: &[T]) -> bool {\n+    fn ne(&self, other: &[B]) -> bool {\n         self.len() != other.len() ||\n             order::ne(self.iter(), other.iter())\n     }"}, {"sha": "1376f59d79fcf03452de450f35129db020bd6097", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2840d58dab0144c5589b60322c4f681bd8052aba/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2840d58dab0144c5589b60322c4f681bd8052aba", "patch": "@@ -629,6 +629,28 @@ impl<'a> Equiv<&'a str> for InternedString {\n     }\n }\n \n+impl<'a> PartialEq<&'a str> for InternedString {\n+    #[inline(always)]\n+    fn eq(&self, other: & &'a str) -> bool {\n+        PartialEq::eq(self.string.as_slice(), *other)\n+    }\n+    #[inline(always)]\n+    fn ne(&self, other: & &'a str) -> bool {\n+        PartialEq::ne(self.string.as_slice(), *other)\n+    }\n+}\n+\n+impl<'a> PartialEq<InternedString > for &'a str {\n+    #[inline(always)]\n+    fn eq(&self, other: &InternedString) -> bool {\n+        PartialEq::eq(*self, other.string.as_slice())\n+    }\n+    #[inline(always)]\n+    fn ne(&self, other: &InternedString) -> bool {\n+        PartialEq::ne(*self, other.string.as_slice())\n+    }\n+}\n+\n impl<D:Decoder<E>, E> Decodable<D, E> for InternedString {\n     fn decode(d: &mut D) -> Result<InternedString, E> {\n         Ok(get_name(get_ident_interner().intern("}]}