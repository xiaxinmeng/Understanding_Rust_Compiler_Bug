{"sha": "0327df224bf67ef2c3ceb5a69729cf36a6a96ba1", "node_id": "C_kwDOAAsO6NoAKDAzMjdkZjIyNGJmNjdlZjJjM2NlYjVhNjk3MjljZjM2YTZhOTZiYTE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-05-30T14:01:17Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-05-30T14:01:17Z"}, "message": "More precise completion filtering", "tree": {"sha": "fedf71b34869af4a027853acfe4d9bc540265034", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fedf71b34869af4a027853acfe4d9bc540265034"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1", "html_url": "https://github.com/rust-lang/rust/commit/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea594c4c44ead8bffcc02c222869334c42ce3b51", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea594c4c44ead8bffcc02c222869334c42ce3b51", "html_url": "https://github.com/rust-lang/rust/commit/ea594c4c44ead8bffcc02c222869334c42ce3b51"}], "stats": {"total": 151, "additions": 115, "deletions": 36}, "files": [{"sha": "edff146d8d772045a10c3aeee65fa24cec9cb6f4", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=0327df224bf67ef2c3ceb5a69729cf36a6a96ba1", "patch": "@@ -8,21 +8,18 @@ use crate::{\n \n pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext) {\n     let _p = profile::span(\"complete_item_list\");\n-    if ctx.is_path_disallowed() || ctx.has_unfinished_impl_or_trait_prev_sibling() {\n-        return;\n-    }\n \n-    let (&is_absolute_path, qualifier) = match ctx.path_context() {\n+    let (&is_absolute_path, path_qualifier, _kind) = match ctx.path_context() {\n         Some(PathCompletionCtx {\n-            kind: PathKind::Item { .. },\n+            kind: PathKind::Item { kind },\n             is_absolute_path,\n             qualifier,\n             ..\n-        }) => (is_absolute_path, qualifier),\n+        }) => (is_absolute_path, qualifier, kind),\n         _ => return,\n     };\n \n-    match qualifier {\n+    match path_qualifier {\n         Some(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n             if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) = resolution {\n                 for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n@@ -39,13 +36,14 @@ pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext)\n         None if is_absolute_path => {\n             acc.add_crate_roots(ctx);\n         }\n-        None => {\n+        None if ctx.qualifier_ctx.none() => {\n             ctx.process_all_names(&mut |name, def| {\n                 if let Some(def) = module_or_fn_macro(ctx.db, def) {\n                     acc.add_resolution(ctx, name, def);\n                 }\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n+        None => {}\n     }\n }"}, {"sha": "281e6e9783cf30164f90c0251240b9a4cb36600d", "filename": "crates/ide-completion/src/completions/keyword.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=0327df224bf67ef2c3ceb5a69729cf36a6a96ba1", "patch": "@@ -51,7 +51,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         return;\n     }\n \n-    if !ctx.has_visibility_prev_sibling()\n+    if ctx.qualifier_ctx.vis_node.is_none()\n         && (expects_item || ctx.expects_non_trait_assoc_item() || ctx.expect_field())\n     {\n         add_keyword(\"pub(crate)\", \"pub(crate)\");\n@@ -67,7 +67,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     }\n \n     if expects_item || has_block_expr_parent {\n-        if !ctx.has_visibility_prev_sibling() {\n+        if ctx.qualifier_ctx.vis_node.is_none() {\n             add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n             add_keyword(\"extern\", \"extern $0\");\n         }"}, {"sha": "ebc3bb5a6f9b921b4f055b24370a7f31e72a84a3", "filename": "crates/ide-completion/src/completions/snippet.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=0327df224bf67ef2c3ceb5a69729cf36a6a96ba1", "patch": "@@ -2,7 +2,6 @@\n \n use hir::Documentation;\n use ide_db::{imports::insert_use::ImportScope, SnippetCap};\n-use syntax::T;\n \n use crate::{\n     context::{ItemListKind, PathCompletionCtx, PathKind},\n@@ -52,10 +51,10 @@ pub(crate) fn complete_item_snippet(acc: &mut Completions, ctx: &CompletionConte\n         }) => kind,\n         _ => return,\n     };\n-    if ctx.previous_token_is(T![unsafe]) || ctx.has_unfinished_impl_or_trait_prev_sibling() {\n+    if !ctx.qualifier_ctx.none() {\n         return;\n     }\n-    if ctx.has_visibility_prev_sibling() {\n+    if ctx.qualifier_ctx.vis_node.is_some() {\n         return; // technically we could do some of these snippet completions if we were to put the\n                 // attributes before the vis node.\n     }"}, {"sha": "b70d6f9e8dc233583a06ec51a465e5e70f6a0f22", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 105, "deletions": 7, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=0327df224bf67ef2c3ceb5a69729cf36a6a96ba1", "patch": "@@ -75,6 +75,18 @@ pub(super) enum ItemListKind {\n     ExternBlock,\n }\n \n+#[derive(Debug, Default)]\n+pub(super) struct QualifierCtx {\n+    pub(super) unsafe_tok: Option<SyntaxToken>,\n+    pub(super) vis_node: Option<ast::Visibility>,\n+}\n+\n+impl QualifierCtx {\n+    pub(super) fn none(&self) -> bool {\n+        self.unsafe_tok.is_none() && self.vis_node.is_none()\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct PathCompletionCtx {\n     /// If this is a call with () already there (or {} in case of record patterns)\n@@ -253,6 +265,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) ident_ctx: IdentContext,\n \n     pub(super) pattern_ctx: Option<PatternContext>,\n+    pub(super) qualifier_ctx: QualifierCtx,\n \n     pub(super) existing_derives: FxHashSet<hir::Macro>,\n \n@@ -363,17 +376,13 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.prev_sibling, Some(ImmediatePrevSibling::ImplDefType))\n     }\n \n-    pub(crate) fn has_visibility_prev_sibling(&self) -> bool {\n-        matches!(self.prev_sibling, Some(ImmediatePrevSibling::Visibility))\n-    }\n-\n     pub(crate) fn after_if(&self) -> bool {\n         matches!(self.prev_sibling, Some(ImmediatePrevSibling::IfExpr))\n     }\n \n     // FIXME: This shouldn't exist\n     pub(crate) fn is_path_disallowed(&self) -> bool {\n-        self.previous_token_is(T![unsafe])\n+        !self.qualifier_ctx.none()\n             || matches!(self.prev_sibling, Some(ImmediatePrevSibling::Visibility))\n             || (matches!(self.name_ctx(), Some(NameContext { .. })) && self.pattern_ctx.is_none())\n             || matches!(self.pattern_ctx, Some(PatternContext { record_pat: Some(_), .. }))\n@@ -555,6 +564,7 @@ impl<'a> CompletionContext<'a> {\n             // dummy value, will be overwritten\n             ident_ctx: IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: None },\n             pattern_ctx: None,\n+            qualifier_ctx: Default::default(),\n             existing_derives: Default::default(),\n             locals,\n         };\n@@ -865,7 +875,7 @@ impl<'a> CompletionContext<'a> {\n         offset: TextSize,\n         derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize, ast::Attr)>,\n     ) -> Option<()> {\n-        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n+        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased()?;\n         let syntax_element = NodeOrToken::Token(fake_ident_token);\n         if is_in_token_of_for_loop(syntax_element.clone()) {\n             // for pat $0\n@@ -967,7 +977,49 @@ impl<'a> CompletionContext<'a> {\n             ast::NameLike::NameRef(name_ref) => {\n                 let parent = name_ref.syntax().parent()?;\n                 let (nameref_ctx, pat_ctx) =\n-                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent);\n+                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent.clone());\n+\n+                // Extract qualifiers\n+                if let Some(path_ctx) = &nameref_ctx.path_ctx {\n+                    if path_ctx.qualifier.is_none() {\n+                        let top = match path_ctx.kind {\n+                            PathKind::Expr { in_block_expr: true, .. } => parent\n+                                .ancestors()\n+                                .find(|it| ast::PathExpr::can_cast(it.kind()))\n+                                .and_then(|p| {\n+                                    let parent = p.parent()?;\n+                                    if ast::StmtList::can_cast(parent.kind()) {\n+                                        Some(p)\n+                                    } else if ast::ExprStmt::can_cast(parent.kind()) {\n+                                        Some(parent)\n+                                    } else {\n+                                        None\n+                                    }\n+                                }),\n+                            PathKind::Item { .. } => {\n+                                parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n+                            }\n+                            _ => None,\n+                        };\n+                        if let Some(top) = top {\n+                            if let Some(NodeOrToken::Node(error_node)) =\n+                                syntax::algo::non_trivia_sibling(\n+                                    top.into(),\n+                                    syntax::Direction::Prev,\n+                                )\n+                            {\n+                                if error_node.kind() == SyntaxKind::ERROR {\n+                                    self.qualifier_ctx.unsafe_tok = error_node\n+                                        .children_with_tokens()\n+                                        .filter_map(NodeOrToken::into_token)\n+                                        .find(|it| it.kind() == T![unsafe]);\n+                                    self.qualifier_ctx.vis_node =\n+                                        error_node.children().find_map(ast::Visibility::cast);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n                 self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n                 self.pattern_ctx = pat_ctx;\n             }\n@@ -1145,12 +1197,54 @@ impl<'a> CompletionContext<'a> {\n             }\n         };\n \n+        // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.\n+        // ex. trait Foo $0 {}\n+        // in these cases parser recovery usually kicks in for our inserted identifier, causing it\n+        // to either be parsed as an ExprStmt or a MacroCall, depending on whether it is in a block\n+        // expression or an item list.\n+        // The following code checks if the body is missing, if it is we either cut off the body\n+        // from the item or it was missing in the first place\n+        let inbetween_body_and_decl_check = |node: SyntaxNode| {\n+            if let Some(NodeOrToken::Node(n)) =\n+                syntax::algo::non_trivia_sibling(node.into(), syntax::Direction::Prev)\n+            {\n+                if let Some(item) = ast::Item::cast(n) {\n+                    match item {\n+                        ast::Item::Const(it) => it.body().is_none(),\n+                        ast::Item::Enum(it) => it.variant_list().is_none(),\n+                        ast::Item::ExternBlock(it) => it.extern_item_list().is_none(),\n+                        ast::Item::Fn(it) => it.body().is_none(),\n+                        ast::Item::Impl(it) => it.assoc_item_list().is_none(),\n+                        ast::Item::Module(it) => it.item_list().is_none(),\n+                        ast::Item::Static(it) => it.body().is_none(),\n+                        ast::Item::Struct(it) => it.field_list().is_none(),\n+                        ast::Item::Trait(it) => it.assoc_item_list().is_none(),\n+                        ast::Item::TypeAlias(it) => it.ty().is_none(),\n+                        ast::Item::Union(it) => it.record_field_list().is_none(),\n+                        _ => false,\n+                    }\n+                } else {\n+                    false\n+                }\n+            } else {\n+                false\n+            }\n+        };\n+\n         let kind = path.syntax().ancestors().find_map(|it| {\n             // using Option<Option<PathKind>> as extra controlflow\n             let kind = match_ast! {\n                 match it {\n                     ast::PathType(_) => Some(PathKind::Type),\n                     ast::PathExpr(it) => {\n+                        if let Some(p) = it.syntax().parent() {\n+                            if ast::ExprStmt::can_cast(p.kind()) {\n+                                if inbetween_body_and_decl_check(p) {\n+                                    return Some(None);\n+                                }\n+                            }\n+                        }\n+\n                         fill_record_expr(it.syntax());\n \n                         path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n@@ -1173,6 +1267,10 @@ impl<'a> CompletionContext<'a> {\n                         Some(PathKind::Pat)\n                     },\n                     ast::MacroCall(it) => {\n+                        if inbetween_body_and_decl_check(it.syntax().clone()) {\n+                            return Some(None);\n+                        }\n+\n                         path_ctx.has_macro_bang = it.excl_token().is_some();\n                         let parent = it.syntax().parent();\n                         match parent.as_ref().map(|it| it.kind()) {"}, {"sha": "537c9a7fa2415c1830c1254ac9a55901412d188a", "filename": "crates/ide-completion/src/tests/item.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs?ref=0327df224bf67ef2c3ceb5a69729cf36a6a96ba1", "patch": "@@ -92,10 +92,7 @@ fn after_struct_name() {\n     check(\n         r\"struct Struct $0\",\n         expect![[r#\"\n-            ma makro!(\u2026)           macro_rules! makro\n-            md module\n             kw const\n-            kw crate::\n             kw enum\n             kw extern\n             kw fn\n@@ -104,18 +101,13 @@ fn after_struct_name() {\n             kw pub\n             kw pub(crate)\n             kw pub(super)\n-            kw self::\n             kw static\n             kw struct\n-            kw super::\n             kw trait\n             kw type\n             kw union\n             kw unsafe\n             kw use\n-            sn macro_rules\n-            sn tfn (Test function)\n-            sn tmod (Test module)\n         \"#]],\n     );\n }\n@@ -126,10 +118,7 @@ fn after_fn_name() {\n     check(\n         r\"fn func() $0\",\n         expect![[r#\"\n-            ma makro!(\u2026)           macro_rules! makro\n-            md module\n             kw const\n-            kw crate::\n             kw enum\n             kw extern\n             kw fn\n@@ -138,18 +127,13 @@ fn after_fn_name() {\n             kw pub\n             kw pub(crate)\n             kw pub(super)\n-            kw self::\n             kw static\n             kw struct\n-            kw super::\n             kw trait\n             kw type\n             kw union\n             kw unsafe\n             kw use\n-            sn macro_rules\n-            sn tfn (Test function)\n-            sn tmod (Test module)\n         \"#]],\n     );\n }"}]}