{"sha": "efc8f65b852b7ce5203ce22f54066a0e647019a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYzhmNjViODUyYjdjZTUyMDNjZTIyZjU0MDY2YTBlNjQ3MDE5YTU=", "commit": {"author": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-05-09T00:56:59Z"}, "committer": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-05-09T00:56:59Z"}, "message": "Try to fix issue 68049", "tree": {"sha": "073ce7294f366fe7aaa88ecda18b4c97e3ff6851", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/073ce7294f366fe7aaa88ecda18b4c97e3ff6851"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efc8f65b852b7ce5203ce22f54066a0e647019a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efc8f65b852b7ce5203ce22f54066a0e647019a5", "html_url": "https://github.com/rust-lang/rust/commit/efc8f65b852b7ce5203ce22f54066a0e647019a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efc8f65b852b7ce5203ce22f54066a0e647019a5/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1773f14a24c49356b384e45ebb45643bc9bef2c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1773f14a24c49356b384e45ebb45643bc9bef2c4", "html_url": "https://github.com/rust-lang/rust/commit/1773f14a24c49356b384e45ebb45643bc9bef2c4"}], "stats": {"total": 180, "additions": 170, "deletions": 10}, "files": [{"sha": "88ba112c8d5592f30c994475d7904b4441641a09", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 103, "deletions": 10, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/efc8f65b852b7ce5203ce22f54066a0e647019a5/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc8f65b852b7ce5203ce22f54066a0e647019a5/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=efc8f65b852b7ce5203ce22f54066a0e647019a5", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::{\n     hir::place::PlaceBase,\n-    mir::{self, ClearCrossCrate, Local, LocalDecl, LocalInfo, Location},\n+    mir::{self, ClearCrossCrate, Local, LocalDecl, LocalInfo, LocalKind, Location},\n };\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, Symbol};\n@@ -424,15 +424,108 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                         match label {\n                             Some((true, err_help_span, suggested_code)) => {\n-                                err.span_suggestion(\n-                                    err_help_span,\n-                                    &format!(\n-                                        \"consider changing this to be a mutable {}\",\n-                                        pointer_desc\n-                                    ),\n-                                    suggested_code,\n-                                    Applicability::MachineApplicable,\n-                                );\n+                                /// User cannot make signature of a trait mutable\n+                                /// without changing the trait. So we find if this\n+                                /// error belongs to a trait and if so we move\n+                                /// suggestion to the trait or disable it if it is\n+                                /// out of scope of this crate\n+                                let (is_trait_sig, local_trait) = {\n+                                    if self.body.local_kind(local) != LocalKind::Arg {\n+                                        (false, None)\n+                                    } else {\n+                                        let hir_map = self.infcx.tcx.hir();\n+                                        let my_hir = hir_map.local_def_id_to_hir_id(\n+                                            self.body.source.def_id().as_local().unwrap(),\n+                                        );\n+                                        match hir_map.find(hir_map.get_parent_node(my_hir)) {\n+                                            Some(Node::Item(hir::Item {\n+                                                kind:\n+                                                    hir::ItemKind::Impl(hir::Impl {\n+                                                        of_trait:\n+                                                            Some(hir::TraitRef {\n+                                                                path:\n+                                                                    hir::Path {\n+                                                                        res:\n+                                                                            hir::def::Res::Def(_, td),\n+                                                                        ..\n+                                                                    },\n+                                                                ..\n+                                                            }),\n+                                                        ..\n+                                                    }),\n+                                                ..\n+                                            })) => {\n+                                                (true, td.as_local().and_then(|tld| {\n+                                                    let h = hir_map.local_def_id_to_hir_id(tld);\n+                                                    match hir_map.find(h) {\n+                                                        Some(Node::Item(hir::Item {\n+                                                            kind: hir::ItemKind::Trait(\n+                                                                _, _, _, _,\n+                                                                items\n+                                                            ),\n+                                                            ..\n+                                                        })) => {\n+                                                            let mut f_in_trait_opt = None;\n+                                                            for hir::TraitItemRef { id: fi, kind: k, .. } in *items {\n+                                                                let hi = fi.hir_id();\n+                                                                if !matches!(k, hir::AssocItemKind::Fn { .. }) {\n+                                                                    continue;\n+                                                                }\n+                                                                if hir_map.name(hi) != hir_map.name(my_hir) {\n+                                                                    continue;\n+                                                                }\n+                                                                f_in_trait_opt = Some(hi);\n+                                                                break;\n+                                                            }\n+                                                            f_in_trait_opt.and_then(|f_in_trait| {\n+                                                                match hir_map.find(f_in_trait) {\n+                                                                    Some(Node::TraitItem(hir::TraitItem {\n+                                                                        kind: hir::TraitItemKind::Fn(hir::FnSig {\n+                                                                            decl: hir::FnDecl {\n+                                                                                inputs,\n+                                                                                ..\n+                                                                            },\n+                                                                            ..\n+                                                                        }, _),\n+                                                                        ..\n+                                                                    })) => {\n+                                                                        let hir::Ty { span, .. } = inputs[local.index() - 1];\n+                                                                        Some(span)\n+                                                                    },\n+                                                                    _ => None,\n+                                                                }\n+                                                            })\n+                                                            //Some(hir_map.span(h))\n+                                                        }\n+                                                        _ => None\n+                                                    }\n+                                                }))\n+                                            }\n+                                            _ => (false, None),\n+                                        }\n+                                    }\n+                                };\n+                                if !is_trait_sig {\n+                                    err.span_suggestion(\n+                                        err_help_span,\n+                                        &format!(\n+                                            \"consider changing this to be a mutable {}\",\n+                                            pointer_desc\n+                                        ),\n+                                        suggested_code,\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                } else if let Some(x) = local_trait {\n+                                    err.span_suggestion(\n+                                        x,\n+                                        &format!(\n+                                            \"consider changing that to be a mutable {}\",\n+                                            pointer_desc\n+                                        ),\n+                                        suggested_code,\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                }\n                             }\n                             Some((false, err_label_span, message)) => {\n                                 err.span_label(err_label_span, &message);"}, {"sha": "9b9ae429aebdcc1118f944a5526b41b62cb7555f", "filename": "src/test/ui/suggestions/issue-68049-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efc8f65b852b7ce5203ce22f54066a0e647019a5/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc8f65b852b7ce5203ce22f54066a0e647019a5/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-1.rs?ref=efc8f65b852b7ce5203ce22f54066a0e647019a5", "patch": "@@ -0,0 +1,16 @@\n+use std::alloc::{GlobalAlloc, Layout};\n+\n+struct Test(u32);\n+\n+unsafe impl GlobalAlloc for Test {\n+    unsafe fn alloc(&self, _layout: Layout) -> *mut u8 {\n+        self.0 += 1;\n+        0 as *mut u8\n+    }\n+\n+    unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {\n+        unimplemented!();\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "32367d2d0cf213b1acc49cd88865911899572709", "filename": "src/test/ui/suggestions/issue-68049-1.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/efc8f65b852b7ce5203ce22f54066a0e647019a5/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efc8f65b852b7ce5203ce22f54066a0e647019a5/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-1.stderr?ref=efc8f65b852b7ce5203ce22f54066a0e647019a5", "patch": "@@ -0,0 +1,9 @@\n+error[E0594]: cannot assign to `self.0` which is behind a `&` reference\n+  --> $DIR/issue-68049-1.rs:7:9\n+   |\n+LL |         self.0 += 1;\n+   |         ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be written\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "22bb6b85d6ffeb0c6bff2a0ac296c3e342c6ceb7", "filename": "src/test/ui/suggestions/issue-68049-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efc8f65b852b7ce5203ce22f54066a0e647019a5/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc8f65b852b7ce5203ce22f54066a0e647019a5/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-2.rs?ref=efc8f65b852b7ce5203ce22f54066a0e647019a5", "patch": "@@ -0,0 +1,21 @@\n+trait Hello {\n+  fn example(&self, input: &i32); // should suggest here\n+}\n+\n+struct Test1(i32);\n+\n+impl Hello for Test1 {\n+  fn example(&self, input: &i32) { // should not suggest here\n+      *input = self.0;\n+  }\n+}\n+\n+struct Test2(i32);\n+\n+impl Hello for Test2 {\n+  fn example(&self, input: &i32) { // should not suggest here\n+    self.0 += *input;\n+  }\n+}\n+\n+fn main() { }"}, {"sha": "f10a83c68a81b062a6cb84c8ab28b168f29ec447", "filename": "src/test/ui/suggestions/issue-68049-2.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efc8f65b852b7ce5203ce22f54066a0e647019a5/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efc8f65b852b7ce5203ce22f54066a0e647019a5/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-68049-2.stderr?ref=efc8f65b852b7ce5203ce22f54066a0e647019a5", "patch": "@@ -0,0 +1,21 @@\n+error[E0594]: cannot assign to `*input` which is behind a `&` reference\n+  --> $DIR/issue-68049-2.rs:9:7\n+   |\n+LL |   fn example(&self, input: &i32); // should suggest here\n+   |                            ---- help: consider changing that to be a mutable reference: `&mut i32`\n+...\n+LL |       *input = self.0;\n+   |       ^^^^^^^^^^^^^^^ `input` is a `&` reference, so the data it refers to cannot be written\n+\n+error[E0594]: cannot assign to `self.0` which is behind a `&` reference\n+  --> $DIR/issue-68049-2.rs:17:5\n+   |\n+LL |   fn example(&self, input: &i32); // should suggest here\n+   |              ----- help: consider changing that to be a mutable reference: `&mut self`\n+...\n+LL |     self.0 += *input;\n+   |     ^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be written\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0594`."}]}