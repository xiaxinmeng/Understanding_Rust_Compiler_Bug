{"sha": "1c3dc294cefcb92b23581273c24c220c74618a02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjM2RjMjk0Y2VmY2I5MmIyMzU4MTI3M2MyNGMyMjBjNzQ2MThhMDI=", "commit": {"author": {"name": "Kevin Murphy", "email": "kemurphy.cmu@gmail.com", "date": "2013-07-23T15:52:44Z"}, "committer": {"name": "Kevin Murphy", "email": "kemurphy.cmu@gmail.com", "date": "2013-07-25T03:54:40Z"}, "message": "Allow uint discriminants and store them as such\n\nInfers type of constants used as discriminants and ensures they are\nintegral, instead of forcing them to be a signed integer.\n\nAlso, stores discriminant values as uint instead of int interally and\ndeals with related fallout.\n\nFixes issue #7994", "tree": {"sha": "d6234f2fb9136d7f83897338f62e2336e1df706f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6234f2fb9136d7f83897338f62e2336e1df706f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c3dc294cefcb92b23581273c24c220c74618a02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c3dc294cefcb92b23581273c24c220c74618a02", "html_url": "https://github.com/rust-lang/rust/commit/1c3dc294cefcb92b23581273c24c220c74618a02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c3dc294cefcb92b23581273c24c220c74618a02/comments", "author": {"login": "kemurphy", "id": 1501435, "node_id": "MDQ6VXNlcjE1MDE0MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1501435?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kemurphy", "html_url": "https://github.com/kemurphy", "followers_url": "https://api.github.com/users/kemurphy/followers", "following_url": "https://api.github.com/users/kemurphy/following{/other_user}", "gists_url": "https://api.github.com/users/kemurphy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kemurphy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kemurphy/subscriptions", "organizations_url": "https://api.github.com/users/kemurphy/orgs", "repos_url": "https://api.github.com/users/kemurphy/repos", "events_url": "https://api.github.com/users/kemurphy/events{/privacy}", "received_events_url": "https://api.github.com/users/kemurphy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kemurphy", "id": 1501435, "node_id": "MDQ6VXNlcjE1MDE0MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1501435?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kemurphy", "html_url": "https://github.com/kemurphy", "followers_url": "https://api.github.com/users/kemurphy/followers", "following_url": "https://api.github.com/users/kemurphy/following{/other_user}", "gists_url": "https://api.github.com/users/kemurphy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kemurphy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kemurphy/subscriptions", "organizations_url": "https://api.github.com/users/kemurphy/orgs", "repos_url": "https://api.github.com/users/kemurphy/repos", "events_url": "https://api.github.com/users/kemurphy/events{/privacy}", "received_events_url": "https://api.github.com/users/kemurphy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a726f0573dcfcd01ae9b37266014df0e26f2e22", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a726f0573dcfcd01ae9b37266014df0e26f2e22", "html_url": "https://github.com/rust-lang/rust/commit/4a726f0573dcfcd01ae9b37266014df0e26f2e22"}], "stats": {"total": 114, "additions": 59, "deletions": 55}, "files": [{"sha": "480661b263ab864b5d678960a48cfbfd1d627589", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1c3dc294cefcb92b23581273c24c220c74618a02", "patch": "@@ -23,7 +23,7 @@ use metadata::tydecode::{parse_ty_data, parse_def_id,\n use middle::ty;\n \n use std::hash::HashUtil;\n-use std::int;\n+use std::uint;\n use std::io::WriterUtil;\n use std::io;\n use std::option;\n@@ -200,9 +200,9 @@ fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n     return true;\n }\n \n-fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n+fn variant_disr_val(d: ebml::Doc) -> Option<uint> {\n     do reader::maybe_get_doc(d, tag_disr_val).chain |val_doc| {\n-        do reader::with_doc_data(val_doc) |data| { int::parse_bytes(data, 10u) }\n+        do reader::with_doc_data(val_doc) |data| { uint::parse_bytes(data, 10u) }\n     }\n }\n "}, {"sha": "8d1f086b3a7769a754b2354037a99e51dff1be3e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1c3dc294cefcb92b23581273c24c220c74618a02", "patch": "@@ -21,7 +21,6 @@ use middle;\n \n use std::hash::HashUtil;\n use std::hashmap::{HashMap, HashSet};\n-use std::int;\n use std::io;\n use std::str;\n use std::uint;\n@@ -290,9 +289,9 @@ fn encode_discriminant(ecx: &EncodeContext,\n \n fn encode_disr_val(_: &EncodeContext,\n                    ebml_w: &mut writer::Encoder,\n-                   disr_val: int) {\n+                   disr_val: uint) {\n     ebml_w.start_tag(tag_disr_val);\n-    let s = int::to_str(disr_val);\n+    let s = uint::to_str(disr_val);\n     ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }"}, {"sha": "648dd0332876b6b286e8637bb28ad580d388553d", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1c3dc294cefcb92b23581273c24c220c74618a02", "patch": "@@ -193,7 +193,7 @@ pub enum Lit {\n // range)\n pub enum Opt {\n     lit(Lit),\n-    var(/* disr val */int, @adt::Repr),\n+    var(/* disr val */ uint, @adt::Repr),\n     range(@ast::expr, @ast::expr),\n     vec_len_eq(uint),\n     vec_len_ge(uint, /* slice */uint)\n@@ -874,7 +874,7 @@ pub struct ExtractedBlock {\n \n pub fn extract_variant_args(bcx: @mut Block,\n                             repr: &adt::Repr,\n-                            disr_val: int,\n+                            disr_val: uint,\n                             val: ValueRef)\n     -> ExtractedBlock {\n     let _icx = push_ctxt(\"match::extract_variant_args\");"}, {"sha": "4a541c17a23a28345ee46c8b13013c98d3030b58", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=1c3dc294cefcb92b23581273c24c220c74618a02", "patch": "@@ -64,7 +64,7 @@ use middle::trans::type_::Type;\n /// Representations.\n pub enum Repr {\n     /// C-like enums; basically an int.\n-    CEnum(int, int), // discriminant range\n+    CEnum(uint, uint), // discriminant range\n     /**\n      * Single-case variants, and structs/tuples/records.\n      *\n@@ -89,7 +89,7 @@ pub enum Repr {\n      * is represented such that `None` is a null pointer and `Some` is the\n      * identity function.\n      */\n-    NullablePointer{ nonnull: Struct, nndiscr: int, ptrfield: uint,\n+    NullablePointer{ nonnull: Struct, nndiscr: uint, ptrfield: uint,\n                      nullfields: ~[ty::t] }\n }\n \n@@ -140,7 +140,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             return Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n-            struct Case { discr: int, tys: ~[ty::t] };\n+            struct Case { discr: uint, tys: ~[ty::t] };\n             impl Case {\n                 fn is_zerolen(&self, cx: &mut CrateContext) -> bool {\n                     mk_struct(cx, self.tys, false).size == 0\n@@ -177,7 +177,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             // Since there's at least one\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n-            if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as int)) {\n+            if !cases.iter().enumerate().all(|(i,c)| c.discr == i) {\n                 cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n                                   discriminants\",\n                                  ty::item_path_str(cx.tcx, def_id)))\n@@ -206,7 +206,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             }\n \n             // The general case.\n-            let discr = ~[ty::mk_int()];\n+            let discr = ~[ty::mk_uint()];\n             return General(cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n         }\n         _ => cx.sess.bug(\"adt::represent_type called on non-ADT type\")\n@@ -305,17 +305,16 @@ pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n     -> ValueRef {\n     match *r {\n         CEnum(min, max) => load_discr(bcx, scrutinee, min, max),\n-        Univariant(*) => C_int(bcx.ccx(), 0),\n-        General(ref cases) => load_discr(bcx, scrutinee, 0,\n-                                         (cases.len() - 1) as int),\n+        Univariant(*) => C_uint(bcx.ccx(), 0),\n+        General(ref cases) => load_discr(bcx, scrutinee, 0, cases.len() - 1),\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             ZExt(bcx, nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee),\n                  Type::enum_discrim(bcx.ccx()))\n         }\n     }\n }\n \n-fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: int, ptrfield: uint,\n+fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: uint, ptrfield: uint,\n                      scrutinee: ValueRef) -> ValueRef {\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n@@ -324,7 +323,7 @@ fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: int, ptrfield:\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: int, max: int)\n+fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: uint, max: uint)\n     -> ValueRef {\n     let ptr = GEPi(bcx, scrutinee, [0, 0]);\n     if max + 1 == min {\n@@ -348,16 +347,16 @@ fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: int, max: int)\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_case(bcx: @mut Block, r: &Repr, discr: int) -> _match::opt_result {\n+pub fn trans_case(bcx: @mut Block, r: &Repr, discr: uint) -> _match::opt_result {\n     match *r {\n         CEnum(*) => {\n-            _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n+            _match::single_result(rslt(bcx, C_uint(bcx.ccx(), discr)))\n         }\n         Univariant(*) => {\n             bcx.ccx().sess.bug(\"no cases for univariants or structs\")\n         }\n         General(*) => {\n-            _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n+            _match::single_result(rslt(bcx, C_uint(bcx.ccx(), discr)))\n         }\n         NullablePointer{ _ } => {\n             assert!(discr == 0 || discr == 1);\n@@ -371,11 +370,11 @@ pub fn trans_case(bcx: @mut Block, r: &Repr, discr: int) -> _match::opt_result {\n  * representation.  The fields, if any, should then be initialized via\n  * `trans_field_ptr`.\n  */\n-pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: int) {\n+pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: uint) {\n     match *r {\n         CEnum(min, max) => {\n             assert!(min <= discr && discr <= max);\n-            Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+            Store(bcx, C_uint(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n         Univariant(ref st, true) => {\n             assert_eq!(discr, 0);\n@@ -386,7 +385,7 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: int) {\n             assert_eq!(discr, 0);\n         }\n         General(*) => {\n-            Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+            Store(bcx, C_uint(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             if discr != nndiscr {\n@@ -402,22 +401,22 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: int) {\n  * The number of fields in a given case; for use when obtaining this\n  * information from the type or definition is less convenient.\n  */\n-pub fn num_args(r: &Repr, discr: int) -> uint {\n+pub fn num_args(r: &Repr, discr: uint) -> uint {\n     match *r {\n         CEnum(*) => 0,\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n-        General(ref cases) => cases[discr as uint].fields.len() - 1,\n+        General(ref cases) => cases[discr].fields.len() - 1,\n         NullablePointer{ nonnull: ref nonnull, nndiscr, nullfields: ref nullfields, _ } => {\n             if discr == nndiscr { nonnull.fields.len() } else { nullfields.len() }\n         }\n     }\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: int,\n+pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: uint,\n                        ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n@@ -431,7 +430,7 @@ pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: int,\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(ref cases) => {\n-            struct_field_ptr(bcx, &cases[discr as uint], val, ix + 1, true)\n+            struct_field_ptr(bcx, &cases[discr], val, ix + 1, true)\n         }\n         NullablePointer{ nonnull: ref nonnull, nullfields: ref nullfields, nndiscr, _ } => {\n             if (discr == nndiscr) {\n@@ -495,22 +494,22 @@ pub fn trans_drop_flag_ptr(bcx: @mut Block, r: &Repr, val: ValueRef) -> ValueRef\n  * this could be changed in the future to avoid allocating unnecessary\n  * space after values of shorter-than-maximum cases.\n  */\n-pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: int,\n+pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: uint,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n         CEnum(min, max) => {\n             assert_eq!(vals.len(), 0);\n             assert!(min <= discr && discr <= max);\n-            C_int(ccx, discr)\n+            C_uint(ccx, discr)\n         }\n         Univariant(ref st, _dro) => {\n             assert_eq!(discr, 0);\n             C_struct(build_const_struct(ccx, st, vals))\n         }\n         General(ref cases) => {\n-            let case = &cases[discr as uint];\n+            let case = &cases[discr];\n             let max_sz = cases.iter().transform(|x| x.size).max().unwrap();\n-            let discr_ty = C_int(ccx, discr);\n+            let discr_ty = C_uint(ccx, discr);\n             let contents = build_const_struct(ccx, case,\n                                               ~[discr_ty] + vals);\n             C_struct(contents + &[padding(max_sz - case.size)])\n@@ -582,13 +581,18 @@ fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.  (Not currently used.)\n pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n-    -> int {\n+    -> uint {\n     match *r {\n-        CEnum(*) => const_to_int(val) as int,\n+        CEnum(*) => const_to_uint(val) as uint,\n         Univariant(*) => 0,\n-        General(*) => const_to_int(const_get_elt(ccx, val, [0])) as int,\n+        General(*) => const_to_uint(const_get_elt(ccx, val, [0])) as uint,\n         NullablePointer{ nndiscr, ptrfield, _ } => {\n-            if is_null(const_struct_field(ccx, val, ptrfield)) { 1 - nndiscr } else { nndiscr }\n+            if is_null(const_struct_field(ccx, val, ptrfield)) {\n+                /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n+                (1 - nndiscr) as uint\n+            } else {\n+                nndiscr\n+            }\n         }\n     }\n }\n@@ -601,7 +605,7 @@ pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n  * raw LLVM-level structs and arrays.)\n  */\n pub fn const_get_field(ccx: &mut CrateContext, r: &Repr, val: ValueRef,\n-                       _discr: int, ix: uint) -> ValueRef {\n+                       _discr: uint, ix: uint) -> ValueRef {\n     match *r {\n         CEnum(*) => ccx.sess.bug(\"element access in C-like enum const\"),\n         Univariant(*) => const_struct_field(ccx, val, ix),"}, {"sha": "437d1a50d185e028ca5d8acf091e91a0b6fa0da2", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1c3dc294cefcb92b23581273c24c220c74618a02", "patch": "@@ -67,7 +67,6 @@ use middle::trans::type_::Type;\n \n use std::hash;\n use std::hashmap::{HashMap, HashSet};\n-use std::int;\n use std::io;\n use std::libc::c_uint;\n use std::uint;\n@@ -732,7 +731,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n                   for (*variants).iter().advance |variant| {\n                       let variant_cx =\n                           sub_block(cx, ~\"enum-iter-variant-\" +\n-                                    int::to_str(variant.disr_val));\n+                                    uint::to_str(variant.disr_val));\n                       let variant_cx =\n                           iter_variant(variant_cx, repr, av, *variant,\n                                        substs.tps, |x,y,z| f(x,y,z));\n@@ -1979,7 +1978,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n                           _enum_id: ast::node_id,\n                           variant: &ast::variant,\n                           args: &[ast::variant_arg],\n-                          disr: int,\n+                          disr: uint,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n@@ -2028,7 +2027,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     ccx: @mut CrateContext,\n     ctor_id: ast::node_id,\n     args: &[A],\n-    disr: int,\n+    disr: uint,\n     param_substs: Option<@param_substs>,\n     llfndecl: ValueRef)\n {\n@@ -2628,7 +2627,7 @@ pub fn trans_constant(ccx: &mut CrateContext, it: @ast::item) {\n                 }\n             };\n             unsafe {\n-                llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, disr_val));\n+                llvm::LLVMSetInitializer(discrim_gvar, C_uint(ccx, disr_val));\n                 llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n             }\n             ccx.discrims.insert("}, {"sha": "db9e3db2c0fda41f8603dcb2f04c2e4a9f153a07", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=1c3dc294cefcb92b23581273c24c220c74618a02", "patch": "@@ -446,7 +446,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               (expr::cast_enum, expr::cast_float)  => {\n                 let repr = adt::represent_type(cx, basety);\n                 let discr = adt::const_get_discrim(cx, repr, v);\n-                let iv = C_int(cx, discr);\n+                let iv = C_uint(cx, discr);\n                 let ety_cast = expr::cast_type_kind(ety);\n                 match ety_cast {\n                     expr::cast_integral => {"}, {"sha": "c038ca710aa4f01bd4068c2ef3357bd66a65f988", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=1c3dc294cefcb92b23581273c24c220c74618a02", "patch": "@@ -1083,7 +1083,7 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::def) -> Datum {\n pub fn with_field_tys<R>(tcx: ty::ctxt,\n                          ty: ty::t,\n                          node_id_opt: Option<ast::node_id>,\n-                         op: &fn(int, (&[ty::field])) -> R) -> R {\n+                         op: &fn(uint, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_fields(tcx, did, substs))\n@@ -1200,7 +1200,7 @@ struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: int,\n+fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: uint,\n              fields: &[(uint, @ast::expr)],\n              optbase: Option<StructBaseInfo>,\n              dest: Dest) -> @mut Block {"}, {"sha": "3d23828979f44038d121196fa3116bc3ef3505d3", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=1c3dc294cefcb92b23581273c24c220c74618a02", "patch": "@@ -321,7 +321,7 @@ impl Reflector {\n                 for variants.iter().enumerate().advance |(i, v)| {\n                     let name = ccx.sess.str_of(v.name);\n                     let variant_args = ~[this.c_uint(i),\n-                                         this.c_int(v.disr_val),\n+                                         this.c_uint(v.disr_val),\n                                          this.c_uint(v.args.len()),\n                                          this.c_slice(name)];\n                     do this.bracketed(\"enum_variant\", variant_args) |this| {"}, {"sha": "20c39cc84eff920da35a4d83ae5b7abfa26a641f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1c3dc294cefcb92b23581273c24c220c74618a02", "patch": "@@ -49,7 +49,7 @@ use syntax::opt_vec;\n use syntax::abi::AbiSet;\n use syntax;\n \n-pub static INITIAL_DISCRIMINANT_VALUE: int = 0;\n+pub static INITIAL_DISCRIMINANT_VALUE: uint = 0;\n \n // Data types\n \n@@ -3689,7 +3689,7 @@ pub struct VariantInfo {\n     ctor_ty: t,\n     name: ast::ident,\n     id: ast::def_id,\n-    disr_val: int,\n+    disr_val: uint,\n     vis: visibility\n }\n \n@@ -3700,7 +3700,7 @@ impl VariantInfo {\n     /// Does not do any caching of the value in the type context.\n     pub fn from_ast_variant(cx: ctxt,\n                             ast_variant: &ast::variant,\n-                            discriminant: int) -> VariantInfo {\n+                            discriminant: uint) -> VariantInfo {\n \n         let ctor_ty = node_id_to_type(cx, ast_variant.node.id);\n \n@@ -3894,7 +3894,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n                 }, _) => {\n-            let mut last_discriminant: Option<int> = None;\n+            let mut last_discriminant: Option<uint> = None;\n             @enum_definition.variants.iter().transform(|variant| {\n \n                 let mut discriminant = match last_discriminant {\n@@ -3904,7 +3904,8 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n \n                 match variant.node.disr_expr {\n                     Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n-                        Ok(const_eval::const_int(val)) => discriminant = val as int,\n+                        Ok(const_eval::const_int(val)) => discriminant = val as uint,\n+                        Ok(const_eval::const_uint(val)) => discriminant = val as uint,\n                         Ok(_) => {\n                             cx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }"}, {"sha": "e5f9cf0d14674cfbc31fc6365dd17209589090ba", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3dc294cefcb92b23581273c24c220c74618a02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1c3dc294cefcb92b23581273c24c220c74618a02", "patch": "@@ -3139,8 +3139,8 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n         let mut variants: ~[@ty::VariantInfo] = ~[];\n-        let mut disr_vals: ~[int] = ~[];\n-        let mut prev_disr_val: Option<int> = None;\n+        let mut disr_vals: ~[uint] = ~[];\n+        let mut prev_disr_val: Option<uint> = None;\n \n         for vs.iter().advance |v| {\n \n@@ -3155,15 +3155,16 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                 Some(e) => {\n                     debug!(\"disr expr, checking %s\", pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n \n-                    let declty = ty::mk_int();\n                     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n+                    let declty = ty::mk_int_var(ccx.tcx, fcx.infcx().next_int_var_id());\n                     check_const_with_ty(fcx, e.span, e, declty);\n                     // check_expr (from check_const pass) doesn't guarantee\n                     // that the expression is in an form that eval_const_expr can\n                     // handle, so we may still get an internal compiler error\n \n                     match const_eval::eval_const_expr_partial(&ccx.tcx, e) {\n-                        Ok(const_eval::const_int(val)) => current_disr_val = val as int,\n+                        Ok(const_eval::const_int(val)) => current_disr_val = val as uint,\n+                        Ok(const_eval::const_uint(val)) => current_disr_val = val as uint,\n                         Ok(_) => {\n                             ccx.tcx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }"}]}