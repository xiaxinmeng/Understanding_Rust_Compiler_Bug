{"sha": "0958f9486ba0cb8ecd0093ff3100af45d19529f3", "node_id": "C_kwDOAAsO6NoAKDA5NThmOTQ4NmJhMGNiOGVjZDAwOTNmZjMxMDBhZjQ1ZDE5NTI5ZjM", "commit": {"author": {"name": "kraktus", "email": "kraktus@users.noreply.github.com", "date": "2022-10-03T11:57:42Z"}, "committer": {"name": "kraktus", "email": "kraktus@users.noreply.github.com", "date": "2022-09-10T08:41:55Z"}, "message": "Add `manual_filter` lint for `Option`\n\nShare much of its implementation with `manual_map` and should greatly benefit from its previous feedback.", "tree": {"sha": "74da20733241a4eb4aa2fd7acdcbe100d0479140", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74da20733241a4eb4aa2fd7acdcbe100d0479140"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0958f9486ba0cb8ecd0093ff3100af45d19529f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0958f9486ba0cb8ecd0093ff3100af45d19529f3", "html_url": "https://github.com/rust-lang/rust/commit/0958f9486ba0cb8ecd0093ff3100af45d19529f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0958f9486ba0cb8ecd0093ff3100af45d19529f3/comments", "author": {"login": "kraktus", "id": 56031107, "node_id": "MDQ6VXNlcjU2MDMxMTA3", "avatar_url": "https://avatars.githubusercontent.com/u/56031107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kraktus", "html_url": "https://github.com/kraktus", "followers_url": "https://api.github.com/users/kraktus/followers", "following_url": "https://api.github.com/users/kraktus/following{/other_user}", "gists_url": "https://api.github.com/users/kraktus/gists{/gist_id}", "starred_url": "https://api.github.com/users/kraktus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kraktus/subscriptions", "organizations_url": "https://api.github.com/users/kraktus/orgs", "repos_url": "https://api.github.com/users/kraktus/repos", "events_url": "https://api.github.com/users/kraktus/events{/privacy}", "received_events_url": "https://api.github.com/users/kraktus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kraktus", "id": 56031107, "node_id": "MDQ6VXNlcjU2MDMxMTA3", "avatar_url": "https://avatars.githubusercontent.com/u/56031107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kraktus", "html_url": "https://github.com/kraktus", "followers_url": "https://api.github.com/users/kraktus/followers", "following_url": "https://api.github.com/users/kraktus/following{/other_user}", "gists_url": "https://api.github.com/users/kraktus/gists{/gist_id}", "starred_url": "https://api.github.com/users/kraktus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kraktus/subscriptions", "organizations_url": "https://api.github.com/users/kraktus/orgs", "repos_url": "https://api.github.com/users/kraktus/repos", "events_url": "https://api.github.com/users/kraktus/events{/privacy}", "received_events_url": "https://api.github.com/users/kraktus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18e10ca29092c01115e0771e0d6753ab9dfb0ff1", "url": "https://api.github.com/repos/rust-lang/rust/commits/18e10ca29092c01115e0771e0d6753ab9dfb0ff1", "html_url": "https://github.com/rust-lang/rust/commit/18e10ca29092c01115e0771e0d6753ab9dfb0ff1"}], "stats": {"total": 1018, "additions": 951, "deletions": 67}, "files": [{"sha": "cab2808ee3b20a452d966456cb507617ba69515c", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -3986,6 +3986,7 @@ Released 2018-09-13\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_bits`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_bits\n [`manual_clamp`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_clamp\n+[`manual_filter`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n [`manual_find`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map"}, {"sha": "21d686fcdf54ddfefd922070fd24d38f5b5935df", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -135,6 +135,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n     LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n+    LintId::of(matches::MANUAL_FILTER),\n     LintId::of(matches::MANUAL_MAP),\n     LintId::of(matches::MANUAL_UNWRAP_OR),\n     LintId::of(matches::MATCH_AS_REF),"}, {"sha": "e3849e5a626bda6b5ab541cc453db97d08e327ee", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -27,6 +27,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(manual_strip::MANUAL_STRIP),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n+    LintId::of(matches::MANUAL_FILTER),\n     LintId::of(matches::MANUAL_UNWRAP_OR),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_SINGLE_BINDING),"}, {"sha": "70defe3bcbd53f86c23fcebb2469e038c873b8a9", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -257,6 +257,7 @@ store.register_lints(&[\n     match_result_ok::MATCH_RESULT_OK,\n     matches::COLLAPSIBLE_MATCH,\n     matches::INFALLIBLE_DESTRUCTURING_MATCH,\n+    matches::MANUAL_FILTER,\n     matches::MANUAL_MAP,\n     matches::MANUAL_UNWRAP_OR,\n     matches::MATCH_AS_REF,"}, {"sha": "9931f1268ab34ca88b98afccdde36208c555a542", "filename": "clippy_lints/src/matches/manual_filter.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -0,0 +1,181 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_res_lang_ctor, path_res, path_to_local_id};\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir::LangItem::OptionSome;\n+use rustc_hir::{Arm, Block, BlockCheckMode, Expr, ExprKind, HirId, Pat, PatKind, UnsafeSource};\n+use rustc_lint::LateContext;\n+use rustc_span::{sym, SyntaxContext};\n+\n+use super::manual_map::{check_with, SomeExpr};\n+use super::MANUAL_FILTER;\n+\n+#[derive(Default)]\n+struct NeedsUnsafeBlock(pub bool);\n+\n+impl<'tcx> Visitor<'tcx> for NeedsUnsafeBlock {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        match expr.kind {\n+            ExprKind::Block(\n+                Block {\n+                    rules: BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+                    ..\n+                },\n+                _,\n+            ) => {\n+                self.0 = true;\n+            },\n+            _ => walk_expr(self, expr),\n+        }\n+    }\n+}\n+\n+// Function called on the `expr` of `[&+]Some((ref | ref mut) x) => <expr>`\n+// Need to check if it's of the `if <cond> {<then_expr>} else {<else_expr>}`\n+// AND that only one `then/else_expr` resolves to `Some(x)` while the other resolves to `None`\n+// return `cond` if\n+fn get_cond_expr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'_>,\n+    expr: &'tcx Expr<'_>,\n+    ctxt: SyntaxContext,\n+) -> Option<SomeExpr<'tcx>> {\n+    if_chain! {\n+        if let Some(block_expr) = peels_blocks_incl_unsafe_opt(expr);\n+        if let ExprKind::If(cond, then_expr, Some(else_expr)) = block_expr.kind;\n+        if let PatKind::Binding(_,target, ..) = pat.kind;\n+        if let (then_visitor, else_visitor)\n+            = (handle_if_or_else_expr(cx, target, ctxt, then_expr),\n+                handle_if_or_else_expr(cx, target, ctxt, else_expr));\n+        if then_visitor != else_visitor; // check that one expr resolves to `Some(x)`, the other to `None`\n+        then {\n+            let mut needs_unsafe_block = NeedsUnsafeBlock::default();\n+            needs_unsafe_block.visit_expr(expr);\n+            return Some(SomeExpr {\n+                    expr: peels_blocks_incl_unsafe(cond.peel_drop_temps()),\n+                    needs_unsafe_block: needs_unsafe_block.0,\n+                    needs_negated: !then_visitor // if the `then_expr` resolves to `None`, need to negate the cond\n+                })\n+            }\n+    };\n+    None\n+}\n+\n+fn peels_blocks_incl_unsafe_opt<'a>(expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n+    // we don't want to use `peel_blocks` here because we don't care if the block is unsafe, it's\n+    // checked by `NeedsUnsafeBlock`\n+    if let ExprKind::Block(block, None) = expr.kind {\n+        if block.stmts.is_empty() {\n+            return block.expr;\n+        }\n+    };\n+    None\n+}\n+\n+fn peels_blocks_incl_unsafe<'a>(expr: &'a Expr<'a>) -> &'a Expr<'a> {\n+    peels_blocks_incl_unsafe_opt(expr).unwrap_or(expr)\n+}\n+\n+// function called for each <ifelse> expression:\n+// Some(x) => if <cond> {\n+//    <ifelse>\n+// } else {\n+//    <ifelse>\n+// }\n+// Returns true if <ifelse> resolves to `Some(x)`, `false` otherwise\n+fn handle_if_or_else_expr<'tcx>(\n+    cx: &LateContext<'_>,\n+    target: HirId,\n+    ctxt: SyntaxContext,\n+    if_or_else_expr: &'tcx Expr<'_>,\n+) -> bool {\n+    if let Some(inner_expr) = peels_blocks_incl_unsafe_opt(if_or_else_expr) {\n+        // there can be not statements in the block as they would be removed when switching to `.filter`\n+        if let ExprKind::Call(callee, [arg]) = inner_expr.kind {\n+            return ctxt == if_or_else_expr.span.ctxt()\n+                && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome)\n+                && path_to_local_id(arg, target);\n+        }\n+    };\n+    false\n+}\n+\n+// given the closure: `|<pattern>| <expr>`\n+// returns `|&<pattern>| <expr>`\n+fn add_ampersand_if_copy(body_str: String, has_copy_trait: bool) -> String {\n+    if has_copy_trait {\n+        let mut with_ampersand = body_str;\n+        with_ampersand.insert(1, '&');\n+        with_ampersand\n+    } else {\n+        body_str\n+    }\n+}\n+\n+pub(super) fn check_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    scrutinee: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'_>],\n+    expr: &'tcx Expr<'_>,\n+) {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    if_chain! {\n+        if is_type_diagnostic_item(cx, ty, sym::Option);\n+        if arms.len() == 2;\n+        if arms[0].guard.is_none();\n+        if arms[1].guard.is_none();\n+        then {\n+            check(cx, expr, scrutinee, arms[0].pat, arms[0].body, Some(arms[1].pat), arms[1].body)\n+        }\n+    }\n+}\n+\n+pub(super) fn check_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &'tcx Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+    then_expr: &'tcx Expr<'_>,\n+    else_expr: &'tcx Expr<'_>,\n+) {\n+    check(cx, expr, let_expr, let_pat, then_expr, None, else_expr);\n+}\n+\n+fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    then_pat: &'tcx Pat<'_>,\n+    then_body: &'tcx Expr<'_>,\n+    else_pat: Option<&'tcx Pat<'_>>,\n+    else_body: &'tcx Expr<'_>,\n+) {\n+    if let Some(sugg_info) = check_with(\n+        cx,\n+        expr,\n+        scrutinee,\n+        then_pat,\n+        then_body,\n+        else_pat,\n+        else_body,\n+        get_cond_expr,\n+    ) {\n+        let body_str = add_ampersand_if_copy(sugg_info.body_str, sugg_info.scrutinee_impl_copy);\n+        span_lint_and_sugg(\n+            cx,\n+            MANUAL_FILTER,\n+            expr.span,\n+            \"manual implementation of `Option::filter`\",\n+            \"try this\",\n+            if sugg_info.needs_brackets {\n+                format!(\n+                    \"{{ {}{}.filter({body_str}) }}\",\n+                    sugg_info.scrutinee_str, sugg_info.as_ref_str\n+                )\n+            } else {\n+                format!(\"{}{}.filter({body_str})\", sugg_info.scrutinee_str, sugg_info.as_ref_str)\n+            },\n+            sugg_info.app,\n+        );\n+    }\n+}"}, {"sha": "2b6a07c5d744540e61ef89888638e066acbc0868", "filename": "clippy_lints/src/matches/manual_map.rs", "status": "modified", "additions": 148, "deletions": 65, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -1,10 +1,11 @@\n+use super::MANUAL_MAP;\n use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n+use clippy_utils::ty::{is_copy, is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n use clippy_utils::{\n     can_move_expr_to_closure, is_else_clause, is_lint_allowed, is_res_lang_ctor, path_res, path_to_local_id,\n-    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n+    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, sugg::Sugg, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n@@ -16,8 +17,6 @@ use rustc_hir::{\n use rustc_lint::LateContext;\n use rustc_span::{sym, SyntaxContext};\n \n-use super::MANUAL_MAP;\n-\n pub(super) fn check_match<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n@@ -43,7 +42,6 @@ pub(super) fn check_if_let<'tcx>(\n     check(cx, expr, let_expr, let_pat, then_expr, None, else_expr);\n }\n \n-#[expect(clippy::too_many_lines)]\n fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n@@ -53,12 +51,59 @@ fn check<'tcx>(\n     else_pat: Option<&'tcx Pat<'_>>,\n     else_body: &'tcx Expr<'_>,\n ) {\n+    if let Some(sugg_info) = check_with(\n+        cx,\n+        expr,\n+        scrutinee,\n+        then_pat,\n+        then_body,\n+        else_pat,\n+        else_body,\n+        get_some_expr,\n+    ) {\n+        span_lint_and_sugg(\n+            cx,\n+            MANUAL_MAP,\n+            expr.span,\n+            \"manual implementation of `Option::map`\",\n+            \"try this\",\n+            if sugg_info.needs_brackets {\n+                format!(\n+                    \"{{ {}{}.map({}) }}\",\n+                    sugg_info.scrutinee_str, sugg_info.as_ref_str, sugg_info.body_str\n+                )\n+            } else {\n+                format!(\n+                    \"{}{}.map({})\",\n+                    sugg_info.scrutinee_str, sugg_info.as_ref_str, sugg_info.body_str\n+                )\n+            },\n+            sugg_info.app,\n+        );\n+    }\n+}\n+\n+#[expect(clippy::too_many_arguments)]\n+#[expect(clippy::too_many_lines)]\n+pub(super) fn check_with<'tcx, F>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    then_pat: &'tcx Pat<'_>,\n+    then_body: &'tcx Expr<'_>,\n+    else_pat: Option<&'tcx Pat<'_>>,\n+    else_body: &'tcx Expr<'_>,\n+    get_some_expr_fn: F,\n+) -> Option<SuggInfo<'tcx>>\n+where\n+    F: Fn(&LateContext<'tcx>, &'tcx Pat<'_>, &'tcx Expr<'_>, SyntaxContext) -> Option<SomeExpr<'tcx>>,\n+{\n     let (scrutinee_ty, ty_ref_count, ty_mutability) =\n         peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n     if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::Option)\n         && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Option))\n     {\n-        return;\n+        return None;\n     }\n \n     let expr_ctxt = expr.span.ctxt();\n@@ -78,29 +123,29 @@ fn check<'tcx>(\n         (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n             (then_body, pattern, ref_count, false)\n         },\n-        _ => return,\n+        _ => return None,\n     };\n \n     // Top level or patterns aren't allowed in closures.\n     if matches!(some_pat.kind, PatKind::Or(_)) {\n-        return;\n+        return None;\n     }\n \n-    let some_expr = match get_some_expr(cx, some_expr, false, expr_ctxt) {\n+    let some_expr = match get_some_expr_fn(cx, some_pat, some_expr, expr_ctxt) {\n         Some(expr) => expr,\n-        None => return,\n+        None => return None,\n     };\n \n     // These two lints will go back and forth with each other.\n     if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n         && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n     {\n-        return;\n+        return None;\n     }\n \n     // `map` won't perform any adjustments.\n     if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n-        return;\n+        return None;\n     }\n \n     // Determine which binding mode to use.\n@@ -125,16 +170,16 @@ fn check<'tcx>(\n                 });\n                 if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n                     match captures.get(l) {\n-                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n+                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return None,\n                         Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n-                            return;\n+                            return None;\n                         },\n                         Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n                     }\n                 }\n             }\n         },\n-        None => return,\n+        None => return None,\n     };\n \n     let mut app = Applicability::MachineApplicable;\n@@ -149,6 +194,7 @@ fn check<'tcx>(\n         scrutinee_str.into()\n     };\n \n+    let closure_expr_snip = some_expr.to_snippet_with_context(cx, expr_ctxt, &mut app);\n     let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n         if_chain! {\n             if !some_expr.needs_unsafe_block;\n@@ -161,7 +207,7 @@ fn check<'tcx>(\n                     && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n                     && binding_ref.is_some()\n                 {\n-                    return;\n+                    return None;\n                 }\n \n                 // `ref` and `ref mut` annotations were handled earlier.\n@@ -170,41 +216,47 @@ fn check<'tcx>(\n                 } else {\n                     \"\"\n                 };\n-                let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n+\n                 if some_expr.needs_unsafe_block {\n-                    format!(\"|{annotation}{some_binding}| unsafe {{ {expr_snip} }}\")\n+                    format!(\"|{annotation}{some_binding}| unsafe {{ {closure_expr_snip} }}\")\n                 } else {\n-                    format!(\"|{annotation}{some_binding}| {expr_snip}\")\n+                    format!(\"|{annotation}{some_binding}| {closure_expr_snip}\")\n                 }\n             }\n         }\n     } else if !is_wild_none && explicit_ref.is_none() {\n         // TODO: handle explicit reference annotations.\n         let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n-        let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n         if some_expr.needs_unsafe_block {\n-            format!(\"|{pat_snip}| unsafe {{ {expr_snip} }}\")\n+            format!(\"|{pat_snip}| unsafe {{ {closure_expr_snip} }}\")\n         } else {\n-            format!(\"|{pat_snip}| {expr_snip}\")\n+            format!(\"|{pat_snip}| {closure_expr_snip}\")\n         }\n     } else {\n         // Refutable bindings and mixed reference annotations can't be handled by `map`.\n-        return;\n+        return None;\n     };\n \n-    span_lint_and_sugg(\n-        cx,\n-        MANUAL_MAP,\n-        expr.span,\n-        \"manual implementation of `Option::map`\",\n-        \"try this\",\n-        if else_pat.is_none() && is_else_clause(cx.tcx, expr) {\n-            format!(\"{{ {scrutinee_str}{as_ref_str}.map({body_str}) }}\")\n-        } else {\n-            format!(\"{scrutinee_str}{as_ref_str}.map({body_str})\")\n-        },\n+    // relies on the fact that Option<T>: Copy where T: copy\n+    let scrutinee_impl_copy = is_copy(cx, scrutinee_ty);\n+\n+    Some(SuggInfo {\n+        needs_brackets: else_pat.is_none() && is_else_clause(cx.tcx, expr),\n+        scrutinee_impl_copy,\n+        scrutinee_str,\n+        as_ref_str,\n+        body_str,\n         app,\n-    );\n+    })\n+}\n+\n+pub struct SuggInfo<'a> {\n+    pub needs_brackets: bool,\n+    pub scrutinee_impl_copy: bool,\n+    pub scrutinee_str: String,\n+    pub as_ref_str: &'a str,\n+    pub body_str: String,\n+    pub app: Applicability,\n }\n \n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n@@ -222,7 +274,8 @@ fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Ex\n     }\n }\n \n-enum OptionPat<'a> {\n+#[derive(Debug)]\n+pub(super) enum OptionPat<'a> {\n     Wild,\n     None,\n     Some {\n@@ -234,14 +287,39 @@ enum OptionPat<'a> {\n     },\n }\n \n-struct SomeExpr<'tcx> {\n-    expr: &'tcx Expr<'tcx>,\n-    needs_unsafe_block: bool,\n+pub(super) struct SomeExpr<'tcx> {\n+    pub expr: &'tcx Expr<'tcx>,\n+    pub needs_unsafe_block: bool,\n+    pub needs_negated: bool, // for `manual_filter` lint\n+}\n+\n+impl<'tcx> SomeExpr<'tcx> {\n+    pub fn new_no_negated(expr: &'tcx Expr<'tcx>, needs_unsafe_block: bool) -> Self {\n+        Self {\n+            expr,\n+            needs_unsafe_block,\n+            needs_negated: false,\n+        }\n+    }\n+\n+    pub fn to_snippet_with_context(\n+        &self,\n+        cx: &LateContext<'tcx>,\n+        ctxt: SyntaxContext,\n+        app: &mut Applicability,\n+    ) -> Sugg<'tcx> {\n+        let sugg = Sugg::hir_with_context(cx, self.expr, ctxt, \"..\", app);\n+        if self.needs_negated { !sugg } else { sugg }\n+    }\n }\n \n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+pub(super) fn try_parse_pattern<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    ctxt: SyntaxContext,\n+) -> Option<OptionPat<'tcx>> {\n     fn f<'tcx>(\n         cx: &LateContext<'tcx>,\n         pat: &'tcx Pat<'_>,\n@@ -268,36 +346,41 @@ fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: Syn\n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n fn get_some_expr<'tcx>(\n     cx: &LateContext<'tcx>,\n+    _: &'tcx Pat<'_>,\n     expr: &'tcx Expr<'_>,\n-    needs_unsafe_block: bool,\n     ctxt: SyntaxContext,\n ) -> Option<SomeExpr<'tcx>> {\n-    // TODO: Allow more complex expressions.\n-    match expr.kind {\n-        ExprKind::Call(callee, [arg])\n-            if ctxt == expr.span.ctxt() && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome) =>\n-        {\n-            Some(SomeExpr {\n-                expr: arg,\n-                needs_unsafe_block,\n-            })\n-        },\n-        ExprKind::Block(\n-            Block {\n-                stmts: [],\n-                expr: Some(expr),\n-                rules,\n-                ..\n+    fn get_some_expr_internal<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        expr: &'tcx Expr<'_>,\n+        needs_unsafe_block: bool,\n+        ctxt: SyntaxContext,\n+    ) -> Option<SomeExpr<'tcx>> {\n+        // TODO: Allow more complex expressions.\n+        match expr.kind {\n+            ExprKind::Call(callee, [arg])\n+                if ctxt == expr.span.ctxt() && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome) =>\n+            {\n+                Some(SomeExpr::new_no_negated(arg, needs_unsafe_block))\n             },\n-            _,\n-        ) => get_some_expr(\n-            cx,\n-            expr,\n-            needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n-            ctxt,\n-        ),\n-        _ => None,\n+            ExprKind::Block(\n+                Block {\n+                    stmts: [],\n+                    expr: Some(expr),\n+                    rules,\n+                    ..\n+                },\n+                _,\n+            ) => get_some_expr_internal(\n+                cx,\n+                expr,\n+                needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+                ctxt,\n+            ),\n+            _ => None,\n+        }\n     }\n+    get_some_expr_internal(cx, expr, false, ctxt)\n }\n \n // Checks for the `None` value."}, {"sha": "cf1bd7a12adec08854da15ea90df4afcab566537", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -1,5 +1,6 @@\n mod collapsible_match;\n mod infallible_destructuring_match;\n+mod manual_filter;\n mod manual_map;\n mod manual_unwrap_or;\n mod match_as_ref;\n@@ -898,6 +899,34 @@ declare_clippy_lint! {\n     \"reimplementation of `map`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of `match` which could be implemented using `filter`\n+    ///\n+    /// ### Why is this bad?\n+    /// Using the `filter` method is clearer and more concise.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// match Some(0) {\n+    ///     Some(x) => if x % 2 == 0 {\n+    ///                     Some(x)\n+    ///                } else {\n+    ///                     None\n+    ///                 },\n+    ///     None => None,\n+    /// };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// Some(0).filter(|&x| x % 2 == 0);\n+    /// ```\n+    #[clippy::version = \"1.65.0\"]\n+    pub MANUAL_FILTER,\n+    complexity,\n+    \"reimplentation of `filter`\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     msrv: Option<RustcVersion>,\n@@ -939,6 +968,7 @@ impl_lint_pass!(Matches => [\n     SIGNIFICANT_DROP_IN_SCRUTINEE,\n     TRY_ERR,\n     MANUAL_MAP,\n+    MANUAL_FILTER,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n@@ -988,6 +1018,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     if !in_constant(cx, expr.hir_id) {\n                         manual_unwrap_or::check(cx, expr, ex, arms);\n                         manual_map::check_match(cx, expr, ex, arms);\n+                        manual_filter::check_match(cx, ex, arms, expr);\n                     }\n \n                     if self.infallible_destructuring_match_linted {\n@@ -1014,6 +1045,14 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     }\n                     if !in_constant(cx, expr.hir_id) {\n                         manual_map::check_if_let(cx, expr, if_let.let_pat, if_let.let_expr, if_let.if_then, else_expr);\n+                        manual_filter::check_if_let(\n+                            cx,\n+                            expr,\n+                            if_let.let_pat,\n+                            if_let.let_expr,\n+                            if_let.if_then,\n+                            else_expr,\n+                        );\n                     }\n                 }\n                 redundant_pattern_match::check_if_let("}, {"sha": "e88542b77a67e8970fce88770b4961772517eae2", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -1,7 +1,9 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::source::{snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite};\n+use crate::source::{\n+    snippet, snippet_opt, snippet_with_applicability, snippet_with_context, snippet_with_macro_callsite,\n+};\n use crate::ty::expr_sig;\n use crate::{get_parent_expr_for_hir, higher};\n use rustc_ast::util::parser::AssocOp;\n@@ -110,7 +112,7 @@ impl<'a> Sugg<'a> {\n         if expr.span.ctxt() == ctxt {\n             Self::hir_from_snippet(expr, |span| snippet(cx, span, default))\n         } else {\n-            let snip = snippet_with_applicability(cx, expr.span, default, applicability);\n+            let snip = snippet_with_context(cx, expr.span, ctxt, default, applicability).0;\n             Sugg::NonParen(snip)\n         }\n     }"}, {"sha": "d24342076b69472df7c424d5a5df2cf3e56320e4", "filename": "src/docs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/src%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/src%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs.rs?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -256,6 +256,7 @@ docs! {\n     \"manual_async_fn\",\n     \"manual_bits\",\n     \"manual_clamp\",\n+    \"manual_filter\",\n     \"manual_filter_map\",\n     \"manual_find\",\n     \"manual_find_map\","}, {"sha": "19a4d9319d94b700d1e88671e4e8f9f6ae6c20ef", "filename": "src/docs/manual_filter.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/src%2Fdocs%2Fmanual_filter.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/src%2Fdocs%2Fmanual_filter.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_filter.txt?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for usages of `match` which could be implemented using `filter`\n+\n+### Why is this bad?\n+Using the `filter` method is clearer and more concise.\n+\n+### Example\n+```\n+match Some(0) {\n+    Some(x) => if x % 2 == 0 {\n+                    Some(x)\n+               } else {\n+                    None\n+                },\n+    None => None,\n+};\n+```\n+Use instead:\n+```\n+Some(0).filter(|&x| x % 2 == 0);\n+```\n\\ No newline at end of file"}, {"sha": "3553291b87df6731aca2e71f905ed63eef21cda7", "filename": "tests/ui/manual_filter.fixed", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/tests%2Fui%2Fmanual_filter.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/tests%2Fui%2Fmanual_filter.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_filter.fixed?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -0,0 +1,119 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_filter)]\n+#![allow(unused_variables, dead_code)]\n+\n+fn main() {\n+    Some(0).filter(|&x| x <= 0);\n+\n+    Some(1).filter(|&x| x <= 0);\n+\n+    Some(2).filter(|&x| x <= 0);\n+\n+    Some(3).filter(|&x| x > 0);\n+\n+    let y = Some(4);\n+    y.filter(|&x| x <= 0);\n+\n+    Some(5).filter(|&x| x > 0);\n+\n+    Some(6).as_ref().filter(|&x| x > &0);\n+\n+    let external_cond = true;\n+    Some(String::new()).filter(|x| external_cond);\n+\n+    Some(7).filter(|&x| external_cond);\n+\n+    Some(8).filter(|&x| x != 0);\n+\n+    Some(9).filter(|&x| x > 10 && x < 100);\n+\n+    const fn f1() {\n+        // Don't lint, `.filter` is not const\n+        match Some(10) {\n+            Some(x) => {\n+                if x > 10 && x < 100 {\n+                    Some(x)\n+                } else {\n+                    None\n+                }\n+            },\n+            None => None,\n+        };\n+    }\n+\n+    #[allow(clippy::blocks_in_if_conditions)]\n+    Some(11).filter(|&x| {\n+                println!(\"foo\");\n+                x > 10 && x < 100\n+            });\n+\n+    match Some(12) {\n+        // Don't Lint, statement is lost by `.filter`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(13) {\n+        // Don't Lint, because of `None => Some(1)`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => Some(1),\n+    };\n+\n+    unsafe fn f(x: u32) -> bool {\n+        true\n+    }\n+    let _ = Some(14).filter(|&x| unsafe { f(x) });\n+    let _ = Some(15).filter(|&x| unsafe { f(x) });\n+\n+    #[allow(clippy::redundant_pattern_matching)]\n+    if let Some(_) = Some(16) {\n+        Some(16)\n+    } else { Some(16).filter(|&x| x % 2 == 0) };\n+\n+    match Some((17, 17)) {\n+        // Not linted for now could be\n+        Some((x, y)) => {\n+            if y != x {\n+                Some((x, y))\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    struct NamedTuple {\n+        pub x: u8,\n+        pub y: (i32, u32),\n+    }\n+\n+    match Some(NamedTuple {\n+        // Not linted for now could be\n+        x: 17,\n+        y: (18, 19),\n+    }) {\n+        Some(NamedTuple { x, y }) => {\n+            if y.1 != x as u32 {\n+                Some(NamedTuple { x, y })\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+}"}, {"sha": "aa9f90f752b1790b1cb3ef52d6052d12221503c6", "filename": "tests/ui/manual_filter.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/tests%2Fui%2Fmanual_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/tests%2Fui%2Fmanual_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_filter.rs?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -0,0 +1,243 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_filter)]\n+#![allow(unused_variables, dead_code)]\n+\n+fn main() {\n+    match Some(0) {\n+        None => None,\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+    };\n+\n+    match Some(1) {\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(2) {\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    match Some(3) {\n+        Some(x) => {\n+            if x > 0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    let y = Some(4);\n+    match y {\n+        // Some(4)\n+        None => None,\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+    };\n+\n+    match Some(5) {\n+        Some(x) => {\n+            if x > 0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    match Some(6) {\n+        Some(ref x) => {\n+            if x > &0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    let external_cond = true;\n+    match Some(String::new()) {\n+        Some(x) => {\n+            if external_cond {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    if let Some(x) = Some(7) {\n+        if external_cond { Some(x) } else { None }\n+    } else {\n+        None\n+    };\n+\n+    match &Some(8) {\n+        &Some(x) => {\n+            if x != 0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    match Some(9) {\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    const fn f1() {\n+        // Don't lint, `.filter` is not const\n+        match Some(10) {\n+            Some(x) => {\n+                if x > 10 && x < 100 {\n+                    Some(x)\n+                } else {\n+                    None\n+                }\n+            },\n+            None => None,\n+        };\n+    }\n+\n+    #[allow(clippy::blocks_in_if_conditions)]\n+    match Some(11) {\n+        // Lint, statement is preserved by `.filter`\n+        Some(x) => {\n+            if {\n+                println!(\"foo\");\n+                x > 10 && x < 100\n+            } {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(12) {\n+        // Don't Lint, statement is lost by `.filter`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(13) {\n+        // Don't Lint, because of `None => Some(1)`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => Some(1),\n+    };\n+\n+    unsafe fn f(x: u32) -> bool {\n+        true\n+    }\n+    let _ = match Some(14) {\n+        Some(x) => {\n+            if unsafe { f(x) } {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+    let _ = match Some(15) {\n+        Some(x) => unsafe {\n+            if f(x) { Some(x) } else { None }\n+        },\n+        None => None,\n+    };\n+\n+    #[allow(clippy::redundant_pattern_matching)]\n+    if let Some(_) = Some(16) {\n+        Some(16)\n+    } else if let Some(x) = Some(16) {\n+        // Lint starting from here\n+        if x % 2 == 0 { Some(x) } else { None }\n+    } else {\n+        None\n+    };\n+\n+    match Some((17, 17)) {\n+        // Not linted for now could be\n+        Some((x, y)) => {\n+            if y != x {\n+                Some((x, y))\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    struct NamedTuple {\n+        pub x: u8,\n+        pub y: (i32, u32),\n+    }\n+\n+    match Some(NamedTuple {\n+        // Not linted for now could be\n+        x: 17,\n+        y: (18, 19),\n+    }) {\n+        Some(NamedTuple { x, y }) => {\n+            if y.1 != x as u32 {\n+                Some(NamedTuple { x, y })\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+}"}, {"sha": "53dea9229306bb2dc2ac21f4eedc46ed8e735e19", "filename": "tests/ui/manual_filter.stderr", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/0958f9486ba0cb8ecd0093ff3100af45d19529f3/tests%2Fui%2Fmanual_filter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0958f9486ba0cb8ecd0093ff3100af45d19529f3/tests%2Fui%2Fmanual_filter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_filter.stderr?ref=0958f9486ba0cb8ecd0093ff3100af45d19529f3", "patch": "@@ -0,0 +1,191 @@\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:7:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         None => None,\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+...  |\n+LL | |         },\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).filter(|&x| x <= 0)`\n+   |\n+   = note: `-D clippy::manual-filter` implied by `-D warnings`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:18:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 None\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(1).filter(|&x| x <= 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:29:5\n+   |\n+LL | /     match Some(2) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 None\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(2).filter(|&x| x <= 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:40:5\n+   |\n+LL | /     match Some(3) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(3).filter(|&x| x > 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:52:5\n+   |\n+LL | /     match y {\n+LL | |         // Some(4)\n+LL | |         None => None,\n+LL | |         Some(x) => {\n+...  |\n+LL | |         },\n+LL | |     };\n+   | |_____^ help: try this: `y.filter(|&x| x <= 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:64:5\n+   |\n+LL | /     match Some(5) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(5).filter(|&x| x > 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:75:5\n+   |\n+LL | /     match Some(6) {\n+LL | |         Some(ref x) => {\n+LL | |             if x > &0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(6).as_ref().filter(|&x| x > &0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:87:5\n+   |\n+LL | /     match Some(String::new()) {\n+LL | |         Some(x) => {\n+LL | |             if external_cond {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(String::new()).filter(|x| external_cond)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:98:5\n+   |\n+LL | /     if let Some(x) = Some(7) {\n+LL | |         if external_cond { Some(x) } else { None }\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^ help: try this: `Some(7).filter(|&x| external_cond)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:104:5\n+   |\n+LL | /     match &Some(8) {\n+LL | |         &Some(x) => {\n+LL | |             if x != 0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(8).filter(|&x| x != 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:115:5\n+   |\n+LL | /     match Some(9) {\n+LL | |         Some(x) => {\n+LL | |             if x > 10 && x < 100 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(9).filter(|&x| x > 10 && x < 100)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:141:5\n+   |\n+LL | /     match Some(11) {\n+LL | |         // Lint, statement is preserved by `.filter`\n+LL | |         Some(x) => {\n+LL | |             if {\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     Some(11).filter(|&x| {\n+LL +                 println!(\"foo\");\n+LL +                 x > 10 && x < 100\n+LL ~             });\n+   |\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:185:13\n+   |\n+LL |       let _ = match Some(14) {\n+   |  _____________^\n+LL | |         Some(x) => {\n+LL | |             if unsafe { f(x) } {\n+LL | |                 Some(x)\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(14).filter(|&x| unsafe { f(x) })`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:195:13\n+   |\n+LL |       let _ = match Some(15) {\n+   |  _____________^\n+LL | |         Some(x) => unsafe {\n+LL | |             if f(x) { Some(x) } else { None }\n+LL | |         },\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(15).filter(|&x| unsafe { f(x) })`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:205:12\n+   |\n+LL |       } else if let Some(x) = Some(16) {\n+   |  ____________^\n+LL | |         // Lint starting from here\n+LL | |         if x % 2 == 0 { Some(x) } else { None }\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^ help: try this: `{ Some(16).filter(|&x| x % 2 == 0) }`\n+\n+error: aborting due to 15 previous errors\n+"}]}