{"sha": "161e8ffda79d25ef7a570bf0c0d884201267c6cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MWU4ZmZkYTc5ZDI1ZWY3YTU3MGJmMGMwZDg4NDIwMTI2N2M2Y2I=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2018-02-10T23:56:24Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2018-02-10T23:56:24Z"}, "message": "typo: correct endianess to endianness (this also changes function names!)", "tree": {"sha": "d3853a5ca10ee8fc820e1a001b740fef3059cc1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3853a5ca10ee8fc820e1a001b740fef3059cc1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/161e8ffda79d25ef7a570bf0c0d884201267c6cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/161e8ffda79d25ef7a570bf0c0d884201267c6cb", "html_url": "https://github.com/rust-lang/rust/commit/161e8ffda79d25ef7a570bf0c0d884201267c6cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/161e8ffda79d25ef7a570bf0c0d884201267c6cb/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45fba43b3d5b4d1944268cf973099bfacb11bf4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/45fba43b3d5b4d1944268cf973099bfacb11bf4c", "html_url": "https://github.com/rust-lang/rust/commit/45fba43b3d5b4d1944268cf973099bfacb11bf4c"}], "stats": {"total": 36, "additions": 18, "deletions": 18}, "files": [{"sha": "7cc4ba84895251ec5303a99e86882d8135a87f78", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/161e8ffda79d25ef7a570bf0c0d884201267c6cb/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/161e8ffda79d25ef7a570bf0c0d884201267c6cb/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=161e8ffda79d25ef7a570bf0c0d884201267c6cb", "patch": "@@ -238,7 +238,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         self.tcx.data_layout.pointer_size.bytes()\n     }\n \n-    pub fn endianess(&self) -> layout::Endian {\n+    pub fn endianness(&self) -> layout::Endian {\n         self.tcx.data_layout.endian\n     }\n \n@@ -722,7 +722,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: u64, signed: bool) -> EvalResult<'tcx, PrimVal> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n-        let endianess = self.endianess();\n+        let endianness = self.endianness();\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n@@ -731,9 +731,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n         // Now we do the actual reading\n         let bytes = if signed {\n-            read_target_int(endianess, bytes).unwrap() as u128\n+            read_target_int(endianness, bytes).unwrap() as u128\n         } else {\n-            read_target_uint(endianess, bytes).unwrap()\n+            read_target_uint(endianness, bytes).unwrap()\n         };\n         // See if we got a pointer\n         if size != self.pointer_size() {\n@@ -756,7 +756,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     pub fn write_primval(&mut self, ptr: MemoryPointer, ptr_align: Align, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n-        let endianess = self.endianess();\n+        let endianness = self.endianness();\n \n         let bytes = match val {\n             PrimVal::Ptr(val) => {\n@@ -788,9 +788,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             let align = self.int_align(size);\n             let dst = self.get_bytes_mut(ptr, size, ptr_align.min(align))?;\n             if signed {\n-                write_target_int(endianess, dst, bytes as i128).unwrap();\n+                write_target_int(endianness, dst, bytes as i128).unwrap();\n             } else {\n-                write_target_uint(endianess, dst, bytes).unwrap();\n+                write_target_uint(endianness, dst, bytes).unwrap();\n             }\n         }\n \n@@ -941,41 +941,41 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// Methods to access integers in the target endianess\n+// Methods to access integers in the target endianness\n ////////////////////////////////////////////////////////////////////////////////\n \n fn write_target_uint(\n-    endianess: layout::Endian,\n+    endianness: layout::Endian,\n     mut target: &mut [u8],\n     data: u128,\n ) -> Result<(), io::Error> {\n     let len = target.len();\n-    match endianess {\n+    match endianness {\n         layout::Endian::Little => target.write_uint128::<LittleEndian>(data, len),\n         layout::Endian::Big => target.write_uint128::<BigEndian>(data, len),\n     }\n }\n fn write_target_int(\n-    endianess: layout::Endian,\n+    endianness: layout::Endian,\n     mut target: &mut [u8],\n     data: i128,\n ) -> Result<(), io::Error> {\n     let len = target.len();\n-    match endianess {\n+    match endianness {\n         layout::Endian::Little => target.write_int128::<LittleEndian>(data, len),\n         layout::Endian::Big => target.write_int128::<BigEndian>(data, len),\n     }\n }\n \n-fn read_target_uint(endianess: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n-    match endianess {\n+fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n+    match endianness {\n         layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n     }\n }\n \n-fn read_target_int(endianess: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n-    match endianess {\n+fn read_target_int(endianness: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n+    match endianness {\n         layout::Endian::Little => source.read_int128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_int128::<BigEndian>(source.len()),\n     }"}, {"sha": "a760922115aef330ebb44463d4412c687e1cbbc4", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/161e8ffda79d25ef7a570bf0c0d884201267c6cb/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/161e8ffda79d25ef7a570bf0c0d884201267c6cb/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=161e8ffda79d25ef7a570bf0c0d884201267c6cb", "patch": "@@ -1023,7 +1023,7 @@ impl f32 {\n     /// This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n     /// It turns out this is incredibly portable, for two reasons:\n     ///\n-    /// * Floats and Ints have the same endianess on all supported platforms.\n+    /// * Floats and Ints have the same endianness on all supported platforms.\n     /// * IEEE-754 very precisely specifies the bit layout of floats.\n     ///\n     /// However there is one caveat: prior to the 2008 version of IEEE-754, how"}, {"sha": "6f34f176a971155b09c2d3e5ecad66cd56002ac7", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/161e8ffda79d25ef7a570bf0c0d884201267c6cb/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/161e8ffda79d25ef7a570bf0c0d884201267c6cb/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=161e8ffda79d25ef7a570bf0c0d884201267c6cb", "patch": "@@ -978,7 +978,7 @@ impl f64 {\n     /// This is currently identical to `transmute::<u64, f64>(v)` on all platforms.\n     /// It turns out this is incredibly portable, for two reasons:\n     ///\n-    /// * Floats and Ints have the same endianess on all supported platforms.\n+    /// * Floats and Ints have the same endianness on all supported platforms.\n     /// * IEEE-754 very precisely specifies the bit layout of floats.\n     ///\n     /// However there is one caveat: prior to the 2008 version of IEEE-754, how"}]}