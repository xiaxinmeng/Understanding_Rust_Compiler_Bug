{"sha": "0a16b8754abe419f8541788c1092e4ef91fcf137", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMTZiODc1NGFiZTQxOWY4NTQxNzg4YzEwOTJlNGVmOTFmY2YxMzc=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-09T16:29:31Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-09T16:29:31Z"}, "message": "Use ? in librustc macros", "tree": {"sha": "c9710cced7ba306fe0389e1636192cb2b68867a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9710cced7ba306fe0389e1636192cb2b68867a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a16b8754abe419f8541788c1092e4ef91fcf137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a16b8754abe419f8541788c1092e4ef91fcf137", "html_url": "https://github.com/rust-lang/rust/commit/0a16b8754abe419f8541788c1092e4ef91fcf137", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a16b8754abe419f8541788c1092e4ef91fcf137/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d329d46a3fcca61a1359c7c8f3b4ed0bccadd32e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d329d46a3fcca61a1359c7c8f3b4ed0bccadd32e", "html_url": "https://github.com/rust-lang/rust/commit/d329d46a3fcca61a1359c7c8f3b4ed0bccadd32e"}], "stats": {"total": 506, "additions": 246, "deletions": 260}, "files": [{"sha": "ccae9d3ad5a82792a3d9e4a9e8de75014d6bfa1e", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0a16b8754abe419f8541788c1092e4ef91fcf137/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a16b8754abe419f8541788c1092e4ef91fcf137/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=0a16b8754abe419f8541788c1092e4ef91fcf137", "patch": "@@ -62,38 +62,36 @@ macro_rules! __impl_stable_hash_field {\n #[macro_export]\n macro_rules! impl_stable_hash_for {\n     // Enums\n-    // FIXME(mark-i-m): Some of these should be `?` rather than `*`. See the git blame and change\n-    // them back when `?` is supported again.\n     (enum $enum_name:path {\n         $( $variant:ident\n            // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n            // when it should be only one or the other\n-           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n-           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n-        ),* $(,)*\n+           $( ( $($field:ident $(-> $delegate:tt)?),* ) )?\n+           $( { $($named_field:ident $(-> $named_delegate:tt)?),* } )?\n+        ),* $(,)?\n     }) => {\n         impl_stable_hash_for!(\n             impl<> for enum $enum_name [ $enum_name ] { $( $variant\n-                $( ( $($field $(-> $delegate)*),* ) )*\n-                $( { $($named_field $(-> $named_delegate)*),* } )*\n+                $( ( $($field $(-> $delegate)?),* ) )?\n+                $( { $($named_field $(-> $named_delegate)?),* } )?\n             ),* }\n         );\n     };\n     // We want to use the enum name both in the `impl ... for $enum_name` as well as for\n     // importing all the variants. Unfortunately it seems we have to take the name\n     // twice for this purpose\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?>\n         for enum $enum_name:path\n         [ $enum_path:path ]\n     {\n         $( $variant:ident\n            // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n            // when it should be only one or the other\n-           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n-           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n-        ),* $(,)*\n+           $( ( $($field:ident $(-> $delegate:tt)?),* ) )?\n+           $( { $($named_field:ident $(-> $named_delegate:tt)?),* } )?\n+        ),* $(,)?\n     }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>\n             for $enum_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n@@ -107,26 +105,25 @@ macro_rules! impl_stable_hash_for {\n \n                 match *self {\n                     $(\n-                        $variant $( ( $(ref $field),* ) )* $( { $(ref $named_field),* } )* => {\n-                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*)*\n-                            $($( __impl_stable_hash_field!($named_field, __ctx, __hasher $(, $named_delegate)*) );*)*\n+                        $variant $( ( $(ref $field),* ) )? $( { $(ref $named_field),* } )? => {\n+                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*)?\n+                            $($( __impl_stable_hash_field!($named_field, __ctx, __hasher $(, $named_delegate)?) );*)?\n                         }\n                     )*\n                 }\n             }\n         }\n     };\n     // Structs\n-    // FIXME(mark-i-m): same here.\n-    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n+    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),* $(,)? }) => {\n         impl_stable_hash_for!(\n-            impl<'tcx> for struct $struct_name { $($field $(-> $delegate)*),* }\n+            impl<'tcx> for struct $struct_name { $($field $(-> $delegate)?),* }\n         );\n     };\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*> for struct $struct_name:path {\n-        $($field:ident $(-> $delegate:tt)*),* $(,)*\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?> for struct $struct_name:path {\n+        $($field:ident $(-> $delegate:tt)?),* $(,)?\n     }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n@@ -138,21 +135,20 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 } = *self;\n \n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };\n     // Tuple structs\n-    // We cannot use normale parentheses here, the parser won't allow it\n-    // FIXME(mark-i-m): same here.\n-    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n+    // We cannot use normal parentheses here, the parser won't allow it\n+    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n         impl_stable_hash_for!(\n-            impl<'tcx> for tuple_struct $struct_name { $($field $(-> $delegate)*),* }\n+            impl<'tcx> for tuple_struct $struct_name { $($field $(-> $delegate)?),* }\n         );\n     };\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n-     for tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?>\n+     for tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n@@ -164,7 +160,7 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 ) = *self;\n \n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };"}, {"sha": "e5828039ac29cb33fb1510aa05359a75a9a7a7d4", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 220, "deletions": 230, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/0a16b8754abe419f8541788c1092e4ef91fcf137/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a16b8754abe419f8541788c1092e4ef91fcf137/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=0a16b8754abe419f8541788c1092e4ef91fcf137", "patch": "@@ -38,10 +38,10 @@ use syntax_pos::Span;\n // ```rust\n // fn super_basic_block_data(&mut self,\n //                           block: BasicBlock,\n-//                           data: & $($mutability)* BasicBlockData<'tcx>) {\n+//                           data: & $($mutability)? BasicBlockData<'tcx>) {\n //     let BasicBlockData {\n-//         ref $($mutability)* statements,\n-//         ref $($mutability)* terminator,\n+//         statements,\n+//         terminator,\n //         is_cleanup: _\n //     } = *data;\n //\n@@ -67,111 +67,111 @@ use syntax_pos::Span;\n // `is_cleanup` above.\n \n macro_rules! make_mir_visitor {\n-    ($visitor_trait_name:ident, $($mutability:ident)*) => {\n+    ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         pub trait $visitor_trait_name<'tcx> {\n             // Override these, and call `self.super_xxx` to revert back to the\n             // default behavior.\n \n-            fn visit_mir(&mut self, mir: & $($mutability)* Mir<'tcx>) {\n+            fn visit_mir(&mut self, mir: & $($mutability)? Mir<'tcx>) {\n                 self.super_mir(mir);\n             }\n \n             fn visit_basic_block_data(&mut self,\n                                       block: BasicBlock,\n-                                      data: & $($mutability)* BasicBlockData<'tcx>) {\n+                                      data: & $($mutability)? BasicBlockData<'tcx>) {\n                 self.super_basic_block_data(block, data);\n             }\n \n             fn visit_source_scope_data(&mut self,\n-                                           scope_data: & $($mutability)* SourceScopeData) {\n+                                           scope_data: & $($mutability)? SourceScopeData) {\n                 self.super_source_scope_data(scope_data);\n             }\n \n             fn visit_statement(&mut self,\n                                block: BasicBlock,\n-                               statement: & $($mutability)* Statement<'tcx>,\n+                               statement: & $($mutability)? Statement<'tcx>,\n                                location: Location) {\n                 self.super_statement(block, statement, location);\n             }\n \n             fn visit_assign(&mut self,\n                             block: BasicBlock,\n-                            place: & $($mutability)* Place<'tcx>,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.super_assign(block, place, rvalue, location);\n             }\n \n             fn visit_terminator(&mut self,\n                                 block: BasicBlock,\n-                                terminator: & $($mutability)* Terminator<'tcx>,\n+                                terminator: & $($mutability)? Terminator<'tcx>,\n                                 location: Location) {\n                 self.super_terminator(block, terminator, location);\n             }\n \n             fn visit_terminator_kind(&mut self,\n                                      block: BasicBlock,\n-                                     kind: & $($mutability)* TerminatorKind<'tcx>,\n+                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n                                      location: Location) {\n                 self.super_terminator_kind(block, kind, location);\n             }\n \n             fn visit_assert_message(&mut self,\n-                                    msg: & $($mutability)* AssertMessage<'tcx>,\n+                                    msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n                 self.super_assert_message(msg, location);\n             }\n \n             fn visit_rvalue(&mut self,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.super_rvalue(rvalue, location);\n             }\n \n             fn visit_operand(&mut self,\n-                             operand: & $($mutability)* Operand<'tcx>,\n+                             operand: & $($mutability)? Operand<'tcx>,\n                              location: Location) {\n                 self.super_operand(operand, location);\n             }\n \n             fn visit_ascribe_user_ty(&mut self,\n-                                     place: & $($mutability)* Place<'tcx>,\n-                                     variance: & $($mutability)* ty::Variance,\n-                                     user_ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                                     place: & $($mutability)? Place<'tcx>,\n+                                     variance: & $($mutability)? ty::Variance,\n+                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n                                      location: Location) {\n                 self.super_ascribe_user_ty(place, variance, user_ty, location);\n             }\n \n             fn visit_retag(&mut self,\n-                           kind: & $($mutability)* RetagKind,\n-                           place: & $($mutability)* Place<'tcx>,\n+                           kind: & $($mutability)? RetagKind,\n+                           place: & $($mutability)? Place<'tcx>,\n                            location: Location) {\n                 self.super_retag(kind, place, location);\n             }\n \n             fn visit_place(&mut self,\n-                            place: & $($mutability)* Place<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n                 self.super_place(place, context, location);\n             }\n \n             fn visit_static(&mut self,\n-                            static_: & $($mutability)* Static<'tcx>,\n+                            static_: & $($mutability)? Static<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n                 self.super_static(static_, context, location);\n             }\n \n             fn visit_projection(&mut self,\n-                                place: & $($mutability)* PlaceProjection<'tcx>,\n+                                place: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,\n                                 location: Location) {\n                 self.super_projection(place, context, location);\n             }\n \n             fn visit_projection_elem(&mut self,\n-                                     place: & $($mutability)* PlaceElem<'tcx>,\n+                                     place: & $($mutability)? PlaceElem<'tcx>,\n                                      location: Location) {\n                 self.super_projection_elem(place, location);\n             }\n@@ -183,101 +183,101 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_constant(&mut self,\n-                              constant: & $($mutability)* Constant<'tcx>,\n+                              constant: & $($mutability)? Constant<'tcx>,\n                               location: Location) {\n                 self.super_constant(constant, location);\n             }\n \n             fn visit_def_id(&mut self,\n-                            def_id: & $($mutability)* DefId,\n+                            def_id: & $($mutability)? DefId,\n                             _: Location) {\n                 self.super_def_id(def_id);\n             }\n \n             fn visit_span(&mut self,\n-                          span: & $($mutability)* Span) {\n+                          span: & $($mutability)? Span) {\n                 self.super_span(span);\n             }\n \n             fn visit_source_info(&mut self,\n-                                 source_info: & $($mutability)* SourceInfo) {\n+                                 source_info: & $($mutability)? SourceInfo) {\n                 self.super_source_info(source_info);\n             }\n \n             fn visit_ty(&mut self,\n-                        ty: & $($mutability)* Ty<'tcx>,\n+                        ty: & $($mutability)? Ty<'tcx>,\n                         _: TyContext) {\n                 self.super_ty(ty);\n             }\n \n             fn visit_user_type_projection(\n                 &mut self,\n-                ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                ty: & $($mutability)? UserTypeProjection<'tcx>,\n             ) {\n                 self.super_user_type_projection(ty);\n             }\n \n             fn visit_user_type_annotation(\n                 &mut self,\n                 index: UserTypeAnnotationIndex,\n-                ty: & $($mutability)* CanonicalUserTypeAnnotation<'tcx>,\n+                ty: & $($mutability)? CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n                 self.super_user_type_annotation(index, ty);\n             }\n \n             fn visit_region(&mut self,\n-                            region: & $($mutability)* ty::Region<'tcx>,\n+                            region: & $($mutability)? ty::Region<'tcx>,\n                             _: Location) {\n                 self.super_region(region);\n             }\n \n             fn visit_const(&mut self,\n-                           constant: & $($mutability)* &'tcx ty::LazyConst<'tcx>,\n+                           constant: & $($mutability)? &'tcx ty::LazyConst<'tcx>,\n                            _: Location) {\n                 self.super_const(constant);\n             }\n \n             fn visit_substs(&mut self,\n-                            substs: & $($mutability)* &'tcx Substs<'tcx>,\n+                            substs: & $($mutability)? &'tcx Substs<'tcx>,\n                             _: Location) {\n                 self.super_substs(substs);\n             }\n \n             fn visit_closure_substs(&mut self,\n-                                    substs: & $($mutability)* ClosureSubsts<'tcx>,\n+                                    substs: & $($mutability)? ClosureSubsts<'tcx>,\n                                     _: Location) {\n                 self.super_closure_substs(substs);\n             }\n \n             fn visit_generator_substs(&mut self,\n-                                      substs: & $($mutability)* GeneratorSubsts<'tcx>,\n+                                      substs: & $($mutability)? GeneratorSubsts<'tcx>,\n                                     _: Location) {\n                 self.super_generator_substs(substs);\n             }\n \n             fn visit_local_decl(&mut self,\n                                 local: Local,\n-                                local_decl: & $($mutability)* LocalDecl<'tcx>) {\n+                                local_decl: & $($mutability)? LocalDecl<'tcx>) {\n                 self.super_local_decl(local, local_decl);\n             }\n \n             fn visit_local(&mut self,\n-                            _local: & $($mutability)* Local,\n+                            _local: & $($mutability)? Local,\n                             _context: PlaceContext<'tcx>,\n                             _location: Location) {\n             }\n \n             fn visit_source_scope(&mut self,\n-                                      scope: & $($mutability)* SourceScope) {\n+                                      scope: & $($mutability)? SourceScope) {\n                 self.super_source_scope(scope);\n             }\n \n             // The `super_xxx` methods comprise the default behavior and are\n             // not meant to be overridden.\n \n             fn super_mir(&mut self,\n-                         mir: & $($mutability)* Mir<'tcx>) {\n-                if let Some(yield_ty) = &$($mutability)* mir.yield_ty {\n+                         mir: & $($mutability)? Mir<'tcx>) {\n+                if let Some(yield_ty) = &$($mutability)? mir.yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n                         span: mir.span,\n                         scope: OUTERMOST_SOURCE_SCOPE,\n@@ -291,45 +291,45 @@ macro_rules! make_mir_visitor {\n                     (mut) => (mir.basic_blocks_mut().iter_enumerated_mut());\n                     () => (mir.basic_blocks().iter_enumerated());\n                 };\n-                for (bb, data) in basic_blocks!($($mutability)*) {\n+                for (bb, data) in basic_blocks!($($mutability)?) {\n                     self.visit_basic_block_data(bb, data);\n                 }\n \n-                for scope in &$($mutability)* mir.source_scopes {\n+                for scope in &$($mutability)? mir.source_scopes {\n                     self.visit_source_scope_data(scope);\n                 }\n \n-                self.visit_ty(&$($mutability)* mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n+                self.visit_ty(&$($mutability)? mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n                     span: mir.span,\n                     scope: OUTERMOST_SOURCE_SCOPE,\n                 }));\n \n                 for local in mir.local_decls.indices() {\n-                    self.visit_local_decl(local, & $($mutability)* mir.local_decls[local]);\n+                    self.visit_local_decl(local, & $($mutability)? mir.local_decls[local]);\n                 }\n \n                 macro_rules! type_annotations {\n                     (mut) => (mir.user_type_annotations.iter_enumerated_mut());\n                     () => (mir.user_type_annotations.iter_enumerated());\n                 };\n \n-                for (index, annotation) in type_annotations!($($mutability)*) {\n+                for (index, annotation) in type_annotations!($($mutability)?) {\n                     self.visit_user_type_annotation(\n                         index, annotation\n                     );\n                 }\n \n-                self.visit_span(&$($mutability)* mir.span);\n+                self.visit_span(&$($mutability)? mir.span);\n             }\n \n             fn super_basic_block_data(&mut self,\n                                       block: BasicBlock,\n-                                      data: & $($mutability)* BasicBlockData<'tcx>) {\n+                                      data: & $($mutability)? BasicBlockData<'tcx>) {\n                 let BasicBlockData {\n-                    ref $($mutability)* statements,\n-                    ref $($mutability)* terminator,\n+                    statements,\n+                    terminator,\n                     is_cleanup: _\n-                } = *data;\n+                } = data;\n \n                 let mut index = 0;\n                 for statement in statements {\n@@ -338,92 +338,83 @@ macro_rules! make_mir_visitor {\n                     index += 1;\n                 }\n \n-                if let Some(ref $($mutability)* terminator) = *terminator {\n+                if let Some(terminator) = terminator {\n                     let location = Location { block: block, statement_index: index };\n                     self.visit_terminator(block, terminator, location);\n                 }\n             }\n \n-            fn super_source_scope_data(&mut self,\n-                                           scope_data: & $($mutability)* SourceScopeData) {\n+            fn super_source_scope_data(&mut self, scope_data: & $($mutability)? SourceScopeData) {\n                 let SourceScopeData {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* parent_scope,\n-                } = *scope_data;\n+                    span,\n+                    parent_scope,\n+                } = scope_data;\n \n                 self.visit_span(span);\n-                if let Some(ref $($mutability)* parent_scope) = *parent_scope {\n+                if let Some(parent_scope) = parent_scope {\n                     self.visit_source_scope(parent_scope);\n                 }\n             }\n \n             fn super_statement(&mut self,\n                                block: BasicBlock,\n-                               statement: & $($mutability)* Statement<'tcx>,\n+                               statement: & $($mutability)? Statement<'tcx>,\n                                location: Location) {\n                 let Statement {\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* kind,\n-                } = *statement;\n+                    source_info,\n+                    kind,\n+                } = statement;\n \n                 self.visit_source_info(source_info);\n-                match *kind {\n-                    StatementKind::Assign(ref $($mutability)* place,\n-                                          ref $($mutability)* rvalue) => {\n+                match kind {\n+                    StatementKind::Assign(place, rvalue) => {\n                         self.visit_assign(block, place, rvalue, location);\n                     }\n-                    StatementKind::FakeRead(_, ref $($mutability)* place) => {\n+                    StatementKind::FakeRead(_, place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n-                    StatementKind::SetDiscriminant{ ref $($mutability)* place, .. } => {\n+                    StatementKind::SetDiscriminant { place, .. } => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::MutatingUse(MutatingUseContext::Store),\n                             location\n                         );\n                     }\n-                    StatementKind::StorageLive(ref $($mutability)* local) => {\n+                    StatementKind::StorageLive(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonUse(NonUseContext::StorageLive),\n                             location\n                         );\n                     }\n-                    StatementKind::StorageDead(ref $($mutability)* local) => {\n+                    StatementKind::StorageDead(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonUse(NonUseContext::StorageDead),\n                             location\n                         );\n                     }\n-                    StatementKind::InlineAsm { ref $($mutability)* outputs,\n-                                               ref $($mutability)* inputs,\n-                                               asm: _ } => {\n-                        for output in & $($mutability)* outputs[..] {\n+                    StatementKind::InlineAsm { outputs, inputs, asm: _ } => {\n+                        for output in & $($mutability)? outputs[..] {\n                             self.visit_place(\n                                 output,\n                                 PlaceContext::MutatingUse(MutatingUseContext::AsmOutput),\n                                 location\n                             );\n                         }\n-                        for (span, input) in & $($mutability)* inputs[..] {\n+                        for (span, input) in & $($mutability)? inputs[..] {\n                             self.visit_span(span);\n                             self.visit_operand(input, location);\n                         }\n                     }\n-                    StatementKind::Retag ( ref $($mutability)* kind,\n-                                           ref $($mutability)* place ) => {\n+                    StatementKind::Retag(kind, place) => {\n                         self.visit_retag(kind, place, location);\n                     }\n-                    StatementKind::AscribeUserType(\n-                        ref $($mutability)* place,\n-                        ref $($mutability)* variance,\n-                        ref $($mutability)* user_ty,\n-                    ) => {\n+                    StatementKind::AscribeUserType(place, variance, user_ty) => {\n                         self.visit_ascribe_user_ty(place, variance, user_ty, location);\n                     }\n                     StatementKind::Nop => {}\n@@ -432,8 +423,8 @@ macro_rules! make_mir_visitor {\n \n             fn super_assign(&mut self,\n                             _block: BasicBlock,\n-                            place: &$($mutability)* Place<'tcx>,\n-                            rvalue: &$($mutability)* Rvalue<'tcx>,\n+                            place: &$($mutability)? Place<'tcx>,\n+                            rvalue: &$($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.visit_place(\n                     place,\n@@ -445,34 +436,33 @@ macro_rules! make_mir_visitor {\n \n             fn super_terminator(&mut self,\n                                 block: BasicBlock,\n-                                terminator: &$($mutability)* Terminator<'tcx>,\n+                                terminator: &$($mutability)? Terminator<'tcx>,\n                                 location: Location) {\n-                let Terminator {\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* kind,\n-                } = *terminator;\n+                let Terminator { source_info, kind } = terminator;\n \n                 self.visit_source_info(source_info);\n                 self.visit_terminator_kind(block, kind, location);\n             }\n \n             fn super_terminator_kind(&mut self,\n                                      block: BasicBlock,\n-                                     kind: & $($mutability)* TerminatorKind<'tcx>,\n+                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n                                      source_location: Location) {\n-                match *kind {\n+                match kind {\n                     TerminatorKind::Goto { target } => {\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                     }\n \n-                    TerminatorKind::SwitchInt { ref $($mutability)* discr,\n-                                                ref $($mutability)* switch_ty,\n-                                                values: _,\n-                                                ref targets } => {\n+                    TerminatorKind::SwitchInt {\n+                        discr,\n+                        switch_ty,\n+                        values: _,\n+                        targets\n+                    } => {\n                         self.visit_operand(discr, source_location);\n                         self.visit_ty(switch_ty, TyContext::Location(source_location));\n-                        for &target in targets {\n-                            self.visit_branch(block, target);\n+                        for target in targets {\n+                            self.visit_branch(block, *target);\n                         }\n                     }\n \n@@ -483,113 +473,120 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Unreachable => {\n                     }\n \n-                    TerminatorKind::Drop { ref $($mutability)* location,\n-                                           target,\n-                                           unwind } => {\n+                    TerminatorKind::Drop {\n+                        location,\n+                        target,\n+                        unwind,\n+                    } => {\n                         self.visit_place(\n                             location,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n                             source_location\n                         );\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::DropAndReplace { ref $($mutability)* location,\n-                                                     ref $($mutability)* value,\n-                                                     target,\n-                                                     unwind } => {\n+                    TerminatorKind::DropAndReplace {\n+                        location,\n+                        value,\n+                        target,\n+                        unwind,\n+                    } => {\n                         self.visit_place(\n                             location,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n                             source_location\n                         );\n                         self.visit_operand(value, source_location);\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Call { ref $($mutability)* func,\n-                                           ref $($mutability)* args,\n-                                           ref $($mutability)* destination,\n-                                           cleanup,\n-                                           from_hir_call: _, } => {\n+                    TerminatorKind::Call {\n+                        func,\n+                        args,\n+                        destination,\n+                        cleanup,\n+                        from_hir_call: _,\n+                    } => {\n                         self.visit_operand(func, source_location);\n                         for arg in args {\n                             self.visit_operand(arg, source_location);\n                         }\n-                        if let Some((ref $($mutability)* destination, target)) = *destination {\n+                        if let Some((destination, target)) = destination {\n                             self.visit_place(\n                                 destination,\n                                 PlaceContext::MutatingUse(MutatingUseContext::Call),\n                                 source_location\n                             );\n-                            self.visit_branch(block, target);\n+                            self.visit_branch(block, *target);\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Assert { ref $($mutability)* cond,\n-                                             expected: _,\n-                                             ref $($mutability)* msg,\n-                                             target,\n-                                             cleanup } => {\n+                    TerminatorKind::Assert {\n+                        cond,\n+                        expected: _,\n+                        msg,\n+                        target,\n+                        cleanup,\n+                    } => {\n                         self.visit_operand(cond, source_location);\n                         self.visit_assert_message(msg, source_location);\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Yield { ref $($mutability)* value,\n-                                              resume,\n-                                              drop } => {\n+                    TerminatorKind::Yield {\n+                        value,\n+                        resume,\n+                        drop,\n+                    } => {\n                         self.visit_operand(value, source_location);\n-                        self.visit_branch(block, resume);\n+                        self.visit_branch(block, *resume);\n                         drop.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::FalseEdges { real_target, ref imaginary_targets} => {\n-                        self.visit_branch(block, real_target);\n+                    TerminatorKind::FalseEdges { real_target, imaginary_targets } => {\n+                        self.visit_branch(block, *real_target);\n                         for target in imaginary_targets {\n                             self.visit_branch(block, *target);\n                         }\n                     }\n \n                     TerminatorKind::FalseUnwind { real_target, unwind } => {\n-                        self.visit_branch(block, real_target);\n+                        self.visit_branch(block, *real_target);\n                         if let Some(unwind) = unwind {\n-                            self.visit_branch(block, unwind);\n+                            self.visit_branch(block, *unwind);\n                         }\n                     }\n                 }\n             }\n \n             fn super_assert_message(&mut self,\n-                                    msg: & $($mutability)* AssertMessage<'tcx>,\n+                                    msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n                 use crate::mir::interpret::EvalErrorKind::*;\n-                if let BoundsCheck {\n-                        ref $($mutability)* len,\n-                        ref $($mutability)* index\n-                    } = *msg {\n+                if let BoundsCheck { len, index } = msg {\n                     self.visit_operand(len, location);\n                     self.visit_operand(index, location);\n                 }\n             }\n \n             fn super_rvalue(&mut self,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n-                match *rvalue {\n-                    Rvalue::Use(ref $($mutability)* operand) => {\n+                match rvalue {\n+                    Rvalue::Use(operand) => {\n                         self.visit_operand(operand, location);\n                     }\n \n-                    Rvalue::Repeat(ref $($mutability)* value, _) => {\n+                    Rvalue::Repeat(value, _) => {\n                         self.visit_operand(value, location);\n                     }\n \n-                    Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n+                    Rvalue::Ref(r, bk, path) => {\n                         self.visit_region(r, location);\n                         let ctx = match bk {\n                             BorrowKind::Shared => PlaceContext::NonMutatingUse(\n@@ -607,71 +604,70 @@ macro_rules! make_mir_visitor {\n                         self.visit_place(path, ctx, location);\n                     }\n \n-                    Rvalue::Len(ref $($mutability)* path) => {\n+                    Rvalue::Len(path) => {\n                         self.visit_place(\n                             path,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n \n-                    Rvalue::Cast(_cast_kind,\n-                                 ref $($mutability)* operand,\n-                                 ref $($mutability)* ty) => {\n+                    Rvalue::Cast(_cast_kind, operand, ty) => {\n                         self.visit_operand(operand, location);\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n \n-                    Rvalue::BinaryOp(_bin_op,\n-                                     ref $($mutability)* lhs,\n-                                     ref $($mutability)* rhs) |\n-                    Rvalue::CheckedBinaryOp(_bin_op,\n-                                     ref $($mutability)* lhs,\n-                                     ref $($mutability)* rhs) => {\n+                    Rvalue::BinaryOp(_bin_op, lhs, rhs)\n+                    | Rvalue::CheckedBinaryOp(_bin_op, lhs, rhs) => {\n                         self.visit_operand(lhs, location);\n                         self.visit_operand(rhs, location);\n                     }\n \n-                    Rvalue::UnaryOp(_un_op, ref $($mutability)* op) => {\n+                    Rvalue::UnaryOp(_un_op, op) => {\n                         self.visit_operand(op, location);\n                     }\n \n-                    Rvalue::Discriminant(ref $($mutability)* place) => {\n+                    Rvalue::Discriminant(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n \n-                    Rvalue::NullaryOp(_op, ref $($mutability)* ty) => {\n+                    Rvalue::NullaryOp(_op, ty) => {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n \n-                    Rvalue::Aggregate(ref $($mutability)* kind,\n-                                      ref $($mutability)* operands) => {\n-                        let kind = &$($mutability)* **kind;\n-                        match *kind {\n-                            AggregateKind::Array(ref $($mutability)* ty) => {\n+                    Rvalue::Aggregate(kind, operands) => {\n+                        let kind = &$($mutability)? **kind;\n+                        match kind {\n+                            AggregateKind::Array(ty) => {\n                                 self.visit_ty(ty, TyContext::Location(location));\n                             }\n                             AggregateKind::Tuple => {\n                             }\n-                            AggregateKind::Adt(_adt_def,\n-                                               _variant_index,\n-                                               ref $($mutability)* substs,\n-                                               _user_substs,\n-                                               _active_field_index) => {\n+                            AggregateKind::Adt(\n+                                _adt_def,\n+                                _variant_index,\n+                                substs,\n+                                _user_substs,\n+                                _active_field_index\n+                            ) => {\n                                 self.visit_substs(substs, location);\n                             }\n-                            AggregateKind::Closure(ref $($mutability)* def_id,\n-                                                   ref $($mutability)* closure_substs) => {\n+                            AggregateKind::Closure(\n+                                def_id,\n+                                closure_substs\n+                            ) => {\n                                 self.visit_def_id(def_id, location);\n                                 self.visit_closure_substs(closure_substs, location);\n                             }\n-                            AggregateKind::Generator(ref $($mutability)* def_id,\n-                                                     ref $($mutability)* generator_substs,\n-                                                     _movability) => {\n+                            AggregateKind::Generator(\n+                                def_id,\n+                                generator_substs,\n+                                _movability,\n+                            ) => {\n                                 self.visit_def_id(def_id, location);\n                                 self.visit_generator_substs(generator_substs, location);\n                             }\n@@ -685,33 +681,33 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_operand(&mut self,\n-                             operand: & $($mutability)* Operand<'tcx>,\n+                             operand: & $($mutability)? Operand<'tcx>,\n                              location: Location) {\n-                match *operand {\n-                    Operand::Copy(ref $($mutability)* place) => {\n+                match operand {\n+                    Operand::Copy(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                             location\n                         );\n                     }\n-                    Operand::Move(ref $($mutability)* place) => {\n+                    Operand::Move(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Move),\n                             location\n                         );\n                     }\n-                    Operand::Constant(ref $($mutability)* constant) => {\n+                    Operand::Constant(constant) => {\n                         self.visit_constant(constant, location);\n                     }\n                 }\n             }\n \n             fn super_ascribe_user_ty(&mut self,\n-                                     place: & $($mutability)* Place<'tcx>,\n-                                     _variance: & $($mutability)* ty::Variance,\n-                                     user_ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                                     place: & $($mutability)? Place<'tcx>,\n+                                     _variance: & $($mutability)? ty::Variance,\n+                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n                                      location: Location) {\n                 self.visit_place(\n                     place,\n@@ -722,8 +718,8 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_retag(&mut self,\n-                           _kind: & $($mutability)* RetagKind,\n-                           place: & $($mutability)* Place<'tcx>,\n+                           _kind: & $($mutability)? RetagKind,\n+                           place: & $($mutability)? Place<'tcx>,\n                            location: Location) {\n                 self.visit_place(\n                     place,\n@@ -733,45 +729,39 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_place(&mut self,\n-                            place: & $($mutability)* Place<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n-                match *place {\n-                    Place::Local(ref $($mutability)* local) => {\n+                match place {\n+                    Place::Local(local) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    Place::Static(ref $($mutability)* static_) => {\n+                    Place::Static(static_) => {\n                         self.visit_static(static_, context, location);\n                     }\n-                    Place::Promoted(ref $($mutability)* promoted) => {\n-                        self.visit_ty(& $($mutability)* promoted.1, TyContext::Location(location));\n+                    Place::Promoted(promoted) => {\n+                        self.visit_ty(& $($mutability)? promoted.1, TyContext::Location(location));\n                     },\n-                    Place::Projection(ref $($mutability)* proj) => {\n+                    Place::Projection(proj) => {\n                         self.visit_projection(proj, context, location);\n                     }\n                 }\n             }\n \n             fn super_static(&mut self,\n-                            static_: & $($mutability)* Static<'tcx>,\n+                            static_: & $($mutability)? Static<'tcx>,\n                             _context: PlaceContext<'tcx>,\n                             location: Location) {\n-                let Static {\n-                    ref $($mutability)* def_id,\n-                    ref $($mutability)* ty,\n-                } = *static_;\n+                let Static { def_id, ty } = static_;\n                 self.visit_def_id(def_id, location);\n                 self.visit_ty(ty, TyContext::Location(location));\n             }\n \n             fn super_projection(&mut self,\n-                                proj: & $($mutability)* PlaceProjection<'tcx>,\n+                                proj: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,\n                                 location: Location) {\n-                let Projection {\n-                    ref $($mutability)* base,\n-                    ref $($mutability)* elem,\n-                } = *proj;\n+                let Projection { base, elem } = proj;\n                 let context = if context.is_mutating_use() {\n                     PlaceContext::MutatingUse(MutatingUseContext::Projection)\n                 } else {\n@@ -782,17 +772,17 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_projection_elem(&mut self,\n-                                     proj: & $($mutability)* PlaceElem<'tcx>,\n+                                     proj: & $($mutability)? PlaceElem<'tcx>,\n                                      location: Location) {\n-                match *proj {\n+                match proj {\n                     ProjectionElem::Deref => {\n                     }\n                     ProjectionElem::Subslice { from: _, to: _ } => {\n                     }\n-                    ProjectionElem::Field(_field, ref $($mutability)* ty) => {\n+                    ProjectionElem::Field(_field, ty) => {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n-                    ProjectionElem::Index(ref $($mutability)* local) => {\n+                    ProjectionElem::Index(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n@@ -810,32 +800,32 @@ macro_rules! make_mir_visitor {\n \n             fn super_local_decl(&mut self,\n                                 local: Local,\n-                                local_decl: & $($mutability)* LocalDecl<'tcx>) {\n+                                local_decl: & $($mutability)? LocalDecl<'tcx>) {\n                 let LocalDecl {\n                     mutability: _,\n-                    ref $($mutability)* ty,\n-                    ref $($mutability)* user_ty,\n+                    ty,\n+                    user_ty,\n                     name: _,\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* visibility_scope,\n+                    source_info,\n+                    visibility_scope,\n                     internal: _,\n                     is_user_variable: _,\n                     is_block_tail: _,\n-                } = *local_decl;\n+                } = local_decl;\n \n                 self.visit_ty(ty, TyContext::LocalDecl {\n                     local,\n                     source_info: *source_info,\n                 });\n-                for (user_ty, _) in & $($mutability)* user_ty.contents {\n+                for (user_ty, _) in & $($mutability)? user_ty.contents {\n                     self.visit_user_type_projection(user_ty);\n                 }\n                 self.visit_source_info(source_info);\n                 self.visit_source_scope(visibility_scope);\n             }\n \n             fn super_source_scope(&mut self,\n-                                      _scope: & $($mutability)* SourceScope) {\n+                                      _scope: & $($mutability)? SourceScope) {\n             }\n \n             fn super_branch(&mut self,\n@@ -844,82 +834,82 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_constant(&mut self,\n-                              constant: & $($mutability)* Constant<'tcx>,\n+                              constant: & $($mutability)? Constant<'tcx>,\n                               location: Location) {\n                 let Constant {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* ty,\n-                    ref $($mutability)* user_ty,\n-                    ref $($mutability)* literal,\n-                } = *constant;\n+                    span,\n+                    ty,\n+                    user_ty,\n+                    literal,\n+                } = constant;\n \n                 self.visit_span(span);\n                 self.visit_ty(ty, TyContext::Location(location));\n                 drop(user_ty); // no visit method for this\n                 self.visit_const(literal, location);\n             }\n \n-            fn super_def_id(&mut self, _def_id: & $($mutability)* DefId) {\n+            fn super_def_id(&mut self, _def_id: & $($mutability)? DefId) {\n             }\n \n-            fn super_span(&mut self, _span: & $($mutability)* Span) {\n+            fn super_span(&mut self, _span: & $($mutability)? Span) {\n             }\n \n-            fn super_source_info(&mut self, source_info: & $($mutability)* SourceInfo) {\n+            fn super_source_info(&mut self, source_info: & $($mutability)? SourceInfo) {\n                 let SourceInfo {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* scope,\n-                } = *source_info;\n+                    span,\n+                    scope,\n+                } = source_info;\n \n                 self.visit_span(span);\n                 self.visit_source_scope(scope);\n             }\n \n             fn super_user_type_projection(\n                 &mut self,\n-                _ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                _ty: & $($mutability)? UserTypeProjection<'tcx>,\n             ) {\n             }\n \n             fn super_user_type_annotation(\n                 &mut self,\n                 _index: UserTypeAnnotationIndex,\n-                ty: & $($mutability)* CanonicalUserTypeAnnotation<'tcx>,\n+                ty: & $($mutability)? CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n-                self.visit_span(& $($mutability)* ty.span);\n-                self.visit_ty(& $($mutability)* ty.inferred_ty, TyContext::UserTy(ty.span));\n+                self.visit_span(& $($mutability)? ty.span);\n+                self.visit_ty(& $($mutability)? ty.inferred_ty, TyContext::UserTy(ty.span));\n             }\n \n-            fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n+            fn super_ty(&mut self, _ty: & $($mutability)? Ty<'tcx>) {\n             }\n \n-            fn super_region(&mut self, _region: & $($mutability)* ty::Region<'tcx>) {\n+            fn super_region(&mut self, _region: & $($mutability)? ty::Region<'tcx>) {\n             }\n \n-            fn super_const(&mut self, _const: & $($mutability)* &'tcx ty::LazyConst<'tcx>) {\n+            fn super_const(&mut self, _const: & $($mutability)? &'tcx ty::LazyConst<'tcx>) {\n             }\n \n-            fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {\n+            fn super_substs(&mut self, _substs: & $($mutability)? &'tcx Substs<'tcx>) {\n             }\n \n             fn super_generator_substs(&mut self,\n-                                      _substs: & $($mutability)* GeneratorSubsts<'tcx>) {\n+                                      _substs: & $($mutability)? GeneratorSubsts<'tcx>) {\n             }\n \n             fn super_closure_substs(&mut self,\n-                                    _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n+                                    _substs: & $($mutability)? ClosureSubsts<'tcx>) {\n             }\n \n             // Convenience methods\n \n-            fn visit_location(&mut self, mir: & $($mutability)* Mir<'tcx>, location: Location) {\n-                let basic_block = & $($mutability)* mir[location.block];\n+            fn visit_location(&mut self, mir: & $($mutability)? Mir<'tcx>, location: Location) {\n+                let basic_block = & $($mutability)? mir[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n-                    if let Some(ref $($mutability)* terminator) = basic_block.terminator {\n+                    if let Some(ref $($mutability)? terminator) = basic_block.terminator {\n                         self.visit_terminator(location.block, terminator, location)\n                     }\n                 } else {\n-                    let statement = & $($mutability)*\n+                    let statement = & $($mutability)?\n                         basic_block.statements[location.statement_index];\n                     self.visit_statement(location.block, statement, location)\n                 }"}]}