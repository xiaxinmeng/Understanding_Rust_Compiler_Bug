{"sha": "197cc1e43afba388a0266a08d2b946a187b766bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5N2NjMWU0M2FmYmEzODhhMDI2NmEwOGQyYjk0NmExODdiNzY2YmI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2020-01-22T11:17:21Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2020-01-23T15:56:59Z"}, "message": "Add projection query for upstream drop-glue instances.\n\nThis reduces the amount of invalidated data when new types are\nadd to upstream crates.", "tree": {"sha": "74a4b064655c776105752655c23056ab580683e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74a4b064655c776105752655c23056ab580683e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/197cc1e43afba388a0266a08d2b946a187b766bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/197cc1e43afba388a0266a08d2b946a187b766bb", "html_url": "https://github.com/rust-lang/rust/commit/197cc1e43afba388a0266a08d2b946a187b766bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/197cc1e43afba388a0266a08d2b946a187b766bb/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ceb92bc53a849e36341c3fd619cb49470e224e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ceb92bc53a849e36341c3fd619cb49470e224e2", "html_url": "https://github.com/rust-lang/rust/commit/2ceb92bc53a849e36341c3fd619cb49470e224e2"}], "stats": {"total": 236, "additions": 138, "deletions": 98}, "files": [{"sha": "1f4318fa537514bf33c0726f49e4db3bb188440a", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=197cc1e43afba388a0266a08d2b946a187b766bb", "patch": "@@ -1,9 +1,7 @@\n-use crate::ich::StableHashingContext;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, TyCtxt};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use std::mem;\n+use rustc_macros::HashStable;\n \n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any\n@@ -23,10 +21,11 @@ impl SymbolExportLevel {\n     }\n }\n \n-#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ExportedSymbol<'tcx> {\n     NonGeneric(DefId),\n     Generic(DefId, SubstsRef<'tcx>),\n+    DropGlue(Ty<'tcx>),\n     NoDefId(ty::SymbolName),\n }\n \n@@ -39,6 +38,9 @@ impl<'tcx> ExportedSymbol<'tcx> {\n             ExportedSymbol::Generic(def_id, substs) => {\n                 tcx.symbol_name(ty::Instance::new(def_id, substs))\n             }\n+            ExportedSymbol::DropGlue(ty) => {\n+                tcx.symbol_name(ty::Instance::resolve_drop_in_place(tcx, ty))\n+            }\n             ExportedSymbol::NoDefId(symbol_name) => symbol_name,\n         }\n     }\n@@ -51,21 +53,3 @@ pub fn metadata_symbol_name(tcx: TyCtxt<'_>) -> String {\n         tcx.crate_disambiguator(LOCAL_CRATE).to_fingerprint().to_hex()\n     )\n }\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ExportedSymbol<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ExportedSymbol::NonGeneric(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            ExportedSymbol::Generic(def_id, substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            ExportedSymbol::NoDefId(symbol_name) => {\n-                symbol_name.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}"}, {"sha": "37d5e23535b817be97008ca94011f886958a8149", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=197cc1e43afba388a0266a08d2b946a187b766bb", "patch": "@@ -776,13 +776,47 @@ rustc_queries! {\n     }\n \n     Codegen {\n+        /// The entire set of monomorphizations the local crate can safely link\n+        /// to because they are exported from upstream crates. Do not depend on\n+        /// this directly, as its value changes anytime a monomorphization gets\n+        /// added or removed in any upstream crate. Instead use the narrower\n+        /// `upstream_monomorphizations_for`, `upstream_drop_glue_for`, or, even\n+        /// better, `Instance::upstream_monomorphization()`.\n         query upstream_monomorphizations(\n             k: CrateNum\n         ) -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n             desc { \"collecting available upstream monomorphizations `{:?}`\", k }\n         }\n+\n+        /// Returns the set of upstream monomorphizations available for the\n+        /// generic function identified by the given `def_id`. The query makes\n+        /// sure to make a stable selection if the same monomorphization is\n+        /// available in multiple upstream crates.\n+        ///\n+        /// You likely want to call `Instance::upstream_monomorphization()`\n+        /// instead of invoking this query directly.\n         query upstream_monomorphizations_for(_: DefId)\n             -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {}\n+\n+        /// Returns the upstream crate that exports drop-glue for the given\n+        /// type (`substs` is expected to be a single-item list containing the\n+        /// type one wants drop-glue for).\n+        ///\n+        /// This is a subset of `upstream_monomorphizations_for` in order to\n+        /// increase dep-tracking granularity. Otherwise adding or removing any\n+        /// type with drop-glue in any upstream crate would invalidate all\n+        /// functions calling drop-glue of an upstream type.\n+        ///\n+        /// You likely want to call `Instance::upstream_monomorphization()`\n+        /// instead of invoking this query directly.\n+        ///\n+        /// NOTE: This query could easily be extended to also support other\n+        ///       common functions that have are large set of monomorphizations\n+        ///       (like `Clone::clone` for example).\n+        query upstream_drop_glue_for(substs: SubstsRef<'tcx>) -> Option<CrateNum> {\n+            desc { \"available upstream drop-glue for `{:?}`\", substs }\n+            no_force\n+        }\n     }\n \n     Other {"}, {"sha": "51a18f8eae2741c418e8d1b56d625bea0886f616", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=197cc1e43afba388a0266a08d2b946a187b766bb", "patch": "@@ -4,7 +4,7 @@ use crate::traits;\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::{self, SubstsRef, Ty, TyCtxt, TypeFoldable};\n use rustc_hir::def::Namespace;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_macros::HashStable;\n use rustc_target::spec::abi::Abi;\n \n@@ -91,6 +91,40 @@ impl<'tcx> Instance<'tcx> {\n         let ty = tcx.type_of(self.def.def_id());\n         tcx.subst_and_normalize_erasing_regions(self.substs, param_env, &ty)\n     }\n+\n+    /// Finds a crate that contains a monomorphization of this instance that\n+    /// can be linked to from the local crate. A return value of `None` means\n+    /// no upstream crate provides such an exported monomorphization.\n+    ///\n+    /// This method already takes into account the global `-Zshare-generics`\n+    /// setting, always returning `None` if `share-generics` is off.\n+    pub fn upstream_monomorphization(&self, tcx: TyCtxt<'tcx>) -> Option<CrateNum> {\n+        // If we are not in share generics mode, we don't link to upstream\n+        // monomorphizations but always instantiate our own internal versions\n+        // instead.\n+        if !tcx.sess.opts.share_generics() {\n+            return None;\n+        }\n+\n+        // If this is an item that is defined in the local crate, no upstream\n+        // crate can know about it/provide a monomorphization.\n+        if self.def_id().is_local() {\n+            return None;\n+        }\n+\n+        // If this a non-generic instance, it cannot be a shared monomorphization.\n+        if self.substs.non_erasable_generics().next().is_none() {\n+            return None;\n+        }\n+\n+        match self.def {\n+            InstanceDef::Item(def_id) => tcx\n+                .upstream_monomorphizations_for(def_id)\n+                .and_then(|monos| monos.get(&self.substs).cloned()),\n+            InstanceDef::DropGlue(_, Some(_)) => tcx.upstream_drop_glue_for(self.substs),\n+            _ => None,\n+        }\n+    }\n }\n \n impl<'tcx> InstanceDef<'tcx> {"}, {"sha": "c1c88e96f94b5d3c5c0140a25355bad68e639bac", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=197cc1e43afba388a0266a08d2b946a187b766bb", "patch": "@@ -116,6 +116,15 @@ impl Key for (DefId, SimplifiedType) {\n     }\n }\n \n+impl<'tcx> Key for SubstsRef<'tcx> {\n+    fn query_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate"}, {"sha": "04d92142266ee03dec42516620484f3d5a984cf0", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=197cc1e43afba388a0266a08d2b946a187b766bb", "patch": "@@ -130,12 +130,7 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n                     } else {\n                         // This is a monomorphization of a generic function\n                         // defined in an upstream crate.\n-                        if cx\n-                            .tcx\n-                            .upstream_monomorphizations_for(instance_def_id)\n-                            .map(|set| set.contains_key(instance.substs))\n-                            .unwrap_or(false)\n-                        {\n+                        if instance.upstream_monomorphization(tcx).is_some() {\n                             // This is instantiated in another crate. It cannot\n                             // be `hidden`.\n                         } else {"}, {"sha": "a6cd0c09684dddbeb129a923930c051d0f133f2f", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=197cc1e43afba388a0266a08d2b946a187b766bb", "patch": "@@ -255,14 +255,13 @@ fn exported_symbols_provider_local(\n                         symbols.push((symbol, SymbolExportLevel::Rust));\n                     }\n                 }\n-                MonoItem::Fn(Instance { def: InstanceDef::DropGlue(def_id, Some(ty)), substs }) => {\n+                MonoItem::Fn(Instance { def: InstanceDef::DropGlue(_, Some(ty)), substs }) => {\n                     // A little sanity-check\n                     debug_assert_eq!(\n                         substs.non_erasable_generics().next(),\n                         Some(GenericArgKind::Type(ty))\n                     );\n-                    let symbol = ExportedSymbol::Generic(def_id, substs);\n-                    symbols.push((symbol, SymbolExportLevel::Rust));\n+                    symbols.push((ExportedSymbol::DropGlue(ty), SymbolExportLevel::Rust));\n                 }\n                 _ => {\n                     // Any other symbols don't qualify for sharing\n@@ -298,24 +297,41 @@ fn upstream_monomorphizations_provider(\n         cnum_stable_ids\n     };\n \n+    let drop_in_place_fn_def_id = tcx.lang_items().drop_in_place_fn();\n+\n     for &cnum in cnums.iter() {\n         for (exported_symbol, _) in tcx.exported_symbols(cnum).iter() {\n-            if let &ExportedSymbol::Generic(def_id, substs) = exported_symbol {\n-                let substs_map = instances.entry(def_id).or_default();\n-\n-                match substs_map.entry(substs) {\n-                    Occupied(mut e) => {\n-                        // If there are multiple monomorphizations available,\n-                        // we select one deterministically.\n-                        let other_cnum = *e.get();\n-                        if cnum_stable_ids[other_cnum] > cnum_stable_ids[cnum] {\n-                            e.insert(cnum);\n-                        }\n+            let (def_id, substs) = match *exported_symbol {\n+                ExportedSymbol::Generic(def_id, substs) => (def_id, substs),\n+                ExportedSymbol::DropGlue(ty) => {\n+                    if let Some(drop_in_place_fn_def_id) = drop_in_place_fn_def_id {\n+                        (drop_in_place_fn_def_id, tcx.intern_substs(&[ty.into()]))\n+                    } else {\n+                        // `drop_in_place` in place does not exist, don't try\n+                        // to use it.\n+                        continue;\n                     }\n-                    Vacant(e) => {\n+                }\n+                ExportedSymbol::NonGeneric(..) | ExportedSymbol::NoDefId(..) => {\n+                    // These are no monomorphizations\n+                    continue;\n+                }\n+            };\n+\n+            let substs_map = instances.entry(def_id).or_default();\n+\n+            match substs_map.entry(substs) {\n+                Occupied(mut e) => {\n+                    // If there are multiple monomorphizations available,\n+                    // we select one deterministically.\n+                    let other_cnum = *e.get();\n+                    if cnum_stable_ids[other_cnum] > cnum_stable_ids[cnum] {\n                         e.insert(cnum);\n                     }\n                 }\n+                Vacant(e) => {\n+                    e.insert(cnum);\n+                }\n             }\n         }\n     }\n@@ -331,6 +347,17 @@ fn upstream_monomorphizations_for_provider(\n     tcx.upstream_monomorphizations(LOCAL_CRATE).get(&def_id)\n }\n \n+fn upstream_drop_glue_for_provider<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    substs: SubstsRef<'tcx>,\n+) -> Option<CrateNum> {\n+    if let Some(def_id) = tcx.lang_items().drop_in_place_fn() {\n+        tcx.upstream_monomorphizations_for(def_id).and_then(|monos| monos.get(&substs).cloned())\n+    } else {\n+        None\n+    }\n+}\n+\n fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n         !tcx.reachable_set(LOCAL_CRATE).contains(&hir_id)\n@@ -345,6 +372,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.exported_symbols = exported_symbols_provider_local;\n     providers.upstream_monomorphizations = upstream_monomorphizations_provider;\n     providers.is_unreachable_local_definition = is_unreachable_local_definition_provider;\n+    providers.upstream_drop_glue_for = upstream_drop_glue_for_provider;\n }\n \n pub fn provide_extern(providers: &mut Providers<'_>) {\n@@ -405,6 +433,11 @@ pub fn symbol_name_for_instance_in_crate<'tcx>(\n             Instance::new(def_id, substs),\n             instantiating_crate,\n         ),\n+        ExportedSymbol::DropGlue(ty) => symbol_names::symbol_name_for_instance_in_crate(\n+            tcx,\n+            Instance::resolve_drop_in_place(tcx, ty),\n+            instantiating_crate,\n+        ),\n         ExportedSymbol::NoDefId(symbol_name) => symbol_name.to_string(),\n     }\n }"}, {"sha": "6713459f627ef726823ee4f247a025392112c560", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=197cc1e43afba388a0266a08d2b946a187b766bb", "patch": "@@ -126,29 +126,10 @@ fn symbol_name_provider(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty::Symb\n         // This closure determines the instantiating crate for instances that\n         // need an instantiating-crate-suffix for their symbol name, in order\n         // to differentiate between local copies.\n-        //\n-        // For generics we might find re-usable upstream instances. For anything\n-        // else we rely on their being a local copy available.\n-\n         if is_generic(instance.substs) {\n-            let def_id = instance.def_id();\n-\n-            if !def_id.is_local() && tcx.sess.opts.share_generics() {\n-                // If we are re-using a monomorphization from another crate,\n-                // we have to compute the symbol hash accordingly.\n-                let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n-\n-                upstream_monomorphizations\n-                    .and_then(|monos| monos.get(&instance.substs).cloned())\n-                    // If there is no instance available upstream, there'll be\n-                    // one in the current crate.\n-                    .unwrap_or(LOCAL_CRATE)\n-            } else {\n-                // For generic functions defined in the current crate, there\n-                // can be no upstream instances. Also, if we don't share\n-                // generics, we'll instantiate a local copy too.\n-                LOCAL_CRATE\n-            }\n+            // For generics we might find re-usable upstream instances. If there\n+            // is one, we rely on the symbol being instantiated locally.\n+            instance.upstream_monomorphization(tcx).unwrap_or(LOCAL_CRATE)\n         } else {\n             // For non-generic things that need to avoid naming conflicts, we\n             // always instantiate a copy in the local crate."}, {"sha": "dd2071a6c596ae7677a78b8c267b5a5c3ac70be7", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197cc1e43afba388a0266a08d2b946a187b766bb/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=197cc1e43afba388a0266a08d2b946a187b766bb", "patch": "@@ -737,9 +737,7 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx\n         return true;\n     }\n \n-    if tcx.is_reachable_non_generic(def_id)\n-        || is_available_upstream_generic(tcx, def_id, instance.substs)\n-    {\n+    if tcx.is_reachable_non_generic(def_id) || instance.upstream_monomorphization(tcx).is_some() {\n         // We can link to the item in question, no instance needed\n         // in this crate.\n         return false;\n@@ -750,34 +748,6 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx\n     }\n \n     return true;\n-\n-    fn is_available_upstream_generic<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n-    ) -> bool {\n-        debug_assert!(!def_id.is_local());\n-\n-        // If we are not in share generics mode, we don't link to upstream\n-        // monomorphizations but always instantiate our own internal versions\n-        // instead.\n-        if !tcx.sess.opts.share_generics() {\n-            return false;\n-        }\n-\n-        // If this instance has non-erasable parameters, it cannot be a shared\n-        // monomorphization. Non-generic instances are already handled above\n-        // by `is_reachable_non_generic()`.\n-        if substs.non_erasable_generics().next().is_none() {\n-            return false;\n-        }\n-\n-        // Take a look at the available monomorphizations listed in the metadata\n-        // of upstream crates.\n-        tcx.upstream_monomorphizations_for(def_id)\n-            .map(|set| set.contains_key(substs))\n-            .unwrap_or(false)\n-    }\n }\n \n /// For a given pair of source and target type that occur in an unsizing coercion,"}]}