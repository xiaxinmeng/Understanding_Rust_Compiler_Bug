{"sha": "c3186914071b71af2c771ec0c0d044a1a8c215c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMTg2OTE0MDcxYjcxYWYyYzc3MWVjMGMwZDA0NGExYThjMjE1YzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-06T17:35:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-06T17:35:40Z"}, "message": "Auto merge of #52626 - brunocodutra:issue-52475, r=oli-obk\n\nFix issue #52475: Make loop detector only consider reachable memory\n\nAs [suggested](https://github.com/rust-lang/rust/pull/51702#discussion_r197585664) by @oli-obk `alloc_id`s should be ignored by traversing all `Allocation`s in interpreter memory at a given moment in time, beginning by `ByRef` locals in the stack.\n\n- [x] Generalize the implementation of `Hash` for `EvalSnapshot` to traverse `Allocation`s\n- [x] Generalize the implementation of `PartialEq` for `EvalSnapshot` to traverse `Allocation`s\n- [x] Commit regression tests\n\nFixes #52626\nFixes https://github.com/rust-lang/rust/issues/52849", "tree": {"sha": "55da58e5a752fd1fd33d4f0e1fb5a6c5837ac4c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55da58e5a752fd1fd33d4f0e1fb5a6c5837ac4c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3186914071b71af2c771ec0c0d044a1a8c215c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3186914071b71af2c771ec0c0d044a1a8c215c2", "html_url": "https://github.com/rust-lang/rust/commit/c3186914071b71af2c771ec0c0d044a1a8c215c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3186914071b71af2c771ec0c0d044a1a8c215c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35a5541fd90c96564d483eee248daabc6b133de3", "url": "https://api.github.com/repos/rust-lang/rust/commits/35a5541fd90c96564d483eee248daabc6b133de3", "html_url": "https://github.com/rust-lang/rust/commit/35a5541fd90c96564d483eee248daabc6b133de3"}, {"sha": "05cdf8dc3d490fbec2519de90b254f47ec7373e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/05cdf8dc3d490fbec2519de90b254f47ec7373e8", "html_url": "https://github.com/rust-lang/rust/commit/05cdf8dc3d490fbec2519de90b254f47ec7373e8"}], "stats": {"total": 799, "additions": 606, "deletions": 193}, "files": [{"sha": "1acc58948f413b71ecf72bf47a71884bb8b3a48e", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -15,7 +15,6 @@ use hir::map::definitions::Definitions;\n use ich::{self, CachingSourceMapView, Fingerprint};\n use middle::cstore::CrateStore;\n use ty::{TyCtxt, fast_reject};\n-use mir::interpret::AllocId;\n use session::Session;\n \n use std::cmp::Ord;\n@@ -60,8 +59,6 @@ pub struct StableHashingContext<'a> {\n     // CachingSourceMapView, so we initialize it lazily.\n     raw_source_map: &'a SourceMap,\n     caching_source_map: Option<CachingSourceMapView<'a>>,\n-\n-    pub(super) alloc_id_recursion_tracker: FxHashSet<AllocId>,\n }\n \n #[derive(PartialEq, Eq, Clone, Copy)]\n@@ -105,7 +102,6 @@ impl<'a> StableHashingContext<'a> {\n             hash_spans: hash_spans_initial,\n             hash_bodies: true,\n             node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n-            alloc_id_recursion_tracker: Default::default(),\n         }\n     }\n "}, {"sha": "68320dfddefbc04934d7a24581d4eb2e4b419f80", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -412,7 +412,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            let alloc_kind = tcx.alloc_map.lock().get(*self).expect(\"no value for AllocId\");\n+            let alloc_kind = tcx.alloc_map.lock().get(*self);\n             alloc_kind.hash_stable(hcx, hasher);\n         });\n     }"}, {"sha": "ccc5bba1ad61170e592665f3857073852191861e", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -133,9 +133,14 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n \n \n+/// Pointer is generic over the type that represents a reference to Allocations,\n+/// thus making it possible for the most convenient representation to be used in\n+/// each context.\n+///\n+/// Defaults to the index based and loosely coupled AllocId.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub struct Pointer {\n-    pub alloc_id: AllocId,\n+pub struct Pointer<Id=AllocId> {\n+    pub alloc_id: Id,\n     pub offset: Size,\n }\n \n@@ -543,16 +548,16 @@ impl Allocation {\n impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct Relocations(SortedMap<Size, AllocId>);\n+pub struct Relocations<Id=AllocId>(SortedMap<Size, Id>);\n \n-impl Relocations {\n-    pub fn new() -> Relocations {\n+impl<Id> Relocations<Id> {\n+    pub fn new() -> Self {\n         Relocations(SortedMap::new())\n     }\n \n     // The caller must guarantee that the given relocations are already sorted\n     // by address and contain no duplicates.\n-    pub fn from_presorted(r: Vec<(Size, AllocId)>) -> Relocations {\n+    pub fn from_presorted(r: Vec<(Size, Id)>) -> Self {\n         Relocations(SortedMap::from_presorted_elements(r))\n     }\n }"}, {"sha": "9982da483ce09968cd18a3b601312946d93125ec", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -326,7 +326,7 @@ impl From<Pointer> for Scalar {\n /// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n /// of a simple value or a pointer into another `Allocation`\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub enum Scalar {\n+pub enum Scalar<Id=AllocId> {\n     /// The raw bytes of a simple value.\n     Bits {\n         /// The first `size` bytes are the value.\n@@ -338,12 +338,12 @@ pub enum Scalar {\n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n     /// relocation and its associated offset together as a `Pointer` here.\n-    Ptr(Pointer),\n+    Ptr(Pointer<Id>),\n }\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub enum ScalarMaybeUndef {\n-    Scalar(Scalar),\n+pub enum ScalarMaybeUndef<Id=AllocId> {\n+    Scalar(Scalar<Id>),\n     Undef,\n }\n "}, {"sha": "c70a0abe8c7e437e5ed2f92aac748d6dca74b1b3", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -281,6 +281,23 @@ impl<T1, T2, T3, CTX> HashStable<CTX> for (T1, T2, T3)\n     }\n }\n \n+impl<T1, T2, T3, T4, CTX> HashStable<CTX> for (T1, T2, T3, T4)\n+     where T1: HashStable<CTX>,\n+           T2: HashStable<CTX>,\n+           T3: HashStable<CTX>,\n+           T4: HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let (ref _0, ref _1, ref _2, ref _3) = *self;\n+        _0.hash_stable(ctx, hasher);\n+        _1.hash_stable(ctx, hasher);\n+        _2.hash_stable(ctx, hasher);\n+        _3.hash_stable(ctx, hasher);\n+    }\n+}\n+\n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for [T] {\n     default fn hash_stable<W: StableHasherResult>(&self,\n                                                   ctx: &mut CTX,"}, {"sha": "92ddd8777f733eb0398566b1c45fe9f1fccd6867", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -196,6 +196,8 @@ impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n     }\n }\n \n+impl_stable_hash_for!(struct CompileTimeEvaluator {});\n+\n #[derive(Clone, Debug)]\n enum ConstEvalError {\n     NeedsRfc(String),"}, {"sha": "f7277f8d27610b3fb5ac780e62caf498210da9d1", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 33, "deletions": 107, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -9,23 +9,23 @@\n // except according to those terms.\n \n use std::fmt::Write;\n-use std::hash::{Hash, Hasher};\n use std::mem;\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n+use rustc::ich::StableHashingContext;\n use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n };\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n-use rustc_data_structures::fx::{FxHashSet, FxHasher};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use rustc::mir::interpret::{\n-    GlobalId, Scalar, FrameInfo,\n+    GlobalId, Scalar, FrameInfo, AllocId,\n     EvalResult, EvalErrorKind,\n     ScalarMaybeUndef,\n     truncate, sign_extend,\n@@ -38,6 +38,8 @@ use super::{\n     Memory, Machine\n };\n \n+use super::snapshot::InfiniteLoopDetector;\n+\n pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n@@ -95,7 +97,7 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     /// The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n-    pub locals: IndexVec<mir::Local, LocalValue>,\n+    pub locals: IndexVec<mir::Local, LocalValue<AllocId>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -108,51 +110,25 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub stmt: usize,\n }\n \n-impl<'mir, 'tcx: 'mir> Eq for Frame<'mir, 'tcx> {}\n-\n-impl<'mir, 'tcx: 'mir> PartialEq for Frame<'mir, 'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        let Frame {\n-            mir: _,\n-            instance,\n-            span: _,\n-            return_to_block,\n-            return_place,\n-            locals,\n-            block,\n-            stmt,\n-        } = self;\n-\n-        // Some of these are constant during evaluation, but are included\n-        // anyways for correctness.\n-        *instance == other.instance\n-            && *return_to_block == other.return_to_block\n-            && *return_place == other.return_place\n-            && *locals == other.locals\n-            && *block == other.block\n-            && *stmt == other.stmt\n-    }\n-}\n+impl<'a, 'mir, 'tcx: 'mir> HashStable<StableHashingContext<'a>> for Frame<'mir, 'tcx> {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>) {\n \n-impl<'mir, 'tcx: 'mir> Hash for Frame<'mir, 'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n         let Frame {\n-            mir: _,\n+            mir,\n             instance,\n-            span: _,\n+            span,\n             return_to_block,\n             return_place,\n             locals,\n             block,\n             stmt,\n         } = self;\n \n-        instance.hash(state);\n-        return_to_block.hash(state);\n-        return_place.hash(state);\n-        locals.hash(state);\n-        block.hash(state);\n-        stmt.hash(state);\n+        (mir, instance, span, return_to_block).hash_stable(hcx, hasher);\n+        (return_place, locals, block, stmt).hash_stable(hcx, hasher);\n     }\n }\n \n@@ -168,15 +144,27 @@ pub enum StackPopCleanup {\n     None { cleanup: bool },\n }\n \n+impl<'a> HashStable<StableHashingContext<'a>> for StackPopCleanup {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>) {\n+        match self {\n+            StackPopCleanup::Goto(ref block) => block.hash_stable(hcx, hasher),\n+            StackPopCleanup::None { cleanup } => cleanup.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n // State of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub enum LocalValue {\n+pub enum LocalValue<Id=AllocId> {\n     Dead,\n     // Mostly for convenience, we re-use the `Operand` type here.\n     // This is an optimization over just always having a pointer here;\n     // we can thus avoid doing an allocation when the local just stores\n     // immediate values *and* never has its address taken.\n-    Live(Operand),\n+    Live(Operand<Id>),\n }\n \n impl<'tcx> LocalValue {\n@@ -195,72 +183,10 @@ impl<'tcx> LocalValue {\n     }\n }\n \n-/// The virtual machine state during const-evaluation at a given point in time.\n-type EvalSnapshot<'a, 'mir, 'tcx, M>\n-    = (M, Vec<Frame<'mir, 'tcx>>, Memory<'a, 'mir, 'tcx, M>);\n-\n-pub(super) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n-    /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n-    ///\n-    /// When a collision occurs in this table, we store the full snapshot in\n-    /// `snapshots`.\n-    hashes: FxHashSet<u64>,\n-\n-    /// The set of all `EvalSnapshot`s observed by this detector.\n-    ///\n-    /// An `EvalSnapshot` will only be fully cloned once it has caused a\n-    /// collision in `hashes`. As a result, the detector must observe at least\n-    /// *two* full cycles of an infinite loop before it triggers.\n-    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx, M>>,\n-}\n-\n-impl<'a, 'mir, 'tcx, M> Default for InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    fn default() -> Self {\n-        InfiniteLoopDetector {\n-            hashes: FxHashSet::default(),\n-            snapshots: FxHashSet::default(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    /// Returns `true` if the loop detector has not yet observed a snapshot.\n-    pub fn is_empty(&self) -> bool {\n-        self.hashes.is_empty()\n-    }\n-\n-    pub fn observe_and_analyze(\n-        &mut self,\n-        machine: &M,\n-        stack: &Vec<Frame<'mir, 'tcx>>,\n-        memory: &Memory<'a, 'mir, 'tcx, M>,\n-    ) -> EvalResult<'tcx, ()> {\n-        let snapshot = (machine, stack, memory);\n-\n-        let mut fx = FxHasher::default();\n-        snapshot.hash(&mut fx);\n-        let hash = fx.finish();\n-\n-        if self.hashes.insert(hash) {\n-            // No collision\n-            return Ok(())\n-        }\n-\n-        if self.snapshots.insert((machine.clone(), stack.clone(), memory.clone())) {\n-            // Spurious collision or first cycle\n-            return Ok(())\n-        }\n-\n-        // Second cycle\n-        Err(EvalErrorKind::InfiniteLoop.into())\n-    }\n-}\n+impl_stable_hash_for!(enum self::LocalValue {\n+    Dead,\n+    Live(x),\n+});\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]"}, {"sha": "61963f6d3d354560828405c7cbdd9f4fa758b49f", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -15,17 +15,19 @@\n use std::hash::Hash;\n \n use rustc::hir::def_id::DefId;\n+use rustc::ich::StableHashingContext;\n use rustc::mir::interpret::{Allocation, EvalResult, Scalar};\n use rustc::mir;\n use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n+use rustc_data_structures::stable_hasher::HashStable;\n \n use super::{EvalContext, PlaceTy, OpTy};\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied\n-pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n+pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash + for<'a> HashStable<StableHashingContext<'a>> {\n     /// Additional data that can be accessed via the Memory\n-    type MemoryData: Clone + Eq + Hash;\n+    type MemoryData: Clone + Eq + Hash + for<'a> HashStable<StableHashingContext<'a>>;\n \n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     type MemoryKinds: ::std::fmt::Debug + Copy + Clone + Eq + Hash;"}, {"sha": "9e61de92936bdb7cf2fdb84670e9b69b3c15d0f7", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -17,7 +17,6 @@\n //! short-circuiting the empty case!\n \n use std::collections::VecDeque;\n-use std::hash::{Hash, Hasher};\n use std::ptr;\n \n use rustc::ty::{self, Instance, query::TyCtxtAt};\n@@ -26,7 +25,7 @@ use rustc::mir::interpret::{Pointer, AllocId, Allocation, ConstValue, ScalarMayb\n                             EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n                             truncate};\n pub use rustc::mir::interpret::{write_target_uint, read_target_uint};\n-use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use syntax::ast::Mutability;\n \n@@ -70,58 +69,6 @@ impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> Eq for Memory<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{}\n-\n-impl<'a, 'mir, 'tcx, M> PartialEq for Memory<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    fn eq(&self, other: &Self) -> bool {\n-        let Memory {\n-            data,\n-            alloc_map,\n-            tcx: _,\n-        } = self;\n-\n-        *data == other.data\n-            && *alloc_map == other.alloc_map\n-    }\n-}\n-\n-impl<'a, 'mir, 'tcx, M> Hash for Memory<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let Memory {\n-            data,\n-            alloc_map: _,\n-            tcx: _,\n-        } = self;\n-\n-        data.hash(state);\n-\n-        // We ignore some fields which don't change between evaluation steps.\n-\n-        // Since HashMaps which contain the same items may have different\n-        // iteration orders, we use a commutative operation (in this case\n-        // addition, but XOR would also work), to combine the hash of each\n-        // `Allocation`.\n-        self.alloc_map.iter()\n-            .map(|(&id, alloc)| {\n-                let mut h = FxHasher::default();\n-                id.hash(&mut h);\n-                alloc.hash(&mut h);\n-                h.finish()\n-            })\n-            .fold(0u64, |hash, x| hash.wrapping_add(x))\n-            .hash(state);\n-    }\n-}\n-\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {"}, {"sha": "1e8de02923240652af9a56a30e1b601b82a9f1c3", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -17,6 +17,7 @@ mod operand;\n mod machine;\n mod memory;\n mod operator;\n+mod snapshot;\n mod step;\n mod terminator;\n mod traits;"}, {"sha": "4093a6304b360d19e2d849a26c5da07db1a0165a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -17,9 +17,10 @@ use std::convert::TryInto;\n use rustc::{mir, ty};\n use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n use rustc_data_structures::indexed_vec::Idx;\n-\n use rustc::mir::interpret::{\n-    GlobalId, ConstValue, Scalar, EvalResult, Pointer, ScalarMaybeUndef, EvalErrorKind\n+    GlobalId, AllocId,\n+    ConstValue, Pointer, Scalar, ScalarMaybeUndef,\n+    EvalResult, EvalErrorKind\n };\n use super::{EvalContext, Machine, MemPlace, MPlaceTy, MemoryKind};\n \n@@ -31,9 +32,9 @@ use super::{EvalContext, Machine, MemPlace, MPlaceTy, MemoryKind};\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Value`, and do not have to work with a `Place`.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Value {\n-    Scalar(ScalarMaybeUndef),\n-    ScalarPair(ScalarMaybeUndef, ScalarMaybeUndef),\n+pub enum Value<Id=AllocId> {\n+    Scalar(ScalarMaybeUndef<Id>),\n+    ScalarPair(ScalarMaybeUndef<Id>, ScalarMaybeUndef<Id>),\n }\n \n impl<'tcx> Value {\n@@ -81,6 +82,11 @@ impl<'tcx> Value {\n     }\n }\n \n+impl_stable_hash_for!(enum ::interpret::Value {\n+    Scalar(x),\n+    ScalarPair(x, y),\n+});\n+\n // ScalarPair needs a type to interpret, so we often have a value and a type together\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n@@ -101,9 +107,9 @@ impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n /// or still in memory.  The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Operand {\n-    Immediate(Value),\n-    Indirect(MemPlace),\n+pub enum Operand<Id=AllocId> {\n+    Immediate(Value<Id>),\n+    Indirect(MemPlace<Id>),\n }\n \n impl Operand {\n@@ -126,6 +132,11 @@ impl Operand {\n     }\n }\n \n+impl_stable_hash_for!(enum ::interpret::Operand {\n+    Immediate(x),\n+    Indirect(x),\n+});\n+\n #[derive(Copy, Clone, Debug)]\n pub struct OpTy<'tcx> {\n     crate op: Operand, // ideally we'd make this private, but const_prop needs this"}, {"sha": "51a4294452719656c0e14d0a56b48c7b56184ea7", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -14,33 +14,41 @@\n \n use std::convert::TryFrom;\n \n+use rustc::ich::StableHashingContext;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout};\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n \n use rustc::mir::interpret::{\n-    GlobalId, Scalar, EvalResult, Pointer, ScalarMaybeUndef, PointerArithmetic\n+    GlobalId, AllocId, Scalar, EvalResult, Pointer, ScalarMaybeUndef, PointerArithmetic\n };\n use super::{EvalContext, Machine, Value, ValTy, Operand, OpTy, MemoryKind};\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub struct MemPlace {\n+pub struct MemPlace<Id=AllocId> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n     /// be turned back into a reference before ever being dereferenced.\n     /// However, it may never be undef.\n-    pub ptr: Scalar,\n+    pub ptr: Scalar<Id>,\n     pub align: Align,\n     /// Metadata for unsized places.  Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g. `extern type`).\n-    pub extra: Option<Scalar>,\n+    pub extra: Option<Scalar<Id>>,\n }\n \n+impl_stable_hash_for!(struct ::interpret::MemPlace {\n+    ptr,\n+    align,\n+    extra,\n+});\n+\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Place {\n+pub enum Place<Id=AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n-    Ptr(MemPlace),\n+    Ptr(MemPlace<Id>),\n \n     /// To support alloc-free locals, we are able to write directly to a local.\n     /// (Without that optimization, we'd just always be a `MemPlace`.)\n@@ -50,6 +58,21 @@ pub enum Place {\n     },\n }\n \n+impl<'a> HashStable<StableHashingContext<'a>> for Place {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self, hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>) {\n+\n+        match self {\n+            Place::Ptr(mem_place) => mem_place.hash_stable(hcx, hasher),\n+\n+            Place::Local { frame, local } => {\n+                frame.hash_stable(hcx, hasher);\n+                local.hash_stable(hcx, hasher);\n+            },\n+        }\n+    }\n+}\n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx> {\n     place: Place,"}, {"sha": "8aa053baae9f017afd022673b04bf5c5fe92d0c2", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "added", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -0,0 +1,411 @@\n+//! This module contains the machinery necessary to detect infinite loops\n+//! during const-evaluation by taking snapshots of the state of the interpreter\n+//! at regular intervals.\n+\n+use std::hash::{Hash, Hasher};\n+\n+use rustc::ich::{StableHashingContext, StableHashingContextProvider};\n+use rustc::mir;\n+use rustc::mir::interpret::{\n+    AllocId, Pointer, Scalar, ScalarMaybeUndef,\n+    Relocations, Allocation, UndefMask,\n+    EvalResult, EvalErrorKind,\n+};\n+\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::layout::Align;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use syntax::ast::Mutability;\n+use syntax::source_map::Span;\n+\n+use super::eval_context::{LocalValue, StackPopCleanup};\n+use super::{Frame, Memory, Machine, Operand, MemPlace, Place, Value};\n+\n+pub(super) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+    /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n+    ///\n+    /// When a collision occurs in this table, we store the full snapshot in\n+    /// `snapshots`.\n+    hashes: FxHashSet<u64>,\n+\n+    /// The set of all `EvalSnapshot`s observed by this detector.\n+    ///\n+    /// An `EvalSnapshot` will only be fully cloned once it has caused a\n+    /// collision in `hashes`. As a result, the detector must observe at least\n+    /// *two* full cycles of an infinite loop before it triggers.\n+    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx, M>>,\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Default for InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn default() -> Self {\n+        InfiniteLoopDetector {\n+            hashes: FxHashSet::default(),\n+            snapshots: FxHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    /// Returns `true` if the loop detector has not yet observed a snapshot.\n+    pub fn is_empty(&self) -> bool {\n+        self.hashes.is_empty()\n+    }\n+\n+    pub fn observe_and_analyze(\n+        &mut self,\n+        tcx: &TyCtxt<'b, 'tcx, 'tcx>,\n+        machine: &M,\n+        memory: &Memory<'a, 'mir, 'tcx, M>,\n+        stack: &[Frame<'mir, 'tcx>],\n+    ) -> EvalResult<'tcx, ()> {\n+\n+        let mut hcx = tcx.get_stable_hashing_context();\n+        let mut hasher = StableHasher::<u64>::new();\n+        (machine, stack).hash_stable(&mut hcx, &mut hasher);\n+        let hash = hasher.finish();\n+\n+        if self.hashes.insert(hash) {\n+            // No collision\n+            return Ok(())\n+        }\n+\n+        info!(\"snapshotting the state of the interpreter\");\n+\n+        if self.snapshots.insert(EvalSnapshot::new(machine, memory, stack)) {\n+            // Spurious collision or first cycle\n+            return Ok(())\n+        }\n+\n+        // Second cycle\n+        Err(EvalErrorKind::InfiniteLoop.into())\n+    }\n+}\n+\n+trait SnapshotContext<'a> {\n+    fn resolve(&'a self, id: &AllocId) -> Option<&'a Allocation>;\n+}\n+\n+/// Taking a snapshot of the evaluation context produces a view of\n+/// the state of the interpreter that is invariant to `AllocId`s.\n+trait Snapshot<'a, Ctx: SnapshotContext<'a>> {\n+    type Item;\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item;\n+}\n+\n+macro_rules! __impl_snapshot_field {\n+    ($field:ident, $ctx:expr) => ($field.snapshot($ctx));\n+    ($field:ident, $ctx:expr, $delegate:expr) => ($delegate);\n+}\n+\n+macro_rules! impl_snapshot_for {\n+    // FIXME(mark-i-m): Some of these should be `?` rather than `*`.\n+    (enum $enum_name:ident {\n+        $( $variant:ident $( ( $($field:ident $(-> $delegate:expr)*),* ) )* ),* $(,)*\n+    }) => {\n+\n+        impl<'a, Ctx> self::Snapshot<'a, Ctx> for $enum_name\n+            where Ctx: self::SnapshotContext<'a>,\n+        {\n+            type Item = $enum_name<AllocIdSnapshot<'a>>;\n+\n+            #[inline]\n+            fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n+                match *self {\n+                    $(\n+                        $enum_name::$variant $( ( $(ref $field),* ) )* =>\n+                            $enum_name::$variant $(\n+                                ( $( __impl_snapshot_field!($field, __ctx $(, $delegate)*) ),* ),\n+                            )*\n+                    )*\n+                }\n+            }\n+        }\n+    };\n+\n+    // FIXME(mark-i-m): same here.\n+    (struct $struct_name:ident { $($field:ident $(-> $delegate:expr)*),*  $(,)* }) => {\n+        impl<'a, Ctx> self::Snapshot<'a, Ctx> for $struct_name\n+            where Ctx: self::SnapshotContext<'a>,\n+        {\n+            type Item = $struct_name<AllocIdSnapshot<'a>>;\n+\n+            #[inline]\n+            fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n+                let $struct_name {\n+                    $(ref $field),*\n+                } = *self;\n+\n+                $struct_name {\n+                    $( $field: __impl_snapshot_field!($field, __ctx $(, $delegate)*) ),*\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+impl<'a, Ctx, T> Snapshot<'a, Ctx> for Option<T>\n+    where Ctx: SnapshotContext<'a>,\n+          T: Snapshot<'a, Ctx>\n+{\n+    type Item = Option<<T as Snapshot<'a, Ctx>>::Item>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        match self {\n+            Some(x) => Some(x.snapshot(ctx)),\n+            None => None,\n+        }\n+    }\n+}\n+\n+#[derive(Eq, PartialEq)]\n+struct AllocIdSnapshot<'a>(Option<AllocationSnapshot<'a>>);\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for AllocId\n+    where Ctx: SnapshotContext<'a>,\n+{\n+    type Item = AllocIdSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        AllocIdSnapshot(ctx.resolve(self).map(|alloc| alloc.snapshot(ctx)))\n+    }\n+}\n+\n+impl_snapshot_for!(struct Pointer {\n+    alloc_id,\n+    offset -> *offset,\n+});\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n+    where Ctx: SnapshotContext<'a>,\n+{\n+    type Item = Scalar<AllocIdSnapshot<'a>>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        match self {\n+            Scalar::Ptr(p) => Scalar::Ptr(p.snapshot(ctx)),\n+            Scalar::Bits{ size, bits } => Scalar::Bits {\n+                size: *size,\n+                bits: *bits,\n+            },\n+        }\n+    }\n+}\n+\n+impl_snapshot_for!(enum ScalarMaybeUndef {\n+    Scalar(s),\n+    Undef,\n+});\n+\n+impl_snapshot_for!(struct MemPlace {\n+    ptr,\n+    extra,\n+    align -> *align,\n+});\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n+    where Ctx: SnapshotContext<'a>,\n+{\n+    type Item = Place<AllocIdSnapshot<'a>>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        match self {\n+            Place::Ptr(p) => Place::Ptr(p.snapshot(ctx)),\n+\n+            Place::Local{ frame, local } => Place::Local{\n+                frame: *frame,\n+                local: *local,\n+            },\n+        }\n+    }\n+}\n+\n+impl_snapshot_for!(enum Value {\n+    Scalar(s),\n+    ScalarPair(s, t),\n+});\n+\n+impl_snapshot_for!(enum Operand {\n+    Immediate(v),\n+    Indirect(m),\n+});\n+\n+impl_snapshot_for!(enum LocalValue {\n+    Live(v),\n+    Dead,\n+});\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for Relocations\n+    where Ctx: SnapshotContext<'a>,\n+{\n+    type Item = Relocations<AllocIdSnapshot<'a>>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        Relocations::from_presorted(self.iter()\n+            .map(|(size, id)| (*size, id.snapshot(ctx)))\n+            .collect())\n+    }\n+}\n+\n+#[derive(Eq, PartialEq)]\n+struct AllocationSnapshot<'a> {\n+    bytes: &'a [u8],\n+    relocations: Relocations<AllocIdSnapshot<'a>>,\n+    undef_mask: &'a UndefMask,\n+    align: &'a Align,\n+    mutability: &'a Mutability,\n+}\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n+    where Ctx: SnapshotContext<'a>,\n+{\n+    type Item = AllocationSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        let Allocation { bytes, relocations, undef_mask, align, mutability } = self;\n+\n+        AllocationSnapshot {\n+            bytes,\n+            undef_mask,\n+            align,\n+            mutability,\n+            relocations: relocations.snapshot(ctx),\n+        }\n+    }\n+}\n+\n+#[derive(Eq, PartialEq)]\n+struct FrameSnapshot<'a, 'tcx: 'a> {\n+    instance: &'a ty::Instance<'tcx>,\n+    span: &'a Span,\n+    return_to_block: &'a StackPopCleanup,\n+    return_place: Place<AllocIdSnapshot<'a>>,\n+    locals: IndexVec<mir::Local, LocalValue<AllocIdSnapshot<'a>>>,\n+    block: &'a mir::BasicBlock,\n+    stmt: usize,\n+}\n+\n+impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n+    where Ctx: SnapshotContext<'a>,\n+{\n+    type Item = FrameSnapshot<'a, 'tcx>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        let Frame {\n+            mir: _,\n+            instance,\n+            span,\n+            return_to_block,\n+            return_place,\n+            locals,\n+            block,\n+            stmt,\n+        } = self;\n+\n+        FrameSnapshot {\n+            instance,\n+            span,\n+            return_to_block,\n+            block,\n+            stmt: *stmt,\n+            return_place: return_place.snapshot(ctx),\n+            locals: locals.iter().map(|local| local.snapshot(ctx)).collect(),\n+        }\n+    }\n+}\n+\n+#[derive(Eq, PartialEq)]\n+struct MemorySnapshot<'a, 'mir: 'a, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx> + 'a> {\n+    data: &'a M::MemoryData,\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Memory<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+{\n+    fn snapshot<'b: 'a>(&'b self) -> MemorySnapshot<'b, 'mir, 'tcx, M> {\n+        let Memory { data, .. } = self;\n+        MemorySnapshot { data }\n+    }\n+}\n+\n+impl<'a, 'b, 'mir, 'tcx, M> SnapshotContext<'b> for Memory<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+{\n+    fn resolve(&'b self, id: &AllocId) -> Option<&'b Allocation> {\n+        self.get(*id).ok()\n+    }\n+}\n+\n+/// The virtual machine state during const-evaluation at a given point in time.\n+struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+    machine: M,\n+    memory: Memory<'a, 'mir, 'tcx, M>,\n+    stack: Vec<Frame<'mir, 'tcx>>,\n+}\n+\n+impl<'a, 'mir, 'tcx, M> EvalSnapshot<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+{\n+    fn new(\n+        machine: &M,\n+        memory: &Memory<'a, 'mir, 'tcx, M>,\n+        stack: &[Frame<'mir, 'tcx>]) -> Self {\n+\n+        EvalSnapshot {\n+            machine: machine.clone(),\n+            memory: memory.clone(),\n+            stack: stack.into(),\n+        }\n+    }\n+\n+    fn snapshot<'b: 'a>(&'b self)\n+        -> (&'b M, MemorySnapshot<'b, 'mir, 'tcx, M>, Vec<FrameSnapshot<'a, 'tcx>>) {\n+        let EvalSnapshot{ machine, memory, stack } = self;\n+        (&machine, memory.snapshot(), stack.iter().map(|frame| frame.snapshot(memory)).collect())\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Hash for EvalSnapshot<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+{\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n+        let mut hcx = self.memory.tcx.get_stable_hashing_context();\n+        let mut hasher = StableHasher::<u64>::new();\n+        self.hash_stable(&mut hcx, &mut hasher);\n+        hasher.finish().hash(state)\n+    }\n+}\n+\n+impl<'a, 'b, 'mir, 'tcx, M> HashStable<StableHashingContext<'b>>\n+    for EvalSnapshot<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+{\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'b>,\n+        hasher: &mut StableHasher<W>) {\n+\n+        let EvalSnapshot{ machine, memory, stack } = self;\n+        (machine, &memory.data, stack).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Eq for EvalSnapshot<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+{}\n+\n+impl<'a, 'mir, 'tcx, M> PartialEq for EvalSnapshot<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        self.snapshot() == other.snapshot()\n+    }\n+}"}, {"sha": "545333e8791760fd29306e59154c4e51b972d271", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -73,7 +73,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 \"Constant evaluating a complex constant, this might take some time\");\n         }\n \n-        self.loop_detector.observe_and_analyze(&self.machine, &self.stack, &self.memory)\n+        self.loop_detector.observe_and_analyze(\n+            &self.tcx,\n+            &self.machine,\n+            &self.memory,\n+            &self.stack[..],\n+        )\n     }\n \n     pub fn run(&mut self) -> EvalResult<'tcx> {"}, {"sha": "1c1e6535e69dcfe61fda296bc129b0758b6f86f4", "filename": "src/test/ui/consts/const-eval/issue-52475.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_let)]\n+\n+fn main() {\n+    let _ = [(); {\n+        //~^ WARNING Constant evaluating a complex constant, this might take some time\n+        //~| ERROR could not evaluate repeat length\n+        let mut x = &0;\n+        let mut n = 0;\n+        while n < 5 { //~ ERROR constant contains unimplemented expression type\n+            n = (n + 1) % 5;\n+            x = &0; // Materialize a new AllocId\n+        }\n+        0\n+    }];\n+}"}, {"sha": "f45587f3f7580140a64083a797d45d2544bec1d9", "filename": "src/test/ui/consts/const-eval/issue-52475.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c3186914071b71af2c771ec0c0d044a1a8c215c2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr?ref=c3186914071b71af2c771ec0c0d044a1a8c215c2", "patch": "@@ -0,0 +1,42 @@\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/issue-52475.rs:19:9\n+   |\n+LL | /         while n < 5 { //~ ERROR constant contains unimplemented expression type\n+LL | |             n = (n + 1) % 5;\n+LL | |             x = &0; // Materialize a new AllocId\n+LL | |         }\n+   | |_________^\n+\n+warning: Constant evaluating a complex constant, this might take some time\n+  --> $DIR/issue-52475.rs:14:18\n+   |\n+LL |       let _ = [(); {\n+   |  __________________^\n+LL | |         //~^ WARNING Constant evaluating a complex constant, this might take some time\n+LL | |         //~| ERROR could not evaluate repeat length\n+LL | |         let mut x = &0;\n+...  |\n+LL | |         0\n+LL | |     }];\n+   | |_____^\n+\n+error[E0080]: could not evaluate repeat length\n+  --> $DIR/issue-52475.rs:14:18\n+   |\n+LL |       let _ = [(); {\n+   |  __________________^\n+LL | |         //~^ WARNING Constant evaluating a complex constant, this might take some time\n+LL | |         //~| ERROR could not evaluate repeat length\n+LL | |         let mut x = &0;\n+...  |\n+LL | |             n = (n + 1) % 5;\n+   | |                 ----------- duplicate interpreter state observed here, const evaluation will never terminate\n+...  |\n+LL | |         0\n+LL | |     }];\n+   | |_____^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0019, E0080.\n+For more information about an error, try `rustc --explain E0019`."}]}