{"sha": "c23f045a8b10c92eef5b1fbefea7696065e5977c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyM2YwNDVhOGIxMGM5MmVlZjViMWZiZWZlYTc2OTYwNjVlNTk3N2M=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-16T18:18:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-16T18:18:24Z"}, "message": "Rollup merge of #73566 - jyn514:name-resolve-first, r=eddyb\n\nDon't run `everybody_loops` for rustdoc; instead ignore resolution errors\n\nr? @eddyb\ncc @petrochenkov, @GuillaumeGomez, @Manishearth, @ecstatic-morse, @marmeladema\n\n~~Blocked on https://github.com/rust-lang/rust/pull/73743~~ Merged.\n~~Blocked on crater run.~~ Crater popped up some ICEs ([now fixed](https://github.com/rust-lang/rust/pull/73566#issuecomment-656934851)). See [crater run](https://crater-reports.s3.amazonaws.com/pr-73566/index.html), [ICEs](https://github.com/rust-lang/rust/pull/73566#issuecomment-653619212).\n~~Blocked on #74070 so that we don't make typeck_tables_of public when it shouldn't be.~~ Merged.\n\nCloses #71820, closes #71104, closes #65863.\n\n## What is the motivation for this change?\n\nAs seen from a lengthy trail of PRs and issues (https://github.com/rust-lang/rust/pull/73532, https://github.com/rust-lang/rust/pull/73103, https://github.com/rust-lang/rust/issues/71820, https://github.com/rust-lang/rust/issues/71104), `everybody_loops` is causing bugs in rustdoc. The main issue is that it does not preserve the validity of the `DefId` tree, meaning that operations on DefIds may unexpectedly fail when called later. This is blocking intra-doc links (see https://github.com/rust-lang/rust/pull/73101).\n\nThis PR starts by removing `everybody_loops`, fixing #71104 and #71820. However, that brings back the bugs seen originally in https://github.com/rust-lang/rust/pull/43348: Since libstd documents items for all platforms, the function bodies sometimes do not type check. Here are the errors from documenting `libstd` with `everybody_loops` disabled and no other changes:\n\n```rust\nerror[E0433]: failed to resolve: could not find `handle` in `sys`\n  --> src/libstd/sys/windows/ext/process.rs:13:27\n   |\n13 |         let handle = sys::handle::Handle::new(handle as *mut _);\n   |                           ^^^^^^ could not find `handle` in `sys`\n\nerror[E0425]: cannot find function `symlink_inner` in module `sys::fs`\n   --> src/libstd/sys/windows/ext/fs.rs:544:14\n    |\n544 |     sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), false)\n    |              ^^^^^^^^^^^^^ not found in `sys::fs`\n\nerror[E0425]: cannot find function `symlink_inner` in module `sys::fs`\n   --> src/libstd/sys/windows/ext/fs.rs:564:14\n    |\n564 |     sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), true)\n    |              ^^^^^^^^^^^^^ not found in `sys::fs`\n```\n\n## Why does this need changes to `rustc_resolve`?\n\nNormally, this could be avoided by simply not calling the `typeck_item_bodies` pass. However, the errors above happen before type checking, in name resolution itself. Since name resolution is intermingled with macro expansion, and rustdoc needs expansion to happen before it knows all items to be documented, there needs to be someway to ignore _resolution_ errors in function bodies.\n\nAn alternative solution suggested by @petrochenkov was to not run `everybody_loops` on anything containing a nested `DefId`. This would solve some of the immediate issues, but isn't bullet-proof: the following functions still could not be documented if the items in the body failed to resolve:\n\n- Functions containing a nested `DefId` (https://github.com/rust-lang/rust/issues/71104)\n- ~~Functions returning `impl Trait` (https://github.com/rust-lang/rust/pull/43878)~~ These ended up not resolving anyway with this PR.\n- ~~`const fn`, because `loop {}` in `const fn` is unstable (https://github.com/rust-lang/rust/issues/43636)~~ `const_loop` was just stabilized.\n\nThis also isn't exactly what rustdoc wants, which is to avoid looking at function bodies in the first place.\n\n## What changes were made?\n\nThe hack implemented in this PR is to add an option to ignore all resolution errors in function bodies. This is enabled only for rustdoc. Since resolution errors are ignored, the MIR generated will be invalid, as can be seen in the following ICE:\n\n```rust\nerror: internal compiler error: broken MIR in DefId(0:11 ~ doc_cfg[8787]::uses_target_feature[0]) (\"return type\"): bad type [type error]\n  --> /home/joshua/src/rust/src/test/rustdoc/doc-cfg.rs:51:1\n   |\n51 | / pub unsafe fn uses_target_feature() {\n52 | |     content::should::be::irrelevant();\n53 | | }\n   | |_^\n```\n\nFortunately, rustdoc does not need to access MIR in order to generate documentation. Therefore this also removes the call to `analyze()` in `rustdoc::run_core`. This has the side effect of not generating all lints by default. Most lints are safe to ignore (does rustdoc really need to run liveness analysis?) but `missing_docs` in particular is disabled when it should not be. Re-running `missing_docs` specifically does not help, because it causes the typechecking pass to be run, bringing back the errors from #24658:\n\n```\nerror[E0599]: no method named `into_handle` found for struct `sys::unix::pipe::AnonPipe` in the current scope\n  --> src/libstd/sys/windows/ext/process.rs:71:27\n   |\n71 |         self.into_inner().into_handle().into_raw() as *mut _\n   |                           ^^^^^^^^^^^ method not found in `sys::unix::pipe::AnonPipe`\n   |\n```\n\nBecause of #73743, we only run typeck on demand. So this only causes an issue for functions returning `impl Trait`, which were already special cased by `ReplaceFunctionWithBody`. However, it now considers `async fn f() -> T` to be considered `impl Future<Output = T>`, where before it was considered to have a concrete `T` type.\n\n## How will this affect future changes to rustdoc?\n\n- Any new changes to rustdoc will not be able to perform type checking without bringing back resolution errors in function bodies.\n    + As a corollary, any new lints cannot require or perform type checking. In some cases this may require refactoring other parts of the compiler to perform type-checking only on-demand, see for example #73743.\n    + As a corollary, rustdoc can never again call `tcx.analysis()` unless this PR is reverted altogether.\n\n## Current status\n\n- ~~I am not yet sure how to bring back `missing_docs` without running typeck. @eddyb suggested allowing lints to opt-out of type-checking, which would probably be another rabbit hole.~~ The opt-out was implemented in https://github.com/rust-lang/rust/pull/73743. However, of the rustc lints, now _only_ missing_docs is run and no other lints: https://github.com/rust-lang/rust/pull/73566#issuecomment-650213058. We need a team decision on whether that's an acceptable tradeoff. Note that all rustdoc lints are still run (`intra_doc_link_resolution_failure`, etc). **UPDATE**: This was deemed acceptable in https://github.com/rust-lang/rust/pull/73566#issuecomment-655750237\n- ~~The implementation of optional errors in `rustc_resolve` is very brute force, it should probably be moved from `LateResolver` to `Resolver` to avoid duplicating the logic in many places.~~ I'm mostly happy with it now.\n\n- This no longer allows errors in `async fn f() -> T`. This caused breakage in 50 crates out of a full crater run, all of which (that I looked at) didn't compile when run with rustc directly. In other words, it used to be that they could not be compiled but could still be documented; now they can't be documented either. This needs a decision from the rustdoc team on whether this is acceptable breakage. **UPDATE**: This was deemed acceptable in https://github.com/rust-lang/rust/pull/73566#issuecomment-655750237\n- ~~This makes `fn typeck_tables_of` in `rustc_typeck` public. This is not desired behavior, but needs the changes from https://github.com/rust-lang/rust/pull/74070 in order to be fixed.~~ Reverted.", "tree": {"sha": "b10918087c472959fa36a535ae67fa0a6db1e2c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b10918087c472959fa36a535ae67fa0a6db1e2c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c23f045a8b10c92eef5b1fbefea7696065e5977c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfEJnwCRBK7hj4Ov3rIwAAdHIIAJDQEt4KD3wgY3LARE/bkgLQ\nSZnURmHAkV7O9u3JFNppnOzd3gShFNt3O0fFiVr0S2E+jkcnJlKcGYuLAzJlDHDU\nxWHDXsNS4BvpfmzCaWNTCyvdDJYZl1ncD9i/PMAjtZQNblxL1JCdQa20lxNrxtxO\noW/Pt37MIKSnnpMb9BJqfmjI45WTE41H1HezPw5cNjh2Z5B+2wSimjKar/CVMMIf\nJUbPogDZSUjpP8pqouIkhHQVq4pdiWRHMZnslrNNQAkLqAIUTZ/EwyimaMlrVpKv\nVhKQoJsHsOQ6J581li/v+FbFjgwqbjrAiejeufbIIwsoqrQLcSZWrOGQFLX0D0Q=\n=am2Z\n-----END PGP SIGNATURE-----\n", "payload": "tree b10918087c472959fa36a535ae67fa0a6db1e2c7\nparent 6ee1b62c811a6eb68d6db6dfb91f66a49956749b\nparent 631b2b9b722a3333aa5931fbbfa9df8846d48380\nauthor Manish Goregaokar <manishsmail@gmail.com> 1594923504 -0700\ncommitter GitHub <noreply@github.com> 1594923504 -0700\n\nRollup merge of #73566 - jyn514:name-resolve-first, r=eddyb\n\nDon't run `everybody_loops` for rustdoc; instead ignore resolution errors\n\nr? @eddyb\ncc @petrochenkov, @GuillaumeGomez, @Manishearth, @ecstatic-morse, @marmeladema\n\n~~Blocked on https://github.com/rust-lang/rust/pull/73743~~ Merged.\n~~Blocked on crater run.~~ Crater popped up some ICEs ([now fixed](https://github.com/rust-lang/rust/pull/73566#issuecomment-656934851)). See [crater run](https://crater-reports.s3.amazonaws.com/pr-73566/index.html), [ICEs](https://github.com/rust-lang/rust/pull/73566#issuecomment-653619212).\n~~Blocked on #74070 so that we don't make typeck_tables_of public when it shouldn't be.~~ Merged.\n\nCloses #71820, closes #71104, closes #65863.\n\n## What is the motivation for this change?\n\nAs seen from a lengthy trail of PRs and issues (https://github.com/rust-lang/rust/pull/73532, https://github.com/rust-lang/rust/pull/73103, https://github.com/rust-lang/rust/issues/71820, https://github.com/rust-lang/rust/issues/71104), `everybody_loops` is causing bugs in rustdoc. The main issue is that it does not preserve the validity of the `DefId` tree, meaning that operations on DefIds may unexpectedly fail when called later. This is blocking intra-doc links (see https://github.com/rust-lang/rust/pull/73101).\n\nThis PR starts by removing `everybody_loops`, fixing #71104 and #71820. However, that brings back the bugs seen originally in https://github.com/rust-lang/rust/pull/43348: Since libstd documents items for all platforms, the function bodies sometimes do not type check. Here are the errors from documenting `libstd` with `everybody_loops` disabled and no other changes:\n\n```rust\nerror[E0433]: failed to resolve: could not find `handle` in `sys`\n  --> src/libstd/sys/windows/ext/process.rs:13:27\n   |\n13 |         let handle = sys::handle::Handle::new(handle as *mut _);\n   |                           ^^^^^^ could not find `handle` in `sys`\n\nerror[E0425]: cannot find function `symlink_inner` in module `sys::fs`\n   --> src/libstd/sys/windows/ext/fs.rs:544:14\n    |\n544 |     sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), false)\n    |              ^^^^^^^^^^^^^ not found in `sys::fs`\n\nerror[E0425]: cannot find function `symlink_inner` in module `sys::fs`\n   --> src/libstd/sys/windows/ext/fs.rs:564:14\n    |\n564 |     sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), true)\n    |              ^^^^^^^^^^^^^ not found in `sys::fs`\n```\n\n## Why does this need changes to `rustc_resolve`?\n\nNormally, this could be avoided by simply not calling the `typeck_item_bodies` pass. However, the errors above happen before type checking, in name resolution itself. Since name resolution is intermingled with macro expansion, and rustdoc needs expansion to happen before it knows all items to be documented, there needs to be someway to ignore _resolution_ errors in function bodies.\n\nAn alternative solution suggested by @petrochenkov was to not run `everybody_loops` on anything containing a nested `DefId`. This would solve some of the immediate issues, but isn't bullet-proof: the following functions still could not be documented if the items in the body failed to resolve:\n\n- Functions containing a nested `DefId` (https://github.com/rust-lang/rust/issues/71104)\n- ~~Functions returning `impl Trait` (https://github.com/rust-lang/rust/pull/43878)~~ These ended up not resolving anyway with this PR.\n- ~~`const fn`, because `loop {}` in `const fn` is unstable (https://github.com/rust-lang/rust/issues/43636)~~ `const_loop` was just stabilized.\n\nThis also isn't exactly what rustdoc wants, which is to avoid looking at function bodies in the first place.\n\n## What changes were made?\n\nThe hack implemented in this PR is to add an option to ignore all resolution errors in function bodies. This is enabled only for rustdoc. Since resolution errors are ignored, the MIR generated will be invalid, as can be seen in the following ICE:\n\n```rust\nerror: internal compiler error: broken MIR in DefId(0:11 ~ doc_cfg[8787]::uses_target_feature[0]) (\"return type\"): bad type [type error]\n  --> /home/joshua/src/rust/src/test/rustdoc/doc-cfg.rs:51:1\n   |\n51 | / pub unsafe fn uses_target_feature() {\n52 | |     content::should::be::irrelevant();\n53 | | }\n   | |_^\n```\n\nFortunately, rustdoc does not need to access MIR in order to generate documentation. Therefore this also removes the call to `analyze()` in `rustdoc::run_core`. This has the side effect of not generating all lints by default. Most lints are safe to ignore (does rustdoc really need to run liveness analysis?) but `missing_docs` in particular is disabled when it should not be. Re-running `missing_docs` specifically does not help, because it causes the typechecking pass to be run, bringing back the errors from #24658:\n\n```\nerror[E0599]: no method named `into_handle` found for struct `sys::unix::pipe::AnonPipe` in the current scope\n  --> src/libstd/sys/windows/ext/process.rs:71:27\n   |\n71 |         self.into_inner().into_handle().into_raw() as *mut _\n   |                           ^^^^^^^^^^^ method not found in `sys::unix::pipe::AnonPipe`\n   |\n```\n\nBecause of #73743, we only run typeck on demand. So this only causes an issue for functions returning `impl Trait`, which were already special cased by `ReplaceFunctionWithBody`. However, it now considers `async fn f() -> T` to be considered `impl Future<Output = T>`, where before it was considered to have a concrete `T` type.\n\n## How will this affect future changes to rustdoc?\n\n- Any new changes to rustdoc will not be able to perform type checking without bringing back resolution errors in function bodies.\n    + As a corollary, any new lints cannot require or perform type checking. In some cases this may require refactoring other parts of the compiler to perform type-checking only on-demand, see for example #73743.\n    + As a corollary, rustdoc can never again call `tcx.analysis()` unless this PR is reverted altogether.\n\n## Current status\n\n- ~~I am not yet sure how to bring back `missing_docs` without running typeck. @eddyb suggested allowing lints to opt-out of type-checking, which would probably be another rabbit hole.~~ The opt-out was implemented in https://github.com/rust-lang/rust/pull/73743. However, of the rustc lints, now _only_ missing_docs is run and no other lints: https://github.com/rust-lang/rust/pull/73566#issuecomment-650213058. We need a team decision on whether that's an acceptable tradeoff. Note that all rustdoc lints are still run (`intra_doc_link_resolution_failure`, etc). **UPDATE**: This was deemed acceptable in https://github.com/rust-lang/rust/pull/73566#issuecomment-655750237\n- ~~The implementation of optional errors in `rustc_resolve` is very brute force, it should probably be moved from `LateResolver` to `Resolver` to avoid duplicating the logic in many places.~~ I'm mostly happy with it now.\n\n- This no longer allows errors in `async fn f() -> T`. This caused breakage in 50 crates out of a full crater run, all of which (that I looked at) didn't compile when run with rustc directly. In other words, it used to be that they could not be compiled but could still be documented; now they can't be documented either. This needs a decision from the rustdoc team on whether this is acceptable breakage. **UPDATE**: This was deemed acceptable in https://github.com/rust-lang/rust/pull/73566#issuecomment-655750237\n- ~~This makes `fn typeck_tables_of` in `rustc_typeck` public. This is not desired behavior, but needs the changes from https://github.com/rust-lang/rust/pull/74070 in order to be fixed.~~ Reverted.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c23f045a8b10c92eef5b1fbefea7696065e5977c", "html_url": "https://github.com/rust-lang/rust/commit/c23f045a8b10c92eef5b1fbefea7696065e5977c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c23f045a8b10c92eef5b1fbefea7696065e5977c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ee1b62c811a6eb68d6db6dfb91f66a49956749b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ee1b62c811a6eb68d6db6dfb91f66a49956749b", "html_url": "https://github.com/rust-lang/rust/commit/6ee1b62c811a6eb68d6db6dfb91f66a49956749b"}, {"sha": "631b2b9b722a3333aa5931fbbfa9df8846d48380", "url": "https://api.github.com/repos/rust-lang/rust/commits/631b2b9b722a3333aa5931fbbfa9df8846d48380", "html_url": "https://github.com/rust-lang/rust/commit/631b2b9b722a3333aa5931fbbfa9df8846d48380"}], "stats": {"total": 542, "additions": 505, "deletions": 37}, "files": [{"sha": "f1b9fafc78158ae98dd6e913861ba883f5e8237c", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -354,13 +354,7 @@ fn configure_and_expand_inner<'a>(\n         )\n     });\n \n-    // If we're actually rustdoc then there's no need to actually compile\n-    // anything, so switch everything to just looping\n-    let mut should_loop = sess.opts.actually_rustdoc;\n     if let Some(PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops)) = sess.opts.pretty {\n-        should_loop |= true;\n-    }\n-    if should_loop {\n         log::debug!(\"replacing bodies with loop {{}}\");\n         util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n     }"}, {"sha": "274f93dd50b0d45361963cdd91b035151990ce60", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 74, "deletions": 25, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -394,13 +394,23 @@ struct LateResolutionVisitor<'a, 'b, 'ast> {\n \n     /// Fields used to add information to diagnostic errors.\n     diagnostic_metadata: DiagnosticMetadata<'ast>,\n+\n+    /// State used to know whether to ignore resolution errors for function bodies.\n+    ///\n+    /// In particular, rustdoc uses this to avoid giving errors for `cfg()` items.\n+    /// In most cases this will be `None`, in which case errors will always be reported.\n+    /// If it is `Some(_)`, then it will be updated when entering a nested function or trait body.\n+    in_func_body: bool,\n }\n \n /// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n     fn visit_item(&mut self, item: &'ast Item) {\n         let prev = replace(&mut self.diagnostic_metadata.current_item, Some(item));\n+        // Always report errors in items we just entered.\n+        let old_ignore = replace(&mut self.in_func_body, false);\n         self.resolve_item(item);\n+        self.in_func_body = old_ignore;\n         self.diagnostic_metadata.current_item = prev;\n     }\n     fn visit_arm(&mut self, arm: &'ast Arm) {\n@@ -497,13 +507,17 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n \n                 visit::walk_fn_ret_ty(this, &declaration.output);\n \n+                // Ignore errors in function bodies if this is rustdoc\n+                // Be sure not to set this until the function signature has been resolved.\n+                let previous_state = replace(&mut this.in_func_body, true);\n                 // Resolve the function body, potentially inside the body of an async closure\n                 match fn_kind {\n                     FnKind::Fn(.., body) => walk_list!(this, visit_block, body),\n                     FnKind::Closure(_, body) => this.visit_expr(body),\n                 };\n \n                 debug!(\"(resolving function) leaving function\");\n+                this.in_func_body = previous_state;\n             })\n         });\n         self.diagnostic_metadata.current_function = previous_value;\n@@ -644,6 +658,8 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             label_ribs: Vec::new(),\n             current_trait_ref: None,\n             diagnostic_metadata: DiagnosticMetadata::default(),\n+            // errors at module scope should always be reported\n+            in_func_body: false,\n         }\n     }\n \n@@ -757,7 +773,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 return if self.is_label_valid_from_rib(i) {\n                     Some(*id)\n                 } else {\n-                    self.r.report_error(\n+                    self.report_error(\n                         original_span,\n                         ResolutionError::UnreachableLabel {\n                             name: label.name,\n@@ -775,7 +791,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             suggestion = suggestion.or_else(|| self.suggestion_for_label_in_rib(i, label));\n         }\n \n-        self.r.report_error(\n+        self.report_error(\n             original_span,\n             ResolutionError::UndeclaredLabel { name: label.name, suggestion },\n         );\n@@ -833,7 +849,11 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n             let report_error = |this: &Self, ns| {\n                 let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n-                this.r.session.span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n+                if this.should_report_errs() {\n+                    this.r\n+                        .session\n+                        .span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n+                }\n             };\n \n             for &ns in nss {\n@@ -1008,7 +1028,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             if seen_bindings.contains_key(&ident) {\n                 let span = seen_bindings.get(&ident).unwrap();\n                 let err = ResolutionError::NameAlreadyUsedInParameterList(ident.name, *span);\n-                self.r.report_error(param.ident.span, err);\n+                self.report_error(param.ident.span, err);\n             }\n             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n@@ -1274,7 +1294,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 .is_err()\n             {\n                 let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n-                self.r.report_error(span, err(ident.name, &path_names_to_string(path)));\n+                self.report_error(span, err(ident.name, &path_names_to_string(path)));\n             }\n         }\n     }\n@@ -1289,6 +1309,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn resolve_local(&mut self, local: &'ast Local) {\n+        debug!(\"resolving local ({:?})\", local);\n         // Resolve the type.\n         walk_list!(self, visit_ty, &local.ty);\n \n@@ -1390,7 +1411,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             if inconsistent_vars.contains_key(name) {\n                 v.could_be_path = false;\n             }\n-            self.r.report_error(\n+            self.report_error(\n                 *v.origin.iter().next().unwrap(),\n                 ResolutionError::VariableNotBoundInPattern(v),\n             );\n@@ -1400,7 +1421,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n         inconsistent_vars.sort();\n         for (name, v) in inconsistent_vars {\n-            self.r.report_error(v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n+            self.report_error(v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n         }\n \n         // 5) Finally bubble up all the binding maps.\n@@ -1550,7 +1571,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // `Variant(a, a)`:\n                 _ => IdentifierBoundMoreThanOnceInSamePattern,\n             };\n-            self.r.report_error(ident.span, error(ident.name));\n+            self.report_error(ident.span, error(ident.name));\n         }\n \n         // Record as bound if it's valid:\n@@ -1624,7 +1645,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // to something unusable as a pattern (e.g., constructor function),\n                 // but we still conservatively report an error, see\n                 // issues/33118#issuecomment-233962221 for one reason why.\n-                self.r.report_error(\n+                self.report_error(\n                     ident.span,\n                     ResolutionError::BindingShadowsSomethingUnacceptable(\n                         pat_src.descr(),\n@@ -1677,18 +1698,27 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         source: PathSource<'ast>,\n         crate_lint: CrateLint,\n     ) -> PartialRes {\n+        log::debug!(\"smart_resolve_path_fragment(id={:?},qself={:?},path={:?}\", id, qself, path);\n         let ns = source.namespace();\n         let is_expected = &|res| source.is_expected(res);\n \n         let report_errors = |this: &mut Self, res: Option<Res>| {\n-            let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n-\n-            let def_id = this.parent_scope.module.normal_ancestor_id;\n-            let instead = res.is_some();\n-            let suggestion =\n-                if res.is_none() { this.report_missing_type_error(path) } else { None };\n-\n-            this.r.use_injections.push(UseError { err, candidates, def_id, instead, suggestion });\n+            if this.should_report_errs() {\n+                let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n+\n+                let def_id = this.parent_scope.module.normal_ancestor_id;\n+                let instead = res.is_some();\n+                let suggestion =\n+                    if res.is_none() { this.report_missing_type_error(path) } else { None };\n+\n+                this.r.use_injections.push(UseError {\n+                    err,\n+                    candidates,\n+                    def_id,\n+                    instead,\n+                    suggestion,\n+                });\n+            }\n \n             PartialRes::new(Res::Err)\n         };\n@@ -1746,13 +1776,17 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             let def_id = this.parent_scope.module.normal_ancestor_id;\n \n-            this.r.use_injections.push(UseError {\n-                err,\n-                candidates,\n-                def_id,\n-                instead: false,\n-                suggestion: None,\n-            });\n+            if this.should_report_errs() {\n+                this.r.use_injections.push(UseError {\n+                    err,\n+                    candidates,\n+                    def_id,\n+                    instead: false,\n+                    suggestion: None,\n+                });\n+            } else {\n+                err.cancel();\n+            }\n \n             // We don't return `Some(parent_err)` here, because the error will\n             // be already printed as part of the `use` injections\n@@ -1809,7 +1843,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             Err(err) => {\n                 if let Some(err) = report_errors_for_call(self, err) {\n-                    self.r.report_error(err.span, err.node);\n+                    self.report_error(err.span, err.node);\n                 }\n \n                 PartialRes::new(Res::Err)\n@@ -1843,6 +1877,21 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n+    /// A wrapper around [`Resolver::report_error`].\n+    ///\n+    /// This doesn't emit errors for function bodies if this is rustdoc.\n+    fn report_error(&self, span: Span, resolution_error: ResolutionError<'_>) {\n+        if self.should_report_errs() {\n+            self.r.report_error(span, resolution_error);\n+        }\n+    }\n+\n+    #[inline]\n+    /// If we're actually rustdoc then avoid giving a name resolution error for `cfg()` items.\n+    fn should_report_errs(&self) -> bool {\n+        !(self.r.session.opts.actually_rustdoc && self.in_func_body)\n+    }\n+\n     // Resolve in alternative namespaces if resolution in the primary namespace fails.\n     fn resolve_qpath_anywhere(\n         &mut self,"}, {"sha": "00315675fafe3e61137cbf69523680f168d6fbd5", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 102, "deletions": 6, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -5,10 +5,15 @@ use rustc_driver::abort_on_err;\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n-use rustc_hir::def::Namespace::TypeNS;\n+use rustc_hir::def::{Namespace::TypeNS, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::HirId;\n+use rustc_hir::{\n+    intravisit::{self, NestedVisitorMap, Visitor},\n+    Path,\n+};\n use rustc_interface::interface;\n+use rustc_middle::hir::map::Map;\n use rustc_middle::middle::cstore::CrateStore;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::{Ty, TyCtxt};\n@@ -372,7 +377,35 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         crate_name,\n         lint_caps,\n         register_lints: None,\n-        override_queries: None,\n+        override_queries: Some(|_sess, providers, _external_providers| {\n+            // Most lints will require typechecking, so just don't run them.\n+            providers.lint_mod = |_, _| {};\n+            // Prevent `rustc_typeck::check_crate` from calling `typeck_tables_of` on all bodies.\n+            providers.typeck_item_bodies = |_, _| {};\n+            // hack so that `used_trait_imports` won't try to call typeck_tables_of\n+            providers.used_trait_imports = |_, _| {\n+                lazy_static! {\n+                    static ref EMPTY_SET: FxHashSet<LocalDefId> = FxHashSet::default();\n+                }\n+                &EMPTY_SET\n+            };\n+            // In case typeck does end up being called, don't ICE in case there were name resolution errors\n+            providers.typeck_tables_of = move |tcx, def_id| {\n+                // Closures' tables come from their outermost function,\n+                // as they are part of the same \"inference environment\".\n+                // This avoids emitting errors for the parent twice (see similar code in `typeck_tables_of_with_fallback`)\n+                let outer_def_id = tcx.closure_base_def_id(def_id.to_def_id()).expect_local();\n+                if outer_def_id != def_id {\n+                    return tcx.typeck_tables_of(outer_def_id);\n+                }\n+\n+                let hir = tcx.hir();\n+                let body = hir.body(hir.body_owned_by(hir.as_local_hir_id(def_id)));\n+                debug!(\"visiting body for {:?}\", def_id);\n+                EmitIgnoredResolutionErrors::new(tcx).visit_body(body);\n+                (rustc_interface::DEFAULT_QUERY_PROVIDERS.typeck_tables_of)(tcx, def_id)\n+            };\n+        }),\n         registry: rustc_driver::diagnostics_registry(),\n     };\n \n@@ -416,10 +449,17 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n \n             global_ctxt.enter(|tcx| {\n-                tcx.analysis(LOCAL_CRATE).ok();\n-\n-                // Abort if there were any errors so far\n-                sess.abort_if_errors();\n+                // Certain queries assume that some checks were run elsewhere\n+                // (see https://github.com/rust-lang/rust/pull/73566#issuecomment-656954425),\n+                // so type-check everything other than function bodies in this crate before running lints.\n+                // NOTE: this does not call `tcx.analysis()` so that we won't\n+                // typeck function bodies or run the default rustc lints.\n+                // (see `override_queries` in the `config`)\n+                let _ = rustc_typeck::check_crate(tcx);\n+                tcx.sess.abort_if_errors();\n+                sess.time(\"missing_docs\", || {\n+                    rustc_lint::check_crate(tcx, rustc_lint::builtin::MissingDoc::new);\n+                });\n \n                 let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n                 // Convert from a HirId set to a DefId set since we don't always have easy access\n@@ -570,6 +610,62 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     })\n }\n \n+/// Due to https://github.com/rust-lang/rust/pull/73566,\n+/// the name resolution pass may find errors that are never emitted.\n+/// If typeck is called after this happens, then we'll get an ICE:\n+/// 'Res::Error found but not reported'. To avoid this, emit the errors now.\n+struct EmitIgnoredResolutionErrors<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> EmitIgnoredResolutionErrors<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        Self { tcx }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for EmitIgnoredResolutionErrors<'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        // We need to recurse into nested closures,\n+        // since those will fallback to the parent for type checking.\n+        NestedVisitorMap::OnlyBodies(self.tcx.hir())\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx Path<'_>, _id: HirId) {\n+        debug!(\"visiting path {:?}\", path);\n+        if path.res == Res::Err {\n+            // We have less context here than in rustc_resolve,\n+            // so we can only emit the name and span.\n+            // However we can give a hint that rustc_resolve will have more info.\n+            let label = format!(\n+                \"could not resolve path `{}`\",\n+                path.segments\n+                    .iter()\n+                    .map(|segment| segment.ident.as_str().to_string())\n+                    .collect::<Vec<_>>()\n+                    .join(\"::\")\n+            );\n+            let mut err = rustc_errors::struct_span_err!(\n+                self.tcx.sess,\n+                path.span,\n+                E0433,\n+                \"failed to resolve: {}\",\n+                label\n+            );\n+            err.span_label(path.span, label);\n+            err.note(\"this error was originally ignored because you are running `rustdoc`\");\n+            err.note(\"try running again with `rustc` or `cargo check` and you may get a more detailed error\");\n+            err.emit();\n+        }\n+        // We could have an outer resolution that succeeded,\n+        // but with generic parameters that failed.\n+        // Recurse into the segments so we catch those too.\n+        intravisit::walk_path(self, path);\n+    }\n+}\n+\n /// `DefId` or parameter index (`ty::ParamTy.index`) of a synthetic type parameter\n /// for `impl Trait` in argument position.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]"}, {"sha": "cbf53d52ef009d13661cbb2a681c6be5357a4955", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -15,6 +15,8 @@\n #![recursion_limit = \"256\"]\n \n extern crate env_logger;\n+#[macro_use]\n+extern crate lazy_static;\n extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;\n@@ -94,6 +96,7 @@ pub fn main() {\n         32_000_000 // 32MB on other platforms\n     };\n     rustc_driver::set_sigpipe_handler();\n+    rustc_driver::install_ice_hook();\n     env_logger::init_from_env(\"RUSTDOC_LOG\");\n     let res = std::thread::Builder::new()\n         .stack_size(thread_stack_size)"}, {"sha": "1176a4a8c4cf830fd7672535e55fc4f1d1d4bf13", "filename": "src/test/rustdoc-ui/error-in-impl-trait/README.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2FREADME.md?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,7 @@\n+Each of these needs to be in a separate file,\n+because the `delay_span_bug` ICE in rustdoc won't be triggerred\n+if even a single other error was emitted.\n+\n+However, conceptually they are all testing basically the same thing.\n+See https://github.com/rust-lang/rust/pull/73566#issuecomment-653689128\n+for more details."}, {"sha": "112a2c494a5c2a090a7b7b8660509ccdbf15de55", "filename": "src/test/rustdoc-ui/error-in-impl-trait/async.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fasync.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,10 @@\n+// edition:2018\n+\n+/// This used to work with ResolveBodyWithLoop.\n+/// However now that we ignore type checking instead of modifying the function body,\n+/// the return type is seen as `impl Future<Output = u32>`, not a `u32`.\n+/// So it no longer allows errors in the function body.\n+pub async fn a() -> u32 {\n+    error::_in::async_fn()\n+    //~^ ERROR failed to resolve\n+}"}, {"sha": "086db1be722742a717b076c2a2f957f0460e4942", "filename": "src/test/rustdoc-ui/error-in-impl-trait/async.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fasync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fasync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fasync.stderr?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,12 @@\n+error[E0433]: failed to resolve: could not resolve path `error::_in::async_fn`\n+  --> $DIR/async.rs:8:5\n+   |\n+LL |     error::_in::async_fn()\n+   |     ^^^^^^^^^^^^^^^^^^^^ could not resolve path `error::_in::async_fn`\n+   |\n+   = note: this error was originally ignored because you are running `rustdoc`\n+   = note: try running again with `rustc` or `cargo check` and you may get a more detailed error\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "df40c121d579efeb0a8a591f2620845ea6f351d6", "filename": "src/test/rustdoc-ui/error-in-impl-trait/closure.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fclosure.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,5 @@\n+// manually desugared version of an `async fn` (but with a closure instead of a generator)\n+pub fn a() -> impl Fn() -> u32 {\n+    || content::doesnt::matter()\n+    //~^ ERROR failed to resolve\n+}"}, {"sha": "4ee9c4d1f438dd2f931ca0691249567d5af19f87", "filename": "src/test/rustdoc-ui/error-in-impl-trait/closure.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fclosure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fclosure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fclosure.stderr?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,12 @@\n+error[E0433]: failed to resolve: could not resolve path `content::doesnt::matter`\n+  --> $DIR/closure.rs:3:8\n+   |\n+LL |     || content::doesnt::matter()\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^ could not resolve path `content::doesnt::matter`\n+   |\n+   = note: this error was originally ignored because you are running `rustdoc`\n+   = note: try running again with `rustc` or `cargo check` and you may get a more detailed error\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "0ccf2e3866fc910a864e5bd010331631a3b5154d", "filename": "src/test/rustdoc-ui/error-in-impl-trait/generic-argument.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fgeneric-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fgeneric-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fgeneric-argument.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,7 @@\n+trait ValidTrait {}\n+\n+/// This has docs\n+pub fn f() -> impl ValidTrait {\n+    Vec::<DoesNotExist>::new()\n+    //~^ ERROR failed to resolve\n+}"}, {"sha": "72716c258dc1ee42d0ba715688d689b94651a9a7", "filename": "src/test/rustdoc-ui/error-in-impl-trait/generic-argument.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fgeneric-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fgeneric-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fgeneric-argument.stderr?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,12 @@\n+error[E0433]: failed to resolve: could not resolve path `DoesNotExist`\n+  --> $DIR/generic-argument.rs:5:11\n+   |\n+LL |     Vec::<DoesNotExist>::new()\n+   |           ^^^^^^^^^^^^ could not resolve path `DoesNotExist`\n+   |\n+   = note: this error was originally ignored because you are running `rustdoc`\n+   = note: try running again with `rustc` or `cargo check` and you may get a more detailed error\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "399fb827517fac2354525ac41fb4c8b60f03cb89", "filename": "src/test/rustdoc-ui/error-in-impl-trait/impl-keyword-closure.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword-closure.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,6 @@\n+pub trait ValidTrait {}\n+/// This returns impl trait\n+pub fn g() -> impl ValidTrait {\n+    (|| error::_in::impl_trait::alias::nested::closure())()\n+    //~^ ERROR failed to resolve\n+}"}, {"sha": "55f9b609a1105183d015e75c9481305703b7fd6c", "filename": "src/test/rustdoc-ui/error-in-impl-trait/impl-keyword-closure.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword-closure.stderr?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,12 @@\n+error[E0433]: failed to resolve: could not resolve path `error::_in::impl_trait::alias::nested::closure`\n+  --> $DIR/impl-keyword-closure.rs:4:9\n+   |\n+LL |     (|| error::_in::impl_trait::alias::nested::closure())()\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not resolve path `error::_in::impl_trait::alias::nested::closure`\n+   |\n+   = note: this error was originally ignored because you are running `rustdoc`\n+   = note: try running again with `rustc` or `cargo check` and you may get a more detailed error\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "24b5734dbd0bf5eca19ef6f8375a238c9a70501f", "filename": "src/test/rustdoc-ui/error-in-impl-trait/impl-keyword.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,6 @@\n+pub trait ValidTrait {}\n+/// This returns impl trait\n+pub fn g() -> impl ValidTrait {\n+    error::_in::impl_trait()\n+    //~^ ERROR failed to resolve\n+}"}, {"sha": "3257079f94219f2c602bdc09f3559cc90f54cdf0", "filename": "src/test/rustdoc-ui/error-in-impl-trait/impl-keyword.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Fimpl-keyword.stderr?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,12 @@\n+error[E0433]: failed to resolve: could not resolve path `error::_in::impl_trait`\n+  --> $DIR/impl-keyword.rs:4:5\n+   |\n+LL |     error::_in::impl_trait()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ could not resolve path `error::_in::impl_trait`\n+   |\n+   = note: this error was originally ignored because you are running `rustdoc`\n+   = note: try running again with `rustc` or `cargo check` and you may get a more detailed error\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "1498fa4f890d0d8b8e4ce9393bee74dccc7baed0", "filename": "src/test/rustdoc-ui/error-in-impl-trait/trait-alias-closure.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias-closure.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,10 @@\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait ValidTrait {}\n+type ImplTrait = impl ValidTrait;\n+\n+/// This returns impl trait, but using a type alias\n+pub fn h() -> ImplTrait {\n+    (|| error::_in::impl_trait::alias::nested::closure())()\n+    //~^ ERROR failed to resolve\n+}"}, {"sha": "84b28139dbcd53cb69c7dbae7d8b48ccd6a9a2b6", "filename": "src/test/rustdoc-ui/error-in-impl-trait/trait-alias-closure.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias-closure.stderr?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,12 @@\n+error[E0433]: failed to resolve: could not resolve path `error::_in::impl_trait::alias::nested::closure`\n+  --> $DIR/trait-alias-closure.rs:8:9\n+   |\n+LL |     (|| error::_in::impl_trait::alias::nested::closure())()\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not resolve path `error::_in::impl_trait::alias::nested::closure`\n+   |\n+   = note: this error was originally ignored because you are running `rustdoc`\n+   = note: try running again with `rustc` or `cargo check` and you may get a more detailed error\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "cf9bc48c7f8727cde28cc6c4fa82a19353300130", "filename": "src/test/rustdoc-ui/error-in-impl-trait/trait-alias.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,10 @@\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait ValidTrait {}\n+type ImplTrait = impl ValidTrait;\n+\n+/// This returns impl trait, but using a type alias\n+pub fn h() -> ImplTrait {\n+    error::_in::impl_trait::alias()\n+    //~^ ERROR failed to resolve\n+}"}, {"sha": "9be6a3d8d6bba7c69cbe6565ca1aa4c2f344d648", "filename": "src/test/rustdoc-ui/error-in-impl-trait/trait-alias.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ferror-in-impl-trait%2Ftrait-alias.stderr?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,12 @@\n+error[E0433]: failed to resolve: could not resolve path `error::_in::impl_trait::alias`\n+  --> $DIR/trait-alias.rs:8:5\n+   |\n+LL |     error::_in::impl_trait::alias()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not resolve path `error::_in::impl_trait::alias`\n+   |\n+   = note: this error was originally ignored because you are running `rustdoc`\n+   = note: try running again with `rustc` or `cargo check` and you may get a more detailed error\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "a927f6bd79976eb85755f242e27e6e4127feb410", "filename": "src/test/rustdoc-ui/impl-fn-nesting.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,49 @@\n+// Ensure that rustdoc gives errors for trait impls inside function bodies that don't resolve.\n+// See https://github.com/rust-lang/rust/pull/73566\n+pub struct ValidType;\n+pub trait ValidTrait {}\n+pub trait NeedsBody {\n+    type Item;\n+    fn f();\n+}\n+\n+/// This function has docs\n+pub fn f<B: UnknownBound>(a: UnknownType, b: B) {\n+//~^ ERROR cannot find trait `UnknownBound` in this scope\n+//~| ERROR cannot find type `UnknownType` in this scope\n+    impl UnknownTrait for ValidType {} //~ ERROR cannot find trait `UnknownTrait`\n+    impl<T: UnknownBound> UnknownTrait for T {}\n+    //~^ ERROR cannot find trait `UnknownBound` in this scope\n+    //~| ERROR cannot find trait `UnknownTrait` in this scope\n+    impl ValidTrait for UnknownType {}\n+    //~^ ERROR cannot find type `UnknownType` in this scope\n+    impl ValidTrait for ValidType where ValidTrait: UnknownBound {}\n+    //~^ ERROR cannot find trait `UnknownBound` in this scope\n+\n+    /// This impl has documentation\n+    impl NeedsBody for ValidType {\n+        type Item = UnknownType;\n+        //~^ ERROR cannot find type `UnknownType` in this scope\n+\n+        /// This function has documentation\n+        fn f() {\n+            <UnknownTypeShouldBeIgnored>::a();\n+            content::shouldnt::matter();\n+            unknown_macro!();\n+            //~^ ERROR cannot find macro `unknown_macro` in this scope\n+\n+            /// This is documentation for a macro\n+            macro_rules! can_define_macros_here_too {\n+                () => {\n+                    this::content::should::also::be::ignored()\n+                }\n+            }\n+            can_define_macros_here_too!();\n+\n+            /// This also is documented.\n+            pub fn doubly_nested(c: UnknownType) {\n+            //~^ ERROR cannot find type `UnknownType` in this scope\n+            }\n+        }\n+    }\n+}"}, {"sha": "608749af895edbd699a2119eacc9fc010991be47", "filename": "src/test/rustdoc-ui/impl-fn-nesting.stderr", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.stderr?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,66 @@\n+error: cannot find macro `unknown_macro` in this scope\n+  --> $DIR/impl-fn-nesting.rs:32:13\n+   |\n+LL |             unknown_macro!();\n+   |             ^^^^^^^^^^^^^\n+\n+error[E0405]: cannot find trait `UnknownBound` in this scope\n+  --> $DIR/impl-fn-nesting.rs:11:13\n+   |\n+LL | pub fn f<B: UnknownBound>(a: UnknownType, b: B) {\n+   |             ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `UnknownType` in this scope\n+  --> $DIR/impl-fn-nesting.rs:11:30\n+   |\n+LL | pub fn f<B: UnknownBound>(a: UnknownType, b: B) {\n+   |                              ^^^^^^^^^^^ not found in this scope\n+\n+error[E0405]: cannot find trait `UnknownTrait` in this scope\n+  --> $DIR/impl-fn-nesting.rs:14:10\n+   |\n+LL |     impl UnknownTrait for ValidType {}\n+   |          ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0405]: cannot find trait `UnknownTrait` in this scope\n+  --> $DIR/impl-fn-nesting.rs:15:27\n+   |\n+LL |     impl<T: UnknownBound> UnknownTrait for T {}\n+   |                           ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0405]: cannot find trait `UnknownBound` in this scope\n+  --> $DIR/impl-fn-nesting.rs:15:13\n+   |\n+LL |     impl<T: UnknownBound> UnknownTrait for T {}\n+   |             ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `UnknownType` in this scope\n+  --> $DIR/impl-fn-nesting.rs:18:25\n+   |\n+LL |     impl ValidTrait for UnknownType {}\n+   |                         ^^^^^^^^^^^ not found in this scope\n+\n+error[E0405]: cannot find trait `UnknownBound` in this scope\n+  --> $DIR/impl-fn-nesting.rs:20:53\n+   |\n+LL |     impl ValidTrait for ValidType where ValidTrait: UnknownBound {}\n+   |                                                     ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `UnknownType` in this scope\n+  --> $DIR/impl-fn-nesting.rs:25:21\n+   |\n+LL |         type Item = UnknownType;\n+   |                     ^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `UnknownType` in this scope\n+  --> $DIR/impl-fn-nesting.rs:44:37\n+   |\n+LL |             pub fn doubly_nested(c: UnknownType) {\n+   |                                     ^^^^^^^^^^^ not found in this scope\n+\n+error: Compilation failed, aborting rustdoc\n+\n+error: aborting due to 11 previous errors\n+\n+Some errors have detailed explanations: E0405, E0412.\n+For more information about an error, try `rustc --explain E0405`."}, {"sha": "32793fc4f76c05c6236611db6ba3cf829ae37611", "filename": "src/test/rustdoc-ui/infinite-recursive-type.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,4 @@\n+enum E {\n+//~^ ERROR recursive type `E` has infinite size\n+    V(E),\n+}"}, {"sha": "897445f200cb701d57d6a70e45454e1aa09179b8", "filename": "src/test/rustdoc-ui/infinite-recursive-type.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type.stderr?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,17 @@\n+error[E0072]: recursive type `E` has infinite size\n+  --> $DIR/infinite-recursive-type.rs:1:1\n+   |\n+LL | enum E {\n+   | ^^^^^^ recursive type has infinite size\n+LL |\n+LL |     V(E),\n+   |       - recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `E` representable\n+   |\n+LL |     V(Box<E>),\n+   |       ^^^^ ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0072`."}, {"sha": "54c3f856ddb3c0ad8a2f901c2e8a3e3ae9a5d0c7", "filename": "src/test/rustdoc/impl-trait-alias.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc%2Fimpl-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc%2Fimpl-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fimpl-trait-alias.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,14 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait MyTrait {}\n+impl MyTrait for i32 {}\n+\n+// @has impl_trait_alias/type.Foo.html 'Foo'\n+/// debug type\n+pub type Foo = impl MyTrait;\n+\n+// @has impl_trait_alias/fn.foo.html 'foo'\n+/// debug function\n+pub fn foo() -> Foo {\n+    1\n+}"}, {"sha": "b4aaacf7b3d40ebf7a373ebd3dfe20507a5a9af1", "filename": "src/test/rustdoc/macro-in-async-block.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc%2Fmacro-in-async-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc%2Fmacro-in-async-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-in-async-block.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,9 @@\n+// Regression issue for rustdoc ICE encountered in PR #72088.\n+// edition:2018\n+#![feature(decl_macro)]\n+\n+fn main() {\n+    async {\n+        macro m() {}\n+    };\n+}"}, {"sha": "b4411d927e271077c64570f21bd1beba0eb83c53", "filename": "src/test/rustdoc/macro-in-closure.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc%2Fmacro-in-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc%2Fmacro-in-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-in-closure.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -6,4 +6,11 @@ fn main() {\n     || {\n         macro m() {}\n     };\n+\n+    let _ = || {\n+        macro n() {}\n+    };\n+\n+    let cond = true;\n+    let _ = || if cond { macro n() {} } else { panic!() };\n }"}, {"sha": "1ccf5ac46119adcf609cb37ab7809e468ac787ba", "filename": "src/test/rustdoc/return-impl-trait.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc%2Freturn-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23f045a8b10c92eef5b1fbefea7696065e5977c/src%2Ftest%2Frustdoc%2Freturn-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Freturn-impl-trait.rs?ref=c23f045a8b10c92eef5b1fbefea7696065e5977c", "patch": "@@ -0,0 +1,15 @@\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait Backend {}\n+\n+impl Backend for () {}\n+\n+pub struct Module<T>(T);\n+\n+pub type BackendImpl = impl Backend;\n+\n+// @has return_impl_trait/fn.make_module.html\n+/// Documentation\n+pub fn make_module() -> Module<BackendImpl> {\n+    Module(())\n+}"}]}