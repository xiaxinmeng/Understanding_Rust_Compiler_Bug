{"sha": "6c551b376659006afb349e15c594fc147a7e0ff6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNTUxYjM3NjY1OTAwNmFmYjM0OWUxNWM1OTRmYzE0N2E3ZTBmZjY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-08T12:38:13Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:54Z"}, "message": "trans: Load and cache cross-crate Mir instances in the shared context.", "tree": {"sha": "515fda4bec8bb3fb28afa138639fd5e4a254b9ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/515fda4bec8bb3fb28afa138639fd5e4a254b9ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c551b376659006afb349e15c594fc147a7e0ff6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c551b376659006afb349e15c594fc147a7e0ff6", "html_url": "https://github.com/rust-lang/rust/commit/6c551b376659006afb349e15c594fc147a7e0ff6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c551b376659006afb349e15c594fc147a7e0ff6/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47cd05c8c139616f67a9487e77b37be5222fadc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/47cd05c8c139616f67a9487e77b37be5222fadc6", "html_url": "https://github.com/rust-lang/rust/commit/47cd05c8c139616f67a9487e77b37be5222fadc6"}], "stats": {"total": 442, "additions": 210, "deletions": 232}, "files": [{"sha": "76085b394c1574ccaaa2a0397b88db6dd2c3de10", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 77, "deletions": 71, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -77,6 +77,7 @@ use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::declare;\n use trans::expr;\n use trans::glue;\n+use trans::inline;\n use trans::intrinsic;\n use trans::machine;\n use trans::machine::{llalign_of_min, llsize_of, llsize_of_real};\n@@ -1392,34 +1393,53 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     pub fn new(ccx: &'blk CrateContext<'blk, 'tcx>,\n                llfndecl: ValueRef,\n                fn_ty: FnType,\n-               id: ast::NodeId,\n+               def_id: Option<DefId>,\n                param_substs: &'tcx Substs<'tcx>,\n-               sp: Option<Span>,\n                block_arena: &'blk TypedArena<common::BlockS<'blk, 'tcx>>)\n                -> FunctionContext<'blk, 'tcx> {\n         common::validate_substs(param_substs);\n \n-        debug!(\"FunctionContext::new(path={}, id={}, param_substs={:?})\",\n-            if id == !0 {\n-                \"\".to_string()\n-            } else {\n+        let inlined_did = def_id.and_then(|def_id| inline::get_local_instance(ccx, def_id));\n+        let inlined_id = inlined_did.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n+        let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n+\n+        debug!(\"FunctionContext::new(path={}, def_id={:?}, param_substs={:?})\",\n+            inlined_id.map_or(String::new(), |id| {\n                 ccx.tcx().map.path_to_string(id).to_string()\n-            },\n-            id,\n+            }),\n+            def_id,\n             param_substs);\n \n-        let debug_context = debuginfo::create_function_debug_context(ccx, id,\n-                                                                     param_substs,\n-                                                                     llfndecl);\n-        let (blk_id, cfg) = build_cfg(ccx.tcx(), id);\n-        let nested_returns = if let Some(ref cfg) = cfg {\n+        let debug_context = debuginfo::create_function_debug_context(ccx,\n+            inlined_id.unwrap_or(ast::DUMMY_NODE_ID), param_substs, llfndecl);\n+\n+        let cfg = inlined_id.map(|id| build_cfg(ccx.tcx(), id));\n+        let nested_returns = if let Some((blk_id, Some(ref cfg))) = cfg {\n             has_nested_returns(ccx.tcx(), cfg, blk_id)\n         } else {\n             false\n         };\n \n+        let check_attrs = |attrs: &[ast::Attribute]| {\n+            attrs.iter().any(|item| item.check_name(\"rustc_mir\"))\n+        };\n+\n+        let use_mir = if let Some(id) = local_id {\n+            check_attrs(ccx.tcx().map.attrs(id))\n+        } else if let Some(def_id) = def_id {\n+            check_attrs(&ccx.sess().cstore.item_attrs(def_id))\n+        } else {\n+            check_attrs(&[])\n+        };\n+\n+        let mir = if use_mir {\n+            def_id.and_then(|id| ccx.get_mir(id))\n+        } else {\n+            None\n+        };\n+\n         FunctionContext {\n-            mir: ccx.mir_map().map.get(&id),\n+            mir: mir,\n             llfn: llfndecl,\n             llretslotptr: Cell::new(None),\n             param_env: ccx.tcx().empty_parameter_environment(),\n@@ -1431,21 +1451,21 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             llupvars: RefCell::new(NodeMap()),\n             lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n             fn_ty: fn_ty,\n-            id: id,\n             param_substs: param_substs,\n-            span: sp,\n+            span: inlined_id.and_then(|id| ccx.tcx().map.opt_span(id)),\n             block_arena: block_arena,\n             lpad_arena: TypedArena::new(),\n             ccx: ccx,\n             debug_context: debug_context,\n             scopes: RefCell::new(Vec::new()),\n-            cfg: cfg,\n+            cfg: cfg.and_then(|(_, cfg)| cfg)\n         }\n     }\n \n     /// Performs setup on a newly created function, creating the entry\n     /// scope block and allocating space for the return pointer.\n-    pub fn init(&'blk self, skip_retptr: bool) -> Block<'blk, 'tcx> {\n+    pub fn init(&'blk self, skip_retptr: bool, fn_did: Option<DefId>)\n+                -> Block<'blk, 'tcx> {\n         let entry_bcx = self.new_temp_block(\"entry-block\");\n \n         // Use a dummy instruction as the insertion point for all allocas.\n@@ -1493,15 +1513,15 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n \n         // Create the drop-flag hints for every unfragmented path in the function.\n         let tcx = self.ccx.tcx();\n-        let fn_did = tcx.map.local_def_id(self.id);\n         let tables = tcx.tables.borrow();\n         let mut hints = self.lldropflag_hints.borrow_mut();\n         let fragment_infos = tcx.fragment_infos.borrow();\n \n         // Intern table for drop-flag hint datums.\n         let mut seen = HashMap::new();\n \n-        if let Some(fragment_infos) = fragment_infos.get(&fn_did) {\n+        let fragment_infos = fn_did.and_then(|did| fragment_infos.get(&did));\n+        if let Some(fragment_infos) = fragment_infos {\n             for &info in fragment_infos {\n \n                 let make_datum = |id| {\n@@ -1558,11 +1578,13 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     fn bind_args(&'blk self,\n                  args: &[hir::Arg],\n                  abi: Abi,\n+                 id: ast::NodeId,\n                  closure_env: closure::ClosureEnv,\n                  arg_scope: cleanup::CustomScopeIndex)\n                  -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"FunctionContext::bind_args\");\n-        let mut bcx = self.init(false);\n+        let fn_did = self.ccx.tcx().map.local_def_id(id);\n+        let mut bcx = self.init(false, Some(fn_did));\n         let arg_scope_id = cleanup::CustomScope(arg_scope);\n \n         let mut idx = 0;\n@@ -1774,19 +1796,24 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n /// Builds an LLVM function out of a source function.\n ///\n /// If the function closes over its environment a closure will be returned.\n-pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                   decl: &hir::FnDecl,\n-                                   body: &hir::Block,\n-                                   llfndecl: ValueRef,\n-                                   param_substs: &'tcx Substs<'tcx>,\n-                                   fn_ast_id: ast::NodeId,\n-                                   attributes: &[ast::Attribute],\n-                                   fn_ty: FnType,\n-                                   abi: Abi,\n-                                   closure_env: closure::ClosureEnv<'b>) {\n+pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               decl: &hir::FnDecl,\n+                               body: &hir::Block,\n+                               llfndecl: ValueRef,\n+                               param_substs: &'tcx Substs<'tcx>,\n+                               def_id: DefId,\n+                               inlined_id: ast::NodeId,\n+                               fn_ty: FnType,\n+                               abi: Abi,\n+                               closure_env: closure::ClosureEnv) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n-    record_translation_item_as_generated(ccx, fn_ast_id, param_substs);\n+    if collector::collecting_debug_information(ccx) {\n+        ccx.record_translation_item_as_generated(TransItem::Fn(Instance {\n+            def: def_id,\n+            params: &param_substs.types\n+        }))\n+    }\n \n     let _icx = push_ctxt(\"trans_closure\");\n     attributes::emit_uwtable(llfndecl, true);\n@@ -1795,23 +1822,20 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, fn_ast_id,\n-                               param_substs, Some(body.span), &arena);\n+    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, Some(def_id), param_substs, &arena);\n \n-    if attributes.iter().any(|item| item.check_name(\"rustc_mir\")) {\n+    if fcx.mir.is_some() {\n         return mir::trans_mir(&fcx);\n     }\n \n     // cleanup scope for the incoming arguments\n-    let fn_cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(ccx,\n-                                                                             fn_ast_id,\n-                                                                             body.span,\n-                                                                             true);\n+    let fn_cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(\n+        ccx, inlined_id, body.span, true);\n     let arg_scope = fcx.push_custom_cleanup_scope_with_debug_loc(fn_cleanup_debug_loc);\n \n     // Set up arguments to the function.\n     debug!(\"trans_closure: function: {:?}\", Value(fcx.llfn));\n-    let bcx = fcx.bind_args(&decl.inputs, abi, closure_env, arg_scope);\n+    let bcx = fcx.bind_args(&decl.inputs, abi, inlined_id, closure_env, arg_scope);\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n@@ -1862,28 +1886,6 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Insert the mandatory first few basic blocks before lltop.\n     fcx.finish(bcx, ret_debug_loc);\n-\n-    fn record_translation_item_as_generated<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                      node_id: ast::NodeId,\n-                                                      param_substs: &'tcx Substs<'tcx>) {\n-        if !collector::collecting_debug_information(ccx) {\n-            return;\n-        }\n-\n-        let def_id = match ccx.tcx().node_id_to_type(node_id).sty {\n-            ty::TyClosure(def_id, _) => def_id,\n-            _ => ccx.external_srcs()\n-                    .borrow()\n-                    .get(&node_id)\n-                    .map(|did| *did)\n-                    .unwrap_or_else(|| ccx.tcx().map.local_def_id(node_id)),\n-        };\n-\n-        ccx.record_translation_item_as_generated(TransItem::Fn(Instance {\n-            def: def_id,\n-            params: &param_substs.types,\n-        }));\n-    }\n }\n \n /// Creates an LLVM function corresponding to a source language function.\n@@ -1892,8 +1894,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           body: &hir::Block,\n                           llfndecl: ValueRef,\n                           param_substs: &'tcx Substs<'tcx>,\n-                          id: ast::NodeId,\n-                          attrs: &[ast::Attribute]) {\n+                          id: ast::NodeId) {\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n     debug!(\"trans_fn(param_substs={:?})\", param_substs);\n     let _icx = push_ctxt(\"trans_fn\");\n@@ -1903,13 +1904,18 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     let abi = fn_ty.fn_abi();\n     let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n+    let def_id = if let Some(&def_id) = ccx.external_srcs().borrow().get(&id) {\n+        def_id\n+    } else {\n+        ccx.tcx().map.local_def_id(id)\n+    };\n     trans_closure(ccx,\n                   decl,\n                   body,\n                   llfndecl,\n                   param_substs,\n+                  def_id,\n                   id,\n-                  attrs,\n                   fn_ty,\n                   abi,\n                   closure::ClosureEnv::NotClosure);\n@@ -2001,9 +2007,10 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, ctor_id,\n-                               param_substs, None, &arena);\n-    let bcx = fcx.init(false);\n+    fcx = FunctionContext::new(ccx, llfndecl, fn_ty,\n+                               Some(ccx.tcx().map.local_def_id(ctor_id)),\n+                               param_substs, &arena);\n+    let bcx = fcx.init(false, None);\n \n     assert!(!fcx.needs_ret_allocas);\n \n@@ -2239,7 +2246,7 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n                     let def_id = tcx.map.local_def_id(item.id);\n                     let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                    trans_fn(ccx, &decl, &body, llfn, empty_substs, item.id, &item.attrs);\n+                    trans_fn(ccx, &decl, &body, llfn, empty_substs, item.id);\n                     set_global_section(ccx, llfn, item);\n                     update_linkage(ccx,\n                                    llfn,\n@@ -2278,8 +2285,7 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                             let empty_substs = tcx.mk_substs(Substs::trans_empty());\n                             let def_id = tcx.map.local_def_id(impl_item.id);\n                             let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                            trans_fn(ccx, &sig.decl, body, llfn, empty_substs,\n-                                     impl_item.id, &impl_item.attrs);\n+                            trans_fn(ccx, &sig.decl, body, llfn, empty_substs, impl_item.id);\n                             update_linkage(ccx, llfn, Some(impl_item.id),\n                                 if is_origin {\n                                     OriginalTranslation"}, {"sha": "bef96cb2b45f6d8a7b230b5a07f4e5cfe2068ae2", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -387,9 +387,8 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, ast::DUMMY_NODE_ID,\n-                               empty_substs, None, &block_arena);\n-    let mut bcx = fcx.init(false);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);\n+    let mut bcx = fcx.init(false, None);\n \n     let llargs = get_params(fcx.llfn);\n "}, {"sha": "24ce44b076f118be4e16c53f9eddfac0ca371d58", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 59, "deletions": 63, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -34,7 +34,6 @@ use middle::ty::{self, Ty, TyCtxt};\n use session::config::FullDebugInfo;\n \n use syntax::ast;\n-use syntax::attr::{ThinAttributes, ThinAttributesExt};\n \n use rustc_front::hir;\n \n@@ -43,7 +42,7 @@ use libc::c_uint;\n fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         closure_def_id: DefId,\n                                         arg_scope_id: ScopeId,\n-                                        freevars: &[ty::Freevar]) {\n+                                        id: ast::NodeId) {\n     let _icx = push_ctxt(\"closure::load_closure_environment\");\n     let kind = kind_for_closure(bcx.ccx(), closure_def_id);\n \n@@ -52,7 +51,7 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Special case for small by-value selfs.\n     let llenv = if kind == ty::ClosureKind::FnOnce && !env_arg.is_indirect() {\n-        let closure_ty = node_id_type(bcx, bcx.fcx.id);\n+        let closure_ty = node_id_type(bcx, id);\n         let llenv = rvalue_scratch_datum(bcx, closure_ty, \"closure_env\").val;\n         env_arg.store_fn_arg(bcx, &mut env_idx, llenv);\n         llenv\n@@ -70,52 +69,52 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         None\n     };\n \n-    for (i, freevar) in freevars.iter().enumerate() {\n-        let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n-                                     closure_expr_id: bcx.fcx.id };\n-        let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n-        let mut upvar_ptr = StructGEP(bcx, llenv, i);\n-        let captured_by_ref = match upvar_capture {\n-            ty::UpvarCapture::ByValue => false,\n-            ty::UpvarCapture::ByRef(..) => {\n-                upvar_ptr = Load(bcx, upvar_ptr);\n-                true\n+    bcx.tcx().with_freevars(id, |fv| {\n+        for (i, freevar) in fv.iter().enumerate() {\n+            let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n+                                        closure_expr_id: id };\n+            let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n+            let mut upvar_ptr = StructGEP(bcx, llenv, i);\n+            let captured_by_ref = match upvar_capture {\n+                ty::UpvarCapture::ByValue => false,\n+                ty::UpvarCapture::ByRef(..) => {\n+                    upvar_ptr = Load(bcx, upvar_ptr);\n+                    true\n+                }\n+            };\n+            let node_id = freevar.def.var_id();\n+            bcx.fcx.llupvars.borrow_mut().insert(node_id, upvar_ptr);\n+\n+            if kind == ty::ClosureKind::FnOnce && !captured_by_ref {\n+                let hint = bcx.fcx.lldropflag_hints.borrow().hint_datum(upvar_id.var_id);\n+                bcx.fcx.schedule_drop_mem(arg_scope_id,\n+                                        upvar_ptr,\n+                                        node_id_type(bcx, node_id),\n+                                        hint)\n             }\n-        };\n-        let node_id = freevar.def.var_id();\n-        bcx.fcx.llupvars.borrow_mut().insert(node_id, upvar_ptr);\n-\n-        if kind == ty::ClosureKind::FnOnce && !captured_by_ref {\n-            let hint = bcx.fcx.lldropflag_hints.borrow().hint_datum(upvar_id.var_id);\n-            bcx.fcx.schedule_drop_mem(arg_scope_id,\n-                                      upvar_ptr,\n-                                      node_id_type(bcx, node_id),\n-                                      hint)\n-        }\n \n-        if let Some(env_pointer_alloca) = env_pointer_alloca {\n-            debuginfo::create_captured_var_metadata(\n-                bcx,\n-                node_id,\n-                env_pointer_alloca,\n-                i,\n-                captured_by_ref,\n-                freevar.span);\n+            if let Some(env_pointer_alloca) = env_pointer_alloca {\n+                debuginfo::create_captured_var_metadata(\n+                    bcx,\n+                    node_id,\n+                    env_pointer_alloca,\n+                    i,\n+                    captured_by_ref,\n+                    freevar.span);\n+            }\n         }\n-    }\n+    })\n }\n \n-pub enum ClosureEnv<'a> {\n+pub enum ClosureEnv {\n     NotClosure,\n-    Closure(DefId, &'a [ty::Freevar]),\n+    Closure(DefId, ast::NodeId),\n }\n \n-impl<'a> ClosureEnv<'a> {\n+impl ClosureEnv {\n     pub fn load<'blk,'tcx>(self, bcx: Block<'blk, 'tcx>, arg_scope: ScopeId) {\n-        if let ClosureEnv::Closure(def_id, freevars) = self {\n-            if !freevars.is_empty() {\n-                load_closure_environment(bcx, def_id, arg_scope, freevars);\n-            }\n+        if let ClosureEnv::Closure(def_id, id) = self {\n+            load_closure_environment(bcx, def_id, arg_scope, id);\n         }\n     }\n }\n@@ -198,8 +197,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                                     body: &hir::Block,\n                                     id: ast::NodeId,\n                                     closure_def_id: DefId, // (*)\n-                                    closure_substs: &'tcx ty::ClosureSubsts<'tcx>,\n-                                    closure_expr_attrs: &ThinAttributes)\n+                                    closure_substs: &ty::ClosureSubsts<'tcx>)\n                                     -> Option<Block<'a, 'tcx>>\n {\n     // (*) Note that in the case of inlined functions, the `closure_def_id` will be the\n@@ -229,9 +227,6 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables, ProjectionMode::Any);\n     let function_type = infcx.closure_type(closure_def_id, closure_substs);\n \n-    let freevars: Vec<ty::Freevar> =\n-        tcx.with_freevars(id, |fv| fv.iter().cloned().collect());\n-\n     let sig = tcx.erase_late_bound_regions(&function_type.sig);\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n \n@@ -250,11 +245,11 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                   body,\n                   llfn,\n                   param_substs,\n+                  closure_def_id,\n                   id,\n-                  closure_expr_attrs.as_attr_slice(),\n                   fn_ty,\n                   Abi::RustCall,\n-                  ClosureEnv::Closure(closure_def_id, &freevars));\n+                  ClosureEnv::Closure(closure_def_id, id));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size closure (in which case dest will be `Ignore`) and\n@@ -270,21 +265,23 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let repr = adt::represent_type(ccx, node_id_type(bcx, id));\n \n     // Create the closure.\n-    for (i, freevar) in freevars.iter().enumerate() {\n-        let datum = expr::trans_var(bcx, freevar.def);\n-        let upvar_slot_dest = adt::trans_field_ptr(\n-            bcx, &repr, adt::MaybeSizedValue::sized(dest_addr), Disr(0), i);\n-        let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n-                                     closure_expr_id: id };\n-        match tcx.upvar_capture(upvar_id).unwrap() {\n-            ty::UpvarCapture::ByValue => {\n-                bcx = datum.store_to(bcx, upvar_slot_dest);\n-            }\n-            ty::UpvarCapture::ByRef(..) => {\n-                Store(bcx, datum.to_llref(), upvar_slot_dest);\n+    tcx.with_freevars(id, |fv| {\n+        for (i, freevar) in fv.iter().enumerate() {\n+            let datum = expr::trans_var(bcx, freevar.def);\n+            let upvar_slot_dest = adt::trans_field_ptr(\n+                bcx, &repr, adt::MaybeSizedValue::sized(dest_addr), Disr(0), i);\n+            let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n+                                        closure_expr_id: id };\n+            match tcx.upvar_capture(upvar_id).unwrap() {\n+                ty::UpvarCapture::ByValue => {\n+                    bcx = datum.store_to(bcx, upvar_slot_dest);\n+                }\n+                ty::UpvarCapture::ByRef(..) => {\n+                    Store(bcx, datum.to_llref(), upvar_slot_dest);\n+                }\n             }\n         }\n-    }\n+    });\n     adt::trans_set_discr(bcx, &repr, dest_addr, Disr(0));\n \n     Some(bcx)\n@@ -394,9 +391,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, ast::DUMMY_NODE_ID,\n-                               substs.func_substs, None, &block_arena);\n-    let mut bcx = fcx.init(false);\n+    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, substs.func_substs, &block_arena);\n+    let mut bcx = fcx.init(false, None);\n \n \n     // the first argument (`self`) will be the (by value) closure env."}, {"sha": "2c996c032ca90eedab2b94092626834e3877b51f", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 7, "deletions": 59, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -217,7 +217,6 @@ use trans::monomorphize::{self, Instance};\n use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n \n use std::hash::{Hash, Hasher};\n-use std::rc::Rc;\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n@@ -263,14 +262,9 @@ pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FnvHashSet();\n         let mut recursion_depths = DefIdMap();\n-        let mut mir_cache = DefIdMap();\n \n         for root in roots {\n-            collect_items_rec(ccx,\n-                              root,\n-                              &mut visited,\n-                              &mut recursion_depths,\n-                              &mut mir_cache);\n+            collect_items_rec(ccx, root, &mut visited, &mut recursion_depths);\n         }\n \n         visited\n@@ -300,27 +294,11 @@ fn collect_roots<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     roots\n }\n \n-#[derive(Clone)]\n-enum CachedMir<'mir, 'tcx: 'mir> {\n-    Ref(&'mir mir::Mir<'tcx>),\n-    Owned(Rc<mir::Mir<'tcx>>)\n-}\n-\n-impl<'mir, 'tcx: 'mir> CachedMir<'mir, 'tcx> {\n-    fn get_ref<'a>(&'a self) -> &'a mir::Mir<'tcx> {\n-        match *self {\n-            CachedMir::Ref(r) => r,\n-            CachedMir::Owned(ref rc) => &rc,\n-        }\n-    }\n-}\n-\n // Collect all monomorphized translation items reachable from `starting_point`\n fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FnvHashSet<TransItem<'tcx>>,\n-                                   recursion_depths: &mut DefIdMap<usize>,\n-                                   mir_cache: &mut DefIdMap<CachedMir<'a, 'tcx>>) {\n+                                   recursion_depths: &mut DefIdMap<usize>) {\n     if !visited.insert(starting_point.clone()) {\n         // We've been here already, no need to search again.\n         return;\n@@ -346,24 +324,25 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n \n             // Scan the MIR in order to find function calls, closures, and\n             // drop-glue\n-            let mir = load_mir(ccx, instance.def, mir_cache);\n+            let mir = errors::expect(ccx.sess().diagnostic(), ccx.get_mir(instance.def),\n+                || format!(\"Could not find MIR for function: {}\", instance));\n \n             let mut visitor = MirNeighborCollector {\n                 ccx: ccx,\n-                mir: mir.get_ref(),\n+                mir: &mir,\n                 output: &mut neighbors,\n                 param_substs: ccx.tcx().mk_substs(Substs {\n                     types: instance.params.clone(),\n                     regions: subst::ErasedRegions\n                 })\n             };\n \n-            visitor.visit_mir(mir.get_ref());\n+            visitor.visit_mir(&mir);\n         }\n     }\n \n     for neighbour in neighbors {\n-        collect_items_rec(ccx, neighbour, visited, recursion_depths, mir_cache);\n+        collect_items_rec(ccx, neighbour, visited, recursion_depths);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n@@ -373,37 +352,6 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(ccx));\n }\n \n-fn load_mir<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n-                          def_id: DefId,\n-                          mir_cache: &mut DefIdMap<CachedMir<'a, 'tcx>>)\n-                          -> CachedMir<'a, 'tcx> {\n-    let mir_not_found_error_message = || {\n-        format!(\"Could not find MIR for function: {}\",\n-                ccx.tcx().item_path_str(def_id))\n-    };\n-\n-    if def_id.is_local() {\n-        let node_id = ccx.tcx().map.as_local_node_id(def_id).unwrap();\n-        let mir_opt = ccx.mir_map().map.get(&node_id);\n-        let mir = errors::expect(ccx.sess().diagnostic(),\n-                             mir_opt,\n-                             mir_not_found_error_message);\n-        CachedMir::Ref(mir)\n-    } else {\n-        if let Some(mir) = mir_cache.get(&def_id) {\n-            return mir.clone();\n-        }\n-\n-        let mir_opt = ccx.sess().cstore.maybe_get_item_mir(ccx.tcx(), def_id);\n-        let mir = errors::expect(ccx.sess().diagnostic(),\n-                                 mir_opt,\n-                                 mir_not_found_error_message);\n-        let cached = CachedMir::Owned(Rc::new(mir));\n-        mir_cache.insert(def_id, cached.clone());\n-        cached\n-    }\n-}\n-\n fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n                                        instance: Instance<'tcx>,\n                                        recursion_depths: &mut DefIdMap<usize>)"}, {"sha": "7872da58ae29a1453ebdd95a8a55c4531cbc273b", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -33,14 +33,14 @@ use trans::datum;\n use trans::debuginfo::{self, DebugLoc};\n use trans::declare;\n use trans::machine;\n+use trans::mir::CachedMir;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::value::Value;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::traits::{self, SelectionContext, ProjectionMode};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use rustc_front::hir;\n-use rustc::mir::repr::Mir;\n use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n@@ -273,7 +273,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // The MIR for this function. At present, this is optional because\n     // we only have MIR available for things that are local to the\n     // crate.\n-    pub mir: Option<&'a Mir<'tcx>>,\n+    pub mir: Option<CachedMir<'a, 'tcx>>,\n \n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n@@ -325,10 +325,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // Describes the return/argument LLVM types and their ABI handling.\n     pub fn_ty: FnType,\n \n-    // The NodeId of the function, or -1 if it doesn't correspond to\n-    // a user-defined function.\n-    pub id: ast::NodeId,\n-\n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n     pub param_substs: &'tcx Substs<'tcx>,\n@@ -356,8 +352,8 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    pub fn mir(&self) -> &'a Mir<'tcx> {\n-        self.mir.unwrap()\n+    pub fn mir(&self) -> CachedMir<'a, 'tcx> {\n+        self.mir.clone().expect(\"fcx.mir was empty\")\n     }\n \n     pub fn cleanup(&self) {\n@@ -584,7 +580,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.lpad.get()\n     }\n \n-    pub fn mir(&self) -> &'blk Mir<'tcx> {\n+    pub fn mir(&self) -> CachedMir<'blk, 'tcx> {\n         self.fcx.mir()\n     }\n \n@@ -709,7 +705,7 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n         self.bcx.llbb\n     }\n \n-    pub fn mir(&self) -> &'blk Mir<'tcx> {\n+    pub fn mir(&self) -> CachedMir<'blk, 'tcx> {\n         self.bcx.mir()\n     }\n "}, {"sha": "349afbba3ec6f9e31a3442e17d124254d183b203", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -1003,8 +1003,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                 body,\n                                                 e.id,\n                                                 def_id,\n-                                                substs,\n-                                                &e.attrs);\n+                                                substs);\n                 }\n                 _ =>\n                     cx.sess().span_bug("}, {"sha": "8f5572f5c4e0ed904f805c623e02017edf352598", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -16,13 +16,15 @@ use middle::def::ExportMap;\n use middle::def_id::DefId;\n use middle::traits;\n use rustc::mir::mir_map::MirMap;\n+use rustc::mir::repr as mir;\n use trans::adt;\n use trans::base;\n use trans::builder::Builder;\n use trans::common::BuilderRef_res;\n use trans::debuginfo;\n use trans::declare;\n use trans::glue::DropGlueKind;\n+use trans::mir::CachedMir;\n use trans::monomorphize::Instance;\n use trans::collector::{TransItem, TransItemState};\n use trans::type_::{Type, TypeNames};\n@@ -75,6 +77,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     check_overflow: bool,\n     check_drop_flag_for_sanity: bool,\n     mir_map: &'a MirMap<'tcx>,\n+    mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n \n     available_drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, String>>,\n     use_dll_storage_attrs: bool,\n@@ -338,6 +341,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n             mir_map: mir_map,\n+            mir_cache: RefCell::new(DefIdMap()),\n             stats: Stats {\n                 n_glues_created: Cell::new(0),\n                 n_null_glues: Cell::new(0),\n@@ -817,8 +821,22 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.use_dll_storage_attrs()\n     }\n \n-    pub fn mir_map(&self) -> &'b MirMap<'tcx> {\n-        self.shared.mir_map\n+    pub fn get_mir(&self, def_id: DefId) -> Option<CachedMir<'b, 'tcx>> {\n+        if def_id.is_local() {\n+            let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n+            self.shared.mir_map.map.get(&node_id).map(CachedMir::Ref)\n+        } else {\n+            if let Some(mir) = self.shared.mir_cache.borrow().get(&def_id).cloned() {\n+                return Some(CachedMir::Owned(mir));\n+            }\n+\n+            let mir = self.sess().cstore.maybe_get_item_mir(self.tcx(), def_id);\n+            let cached = mir.map(Rc::new);\n+            if let Some(ref mir) = cached {\n+                self.shared.mir_cache.borrow_mut().insert(def_id, mir.clone());\n+            }\n+            cached.map(CachedMir::Owned)\n+        }\n     }\n \n     pub fn translation_items(&self) -> &RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>> {"}, {"sha": "094d530d14cbae113a43c9da81f89de72c5a4d95", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -1141,8 +1141,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         body,\n                                         expr.id,\n                                         def_id,\n-                                        substs,\n-                                        &expr.attrs).unwrap_or(bcx)\n+                                        substs).unwrap_or(bcx)\n         }\n         hir::ExprCall(ref f, ref args) => {\n             let method = bcx.tcx().tables.borrow().method_map.get(&method_call).cloned();"}, {"sha": "a2bf4d3f753325a1f1b4f5805ad25558cb1f559a", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -41,7 +41,6 @@ use trans::type_::Type;\n use trans::value::Value;\n \n use arena::TypedArena;\n-use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n \n pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -271,10 +270,9 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, ast::DUMMY_NODE_ID,\n-                               empty_substs, None, &arena);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &arena);\n \n-    let bcx = fcx.init(false);\n+    let bcx = fcx.init(false, None);\n \n     update_linkage(ccx, llfn, None, OriginalTranslation);\n "}, {"sha": "ad32870444a22d0804ee0125739631ce73077fd3", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -152,8 +152,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n                              body,\n                              llfn,\n                              empty_substs,\n-                             impl_item.id,\n-                             &impl_item.attrs);\n+                             impl_item.id);\n                     // See linkage comments on items.\n                     if ccx.sess().opts.cg.codegen_units == 1 {\n                         SetLinkage(llfn, InternalLinkage);"}, {"sha": "7673c98af2a3330570e642fda67616256cf19af7", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -1267,12 +1267,11 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         sig: ty::Binder(sig)\n     });\n     let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n+    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n     let (fcx, block_arena);\n     block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, ast::DUMMY_NODE_ID,\n-                               ccx.tcx().mk_substs(Substs::trans_empty()),\n-                               None, &block_arena);\n-    let bcx = fcx.init(true);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);\n+    let bcx = fcx.init(true, None);\n     trans(bcx);\n     fcx.cleanup();\n     llfn"}, {"sha": "30560ec05c46946851b60f15a64fb230207aac50", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -35,7 +35,7 @@ use trans::type_of::*;\n use trans::value::Value;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n-use syntax::ast::{self, Name};\n+use syntax::ast::Name;\n use syntax::codemap::DUMMY_SP;\n \n // drop_glue pointer, size, align.\n@@ -95,9 +95,8 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, ast::DUMMY_NODE_ID,\n-                               empty_substs, None, &block_arena);\n-    let mut bcx = fcx.init(false);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);\n+    let mut bcx = fcx.init(false, None);\n     assert!(!fcx.needs_ret_allocas);\n \n "}, {"sha": "5cf81b4621a0bef95a76d4de9e9620568082f4be", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -34,7 +34,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         debug!(\"trans_block({:?})\", bb);\n \n         let mut bcx = self.bcx(bb);\n-        let data = self.mir.basic_block_data(bb);\n+        let mir = self.mir.clone();\n+        let data = mir.basic_block_data(bb);\n \n         // MSVC SEH bits\n         let (cleanup_pad, cleanup_bundle) = if let Some((cp, cb)) = self.make_cleanup_pad(bb) {"}, {"sha": "b7364b30f06753e658a7f128ab4633192a32b6b4", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -10,20 +10,41 @@\n \n use libc::c_uint;\n use llvm::{self, ValueRef};\n+use middle::ty;\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use trans::base;\n+use trans::build;\n use trans::common::{self, Block, BlockAndBuilder, FunctionContext};\n use trans::expr;\n \n+use std::ops::Deref;\n+use std::rc::Rc;\n+\n use self::lvalue::LvalueRef;\n use self::operand::OperandRef;\n \n+#[derive(Clone)]\n+pub enum CachedMir<'mir, 'tcx: 'mir> {\n+    Ref(&'mir mir::Mir<'tcx>),\n+    Owned(Rc<mir::Mir<'tcx>>)\n+}\n+\n+impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n+    type Target = mir::Mir<'tcx>;\n+    fn deref(&self) -> &mir::Mir<'tcx> {\n+        match *self {\n+            CachedMir::Ref(r) => r,\n+            CachedMir::Owned(ref rc) => rc\n+        }\n+    }\n+}\n+\n // FIXME DebugLoc is always None right now\n \n /// Master context for translating MIR.\n pub struct MirContext<'bcx, 'tcx:'bcx> {\n-    mir: &'bcx mir::Mir<'tcx>,\n+    mir: CachedMir<'bcx, 'tcx>,\n \n     /// Function context\n     fcx: &'bcx common::FunctionContext<'bcx, 'tcx>,\n@@ -77,15 +98,15 @@ enum TempRef<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n-    let bcx = fcx.init(false).build();\n+    let bcx = fcx.init(false, None).build();\n     let mir = bcx.mir();\n \n     let mir_blocks = mir.all_basic_blocks();\n \n     // Analyze the temps to determine which must be lvalues\n     // FIXME\n     let lvalue_temps = bcx.with_block(|bcx| {\n-      analyze::lvalue_temps(bcx, mir)\n+      analyze::lvalue_temps(bcx, &mir)\n     });\n \n     // Allocate variable and temp allocas\n@@ -107,7 +128,7 @@ pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                                   TempRef::Operand(None)\n                               })\n                               .collect();\n-    let args = arg_value_refs(&bcx, mir);\n+    let args = arg_value_refs(&bcx, &mir);\n \n     // Allocate a `Block` for every basic block\n     let block_bcxs: Vec<Block<'blk,'tcx>> ="}, {"sha": "2e75439ffc3292ed75668a717a4e19e861f23ebe", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c551b376659006afb349e15c594fc147a7e0ff6/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=6c551b376659006afb349e15c594fc147a7e0ff6", "patch": "@@ -151,7 +151,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n \n             if trans_everywhere || is_first {\n-                trans_fn(ccx, decl, body, lldecl, psubsts, fn_node_id, attrs);\n+                trans_fn(ccx, decl, body, lldecl, psubsts, fn_node_id);\n             }\n         }\n "}]}