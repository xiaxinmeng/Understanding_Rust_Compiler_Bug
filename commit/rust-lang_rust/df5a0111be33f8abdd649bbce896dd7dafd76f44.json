{"sha": "df5a0111be33f8abdd649bbce896dd7dafd76f44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNWEwMTExYmUzM2Y4YWJkZDY0OWJiY2U4OTZkZDdkYWZkNzZmNDQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-04-24T19:02:17Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-05-08T10:18:09Z"}, "message": "Optimize HIR map", "tree": {"sha": "304e9ad56cce7802dd03f63c302afb7a01acf478", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/304e9ad56cce7802dd03f63c302afb7a01acf478"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df5a0111be33f8abdd649bbce896dd7dafd76f44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df5a0111be33f8abdd649bbce896dd7dafd76f44", "html_url": "https://github.com/rust-lang/rust/commit/df5a0111be33f8abdd649bbce896dd7dafd76f44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df5a0111be33f8abdd649bbce896dd7dafd76f44/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "url": "https://api.github.com/repos/rust-lang/rust/commits/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "html_url": "https://github.com/rust-lang/rust/commit/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94"}], "stats": {"total": 147, "additions": 87, "deletions": 60}, "files": [{"sha": "24eaeb45ba5ec140e19a72eac2d109172a1d5a27", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/df5a0111be33f8abdd649bbce896dd7dafd76f44/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df5a0111be33f8abdd649bbce896dd7dafd76f44/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=df5a0111be33f8abdd649bbce896dd7dafd76f44", "patch": "@@ -1,9 +1,11 @@\n use super::*;\n use crate::dep_graph::{DepGraph, DepKind, DepNodeIndex};\n use crate::hir;\n+use crate::hir::map::HirMap;\n use crate::hir::def_id::{LOCAL_CRATE, CrateNum};\n use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use crate::ich::Fingerprint;\n use crate::middle::cstore::CrateStore;\n use crate::session::CrateDisambiguator;\n@@ -12,6 +14,7 @@ use crate::util::nodemap::FxHashMap;\n use syntax::ast::NodeId;\n use syntax::source_map::SourceMap;\n use syntax_pos::Span;\n+use std::iter::repeat;\n \n use crate::ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n@@ -25,7 +28,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     source_map: &'a SourceMap,\n \n     /// The node map\n-    map: FxHashMap<HirId, Entry<'hir>>,\n+    map: HirMap<'hir>,\n     /// The parent of this node\n     parent_node: hir::HirId,\n \n@@ -142,11 +145,15 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             );\n         }\n \n+        let (lo, hi) = definitions.def_index_counts_lo_hi();\n+\n         let mut collector = NodeCollector {\n             krate,\n             source_map: sess.source_map(),\n-            map: FxHashMap::with_capacity_and_hasher(sess.current_node_id_count(),\n-                Default::default()),\n+            map: [\n+                repeat(None).take(lo).collect(),\n+                repeat(None).take(hi).collect(),\n+            ],\n             parent_node: hir::CRATE_HIR_ID,\n             current_signature_dep_index: root_mod_sig_dep_index,\n             current_full_dep_index: root_mod_full_dep_index,\n@@ -171,7 +178,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &dyn CrateStore,\n                                                   commandline_args_hash: u64)\n-                                                  -> (FxHashMap<HirId, Entry<'hir>>, Svh)\n+                                                  -> (HirMap<'hir>, Svh)\n     {\n         self.hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n \n@@ -224,7 +231,17 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n     fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n-        self.map.insert(id, entry);\n+        let local_map = &mut self.map[id.owner.address_space().index()][id.owner.as_array_index()];\n+        let i = id.local_id.as_u32() as usize;\n+        if local_map.is_none() {\n+            *local_map = Some(IndexVec::with_capacity(i + 1));\n+        }\n+        let local_map = local_map.as_mut().unwrap();\n+        let len = local_map.len();\n+        if i >= len {\n+            local_map.extend(repeat(None).take(i - len + 1));\n+        }\n+        local_map[id.local_id] = Some(entry);\n     }\n \n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {"}, {"sha": "e6bc4beb450fc80b828d2ec0f6959699db12c927", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 58, "deletions": 47, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/df5a0111be33f8abdd649bbce896dd7dafd76f44/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df5a0111be33f8abdd649bbce896dd7dafd76f44/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=df5a0111be33f8abdd649bbce896dd7dafd76f44", "patch": "@@ -11,6 +11,7 @@ use crate::middle::cstore::CrateStoreDyn;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use syntax::ast::{self, Name, NodeId};\n use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n@@ -161,6 +162,8 @@ impl Forest {\n     }\n }\n \n+pub(super) type HirMap<'hir> = [Vec<Option<IndexVec<ItemLocalId, Option<Entry<'hir>>>>>; 2];\n+\n /// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n #[derive(Clone)]\n pub struct Map<'hir> {\n@@ -174,7 +177,7 @@ pub struct Map<'hir> {\n     /// The SVH of the local crate.\n     pub crate_hash: Svh,\n \n-    map: FxHashMap<HirId, Entry<'hir>>,\n+    map: HirMap<'hir>,\n \n     definitions: &'hir Definitions,\n \n@@ -183,6 +186,12 @@ pub struct Map<'hir> {\n }\n \n impl<'hir> Map<'hir> {\n+    #[inline]\n+    fn lookup(&self, id: HirId) -> Option<&Entry<'hir>> {\n+        let local_map = self.map[id.owner.address_space().index()].get(id.owner.as_array_index())?;\n+        local_map.as_ref()?.get(id.local_id)?.as_ref()\n+    }\n+\n     /// Registers a read in the dependency graph of the AST node with\n     /// the given `id`. This needs to be called each time a public\n     /// function returns the HIR for a node -- in other words, when it\n@@ -191,7 +200,7 @@ impl<'hir> Map<'hir> {\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n     pub fn read(&self, hir_id: HirId) {\n-        if let Some(entry) = self.map.get(&hir_id) {\n+        if let Some(entry) = self.lookup(hir_id) {\n             self.dep_graph.read_index(entry.dep_node);\n         } else {\n             bug!(\"called `HirMap::read()` with invalid `HirId`: {:?}\", hir_id)\n@@ -378,12 +387,8 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    fn entry_count(&self) -> usize {\n-        self.map.len()\n-    }\n-\n     fn find_entry(&self, id: HirId) -> Option<Entry<'hir>> {\n-        self.map.get(&id).cloned()\n+        self.lookup(id).cloned()\n     }\n \n     pub fn krate(&self) -> &'hir Crate {\n@@ -433,7 +438,7 @@ impl<'hir> Map<'hir> {\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> NodeId {\n         let parent = self.get_parent_node_by_hir_id(hir_id);\n-        assert!(self.map.get(&parent).map_or(false, |e| e.is_body_owner(hir_id)));\n+        assert!(self.lookup(parent).map_or(false, |e| e.is_body_owner(hir_id)));\n         self.hir_to_node_id(parent)\n     }\n \n@@ -1004,6 +1009,24 @@ impl<'hir> Map<'hir> {\n         attrs.unwrap_or(&[])\n     }\n \n+    /// Returns an iterator that yields all the hir ids in the map.\n+    fn all_ids<'a>(&'a self) -> impl Iterator<Item = HirId> + 'a {\n+        let map = &self.map;\n+        let spaces = [DefIndexAddressSpace::Low, DefIndexAddressSpace::High].iter().cloned();\n+        spaces.flat_map(move |space| {\n+            map[space.index()].iter().enumerate().filter_map(|(i, local_map)| {\n+                local_map.as_ref().map(|m| (i, m))\n+            }).flat_map(move |(def_index, local_map)| {\n+                local_map.iter_enumerated().filter_map(move |(i, entry)| entry.map(move |_| {\n+                    HirId {\n+                        owner: DefIndex::from_array_index(def_index, space),\n+                        local_id: i,\n+                    }\n+                }))\n+            })\n+        })\n+    }\n+\n     /// Returns an iterator that yields the node id's with paths that\n     /// match `parts`.  (Requires `parts` is non-empty.)\n     ///\n@@ -1012,13 +1035,16 @@ impl<'hir> Map<'hir> {\n     /// such as `foo::bar::quux`, `bar::quux`, `other::bar::quux`, and\n     /// any other such items it can find in the map.\n     pub fn nodes_matching_suffix<'a>(&'a self, parts: &'a [String])\n-                                 -> NodesMatchingSuffix<'a, 'hir> {\n-        NodesMatchingSuffix {\n+                                 -> impl Iterator<Item = NodeId> + 'a {\n+        let nodes = NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n             in_which: &parts[..parts.len() - 1],\n-            idx: ast::CRATE_NODE_ID,\n-        }\n+        };\n+\n+        self.all_ids().filter(move |hir| nodes.matces_suffix(*hir)).map(move |hir| {\n+            self.hir_to_node_id(hir)\n+        })\n     }\n \n     pub fn span(&self, id: NodeId) -> Span {\n@@ -1097,21 +1123,20 @@ impl<'hir> Map<'hir> {\n     }\n }\n \n-pub struct NodesMatchingSuffix<'a, 'hir:'a> {\n-    map: &'a Map<'hir>,\n+pub struct NodesMatchingSuffix<'a> {\n+    map: &'a Map<'a>,\n     item_name: &'a String,\n     in_which: &'a [String],\n-    idx: NodeId,\n }\n \n-impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n+impl<'a> NodesMatchingSuffix<'a> {\n     /// Returns `true` only if some suffix of the module path for parent\n     /// matches `self.in_which`.\n     ///\n     /// In other words: let `[x_0,x_1,...,x_k]` be `self.in_which`;\n     /// returns true if parent's path ends with the suffix\n     /// `x_0::x_1::...::x_k`.\n-    fn suffix_matches(&self, parent: NodeId) -> bool {\n+    fn suffix_matches(&self, parent: HirId) -> bool {\n         let mut cursor = parent;\n         for part in self.in_which.iter().rev() {\n             let (mod_id, mod_name) = match find_first_mod_parent(self.map, cursor) {\n@@ -1121,7 +1146,7 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n             if mod_name != &**part {\n                 return false;\n             }\n-            cursor = self.map.get_parent(mod_id);\n+            cursor = self.map.get_parent_item(mod_id);\n         }\n         return true;\n \n@@ -1131,14 +1156,14 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n         // If `id` itself is a mod named `m` with parent `p`, then\n         // returns `Some(id, m, p)`.  If `id` has no mod in its parent\n         // chain, then returns `None`.\n-        fn find_first_mod_parent<'a>(map: &'a Map<'_>, mut id: NodeId) -> Option<(NodeId, Name)> {\n+        fn find_first_mod_parent<'a>(map: &'a Map<'_>, mut id: HirId) -> Option<(HirId, Name)> {\n             loop {\n-                if let Node::Item(item) = map.find(id)? {\n+                if let Node::Item(item) = map.find_by_hir_id(id)? {\n                     if item_is_mod(&item) {\n                         return Some((id, item.ident.name))\n                     }\n                 }\n-                let parent = map.get_parent(id);\n+                let parent = map.get_parent_item(id);\n                 if parent == id { return None }\n                 id = parent;\n             }\n@@ -1154,35 +1179,21 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n \n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n-    fn matches_names(&self, parent_of_n: NodeId, name: Name) -> bool {\n+    fn matches_names(&self, parent_of_n: HirId, name: Name) -> bool {\n         name == &**self.item_name && self.suffix_matches(parent_of_n)\n     }\n-}\n \n-impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n-    type Item = NodeId;\n-\n-    fn next(&mut self) -> Option<NodeId> {\n-        loop {\n-            let idx = self.idx;\n-            if idx.as_usize() >= self.map.entry_count() {\n-                return None;\n-            }\n-            self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n-            let hir_idx = self.map.node_to_hir_id(idx);\n-            let name = match self.map.find_entry(hir_idx).map(|entry| entry.node) {\n-                Some(Node::Item(n)) => n.name(),\n-                Some(Node::ForeignItem(n)) => n.name(),\n-                Some(Node::TraitItem(n)) => n.name(),\n-                Some(Node::ImplItem(n)) => n.name(),\n-                Some(Node::Variant(n)) => n.name(),\n-                Some(Node::Field(n)) => n.name(),\n-                _ => continue,\n-            };\n-            if self.matches_names(self.map.get_parent(idx), name) {\n-                return Some(idx)\n-            }\n-        }\n+    fn matces_suffix(&self, hir: HirId) -> bool {\n+        let name = match self.map.find_entry(hir).map(|entry| entry.node) {\n+            Some(Node::Item(n)) => n.name(),\n+            Some(Node::ForeignItem(n)) => n.name(),\n+            Some(Node::TraitItem(n)) => n.name(),\n+            Some(Node::ImplItem(n)) => n.name(),\n+            Some(Node::Variant(n)) => n.name(),\n+            Some(Node::Field(n)) => n.name(),\n+            _ => return false,\n+        };\n+        self.matches_names(self.map.get_parent_item(hir), name)\n     }\n }\n "}, {"sha": "e8c7965ab4f45835c196bdff7909b22b7d3ee480", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df5a0111be33f8abdd649bbce896dd7dafd76f44/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df5a0111be33f8abdd649bbce896dd7dafd76f44/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=df5a0111be33f8abdd649bbce896dd7dafd76f44", "patch": "@@ -408,9 +408,6 @@ impl Session {\n     pub fn next_node_id(&self) -> NodeId {\n         self.reserve_node_ids(1)\n     }\n-    pub(crate) fn current_node_id_count(&self) -> usize {\n-        self.next_node_id.get().as_u32() as usize\n-    }\n     pub fn diagnostic<'a>(&'a self) -> &'a errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }"}, {"sha": "a339ec30a74f8b262a1ca9b402bfa060967937ad", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df5a0111be33f8abdd649bbce896dd7dafd76f44/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df5a0111be33f8abdd649bbce896dd7dafd76f44/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=df5a0111be33f8abdd649bbce896dd7dafd76f44", "patch": "@@ -543,12 +543,12 @@ impl FromStr for UserIdentifiedItem {\n     }\n }\n \n-enum NodesMatchingUII<'a, 'hir: 'a> {\n+enum NodesMatchingUII<'a> {\n     NodesMatchingDirect(option::IntoIter<ast::NodeId>),\n-    NodesMatchingSuffix(hir_map::NodesMatchingSuffix<'a, 'hir>),\n+    NodesMatchingSuffix(Box<dyn Iterator<Item = ast::NodeId> + 'a>),\n }\n \n-impl<'a, 'hir> Iterator for NodesMatchingUII<'a, 'hir> {\n+impl<'a> Iterator for NodesMatchingUII<'a> {\n     type Item = ast::NodeId;\n \n     fn next(&mut self) -> Option<ast::NodeId> {\n@@ -576,10 +576,12 @@ impl UserIdentifiedItem {\n \n     fn all_matching_node_ids<'a, 'hir>(&'a self,\n                                        map: &'a hir_map::Map<'hir>)\n-                                       -> NodesMatchingUII<'a, 'hir> {\n+                                       -> NodesMatchingUII<'a> {\n         match *self {\n             ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n-            ItemViaPath(ref parts) => NodesMatchingSuffix(map.nodes_matching_suffix(&parts)),\n+            ItemViaPath(ref parts) => {\n+                NodesMatchingSuffix(Box::new(map.nodes_matching_suffix(&parts)))\n+            }\n         }\n     }\n "}]}