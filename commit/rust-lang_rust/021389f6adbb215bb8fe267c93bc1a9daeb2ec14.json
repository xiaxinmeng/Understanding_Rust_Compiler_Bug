{"sha": "021389f6adbb215bb8fe267c93bc1a9daeb2ec14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMTM4OWY2YWRiYjIxNWJiOGZlMjY3YzkzYmMxYTlkYWViMmVjMTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-13T00:26:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-13T00:26:29Z"}, "message": "Auto merge of #27652 - alex-ozdemir:iter, r=bluss\n\nProvides a custom implementation of Iterator methods `count`, `nth`, and `last` for the structures `slice::{Windows,Chunks,ChunksMut}` in the core module.\r\n\r\nThese implementations run in constant time as opposed to the default implementations which run in linear time.\r\n\r\nAddresses Issue #24214 \r\n\r\nr? @aturon", "tree": {"sha": "0695e164b30fdb2c7017d55f5858f948593c23b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0695e164b30fdb2c7017d55f5858f948593c23b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/021389f6adbb215bb8fe267c93bc1a9daeb2ec14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/021389f6adbb215bb8fe267c93bc1a9daeb2ec14", "html_url": "https://github.com/rust-lang/rust/commit/021389f6adbb215bb8fe267c93bc1a9daeb2ec14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/021389f6adbb215bb8fe267c93bc1a9daeb2ec14/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82169afba773828ddb8a7e3770ba62d90c711079", "url": "https://api.github.com/repos/rust-lang/rust/commits/82169afba773828ddb8a7e3770ba62d90c711079", "html_url": "https://github.com/rust-lang/rust/commit/82169afba773828ddb8a7e3770ba62d90c711079"}, {"sha": "e09f83ea4491ae7c1e48d667b9c552641de0ce5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e09f83ea4491ae7c1e48d667b9c552641de0ce5b", "html_url": "https://github.com/rust-lang/rust/commit/e09f83ea4491ae7c1e48d667b9c552641de0ce5b"}], "stats": {"total": 215, "additions": 215, "deletions": 0}, "files": [{"sha": "f6220a74b2441bc1c395aeedc21227769fe9aa1d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/021389f6adbb215bb8fe267c93bc1a9daeb2ec14/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021389f6adbb215bb8fe267c93bc1a9daeb2ec14/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=021389f6adbb215bb8fe267c93bc1a9daeb2ec14", "patch": "@@ -50,6 +50,7 @@ use ptr;\n use mem;\n use mem::size_of;\n use marker::{Send, Sync, self};\n+use num::wrapping::OverflowingOps;\n use raw::Repr;\n // Avoid conflicts with *both* the Slice trait (buggy) and the `slice::raw` module.\n use raw::Slice as RawSlice;\n@@ -1180,6 +1181,34 @@ impl<'a, T> Iterator for Windows<'a, T> {\n             (size, Some(size))\n         }\n     }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.size_hint().0\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (end, overflow) = self.size.overflowing_add(n);\n+        if end > self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let nth = &self.v[n..end];\n+            self.v = &self.v[n+1..];\n+            Some(nth)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.size > self.v.len() {\n+            None\n+        } else {\n+            let start = self.v.len() - self.size;\n+            Some(&self.v[start..])\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1266,6 +1295,38 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n             (n, Some(n))\n         }\n     }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.size_hint().0\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (start, overflow) = n.overflowing_mul(self.size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let end = match start.checked_add(self.size) {\n+                Some(sum) => cmp::min(self.v.len(), sum),\n+                None => self.v.len(),\n+            };\n+            let nth = &self.v[start..end];\n+            self.v = &self.v[end..];\n+            Some(nth)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let start = (self.v.len() - 1) / self.size * self.size;\n+            Some(&self.v[start..])\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1346,6 +1407,40 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n             (n, Some(n))\n         }\n     }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.size_hint().0\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let end = match start.checked_add(self.chunk_size) {\n+                Some(sum) => cmp::min(self.v.len(), sum),\n+                None => self.v.len(),\n+            };\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(end);\n+            let (_, nth) =  head.split_at_mut(start);\n+            self.v = tail;\n+            Some(nth)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n+            Some(&mut self.v[start..])\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "d60eeb76ccd4ad10ccc8b9b6b3a69675772fb8ee", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/021389f6adbb215bb8fe267c93bc1a9daeb2ec14/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021389f6adbb215bb8fe267c93bc1a9daeb2ec14/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=021389f6adbb215bb8fe267c93bc1a9daeb2ec14", "patch": "@@ -64,3 +64,123 @@ fn test_iterator_count() {\n     iter2.next();\n     assert_eq!(iter2.count(), 3);\n }\n+\n+#[test]\n+fn test_chunks_count() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.chunks(3);\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.chunks(2);\n+    assert_eq!(c2.count(), 3);\n+\n+    let v3: &[i32] = &[];\n+    let c3 = v3.chunks(2);\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_chunks_nth() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.chunks(2);\n+    assert_eq!(c.nth(1).unwrap()[1], 3);\n+    assert_eq!(c.next().unwrap()[0], 4);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c2 = v2.chunks(3);\n+    assert_eq!(c2.nth(1).unwrap()[1], 4);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_chunks_last() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.chunks(2);\n+    assert_eq!(c.last().unwrap()[1], 5);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.chunks(2);\n+    assert_eq!(c2.last().unwrap()[0], 4);\n+}\n+\n+#[test]\n+fn test_chunks_mut_count() {\n+    let mut v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.chunks_mut(3);\n+    assert_eq!(c.count(), 2);\n+\n+    let mut v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.chunks_mut(2);\n+    assert_eq!(c2.count(), 3);\n+\n+    let mut v3: &mut [i32] = &mut [];\n+    let c3 = v3.chunks_mut(2);\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_chunks_mut_nth() {\n+    let mut v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.chunks_mut(2);\n+    assert_eq!(c.nth(1).unwrap()[1], 3);\n+    assert_eq!(c.next().unwrap()[0], 4);\n+\n+    let mut v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c2 = v2.chunks_mut(3);\n+    assert_eq!(c2.nth(1).unwrap()[1], 4);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_chunks_mut_last() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.chunks_mut(2);\n+    assert_eq!(c.last().unwrap()[1], 5);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.chunks_mut(2);\n+    assert_eq!(c2.last().unwrap()[0], 4);\n+}\n+\n+\n+\n+\n+#[test]\n+fn test_windows_count() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.windows(3);\n+    assert_eq!(c.count(), 4);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.windows(6);\n+    assert_eq!(c2.count(), 0);\n+\n+    let v3: &[i32] = &[];\n+    let c3 = v3.windows(2);\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_windows_nth() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.windows(2);\n+    assert_eq!(c.nth(2).unwrap()[1], 3);\n+    assert_eq!(c.next().unwrap()[0], 3);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c2 = v2.windows(4);\n+    assert_eq!(c2.nth(1).unwrap()[1], 2);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_windows_last() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.windows(2);\n+    assert_eq!(c.last().unwrap()[1], 5);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.windows(2);\n+    assert_eq!(c2.last().unwrap()[0], 3);\n+}"}]}