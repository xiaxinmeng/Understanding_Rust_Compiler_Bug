{"sha": "bf161fa3e58d57d9b15bd965405036d834f18595", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMTYxZmEzZTU4ZDU3ZDliMTViZDk2NTQwNTAzNmQ4MzRmMTg1OTU=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-17T19:59:51Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-25T22:04:43Z"}, "message": "Better handle never type and branch merging\nSplit out tests for never type to another file", "tree": {"sha": "62f7103143462ed75544985b7c3ad0cb2ddda96b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62f7103143462ed75544985b7c3ad0cb2ddda96b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf161fa3e58d57d9b15bd965405036d834f18595", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl2L5HsACgkQztOS3gxI\nPQBzcA/+PGNsiDU9Wn0aM2FWsUYpNHp3pm5PpU5HxR9m6hgqNSH8S+NR1axC7Zcb\n84/gLe7KlPjBN4dzJhdsLlLvsDHqnMXyyRrCZybw20hvSq4GeD9thxhz5gqrZhUK\n1Iv492j0iQ5VsceBrnUvOG6Whi/63qIa2vA5/25jnOlsqOIh6YXTo2csmqEsOgVj\n9Z4fL7P2ayJF/tEcxFPEM0uDMRZUH4KPP75NfvSdJSAPb/qRM/1DjiXiXo+G3XLp\n0z7/vmLa0xv1O8xoD4Clew2ROg/YYoSfVF+SNSm5AUhwgA5DgvGWDA+S53S6NL9u\n/e7O8Alj/I3lXwnB1Hp2qupQIQMsTW5l23Mq4FBaNB/wnhFE+54JYRXPhQUqmpgS\nTSeqGNykVFvCKw/Sf5VSxtklRkFiOaGGfC6utLcVwkU4wd/8jSLj3wSCJlNq37dL\nRZMb2qiGT0rz+3u34EUKuACBCsxdb3ws0jD6/PIPQice3tZYc2Q9zfoDwXdXCqkT\ny36Q8W/TYNyHAAcxtMOWAOWjaKuVC13K9ZEfwI9ODnoHi/Nak3aHDosa7J2wzwfk\nh/mMtS5e2KFu1vYqp4daGQgWFpP79N+O/YEIABhru8xgRmid8eHPMPqSB0V3SwiI\ncLfZjEXrWThwiIEb0o0Jm3KfDKdfdncaTv/Yf2vUIlDxr0YVyI8=\n=jWFn\n-----END PGP SIGNATURE-----", "payload": "tree 62f7103143462ed75544985b7c3ad0cb2ddda96b\nparent 4bb66df6de6a832f53f09128ea038fc1c0068515\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1568750391 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1569449083 +0800\n\nBetter handle never type and branch merging\nSplit out tests for never type to another file\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf161fa3e58d57d9b15bd965405036d834f18595", "html_url": "https://github.com/rust-lang/rust/commit/bf161fa3e58d57d9b15bd965405036d834f18595", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf161fa3e58d57d9b15bd965405036d834f18595/comments", "author": null, "committer": null, "parents": [{"sha": "4bb66df6de6a832f53f09128ea038fc1c0068515", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb66df6de6a832f53f09128ea038fc1c0068515", "html_url": "https://github.com/rust-lang/rust/commit/4bb66df6de6a832f53f09128ea038fc1c0068515"}], "stats": {"total": 573, "additions": 392, "deletions": 181}, "files": [{"sha": "b2111be053ccc88027548191003d2d5d4d8a8a10", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf161fa3e58d57d9b15bd965405036d834f18595/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf161fa3e58d57d9b15bd965405036d834f18595/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=bf161fa3e58d57d9b15bd965405036d834f18595", "patch": "@@ -13,4 +13,5 @@ test_utils::marks!(\n     infer_while_let\n     macro_rules_from_other_crates_are_visible_with_macro_use\n     prelude_is_macro_use\n+    coerce_merge_fail_fallback\n );"}, {"sha": "cbbba8b23fde4fabd35175cbc3a50649125def94", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 92, "deletions": 60, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/bf161fa3e58d57d9b15bd965405036d834f18595/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf161fa3e58d57d9b15bd965405036d834f18595/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=bf161fa3e58d57d9b15bd965405036d834f18595", "patch": "@@ -297,23 +297,35 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n         match (ty1, ty2) {\n             (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n+\n             (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n             | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n-            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2))) => {\n+            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2)))\n+            | (\n+                Ty::Infer(InferTy::MaybeNeverTypeVar(tv1)),\n+                Ty::Infer(InferTy::MaybeNeverTypeVar(tv2)),\n+            ) => {\n                 // both type vars are unknown since we tried to resolve them\n                 self.var_unification_table.union(*tv1, *tv2);\n                 true\n             }\n+\n+            // The order of MaybeNeverTypeVar matters here.\n+            // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n+            // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n             (Ty::Infer(InferTy::TypeVar(tv)), other)\n             | (other, Ty::Infer(InferTy::TypeVar(tv)))\n-            | (Ty::Infer(InferTy::IntVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::IntVar(tv)))\n-            | (Ty::Infer(InferTy::FloatVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::FloatVar(tv))) => {\n+            | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n+            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Int(_)))\n+            | (other @ ty_app!(TypeCtor::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n+            | (Ty::Infer(InferTy::FloatVar(tv)), other @ ty_app!(TypeCtor::Float(_)))\n+            | (other @ ty_app!(TypeCtor::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n                 // the type var is unknown since we tried to resolve it\n                 self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n                 true\n             }\n+\n             _ => false,\n         }\n     }\n@@ -330,6 +342,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n     }\n \n+    fn new_maybe_never_type_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::MaybeNeverTypeVar(\n+            self.var_unification_table.new_key(TypeVarValue::Unknown),\n+        ))\n+    }\n+\n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty {\n@@ -817,6 +835,24 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ty\n     }\n \n+    /// Merge two types from different branches, with possible implicit coerce.\n+    ///\n+    /// Note that it is only possible that one type are coerced to another.\n+    /// Coercing both types to another least upper bound type is not possible in rustc,\n+    /// which will simply result in \"incompatible types\" error.\n+    fn coerce_merge_branch<'t>(&mut self, ty1: &Ty, ty2: &Ty) -> Ty {\n+        if self.coerce(ty1, ty2) {\n+            ty2.clone()\n+        } else if self.coerce(ty2, ty1) {\n+            ty1.clone()\n+        } else {\n+            tested_by!(coerce_merge_fail_fallback);\n+            // For incompatible types, we use the latter one as result\n+            // to be better recovery for `if` without `else`.\n+            ty2.clone()\n+        }\n+    }\n+\n     /// Unify two types, but may coerce the first one to the second one\n     /// using \"implicit coercion rules\" if needed.\n     ///\n@@ -828,12 +864,26 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n-        match (&mut from_ty, &*to_ty) {\n-            // Top and bottom type\n+        match (&from_ty, to_ty) {\n+            // Never type will make type variable to fallback to Never Type instead of Unknown.\n+            (ty_app!(TypeCtor::Never), Ty::Infer(InferTy::TypeVar(tv))) => {\n+                let var = self.new_maybe_never_type_var();\n+                self.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n+                return true;\n+            }\n             (ty_app!(TypeCtor::Never), _) => return true,\n \n-            // FIXME: Solve `FromTy: CoerceUnsized<ToTy>` instead of listing common impls here.\n+            // Trivial cases, this should go after `never` check to\n+            // avoid infer result type to be never\n+            _ => {\n+                if self.unify_inner_trivial(&from_ty, &to_ty) {\n+                    return true;\n+                }\n+            }\n+        }\n \n+        // Pointer weakening and function to pointer\n+        match (&mut from_ty, to_ty) {\n             // `*mut T`, `&mut T, `&T`` -> `*const T`\n             // `&mut T` -> `&T`\n             // `&mut T` -> `*mut T`\n@@ -866,71 +916,67 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n             }\n \n-            // Trivial cases, this should go after `never` check to\n-            // avoid infer result type to be never\n-            _ => {\n-                if self.unify_inner_trivial(&from_ty, &to_ty) {\n-                    return true;\n-                }\n-            }\n+            _ => {}\n         }\n \n-        // Try coerce or unify\n+        // FIXME: Solve `FromTy: CoerceUnsized<ToTy>` instead of listing common impls here.\n         match (&from_ty, &to_ty) {\n-            // FIXME: Solve `FromTy: CoerceUnsized<ToTy>` instead of listing common impls here.\n+            // Mutilibity is checked above\n             (ty_app!(TypeCtor::Ref(_), st1), ty_app!(TypeCtor::Ref(_), st2))\n             | (ty_app!(TypeCtor::RawPtr(_), st1), ty_app!(TypeCtor::RawPtr(_), st2)) => {\n-                match self.try_coerce_unsized(&st1[0], &st2[0], 0) {\n-                    Some(ret) => return ret,\n-                    None => {}\n+                if self.try_coerce_unsized(&st1[0], &st2[0], 0) {\n+                    return true;\n                 }\n             }\n             _ => {}\n         }\n \n         // Auto Deref if cannot coerce\n-        match (&from_ty, &to_ty) {\n+        match (&from_ty, to_ty) {\n+            // FIXME: DerefMut\n             (ty_app!(TypeCtor::Ref(_), st1), ty_app!(TypeCtor::Ref(_), st2)) => {\n                 self.unify_autoderef_behind_ref(&st1[0], &st2[0])\n             }\n \n-            // Normal unify\n-            _ => self.unify(&from_ty, &to_ty),\n+            // Otherwise, normal unify\n+            _ => self.unify(&from_ty, to_ty),\n         }\n     }\n \n     /// Coerce a type to a DST if `FromTy: Unsize<ToTy>`\n     ///\n     /// See: `https://doc.rust-lang.org/nightly/std/marker/trait.Unsize.html`\n-    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty, depth: usize) -> Option<bool> {\n+    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty, depth: usize) -> bool {\n         if depth > 1000 {\n             panic!(\"Infinite recursion in coercion\");\n         }\n \n-        // FIXME: Correctly handle\n         match (&from_ty, &to_ty) {\n             // `[T; N]` -> `[T]`\n             (ty_app!(TypeCtor::Array, st1), ty_app!(TypeCtor::Slice, st2)) => {\n-                Some(self.unify(&st1[0], &st2[0]))\n+                self.unify(&st1[0], &st2[0])\n             }\n \n             // `T` -> `dyn Trait` when `T: Trait`\n             (_, Ty::Dyn(_)) => {\n                 // FIXME: Check predicates\n-                Some(true)\n+                true\n             }\n \n-            (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) if ctor1 == ctor2 => {\n+            (\n+                ty_app!(TypeCtor::Adt(Adt::Struct(struct1)), st1),\n+                ty_app!(TypeCtor::Adt(Adt::Struct(struct2)), st2),\n+            ) if struct1 == struct2 => {\n+                // FIXME: Check preconditions here\n                 for (ty1, ty2) in st1.iter().zip(st2.iter()) {\n-                    match self.try_coerce_unsized(ty1, ty2, depth + 1) {\n-                        Some(true) => {}\n-                        ret => return ret,\n+                    if !self.try_coerce_unsized(ty1, ty2, depth + 1) {\n+                        return false;\n                     }\n                 }\n-                Some(true)\n+                true\n             }\n \n-            _ => None,\n+            _ => false,\n         }\n     }\n \n@@ -980,18 +1026,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n \n                 let then_ty = self.infer_expr_inner(*then_branch, &expected);\n-                self.coerce(&then_ty, &expected.ty);\n-\n                 let else_ty = match else_branch {\n                     Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n                     None => Ty::unit(),\n                 };\n-                if !self.coerce(&else_ty, &expected.ty) {\n-                    self.coerce(&expected.ty, &else_ty);\n-                    else_ty.clone()\n-                } else {\n-                    expected.ty.clone()\n-                }\n+\n+                self.coerce_merge_branch(&then_ty, &else_ty)\n             }\n             Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n             Expr::TryBlock { body } => {\n@@ -1087,11 +1127,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .infer_method_call(tgt_expr, *receiver, &args, &method_name, generic_args.as_ref()),\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n-                let mut expected = match expected.ty {\n-                    Ty::Unknown => Expectation::has_type(Ty::simple(TypeCtor::Never)),\n-                    _ => expected.clone(),\n-                };\n-                let mut all_never = true;\n+\n+                let mut result_ty = self.new_maybe_never_type_var();\n \n                 for arm in arms {\n                     for &pat in &arm.pats {\n@@ -1103,22 +1140,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n                         );\n                     }\n+\n                     let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n-                    match &arm_ty {\n-                        ty_app!(TypeCtor::Never) => (),\n-                        _ => all_never = false,\n-                    }\n-                    if !self.coerce(&arm_ty, &expected.ty) {\n-                        self.coerce(&expected.ty, &arm_ty);\n-                        expected = Expectation::has_type(arm_ty);\n-                    }\n+                    result_ty = self.coerce_merge_branch(&result_ty, &arm_ty);\n                 }\n \n-                if all_never {\n-                    Ty::simple(TypeCtor::Never)\n-                } else {\n-                    expected.ty\n-                }\n+                result_ty\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -1558,12 +1585,16 @@ pub enum InferTy {\n     TypeVar(TypeVarId),\n     IntVar(TypeVarId),\n     FloatVar(TypeVarId),\n+    MaybeNeverTypeVar(TypeVarId),\n }\n \n impl InferTy {\n     fn to_inner(self) -> TypeVarId {\n         match self {\n-            InferTy::TypeVar(ty) | InferTy::IntVar(ty) | InferTy::FloatVar(ty) => ty,\n+            InferTy::TypeVar(ty)\n+            | InferTy::IntVar(ty)\n+            | InferTy::FloatVar(ty)\n+            | InferTy::MaybeNeverTypeVar(ty) => ty,\n         }\n     }\n \n@@ -1576,6 +1607,7 @@ impl InferTy {\n             InferTy::FloatVar(..) => Ty::simple(TypeCtor::Float(\n                 primitive::UncertainFloatTy::Known(primitive::FloatTy::f64()),\n             )),\n+            InferTy::MaybeNeverTypeVar(..) => Ty::simple(TypeCtor::Never),\n         }\n     }\n }"}, {"sha": "b6ebee3b1b2a1ce35ef626be99161119c44341f8", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf161fa3e58d57d9b15bd965405036d834f18595/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf161fa3e58d57d9b15bd965405036d834f18595/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=bf161fa3e58d57d9b15bd965405036d834f18595", "patch": "@@ -63,6 +63,7 @@ where\n                         InferTy::TypeVar(_) => InferTy::TypeVar(root),\n                         InferTy::IntVar(_) => InferTy::IntVar(root),\n                         InferTy::FloatVar(_) => InferTy::FloatVar(root),\n+                        InferTy::MaybeNeverTypeVar(_) => InferTy::MaybeNeverTypeVar(root),\n                     };\n                     let position = self.add(free_var);\n                     Ty::Bound(position as u32)"}, {"sha": "081bfe37c9dfe0985fb4325cda74c0040c91879b", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 40, "deletions": 121, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/bf161fa3e58d57d9b15bd965405036d834f18595/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf161fa3e58d57d9b15bd965405036d834f18595/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=bf161fa3e58d57d9b15bd965405036d834f18595", "patch": "@@ -20,6 +20,8 @@ use crate::{\n // against snapshots of the expected results using insta. Use cargo-insta to\n // update the snapshots.\n \n+mod never_type;\n+\n #[test]\n fn infer_await() {\n     let (mut db, pos) = MockDatabase::with_position(\n@@ -1077,6 +1079,42 @@ fn test(i: i32) {\n     );\n }\n \n+#[test]\n+fn coerce_merge_one_by_one1() {\n+    covers!(coerce_merge_fail_fallback);\n+\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let t = &mut 1;\n+    let x = match 1 {\n+        1 => t as *mut i32,\n+        2 => t as &i32,\n+        _ => t as *const i32,\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 145) '{     ...  }; }': ()\n+    [21; 22) 't': &mut i32\n+    [25; 31) '&mut 1': &mut i32\n+    [30; 31) '1': i32\n+    [41; 42) 'x': *const i32\n+    [45; 142) 'match ...     }': *const i32\n+    [51; 52) '1': i32\n+    [63; 64) '1': i32\n+    [68; 69) 't': &mut i32\n+    [68; 81) 't as *mut i32': *mut i32\n+    [91; 92) '2': i32\n+    [96; 97) 't': &mut i32\n+    [96; 105) 't as &i32': &i32\n+    [115; 116) '_': i32\n+    [120; 121) 't': &mut i32\n+    [120; 135) 't as *const i32': *const i32\n+    \"###\n+    );\n+}\n+\n #[test]\n fn bug_484() {\n     assert_snapshot!(\n@@ -2458,7 +2496,6 @@ fn extra_compiler_flags() {\n }\n \"#),\n         @r###\"\n-\n     [27; 323) '{     ...   } }': ()\n     [33; 321) 'for co...     }': ()\n     [37; 44) 'content': &{unknown}\n@@ -2472,8 +2509,8 @@ fn extra_compiler_flags() {\n     [135; 167) '{     ...     }': &&{unknown}\n     [149; 157) '&content': &&{unknown}\n     [150; 157) 'content': &{unknown}\n-    [182; 189) 'content': &&{unknown}\n-    [192; 314) 'if ICE...     }': &&{unknown}\n+    [182; 189) 'content': &{unknown}\n+    [192; 314) 'if ICE...     }': &{unknown}\n     [195; 232) 'ICE_RE..._VALUE': {unknown}\n     [195; 248) 'ICE_RE...&name)': bool\n     [242; 247) '&name': &&&{unknown}\n@@ -4683,121 +4720,3 @@ fn no_such_field_diagnostics() {\n     \"###\n     );\n }\n-\n-mod branching_with_never_tests {\n-    use super::type_at;\n-\n-    #[test]\n-    fn if_never() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test() {\n-    let i = if true {\n-        loop {}\n-    } else {\n-        3.0\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"f64\");\n-    }\n-\n-    #[test]\n-    fn if_else_never() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test(input: bool) {\n-    let i = if input {\n-        2.0\n-    } else {\n-        return\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"f64\");\n-    }\n-\n-    #[test]\n-    fn match_first_arm_never() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test(a: i32) {\n-    let i = match a {\n-        1 => return,\n-        2 => 2.0,\n-        3 => loop {},\n-        _ => 3.0,\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"f64\");\n-    }\n-\n-    #[test]\n-    fn match_second_arm_never() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test(a: i32) {\n-    let i = match a {\n-        1 => 3.0,\n-        2 => loop {},\n-        3 => 3.0,\n-        _ => return,\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"f64\");\n-    }\n-\n-    #[test]\n-    fn match_all_arms_never() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test(a: i32) {\n-    let i = match a {\n-        2 => return,\n-        _ => loop {},\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"!\");\n-    }\n-\n-    #[test]\n-    fn match_no_never_arms() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test(a: i32) {\n-    let i = match a {\n-        2 => 2.0,\n-        _ => 3.0,\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"f64\");\n-    }\n-}"}, {"sha": "b9af918e92d0a3c780e5e6acc3ebe6c2db0e564f", "filename": "crates/ra_hir/src/ty/tests/never_type.rs", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/bf161fa3e58d57d9b15bd965405036d834f18595/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf161fa3e58d57d9b15bd965405036d834f18595/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fnever_type.rs?ref=bf161fa3e58d57d9b15bd965405036d834f18595", "patch": "@@ -0,0 +1,258 @@\n+use super::type_at;\n+\n+#[test]\n+fn infer_never1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test() {\n+    let t = return;\n+    t<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"!\");\n+}\n+\n+#[test]\n+fn infer_never2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Foo { fn gen() -> Self; }\n+impl Foo for ! { fn gen() -> Self { loop {} } }\n+impl Foo for () { fn gen() -> Self { loop {} } }\n+\n+fn test() {\n+    let a = Foo::gen();\n+    if false { a } else { loop {} };\n+    a<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"!\");\n+}\n+\n+#[test]\n+fn infer_never3() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Foo { fn gen() -> Self; }\n+impl Foo for ! { fn gen() -> Self { loop {} } }\n+impl Foo for () { fn gen() -> Self { loop {} } }\n+\n+fn test() {\n+    let a = Foo::gen();\n+    if false { loop {} } else { a };\n+    a<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"!\");\n+}\n+\n+#[test]\n+fn never_type_in_generic_args() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+enum Option<T> { None, Some(T) }\n+\n+fn test() {\n+    let a = if true { Option::None } else { Option::Some(return) };\n+    a<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"Option<!>\");\n+}\n+\n+#[test]\n+fn never_type_can_be_reinferred1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Foo { fn gen() -> Self; }\n+impl Foo for ! { fn gen() -> Self { loop {} } }\n+impl Foo for () { fn gen() -> Self { loop {} } }\n+\n+fn test() {\n+    let a = Foo::gen();\n+    if false { loop {} } else { a };\n+    a<|>;\n+    if false { a };\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"()\");\n+}\n+\n+#[test]\n+fn never_type_can_be_reinferred2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+enum Option<T> { None, Some(T) }\n+\n+fn test() {\n+    let a = if true { Option::None } else { Option::Some(return) };\n+    a<|>;\n+    match 42 {\n+        42 => a,\n+        _ => Option::Some(42),\n+    };\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"Option<i32>\");\n+}\n+#[test]\n+fn never_type_can_be_reinferred3() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+enum Option<T> { None, Some(T) }\n+\n+fn test() {\n+    let a = if true { Option::None } else { Option::Some(return) };\n+    a<|>;\n+    match 42 {\n+        42 => a,\n+        _ => Option::Some(\"str\"),\n+    };\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"Option<&str>\");\n+}\n+\n+#[test]\n+fn match_no_arm() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+enum Void {}\n+\n+fn test(a: Void) {\n+    let t = match a {};\n+    t<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"!\");\n+}\n+\n+#[test]\n+fn if_never() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test() {\n+    let i = if true {\n+        loop {}\n+    } else {\n+        3.0\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"f64\");\n+}\n+\n+#[test]\n+fn if_else_never() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test(input: bool) {\n+    let i = if input {\n+        2.0\n+    } else {\n+        return\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"f64\");\n+}\n+\n+#[test]\n+fn match_first_arm_never() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        1 => return,\n+        2 => 2.0,\n+        3 => loop {},\n+        _ => 3.0,\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"f64\");\n+}\n+\n+#[test]\n+fn match_second_arm_never() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        1 => 3.0,\n+        2 => loop {},\n+        3 => 3.0,\n+        _ => return,\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"f64\");\n+}\n+\n+#[test]\n+fn match_all_arms_never() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        2 => return,\n+        _ => loop {},\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"!\");\n+}\n+\n+#[test]\n+fn match_no_never_arms() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        2 => 2.0,\n+        _ => 3.0,\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"f64\");\n+}"}]}