{"sha": "31ac9c4288f32c2afdce11e616668b251e6164ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYWM5YzQyODhmMzJjMmFmZGNlMTFlNjE2NjY4YjI1MWU2MTY0ZWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-24T19:00:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-26T18:37:08Z"}, "message": "Change private structs to have private fields by default\n\nThis was the original intention of the privacy of structs, and it was\nerroneously implemented before. A pub struct will now have default-pub fields,\nand a non-pub struct will have default-priv fields. This essentially brings\nstruct fields in line with enum variants in terms of inheriting visibility.\n\nAs usual, extraneous modifiers to visibility are disallowed depend on the case\nthat you're dealing with.\n\nCloses #11522", "tree": {"sha": "7bdaf7a6709929382bd84d4b9f8c340864a804d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bdaf7a6709929382bd84d4b9f8c340864a804d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31ac9c4288f32c2afdce11e616668b251e6164ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31ac9c4288f32c2afdce11e616668b251e6164ef", "html_url": "https://github.com/rust-lang/rust/commit/31ac9c4288f32c2afdce11e616668b251e6164ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31ac9c4288f32c2afdce11e616668b251e6164ef/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "838b5a4cc072057f31453cdd1b50345f92e1a772", "url": "https://api.github.com/repos/rust-lang/rust/commits/838b5a4cc072057f31453cdd1b50345f92e1a772", "html_url": "https://github.com/rust-lang/rust/commit/838b5a4cc072057f31453cdd1b50345f92e1a772"}], "stats": {"total": 168, "additions": 136, "deletions": 32}, "files": [{"sha": "052a6ad898fd63ce55e8d234e1beee492153c135", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 66, "deletions": 32, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/31ac9c4288f32c2afdce11e616668b251e6164ef/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ac9c4288f32c2afdce11e616668b251e6164ef/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=31ac9c4288f32c2afdce11e616668b251e6164ef", "patch": "@@ -15,6 +15,7 @@\n use std::hashmap::{HashSet, HashMap};\n use std::util;\n \n+use metadata::csearch;\n use middle::resolve;\n use middle::ty;\n use middle::typeck::{method_map, method_origin, method_param};\n@@ -123,22 +124,7 @@ impl Visitor<()> for ParentVisitor {\n         // While we have the id of the struct definition, go ahead and parent\n         // all the fields.\n         for field in s.fields.iter() {\n-            let vis = match field.node.kind {\n-                ast::NamedField(_, vis) => vis,\n-                ast::UnnamedField => continue\n-            };\n-\n-            // Private fields are scoped to this module, so parent them directly\n-            // to the module instead of the struct. This is similar to the case\n-            // of private enum variants.\n-            if vis == ast::Private {\n-                self.parents.insert(field.node.id, self.curparent);\n-\n-            // Otherwise public fields are scoped to the visibility of the\n-            // struct itself\n-            } else {\n-                self.parents.insert(field.node.id, n);\n-            }\n+            self.parents.insert(field.node.id, self.curparent);\n         }\n         visit::walk_struct_def(self, s, i, g, n, ())\n     }\n@@ -558,12 +544,48 @@ impl<'a> PrivacyVisitor<'a> {\n \n     // Checks that a field is in scope.\n     // FIXME #6993: change type (and name) from Ident to Name\n-    fn check_field(&mut self, span: Span, id: ast::DefId, ident: ast::Ident) {\n+    fn check_field(&mut self, span: Span, id: ast::DefId, ident: ast::Ident,\n+                   enum_id: Option<ast::DefId>) {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n+        let struct_vis = if is_local(id) {\n+            match self.tcx.items.get(id.node) {\n+                ast_map::NodeItem(ref it, _) => it.vis,\n+                ast_map::NodeVariant(ref v, ref it, _) => {\n+                    if v.node.vis == ast::Inherited {it.vis} else {v.node.vis}\n+                }\n+                _ => {\n+                    self.tcx.sess.span_bug(span,\n+                                           format!(\"not an item or variant def\"));\n+                }\n+            }\n+        } else {\n+            let cstore = self.tcx.sess.cstore;\n+            match enum_id {\n+                Some(enum_id) => {\n+                    let v = csearch::get_enum_variants(self.tcx, enum_id);\n+                    match v.iter().find(|v| v.id == id) {\n+                        Some(variant) => {\n+                            if variant.vis == ast::Inherited {\n+                                csearch::get_item_visibility(cstore, enum_id)\n+                            } else {\n+                                variant.vis\n+                            }\n+                        }\n+                        None => {\n+                            self.tcx.sess.span_bug(span, \"no xcrate variant\");\n+                        }\n+                    }\n+                }\n+                None => csearch::get_item_visibility(cstore, id)\n+            }\n+        };\n+\n         for field in fields.iter() {\n             if field.name != ident.name { continue; }\n-            // public fields are public everywhere\n-            if field.vis != ast::Private { break }\n+            // public structs have public fields by default, and private structs\n+            // have private fields by default.\n+            if struct_vis == ast::Public && field.vis != ast::Private { break }\n+            if struct_vis != ast::Public && field.vis == ast::Public { break }\n             if !is_local(field.id) ||\n                !self.private_accessible(field.id.node) {\n                 self.tcx.sess.span_err(span, format!(\"field `{}` is private\",\n@@ -661,7 +683,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 let t = ty::type_autoderef(ty::expr_ty(self.tcx, base));\n                 match ty::get(t).sty {\n                     ty::ty_struct(id, _) => {\n-                        self.check_field(expr.span, id, ident);\n+                        self.check_field(expr.span, id, ident, None);\n                     }\n                     _ => {}\n                 }\n@@ -690,16 +712,18 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in (*fields).iter() {\n-                            self.check_field(expr.span, id, field.ident.node);\n+                            self.check_field(expr.span, id, field.ident.node,\n+                                             None);\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         let def_map = self.tcx.def_map.borrow();\n                         match def_map.get().get_copy(&expr.id) {\n-                            ast::DefVariant(_, variant_id, _) => {\n+                            ast::DefVariant(enum_id, variant_id, _) => {\n                                 for field in fields.iter() {\n                                     self.check_field(expr.span, variant_id,\n-                                                     field.ident.node);\n+                                                     field.ident.node,\n+                                                     Some(enum_id));\n                                 }\n                             }\n                             _ => self.tcx.sess.span_bug(expr.span,\n@@ -763,16 +787,17 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in fields.iter() {\n-                            self.check_field(pattern.span, id, field.ident);\n+                            self.check_field(pattern.span, id, field.ident,\n+                                             None);\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         let def_map = self.tcx.def_map.borrow();\n                         match def_map.get().find(&pattern.id) {\n-                            Some(&ast::DefVariant(_, variant_id, _)) => {\n+                            Some(&ast::DefVariant(enum_id, variant_id, _)) => {\n                                 for field in fields.iter() {\n                                     self.check_field(pattern.span, variant_id,\n-                                                     field.ident);\n+                                                     field.ident, Some(enum_id));\n                                 }\n                             }\n                             _ => self.tcx.sess.span_bug(pattern.span,\n@@ -888,15 +913,22 @@ impl SanePrivacyVisitor {\n                 }\n             }\n         };\n-        let check_struct = |def: &@ast::StructDef| {\n+        let check_struct = |def: &@ast::StructDef,\n+                            vis: ast::Visibility,\n+                            parent_vis: Option<ast::Visibility>| {\n+            let public_def = match vis {\n+                ast::Public => true,\n+                ast::Inherited | ast::Private => parent_vis == Some(ast::Public),\n+            };\n             for f in def.fields.iter() {\n                match f.node.kind {\n-                    ast::NamedField(_, ast::Public) => {\n+                    ast::NamedField(_, ast::Public) if public_def => {\n                         tcx.sess.span_err(f.span, \"unnecessary `pub` \\\n                                                    visibility\");\n                     }\n-                    ast::NamedField(_, ast::Private) => {\n-                        // Fields should really be private by default...\n+                    ast::NamedField(_, ast::Private) if !public_def => {\n+                        tcx.sess.span_err(f.span, \"unnecessary `priv` \\\n+                                                   visibility\");\n                     }\n                     ast::NamedField(..) | ast::UnnamedField => {}\n                 }\n@@ -951,13 +983,15 @@ impl SanePrivacyVisitor {\n                     }\n \n                     match v.node.kind {\n-                        ast::StructVariantKind(ref s) => check_struct(s),\n+                        ast::StructVariantKind(ref s) => {\n+                            check_struct(s, v.node.vis, Some(item.vis));\n+                        }\n                         ast::TupleVariantKind(..) => {}\n                     }\n                 }\n             }\n \n-            ast::ItemStruct(ref def, _) => check_struct(def),\n+            ast::ItemStruct(ref def, _) => check_struct(def, item.vis, None),\n \n             ast::ItemTrait(_, _, ref methods) => {\n                 for m in methods.iter() {"}, {"sha": "497d50a2390325833de7c048d9db58baa2b88fb7", "filename": "src/test/auxiliary/struct-field-privacy.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/31ac9c4288f32c2afdce11e616668b251e6164ef/src%2Ftest%2Fauxiliary%2Fstruct-field-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ac9c4288f32c2afdce11e616668b251e6164ef/src%2Ftest%2Fauxiliary%2Fstruct-field-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstruct-field-privacy.rs?ref=31ac9c4288f32c2afdce11e616668b251e6164ef", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A {\n+    a: int,\n+    pub b: int,\n+}\n+\n+pub struct B {\n+    a: int,\n+    priv b: int,\n+}"}, {"sha": "f31690047854f5017c59f2c689d186dff0142572", "filename": "src/test/compile-fail/struct-field-privacy.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/31ac9c4288f32c2afdce11e616668b251e6164ef/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ac9c4288f32c2afdce11e616668b251e6164ef/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs?ref=31ac9c4288f32c2afdce11e616668b251e6164ef", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:struct-field-privacy.rs\n+\n+extern mod xc = \"struct-field-privacy\";\n+\n+struct A {\n+    a: int,\n+}\n+\n+mod inner {\n+    struct A {\n+        a: int,\n+        pub b: int,\n+        priv c: int, //~ ERROR: unnecessary `priv` visibility\n+    }\n+    pub struct B {\n+        a: int,\n+        priv b: int,\n+        pub c: int, //~ ERROR: unnecessary `pub` visibility\n+    }\n+}\n+\n+fn test(a: A, b: inner::A, c: inner::B, d: xc::A, e: xc::B) {\n+    //~^ ERROR: type `A` is private\n+    //~^^ ERROR: struct `A` is private\n+\n+    a.a;\n+    b.a; //~ ERROR: field `a` is private\n+    b.b;\n+    b.c; //~ ERROR: field `c` is private\n+    c.a;\n+    c.b; //~ ERROR: field `b` is private\n+    c.c;\n+\n+    d.a; //~ ERROR: field `a` is private\n+    d.b;\n+\n+    e.a;\n+    e.b; //~ ERROR: field `b` is private\n+}\n+\n+fn main() {}"}]}