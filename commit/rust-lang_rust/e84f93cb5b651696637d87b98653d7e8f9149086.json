{"sha": "e84f93cb5b651696637d87b98653d7e8f9149086", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NGY5M2NiNWI2NTE2OTY2MzdkODdiOTg2NTNkN2U4ZjkxNDkwODY=", "commit": {"author": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-08-22T18:31:21Z"}, "committer": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-08-22T21:43:12Z"}, "message": "refactor fill_match_arms assist", "tree": {"sha": "9e4ea5877bce11dbc620bb56e01f86d761b7c5fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e4ea5877bce11dbc620bb56e01f86d761b7c5fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e84f93cb5b651696637d87b98653d7e8f9149086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e84f93cb5b651696637d87b98653d7e8f9149086", "html_url": "https://github.com/rust-lang/rust/commit/e84f93cb5b651696637d87b98653d7e8f9149086", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e84f93cb5b651696637d87b98653d7e8f9149086/comments", "author": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08e5d394dfbca28b15ed5dc772d55d48f87c3f54", "url": "https://api.github.com/repos/rust-lang/rust/commits/08e5d394dfbca28b15ed5dc772d55d48f87c3f54", "html_url": "https://github.com/rust-lang/rust/commit/08e5d394dfbca28b15ed5dc772d55d48f87c3f54"}], "stats": {"total": 302, "additions": 170, "deletions": 132}, "files": [{"sha": "cbeb7054f4e539cff9adea2d9bd8f6160a07e4e9", "filename": "crates/ra_assists/src/add_missing_impl_members.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e84f93cb5b651696637d87b98653d7e8f9149086/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84f93cb5b651696637d87b98653d7e8f9149086/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs?ref=e84f93cb5b651696637d87b98653d7e8f9149086", "patch": "@@ -1,13 +1,14 @@\n+use hir::{db::HirDatabase, HasSource};\n+use ra_syntax::{\n+    ast::{self, AstNode, NameOwner},\n+    SmolStr,\n+};\n+\n use crate::{\n     ast_editor::{AstBuilder, AstEditor},\n     Assist, AssistCtx, AssistId,\n };\n \n-use hir::{db::HirDatabase, HasSource};\n-use ra_db::FilePosition;\n-use ra_syntax::ast::{self, AstNode, NameOwner};\n-use ra_syntax::SmolStr;\n-\n #[derive(PartialEq)]\n enum AddMissingImplMembersMode {\n     DefaultMethodsOnly,\n@@ -43,8 +44,7 @@ fn add_missing_impl_members_inner(\n \n     let trait_def = {\n         let file_id = ctx.frange.file_id;\n-        let position = FilePosition { file_id, offset: impl_node.syntax().text_range().start() };\n-        let analyzer = hir::SourceAnalyzer::new(ctx.db, position.file_id, impl_node.syntax(), None);\n+        let analyzer = hir::SourceAnalyzer::new(ctx.db, file_id, impl_node.syntax(), None);\n \n         resolve_target_trait_def(ctx.db, &analyzer, &impl_node)?\n     };"}, {"sha": "5b6952426568752c6f162b4f61b28bcddf2f86d9", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 91, "deletions": 2, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e84f93cb5b651696637d87b98653d7e8f9149086/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84f93cb5b651696637d87b98653d7e8f9149086/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=e84f93cb5b651696637d87b98653d7e8f9149086", "patch": "@@ -1,6 +1,8 @@\n use std::{iter, ops::RangeInclusive};\n \n use arrayvec::ArrayVec;\n+use itertools::Itertools;\n+\n use hir::Name;\n use ra_fmt::leading_indent;\n use ra_syntax::{\n@@ -168,8 +170,7 @@ impl AstEditor<ast::NamedFieldList> {\n \n impl AstEditor<ast::ItemList> {\n     pub fn append_items(&mut self, items: impl Iterator<Item = ast::ImplItem>) {\n-        let n_existing_items = self.ast().impl_items().count();\n-        if n_existing_items == 0 {\n+        if !self.ast().syntax().text().contains_char('\\n') {\n             self.do_make_multiline();\n         }\n         items.for_each(|it| self.append_item(it));\n@@ -288,6 +289,94 @@ impl AstBuilder<ast::NameRef> {\n     }\n }\n \n+impl AstBuilder<ast::Path> {\n+    fn from_text(text: &str) -> ast::Path {\n+        ast_node_from_file_text(text)\n+    }\n+\n+    pub fn from_pieces(enum_name: ast::Name, var_name: ast::Name) -> ast::Path {\n+        Self::from_text(&format!(\"{}::{}\", enum_name.syntax(), var_name.syntax()))\n+    }\n+}\n+\n+impl AstBuilder<ast::BindPat> {\n+    fn from_text(text: &str) -> ast::BindPat {\n+        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n+    }\n+\n+    pub fn from_name(name: &ast::Name) -> ast::BindPat {\n+        Self::from_text(name.text())\n+    }\n+}\n+\n+impl AstBuilder<ast::PlaceholderPat> {\n+    fn from_text(text: &str) -> ast::PlaceholderPat {\n+        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n+    }\n+\n+    pub fn placeholder() -> ast::PlaceholderPat {\n+        Self::from_text(\"_\")\n+    }\n+}\n+\n+impl AstBuilder<ast::TupleStructPat> {\n+    fn from_text(text: &str) -> ast::TupleStructPat {\n+        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n+    }\n+\n+    pub fn from_pieces(\n+        path: &ast::Path,\n+        pats: impl Iterator<Item = ast::Pat>,\n+    ) -> ast::TupleStructPat {\n+        let pats_str = pats.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n+        Self::from_text(&format!(\"{}({})\", path.syntax(), pats_str))\n+    }\n+}\n+\n+impl AstBuilder<ast::StructPat> {\n+    fn from_text(text: &str) -> ast::StructPat {\n+        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n+    }\n+\n+    pub fn from_pieces(path: &ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::StructPat {\n+        let pats_str = pats.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n+        Self::from_text(&format!(\"{}{{ {} }}\", path.syntax(), pats_str))\n+    }\n+}\n+\n+impl AstBuilder<ast::PathPat> {\n+    fn from_text(text: &str) -> ast::PathPat {\n+        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n+    }\n+\n+    pub fn from_path(path: &ast::Path) -> ast::PathPat {\n+        let path_str = path.syntax().text().to_string();\n+        Self::from_text(path_str.as_str())\n+    }\n+}\n+\n+impl AstBuilder<ast::MatchArm> {\n+    fn from_text(text: &str) -> ast::MatchArm {\n+        ast_node_from_file_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+    }\n+\n+    pub fn from_pieces(pats: impl Iterator<Item = ast::Pat>, expr: &ast::Expr) -> ast::MatchArm {\n+        let pats_str = pats.map(|p| p.syntax().to_string()).join(\" | \");\n+        Self::from_text(&format!(\"{} => {}\", pats_str, expr.syntax()))\n+    }\n+}\n+\n+impl AstBuilder<ast::MatchArmList> {\n+    fn from_text(text: &str) -> ast::MatchArmList {\n+        ast_node_from_file_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+    }\n+\n+    pub fn from_arms(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n+        let arms_str = arms.map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n+        Self::from_text(&format!(\"{},\\n\", arms_str))\n+    }\n+}\n+\n fn ast_node_from_file_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     let res = parse.tree().syntax().descendants().find_map(N::cast).unwrap().to_owned();"}, {"sha": "ce715a449d6da9f099f28b3ba89eb3dcd06d951e", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 72, "deletions": 123, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/e84f93cb5b651696637d87b98653d7e8f9149086/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84f93cb5b651696637d87b98653d7e8f9149086/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=e84f93cb5b651696637d87b98653d7e8f9149086", "patch": "@@ -1,97 +1,91 @@\n-use itertools::Itertools;\n-use std::fmt::Write;\n+use std::iter;\n \n-use hir::{db::HirDatabase, AdtDef, FieldSource, HasSource};\n-use ra_syntax::ast::{self, AstNode};\n+use hir::{db::HirDatabase, AdtDef, HasSource};\n+use ra_syntax::ast::{self, AstNode, NameOwner};\n \n-use crate::{Assist, AssistCtx, AssistId};\n-\n-fn is_trivial_arm(arm: &ast::MatchArm) -> bool {\n-    fn single_pattern(arm: &ast::MatchArm) -> Option<ast::Pat> {\n-        let (pat,) = arm.pats().collect_tuple()?;\n-        Some(pat)\n-    }\n-    match single_pattern(arm) {\n-        Some(ast::Pat::PlaceholderPat(..)) => true,\n-        _ => false,\n-    }\n-}\n+use crate::{ast_editor::AstBuilder, Assist, AssistCtx, AssistId};\n \n pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let match_expr = ctx.node_at_offset::<ast::MatchExpr>()?;\n+    let match_arm_list = match_expr.match_arm_list()?;\n \n     // We already have some match arms, so we don't provide any assists.\n     // Unless if there is only one trivial match arm possibly created\n     // by match postfix complete. Trivial match arm is the catch all arm.\n-    if let Some(arm_list) = match_expr.match_arm_list() {\n-        let mut arm_iter = arm_list.arms();\n-        let first = arm_iter.next();\n-\n-        match &first {\n-            // If there arm list is empty or there is only one trivial arm, then proceed.\n-            Some(arm) if is_trivial_arm(arm) => {\n-                if arm_iter.next() != None {\n-                    return None;\n-                }\n-            }\n-            None => {}\n-\n-            _ => {\n-                return None;\n-            }\n+    let mut existing_arms = match_arm_list.arms();\n+    if let Some(arm) = existing_arms.next() {\n+        if !is_trivial(&arm) || existing_arms.next().is_some() {\n+            return None;\n         }\n     };\n \n     let expr = match_expr.expr()?;\n-    let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, expr.syntax(), None);\n-    let match_expr_ty = analyzer.type_of(ctx.db, &expr)?;\n-    let enum_def = analyzer.autoderef(ctx.db, match_expr_ty).find_map(|ty| match ty.as_adt() {\n-        Some((AdtDef::Enum(e), _)) => Some(e),\n-        _ => None,\n-    })?;\n-    let enum_name = enum_def.name(ctx.db)?;\n-    let db = ctx.db;\n+    let enum_def = {\n+        let file_id = ctx.frange.file_id;\n+        let analyzer = hir::SourceAnalyzer::new(ctx.db, file_id, expr.syntax(), None);\n+        resolve_enum_def(ctx.db, &analyzer, &expr)?\n+    };\n+    let variant_list = enum_def.variant_list()?;\n \n     ctx.add_action(AssistId(\"fill_match_arms\"), \"fill match arms\", |edit| {\n-        let mut buf = format!(\"match {} {{\\n\", expr.syntax().text().to_string());\n-        let variants = enum_def.variants(db);\n-        for variant in variants {\n-            let name = match variant.name(db) {\n-                Some(it) => it,\n-                None => continue,\n-            };\n-            write!(&mut buf, \"    {}::{}\", enum_name, name.to_string()).unwrap();\n-\n-            let pat = variant\n-                .fields(db)\n-                .into_iter()\n-                .map(|field| {\n-                    let name = field.name(db).to_string();\n-                    let src = field.source(db);\n-                    match src.ast {\n-                        FieldSource::Named(_) => name,\n-                        FieldSource::Pos(_) => \"_\".to_string(),\n-                    }\n-                })\n-                .collect::<Vec<_>>();\n+        let variants = variant_list.variants();\n+        let arms = variants.into_iter().filter_map(build_pat).map(|pat| {\n+            AstBuilder::<ast::MatchArm>::from_pieces(\n+                iter::once(pat),\n+                &AstBuilder::<ast::Expr>::unit(),\n+            )\n+        });\n+        let new_arm_list = AstBuilder::<ast::MatchArmList>::from_arms(arms);\n \n-            match pat.first().map(|s| s.as_str()) {\n-                Some(\"_\") => write!(&mut buf, \"({})\", pat.join(\", \")).unwrap(),\n-                Some(_) => write!(&mut buf, \"{{{}}}\", pat.join(\", \")).unwrap(),\n-                None => (),\n-            };\n-\n-            buf.push_str(\" => (),\\n\");\n-        }\n-        buf.push_str(\"}\");\n         edit.target(match_expr.syntax().text_range());\n         edit.set_cursor(expr.syntax().text_range().start());\n-        edit.replace_node_and_indent(match_expr.syntax(), buf);\n+        edit.replace_node_and_indent(match_arm_list.syntax(), new_arm_list.syntax().text());\n     });\n \n     ctx.build()\n }\n \n+fn is_trivial(arm: &ast::MatchArm) -> bool {\n+    arm.pats().any(|pat| match pat {\n+        ast::Pat::PlaceholderPat(..) => true,\n+        _ => false,\n+    })\n+}\n+\n+fn resolve_enum_def(\n+    db: &impl HirDatabase,\n+    analyzer: &hir::SourceAnalyzer,\n+    expr: &ast::Expr,\n+) -> Option<ast::EnumDef> {\n+    let expr_ty = analyzer.type_of(db, &expr)?;\n+\n+    analyzer.autoderef(db, expr_ty).find_map(|ty| match ty.as_adt() {\n+        Some((AdtDef::Enum(e), _)) => Some(e.source(db).ast),\n+        _ => None,\n+    })\n+}\n+\n+fn build_pat(var: ast::EnumVariant) -> Option<ast::Pat> {\n+    let path = &AstBuilder::<ast::Path>::from_pieces(var.parent_enum().name()?, var.name()?);\n+\n+    let pat: ast::Pat = match var.kind() {\n+        ast::StructKind::Tuple(field_list) => {\n+            let pats = iter::repeat(AstBuilder::<ast::PlaceholderPat>::placeholder().into())\n+                .take(field_list.fields().count());\n+            AstBuilder::<ast::TupleStructPat>::from_pieces(path, pats).into()\n+        }\n+        ast::StructKind::Named(field_list) => {\n+            let pats = field_list\n+                .fields()\n+                .map(|f| AstBuilder::<ast::BindPat>::from_name(&f.name().unwrap()).into());\n+            AstBuilder::<ast::StructPat>::from_pieces(path, pats).into()\n+        }\n+        ast::StructKind::Unit => AstBuilder::<ast::PathPat>::from_path(path).into(),\n+    };\n+\n+    Some(pat)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::helpers::{check_assist, check_assist_target};\n@@ -108,7 +102,7 @@ mod tests {\n                 Bs,\n                 Cs(String),\n                 Ds(String, String),\n-                Es{x: usize, y: usize}\n+                Es{ x: usize, y: usize }\n             }\n \n             fn main() {\n@@ -122,7 +116,7 @@ mod tests {\n                 Bs,\n                 Cs(String),\n                 Ds(String, String),\n-                Es{x: usize, y: usize}\n+                Es{ x: usize, y: usize }\n             }\n \n             fn main() {\n@@ -132,7 +126,7 @@ mod tests {\n                     A::Bs => (),\n                     A::Cs(_) => (),\n                     A::Ds(_, _) => (),\n-                    A::Es{x, y} => (),\n+                    A::Es{ x, y } => (),\n                 }\n             }\n             \"#,\n@@ -170,7 +164,7 @@ mod tests {\n             fill_match_arms,\n             r#\"\n             enum A {\n-                Es{x: usize, y: usize}\n+                Es{ x: usize, y: usize }\n             }\n \n             fn foo(a: &mut A) {\n@@ -180,57 +174,12 @@ mod tests {\n             \"#,\n             r#\"\n             enum A {\n-                Es{x: usize, y: usize}\n+                Es{ x: usize, y: usize }\n             }\n \n             fn foo(a: &mut A) {\n                 match <|>a {\n-                    A::Es{x, y} => (),\n-                }\n-            }\n-            \"#,\n-        );\n-\n-        check_assist(\n-            fill_match_arms,\n-            r#\"\n-            enum E { X, Y}\n-\n-            fn main() {\n-                match &E::X<|>\n-            }\n-            \"#,\n-            r#\"\n-            enum E { X, Y}\n-\n-            fn main() {\n-                match <|>&E::X {\n-                    E::X => (),\n-                    E::Y => (),\n-                }\n-            }\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn fill_match_arms_no_body() {\n-        check_assist(\n-            fill_match_arms,\n-            r#\"\n-            enum E { X, Y}\n-\n-            fn main() {\n-                match E::X<|>\n-            }\n-            \"#,\n-            r#\"\n-            enum E { X, Y}\n-\n-            fn main() {\n-                match <|>E::X {\n-                    E::X => (),\n-                    E::Y => (),\n+                    A::Es{ x, y } => (),\n                 }\n             }\n             \"#,\n@@ -242,7 +191,7 @@ mod tests {\n         check_assist_target(\n             fill_match_arms,\n             r#\"\n-            enum E { X, Y}\n+            enum E { X, Y }\n \n             fn main() {\n                 match E::X<|> {}"}]}