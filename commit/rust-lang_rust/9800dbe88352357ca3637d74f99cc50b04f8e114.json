{"sha": "9800dbe88352357ca3637d74f99cc50b04f8e114", "node_id": "C_kwDOAAsO6NoAKDk4MDBkYmU4ODM1MjM1N2NhMzYzN2Q3NGY5OWNjNTBiMDRmOGUxMTQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-02-15T06:54:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-15T06:54:54Z"}, "message": "Rollup merge of #107163 - mikebenfield:parameters-pr, r=TaKO8Ki\n\nRemove some superfluous type parameters from layout.rs.\n\nSpecifically remove V, which can always be VariantIdx, and F, which can always be Layout.", "tree": {"sha": "c9cc3acef9bf4bcbac21d0bcb1f494c18b09e10c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9cc3acef9bf4bcbac21d0bcb1f494c18b09e10c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9800dbe88352357ca3637d74f99cc50b04f8e114", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj7IG+CRBK7hj4Ov3rIwAAagEIAJ2yIH9Q7UIwwnHJ55+1T2PL\niANL51io4nVjnX8bBjUvi/x22TSkvVOVTEiF4apGTBZ1p5LlvA1rCWzcVcpZrSXe\nt9XDzPNPVMg9tQp4bB+upz6LBWti3BcVgMZSaHrzWh8i1ubs5NuCxsfwGF8SXWF2\nVtUmWg4J+iHmvEedd/IMJsGBO3D4Ucxyt6zhUMSY7qETAGZCwxlWM1PmbsSBrf9g\np09SlOjKuytWZn+vHWY5PXhOPKwga9xVI7LCvm0YFS8iQD93oJ4LKgd2drihobCb\nmeDeLLAfAdNCxtnRDgEPzKUY8pL6SKxvmSoiplkaXVr17JTs+c1uOH7KTY6UVNY=\n=LCKi\n-----END PGP SIGNATURE-----\n", "payload": "tree c9cc3acef9bf4bcbac21d0bcb1f494c18b09e10c\nparent 83f10ea5b729fe5133842b407d757c684ef650b5\nparent 8df27d07aed4e12ce6e767f8675599aa0a8e46b9\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1676444094 +0530\ncommitter GitHub <noreply@github.com> 1676444094 +0530\n\nRollup merge of #107163 - mikebenfield:parameters-pr, r=TaKO8Ki\n\nRemove some superfluous type parameters from layout.rs.\n\nSpecifically remove V, which can always be VariantIdx, and F, which can always be Layout.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9800dbe88352357ca3637d74f99cc50b04f8e114", "html_url": "https://github.com/rust-lang/rust/commit/9800dbe88352357ca3637d74f99cc50b04f8e114", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9800dbe88352357ca3637d74f99cc50b04f8e114/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83f10ea5b729fe5133842b407d757c684ef650b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/83f10ea5b729fe5133842b407d757c684ef650b5", "html_url": "https://github.com/rust-lang/rust/commit/83f10ea5b729fe5133842b407d757c684ef650b5"}, {"sha": "8df27d07aed4e12ce6e767f8675599aa0a8e46b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8df27d07aed4e12ce6e767f8675599aa0a8e46b9", "html_url": "https://github.com/rust-lang/rust/commit/8df27d07aed4e12ce6e767f8675599aa0a8e46b9"}], "stats": {"total": 297, "additions": 148, "deletions": 149}, "files": [{"sha": "54858b52008f9b3d7a2848cf6f5cb8378a6be965", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 71, "deletions": 75, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=9800dbe88352357ca3637d74f99cc50b04f8e114", "patch": "@@ -1,11 +1,5 @@\n use super::*;\n-use std::{\n-    borrow::Borrow,\n-    cmp,\n-    fmt::Debug,\n-    iter,\n-    ops::{Bound, Deref},\n-};\n+use std::{borrow::Borrow, cmp, iter, ops::Bound};\n \n #[cfg(feature = \"randomize\")]\n use rand::{seq::SliceRandom, SeedableRng};\n@@ -33,7 +27,7 @@ pub trait LayoutCalculator {\n     fn delay_bug(&self, txt: &str);\n     fn current_data_layout(&self) -> Self::TargetDataLayoutRef;\n \n-    fn scalar_pair<V: Idx>(&self, a: Scalar, b: Scalar) -> LayoutS<V> {\n+    fn scalar_pair(&self, a: Scalar, b: Scalar) -> LayoutS {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();\n         let b_align = b.align(dl);\n@@ -49,7 +43,7 @@ pub trait LayoutCalculator {\n             .max_by_key(|niche| niche.available(dl));\n \n         LayoutS {\n-            variants: Variants::Single { index: V::new(0) },\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Arbitrary {\n                 offsets: vec![Size::ZERO, b_offset],\n                 memory_index: vec![0, 1],\n@@ -61,13 +55,13 @@ pub trait LayoutCalculator {\n         }\n     }\n \n-    fn univariant<'a, V: Idx, F: Deref<Target = &'a LayoutS<V>> + Debug>(\n+    fn univariant(\n         &self,\n         dl: &TargetDataLayout,\n-        fields: &[F],\n+        fields: &[Layout<'_>],\n         repr: &ReprOptions,\n         kind: StructKind,\n-    ) -> Option<LayoutS<V>> {\n+    ) -> Option<LayoutS> {\n         let pack = repr.pack;\n         let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n         let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n@@ -76,17 +70,17 @@ pub trait LayoutCalculator {\n             let end =\n                 if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n             let optimizing = &mut inverse_memory_index[..end];\n-            let effective_field_align = |f: &F| {\n+            let effective_field_align = |layout: Layout<'_>| {\n                 if let Some(pack) = pack {\n                     // return the packed alignment in bytes\n-                    f.align.abi.min(pack).bytes()\n+                    layout.align().abi.min(pack).bytes()\n                 } else {\n                     // returns log2(effective-align).\n                     // This is ok since `pack` applies to all fields equally.\n                     // The calculation assumes that size is an integer multiple of align, except for ZSTs.\n                     //\n                     // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n-                    f.align.abi.bytes().max(f.size.bytes()).trailing_zeros() as u64\n+                    layout.align().abi.bytes().max(layout.size().bytes()).trailing_zeros() as u64\n                 }\n             };\n \n@@ -111,9 +105,9 @@ pub trait LayoutCalculator {\n                             // Place ZSTs first to avoid \"interesting offsets\",\n                             // especially with only one or two non-ZST fields.\n                             // Then place largest alignments first, largest niches within an alignment group last\n-                            let f = &fields[x as usize];\n-                            let niche_size = f.largest_niche.map_or(0, |n| n.available(dl));\n-                            (!f.is_zst(), cmp::Reverse(effective_field_align(f)), niche_size)\n+                            let f = fields[x as usize];\n+                            let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n+                            (!f.0.is_zst(), cmp::Reverse(effective_field_align(f)), niche_size)\n                         });\n                     }\n \n@@ -123,8 +117,8 @@ pub trait LayoutCalculator {\n                         // And put the largest niche in an alignment group at the end\n                         // so it can be used as discriminant in jagged enums\n                         optimizing.sort_by_key(|&x| {\n-                            let f = &fields[x as usize];\n-                            let niche_size = f.largest_niche.map_or(0, |n| n.available(dl));\n+                            let f = fields[x as usize];\n+                            let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n                             (effective_field_align(f), niche_size)\n                         });\n                     }\n@@ -160,23 +154,23 @@ pub trait LayoutCalculator {\n                 ));\n             }\n \n-            if field.is_unsized() {\n+            if field.0.is_unsized() {\n                 sized = false;\n             }\n \n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n             let field_align = if let Some(pack) = pack {\n-                field.align.min(AbiAndPrefAlign::new(pack))\n+                field.align().min(AbiAndPrefAlign::new(pack))\n             } else {\n-                field.align\n+                field.align()\n             };\n             offset = offset.align_to(field_align.abi);\n             align = align.max(field_align);\n \n             debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n             offsets[i as usize] = offset;\n \n-            if let Some(mut niche) = field.largest_niche {\n+            if let Some(mut niche) = field.largest_niche() {\n                 let available = niche.available(dl);\n                 if available > largest_niche_available {\n                     largest_niche_available = available;\n@@ -185,7 +179,7 @@ pub trait LayoutCalculator {\n                 }\n             }\n \n-            offset = offset.checked_add(field.size, dl)?;\n+            offset = offset.checked_add(field.size(), dl)?;\n         }\n         if let Some(repr_align) = repr.align {\n             align = align.max(AbiAndPrefAlign::new(repr_align));\n@@ -205,24 +199,26 @@ pub trait LayoutCalculator {\n         // Unpack newtype ABIs and find scalar pairs.\n         if sized && size.bytes() > 0 {\n             // All other fields must be ZSTs.\n-            let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n+            let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.0.is_zst());\n \n             match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n                 // We have exactly one non-ZST field.\n                 (Some((i, field)), None, None) => {\n                     // Field fills the struct and it has a scalar or scalar pair ABI.\n-                    if offsets[i].bytes() == 0 && align.abi == field.align.abi && size == field.size\n+                    if offsets[i].bytes() == 0\n+                        && align.abi == field.align().abi\n+                        && size == field.size()\n                     {\n-                        match field.abi {\n+                        match field.abi() {\n                             // For plain scalars, or vectors of them, we can't unpack\n                             // newtypes for `#[repr(C)]`, as that affects C ABIs.\n                             Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n-                                abi = field.abi;\n+                                abi = field.abi();\n                             }\n                             // But scalar pairs are Rust-specific and get\n                             // treated as aggregates by C ABIs anyway.\n                             Abi::ScalarPair(..) => {\n-                                abi = field.abi;\n+                                abi = field.abi();\n                             }\n                             _ => {}\n                         }\n@@ -231,15 +227,15 @@ pub trait LayoutCalculator {\n \n                 // Two non-ZST fields, and they're both scalars.\n                 (Some((i, a)), Some((j, b)), None) => {\n-                    match (a.abi, b.abi) {\n+                    match (a.abi(), b.abi()) {\n                         (Abi::Scalar(a), Abi::Scalar(b)) => {\n                             // Order by the memory placement, not source order.\n                             let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n                                 ((i, a), (j, b))\n                             } else {\n                                 ((j, b), (i, a))\n                             };\n-                            let pair = self.scalar_pair::<V>(a, b);\n+                            let pair = self.scalar_pair(a, b);\n                             let pair_offsets = match pair.fields {\n                                 FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                                     assert_eq!(memory_index, &[0, 1]);\n@@ -264,11 +260,11 @@ pub trait LayoutCalculator {\n                 _ => {}\n             }\n         }\n-        if fields.iter().any(|f| f.abi.is_uninhabited()) {\n+        if fields.iter().any(|f| f.abi().is_uninhabited()) {\n             abi = Abi::Uninhabited;\n         }\n         Some(LayoutS {\n-            variants: Variants::Single { index: V::new(0) },\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Arbitrary { offsets, memory_index },\n             abi,\n             largest_niche,\n@@ -277,11 +273,11 @@ pub trait LayoutCalculator {\n         })\n     }\n \n-    fn layout_of_never_type<V: Idx>(&self) -> LayoutS<V> {\n+    fn layout_of_never_type(&self) -> LayoutS {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();\n         LayoutS {\n-            variants: Variants::Single { index: V::new(0) },\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Primitive,\n             abi: Abi::Uninhabited,\n             largest_niche: None,\n@@ -290,18 +286,18 @@ pub trait LayoutCalculator {\n         }\n     }\n \n-    fn layout_of_struct_or_enum<'a, V: Idx, F: Deref<Target = &'a LayoutS<V>> + Debug>(\n+    fn layout_of_struct_or_enum(\n         &self,\n         repr: &ReprOptions,\n-        variants: &IndexVec<V, Vec<F>>,\n+        variants: &IndexVec<VariantIdx, Vec<Layout<'_>>>,\n         is_enum: bool,\n         is_unsafe_cell: bool,\n         scalar_valid_range: (Bound<u128>, Bound<u128>),\n         discr_range_of_repr: impl Fn(i128, i128) -> (Integer, bool),\n-        discriminants: impl Iterator<Item = (V, i128)>,\n+        discriminants: impl Iterator<Item = (VariantIdx, i128)>,\n         niche_optimize_enum: bool,\n         always_sized: bool,\n-    ) -> Option<LayoutS<V>> {\n+    ) -> Option<LayoutS> {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();\n \n@@ -316,9 +312,9 @@ pub trait LayoutCalculator {\n         // but *not* an encoding of the discriminant (e.g., a tag value).\n         // See issue #49298 for more details on the need to leave space\n         // for non-ZST uninhabited data (mostly partial initialization).\n-        let absent = |fields: &[F]| {\n-            let uninhabited = fields.iter().any(|f| f.abi.is_uninhabited());\n-            let is_zst = fields.iter().all(|f| f.is_zst());\n+        let absent = |fields: &[Layout<'_>]| {\n+            let uninhabited = fields.iter().any(|f| f.abi().is_uninhabited());\n+            let is_zst = fields.iter().all(|f| f.0.is_zst());\n             uninhabited && is_zst\n         };\n         let (present_first, present_second) = {\n@@ -335,7 +331,7 @@ pub trait LayoutCalculator {\n             }\n             // If it's a struct, still compute a layout so that we can still compute the\n             // field offsets.\n-            None => V::new(0),\n+            None => VariantIdx::new(0),\n         };\n \n         let is_struct = !is_enum ||\n@@ -439,12 +435,12 @@ pub trait LayoutCalculator {\n         // variant layouts, so we can't store them in the\n         // overall LayoutS. Store the overall LayoutS\n         // and the variant LayoutSs here until then.\n-        struct TmpLayout<V: Idx> {\n-            layout: LayoutS<V>,\n-            variants: IndexVec<V, LayoutS<V>>,\n+        struct TmpLayout {\n+            layout: LayoutS,\n+            variants: IndexVec<VariantIdx, LayoutS>,\n         }\n \n-        let calculate_niche_filling_layout = || -> Option<TmpLayout<V>> {\n+        let calculate_niche_filling_layout = || -> Option<TmpLayout> {\n             if niche_optimize_enum {\n                 return None;\n             }\n@@ -464,15 +460,16 @@ pub trait LayoutCalculator {\n \n                     Some(st)\n                 })\n-                .collect::<Option<IndexVec<V, _>>>()?;\n+                .collect::<Option<IndexVec<VariantIdx, _>>>()?;\n \n             let largest_variant_index = variant_layouts\n                 .iter_enumerated()\n                 .max_by_key(|(_i, layout)| layout.size.bytes())\n                 .map(|(i, _layout)| i)?;\n \n-            let all_indices = (0..=variants.len() - 1).map(V::new);\n-            let needs_disc = |index: V| index != largest_variant_index && !absent(&variants[index]);\n+            let all_indices = (0..=variants.len() - 1).map(VariantIdx::new);\n+            let needs_disc =\n+                |index: VariantIdx| index != largest_variant_index && !absent(&variants[index]);\n             let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap().index()\n                 ..=all_indices.rev().find(|v| needs_disc(*v)).unwrap().index();\n \n@@ -482,7 +479,7 @@ pub trait LayoutCalculator {\n             let (field_index, niche, (niche_start, niche_scalar)) = variants[largest_variant_index]\n                 .iter()\n                 .enumerate()\n-                .filter_map(|(j, field)| Some((j, field.largest_niche?)))\n+                .filter_map(|(j, field)| Some((j, field.largest_niche()?)))\n                 .max_by_key(|(_, niche)| niche.available(dl))\n                 .and_then(|(j, niche)| Some((j, niche, niche.reserve(dl, count)?)))?;\n             let niche_offset =\n@@ -514,7 +511,7 @@ pub trait LayoutCalculator {\n                 match layout.fields {\n                     FieldsShape::Arbitrary { ref mut offsets, .. } => {\n                         for (j, offset) in offsets.iter_mut().enumerate() {\n-                            if !variants[i][j].is_zst() {\n+                            if !variants[i][j].0.is_zst() {\n                                 *offset += this_offset;\n                             }\n                         }\n@@ -572,8 +569,8 @@ pub trait LayoutCalculator {\n                     tag: niche_scalar,\n                     tag_encoding: TagEncoding::Niche {\n                         untagged_variant: largest_variant_index,\n-                        niche_variants: (V::new(*niche_variants.start())\n-                            ..=V::new(*niche_variants.end())),\n+                        niche_variants: (VariantIdx::new(*niche_variants.start())\n+                            ..=VariantIdx::new(*niche_variants.end())),\n                         niche_start,\n                     },\n                     tag_field: 0,\n@@ -598,7 +595,7 @@ pub trait LayoutCalculator {\n         let discr_type = repr.discr_type();\n         let bits = Integer::from_attr(dl, discr_type).size().bits();\n         for (i, mut val) in discriminants {\n-            if variants[i].iter().any(|f| f.abi.is_uninhabited()) {\n+            if variants[i].iter().any(|f| f.abi().is_uninhabited()) {\n                 continue;\n             }\n             if discr_type.is_signed() {\n@@ -636,7 +633,7 @@ pub trait LayoutCalculator {\n         if repr.c() {\n             for fields in variants {\n                 for field in fields {\n-                    prefix_align = prefix_align.max(field.align.abi);\n+                    prefix_align = prefix_align.max(field.align().abi);\n                 }\n             }\n         }\n@@ -655,16 +652,16 @@ pub trait LayoutCalculator {\n                 // Find the first field we can't move later\n                 // to make room for a larger discriminant.\n                 for field in st.fields.index_by_increasing_offset().map(|j| &field_layouts[j]) {\n-                    if !field.is_zst() || field.align.abi.bytes() != 1 {\n-                        start_align = start_align.min(field.align.abi);\n+                    if !field.0.is_zst() || field.align().abi.bytes() != 1 {\n+                        start_align = start_align.min(field.align().abi);\n                         break;\n                     }\n                 }\n                 size = cmp::max(size, st.size);\n                 align = align.max(st.align);\n                 Some(st)\n             })\n-            .collect::<Option<IndexVec<V, _>>>()?;\n+            .collect::<Option<IndexVec<VariantIdx, _>>>()?;\n \n         // Align the maximum variant size to the largest alignment.\n         size = size.align_to(align.abi);\n@@ -759,7 +756,7 @@ pub trait LayoutCalculator {\n                 let FieldsShape::Arbitrary { ref offsets, .. } = layout_variant.fields else {\n                     panic!();\n                 };\n-                let mut fields = iter::zip(field_layouts, offsets).filter(|p| !p.0.is_zst());\n+                let mut fields = iter::zip(field_layouts, offsets).filter(|p| !p.0.0.is_zst());\n                 let (field, offset) = match (fields.next(), fields.next()) {\n                     (None, None) => {\n                         common_prim_initialized_in_all_variants = false;\n@@ -771,7 +768,7 @@ pub trait LayoutCalculator {\n                         break;\n                     }\n                 };\n-                let prim = match field.abi {\n+                let prim = match field.abi() {\n                     Abi::Scalar(scalar) => {\n                         common_prim_initialized_in_all_variants &=\n                             matches!(scalar, Scalar::Initialized { .. });\n@@ -802,7 +799,7 @@ pub trait LayoutCalculator {\n                     // Common prim might be uninit.\n                     Scalar::Union { value: prim }\n                 };\n-                let pair = self.scalar_pair::<V>(tag, prim_scalar);\n+                let pair = self.scalar_pair(tag, prim_scalar);\n                 let pair_offsets = match pair.fields {\n                     FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                         assert_eq!(memory_index, &[0, 1]);\n@@ -862,9 +859,8 @@ pub trait LayoutCalculator {\n                 // pick the layout with the larger niche; otherwise,\n                 // pick tagged as it has simpler codegen.\n                 use cmp::Ordering::*;\n-                let niche_size = |tmp_l: &TmpLayout<V>| {\n-                    tmp_l.layout.largest_niche.map_or(0, |n| n.available(dl))\n-                };\n+                let niche_size =\n+                    |tmp_l: &TmpLayout| tmp_l.layout.largest_niche.map_or(0, |n| n.available(dl));\n                 match (tl.layout.size.cmp(&nl.layout.size), niche_size(&tl).cmp(&niche_size(&nl))) {\n                     (Greater, _) => nl,\n                     (Equal, Less) => nl,\n@@ -884,11 +880,11 @@ pub trait LayoutCalculator {\n         Some(best_layout.layout)\n     }\n \n-    fn layout_of_union<'a, V: Idx, F: Deref<Target = &'a LayoutS<V>> + Debug>(\n+    fn layout_of_union(\n         &self,\n         repr: &ReprOptions,\n-        variants: &IndexVec<V, Vec<F>>,\n-    ) -> Option<LayoutS<V>> {\n+        variants: &IndexVec<VariantIdx, Vec<Layout<'_>>>,\n+    ) -> Option<LayoutS> {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();\n         let mut align = if repr.pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n@@ -900,15 +896,15 @@ pub trait LayoutCalculator {\n         let optimize = !repr.inhibit_union_abi_opt();\n         let mut size = Size::ZERO;\n         let mut abi = Abi::Aggregate { sized: true };\n-        let index = V::new(0);\n+        let index = VariantIdx::new(0);\n         for field in &variants[index] {\n-            assert!(field.is_sized());\n-            align = align.max(field.align);\n+            assert!(field.0.is_sized());\n+            align = align.max(field.align());\n \n             // If all non-ZST fields have the same ABI, forward this ABI\n-            if optimize && !field.is_zst() {\n+            if optimize && !field.0.is_zst() {\n                 // Discard valid range information and allow undef\n-                let field_abi = match field.abi {\n+                let field_abi = match field.abi() {\n                     Abi::Scalar(x) => Abi::Scalar(x.to_union()),\n                     Abi::ScalarPair(x, y) => Abi::ScalarPair(x.to_union(), y.to_union()),\n                     Abi::Vector { element: x, count } => {\n@@ -926,7 +922,7 @@ pub trait LayoutCalculator {\n                 }\n             }\n \n-            size = cmp::max(size, field.size);\n+            size = cmp::max(size, field.size());\n         }\n \n         if let Some(pack) = repr.pack {"}, {"sha": "c88a60c62b9df7de4913c4787358b751eeaf7755", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=9800dbe88352357ca3637d74f99cc50b04f8e114", "patch": "@@ -8,6 +8,7 @@ use std::ops::{Add, AddAssign, Mul, RangeInclusive, Sub};\n use std::str::FromStr;\n \n use bitflags::bitflags;\n+use rustc_data_structures::intern::Interned;\n #[cfg(feature = \"nightly\")]\n use rustc_data_structures::stable_hasher::StableOrd;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -1250,9 +1251,9 @@ impl Abi {\n \n #[derive(PartialEq, Eq, Hash, Clone, Debug)]\n #[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n-pub enum Variants<V: Idx> {\n+pub enum Variants {\n     /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n-    Single { index: V },\n+    Single { index: VariantIdx },\n \n     /// Enum-likes with more than one inhabited variant: each variant comes with\n     /// a *discriminant* (usually the same as the variant index but the user can\n@@ -1262,15 +1263,15 @@ pub enum Variants<V: Idx> {\n     /// For enums, the tag is the sole field of the layout.\n     Multiple {\n         tag: Scalar,\n-        tag_encoding: TagEncoding<V>,\n+        tag_encoding: TagEncoding,\n         tag_field: usize,\n-        variants: IndexVec<V, LayoutS<V>>,\n+        variants: IndexVec<VariantIdx, LayoutS>,\n     },\n }\n \n #[derive(PartialEq, Eq, Hash, Clone, Debug)]\n #[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n-pub enum TagEncoding<V: Idx> {\n+pub enum TagEncoding {\n     /// The tag directly stores the discriminant, but possibly with a smaller layout\n     /// (so converting the tag to the discriminant can require sign extension).\n     Direct,\n@@ -1285,7 +1286,11 @@ pub enum TagEncoding<V: Idx> {\n     /// For example, `Option<(usize, &T)>`  is represented such that\n     /// `None` has a null pointer for the second tuple field, and\n     /// `Some` is the identity function (with a non-null reference).\n-    Niche { untagged_variant: V, niche_variants: RangeInclusive<V>, niche_start: u128 },\n+    Niche {\n+        untagged_variant: VariantIdx,\n+        niche_variants: RangeInclusive<VariantIdx>,\n+        niche_start: u128,\n+    },\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -1372,9 +1377,14 @@ impl Niche {\n     }\n }\n \n+rustc_index::newtype_index! {\n+    #[derive(HashStable_Generic)]\n+    pub struct VariantIdx {}\n+}\n+\n #[derive(PartialEq, Eq, Hash, Clone)]\n #[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n-pub struct LayoutS<V: Idx> {\n+pub struct LayoutS {\n     /// Says where the fields are located within the layout.\n     pub fields: FieldsShape,\n \n@@ -1385,7 +1395,7 @@ pub struct LayoutS<V: Idx> {\n     ///\n     /// To access all fields of this layout, both `fields` and the fields of the active variant\n     /// must be taken into account.\n-    pub variants: Variants<V>,\n+    pub variants: Variants,\n \n     /// The `abi` defines how this data is passed between functions, and it defines\n     /// value restrictions via `valid_range`.\n@@ -1404,13 +1414,13 @@ pub struct LayoutS<V: Idx> {\n     pub size: Size,\n }\n \n-impl<V: Idx> LayoutS<V> {\n+impl LayoutS {\n     pub fn scalar<C: HasDataLayout>(cx: &C, scalar: Scalar) -> Self {\n         let largest_niche = Niche::from_scalar(cx, Size::ZERO, scalar);\n         let size = scalar.size(cx);\n         let align = scalar.align(cx);\n         LayoutS {\n-            variants: Variants::Single { index: V::new(0) },\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Primitive,\n             abi: Abi::Scalar(scalar),\n             largest_niche,\n@@ -1420,7 +1430,7 @@ impl<V: Idx> LayoutS<V> {\n     }\n }\n \n-impl<V: Idx> fmt::Debug for LayoutS<V> {\n+impl fmt::Debug for LayoutS {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // This is how `Layout` used to print before it become\n         // `Interned<LayoutS>`. We print it like this to avoid having to update\n@@ -1437,6 +1447,43 @@ impl<V: Idx> fmt::Debug for LayoutS<V> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, HashStable_Generic)]\n+#[rustc_pass_by_value]\n+pub struct Layout<'a>(pub Interned<'a, LayoutS>);\n+\n+impl<'a> fmt::Debug for Layout<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // See comment on `<LayoutS as Debug>::fmt` above.\n+        self.0.0.fmt(f)\n+    }\n+}\n+\n+impl<'a> Layout<'a> {\n+    pub fn fields(self) -> &'a FieldsShape {\n+        &self.0.0.fields\n+    }\n+\n+    pub fn variants(self) -> &'a Variants {\n+        &self.0.0.variants\n+    }\n+\n+    pub fn abi(self) -> Abi {\n+        self.0.0.abi\n+    }\n+\n+    pub fn largest_niche(self) -> Option<Niche> {\n+        self.0.0.largest_niche\n+    }\n+\n+    pub fn align(self) -> AbiAndPrefAlign {\n+        self.0.0.align\n+    }\n+\n+    pub fn size(self) -> Size {\n+        self.0.0.size\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum PointerKind {\n     /// Shared reference. `frozen` indicates the absence of any `UnsafeCell`.\n@@ -1464,7 +1511,7 @@ pub enum InitKind {\n     UninitMitigated0x01Fill,\n }\n \n-impl<V: Idx> LayoutS<V> {\n+impl LayoutS {\n     /// Returns `true` if the layout corresponds to an unsized type.\n     pub fn is_unsized(&self) -> bool {\n         self.abi.is_unsized()"}, {"sha": "38a559d892a35a0c3b7f12863169ce80fc646d78", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=9800dbe88352357ca3637d74f99cc50b04f8e114", "patch": "@@ -8,7 +8,7 @@\n macro_rules! arena_types {\n     ($macro:path) => (\n         $macro!([\n-            [] layout: rustc_target::abi::LayoutS<rustc_target::abi::VariantIdx>,\n+            [] layout: rustc_target::abi::LayoutS,\n             [] fn_abi: rustc_target::abi::call::FnAbi<'tcx, rustc_middle::ty::Ty<'tcx>>,\n             // AdtDef are interned and compared by address\n             [decode] adt_def: rustc_middle::ty::AdtDefData,"}, {"sha": "4aef071cd98274ca90b1c0e38a7315981c7333ee", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=9800dbe88352357ca3637d74f99cc50b04f8e114", "patch": "@@ -149,7 +149,7 @@ pub struct CtxtInterners<'tcx> {\n     const_: InternedSet<'tcx, ConstData<'tcx>>,\n     const_allocation: InternedSet<'tcx, Allocation>,\n     bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n-    layout: InternedSet<'tcx, LayoutS<VariantIdx>>,\n+    layout: InternedSet<'tcx, LayoutS>,\n     adt_def: InternedSet<'tcx, AdtDefData>,\n     external_constraints: InternedSet<'tcx, ExternalConstraintsData<'tcx>>,\n }\n@@ -1520,7 +1520,7 @@ direct_interners! {\n     region: mk_region(RegionKind<'tcx>): Region -> Region<'tcx>,\n     const_: mk_const_internal(ConstData<'tcx>): Const -> Const<'tcx>,\n     const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n-    layout: intern_layout(LayoutS<VariantIdx>): Layout -> Layout<'tcx>,\n+    layout: intern_layout(LayoutS): Layout -> Layout<'tcx>,\n     adt_def: intern_adt_def(AdtDefData): AdtDef -> AdtDef<'tcx>,\n     external_constraints: intern_external_constraints(ExternalConstraintsData<'tcx>): ExternalConstraints -> ExternalConstraints<'tcx>,\n }"}, {"sha": "8d2e92cc76c6f2cb581cf6241475725b18a418e4", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 46, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=9800dbe88352357ca3637d74f99cc50b04f8e114", "patch": "@@ -3,10 +3,8 @@ pub use Primitive::*;\n \n use crate::json::{Json, ToJson};\n \n-use std::fmt;\n use std::ops::Deref;\n \n-use rustc_data_structures::intern::Interned;\n use rustc_macros::HashStable_Generic;\n \n pub mod call;\n@@ -19,48 +17,6 @@ impl ToJson for Endian {\n     }\n }\n \n-rustc_index::newtype_index! {\n-    #[derive(HashStable_Generic)]\n-    pub struct VariantIdx {}\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, HashStable_Generic)]\n-#[rustc_pass_by_value]\n-pub struct Layout<'a>(pub Interned<'a, LayoutS<VariantIdx>>);\n-\n-impl<'a> fmt::Debug for Layout<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // See comment on `<LayoutS as Debug>::fmt` above.\n-        self.0.0.fmt(f)\n-    }\n-}\n-\n-impl<'a> Layout<'a> {\n-    pub fn fields(self) -> &'a FieldsShape {\n-        &self.0.0.fields\n-    }\n-\n-    pub fn variants(self) -> &'a Variants<VariantIdx> {\n-        &self.0.0.variants\n-    }\n-\n-    pub fn abi(self) -> Abi {\n-        self.0.0.abi\n-    }\n-\n-    pub fn largest_niche(self) -> Option<Niche> {\n-        self.0.0.largest_niche\n-    }\n-\n-    pub fn align(self) -> AbiAndPrefAlign {\n-        self.0.0.align\n-    }\n-\n-    pub fn size(self) -> Size {\n-        self.0.0.size\n-    }\n-}\n-\n /// The layout of a type, alongside the type itself.\n /// Provides various type traversal APIs (e.g., recursing into fields).\n ///\n@@ -75,8 +31,8 @@ pub struct TyAndLayout<'a, Ty> {\n }\n \n impl<'a, Ty> Deref for TyAndLayout<'a, Ty> {\n-    type Target = &'a LayoutS<VariantIdx>;\n-    fn deref(&self) -> &&'a LayoutS<VariantIdx> {\n+    type Target = &'a LayoutS;\n+    fn deref(&self) -> &&'a LayoutS {\n         &self.layout.0.0\n     }\n }"}, {"sha": "2df4a5eab21001bc7bc2a447116b7c904201ad2e", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9800dbe88352357ca3637d74f99cc50b04f8e114/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=9800dbe88352357ca3637d74f99cc50b04f8e114", "patch": "@@ -78,10 +78,10 @@ fn invert_mapping(map: &[u32]) -> Vec<u32> {\n fn univariant_uninterned<'tcx>(\n     cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n     ty: Ty<'tcx>,\n-    fields: &[TyAndLayout<'_>],\n+    fields: &[Layout<'_>],\n     repr: &ReprOptions,\n     kind: StructKind,\n-) -> Result<LayoutS<VariantIdx>, LayoutError<'tcx>> {\n+) -> Result<LayoutS, LayoutError<'tcx>> {\n     let dl = cx.data_layout();\n     let pack = repr.pack;\n     if pack.is_some() && repr.align.is_some() {\n@@ -106,7 +106,7 @@ fn layout_of_uncached<'tcx>(\n     };\n     let scalar = |value: Primitive| tcx.intern_layout(LayoutS::scalar(cx, scalar_unit(value)));\n \n-    let univariant = |fields: &[TyAndLayout<'_>], repr: &ReprOptions, kind| {\n+    let univariant = |fields: &[Layout<'_>], repr: &ReprOptions, kind| {\n         Ok(tcx.intern_layout(univariant_uninterned(cx, ty, fields, repr, kind)?))\n     };\n     debug_assert!(!ty.has_non_region_infer());\n@@ -273,7 +273,7 @@ fn layout_of_uncached<'tcx>(\n         ty::Closure(_, ref substs) => {\n             let tys = substs.as_closure().upvar_tys();\n             univariant(\n-                &tys.map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                &tys.map(|ty| Ok(cx.layout_of(ty)?.layout)).collect::<Result<Vec<_>, _>>()?,\n                 &ReprOptions::default(),\n                 StructKind::AlwaysSized,\n             )?\n@@ -284,7 +284,7 @@ fn layout_of_uncached<'tcx>(\n                 if tys.len() == 0 { StructKind::AlwaysSized } else { StructKind::MaybeUnsized };\n \n             univariant(\n-                &tys.iter().map(|k| cx.layout_of(k)).collect::<Result<Vec<_>, _>>()?,\n+                &tys.iter().map(|k| Ok(cx.layout_of(k)?.layout)).collect::<Result<Vec<_>, _>>()?,\n                 &ReprOptions::default(),\n                 kind,\n             )?\n@@ -413,7 +413,7 @@ fn layout_of_uncached<'tcx>(\n                 .map(|v| {\n                     v.fields\n                         .iter()\n-                        .map(|field| cx.layout_of(field.ty(tcx, substs)))\n+                        .map(|field| Ok(cx.layout_of(field.ty(tcx, substs))?.layout))\n                         .collect::<Result<Vec<_>, _>>()\n                 })\n                 .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n@@ -631,23 +631,21 @@ fn generator_layout<'tcx>(\n     // `info.variant_fields` already accounts for the reserved variants, so no need to add them.\n     let max_discr = (info.variant_fields.len() - 1) as u128;\n     let discr_int = Integer::fit_unsigned(max_discr);\n-    let discr_int_ty = discr_int.to_ty(tcx, false);\n     let tag = Scalar::Initialized {\n         value: Primitive::Int(discr_int, false),\n         valid_range: WrappingRange { start: 0, end: max_discr },\n     };\n     let tag_layout = cx.tcx.intern_layout(LayoutS::scalar(cx, tag));\n-    let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout };\n \n     let promoted_layouts = ineligible_locals\n         .iter()\n         .map(|local| subst_field(info.field_tys[local].ty))\n         .map(|ty| tcx.mk_maybe_uninit(ty))\n-        .map(|ty| cx.layout_of(ty));\n+        .map(|ty| Ok(cx.layout_of(ty)?.layout));\n     let prefix_layouts = substs\n         .as_generator()\n         .prefix_tys()\n-        .map(|ty| cx.layout_of(ty))\n+        .map(|ty| Ok(cx.layout_of(ty)?.layout))\n         .chain(iter::once(Ok(tag_layout)))\n         .chain(promoted_layouts)\n         .collect::<Result<Vec<_>, _>>()?;\n@@ -716,7 +714,9 @@ fn generator_layout<'tcx>(\n             let mut variant = univariant_uninterned(\n                 cx,\n                 ty,\n-                &variant_only_tys.map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                &variant_only_tys\n+                    .map(|ty| Ok(cx.layout_of(ty)?.layout))\n+                    .collect::<Result<Vec<_>, _>>()?,\n                 &ReprOptions::default(),\n                 StructKind::Prefixed(prefix_size, prefix_align.abi),\n             )?;"}, {"sha": "4ff1c93dc5d554ca2b851619f10d281397d137c0", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9800dbe88352357ca3637d74f99cc50b04f8e114/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9800dbe88352357ca3637d74f99cc50b04f8e114/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=9800dbe88352357ca3637d74f99cc50b04f8e114", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::layout::LayoutError;\n use rustc_middle::ty::{self, Adt, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_target::abi::{LayoutS, Primitive, TagEncoding, VariantIdx, Variants};\n+use rustc_target::abi::{LayoutS, Primitive, TagEncoding, Variants};\n use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n@@ -1833,7 +1833,7 @@ fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n }\n \n fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n-    fn write_size_of_layout(w: &mut Buffer, layout: &LayoutS<VariantIdx>, tag_size: u64) {\n+    fn write_size_of_layout(w: &mut Buffer, layout: &LayoutS, tag_size: u64) {\n         if layout.abi.is_unsized() {\n             write!(w, \"(unsized)\");\n         } else {"}]}