{"sha": "0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYjI3YjFkNWI2OGQzYmMzYzcyNzg5NWU1MjE5Y2UyNTRjNjg1YWQ=", "commit": {"author": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-07-16T18:27:57Z"}, "committer": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-09-05T16:18:55Z"}, "message": "split CrateContext into shared and local pieces\n\nBreak up `CrateContext` into `SharedCrateContext` and `LocalCrateContext`.  The\nlocal piece corresponds to a single compilation unit, and contains all\nLLVM-related components.  (LLVM data structures are tied to a specific\n`LLVMContext`, and we will need separate `LLVMContext`s to safely run\nmultithreaded optimization.)  The shared piece contains data structures that\nneed to be shared across all compilation units, such as the `ty::ctxt` and some\ntables related to crate metadata.", "tree": {"sha": "b10a7dbb6388cc4ed09513de861f2e7534700ce0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b10a7dbb6388cc4ed09513de861f2e7534700ce0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "html_url": "https://github.com/rust-lang/rust/commit/0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/comments", "author": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf35cb365a4efee53f6372095aaff4798544bf94", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf35cb365a4efee53f6372095aaff4798544bf94", "html_url": "https://github.com/rust-lang/rust/commit/cf35cb365a4efee53f6372095aaff4798544bf94"}], "stats": {"total": 509, "additions": 327, "deletions": 182}, "files": [{"sha": "cb71e5983235da0ea38bf37453f4ccd8075aafd1", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "patch": "@@ -405,6 +405,7 @@ pub mod write {\n \n             llvm::LLVMRustDisposeTargetMachine(tm);\n             llvm::LLVMDisposeModule(trans.metadata_module);\n+            llvm::LLVMContextDispose(trans.metadata_context);\n             llvm::LLVMDisposeModule(llmod);\n             llvm::LLVMContextDispose(llcx);\n             if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }"}, {"sha": "5e9d8da5b4edb99990326dbeb880a8c3fafe7d25", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "patch": "@@ -444,6 +444,7 @@ pub fn phase_save_analysis(sess: &Session,\n pub struct CrateTranslation {\n     pub context: ContextRef,\n     pub module: ModuleRef,\n+    pub metadata_context: ContextRef,\n     pub metadata_module: ModuleRef,\n     pub link: LinkMeta,\n     pub metadata: Vec<u8>,"}, {"sha": "dc8dabda8343892d311b8e0a912c3e092937e1be", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "patch": "@@ -56,6 +56,7 @@ use middle::trans::common::{tydesc_info, type_is_immediate};\n use middle::trans::common::{type_is_zero_size, val_ty};\n use middle::trans::common;\n use middle::trans::consts;\n+use middle::trans::context::SharedCrateContext;\n use middle::trans::controlflow;\n use middle::trans::datum;\n use middle::trans::debuginfo;\n@@ -136,7 +137,7 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n }\n \n pub struct StatRecorder<'a> {\n-    ccx: &'a CrateContext,\n+    ccx: &'a CrateContext<'a>,\n     name: Option<String>,\n     start: u64,\n     istart: uint,\n@@ -2114,7 +2115,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n }\n \n pub struct TransItemVisitor<'a> {\n-    pub ccx: &'a CrateContext,\n+    pub ccx: &'a CrateContext<'a>,\n }\n \n impl<'a> Visitor<()> for TransItemVisitor<'a> {\n@@ -2895,80 +2896,81 @@ pub fn trans_crate(krate: ast::Crate,\n \n     let link_meta = link::build_link_meta(&tcx.sess, &krate, name);\n \n-    // Append \".rs\" to crate name as LLVM module identifier.\n-    //\n-    // LLVM code generator emits a \".file filename\" directive\n-    // for ELF backends. Value of the \"filename\" is set as the\n-    // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n-    // crashes if the module identifier is same as other symbols\n-    // such as a function name in the module.\n-    // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-    let mut llmod_id = link_meta.crate_name.clone();\n-    llmod_id.push_str(\".rs\");\n+    // Multiple compilation units won't be supported until a later commit.\n+    let codegen_units = 1;\n+    let shared_ccx = SharedCrateContext::new(link_meta.crate_name.as_slice(),\n+                                             codegen_units,\n+                                             tcx,\n+                                             exp_map2,\n+                                             Sha256::new(),\n+                                             link_meta.clone(),\n+                                             reachable);\n \n-    let ccx = CrateContext::new(llmod_id.as_slice(), tcx, exp_map2,\n-                                Sha256::new(), link_meta, reachable);\n+    let metadata = {\n+        let ccx = shared_ccx.get_ccx(0);\n \n-    // First, verify intrinsics.\n-    intrinsic::check_intrinsics(&ccx);\n+        // First, verify intrinsics.\n+        intrinsic::check_intrinsics(&ccx);\n \n-    // Next, translate the module.\n-    {\n-        let _icx = push_ctxt(\"text\");\n-        trans_mod(&ccx, &krate.module);\n-    }\n+        // Next, translate the module.\n+        {\n+            let _icx = push_ctxt(\"text\");\n+            trans_mod(&ccx, &krate.module);\n+        }\n \n-    glue::emit_tydescs(&ccx);\n-    if ccx.sess().opts.debuginfo != NoDebugInfo {\n-        debuginfo::finalize(&ccx);\n-    }\n+        glue::emit_tydescs(&ccx);\n+        if ccx.sess().opts.debuginfo != NoDebugInfo {\n+            debuginfo::finalize(&ccx);\n+        }\n+\n+        // Translate the metadata.\n+        write_metadata(&ccx, &krate)\n+    };\n \n-    // Translate the metadata.\n-    let metadata = write_metadata(&ccx, &krate);\n-    if ccx.sess().trans_stats() {\n+    if shared_ccx.sess().trans_stats() {\n+        let stats = shared_ccx.stats();\n         println!(\"--- trans stats ---\");\n-        println!(\"n_static_tydescs: {}\", ccx.stats().n_static_tydescs.get());\n-        println!(\"n_glues_created: {}\", ccx.stats().n_glues_created.get());\n-        println!(\"n_null_glues: {}\", ccx.stats().n_null_glues.get());\n-        println!(\"n_real_glues: {}\", ccx.stats().n_real_glues.get());\n-\n-        println!(\"n_fns: {}\", ccx.stats().n_fns.get());\n-        println!(\"n_monos: {}\", ccx.stats().n_monos.get());\n-        println!(\"n_inlines: {}\", ccx.stats().n_inlines.get());\n-        println!(\"n_closures: {}\", ccx.stats().n_closures.get());\n+        println!(\"n_static_tydescs: {}\", stats.n_static_tydescs.get());\n+        println!(\"n_glues_created: {}\", stats.n_glues_created.get());\n+        println!(\"n_null_glues: {}\", stats.n_null_glues.get());\n+        println!(\"n_real_glues: {}\", stats.n_real_glues.get());\n+\n+        println!(\"n_fns: {}\", stats.n_fns.get());\n+        println!(\"n_monos: {}\", stats.n_monos.get());\n+        println!(\"n_inlines: {}\", stats.n_inlines.get());\n+        println!(\"n_closures: {}\", stats.n_closures.get());\n         println!(\"fn stats:\");\n-        ccx.stats().fn_stats.borrow_mut().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n+        stats.fn_stats.borrow_mut().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n             insns_b.cmp(&insns_a)\n         });\n-        for tuple in ccx.stats().fn_stats.borrow().iter() {\n+        for tuple in stats.fn_stats.borrow().iter() {\n             match *tuple {\n                 (ref name, ms, insns) => {\n                     println!(\"{} insns, {} ms, {}\", insns, ms, *name);\n                 }\n             }\n         }\n     }\n-    if ccx.sess().count_llvm_insns() {\n-        for (k, v) in ccx.stats().llvm_insns.borrow().iter() {\n+    if shared_ccx.sess().count_llvm_insns() {\n+        for (k, v) in shared_ccx.stats().llvm_insns.borrow().iter() {\n             println!(\"{:7u} {}\", *v, *k);\n         }\n     }\n \n-    let llcx = ccx.llcx();\n-    let link_meta = ccx.link_meta().clone();\n-    let llmod = ccx.llmod();\n+    let llcx = shared_ccx.get_ccx(0).llcx();\n+    let llmod = shared_ccx.get_ccx(0).llmod();\n \n-    let mut reachable: Vec<String> = ccx.reachable().iter().filter_map(|id| {\n-        ccx.item_symbols().borrow().find(id).map(|s| s.to_string())\n+    let mut reachable: Vec<String> = shared_ccx.reachable().iter().filter_map(|id| {\n+        shared_ccx.item_symbols().borrow().find(id).map(|s| s.to_string())\n     }).collect();\n \n     // For the purposes of LTO, we add to the reachable set all of the upstream\n     // reachable extern fns. These functions are all part of the public ABI of\n     // the final product, so LTO needs to preserve them.\n-    ccx.sess().cstore.iter_crate_data(|cnum, _| {\n-        let syms = csearch::get_reachable_extern_fns(&ccx.sess().cstore, cnum);\n+    shared_ccx.sess().cstore.iter_crate_data(|cnum, _| {\n+        let syms = csearch::get_reachable_extern_fns(&shared_ccx.sess().cstore, cnum);\n         reachable.extend(syms.move_iter().map(|did| {\n-            csearch::get_symbol(&ccx.sess().cstore, did)\n+            csearch::get_symbol(&shared_ccx.sess().cstore, did)\n         }));\n     });\n \n@@ -2986,15 +2988,17 @@ pub fn trans_crate(krate: ast::Crate,\n     // referenced from rt/rust_try.ll\n     reachable.push(\"rust_eh_personality_catch\".to_string());\n \n-    let metadata_module = ccx.metadata_llmod();\n-    let formats = ccx.tcx().dependency_formats.borrow().clone();\n+    let metadata_module = shared_ccx.metadata_llmod();\n+    let metadata_context = shared_ccx.metadata_llcx();\n+    let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n     let no_builtins = attr::contains_name(krate.attrs.as_slice(), \"no_builtins\");\n \n-    (ccx.take_tcx(), CrateTranslation {\n+    (shared_ccx.take_tcx(), CrateTranslation {\n         context: llcx,\n         module: llmod,\n         link: link_meta,\n         metadata_module: metadata_module,\n+        metadata_context: metadata_context,\n         metadata: metadata,\n         reachable: reachable,\n         crate_formats: formats,"}, {"sha": "61a79f4a8eeba54175f8a8f6a2faa1fdd5429cbf", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "patch": "@@ -25,7 +25,7 @@ use syntax::codemap::Span;\n \n pub struct Builder<'a> {\n     pub llbuilder: BuilderRef,\n-    pub ccx: &'a CrateContext,\n+    pub ccx: &'a CrateContext<'a>,\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a"}, {"sha": "dbd3de2a9986a77ea0dcc0fe803df8278a90ed41", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "patch": "@@ -297,7 +297,7 @@ pub struct FunctionContext<'a> {\n     pub block_arena: &'a TypedArena<Block<'a>>,\n \n     // This function's enclosing crate context.\n-    pub ccx: &'a CrateContext,\n+    pub ccx: &'a CrateContext<'a>,\n \n     // Used and maintained by the debuginfo module.\n     pub debug_context: debuginfo::FunctionDebugContext,\n@@ -449,7 +449,7 @@ impl<'a> Block<'a> {\n         })\n     }\n \n-    pub fn ccx(&self) -> &'a CrateContext { self.fcx.ccx }\n+    pub fn ccx(&self) -> &'a CrateContext<'a> { self.fcx.ccx }\n     pub fn tcx(&self) -> &'a ty::ctxt {\n         self.fcx.ccx.tcx()\n     }"}, {"sha": "130e382e4e8978fe94b597c900ad4f7b3d7b3799", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 266, "deletions": 127, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab27b1d5b68d3bc3c727895e5219ce254c685ad/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "patch": "@@ -51,18 +51,40 @@ pub struct Stats {\n     pub fn_stats: RefCell<Vec<(String, uint, uint)> >,\n }\n \n-pub struct CrateContext {\n+/// The shared portion of a `CrateContext`.  There is one `SharedCrateContext`\n+/// per crate.  The data here is shared between all compilation units of the\n+/// crate, so it must not contain references to any LLVM data structures\n+/// (aside from metadata-related ones).\n+pub struct SharedCrateContext {\n+    local_ccxs: Vec<LocalCrateContext>,\n+\n+    metadata_llmod: ModuleRef,\n+    metadata_llcx: ContextRef,\n+\n+    exp_map2: resolve::ExportMap2,\n+    reachable: NodeSet,\n+    item_symbols: RefCell<NodeMap<String>>,\n+    link_meta: LinkMeta,\n+    /// A set of static items which cannot be inlined into other crates. This\n+    /// will prevent in IIItem() structures from being encoded into the metadata\n+    /// that is generated\n+    non_inlineable_statics: RefCell<NodeSet>,\n+    symbol_hasher: RefCell<Sha256>,\n+    tcx: ty::ctxt,\n+    stats: Stats,\n+}\n+\n+/// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n+/// per compilation unit.  Each one has its own LLVM `ContextRef` so that\n+/// several compilation units may be optimized in parallel.  All other LLVM\n+/// data structures in the `LocalCrateContext` are tied to that `ContextRef`.\n+pub struct LocalCrateContext {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n-    metadata_llmod: ModuleRef,\n     td: TargetData,\n     tn: TypeNames,\n     externs: RefCell<ExternMap>,\n     item_vals: RefCell<NodeMap<ValueRef>>,\n-    exp_map2: resolve::ExportMap2,\n-    reachable: NodeSet,\n-    item_symbols: RefCell<NodeMap<String>>,\n-    link_meta: LinkMeta,\n     drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n     tydescs: RefCell<HashMap<ty::t, Rc<tydesc_info>>>,\n     /// Set when running emit_tydescs to enforce that no more tydescs are\n@@ -73,10 +95,6 @@ pub struct CrateContext {\n     /// Backwards version of the `external` map (inlined items to where they\n     /// came from)\n     external_srcs: RefCell<NodeMap<ast::DefId>>,\n-    /// A set of static items which cannot be inlined into other crates. This\n-    /// will prevent in IIItem() structures from being encoded into the metadata\n-    /// that is generated\n-    non_inlineable_statics: RefCell<NodeSet>,\n     /// Cache instances of monomorphized functions\n     monomorphized: RefCell<HashMap<MonoId, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n@@ -109,11 +127,8 @@ pub struct CrateContext {\n     lltypes: RefCell<HashMap<ty::t, Type>>,\n     llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n     adt_reprs: RefCell<HashMap<ty::t, Rc<adt::Repr>>>,\n-    symbol_hasher: RefCell<Sha256>,\n     type_hashcodes: RefCell<HashMap<ty::t, String>>,\n     all_llvm_symbols: RefCell<HashSet<String>>,\n-    tcx: ty::ctxt,\n-    stats: Stats,\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n@@ -128,71 +143,178 @@ pub struct CrateContext {\n     intrinsics: RefCell<HashMap<&'static str, ValueRef>>,\n }\n \n-impl CrateContext {\n-    pub fn new(name: &str,\n+pub struct CrateContext<'a> {\n+    shared: &'a SharedCrateContext,\n+    local: &'a LocalCrateContext,\n+}\n+\n+unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n+    let llcx = llvm::LLVMContextCreate();\n+    let llmod = mod_name.with_c_str(|buf| {\n+        llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n+    });\n+    sess.targ_cfg\n+        .target_strs\n+        .data_layout\n+        .as_slice()\n+        .with_c_str(|buf| {\n+        llvm::LLVMSetDataLayout(llmod, buf);\n+    });\n+    sess.targ_cfg\n+        .target_strs\n+        .target_triple\n+        .as_slice()\n+        .with_c_str(|buf| {\n+        llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n+    });\n+    (llcx, llmod)\n+}\n+\n+impl SharedCrateContext {\n+    pub fn new(crate_name: &str,\n+               local_count: uint,\n                tcx: ty::ctxt,\n                emap2: resolve::ExportMap2,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet)\n-               -> CrateContext {\n+               -> SharedCrateContext {\n+        let (metadata_llcx, metadata_llmod) = unsafe {\n+            create_context_and_module(&tcx.sess, \"metadata\")\n+        };\n+\n+        let mut shared_ccx = SharedCrateContext {\n+            local_ccxs: Vec::with_capacity(local_count),\n+            metadata_llmod: metadata_llmod,\n+            metadata_llcx: metadata_llcx,\n+            exp_map2: emap2,\n+            reachable: reachable,\n+            item_symbols: RefCell::new(NodeMap::new()),\n+            link_meta: link_meta,\n+            non_inlineable_statics: RefCell::new(NodeSet::new()),\n+            symbol_hasher: RefCell::new(symbol_hasher),\n+            tcx: tcx,\n+            stats: Stats {\n+                n_static_tydescs: Cell::new(0u),\n+                n_glues_created: Cell::new(0u),\n+                n_null_glues: Cell::new(0u),\n+                n_real_glues: Cell::new(0u),\n+                n_fns: Cell::new(0u),\n+                n_monos: Cell::new(0u),\n+                n_inlines: Cell::new(0u),\n+                n_closures: Cell::new(0u),\n+                n_llvm_insns: Cell::new(0u),\n+                llvm_insns: RefCell::new(HashMap::new()),\n+                fn_stats: RefCell::new(Vec::new()),\n+            },\n+        };\n+\n+        for i in range(0, local_count) {\n+            // Append \".rs\" to crate name as LLVM module identifier.\n+            //\n+            // LLVM code generator emits a \".file filename\" directive\n+            // for ELF backends. Value of the \"filename\" is set as the\n+            // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n+            // crashes if the module identifier is same as other symbols\n+            // such as a function name in the module.\n+            // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n+            let llmod_id = format!(\"{}.{}.rs\", crate_name, i);\n+            let local_ccx = LocalCrateContext::new(&shared_ccx, llmod_id.as_slice());\n+            shared_ccx.local_ccxs.push(local_ccx);\n+        }\n+\n+        shared_ccx\n+    }\n+\n+    pub fn get_ccx<'a>(&'a self, index: uint) -> CrateContext<'a> {\n+        CrateContext {\n+            shared: self,\n+            local: &self.local_ccxs[index],\n+        }\n+    }\n+\n+\n+    pub fn metadata_llmod(&self) -> ModuleRef {\n+        self.metadata_llmod\n+    }\n+\n+    pub fn metadata_llcx(&self) -> ContextRef {\n+        self.metadata_llcx\n+    }\n+\n+    pub fn exp_map2<'a>(&'a self) -> &'a resolve::ExportMap2 {\n+        &self.exp_map2\n+    }\n+\n+    pub fn reachable<'a>(&'a self) -> &'a NodeSet {\n+        &self.reachable\n+    }\n+\n+    pub fn item_symbols<'a>(&'a self) -> &'a RefCell<NodeMap<String>> {\n+        &self.item_symbols\n+    }\n+\n+    pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n+        &self.link_meta\n+    }\n+\n+    pub fn non_inlineable_statics<'a>(&'a self) -> &'a RefCell<NodeSet> {\n+        &self.non_inlineable_statics\n+    }\n+\n+    pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n+        &self.symbol_hasher\n+    }\n+\n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        &self.tcx\n+    }\n+\n+    pub fn take_tcx(self) -> ty::ctxt {\n+        self.tcx\n+    }\n+\n+    pub fn sess<'a>(&'a self) -> &'a Session {\n+        &self.tcx.sess\n+    }\n+\n+    pub fn stats<'a>(&'a self) -> &'a Stats {\n+        &self.stats\n+    }\n+}\n+\n+impl LocalCrateContext {\n+    fn new(shared: &SharedCrateContext,\n+           name: &str)\n+           -> LocalCrateContext {\n         unsafe {\n-            let llcx = llvm::LLVMContextCreate();\n-            let llmod = name.with_c_str(|buf| {\n-                llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n-            });\n-            let metadata_llmod = format!(\"{}_metadata\", name).with_c_str(|buf| {\n-                llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n-            });\n-            tcx.sess\n-               .targ_cfg\n-               .target_strs\n-               .data_layout\n-               .as_slice()\n-               .with_c_str(|buf| {\n-                llvm::LLVMSetDataLayout(llmod, buf);\n-                llvm::LLVMSetDataLayout(metadata_llmod, buf);\n-            });\n-            tcx.sess\n-               .targ_cfg\n-               .target_strs\n-               .target_triple\n-               .as_slice()\n-               .with_c_str(|buf| {\n-                llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n-                llvm::LLVMRustSetNormalizedTarget(metadata_llmod, buf);\n-            });\n-\n-            let td = mk_target_data(tcx.sess\n-                                       .targ_cfg\n-                                       .target_strs\n-                                       .data_layout\n-                                       .as_slice());\n-\n-            let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n+            let (llcx, llmod) = create_context_and_module(&shared.tcx.sess, name);\n+\n+            let td = mk_target_data(shared.tcx\n+                                          .sess\n+                                          .targ_cfg\n+                                          .target_strs\n+                                          .data_layout\n+                                          .as_slice());\n+\n+            let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n             } else {\n                 None\n             };\n \n-            let mut ccx = CrateContext {\n+            let mut local_ccx = LocalCrateContext {\n                 llmod: llmod,\n                 llcx: llcx,\n-                metadata_llmod: metadata_llmod,\n                 td: td,\n                 tn: TypeNames::new(),\n                 externs: RefCell::new(HashMap::new()),\n                 item_vals: RefCell::new(NodeMap::new()),\n-                exp_map2: emap2,\n-                reachable: reachable,\n-                item_symbols: RefCell::new(NodeMap::new()),\n-                link_meta: link_meta,\n                 drop_glues: RefCell::new(HashMap::new()),\n                 tydescs: RefCell::new(HashMap::new()),\n                 finished_tydescs: Cell::new(false),\n                 external: RefCell::new(DefIdMap::new()),\n                 external_srcs: RefCell::new(NodeMap::new()),\n-                non_inlineable_statics: RefCell::new(NodeSet::new()),\n                 monomorphized: RefCell::new(HashMap::new()),\n                 monomorphizing: RefCell::new(DefIdMap::new()),\n                 vtables: RefCell::new(HashMap::new()),\n@@ -205,23 +327,8 @@ impl CrateContext {\n                 lltypes: RefCell::new(HashMap::new()),\n                 llsizingtypes: RefCell::new(HashMap::new()),\n                 adt_reprs: RefCell::new(HashMap::new()),\n-                symbol_hasher: RefCell::new(symbol_hasher),\n                 type_hashcodes: RefCell::new(HashMap::new()),\n                 all_llvm_symbols: RefCell::new(HashSet::new()),\n-                tcx: tcx,\n-                stats: Stats {\n-                    n_static_tydescs: Cell::new(0u),\n-                    n_glues_created: Cell::new(0u),\n-                    n_null_glues: Cell::new(0u),\n-                    n_real_glues: Cell::new(0u),\n-                    n_fns: Cell::new(0u),\n-                    n_monos: Cell::new(0u),\n-                    n_inlines: Cell::new(0u),\n-                    n_closures: Cell::new(0u),\n-                    n_llvm_insns: Cell::new(0u),\n-                    llvm_insns: RefCell::new(HashMap::new()),\n-                    fn_stats: RefCell::new(Vec::new()),\n-                },\n                 int_type: Type::from_ref(ptr::mut_null()),\n                 opaque_vec_type: Type::from_ref(ptr::mut_null()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n@@ -231,49 +338,77 @@ impl CrateContext {\n                 intrinsics: RefCell::new(HashMap::new()),\n             };\n \n-            ccx.int_type = Type::int(&ccx);\n-            ccx.opaque_vec_type = Type::opaque_vec(&ccx);\n+            local_ccx.int_type = Type::int(&local_ccx.dummy_ccx(shared));\n+            local_ccx.opaque_vec_type = Type::opaque_vec(&local_ccx.dummy_ccx(shared));\n+\n+            // Done mutating local_ccx directly.  (The rest of the\n+            // initialization goes through RefCell.)\n+            {\n+                let ccx = local_ccx.dummy_ccx(shared);\n \n-            let mut str_slice_ty = Type::named_struct(&ccx, \"str_slice\");\n-            str_slice_ty.set_struct_body([Type::i8p(&ccx), ccx.int_type()], false);\n-            ccx.tn().associate_type(\"str_slice\", &str_slice_ty);\n+                let mut str_slice_ty = Type::named_struct(&ccx, \"str_slice\");\n+                str_slice_ty.set_struct_body([Type::i8p(&ccx), ccx.int_type()], false);\n+                ccx.tn().associate_type(\"str_slice\", &str_slice_ty);\n \n-            ccx.tn().associate_type(\"tydesc\", &Type::tydesc(&ccx, str_slice_ty));\n+                ccx.tn().associate_type(\"tydesc\", &Type::tydesc(&ccx, str_slice_ty));\n \n-            if ccx.sess().count_llvm_insns() {\n-                base::init_insn_ctxt()\n+                if ccx.sess().count_llvm_insns() {\n+                    base::init_insn_ctxt()\n+                }\n             }\n \n-            ccx\n+            local_ccx\n         }\n     }\n \n-    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n-        &self.tcx\n+    /// Create a dummy `CrateContext` from `self` and  the provided\n+    /// `SharedCrateContext`.  This is somewhat dangerous because `self` may\n+    /// not actually be an element of `shared.local_ccxs`, which can cause some\n+    /// operations to `fail` unexpectedly.\n+    ///\n+    /// This is used in the `LocalCrateContext` constructor to allow calling\n+    /// functions that expect a complete `CrateContext`, even before the local\n+    /// portion is fully initialized and attached to the `SharedCrateContext`.\n+    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext) -> CrateContext<'a> {\n+        CrateContext {\n+            shared: shared,\n+            local: self,\n+        }\n     }\n+}\n \n-    pub fn take_tcx(self) -> ty::ctxt {\n-        self.tcx\n+impl<'b> CrateContext<'b> {\n+    pub fn shared(&self) -> &'b SharedCrateContext {\n+        self.shared\n+    }\n+\n+    pub fn local(&self) -> &'b LocalCrateContext {\n+        self.local\n+    }\n+\n+\n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        &self.shared.tcx\n     }\n \n     pub fn sess<'a>(&'a self) -> &'a Session {\n-        &self.tcx.sess\n+        &self.shared.tcx.sess\n     }\n \n     pub fn builder<'a>(&'a self) -> Builder<'a> {\n         Builder::new(self)\n     }\n \n     pub fn raw_builder<'a>(&'a self) -> BuilderRef {\n-        self.builder.b\n+        self.local.builder.b\n     }\n \n     pub fn tydesc_type(&self) -> Type {\n-        self.tn.find_type(\"tydesc\").unwrap()\n+        self.local.tn.find_type(\"tydesc\").unwrap()\n     }\n \n     pub fn get_intrinsic(&self, key: & &'static str) -> ValueRef {\n-        match self.intrinsics.borrow().find_copy(key) {\n+        match self.intrinsics().borrow().find_copy(key) {\n             Some(v) => return v,\n             _ => {}\n         }\n@@ -297,160 +432,164 @@ impl CrateContext {\n \n \n     pub fn llmod(&self) -> ModuleRef {\n-        self.llmod\n+        self.local.llmod\n     }\n \n     pub fn llcx(&self) -> ContextRef {\n-        self.llcx\n+        self.local.llcx\n     }\n \n     pub fn metadata_llmod(&self) -> ModuleRef {\n-        self.metadata_llmod\n+        self.shared.metadata_llmod\n+    }\n+\n+    pub fn metadata_llcx(&self) -> ContextRef {\n+        self.shared.metadata_llcx\n     }\n \n     pub fn td<'a>(&'a self) -> &'a TargetData {\n-        &self.td\n+        &self.local.td\n     }\n \n     pub fn tn<'a>(&'a self) -> &'a TypeNames {\n-        &self.tn\n+        &self.local.tn\n     }\n \n     pub fn externs<'a>(&'a self) -> &'a RefCell<ExternMap> {\n-        &self.externs\n+        &self.local.externs\n     }\n \n     pub fn item_vals<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n-        &self.item_vals\n+        &self.local.item_vals\n     }\n \n     pub fn exp_map2<'a>(&'a self) -> &'a resolve::ExportMap2 {\n-        &self.exp_map2\n+        &self.shared.exp_map2\n     }\n \n     pub fn reachable<'a>(&'a self) -> &'a NodeSet {\n-        &self.reachable\n+        &self.shared.reachable\n     }\n \n     pub fn item_symbols<'a>(&'a self) -> &'a RefCell<NodeMap<String>> {\n-        &self.item_symbols\n+        &self.shared.item_symbols\n     }\n \n     pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n-        &self.link_meta\n+        &self.shared.link_meta\n     }\n \n     pub fn drop_glues<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, ValueRef>> {\n-        &self.drop_glues\n+        &self.local.drop_glues\n     }\n \n     pub fn tydescs<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Rc<tydesc_info>>> {\n-        &self.tydescs\n+        &self.local.tydescs\n     }\n \n     pub fn finished_tydescs<'a>(&'a self) -> &'a Cell<bool> {\n-        &self.finished_tydescs\n+        &self.local.finished_tydescs\n     }\n \n     pub fn external<'a>(&'a self) -> &'a RefCell<DefIdMap<Option<ast::NodeId>>> {\n-        &self.external\n+        &self.local.external\n     }\n \n     pub fn external_srcs<'a>(&'a self) -> &'a RefCell<NodeMap<ast::DefId>> {\n-        &self.external_srcs\n+        &self.local.external_srcs\n     }\n \n     pub fn non_inlineable_statics<'a>(&'a self) -> &'a RefCell<NodeSet> {\n-        &self.non_inlineable_statics\n+        &self.shared.non_inlineable_statics\n     }\n \n     pub fn monomorphized<'a>(&'a self) -> &'a RefCell<HashMap<MonoId, ValueRef>> {\n-        &self.monomorphized\n+        &self.local.monomorphized\n     }\n \n     pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<uint>> {\n-        &self.monomorphizing\n+        &self.local.monomorphizing\n     }\n \n     pub fn vtables<'a>(&'a self) -> &'a RefCell<HashMap<(ty::t, MonoId), ValueRef>> {\n-        &self.vtables\n+        &self.local.vtables\n     }\n \n     pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<HashMap<InternedString, ValueRef>> {\n-        &self.const_cstr_cache\n+        &self.local.const_cstr_cache\n     }\n \n     pub fn const_globals<'a>(&'a self) -> &'a RefCell<HashMap<int, ValueRef>> {\n-        &self.const_globals\n+        &self.local.const_globals\n     }\n \n     pub fn const_values<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n-        &self.const_values\n+        &self.local.const_values\n     }\n \n     pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n-        &self.extern_const_values\n+        &self.local.extern_const_values\n     }\n \n     pub fn impl_method_cache<'a>(&'a self)\n             -> &'a RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>> {\n-        &self.impl_method_cache\n+        &self.local.impl_method_cache\n     }\n \n     pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<HashMap<ValueRef, ValueRef>> {\n-        &self.closure_bare_wrapper_cache\n+        &self.local.closure_bare_wrapper_cache\n     }\n \n     pub fn lltypes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Type>> {\n-        &self.lltypes\n+        &self.local.lltypes\n     }\n \n     pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Type>> {\n-        &self.llsizingtypes\n+        &self.local.llsizingtypes\n     }\n \n     pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Rc<adt::Repr>>> {\n-        &self.adt_reprs\n+        &self.local.adt_reprs\n     }\n \n     pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n-        &self.symbol_hasher\n+        &self.shared.symbol_hasher\n     }\n \n     pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, String>> {\n-        &self.type_hashcodes\n+        &self.local.type_hashcodes\n     }\n \n     pub fn all_llvm_symbols<'a>(&'a self) -> &'a RefCell<HashSet<String>> {\n-        &self.all_llvm_symbols\n+        &self.local.all_llvm_symbols\n     }\n \n     pub fn stats<'a>(&'a self) -> &'a Stats {\n-        &self.stats\n+        &self.shared.stats\n     }\n \n     pub fn int_type(&self) -> Type {\n-        self.int_type\n+        self.local.int_type\n     }\n \n     pub fn opaque_vec_type(&self) -> Type {\n-        self.opaque_vec_type\n+        self.local.opaque_vec_type\n     }\n \n     pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n-        &self.unboxed_closure_vals\n+        &self.local.unboxed_closure_vals\n     }\n \n     pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext> {\n-        &self.dbg_cx\n+        &self.local.dbg_cx\n     }\n \n     pub fn eh_personality<'a>(&'a self) -> &'a RefCell<Option<ValueRef>> {\n-        &self.eh_personality\n+        &self.local.eh_personality\n     }\n \n     fn intrinsics<'a>(&'a self) -> &'a RefCell<HashMap<&'static str, ValueRef>> {\n-        &self.intrinsics\n+        &self.local.intrinsics\n     }\n }\n "}]}