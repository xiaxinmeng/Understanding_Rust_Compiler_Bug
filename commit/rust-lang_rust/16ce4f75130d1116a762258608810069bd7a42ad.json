{"sha": "16ce4f75130d1116a762258608810069bd7a42ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2Y2U0Zjc1MTMwZDExMTZhNzYyMjU4NjA4ODEwMDY5YmQ3YTQyYWQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2021-03-11T23:55:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-11T23:55:15Z"}, "message": "Rollup merge of #82950 - mockersf:slice-intra-doc-link, r=jyn514\n\nconvert slice doc link to intra-doc links\n\nContinuing where #80189 stopped, with `core::slice`.\n\nI had an issue with two dead links in my doc when implementing `Deref<Target = [T]>` for one of my type. This means that [`binary_search_by_key`](https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.binary_search_by_key) was available, but not [`sort_by_key`](https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.sort_by_key) even though it was linked in it's doc (same issue with [`as_ptr`](https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.as_ptr) and [`as_mut_pbr`](https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.as_mut_ptr)). It becomes available if I implement `DerefMut`, as it needs an `&mut self`.\n\n<details>\n  <summary>Code that will have dead links in its doc</summary>\n\n```rust\npub struct A;\npub struct B;\n\nimpl std::ops::Deref for B{\n    type Target = [A];\n\n    fn deref(&self) -> &Self::Target {\n        &A\n    }\n}\n```\n</details>\n\nI removed the link to `sort_by_key` from `binary_search_by_key` doc as I didn't find a nice way to have a live link:\n- `binary_search_by_key` is in `core`\n- `sort_by_key` is in `alloc`\n- intra-doc link `slice::sort_by_key` doesn't work, as `alloc` is not available when `core` is being build (the warning can't be ignored: ```error[E0710]: an unknown tool name found in scoped lint: `rustdoc::broken_intra_doc_links` ```)\n- keeping the link as an anchor `#method.sort_by_key` meant a dead link\n- an absolute link would work but doesn't feel right...", "tree": {"sha": "8138d8c50f0395a1e80d65eaa1dd478b420e9df0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8138d8c50f0395a1e80d65eaa1dd478b420e9df0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16ce4f75130d1116a762258608810069bd7a42ad", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgSq3kCRBK7hj4Ov3rIwAAdHIIAESFZUMQrh/jpGCJFrDmJ7Z0\nA13DOwPPJsYNKpnkJ06tksjBdxkBiRrJesihc7D/Rj4UTocN6lAxXzKRsdFupKKl\nfESZnHS1WmYLheDQd2AFHO6G1meAtvFrEFO4+WACEYKuUO6NODWaE1wosp56HSiK\nSDUQ51EhUM4FSy2nHGMwuMJrc42GtUUmcKMHu6MGqGuihHj+xAUhhq/VDZBNQ0Ie\nGGQehUkFBbA1wsu0m3J/URz6X7iyJhNNYK1Trxso+JYLwcUyuLCa/7e4lpJ+vnfY\n/jbw2JbE9/LDrvBhEs5QnrPBiA9WlEBXys8EA5vGL9iQjbHQsdEHtuHEenIFBJo=\n=LNaW\n-----END PGP SIGNATURE-----\n", "payload": "tree 8138d8c50f0395a1e80d65eaa1dd478b420e9df0\nparent f183a3ec13fdd2c7b78683bd7a8d3019dcb9a057\nparent 232b9f1641097763ef40fedccf442f2119958608\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1615506915 +0900\ncommitter GitHub <noreply@github.com> 1615506915 +0900\n\nRollup merge of #82950 - mockersf:slice-intra-doc-link, r=jyn514\n\nconvert slice doc link to intra-doc links\n\nContinuing where #80189 stopped, with `core::slice`.\n\nI had an issue with two dead links in my doc when implementing `Deref<Target = [T]>` for one of my type. This means that [`binary_search_by_key`](https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.binary_search_by_key) was available, but not [`sort_by_key`](https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.sort_by_key) even though it was linked in it's doc (same issue with [`as_ptr`](https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.as_ptr) and [`as_mut_pbr`](https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.as_mut_ptr)). It becomes available if I implement `DerefMut`, as it needs an `&mut self`.\n\n<details>\n  <summary>Code that will have dead links in its doc</summary>\n\n```rust\npub struct A;\npub struct B;\n\nimpl std::ops::Deref for B{\n    type Target = [A];\n\n    fn deref(&self) -> &Self::Target {\n        &A\n    }\n}\n```\n</details>\n\nI removed the link to `sort_by_key` from `binary_search_by_key` doc as I didn't find a nice way to have a live link:\n- `binary_search_by_key` is in `core`\n- `sort_by_key` is in `alloc`\n- intra-doc link `slice::sort_by_key` doesn't work, as `alloc` is not available when `core` is being build (the warning can't be ignored: ```error[E0710]: an unknown tool name found in scoped lint: `rustdoc::broken_intra_doc_links` ```)\n- keeping the link as an anchor `#method.sort_by_key` meant a dead link\n- an absolute link would work but doesn't feel right...\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16ce4f75130d1116a762258608810069bd7a42ad", "html_url": "https://github.com/rust-lang/rust/commit/16ce4f75130d1116a762258608810069bd7a42ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16ce4f75130d1116a762258608810069bd7a42ad/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f183a3ec13fdd2c7b78683bd7a8d3019dcb9a057", "url": "https://api.github.com/repos/rust-lang/rust/commits/f183a3ec13fdd2c7b78683bd7a8d3019dcb9a057", "html_url": "https://github.com/rust-lang/rust/commit/f183a3ec13fdd2c7b78683bd7a8d3019dcb9a057"}, {"sha": "232b9f1641097763ef40fedccf442f2119958608", "url": "https://api.github.com/repos/rust-lang/rust/commits/232b9f1641097763ef40fedccf442f2119958608", "html_url": "https://github.com/rust-lang/rust/commit/232b9f1641097763ef40fedccf442f2119958608"}], "stats": {"total": 127, "additions": 64, "deletions": 63}, "files": [{"sha": "8cd4ef7a14e8153f9ed712e0b6a8759cd1e96435", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16ce4f75130d1116a762258608810069bd7a42ad/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ce4f75130d1116a762258608810069bd7a42ad/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=16ce4f75130d1116a762258608810069bd7a42ad", "patch": "@@ -231,7 +231,7 @@ impl<T> [T] {\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n-    /// See [`sort_unstable`](#method.sort_unstable).\n+    /// See [`sort_unstable`](slice::sort_unstable).\n     ///\n     /// # Current implementation\n     ///\n@@ -282,7 +282,7 @@ impl<T> [T] {\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n-    /// See [`sort_unstable_by`](#method.sort_unstable_by).\n+    /// See [`sort_unstable_by`](slice::sort_unstable_by).\n     ///\n     /// # Current implementation\n     ///\n@@ -320,12 +320,12 @@ impl<T> [T] {\n     /// worst-case, where the key function is *O*(*m*).\n     ///\n     /// For expensive key functions (e.g. functions that are not simple property accesses or\n-    /// basic operations), [`sort_by_cached_key`](#method.sort_by_cached_key) is likely to be\n+    /// basic operations), [`sort_by_cached_key`](slice::sort_by_cached_key) is likely to be\n     /// significantly faster, as it does not recompute element keys.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n-    /// See [`sort_unstable_by_key`](#method.sort_unstable_by_key).\n+    /// See [`sort_unstable_by_key`](slice::sort_unstable_by_key).\n     ///\n     /// # Current implementation\n     ///\n@@ -363,7 +363,7 @@ impl<T> [T] {\n     /// worst-case, where the key function is *O*(*m*).\n     ///\n     /// For simple key functions (e.g., functions that are property accesses or\n-    /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n+    /// basic operations), [`sort_by_key`](slice::sort_by_key) is likely to be\n     /// faster.\n     ///\n     /// # Current implementation"}, {"sha": "417a106b99a2ef9384ead64eb64336293023d1fb", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 59, "deletions": 53, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/16ce4f75130d1116a762258608810069bd7a42ad/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ce4f75130d1116a762258608810069bd7a42ad/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=16ce4f75130d1116a762258608810069bd7a42ad", "patch": "@@ -308,7 +308,7 @@ impl<T> [T] {\n     /// Returns a mutable reference to an element or subslice depending on the\n     /// type of index (see [`get`]) or `None` if the index is out of bounds.\n     ///\n-    /// [`get`]: #method.get\n+    /// [`get`]: slice::get\n     ///\n     /// # Examples\n     ///\n@@ -339,7 +339,7 @@ impl<T> [T] {\n     /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n     /// even if the resulting reference is not used.\n     ///\n-    /// [`get`]: #method.get\n+    /// [`get`]: slice::get\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n@@ -373,7 +373,7 @@ impl<T> [T] {\n     /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n     /// even if the resulting reference is not used.\n     ///\n-    /// [`get_mut`]: #method.get_mut\n+    /// [`get_mut`]: slice::get_mut\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n@@ -424,7 +424,7 @@ impl<T> [T] {\n     /// }\n     /// ```\n     ///\n-    /// [`as_mut_ptr`]: #method.as_mut_ptr\n+    /// [`as_mut_ptr`]: slice::as_mut_ptr\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_slice_as_ptr\", since = \"1.32.0\")]\n     #[inline]\n@@ -487,7 +487,7 @@ impl<T> [T] {\n     /// assert!(!a.as_ptr_range().contains(&y));\n     /// ```\n     ///\n-    /// [`as_ptr`]: #method.as_ptr\n+    /// [`as_ptr`]: slice::as_ptr\n     #[stable(feature = \"slice_ptr_range\", since = \"1.48.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n@@ -529,7 +529,7 @@ impl<T> [T] {\n     /// use two pointers to refer to a range of elements in memory, as is\n     /// common in C++.\n     ///\n-    /// [`as_mut_ptr`]: #method.as_mut_ptr\n+    /// [`as_mut_ptr`]: slice::as_mut_ptr\n     #[stable(feature = \"slice_ptr_range\", since = \"1.48.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n@@ -780,8 +780,8 @@ impl<T> [T] {\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n-    /// [`chunks_exact`]: #method.chunks_exact\n-    /// [`rchunks`]: #method.rchunks\n+    /// [`chunks_exact`]: slice::chunks_exact\n+    /// [`rchunks`]: slice::rchunks\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n@@ -818,8 +818,8 @@ impl<T> [T] {\n     /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n     /// ```\n     ///\n-    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n-    /// [`rchunks_mut`]: #method.rchunks_mut\n+    /// [`chunks_exact_mut`]: slice::chunks_exact_mut\n+    /// [`rchunks_mut`]: slice::rchunks_mut\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<'_, T> {\n@@ -855,8 +855,8 @@ impl<T> [T] {\n     /// assert_eq!(iter.remainder(), &['m']);\n     /// ```\n     ///\n-    /// [`chunks`]: #method.chunks\n-    /// [`rchunks_exact`]: #method.rchunks_exact\n+    /// [`chunks`]: slice::chunks\n+    /// [`rchunks_exact`]: slice::rchunks_exact\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     #[inline]\n     pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<'_, T> {\n@@ -897,8 +897,8 @@ impl<T> [T] {\n     /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n     /// ```\n     ///\n-    /// [`chunks_mut`]: #method.chunks_mut\n-    /// [`rchunks_exact_mut`]: #method.rchunks_exact_mut\n+    /// [`chunks_mut`]: slice::chunks_mut\n+    /// [`rchunks_exact_mut`]: slice::rchunks_exact_mut\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     #[inline]\n     pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<'_, T> {\n@@ -1032,7 +1032,7 @@ impl<T> [T] {\n     /// assert_eq!(iter.remainder(), &['m']);\n     /// ```\n     ///\n-    /// [`chunks_exact`]: #method.chunks_exact\n+    /// [`chunks_exact`]: slice::chunks_exact\n     #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n     #[inline]\n     pub fn array_chunks<const N: usize>(&self) -> ArrayChunks<'_, T, N> {\n@@ -1182,7 +1182,7 @@ impl<T> [T] {\n     /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n     /// ```\n     ///\n-    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n+    /// [`chunks_exact_mut`]: slice::chunks_exact_mut\n     #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n     #[inline]\n     pub fn array_chunks_mut<const N: usize>(&mut self) -> ArrayChunksMut<'_, T, N> {\n@@ -1214,7 +1214,7 @@ impl<T> [T] {\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n-    /// [`windows`]: #method.windows\n+    /// [`windows`]: slice::windows\n     #[unstable(feature = \"array_windows\", issue = \"75027\")]\n     #[inline]\n     pub fn array_windows<const N: usize>(&self) -> ArrayWindows<'_, T, N> {\n@@ -1247,8 +1247,8 @@ impl<T> [T] {\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n-    /// [`rchunks_exact`]: #method.rchunks_exact\n-    /// [`chunks`]: #method.chunks\n+    /// [`rchunks_exact`]: slice::rchunks_exact\n+    /// [`chunks`]: slice::chunks\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks(&self, chunk_size: usize) -> RChunks<'_, T> {\n@@ -1285,8 +1285,8 @@ impl<T> [T] {\n     /// assert_eq!(v, &[3, 2, 2, 1, 1]);\n     /// ```\n     ///\n-    /// [`rchunks_exact_mut`]: #method.rchunks_exact_mut\n-    /// [`chunks_mut`]: #method.chunks_mut\n+    /// [`rchunks_exact_mut`]: slice::rchunks_exact_mut\n+    /// [`chunks_mut`]: slice::chunks_mut\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks_mut(&mut self, chunk_size: usize) -> RChunksMut<'_, T> {\n@@ -1323,9 +1323,9 @@ impl<T> [T] {\n     /// assert_eq!(iter.remainder(), &['l']);\n     /// ```\n     ///\n-    /// [`chunks`]: #method.chunks\n-    /// [`rchunks`]: #method.rchunks\n-    /// [`chunks_exact`]: #method.chunks_exact\n+    /// [`chunks`]: slice::chunks\n+    /// [`rchunks`]: slice::rchunks\n+    /// [`chunks_exact`]: slice::chunks_exact\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks_exact(&self, chunk_size: usize) -> RChunksExact<'_, T> {\n@@ -1366,9 +1366,9 @@ impl<T> [T] {\n     /// assert_eq!(v, &[0, 2, 2, 1, 1]);\n     /// ```\n     ///\n-    /// [`chunks_mut`]: #method.chunks_mut\n-    /// [`rchunks_mut`]: #method.rchunks_mut\n-    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n+    /// [`chunks_mut`]: slice::chunks_mut\n+    /// [`rchunks_mut`]: slice::rchunks_mut\n+    /// [`chunks_exact_mut`]: slice::chunks_exact_mut\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks_exact_mut(&mut self, chunk_size: usize) -> RChunksExactMut<'_, T> {\n@@ -1552,7 +1552,7 @@ impl<T> [T] {\n     /// even if the resulting reference is not used. The caller has to ensure that\n     /// `0 <= mid <= self.len()`.\n     ///\n-    /// [`split_at`]: #method.split_at\n+    /// [`split_at`]: slice::split_at\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n@@ -1601,7 +1601,7 @@ impl<T> [T] {\n     /// even if the resulting reference is not used. The caller has to ensure that\n     /// `0 <= mid <= self.len()`.\n     ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n+    /// [`split_at_mut`]: slice::split_at_mut\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n@@ -2103,9 +2103,9 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search_by`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n-    /// [`binary_search_by`]: #method.binary_search_by\n-    /// [`binary_search_by_key`]: #method.binary_search_by_key\n-    /// [`partition_point`]: #method.partition_point\n+    /// [`binary_search_by`]: slice::binary_search_by\n+    /// [`binary_search_by_key`]: slice::binary_search_by_key\n+    /// [`partition_point`]: slice::partition_point\n     ///\n     /// # Examples\n     ///\n@@ -2156,9 +2156,9 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n-    /// [`binary_search`]: #method.binary_search\n-    /// [`binary_search_by_key`]: #method.binary_search_by_key\n-    /// [`partition_point`]: #method.partition_point\n+    /// [`binary_search`]: slice::binary_search\n+    /// [`binary_search_by_key`]: slice::binary_search_by_key\n+    /// [`partition_point`]: slice::partition_point\n     ///\n     /// # Examples\n     ///\n@@ -2225,10 +2225,10 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n     ///\n-    /// [`sort_by_key`]: #method.sort_by_key\n-    /// [`binary_search`]: #method.binary_search\n-    /// [`binary_search_by`]: #method.binary_search_by\n-    /// [`partition_point`]: #method.partition_point\n+    /// [`sort_by_key`]: slice::sort_by_key\n+    /// [`binary_search`]: slice::binary_search\n+    /// [`binary_search_by`]: slice::binary_search_by\n+    /// [`partition_point`]: slice::partition_point\n     ///\n     /// # Examples\n     ///\n@@ -2248,6 +2248,12 @@ impl<T> [T] {\n     /// let r = s.binary_search_by_key(&1, |&(a, b)| b);\n     /// assert!(match r { Ok(1..=4) => true, _ => false, });\n     /// ```\n+    // Lint rustdoc::broken_intra_doc_links is allowed as `slice::sort_by_key` is\n+    // in crate `alloc`, and as such doesn't exists yet when building `core`.\n+    // links to downstream crate: #74481. Since primitives are only documented in\n+    // libstd (#73423), this never leads to broken links in practice.\n+    #[cfg_attr(not(bootstrap), allow(rustdoc::broken_intra_doc_links))]\n+    #[cfg_attr(bootstrap, allow(broken_intra_doc_links))]\n     #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n     #[inline]\n     pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n@@ -2446,7 +2452,7 @@ impl<T> [T] {\n     /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n     /// used for [`sort_unstable`].\n     ///\n-    /// [`sort_unstable`]: #method.sort_unstable\n+    /// [`sort_unstable`]: slice::sort_unstable\n     ///\n     /// # Panics\n     ///\n@@ -2494,7 +2500,7 @@ impl<T> [T] {\n     /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n     /// used for [`sort_unstable`].\n     ///\n-    /// [`sort_unstable`]: #method.sort_unstable\n+    /// [`sort_unstable`]: slice::sort_unstable\n     ///\n     /// # Panics\n     ///\n@@ -2546,7 +2552,7 @@ impl<T> [T] {\n     /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n     /// used for [`sort_unstable`].\n     ///\n-    /// [`sort_unstable`]: #method.sort_unstable\n+    /// [`sort_unstable`]: slice::sort_unstable\n     ///\n     /// # Panics\n     ///\n@@ -2883,7 +2889,7 @@ impl<T> [T] {\n     /// trait to generate values, you can pass [`Default::default`] as the\n     /// argument.\n     ///\n-    /// [`fill`]: #method.fill\n+    /// [`fill`]: slice::fill\n     ///\n     /// # Examples\n     ///\n@@ -2956,8 +2962,8 @@ impl<T> [T] {\n     /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n     /// ```\n     ///\n-    /// [`copy_from_slice`]: #method.copy_from_slice\n-    /// [`split_at_mut`]: #method.split_at_mut\n+    /// [`copy_from_slice`]: slice::copy_from_slice\n+    /// [`split_at_mut`]: slice::split_at_mut\n     #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n     pub fn clone_from_slice(&mut self, src: &[T])\n     where\n@@ -3018,8 +3024,8 @@ impl<T> [T] {\n     /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n     /// ```\n     ///\n-    /// [`clone_from_slice`]: #method.clone_from_slice\n-    /// [`split_at_mut`]: #method.split_at_mut\n+    /// [`clone_from_slice`]: slice::clone_from_slice\n+    /// [`split_at_mut`]: slice::split_at_mut\n     #[doc(alias = \"memcpy\")]\n     #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     pub fn copy_from_slice(&mut self, src: &[T])\n@@ -3136,7 +3142,7 @@ impl<T> [T] {\n     /// assert_eq!(slice, [4, 5, 3, 1, 2]);\n     /// ```\n     ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n+    /// [`split_at_mut`]: slice::split_at_mut\n     #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n     pub fn swap_with_slice(&mut self, other: &mut [T]) {\n         assert!(self.len() == other.len(), \"destination and source slices have different lengths\");\n@@ -3380,7 +3386,7 @@ impl<T> [T] {\n     /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n     /// [`is_sorted`]; see its documentation for more information.\n     ///\n-    /// [`is_sorted`]: #method.is_sorted\n+    /// [`is_sorted`]: slice::is_sorted\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n     pub fn is_sorted_by<F>(&self, mut compare: F) -> bool\n     where\n@@ -3395,7 +3401,7 @@ impl<T> [T] {\n     /// elements, as determined by `f`. Apart from that, it's equivalent to [`is_sorted`]; see its\n     /// documentation for more information.\n     ///\n-    /// [`is_sorted`]: #method.is_sorted\n+    /// [`is_sorted`]: slice::is_sorted\n     ///\n     /// # Examples\n     ///\n@@ -3429,9 +3435,9 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search`], [`binary_search_by`], and [`binary_search_by_key`].\n     ///\n-    /// [`binary_search`]: #method.binary_search\n-    /// [`binary_search_by`]: #method.binary_search_by\n-    /// [`binary_search_by_key`]: #method.binary_search_by_key\n+    /// [`binary_search`]: slice::binary_search\n+    /// [`binary_search_by`]: slice::binary_search_by\n+    /// [`binary_search_by_key`]: slice::binary_search_by_key\n     ///\n     /// # Examples\n     ///"}, {"sha": "f6875e0036f679e14bd16a7fd711feb090d1188e", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16ce4f75130d1116a762258608810069bd7a42ad/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ce4f75130d1116a762258608810069bd7a42ad/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=16ce4f75130d1116a762258608810069bd7a42ad", "patch": "@@ -33,11 +33,6 @@ use crate::Redirect::*;\n // are cases where that does not work\n // [(generated_documentation_page, &[broken_links])]\n const LINKCHECK_EXCEPTIONS: &[(&str, &[&str])] = &[\n-    // These are methods on slice, and `Self` does not work on primitive impls\n-    // in intra-doc links (primitive impls are weird)\n-    // https://github.com/rust-lang/rust/issues/62834 is necessary to be\n-    // able to link to slices\n-    (\"std/io/struct.IoSlice.html\", &[\"#method.as_mut_ptr\", \"#method.sort_by_key\"]),\n     // These try to link to std::collections, but are defined in alloc\n     // https://github.com/rust-lang/rust/issues/74481\n     (\"std/collections/btree_map/struct.BTreeMap.html\", &[\"#insert-and-complex-keys\"]),"}]}