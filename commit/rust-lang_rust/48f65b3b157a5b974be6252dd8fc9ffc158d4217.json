{"sha": "48f65b3b157a5b974be6252dd8fc9ffc158d4217", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZjY1YjNiMTU3YTViOTc0YmU2MjUyZGQ4ZmM5ZmZjMTU4ZDQyMTc=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-11T17:23:59Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-11T17:24:52Z"}, "message": "Item search now respects trait impl items", "tree": {"sha": "202abc290828e43fcfca625bfe5ffcd85f050153", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/202abc290828e43fcfca625bfe5ffcd85f050153"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48f65b3b157a5b974be6252dd8fc9ffc158d4217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48f65b3b157a5b974be6252dd8fc9ffc158d4217", "html_url": "https://github.com/rust-lang/rust/commit/48f65b3b157a5b974be6252dd8fc9ffc158d4217", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48f65b3b157a5b974be6252dd8fc9ffc158d4217/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6133fe51c2cf31d776f16d520de4f78c709181c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6133fe51c2cf31d776f16d520de4f78c709181c", "html_url": "https://github.com/rust-lang/rust/commit/c6133fe51c2cf31d776f16d520de4f78c709181c"}], "stats": {"total": 226, "additions": 215, "deletions": 11}, "files": [{"sha": "68ac8400ca7622e6b3ce712ed515a08da3178153", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/48f65b3b157a5b974be6252dd8fc9ffc158d4217/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f65b3b157a5b974be6252dd8fc9ffc158d4217/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=48f65b3b157a5b974be6252dd8fc9ffc158d4217", "patch": "@@ -1450,6 +1450,20 @@ impl AssocItem {\n             _ => None,\n         }\n     }\n+\n+    pub fn containing_trait_impl(self, db: &dyn HirDatabase) -> Option<Trait> {\n+        match self.container(db) {\n+            AssocItemContainer::Impl(i) => i.trait_(db),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn containing_trait_or_trait_impl(self, db: &dyn HirDatabase) -> Option<Trait> {\n+        match self.container(db) {\n+            AssocItemContainer::Trait(t) => Some(t),\n+            AssocItemContainer::Impl(i) => i.trait_(db),\n+        }\n+    }\n }\n \n impl HasVisibility for AssocItem {"}, {"sha": "7dfc5043ee99ee7f78b931b5dd738b9db5d4706f", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 164, "deletions": 1, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/48f65b3b157a5b974be6252dd8fc9ffc158d4217/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f65b3b157a5b974be6252dd8fc9ffc158d4217/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=48f65b3b157a5b974be6252dd8fc9ffc158d4217", "patch": "@@ -239,7 +239,7 @@ fn rename_mod(\n \n fn rename_reference(\n     sema: &Semantics<RootDatabase>,\n-    def: Definition,\n+    mut def: Definition,\n     new_name: &str,\n ) -> RenameResult<SourceChange> {\n     let ident_kind = check_identifier(new_name)?;\n@@ -285,7 +285,38 @@ fn rename_reference(\n         }\n     }\n \n+    def = match def {\n+        // HACK: resolve trait impl items to the item def of the trait definition\n+        // so that we properly resolve all trait item references\n+        Definition::ModuleDef(mod_def) => mod_def\n+            .as_assoc_item(sema.db)\n+            .and_then(|it| it.containing_trait_impl(sema.db))\n+            .and_then(|it| {\n+                it.items(sema.db).into_iter().find_map(|it| match (it, mod_def) {\n+                    (hir::AssocItem::Function(trait_func), ModuleDef::Function(func))\n+                        if trait_func.name(sema.db) == func.name(sema.db) =>\n+                    {\n+                        Some(Definition::ModuleDef(ModuleDef::Function(trait_func)))\n+                    }\n+                    (hir::AssocItem::Const(trait_konst), ModuleDef::Const(konst))\n+                        if trait_konst.name(sema.db) == konst.name(sema.db) =>\n+                    {\n+                        Some(Definition::ModuleDef(ModuleDef::Const(trait_konst)))\n+                    }\n+                    (\n+                        hir::AssocItem::TypeAlias(trait_type_alias),\n+                        ModuleDef::TypeAlias(type_alias),\n+                    ) if trait_type_alias.name(sema.db) == type_alias.name(sema.db) => {\n+                        Some(Definition::ModuleDef(ModuleDef::TypeAlias(trait_type_alias)))\n+                    }\n+                    _ => None,\n+                })\n+            })\n+            .unwrap_or(def),\n+        _ => def,\n+    };\n     let usages = def.usages(sema).all();\n+\n     if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {\n         cov_mark::hit!(rename_underscore_multiple);\n         bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n@@ -1938,4 +1969,136 @@ use Bar$0;\n             \"error: Renaming aliases is currently unsupported\",\n         );\n     }\n+\n+    #[test]\n+    fn test_rename_trait_method() {\n+        let res = r\"\n+trait Foo {\n+    fn foo(&self) {\n+        self.foo();\n+    }\n+}\n+\n+impl Foo for () {\n+    fn foo(&self) {\n+        self.foo();\n+    }\n+}\";\n+        check(\n+            \"foo\",\n+            r#\"\n+trait Foo {\n+    fn bar$0(&self) {\n+        self.bar();\n+    }\n+}\n+\n+impl Foo for () {\n+    fn bar(&self) {\n+        self.bar();\n+    }\n+}\"#,\n+            res,\n+        );\n+        check(\n+            \"foo\",\n+            r#\"\n+trait Foo {\n+    fn bar(&self) {\n+        self.bar$0();\n+    }\n+}\n+\n+impl Foo for () {\n+    fn bar(&self) {\n+        self.bar();\n+    }\n+}\"#,\n+            res,\n+        );\n+        check(\n+            \"foo\",\n+            r#\"\n+trait Foo {\n+    fn bar(&self) {\n+        self.bar();\n+    }\n+}\n+\n+impl Foo for () {\n+    fn bar$0(&self) {\n+        self.bar();\n+    }\n+}\"#,\n+            res,\n+        );\n+        check(\n+            \"foo\",\n+            r#\"\n+trait Foo {\n+    fn bar(&self) {\n+        self.bar();\n+    }\n+}\n+\n+impl Foo for () {\n+    fn bar(&self) {\n+        self.bar$0();\n+    }\n+}\"#,\n+            res,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_trait_const() {\n+        let res = r\"\n+trait Foo {\n+    const FOO: ();\n+}\n+\n+impl Foo for () {\n+    const FOO: ();\n+}\n+fn f() { <()>::FOO; }\";\n+        check(\n+            \"FOO\",\n+            r#\"\n+trait Foo {\n+    const BAR$0: ();\n+}\n+\n+impl Foo for () {\n+    const BAR: ();\n+}\n+fn f() { <()>::BAR; }\"#,\n+            res,\n+        );\n+        check(\n+            \"FOO\",\n+            r#\"\n+trait Foo {\n+    const BAR: ();\n+}\n+\n+impl Foo for () {\n+    const BAR$0: ();\n+}\n+fn f() { <()>::BAR; }\"#,\n+            res,\n+        );\n+        check(\n+            \"FOO\",\n+            r#\"\n+trait Foo {\n+    const BAR: ();\n+}\n+\n+impl Foo for () {\n+    const BAR: ();\n+}\n+fn f() { <()>::BAR$0; }\"#,\n+            res,\n+        );\n+    }\n }"}, {"sha": "8152630f5808c74e541c8105e6ac6d7a6bd1989b", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/48f65b3b157a5b974be6252dd8fc9ffc158d4217/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f65b3b157a5b974be6252dd8fc9ffc158d4217/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=48f65b3b157a5b974be6252dd8fc9ffc158d4217", "patch": "@@ -8,7 +8,8 @@ use std::{convert::TryInto, mem};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n use hir::{\n-    DefWithBody, HasAttrs, HasSource, InFile, ModuleDef, ModuleSource, Semantics, Visibility,\n+    AsAssocItem, DefWithBody, HasAttrs, HasSource, InFile, ModuleDef, ModuleSource, Semantics,\n+    Visibility,\n };\n use once_cell::unsync::Lazy;\n use rustc_hash::FxHashMap;\n@@ -303,13 +304,13 @@ impl Definition {\n         }\n     }\n \n-    pub fn usages<'a>(&'a self, sema: &'a Semantics<RootDatabase>) -> FindUsages<'a> {\n+    pub fn usages<'a>(self, sema: &'a Semantics<RootDatabase>) -> FindUsages<'a> {\n         FindUsages { def: self, sema, scope: None, include_self_kw_refs: None }\n     }\n }\n \n pub struct FindUsages<'a> {\n-    def: &'a Definition,\n+    def: Definition,\n     sema: &'a Semantics<'a, RootDatabase>,\n     scope: Option<SearchScope>,\n     include_self_kw_refs: Option<hir::Type>,\n@@ -318,7 +319,7 @@ pub struct FindUsages<'a> {\n impl<'a> FindUsages<'a> {\n     /// Enable searching for `Self` when the definition is a type.\n     pub fn include_self_refs(mut self) -> FindUsages<'a> {\n-        self.include_self_kw_refs = def_to_ty(self.sema, self.def);\n+        self.include_self_kw_refs = def_to_ty(self.sema, &self.def);\n         self\n     }\n \n@@ -445,7 +446,7 @@ impl<'a> FindUsages<'a> {\n         sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify_lifetime(self.sema, lifetime) {\n-            Some(NameRefClass::Definition(def)) if &def == self.def => {\n+            Some(NameRefClass::Definition(def)) if def == self.def => {\n                 let FileRange { file_id, range } = self.sema.original_range(lifetime.syntax());\n                 let reference = FileReference {\n                     range,\n@@ -464,7 +465,7 @@ impl<'a> FindUsages<'a> {\n         sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify(self.sema, &name_ref) {\n-            Some(NameRefClass::Definition(def)) if &def == self.def => {\n+            Some(NameRefClass::Definition(def)) if def == self.def => {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = FileReference {\n                     range,\n@@ -489,10 +490,10 @@ impl<'a> FindUsages<'a> {\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let access = match self.def {\n-                    Definition::Field(_) if &field == self.def => {\n+                    Definition::Field(_) if field == self.def => {\n                         reference_access(&field, &name_ref)\n                     }\n-                    Definition::Local(l) if &local == l => {\n+                    Definition::Local(l) if local == l => {\n                         reference_access(&Definition::Local(local), &name_ref)\n                     }\n                     _ => return false,\n@@ -513,7 +514,7 @@ impl<'a> FindUsages<'a> {\n         match NameClass::classify(self.sema, name) {\n             Some(NameClass::PatFieldShorthand { local_def: _, field_ref })\n                 if matches!(\n-                    self.def, Definition::Field(_) if &field_ref == self.def\n+                    self.def, Definition::Field(_) if field_ref == self.def\n                 ) =>\n             {\n                 let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n@@ -525,12 +526,38 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n-            Some(NameClass::ConstReference(def)) if *self.def == def => {\n+            Some(NameClass::ConstReference(def)) if self.def == def => {\n                 let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n                 let reference =\n                     FileReference { range, name: ast::NameLike::Name(name.clone()), access: None };\n                 sink(file_id, reference)\n             }\n+            // Resolve trait impl function definitions to the trait definition's version if self.def is the trait definition's\n+            Some(NameClass::Definition(Definition::ModuleDef(mod_def))) => {\n+                /* poor man's try block */\n+                (|| {\n+                    let this = match self.def {\n+                        Definition::ModuleDef(this) if this != mod_def => this,\n+                        _ => return None,\n+                    };\n+                    let this_trait = this\n+                        .as_assoc_item(self.sema.db)?\n+                        .containing_trait_or_trait_impl(self.sema.db)?;\n+                    let trait_ = mod_def\n+                        .as_assoc_item(self.sema.db)?\n+                        .containing_trait_or_trait_impl(self.sema.db)?;\n+                    (trait_ == this_trait).then(|| {\n+                        let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n+                        let reference = FileReference {\n+                            range,\n+                            name: ast::NameLike::Name(name.clone()),\n+                            access: None,\n+                        };\n+                        sink(file_id, reference)\n+                    })\n+                })()\n+                .unwrap_or(false)\n+            }\n             _ => false,\n         }\n     }"}]}