{"sha": "65a4266f1f4ce9dac5a6ef588443b7cac911d265", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YTQyNjZmMWY0Y2U5ZGFjNWE2ZWY1ODg0NDNiN2NhYzkxMWQyNjU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-08T16:33:21Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-18T00:53:07Z"}, "message": "refactor away callee::Callee and translate virtual calls through a MIR shim\n\nThese changes are in the same commit to avoid needing to adapt\nmeth::trans_object_shim to the new scheme.\n\nOne codegen-units test is broken because we instantiate the shims even\nwhen they are not needed. This will be fixed in the next PR.", "tree": {"sha": "2f4346b9e5d106b86893c3af65dfd46b3240f85c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f4346b9e5d106b86893c3af65dfd46b3240f85c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65a4266f1f4ce9dac5a6ef588443b7cac911d265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65a4266f1f4ce9dac5a6ef588443b7cac911d265", "html_url": "https://github.com/rust-lang/rust/commit/65a4266f1f4ce9dac5a6ef588443b7cac911d265", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65a4266f1f4ce9dac5a6ef588443b7cac911d265/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aac5ba5dab758803b06add74457eba03bbbd9930", "url": "https://api.github.com/repos/rust-lang/rust/commits/aac5ba5dab758803b06add74457eba03bbbd9930", "html_url": "https://github.com/rust-lang/rust/commit/aac5ba5dab758803b06add74457eba03bbbd9930"}], "stats": {"total": 691, "additions": 324, "deletions": 367}, "files": [{"sha": "2718a0204a1ed07926a3921d5cf2e245617cf28a", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -23,6 +23,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(associated_consts)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![cfg_attr(stage0, feature(field_init_shorthand))]\n #![feature(i128_type)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "2d2b90235ca3b6b6392cab0bcd378a42fd9f8f34", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -252,12 +252,9 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> Ty<'tcx> {\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n \n-    // We're just hard-coding the idea that the signature will be\n-    // &self or &mut self and hence will have a bound region with\n-    // number 0, hokey.\n     let region = ty::Region::ReFree(ty::FreeRegion {\n         scope: tcx.region_maps.item_extent(body_id.node_id),\n-        bound_region: ty::BoundRegion::BrAnon(0),\n+        bound_region: ty::BoundRegion::BrEnv,\n     });\n     let region = tcx.mk_region(region);\n "}, {"sha": "97c83c7a42e28f368fda4cfe91cb4acefcac8f32", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 133, "deletions": 80, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -9,17 +9,19 @@\n // except according to those terms.\n \n use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc::infer;\n+use rustc::middle::region::ROOT_CODE_EXTENT;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::ty::{self, Ty};\n+use rustc::ty::subst::Subst;\n use rustc::ty::maps::Providers;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::codemap::DUMMY_SP;\n use syntax_pos::Span;\n \n use std::cell::RefCell;\n@@ -35,11 +37,51 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                        -> &'tcx RefCell<Mir<'tcx>>\n {\n     debug!(\"make_shim({:?})\", instance);\n+    let did = instance.def_id();\n+    let span = tcx.def_span(did);\n+    let param_env =\n+        tcx.construct_parameter_environment(span, did, ROOT_CODE_EXTENT);\n+\n     let result = match instance {\n         ty::InstanceDef::Item(..) =>\n             bug!(\"item {:?} passed to make_shim\", instance),\n-        ty::InstanceDef::FnPtrShim(_, ty) => {\n-            build_fn_ptr_shim(tcx, ty, instance.def_ty(tcx))\n+        ty::InstanceDef::FnPtrShim(def_id, ty) => {\n+            let trait_ = tcx.trait_of_item(def_id).unwrap();\n+            let adjustment = match tcx.lang_items.fn_trait_kind(trait_) {\n+                Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n+                Some(ty::ClosureKind::FnMut) |\n+                Some(ty::ClosureKind::Fn) => Adjustment::Deref,\n+                None => bug!(\"fn pointer {:?} is not an fn\", ty)\n+            };\n+            // HACK: we need the \"real\" argument types for the MIR,\n+            // but because our substs are (Self, Args), where Args\n+            // is a tuple, we must include the *concrete* argument\n+            // types in the MIR. They will be substituted again with\n+            // the param-substs, but because they are concrete, this\n+            // will not do any harm.\n+            let sig = tcx.erase_late_bound_regions(&ty.fn_sig());\n+            let arg_tys = sig.inputs();\n+\n+            build_call_shim(\n+                tcx,\n+                &param_env,\n+                def_id,\n+                adjustment,\n+                CallKind::Indirect,\n+                Some(arg_tys)\n+            )\n+        }\n+        ty::InstanceDef::Virtual(def_id, _) => {\n+            // We are translating a call back to our def-id, which\n+            // trans::mir knows to turn to an actual virtual call.\n+            build_call_shim(\n+                tcx,\n+                &param_env,\n+                def_id,\n+                Adjustment::Identity,\n+                CallKind::Direct(def_id),\n+                None\n+            )\n         }\n         _ => bug!(\"unknown shim kind\")\n     };\n@@ -51,124 +93,135 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     result\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq)]\n+enum Adjustment {\n+    Identity,\n+    Deref,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+enum CallKind {\n+    Indirect,\n+    Direct(DefId),\n+}\n+\n+fn temp_decl(mutability: Mutability, ty: Ty) -> LocalDecl {\n+    LocalDecl { mutability, ty, name: None, source_info: None }\n+}\n+\n fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>)\n     -> IndexVec<Local, LocalDecl<'tcx>>\n {\n-    iter::once(LocalDecl {\n-        mutability: Mutability::Mut,\n-        ty: sig.output(),\n-        name: None,\n-        source_info: None\n-    }).chain(sig.inputs().iter().map(|ity| LocalDecl {\n-        mutability: Mutability::Not,\n-        ty: *ity,\n-        name: None,\n-        source_info: None,\n-    })).collect()\n+    iter::once(temp_decl(Mutability::Mut, sig.output()))\n+        .chain(sig.inputs().iter().map(\n+            |ity| temp_decl(Mutability::Not, ity)))\n+        .collect()\n }\n \n-\n-fn build_fn_ptr_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-                               fn_ty: Ty<'tcx>,\n-                               sig_ty: Ty<'tcx>)\n-                               -> Mir<'tcx>\n+/// Build a \"call\" shim for `def_id`. The shim calls the\n+/// function specified by `call_kind`, first adjusting its first\n+/// argument according to `rcvr_adjustment`.\n+///\n+/// If `untuple_args` is a vec of types, the second argument of the\n+/// function will be untupled as these types.\n+fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                             param_env: &ty::ParameterEnvironment<'tcx>,\n+                             def_id: DefId,\n+                             rcvr_adjustment: Adjustment,\n+                             call_kind: CallKind,\n+                             untuple_args: Option<&[Ty<'tcx>]>)\n+                             -> Mir<'tcx>\n {\n-    debug!(\"build_fn_ptr_shim(fn_ty={:?}, sig_ty={:?})\", fn_ty, sig_ty);\n-    let trait_sig = match sig_ty.sty {\n-        ty::TyFnDef(_, _, fty) => tcx.erase_late_bound_regions(&fty),\n-        _ => bug!(\"unexpected type for shim {:?}\", sig_ty)\n-    };\n+    debug!(\"build_call_shim(def_id={:?}, rcvr_adjustment={:?}, \\\n+            call_kind={:?}, untuple_args={:?})\",\n+           def_id, rcvr_adjustment, call_kind, untuple_args);\n \n-    let self_ty = match trait_sig.inputs()[0].sty {\n-        ty::TyParam(..) => fn_ty,\n-        ty::TyRef(r, mt) => tcx.mk_ref(r, ty::TypeAndMut {\n-            ty: fn_ty,\n-            mutbl: mt.mutbl\n-        }),\n-        _ => bug!(\"unexpected self_ty {:?}\", trait_sig),\n-    };\n+    let fn_ty = tcx.item_type(def_id).subst(tcx, param_env.free_substs);\n+    // Not normalizing here without a param env.\n+    let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n+    let span = tcx.def_span(def_id);\n \n-    let fn_ptr_sig = match fn_ty.sty {\n-        ty::TyFnPtr(fty) |\n-        ty::TyFnDef(_, _, fty) =>\n-            tcx.erase_late_bound_regions_and_normalize(&fty),\n-        _ => bug!(\"non-fn-ptr {:?} in build_fn_ptr_shim\", fn_ty)\n-    };\n-\n-    let sig = tcx.mk_fn_sig(\n-        [\n-            self_ty,\n-            tcx.intern_tup(fn_ptr_sig.inputs(), false)\n-        ].iter().cloned(),\n-        fn_ptr_sig.output(),\n-        false,\n-        hir::Unsafety::Normal,\n-        Abi::RustCall,\n-    );\n+    debug!(\"build_call_shim: sig={:?}\", sig);\n \n     let local_decls = local_decls_for_sig(&sig);\n-    let source_info = SourceInfo {\n-        span: DUMMY_SP,\n-        scope: ARGUMENT_VISIBILITY_SCOPE\n+    let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n+\n+    let rcvr_l = Lvalue::Local(Local::new(1+0));\n+\n+    let return_block_id = BasicBlock::new(1);\n+\n+    let rcvr = match rcvr_adjustment {\n+        Adjustment::Identity => Operand::Consume(rcvr_l),\n+        Adjustment::Deref => Operand::Consume(Lvalue::Projection(\n+            box Projection { base: rcvr_l, elem: ProjectionElem::Deref }\n+        ))\n     };\n \n-    let fn_ptr = Lvalue::Local(Local::new(1+0));\n-    let fn_ptr = match trait_sig.inputs()[0].sty {\n-        ty::TyParam(..) => fn_ptr,\n-        ty::TyRef(..) => Lvalue::Projection(box Projection {\n-            base: fn_ptr, elem: ProjectionElem::Deref\n-        }),\n-        _ => bug!(\"unexpected self_ty {:?}\", trait_sig),\n+    let (callee, mut args) = match call_kind {\n+        CallKind::Indirect => (rcvr, vec![]),\n+        CallKind::Direct(def_id) => (\n+            Operand::Constant(Constant {\n+                span: span,\n+                ty: tcx.item_type(def_id).subst(tcx, param_env.free_substs),\n+                literal: Literal::Item { def_id, substs: param_env.free_substs },\n+            }),\n+            vec![rcvr]\n+        )\n     };\n-    let fn_args = Local::new(1+1);\n \n-    let return_block_id = BasicBlock::new(1);\n+    if let Some(untuple_args) = untuple_args {\n+        args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n+            let arg_lv = Lvalue::Local(Local::new(1+1));\n+            Operand::Consume(Lvalue::Projection(box Projection {\n+                base: arg_lv,\n+                elem: ProjectionElem::Field(Field::new(i), *ity)\n+            }))\n+        }));\n+    } else {\n+        args.extend((1..sig.inputs().len()).map(|i| {\n+            Operand::Consume(Lvalue::Local(Local::new(1+i)))\n+        }));\n+    }\n \n-    // return = ADT(arg0, arg1, ...); return\n-    let start_block = BasicBlockData {\n+    let mut blocks = IndexVec::new();\n+    blocks.push(BasicBlockData {\n         statements: vec![],\n         terminator: Some(Terminator {\n             source_info: source_info,\n             kind: TerminatorKind::Call {\n-                func: Operand::Consume(fn_ptr),\n-                args: fn_ptr_sig.inputs().iter().enumerate().map(|(i, ity)| {\n-                    Operand::Consume(Lvalue::Projection(box Projection {\n-                        base: Lvalue::Local(fn_args),\n-                        elem: ProjectionElem::Field(\n-                            Field::new(i), *ity\n-                        )\n-                    }))\n-                }).collect(),\n-                // FIXME: can we pass a Some destination for an uninhabited ty?\n+                func: callee,\n+                args: args,\n                 destination: Some((Lvalue::Local(RETURN_POINTER),\n                                    return_block_id)),\n                 cleanup: None\n             }\n         }),\n         is_cleanup: false\n-    };\n-    let return_block = BasicBlockData {\n+    });\n+    blocks.push(BasicBlockData {\n         statements: vec![],\n         terminator: Some(Terminator {\n             source_info: source_info,\n             kind: TerminatorKind::Return\n         }),\n         is_cleanup: false\n-    };\n+    });\n \n     let mut mir = Mir::new(\n-        vec![start_block, return_block].into_iter().collect(),\n+        blocks,\n         IndexVec::from_elem_n(\n-            VisibilityScopeData { span: DUMMY_SP, parent_scope: None }, 1\n+            VisibilityScopeData { span: span, parent_scope: None }, 1\n         ),\n         IndexVec::new(),\n         sig.output(),\n         local_decls,\n         sig.inputs().len(),\n         vec![],\n-        DUMMY_SP\n+        span\n     );\n-    mir.spread_arg = Some(fn_args);\n+    if let Abi::RustCall = sig.abi {\n+        mir.spread_arg = Some(Local::new(sig.inputs().len()));\n+    }\n     mir\n }\n "}, {"sha": "710aa1fbbc6d951016b257b3649d323218a75380", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector, AttributePlace};\n use base;\n use builder::Builder;\n-use common::{type_is_fat_ptr, C_uint};\n+use common::{self, type_is_fat_ptr, C_uint};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -334,9 +334,30 @@ impl FnType {\n         fn_ty\n     }\n \n-    pub fn unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn new_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 sig: ty::FnSig<'tcx>,\n                                 extra_args: &[Ty<'tcx>]) -> FnType {\n+        let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n+        // Don't pass the vtable, it's not an argument of the virtual fn.\n+        fn_ty.args[1].ignore();\n+        fn_ty.adjust_for_abi(ccx, sig);\n+        fn_ty\n+    }\n+\n+    pub fn from_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                   instance: &ty::Instance<'tcx>,\n+                                   extra_args: &[Ty<'tcx>]) -> FnType\n+    {\n+        let ity = common::instance_ty(ccx.shared(), instance);\n+        let sig = common::ty_fn_sig(ccx, ity);\n+        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+\n+        Self::new(ccx, sig, extra_args)\n+    }\n+\n+    fn unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                            sig: ty::FnSig<'tcx>,\n+                            extra_args: &[Ty<'tcx>]) -> FnType {\n         use self::Abi::*;\n         let cconv = match ccx.sess().target.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic |\n@@ -532,9 +553,9 @@ impl FnType {\n         }\n     }\n \n-    pub fn adjust_for_abi<'a, 'tcx>(&mut self,\n-                                    ccx: &CrateContext<'a, 'tcx>,\n-                                    sig: ty::FnSig<'tcx>) {\n+    fn adjust_for_abi<'a, 'tcx>(&mut self,\n+                                ccx: &CrateContext<'a, 'tcx>,\n+                                sig: ty::FnSig<'tcx>) {\n         let abi = sig.abi;\n         if abi == Abi::Unadjusted { return }\n "}, {"sha": "a58764878a318e843169d2e7453751db0a3efa71", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -47,7 +47,7 @@ use abi;\n use mir::lvalue::LvalueRef;\n use attributes;\n use builder::Builder;\n-use callee::{Callee};\n+use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n use common::{C_struct_in_context, C_u64, C_undef};\n@@ -654,7 +654,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         return;\n     }\n \n-    let main_llfn = Callee::def(ccx, main_def_id, instance.substs).reify(ccx);\n+    let main_llfn = callee::get_fn(ccx, instance);\n \n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n@@ -688,8 +688,8 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n \n         let (start_fn, args) = if use_start_lang_item {\n             let start_def_id = ccx.tcx().require_lang_item(StartFnLangItem);\n-            let empty_substs = ccx.tcx().intern_substs(&[]);\n-            let start_fn = Callee::def(ccx, start_def_id, empty_substs).reify(ccx);\n+            let start_instance = Instance::mono(ccx.tcx(), start_def_id);\n+            let start_fn = callee::get_fn(ccx, start_instance);\n             (start_fn, vec![bld.pointercast(rust_main, Type::i8p(ccx).ptr_to()), get_param(llfn, 0),\n                 get_param(llfn, 1)])\n         } else {"}, {"sha": "5c7be56b56dad21b384416f3be31968952790dbe", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 52, "deletions": 98, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -14,8 +14,6 @@\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n \n-pub use self::CalleeData::*;\n-\n use llvm::{self, ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::{Substs, Subst};\n@@ -27,98 +25,17 @@ use cleanup::CleanupScope;\n use mir::lvalue::LvalueRef;\n use monomorphize;\n use consts;\n-use common::instance_ty;\n use declare;\n use value::Value;\n-use meth;\n use monomorphize::Instance;\n use back::symbol_names::symbol_name;\n use trans_item::TransItem;\n use type_of;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, TypeFoldable};\n use std::iter;\n \n use mir::lvalue::Alignment;\n \n-#[derive(Debug)]\n-pub enum CalleeData {\n-    /// Function pointer.\n-    Fn(ValueRef),\n-\n-    Intrinsic,\n-\n-    /// Trait object found in the vtable at that index.\n-    Virtual(usize)\n-}\n-\n-#[derive(Debug)]\n-pub struct Callee<'tcx> {\n-    pub data: CalleeData,\n-    pub ty: Ty<'tcx>\n-}\n-\n-impl<'tcx> Callee<'tcx> {\n-    /// Function or method definition.\n-    pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>)\n-                   -> Callee<'tcx> {\n-        let instance = monomorphize::resolve(ccx.shared(), def_id, substs);\n-        let ty = instance_ty(ccx.shared(), &instance);\n-        let data = match instance.def {\n-            ty::InstanceDef::Intrinsic(_) => Intrinsic,\n-            ty::InstanceDef::ClosureOnceShim { .. } => {\n-                let closure_ty = instance.substs.type_at(0);\n-                let (closure_def_id, closure_substs) = match closure_ty.sty {\n-                    ty::TyClosure(def_id, substs) => (def_id, substs),\n-                    _ => bug!(\"bad closure instance {:?}\", instance)\n-                };\n-\n-                Fn(trans_fn_once_adapter_shim(\n-                    ccx,\n-                    closure_def_id,\n-                    closure_substs,\n-                    instance,\n-                    get_fn(\n-                        ccx,\n-                        Instance::new(closure_def_id, closure_substs.substs)\n-                    )\n-                ))\n-            }\n-            ty::InstanceDef::Virtual(_, n) => Virtual(n),\n-            ty::InstanceDef::FnPtrShim(..) |\n-            ty::InstanceDef::Item(..) => {\n-                Fn(get_fn(ccx, instance))\n-            }\n-        };\n-\n-        Callee { data, ty }\n-    }\n-\n-    /// Get the abi::FnType for a direct call. Mainly deals with the fact\n-    /// that a Virtual call doesn't take the vtable, like its shim does.\n-    /// The extra argument types are for variadic (extern \"C\") functions.\n-    pub fn direct_fn_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n-                              extra_args: &[Ty<'tcx>]) -> FnType {\n-        let sig = common::ty_fn_sig(ccx, self.ty);\n-        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-        let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n-        if let Virtual(_) = self.data {\n-            // Don't pass the vtable, it's not an argument of the virtual fn.\n-            fn_ty.args[1].ignore();\n-        }\n-        fn_ty.adjust_for_abi(ccx, sig);\n-        fn_ty\n-    }\n-\n-    /// Turn the callee into a function pointer.\n-    pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n-        match self.data {\n-            Fn(llfn) => llfn,\n-            Virtual(_) => meth::trans_object_shim(ccx, self),\n-            Intrinsic => bug!(\"intrinsic {} getting reified\", self.ty)\n-        }\n-    }\n-}\n-\n fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     def_id: DefId,\n@@ -145,13 +62,14 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let sig = tcx.closure_type(def_id).subst(tcx, substs.substs);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     assert_eq!(sig.abi, Abi::RustCall);\n-    let llref_fn_ty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n+    let llref_fn_sig = tcx.mk_fn_sig(\n         iter::once(ref_closure_ty).chain(sig.inputs().iter().cloned()),\n         sig.output(),\n         sig.variadic,\n         sig.unsafety,\n         Abi::RustCall\n-    )));\n+    );\n+    let llref_fn_ty = tcx.mk_fn_ptr(ty::Binder(llref_fn_sig));\n     debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n            llref_fn_ty);\n \n@@ -177,15 +95,10 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let orig_fn_ty = fn_ty;\n     let mut bcx = Builder::new_block(ccx, lloncefn, \"entry-block\");\n \n-    let callee = Callee {\n-        data: Fn(llreffn),\n-        ty: llref_fn_ty\n-    };\n-\n     // the first argument (`self`) will be the (by value) closure env.\n \n     let mut llargs = get_params(lloncefn);\n-    let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n+    let fn_ty = FnType::new(ccx, llref_fn_sig, &[]);\n     let self_idx = fn_ty.ret.is_indirect() as usize;\n     let env_arg = &orig_fn_ty.args[0];\n     let env = if env_arg.is_indirect() {\n@@ -210,14 +123,13 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     // to drop `self` when the body returns, or in case it unwinds.\n     let self_scope = CleanupScope::schedule_drop_mem(&bcx, env);\n \n-    let llfn = callee.reify(bcx.ccx);\n     let llret;\n     if let Some(landing_pad) = self_scope.landing_pad {\n         let normal_bcx = bcx.build_sibling_block(\"normal-return\");\n-        llret = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n+        llret = bcx.invoke(llreffn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n         bcx = normal_bcx;\n     } else {\n-        llret = bcx.call(llfn, &llargs[..], None);\n+        llret = bcx.call(llreffn, &llargs[..], None);\n     }\n     fn_ty.apply_attrs_callsite(llret);\n \n@@ -247,9 +159,9 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n /// - `ccx`: the crate context\n /// - `def_id`: def id of the fn or method item being referenced\n /// - `substs`: values for each of the fn/method's parameters\n-fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                    instance: Instance<'tcx>)\n-                    -> ValueRef\n+fn do_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                       instance: Instance<'tcx>)\n+                       -> ValueRef\n {\n     let tcx = ccx.tcx();\n \n@@ -335,3 +247,45 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     llfn\n }\n+\n+pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                        instance: Instance<'tcx>)\n+                        -> ValueRef\n+{\n+    match instance.def {\n+        ty::InstanceDef::Intrinsic(_) => {\n+            bug!(\"intrinsic {} getting reified\", instance)\n+        }\n+        ty::InstanceDef::ClosureOnceShim { .. } => {\n+            let closure_ty = instance.substs.type_at(0);\n+            let (closure_def_id, closure_substs) = match closure_ty.sty {\n+                ty::TyClosure(def_id, substs) => (def_id, substs),\n+                _ => bug!(\"bad closure instance {:?}\", instance)\n+            };\n+\n+            trans_fn_once_adapter_shim(\n+                ccx,\n+                closure_def_id,\n+                closure_substs,\n+                instance,\n+                do_get_fn(\n+                    ccx,\n+                    Instance::new(closure_def_id, closure_substs.substs)\n+                )\n+            )\n+        }\n+        ty::InstanceDef::FnPtrShim(..) |\n+        ty::InstanceDef::Item(..) |\n+        ty::InstanceDef::Virtual(..) => {\n+            do_get_fn(ccx, instance)\n+        }\n+    }\n+}\n+\n+pub fn resolve_and_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    def_id: DefId,\n+                                    substs: &'tcx Substs<'tcx>)\n+                                    -> ValueRef\n+{\n+    get_fn(ccx, monomorphize::resolve(ccx.shared(), def_id, substs))\n+}"}, {"sha": "2113b9b203ced854a79ee54245baaf70ec67614f", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -656,8 +656,8 @@ fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instan\n         ty::InstanceDef::ClosureOnceShim {\n             call_once: _, closure_did: def_id\n         } => def_id,\n-        ty::InstanceDef::FnPtrShim(..) => return true,\n         ty::InstanceDef::Virtual(..) |\n+        ty::InstanceDef::FnPtrShim(..) => return true,\n         ty::InstanceDef::Intrinsic(_) => return false\n     };\n     match tcx.hir.get_if_local(def_id) {"}, {"sha": "9297c0108468a21e21b8480c247532e2fb7d3933", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -18,7 +18,7 @@ use rustc::hir::def::ExportMap;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n use debuginfo;\n-use callee::Callee;\n+use callee;\n use base;\n use declare;\n use glue::DropGlueKind;\n@@ -920,7 +920,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         let tcx = self.tcx();\n         let llfn = match tcx.lang_items.eh_personality() {\n             Some(def_id) if !base::wants_msvc_seh(self.sess()) => {\n-                Callee::def(self, def_id, tcx.intern_substs(&[])).reify(self)\n+                callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n             }\n             _ => {\n                 let name = if base::wants_msvc_seh(self.sess()) {\n@@ -948,7 +948,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         let tcx = self.tcx();\n         assert!(self.sess().target.target.options.custom_unwind_resume);\n         if let Some(def_id) = tcx.lang_items.eh_unwind_resume() {\n-            let llfn = Callee::def(self, def_id, tcx.intern_substs(&[])).reify(self);\n+            let llfn = callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n             unwresume.set(Some(llfn));\n             return llfn;\n         }"}, {"sha": "9a639ed21f1ac5a2a2b9191c21785bf07f3fd314", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -24,9 +24,10 @@ use rustc::ty::{self, layout, AdtDef, AdtKind, Ty, TypeFoldable};\n use rustc::ty::subst::Kind;\n use rustc::mir::tcx::LvalueTy;\n use mir::lvalue::LvalueRef;\n+use abi::FnType;\n use adt;\n use base::*;\n-use callee::Callee;\n+use callee::get_fn;\n use cleanup::CleanupScope;\n use common::*;\n use machine::*;\n@@ -45,11 +46,10 @@ pub fn trans_exchange_free_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, ptr: LvalueRef<\n     let content_ty = ptr.ty.to_ty(bcx.tcx());\n     let def_id = langcall(bcx.tcx(), None, \"\", BoxFreeFnLangItem);\n     let substs = bcx.tcx().mk_substs(iter::once(Kind::from(content_ty)));\n-    let callee = Callee::def(bcx.ccx, def_id, substs);\n+    let instance = monomorphize::resolve(bcx.ccx.shared(), def_id, substs);\n \n-    let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n-\n-    let llret = bcx.call(callee.reify(bcx.ccx),\n+    let fn_ty = FnType::from_instance(bcx.ccx, &instance, &[]);\n+    let llret = bcx.call(get_fn(bcx.ccx, instance),\n         &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize], None);\n     fn_ty.apply_attrs_callsite(llret);\n }\n@@ -258,16 +258,18 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n                 .find(|it| it.kind == ty::AssociatedKind::Method)\n                 .unwrap().def_id;\n             let self_type_substs = tcx.mk_substs_trait(t, &[]);\n-            let callee = Callee::def(bcx.ccx, drop_method, self_type_substs);\n-            let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n+            let drop_instance = monomorphize::resolve(\n+                bcx.ccx.shared(), drop_method, self_type_substs);\n+            let fn_ty = FnType::from_instance(bcx.ccx, &drop_instance, &[]);\n+            let llfn = get_fn(bcx.ccx, drop_instance);\n             let llret;\n             let args = &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize];\n             if let Some(landing_pad) = contents_scope.landing_pad {\n                 let normal_bcx = bcx.build_sibling_block(\"normal-return\");\n-                llret = bcx.invoke(callee.reify(ccx), args, normal_bcx.llbb(), landing_pad, None);\n+                llret = bcx.invoke(llfn, args, normal_bcx.llbb(), landing_pad, None);\n                 bcx = normal_bcx;\n             } else {\n-                llret = bcx.call(callee.reify(bcx.ccx), args, None);\n+                llret = bcx.call(llfn, args, None);\n             }\n             fn_ty.apply_attrs_callsite(llret);\n             contents_scope.trans(&bcx);"}, {"sha": "6b823756c8eabb6eac8d1e3b1a68b554625e8f50", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 3, "deletions": 75, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -8,20 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use attributes;\n-use llvm::{ValueRef, get_params};\n+use llvm::ValueRef;\n use rustc::traits;\n-use callee::{Callee, CalleeData};\n+use callee;\n use common::*;\n use builder::Builder;\n use consts;\n-use declare;\n use glue;\n use machine;\n-use monomorphize::Instance;\n use type_::Type;\n use type_of::*;\n-use back::symbol_names;\n use value::Value;\n use rustc::ty;\n \n@@ -42,74 +38,6 @@ pub fn get_virtual_method<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     ptr\n }\n \n-/// Generate a shim function that allows an object type like `SomeTrait` to\n-/// implement the type `SomeTrait`. Imagine a trait definition:\n-///\n-///    trait SomeTrait { fn get(&self) -> i32; ... }\n-///\n-/// And a generic bit of code:\n-///\n-///    fn foo<T:SomeTrait>(t: &T) {\n-///        let x = SomeTrait::get;\n-///        x(t)\n-///    }\n-///\n-/// What is the value of `x` when `foo` is invoked with `T=SomeTrait`?\n-/// The answer is that it is a shim function generated by this routine:\n-///\n-///    fn shim(t: &SomeTrait) -> i32 {\n-///        // ... call t.get() virtually ...\n-///    }\n-///\n-/// In fact, all virtual calls can be thought of as normal trait calls\n-/// that go through this shim function.\n-pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                                   callee: Callee<'tcx>)\n-                                   -> ValueRef {\n-    debug!(\"trans_object_shim({:?})\", callee);\n-\n-    let function_name = match callee.ty.sty {\n-        ty::TyFnDef(def_id, substs, _) => {\n-            let instance = Instance::new(def_id, substs);\n-            symbol_names::symbol_name(instance, ccx.shared())\n-        }\n-        _ => bug!()\n-    };\n-\n-    let llfn = declare::define_internal_fn(ccx, &function_name, callee.ty);\n-    attributes::set_frame_pointer_elimination(ccx, llfn);\n-\n-    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n-\n-    let mut llargs = get_params(llfn);\n-    let fn_ret = callee.ty.fn_ret();\n-    let fn_ty = callee.direct_fn_type(ccx, &[]);\n-\n-    let fn_ptr = match callee.data {\n-        CalleeData::Virtual(idx) => {\n-            let fn_ptr = get_virtual_method(&bcx,\n-                llargs.remove(fn_ty.ret.is_indirect() as usize + 1), idx);\n-            let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n-            bcx.pointercast(fn_ptr, llty)\n-        },\n-        _ => bug!(\"trans_object_shim called with non-virtual callee\"),\n-    };\n-    let llret = bcx.call(fn_ptr, &llargs, None);\n-    fn_ty.apply_attrs_callsite(llret);\n-\n-    if fn_ret.0.is_never() {\n-        bcx.unreachable();\n-    } else {\n-        if fn_ty.ret.is_indirect() || fn_ty.ret.is_ignore() {\n-            bcx.ret_void();\n-        } else {\n-            bcx.ret(llret);\n-        }\n-    }\n-\n-    llfn\n-}\n-\n /// Creates a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n ///\n@@ -150,7 +78,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let trait_ref = trait_ref.with_self_ty(tcx, ty);\n         let methods = traits::get_vtable_methods(tcx, trait_ref).map(|opt_mth| {\n             opt_mth.map_or(nullptr, |(def_id, substs)| {\n-                Callee::def(ccx, def_id, substs).reify(ccx)\n+                callee::resolve_and_get_fn(ccx, def_id, substs)\n             })\n         });\n         components.extend(methods);"}, {"sha": "761f6b208e747eeaab374a2388e2b39af6014ed3", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 80, "deletions": 76, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -16,13 +16,14 @@ use rustc::ty::{self, layout, TypeFoldable};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n use base::{self, Lifetime};\n-use callee::{Callee, CalleeData, Fn, Intrinsic, Virtual};\n+use callee;\n use builder::Builder;\n use common::{self, Funclet};\n use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use machine::llalign_of_min;\n use meth;\n+use monomorphize;\n use type_of::{self, align_of};\n use glue;\n use type_::Type;\n@@ -340,9 +341,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n-                let callee = Callee::def(bcx.ccx, def_id,\n-                    bcx.ccx.empty_substs_for_def_id(def_id));\n-                let llfn = callee.reify(bcx.ccx);\n+                let instance = ty::Instance::mono(bcx.tcx(), def_id);\n+                let llfn = callee::get_fn(bcx.ccx, instance);\n \n                 // Translate the actual panic invoke/call.\n                 if let Some(unwind) = cleanup {\n@@ -365,30 +365,30 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n \n-                let (mut callee, sig) = match callee.ty.sty {\n+                let (instance, mut llfn, sig) = match callee.ty.sty {\n                     ty::TyFnDef(def_id, substs, sig) => {\n-                        (Callee::def(bcx.ccx, def_id, substs), sig)\n+                        (Some(monomorphize::resolve(bcx.ccx.shared(), def_id, substs)),\n+                         None,\n+                         sig)\n                     }\n                     ty::TyFnPtr(sig) => {\n-                        (Callee {\n-                            data: Fn(callee.immediate()),\n-                            ty: callee.ty\n-                        }, sig)\n+                        (None,\n+                         Some(callee.immediate()),\n+                         sig)\n                     }\n                     _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n-\n+                let def = instance.map(|i| i.def);\n                 let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                 let abi = sig.abi;\n \n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n-                let intrinsic = match (&callee.ty.sty, &callee.data) {\n-                    (&ty::TyFnDef(def_id, ..), &Intrinsic) => {\n-                        Some(bcx.tcx().item_name(def_id).as_str())\n-                    }\n+                let intrinsic = match def {\n+                    Some(ty::InstanceDef::Intrinsic(def_id))\n+                        => Some(bcx.tcx().item_name(def_id).as_str()),\n                     _ => None\n                 };\n-                let mut intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n+                let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n \n                 if intrinsic == Some(\"move_val_init\") {\n                     let &(_, target) = destination.as_ref().unwrap();\n@@ -412,15 +412,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let op_ty = op_arg.ty(&self.mir, bcx.tcx());\n                     self.monomorphize(&op_ty)\n                 }).collect::<Vec<_>>();\n-                let fn_ty = callee.direct_fn_type(bcx.ccx, &extra_args);\n+\n+                let fn_ty = match def {\n+                    Some(ty::InstanceDef::Virtual(..)) => {\n+                        FnType::new_vtable(bcx.ccx, sig, &extra_args)\n+                    }\n+                    _ => FnType::new(bcx.ccx, sig, &extra_args)\n+                };\n \n                 if intrinsic == Some(\"drop_in_place\") {\n                     let &(_, target) = destination.as_ref().unwrap();\n-                    let ty = if let ty::TyFnDef(_, substs, _) = callee.ty.sty {\n-                        substs.type_at(0)\n-                    } else {\n-                        bug!(\"Unexpected ty: {}\", callee.ty);\n-                    };\n+                    let ty = instance.unwrap().substs.type_at(0);\n \n                     // Double check for necessity to drop\n                     if !bcx.ccx.shared().type_needs_drop(ty) {\n@@ -430,8 +432,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                     let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n                     let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n-                    callee.data = Fn(bcx.pointercast(drop_fn, llty));\n-                    intrinsic = None;\n+                    llfn = Some(bcx.pointercast(drop_fn, llty));\n                 }\n \n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n@@ -440,12 +441,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Prepare the return value destination\n                 let ret_dest = if let Some((ref dest, _)) = *destination {\n-                    let is_intrinsic = if let Intrinsic = callee.data {\n-                        true\n-                    } else {\n-                        false\n-                    };\n-                    self.make_return_dest(&bcx, dest, &fn_ty.ret, &mut llargs, is_intrinsic)\n+                    let is_intrinsic = intrinsic.is_some();\n+                    self.make_return_dest(&bcx, dest, &fn_ty.ret, &mut llargs,\n+                                          is_intrinsic)\n                 } else {\n                     ReturnDest::Nothing\n                 };\n@@ -483,52 +481,56 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                     let op = self.trans_operand(&bcx, arg);\n                     self.trans_argument(&bcx, op, &mut llargs, &fn_ty,\n-                                        &mut idx, &mut callee.data);\n+                                        &mut idx, &mut llfn, &def);\n                 }\n                 if let Some(tup) = untuple {\n                     self.trans_arguments_untupled(&bcx, tup, &mut llargs, &fn_ty,\n-                                                  &mut idx, &mut callee.data)\n+                                                  &mut idx, &mut llfn, &def)\n                 }\n \n-                let fn_ptr = match callee.data {\n-                    Intrinsic => {\n-                        use intrinsic::trans_intrinsic_call;\n-\n-                        let (dest, llargs) = match ret_dest {\n-                            _ if fn_ty.ret.is_indirect() => {\n-                                (llargs[0], &llargs[1..])\n-                            }\n-                            ReturnDest::Nothing => {\n-                                (C_undef(fn_ty.ret.original_ty.ptr_to()), &llargs[..])\n-                            }\n-                            ReturnDest::IndirectOperand(dst, _) |\n-                            ReturnDest::Store(dst) => (dst, &llargs[..]),\n-                            ReturnDest::DirectOperand(_) =>\n-                                bug!(\"Cannot use direct operand with an intrinsic call\")\n-                        };\n-\n-                        trans_intrinsic_call(&bcx, callee.ty, &fn_ty, &llargs, dest,\n-                            terminator.source_info.span);\n+                if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n+                    use intrinsic::trans_intrinsic_call;\n \n-                        if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                            // Make a fake operand for store_return\n-                            let op = OperandRef {\n-                                val: Ref(dst, Alignment::AbiAligned),\n-                                ty: sig.output(),\n-                            };\n-                            self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n+                    let (dest, llargs) = match ret_dest {\n+                        _ if fn_ty.ret.is_indirect() => {\n+                            (llargs[0], &llargs[1..])\n                         }\n-\n-                        if let Some((_, target)) = *destination {\n-                            funclet_br(self, bcx, target);\n-                        } else {\n-                            bcx.unreachable();\n+                        ReturnDest::Nothing => {\n+                            (C_undef(fn_ty.ret.original_ty.ptr_to()), &llargs[..])\n                         }\n+                        ReturnDest::IndirectOperand(dst, _) |\n+                        ReturnDest::Store(dst) => (dst, &llargs[..]),\n+                        ReturnDest::DirectOperand(_) =>\n+                            bug!(\"Cannot use direct operand with an intrinsic call\")\n+                    };\n \n-                        return;\n+                    let callee_ty = common::instance_ty(\n+                        bcx.ccx.shared(), instance.as_ref().unwrap());\n+                    trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &llargs, dest,\n+                                         terminator.source_info.span);\n+\n+                    if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n+                        // Make a fake operand for store_return\n+                        let op = OperandRef {\n+                            val: Ref(dst, Alignment::AbiAligned),\n+                            ty: sig.output(),\n+                        };\n+                        self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n+                    }\n+\n+                    if let Some((_, target)) = *destination {\n+                        funclet_br(self, bcx, target);\n+                    } else {\n+                        bcx.unreachable();\n                     }\n-                    Fn(f) => f,\n-                    Virtual(_) => bug!(\"Virtual fn ptr not extracted\")\n+\n+                    return;\n+                }\n+\n+                let fn_ptr = match (llfn, instance) {\n+                    (Some(llfn), _) => llfn,\n+                    (None, Some(instance)) => callee::get_fn(bcx.ccx, instance),\n+                    _ => span_bug!(span, \"no llfn for call\"),\n                 };\n \n                 // Many different ways to call a function handled here\n@@ -578,16 +580,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                       llargs: &mut Vec<ValueRef>,\n                       fn_ty: &FnType,\n                       next_idx: &mut usize,\n-                      callee: &mut CalleeData) {\n+                      llfn: &mut Option<ValueRef>,\n+                      def: &Option<ty::InstanceDef<'tcx>>) {\n         if let Pair(a, b) = op.val {\n             // Treat the values in a fat pointer separately.\n             if common::type_is_fat_ptr(bcx.ccx, op.ty) {\n                 let (ptr, meta) = (a, b);\n                 if *next_idx == 0 {\n-                    if let Virtual(idx) = *callee {\n-                        let llfn = meth::get_virtual_method(bcx, meta, idx);\n+                    if let Some(ty::InstanceDef::Virtual(_, idx)) = *def {\n+                        let llmeth = meth::get_virtual_method(bcx, meta, idx);\n                         let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n-                        *callee = Fn(bcx.pointercast(llfn, llty));\n+                        *llfn = Some(bcx.pointercast(llmeth, llty));\n                     }\n                 }\n \n@@ -596,8 +599,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // We won't be checking the type again.\n                     ty: bcx.tcx().types.err\n                 };\n-                self.trans_argument(bcx, imm_op(ptr), llargs, fn_ty, next_idx, callee);\n-                self.trans_argument(bcx, imm_op(meta), llargs, fn_ty, next_idx, callee);\n+                self.trans_argument(bcx, imm_op(ptr), llargs, fn_ty, next_idx, llfn, def);\n+                self.trans_argument(bcx, imm_op(meta), llargs, fn_ty, next_idx, llfn, def);\n                 return;\n             }\n         }\n@@ -660,7 +663,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 llargs: &mut Vec<ValueRef>,\n                                 fn_ty: &FnType,\n                                 next_idx: &mut usize,\n-                                callee: &mut CalleeData) {\n+                                llfn: &mut Option<ValueRef>,\n+                                def: &Option<ty::InstanceDef<'tcx>>) {\n         let tuple = self.trans_operand(bcx, operand);\n \n         let arg_types = match tuple.ty.sty {\n@@ -686,7 +690,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         val: val,\n                         ty: ty\n                     };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n                 }\n \n             }\n@@ -708,7 +712,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         val: Immediate(elem),\n                         ty: ty\n                     };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n                 }\n             }\n             Pair(a, b) => {\n@@ -724,7 +728,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         val: Immediate(elem),\n                         ty: ty\n                     };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n                 }\n             }\n         }"}, {"sha": "107b0982af982b9d606927696c18677d568db207", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -23,7 +23,7 @@ use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr, machine};\n-use callee::Callee;\n+use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n@@ -565,8 +565,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n                             ty::TyFnDef(def_id, substs, _) => {\n-                                Callee::def(self.ccx, def_id, substs)\n-                                    .reify(self.ccx)\n+                                callee::resolve_and_get_fn(self.ccx, def_id, substs)\n                             }\n                             _ => {\n                                 span_bug!(span, \"{} cannot be reified to a fn ptr\",\n@@ -589,8 +588,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 let input = tcx.erase_late_bound_regions_and_normalize(&input);\n                                 let substs = tcx.mk_substs([operand.ty, input]\n                                     .iter().cloned().map(Kind::from));\n-                                Callee::def(self.ccx, call_once, substs)\n-                                    .reify(self.ccx)\n+                                callee::resolve_and_get_fn(self.ccx, call_once, substs)\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.ty)"}, {"sha": "3832c21d10a49c094d3efda5d39aa664b17edfe3", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a4266f1f4ce9dac5a6ef588443b7cac911d265/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=65a4266f1f4ce9dac5a6ef588443b7cac911d265", "patch": "@@ -19,7 +19,7 @@ use middle::lang_items::ExchangeMallocFnLangItem;\n \n use base;\n use builder::Builder;\n-use callee::Callee;\n+use callee;\n use common::{self, val_ty, C_bool, C_null, C_uint};\n use common::{C_integral};\n use adt;\n@@ -183,8 +183,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         match operand.ty.sty {\n                             ty::TyFnDef(def_id, substs, _) => {\n                                 OperandValue::Immediate(\n-                                    Callee::def(bcx.ccx, def_id, substs)\n-                                        .reify(bcx.ccx))\n+                                    callee::resolve_and_get_fn(bcx.ccx, def_id, substs))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be reified to a fn ptr\", operand.ty)\n@@ -208,8 +207,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 let substs = bcx.tcx().mk_substs([operand.ty, input]\n                                     .iter().cloned().map(Kind::from));\n                                 OperandValue::Immediate(\n-                                    Callee::def(bcx.ccx, call_once, substs)\n-                                        .reify(bcx.ccx))\n+                                    callee::resolve_and_get_fn(bcx.ccx, call_once, substs)\n+                                )\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.ty)\n@@ -463,8 +462,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_ty, s));\n                     }\n                 };\n-                let r = Callee::def(bcx.ccx, def_id, bcx.tcx().intern_substs(&[]))\n-                    .reify(bcx.ccx);\n+                let instance = ty::Instance::mono(bcx.tcx(), def_id);\n+                let r = callee::get_fn(bcx.ccx, instance);\n                 let val = bcx.pointercast(bcx.call(r, &[llsize, llalign], None), llty_ptr);\n \n                 let operand = OperandRef {"}]}