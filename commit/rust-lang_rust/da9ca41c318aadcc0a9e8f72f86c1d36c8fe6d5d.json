{"sha": "da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "node_id": "C_kwDOAAsO6NoAKGRhOWNhNDFjMzE4YWFkY2MwYTllOGY3MmY4NmMxZDM2YzhmZTZkNWQ", "commit": {"author": {"name": "Tomoaki Kawada", "email": "kawada@kmckk.co.jp", "date": "2021-09-28T02:20:46Z"}, "committer": {"name": "Tomoaki Kawada", "email": "kawada@kmckk.co.jp", "date": "2021-09-28T02:31:47Z"}, "message": "Add SOLID targets\n\nSOLID[1] is an embedded development platform provided by Kyoto\nMicrocomputer Co., Ltd. This commit introduces a basic Tier 3 support\nfor SOLID.\n\n# New Targets\n\nThe following targets are added:\n\n - `aarch64-kmc-solid_asp3`\n - `armv7a-kmc-solid_asp3-eabi`\n - `armv7a-kmc-solid_asp3-eabihf`\n\nSOLID's target software system can be divided into two parts: an\nRTOS kernel, which is responsible for threading and synchronization,\nand Core Services, which provides filesystems, networking, and other\nthings. The RTOS kernel is a \u03bcITRON4.0[2][3]-derived kernel based on\nthe open-source TOPPERS RTOS kernels[4]. For uniprocessor systems\n(more precisely, systems where only one processor core is allocated for\nSOLID), this will be the TOPPERS/ASP3 kernel. As \u03bcITRON is\ntraditionally only specified at the source-code level, the ABI is\nunique to each implementation, which is why `asp3` is included in the\ntarget names.\n\nMore targets could be added later, as we support other base kernels\n(there are at least three at the point of writing) and are interested\nin supporting other processor architectures in the future.\n\n# C Compiler\n\nAlthough SOLID provides its own supported C/C++ build toolchain, GNU Arm\nEmbedded Toolchain seems to work for the purpose of building Rust.\n\n# Unresolved Questions\n\nA \u03bcITRON4 kernel can support `Thread::unpark` natively, but it's not\nused by this commit's implementation because the underlying kernel\nfeature is also used to implement `Condvar`, and it's unclear whether\n`std` should guarantee that parking tokens are not clobbered by other\nsynchronization primitives.\n\n# Unsupported or Unimplemented Features\n\nMost features are implemented. The following features are not\nimplemented due to the lack of native support:\n\n- `fs::File::{file_attr, truncate, duplicate, set_permissions}`\n- `fs::{symlink, link, canonicalize}`\n- Process creation\n- Command-line arguments\n\nBacktrace generation is not really a good fit for embedded targets, so\nit's intentionally left unimplemented. Unwinding is functional, however.\n\n## Dynamic Linking\n\nDynamic linking is not supported. The target platform supports dynamic\nlinking, but enabling this in Rust causes several problems.\n\n - The linker invocation used to build the shared object of `std` is\n   too long for the platform-provided linker to handle.\n\n - A linker script with specific requirements is required for the\n   compiled shared object to be actually loadable.\n\nAs such, we decided to disable dynamic linking for now. Regardless, the\nusers can try to create shared objects by manually invoking the linker.\n\n## Executable\n\nBuilding an executable is not supported as the notion of \"executable\nfiles\" isn't well-defined for these targets.\n\n[1] https://solid.kmckk.com/SOLID/\n[2] http://ertl.jp/ITRON/SPEC/mitron4-e.html\n[3] https://en.wikipedia.org/wiki/ITRON_project\n[4] https://toppers.jp/", "tree": {"sha": "3bf3ab3b2b4d8e63b599e0c78c5e3ae13364584b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bf3ab3b2b4d8e63b599e0c78c5e3ae13364584b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "html_url": "https://github.com/rust-lang/rust/commit/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/comments", "author": {"login": "kawadakk", "id": 81723441, "node_id": "MDQ6VXNlcjgxNzIzNDQx", "avatar_url": "https://avatars.githubusercontent.com/u/81723441?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kawadakk", "html_url": "https://github.com/kawadakk", "followers_url": "https://api.github.com/users/kawadakk/followers", "following_url": "https://api.github.com/users/kawadakk/following{/other_user}", "gists_url": "https://api.github.com/users/kawadakk/gists{/gist_id}", "starred_url": "https://api.github.com/users/kawadakk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kawadakk/subscriptions", "organizations_url": "https://api.github.com/users/kawadakk/orgs", "repos_url": "https://api.github.com/users/kawadakk/repos", "events_url": "https://api.github.com/users/kawadakk/events{/privacy}", "received_events_url": "https://api.github.com/users/kawadakk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kawadakk", "id": 81723441, "node_id": "MDQ6VXNlcjgxNzIzNDQx", "avatar_url": "https://avatars.githubusercontent.com/u/81723441?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kawadakk", "html_url": "https://github.com/kawadakk", "followers_url": "https://api.github.com/users/kawadakk/followers", "following_url": "https://api.github.com/users/kawadakk/following{/other_user}", "gists_url": "https://api.github.com/users/kawadakk/gists{/gist_id}", "starred_url": "https://api.github.com/users/kawadakk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kawadakk/subscriptions", "organizations_url": "https://api.github.com/users/kawadakk/orgs", "repos_url": "https://api.github.com/users/kawadakk/repos", "events_url": "https://api.github.com/users/kawadakk/events{/privacy}", "received_events_url": "https://api.github.com/users/kawadakk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "293b8f2c11cbec03f0d4daae6b82ed7541ebbf4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/293b8f2c11cbec03f0d4daae6b82ed7541ebbf4e", "html_url": "https://github.com/rust-lang/rust/commit/293b8f2c11cbec03f0d4daae6b82ed7541ebbf4e"}], "stats": {"total": 4062, "additions": 4062, "deletions": 0}, "files": [{"sha": "61e3be617e9c1c6915bc3a309c54c6cd18ef82ee", "filename": "compiler/rustc_target/src/spec/aarch64_kmc_solid_asp3.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_kmc_solid_asp3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_kmc_solid_asp3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_kmc_solid_asp3.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,19 @@\n+use super::{RelocModel, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    let base = super::solid_base::opts(\"asp3\");\n+    Target {\n+        llvm_target: \"aarch64-unknown-none\".to_string(),\n+        pointer_width: 64,\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        options: TargetOptions {\n+            linker: Some(\"aarch64-kmc-elf-gcc\".to_owned()),\n+            features: \"+neon,+fp-armv8\".to_string(),\n+            relocation_model: RelocModel::Static,\n+            disable_redzone: true,\n+            max_atomic_width: Some(128),\n+            ..base\n+        },\n+    }\n+}"}, {"sha": "344c48022b2fa5a24d3d39fe7422e9b1c116c0a2", "filename": "compiler/rustc_target/src/spec/armv7a_kmc_solid_asp3_eabi.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_kmc_solid_asp3_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_kmc_solid_asp3_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_kmc_solid_asp3_eabi.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,19 @@\n+use super::{RelocModel, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    let base = super::solid_base::opts(\"asp3\");\n+    Target {\n+        llvm_target: \"armv7a-none-eabi\".to_string(),\n+        pointer_width: 32,\n+        data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        options: TargetOptions {\n+            linker: Some(\"arm-kmc-eabi-gcc\".to_owned()),\n+            features: \"+v7,+soft-float,+thumb2,-neon\".to_string(),\n+            relocation_model: RelocModel::Static,\n+            disable_redzone: true,\n+            max_atomic_width: Some(64),\n+            ..base\n+        },\n+    }\n+}"}, {"sha": "375502478fe9753c3d90b6fd42d6f664f9247d33", "filename": "compiler/rustc_target/src/spec/armv7a_kmc_solid_asp3_eabihf.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_kmc_solid_asp3_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_kmc_solid_asp3_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_kmc_solid_asp3_eabihf.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,19 @@\n+use super::{RelocModel, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    let base = super::solid_base::opts(\"asp3\");\n+    Target {\n+        llvm_target: \"armv7a-none-eabihf\".to_string(),\n+        pointer_width: 32,\n+        data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        options: TargetOptions {\n+            linker: Some(\"arm-kmc-eabi-gcc\".to_owned()),\n+            features: \"+v7,+vfp3,-d32,+thumb2,-neon\".to_string(),\n+            relocation_model: RelocModel::Static,\n+            disable_redzone: true,\n+            max_atomic_width: Some(64),\n+            ..base\n+        },\n+    }\n+}"}, {"sha": "d18e5823cb80c1d406bdf9ec3bfe7d5c5451e1a9", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -75,6 +75,7 @@ mod netbsd_base;\n mod openbsd_base;\n mod redox_base;\n mod solaris_base;\n+mod solid_base;\n mod thumb_base;\n mod uefi_msvc_base;\n mod vxworks_base;\n@@ -932,6 +933,10 @@ supported_targets! {\n     (\"powerpc-wrs-vxworks-spe\", powerpc_wrs_vxworks_spe),\n     (\"powerpc64-wrs-vxworks\", powerpc64_wrs_vxworks),\n \n+    (\"aarch64-kmc-solid_asp3\", aarch64_kmc_solid_asp3),\n+    (\"armv7a-kmc-solid_asp3-eabi\", armv7a_kmc_solid_asp3_eabi),\n+    (\"armv7a-kmc-solid_asp3-eabihf\", armv7a_kmc_solid_asp3_eabihf),\n+\n     (\"mipsel-sony-psp\", mipsel_sony_psp),\n     (\"mipsel-unknown-none\", mipsel_unknown_none),\n     (\"thumbv4t-none-eabi\", thumbv4t_none_eabi),"}, {"sha": "c6a279d92e839d4ac13c79e12ba1c66f863c0285", "filename": "compiler/rustc_target/src/spec/solid_base.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsolid_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsolid_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsolid_base.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,12 @@\n+use super::FramePointer;\n+use crate::spec::TargetOptions;\n+\n+pub fn opts(kernel: &str) -> TargetOptions {\n+    TargetOptions {\n+        os: format!(\"solid_{}\", kernel),\n+        vendor: \"kmc\".to_string(),\n+        frame_pointer: FramePointer::NonLeaf,\n+        has_elf_tls: true,\n+        ..Default::default()\n+    }\n+}"}, {"sha": "ac75ce7f2211046ac7a17f3d25b170a9dcbb5b46", "filename": "library/panic_abort/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fpanic_abort%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fpanic_abort%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Flib.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -44,6 +44,7 @@ pub unsafe extern \"C-unwind\" fn __rust_start_panic(_payload: *mut &mut dyn BoxMe\n                 libc::abort();\n             }\n         } else if #[cfg(any(target_os = \"hermit\",\n+                            target_os = \"solid_asp3\",\n                             all(target_vendor = \"fortanix\", target_env = \"sgx\")\n         ))] {\n             unsafe fn abort() -> ! {"}, {"sha": "b5d0ca2572c93adc9841a72943b788d67e190b5e", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -45,6 +45,7 @@ cfg_if::cfg_if! {\n     } else if #[cfg(any(\n         all(target_family = \"windows\", target_env = \"gnu\"),\n         target_os = \"psp\",\n+        target_os = \"solid_asp3\",\n         all(target_family = \"unix\", not(target_os = \"espidf\")),\n         all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     ))] {"}, {"sha": "cc7184d57f178a26a94f1139d72c21cad54c6015", "filename": "library/std/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fbuild.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -27,6 +27,7 @@ fn main() {\n         || target.contains(\"wasm32\")\n         || target.contains(\"asmjs\")\n         || target.contains(\"espidf\")\n+        || target.contains(\"solid\")\n     {\n         // These platforms don't have any special requirements.\n     } else {"}, {"sha": "90c30313dbbda7bc1e94e2d97ac2ecd7af5b1884", "filename": "library/std/src/os/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmod.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -138,6 +138,8 @@ pub mod redox;\n #[cfg(target_os = \"solaris\")]\n pub mod solaris;\n \n+#[cfg(target_os = \"solid_asp3\")]\n+pub mod solid;\n #[cfg(target_os = \"vxworks\")]\n pub mod vxworks;\n "}, {"sha": "aaa2070a6abe90b7710c395ff56cbb80156b3e05", "filename": "library/std/src/os/solid/ffi.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fos%2Fsolid%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fos%2Fsolid%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fsolid%2Fffi.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,41 @@\n+//! SOLID-specific extension to the primitives in the `std::ffi` module\n+//!\n+//! # Examples\n+//!\n+//! ```\n+//! use std::ffi::OsString;\n+//! use std::os::solid::ffi::OsStringExt;\n+//!\n+//! let bytes = b\"foo\".to_vec();\n+//!\n+//! // OsStringExt::from_vec\n+//! let os_string = OsString::from_vec(bytes);\n+//! assert_eq!(os_string.to_str(), Some(\"foo\"));\n+//!\n+//! // OsStringExt::into_vec\n+//! let bytes = os_string.into_vec();\n+//! assert_eq!(bytes, b\"foo\");\n+//! ```\n+//!\n+//! ```\n+//! use std::ffi::OsStr;\n+//! use std::os::solid::ffi::OsStrExt;\n+//!\n+//! let bytes = b\"foo\";\n+//!\n+//! // OsStrExt::from_bytes\n+//! let os_str = OsStr::from_bytes(bytes);\n+//! assert_eq!(os_str.to_str(), Some(\"foo\"));\n+//!\n+//! // OsStrExt::as_bytes\n+//! let bytes = os_str.as_bytes();\n+//! assert_eq!(bytes, b\"foo\");\n+//! ```\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+#[path = \"../unix/ffi/os_str.rs\"]\n+mod os_str;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::os_str::{OsStrExt, OsStringExt};"}, {"sha": "33cc5a015b5dcadb0e603badf034715c90d9166c", "filename": "library/std/src/os/solid/io.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fos%2Fsolid%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fos%2Fsolid%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fsolid%2Fio.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,113 @@\n+//! SOLID-specific extensions to general I/O primitives\n+\n+#![deny(unsafe_op_in_unsafe_fn)]\n+#![unstable(feature = \"solid_ext\", issue = \"none\")]\n+\n+use crate::net;\n+use crate::sys;\n+use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n+\n+/// Raw file descriptors.\n+pub type RawFd = i32;\n+\n+/// A trait to extract the raw SOLID Sockets file descriptor from an underlying\n+/// object.\n+pub trait AsRawFd {\n+    /// Extracts the raw file descriptor.\n+    ///\n+    /// This method does **not** pass ownership of the raw file descriptor\n+    /// to the caller. The descriptor is only guaranteed to be valid while\n+    /// the original object has not yet been destroyed.\n+    fn as_raw_fd(&self) -> RawFd;\n+}\n+\n+/// A trait to express the ability to construct an object from a raw file\n+/// descriptor.\n+pub trait FromRawFd {\n+    /// Constructs a new instance of `Self` from the given raw file\n+    /// descriptor.\n+    ///\n+    /// This function **consumes ownership** of the specified file\n+    /// descriptor. The returned object will take responsibility for closing\n+    /// it when the object goes out of scope.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n+}\n+\n+/// A trait to express the ability to consume an object and acquire ownership of\n+/// its raw file descriptor.\n+pub trait IntoRawFd {\n+    /// Consumes this object, returning the raw underlying file descriptor.\n+    ///\n+    /// This function **transfers ownership** of the underlying file descriptor\n+    /// to the caller. Callers are then the unique owners of the file descriptor\n+    /// and must close the descriptor once it's no longer needed.\n+    fn into_raw_fd(self) -> RawFd;\n+}\n+\n+#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n+impl AsRawFd for RawFd {\n+    #[inline]\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self\n+    }\n+}\n+#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n+impl IntoRawFd for RawFd {\n+    #[inline]\n+    fn into_raw_fd(self) -> RawFd {\n+        self\n+    }\n+}\n+#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n+impl FromRawFd for RawFd {\n+    #[inline]\n+    unsafe fn from_raw_fd(fd: RawFd) -> RawFd {\n+        fd\n+    }\n+}\n+\n+macro_rules! impl_as_raw_fd {\n+    ($($t:ident)*) => {$(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl AsRawFd for net::$t {\n+            #[inline]\n+            fn as_raw_fd(&self) -> RawFd {\n+                *self.as_inner().socket().as_inner()\n+            }\n+        }\n+    )*};\n+}\n+impl_as_raw_fd! { TcpStream TcpListener UdpSocket }\n+\n+macro_rules! impl_from_raw_fd {\n+    ($($t:ident)*) => {$(\n+        #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+        impl FromRawFd for net::$t {\n+            #[inline]\n+            unsafe fn from_raw_fd(fd: RawFd) -> net::$t {\n+                let socket = sys::net::Socket::from_inner(fd);\n+                net::$t::from_inner(sys_common::net::$t::from_inner(socket))\n+            }\n+        }\n+    )*};\n+}\n+impl_from_raw_fd! { TcpStream TcpListener UdpSocket }\n+\n+macro_rules! impl_into_raw_fd {\n+    ($($t:ident)*) => {$(\n+        #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+        impl IntoRawFd for net::$t {\n+            #[inline]\n+            fn into_raw_fd(self) -> RawFd {\n+                self.into_inner().into_socket().into_inner()\n+            }\n+        }\n+    )*};\n+}\n+impl_into_raw_fd! { TcpStream TcpListener UdpSocket }"}, {"sha": "4328ba7c340229330ac78018703c82a7a364b047", "filename": "library/std/src/os/solid/mod.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fos%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fos%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fsolid%2Fmod.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,17 @@\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+pub mod ffi;\n+pub mod io;\n+\n+/// A prelude for conveniently writing platform-specific code.\n+///\n+/// Includes all extension traits, and some important type definitions.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod prelude {\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::ffi::{OsStrExt, OsStringExt};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+}"}, {"sha": "f99ee4fa897eabb041adfaef6f6bb3420f449ee4", "filename": "library/std/src/sys/itron/abi.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fabi.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,155 @@\n+//! ABI for \u03bcITRON derivatives\n+pub type int_t = crate::os::raw::c_int;\n+pub type uint_t = crate::os::raw::c_uint;\n+pub type bool_t = int_t;\n+\n+/// Kernel object ID\n+pub type ID = int_t;\n+\n+/// The current task.\n+pub const TSK_SELF: ID = 0;\n+\n+/// Relative time\n+pub type RELTIM = u32;\n+\n+/// Timeout (a valid `RELTIM` value or `TMO_FEVR`)\n+pub type TMO = u32;\n+\n+/// The infinite timeout value\n+pub const TMO_FEVR: TMO = TMO::MAX;\n+\n+/// The maximum valid value of `RELTIM`\n+pub const TMAX_RELTIM: RELTIM = 4_000_000_000;\n+\n+/// System time\n+pub type SYSTIM = u64;\n+\n+/// Error code type\n+pub type ER = int_t;\n+\n+/// Error code type, `ID` on success\n+pub type ER_ID = int_t;\n+\n+/// Task or interrupt priority\n+pub type PRI = int_t;\n+\n+/// The special value of `PRI` representing the current task's priority.\n+pub const TPRI_SELF: PRI = 0;\n+\n+/// Object attributes\n+pub type ATR = uint_t;\n+\n+/// Use the priority inheritance protocol\n+#[cfg(target_os = \"solid_asp3\")]\n+pub const TA_INHERIT: ATR = 0x02;\n+\n+/// Activate the task on creation\n+pub const TA_ACT: ATR = 0x01;\n+\n+/// The maximum count of a semaphore\n+pub const TMAX_MAXSEM: uint_t = uint_t::MAX;\n+\n+/// Callback parameter\n+pub type EXINF = isize;\n+\n+/// Task entrypoint\n+pub type TASK = Option<unsafe extern \"C\" fn(EXINF)>;\n+\n+// Error codes\n+pub const E_OK: ER = 0;\n+pub const E_SYS: ER = -5;\n+pub const E_NOSPT: ER = -9;\n+pub const E_RSFN: ER = -10;\n+pub const E_RSATR: ER = -11;\n+pub const E_PAR: ER = -17;\n+pub const E_ID: ER = -18;\n+pub const E_CTX: ER = -25;\n+pub const E_MACV: ER = -26;\n+pub const E_OACV: ER = -27;\n+pub const E_ILUSE: ER = -28;\n+pub const E_NOMEM: ER = -33;\n+pub const E_NOID: ER = -34;\n+pub const E_NORES: ER = -35;\n+pub const E_OBJ: ER = -41;\n+pub const E_NOEXS: ER = -42;\n+pub const E_QOVR: ER = -43;\n+pub const E_RLWAI: ER = -49;\n+pub const E_TMOUT: ER = -50;\n+pub const E_DLT: ER = -51;\n+pub const E_CLS: ER = -52;\n+pub const E_RASTER: ER = -53;\n+pub const E_WBLK: ER = -57;\n+pub const E_BOVR: ER = -58;\n+pub const E_COMM: ER = -65;\n+\n+#[derive(Clone, Copy)]\n+#[repr(C)]\n+pub struct T_CSEM {\n+    pub sematr: ATR,\n+    pub isemcnt: uint_t,\n+    pub maxsem: uint_t,\n+}\n+\n+#[derive(Clone, Copy)]\n+#[repr(C)]\n+pub struct T_CMTX {\n+    pub mtxatr: ATR,\n+    pub ceilpri: PRI,\n+}\n+\n+#[derive(Clone, Copy)]\n+#[repr(C)]\n+pub struct T_CTSK {\n+    pub tskatr: ATR,\n+    pub exinf: EXINF,\n+    pub task: TASK,\n+    pub itskpri: PRI,\n+    pub stksz: usize,\n+    pub stk: *mut u8,\n+}\n+\n+extern \"C\" {\n+    #[link_name = \"__asp3_acre_tsk\"]\n+    pub fn acre_tsk(pk_ctsk: *const T_CTSK) -> ER_ID;\n+    #[link_name = \"__asp3_get_tid\"]\n+    pub fn get_tid(p_tskid: *mut ID) -> ER;\n+    #[link_name = \"__asp3_dly_tsk\"]\n+    pub fn dly_tsk(dlytim: RELTIM) -> ER;\n+    #[link_name = \"__asp3_ter_tsk\"]\n+    pub fn ter_tsk(tskid: ID) -> ER;\n+    #[link_name = \"__asp3_del_tsk\"]\n+    pub fn del_tsk(tskid: ID) -> ER;\n+    #[link_name = \"__asp3_get_pri\"]\n+    pub fn get_pri(tskid: ID, p_tskpri: *mut PRI) -> ER;\n+    #[link_name = \"__asp3_rot_rdq\"]\n+    pub fn rot_rdq(tskpri: PRI) -> ER;\n+    #[link_name = \"__asp3_slp_tsk\"]\n+    pub fn slp_tsk() -> ER;\n+    #[link_name = \"__asp3_tslp_tsk\"]\n+    pub fn tslp_tsk(tmout: TMO) -> ER;\n+    #[link_name = \"__asp3_wup_tsk\"]\n+    pub fn wup_tsk(tskid: ID) -> ER;\n+    #[link_name = \"__asp3_unl_cpu\"]\n+    pub fn unl_cpu() -> ER;\n+    #[link_name = \"__asp3_dis_dsp\"]\n+    pub fn dis_dsp() -> ER;\n+    #[link_name = \"__asp3_ena_dsp\"]\n+    pub fn ena_dsp() -> ER;\n+    #[link_name = \"__asp3_sns_dsp\"]\n+    pub fn sns_dsp() -> bool_t;\n+    #[link_name = \"__asp3_get_tim\"]\n+    pub fn get_tim(p_systim: *mut SYSTIM) -> ER;\n+    #[link_name = \"__asp3_acre_mtx\"]\n+    pub fn acre_mtx(pk_cmtx: *const T_CMTX) -> ER_ID;\n+    #[link_name = \"__asp3_del_mtx\"]\n+    pub fn del_mtx(tskid: ID) -> ER;\n+    #[link_name = \"__asp3_loc_mtx\"]\n+    pub fn loc_mtx(mtxid: ID) -> ER;\n+    #[link_name = \"__asp3_ploc_mtx\"]\n+    pub fn ploc_mtx(mtxid: ID) -> ER;\n+    #[link_name = \"__asp3_tloc_mtx\"]\n+    pub fn tloc_mtx(mtxid: ID, tmout: TMO) -> ER;\n+    #[link_name = \"__asp3_unl_mtx\"]\n+    pub fn unl_mtx(mtxid: ID) -> ER;\n+    pub fn exd_tsk() -> ER;\n+}"}, {"sha": "dac4b8abfc47ff1b7e58673887d98d834b0b8ed6", "filename": "library/std/src/sys/itron/condvar.rs", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,294 @@\n+//! POSIX conditional variable implementation based on user-space wait queues.\n+use super::{abi, error::expect_success_aborting, spin::SpinMutex, task, time::with_tmos_strong};\n+use crate::{mem::replace, ptr::NonNull, sys::mutex::Mutex, time::Duration};\n+\n+// The implementation is inspired by the queue-based implementation shown in\n+// Andrew D. Birrell's paper \"Implementing Condition Variables with Semaphores\"\n+\n+pub struct Condvar {\n+    waiters: SpinMutex<waiter_queue::WaiterQueue>,\n+}\n+\n+unsafe impl Send for Condvar {}\n+unsafe impl Sync for Condvar {}\n+\n+pub type MovableCondvar = Condvar;\n+\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar { waiters: SpinMutex::new(waiter_queue::WaiterQueue::new()) }\n+    }\n+\n+    pub unsafe fn init(&mut self) {}\n+\n+    pub unsafe fn notify_one(&self) {\n+        self.waiters.with_locked(|waiters| {\n+            if let Some(task) = waiters.pop_front() {\n+                // Unpark the task\n+                match unsafe { abi::wup_tsk(task) } {\n+                    // The task already has a token.\n+                    abi::E_QOVR => {}\n+                    // Can't undo the effect; abort the program on failure\n+                    er => {\n+                        expect_success_aborting(er, &\"wup_tsk\");\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    pub unsafe fn notify_all(&self) {\n+        self.waiters.with_locked(|waiters| {\n+            while let Some(task) = waiters.pop_front() {\n+                // Unpark the task\n+                match unsafe { abi::wup_tsk(task) } {\n+                    // The task already has a token.\n+                    abi::E_QOVR => {}\n+                    // Can't undo the effect; abort the program on failure\n+                    er => {\n+                        expect_success_aborting(er, &\"wup_tsk\");\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        // Construct `Waiter`.\n+        let mut waiter = waiter_queue::Waiter::new();\n+        let waiter = NonNull::from(&mut waiter);\n+\n+        self.waiters.with_locked(|waiters| unsafe {\n+            waiters.insert(waiter);\n+        });\n+\n+        unsafe { mutex.unlock() };\n+\n+        // Wait until `waiter` is removed from the queue\n+        loop {\n+            // Park the current task\n+            expect_success_aborting(unsafe { abi::slp_tsk() }, &\"slp_tsk\");\n+\n+            if !self.waiters.with_locked(|waiters| unsafe { waiters.is_queued(waiter) }) {\n+                break;\n+            }\n+        }\n+\n+        unsafe { mutex.lock() };\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        // Construct and pin `Waiter`\n+        let mut waiter = waiter_queue::Waiter::new();\n+        let waiter = NonNull::from(&mut waiter);\n+\n+        self.waiters.with_locked(|waiters| unsafe {\n+            waiters.insert(waiter);\n+        });\n+\n+        unsafe { mutex.unlock() };\n+\n+        // Park the current task and do not wake up until the timeout elapses\n+        // or the task gets woken up by `notify_*`\n+        match with_tmos_strong(dur, |tmo| {\n+            let er = unsafe { abi::tslp_tsk(tmo) };\n+            if er == 0 {\n+                // We were unparked. Are we really dequeued?\n+                if self.waiters.with_locked(|waiters| unsafe { waiters.is_queued(waiter) }) {\n+                    // No we are not. Continue waiting.\n+                    return abi::E_TMOUT;\n+                }\n+            }\n+            er\n+        }) {\n+            abi::E_TMOUT => {}\n+            er => {\n+                expect_success_aborting(er, &\"tslp_tsk\");\n+            }\n+        }\n+\n+        // Remove `waiter` from `self.waiters`. If `waiter` is still in\n+        // `waiters`, it means we woke up because of a timeout. Otherwise,\n+        // we woke up because of `notify_*`.\n+        let success = self.waiters.with_locked(|waiters| unsafe { !waiters.remove(waiter) });\n+\n+        unsafe { mutex.lock() };\n+        success\n+    }\n+\n+    pub unsafe fn destroy(&self) {}\n+}\n+\n+mod waiter_queue {\n+    use super::*;\n+\n+    pub struct WaiterQueue {\n+        head: Option<ListHead>,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    struct ListHead {\n+        first: NonNull<Waiter>,\n+        last: NonNull<Waiter>,\n+    }\n+\n+    unsafe impl Send for ListHead {}\n+    unsafe impl Sync for ListHead {}\n+\n+    pub struct Waiter {\n+        // These fields are only accessed through `&[mut] WaiterQueue`.\n+        /// The waiting task's ID. Will be zeroed when the task is woken up\n+        /// and removed from a queue.\n+        task: abi::ID,\n+        priority: abi::PRI,\n+        prev: Option<NonNull<Waiter>>,\n+        next: Option<NonNull<Waiter>>,\n+    }\n+\n+    unsafe impl Send for Waiter {}\n+    unsafe impl Sync for Waiter {}\n+\n+    impl Waiter {\n+        #[inline]\n+        pub fn new() -> Self {\n+            let task = task::current_task_id();\n+            let priority = task::task_priority(abi::TSK_SELF);\n+\n+            // Zeroness of `Waiter::task` indicates whether the `Waiter` is\n+            // linked to a queue or not. This invariant is important for\n+            // the correctness.\n+            debug_assert_ne!(task, 0);\n+\n+            Self { task, priority, prev: None, next: None }\n+        }\n+    }\n+\n+    impl WaiterQueue {\n+        #[inline]\n+        pub const fn new() -> Self {\n+            Self { head: None }\n+        }\n+\n+        /// # Safety\n+        ///\n+        ///  - The caller must own `*waiter_ptr`. The caller will lose the\n+        ///    ownership until `*waiter_ptr` is removed from `self`.\n+        ///\n+        ///  - `*waiter_ptr` must be valid until it's removed from the queue.\n+        ///\n+        ///  - `*waiter_ptr` must not have been previously inserted to a `WaiterQueue`.\n+        ///\n+        pub unsafe fn insert(&mut self, mut waiter_ptr: NonNull<Waiter>) {\n+            unsafe {\n+                let waiter = waiter_ptr.as_mut();\n+\n+                debug_assert!(waiter.prev.is_none());\n+                debug_assert!(waiter.next.is_none());\n+\n+                if let Some(head) = &mut self.head {\n+                    // Find the insertion position and insert `waiter`\n+                    let insert_after = {\n+                        let mut cursor = head.last;\n+                        loop {\n+                            if waiter.priority <= cursor.as_ref().priority {\n+                                // `cursor` and all previous waiters have the same or higher\n+                                // priority than `current_task_priority`. Insert the new\n+                                // waiter right after `cursor`.\n+                                break Some(cursor);\n+                            }\n+                            cursor = if let Some(prev) = cursor.as_ref().prev {\n+                                prev\n+                            } else {\n+                                break None;\n+                            };\n+                        }\n+                    };\n+\n+                    if let Some(mut insert_after) = insert_after {\n+                        // Insert `waiter` after `insert_after`\n+                        let insert_before = insert_after.as_ref().prev;\n+\n+                        waiter.prev = Some(insert_after);\n+                        insert_after.as_mut().next = Some(waiter_ptr);\n+\n+                        waiter.next = insert_before;\n+                        if let Some(mut insert_before) = insert_before {\n+                            insert_before.as_mut().prev = Some(waiter_ptr);\n+                        }\n+                    } else {\n+                        // Insert `waiter` to the front\n+                        waiter.next = Some(head.first);\n+                        head.first.as_mut().prev = Some(waiter_ptr);\n+                        head.first = waiter_ptr;\n+                    }\n+                } else {\n+                    // `waiter` is the only element\n+                    self.head = Some(ListHead { first: waiter_ptr, last: waiter_ptr });\n+                }\n+            }\n+        }\n+\n+        /// Given a `Waiter` that was previously inserted to `self`, remove\n+        /// it from `self` if it's still there.\n+        #[inline]\n+        pub unsafe fn remove(&mut self, mut waiter_ptr: NonNull<Waiter>) -> bool {\n+            unsafe {\n+                let waiter = waiter_ptr.as_mut();\n+                if waiter.task != 0 {\n+                    let head = self.head.as_mut().unwrap();\n+\n+                    match (waiter.prev, waiter.next) {\n+                        (Some(mut prev), Some(mut next)) => {\n+                            prev.as_mut().next = Some(next);\n+                            next.as_mut().next = Some(prev);\n+                        }\n+                        (None, Some(mut next)) => {\n+                            head.first = next;\n+                            next.as_mut().next = None;\n+                        }\n+                        (Some(mut prev), None) => {\n+                            prev.as_mut().next = None;\n+                            head.last = prev;\n+                        }\n+                        (None, None) => {\n+                            self.head = None;\n+                        }\n+                    }\n+\n+                    waiter.task = 0;\n+\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+\n+        /// Given a `Waiter` that was previously inserted to `self`, return a\n+        /// flag indicating whether it's still in `self`.\n+        #[inline]\n+        pub unsafe fn is_queued(&self, waiter: NonNull<Waiter>) -> bool {\n+            unsafe { waiter.as_ref().task != 0 }\n+        }\n+\n+        pub fn pop_front(&mut self) -> Option<abi::ID> {\n+            unsafe {\n+                let head = self.head.as_mut()?;\n+                let waiter = head.first.as_mut();\n+\n+                // Get the ID\n+                let id = replace(&mut waiter.task, 0);\n+\n+                // Unlink the waiter\n+                if let Some(mut next) = waiter.next {\n+                    head.first = next;\n+                    next.as_mut().prev = None;\n+                } else {\n+                    self.head = None;\n+                }\n+\n+                Some(id)\n+            }\n+        }\n+    }\n+}"}, {"sha": "830c60d329e4ec8b59ee98725641a7dde27d04fa", "filename": "library/std/src/sys/itron/error.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ferror.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,159 @@\n+use crate::{fmt, io::ErrorKind};\n+\n+use super::abi;\n+\n+/// Wraps a \u03bcITRON error code.\n+#[derive(Debug, Copy, Clone)]\n+pub struct ItronError {\n+    er: abi::ER,\n+}\n+\n+impl ItronError {\n+    /// Construct `ItronError` from the specified error code. Returns `None` if the\n+    /// error code does not represent a failure or warning.\n+    #[inline]\n+    pub fn new(er: abi::ER) -> Option<Self> {\n+        if er < 0 { Some(Self { er }) } else { None }\n+    }\n+\n+    /// Returns `Ok(er)` if `er` represents a success or `Err(_)` otherwise.\n+    #[inline]\n+    pub fn err_if_negative(er: abi::ER) -> Result<abi::ER, Self> {\n+        if let Some(error) = Self::new(er) { Err(error) } else { Ok(er) }\n+    }\n+\n+    /// Get the raw error code.\n+    #[inline]\n+    pub fn as_raw(&self) -> abi::ER {\n+        self.er\n+    }\n+}\n+\n+impl fmt::Display for ItronError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Allow the platforms to extend `error_name`\n+        if let Some(name) = crate::sys::error::error_name(self.er) {\n+            write!(f, \"{} ({})\", name, self.er)\n+        } else {\n+            write!(f, \"{}\", self.er)\n+        }\n+    }\n+}\n+\n+/// Describe the specified \u03bcITRON error code. Returns `None` if it's an\n+/// undefined error code.\n+pub fn error_name(er: abi::ER) -> Option<&'static str> {\n+    match er {\n+        // Success\n+        er if er >= 0 => None,\n+\n+        // \u03bcITRON 4.0\n+        abi::E_SYS => Some(\"system error\"),\n+        abi::E_NOSPT => Some(\"unsupported function\"),\n+        abi::E_RSFN => Some(\"reserved function code\"),\n+        abi::E_RSATR => Some(\"reserved attribute\"),\n+        abi::E_PAR => Some(\"parameter error\"),\n+        abi::E_ID => Some(\"invalid ID number\"),\n+        abi::E_CTX => Some(\"context error\"),\n+        abi::E_MACV => Some(\"memory access violation\"),\n+        abi::E_OACV => Some(\"object access violation\"),\n+        abi::E_ILUSE => Some(\"illegal service call use\"),\n+        abi::E_NOMEM => Some(\"insufficient memory\"),\n+        abi::E_NOID => Some(\"no ID number available\"),\n+        abi::E_OBJ => Some(\"object state error\"),\n+        abi::E_NOEXS => Some(\"non-existent object\"),\n+        abi::E_QOVR => Some(\"queue overflow\"),\n+        abi::E_RLWAI => Some(\"forced release from waiting\"),\n+        abi::E_TMOUT => Some(\"polling failure or timeout\"),\n+        abi::E_DLT => Some(\"waiting object deleted\"),\n+        abi::E_CLS => Some(\"waiting object state changed\"),\n+        abi::E_WBLK => Some(\"non-blocking code accepted\"),\n+        abi::E_BOVR => Some(\"buffer overflow\"),\n+\n+        // The TOPPERS third generation kernels\n+        abi::E_NORES => Some(\"insufficient system resources\"),\n+        abi::E_RASTER => Some(\"termination request raised\"),\n+        abi::E_COMM => Some(\"communication failure\"),\n+\n+        _ => None,\n+    }\n+}\n+\n+pub fn decode_error_kind(er: abi::ER) -> ErrorKind {\n+    match er {\n+        // Success\n+        er if er >= 0 => ErrorKind::Uncategorized,\n+\n+        // \u03bcITRON 4.0\n+        // abi::E_SYS\n+        abi::E_NOSPT => ErrorKind::Unsupported, // Some(\"unsupported function\"),\n+        abi::E_RSFN => ErrorKind::InvalidInput, // Some(\"reserved function code\"),\n+        abi::E_RSATR => ErrorKind::InvalidInput, // Some(\"reserved attribute\"),\n+        abi::E_PAR => ErrorKind::InvalidInput,  // Some(\"parameter error\"),\n+        abi::E_ID => ErrorKind::NotFound,       // Some(\"invalid ID number\"),\n+        // abi::E_CTX\n+        abi::E_MACV => ErrorKind::PermissionDenied, // Some(\"memory access violation\"),\n+        abi::E_OACV => ErrorKind::PermissionDenied, // Some(\"object access violation\"),\n+        // abi::E_ILUSE\n+        abi::E_NOMEM => ErrorKind::OutOfMemory, // Some(\"insufficient memory\"),\n+        abi::E_NOID => ErrorKind::OutOfMemory,  // Some(\"no ID number available\"),\n+        // abi::E_OBJ\n+        abi::E_NOEXS => ErrorKind::NotFound, // Some(\"non-existent object\"),\n+        // abi::E_QOVR\n+        abi::E_RLWAI => ErrorKind::Interrupted, // Some(\"forced release from waiting\"),\n+        abi::E_TMOUT => ErrorKind::TimedOut,    // Some(\"polling failure or timeout\"),\n+        // abi::E_DLT\n+        // abi::E_CLS\n+        // abi::E_WBLK\n+        // abi::E_BOVR\n+\n+        // The TOPPERS third generation kernels\n+        abi::E_NORES => ErrorKind::OutOfMemory, // Some(\"insufficient system resources\"),\n+        // abi::E_RASTER\n+        // abi::E_COMM\n+        _ => ErrorKind::Uncategorized,\n+    }\n+}\n+\n+/// Similar to `ItronError::err_if_negative(er).expect()` except that, while\n+/// panicking, it prints the message to `panic_output` and aborts the program\n+/// instead. This ensures the error message is not obscured by double\n+/// panicking.\n+///\n+/// This is useful for diagnosing creation failures of synchronization\n+/// primitives that are used by `std`'s internal mechanisms. Such failures\n+/// are common when the system is mis-configured to provide a too-small pool for\n+/// kernel objects.\n+#[inline]\n+pub fn expect_success(er: abi::ER, msg: &&str) -> abi::ER {\n+    match ItronError::err_if_negative(er) {\n+        Ok(x) => x,\n+        Err(e) => fail(e, msg),\n+    }\n+}\n+\n+/// Similar to `ItronError::err_if_negative(er).expect()` but aborts instead.\n+///\n+/// Use this where panicking is not allowed or the effect of the failure\n+/// would be persistent.\n+#[inline]\n+pub fn expect_success_aborting(er: abi::ER, msg: &&str) -> abi::ER {\n+    match ItronError::err_if_negative(er) {\n+        Ok(x) => x,\n+        Err(e) => fail_aborting(e, msg),\n+    }\n+}\n+\n+#[cold]\n+pub fn fail(e: impl fmt::Display, msg: &&str) -> ! {\n+    if crate::thread::panicking() {\n+        fail_aborting(e, msg)\n+    } else {\n+        panic!(\"{} failed: {}\", *msg, e)\n+    }\n+}\n+\n+#[cold]\n+pub fn fail_aborting(e: impl fmt::Display, msg: &&str) -> ! {\n+    rtabort!(\"{} failed: {}\", *msg, e)\n+}"}, {"sha": "e01f595ac54abeefcb835b8fa54891209e95251c", "filename": "library/std/src/sys/itron/mutex.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,183 @@\n+//! Mutex implementation backed by \u03bcITRON mutexes. Assumes `acre_mtx` and\n+//! `TA_INHERIT` are available.\n+use super::{\n+    abi,\n+    error::{expect_success, expect_success_aborting, fail, ItronError},\n+    spin::SpinIdOnceCell,\n+};\n+use crate::cell::UnsafeCell;\n+\n+pub struct Mutex {\n+    /// The ID of the underlying mutex object\n+    mtx: SpinIdOnceCell<()>,\n+}\n+\n+pub type MovableMutex = Mutex;\n+\n+/// Create a mutex object. This function never panics.\n+fn new_mtx() -> Result<abi::ID, ItronError> {\n+    ItronError::err_if_negative(unsafe {\n+        abi::acre_mtx(&abi::T_CMTX {\n+            // Priority inheritance mutex\n+            mtxatr: abi::TA_INHERIT,\n+            // Unused\n+            ceilpri: 0,\n+        })\n+    })\n+}\n+\n+impl Mutex {\n+    pub const fn new() -> Mutex {\n+        Mutex { mtx: SpinIdOnceCell::new() }\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n+        // Initialize `self.mtx` eagerly\n+        let id = new_mtx().unwrap_or_else(|e| fail(e, &\"acre_mtx\"));\n+        unsafe { self.mtx.set_unchecked((id, ())) };\n+    }\n+\n+    /// Get the inner mutex's ID, which is lazily created.\n+    fn raw(&self) -> abi::ID {\n+        match self.mtx.get_or_try_init(|| new_mtx().map(|id| (id, ()))) {\n+            Ok((id, ())) => id,\n+            Err(e) => fail(e, &\"acre_mtx\"),\n+        }\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        let mtx = self.raw();\n+        expect_success(unsafe { abi::loc_mtx(mtx) }, &\"loc_mtx\");\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        let mtx = unsafe { self.mtx.get_unchecked().0 };\n+        expect_success_aborting(unsafe { abi::unl_mtx(mtx) }, &\"unl_mtx\");\n+    }\n+\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let mtx = self.raw();\n+        match unsafe { abi::ploc_mtx(mtx) } {\n+            abi::E_TMOUT => false,\n+            er => {\n+                expect_success(er, &\"ploc_mtx\");\n+                true\n+            }\n+        }\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        if let Some(mtx) = self.mtx.get().map(|x| x.0) {\n+            expect_success_aborting(unsafe { abi::del_mtx(mtx) }, &\"del_mtx\");\n+        }\n+    }\n+}\n+\n+pub(super) struct MutexGuard<'a>(&'a Mutex);\n+\n+impl<'a> MutexGuard<'a> {\n+    #[inline]\n+    pub(super) fn lock(x: &'a Mutex) -> Self {\n+        unsafe { x.lock() };\n+        Self(x)\n+    }\n+}\n+\n+impl Drop for MutexGuard<'_> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe { self.0.unlock() };\n+    }\n+}\n+\n+// All empty stubs because this platform does not yet support threads, so lock\n+// acquisition always succeeds.\n+pub struct ReentrantMutex {\n+    /// The ID of the underlying mutex object\n+    mtx: abi::ID,\n+    /// The lock count.\n+    count: UnsafeCell<usize>,\n+}\n+\n+unsafe impl Send for ReentrantMutex {}\n+unsafe impl Sync for ReentrantMutex {}\n+\n+impl ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n+        ReentrantMutex { mtx: 0, count: UnsafeCell::new(0) }\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n+        self.mtx = expect_success(\n+            unsafe {\n+                abi::acre_mtx(&abi::T_CMTX {\n+                    // Priority inheritance mutex\n+                    mtxatr: abi::TA_INHERIT,\n+                    // Unused\n+                    ceilpri: 0,\n+                })\n+            },\n+            &\"acre_mtx\",\n+        );\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        match unsafe { abi::loc_mtx(self.mtx) } {\n+            abi::E_OBJ => {\n+                // Recursive lock\n+                unsafe {\n+                    let count = &mut *self.count.get();\n+                    if let Some(new_count) = count.checked_add(1) {\n+                        *count = new_count;\n+                    } else {\n+                        // counter overflow\n+                        rtabort!(\"lock count overflow\");\n+                    }\n+                }\n+            }\n+            er => {\n+                expect_success(er, &\"loc_mtx\");\n+            }\n+        }\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        unsafe {\n+            let count = &mut *self.count.get();\n+            if *count > 0 {\n+                *count -= 1;\n+                return;\n+            }\n+        }\n+\n+        expect_success_aborting(unsafe { abi::unl_mtx(self.mtx) }, &\"unl_mtx\");\n+    }\n+\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let er = unsafe { abi::ploc_mtx(self.mtx) };\n+        if er == abi::E_OBJ {\n+            // Recursive lock\n+            unsafe {\n+                let count = &mut *self.count.get();\n+                if let Some(new_count) = count.checked_add(1) {\n+                    *count = new_count;\n+                } else {\n+                    // counter overflow\n+                    rtabort!(\"lock count overflow\");\n+                }\n+            }\n+            true\n+        } else if er == abi::E_TMOUT {\n+            // Locked by another thread\n+            false\n+        } else {\n+            expect_success(er, &\"ploc_mtx\");\n+            // Top-level lock by the current thread\n+            true\n+        }\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        expect_success_aborting(unsafe { abi::del_mtx(self.mtx) }, &\"del_mtx\");\n+    }\n+}"}, {"sha": "d0149d1f037db82a0a5b9897d11eff0e649058fe", "filename": "library/std/src/sys/itron/spin.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fspin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fspin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fspin.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,164 @@\n+use super::abi;\n+use crate::{\n+    cell::UnsafeCell,\n+    convert::TryFrom,\n+    mem::MaybeUninit,\n+    sync::atomic::{AtomicBool, AtomicUsize, Ordering},\n+};\n+\n+/// A mutex implemented by `dis_dsp` (for intra-core synchronization) and a\n+/// spinlock (for inter-core synchronization).\n+pub struct SpinMutex<T = ()> {\n+    locked: AtomicBool,\n+    data: UnsafeCell<T>,\n+}\n+\n+impl<T> SpinMutex<T> {\n+    #[inline]\n+    pub const fn new(x: T) -> Self {\n+        Self { locked: AtomicBool::new(false), data: UnsafeCell::new(x) }\n+    }\n+\n+    /// Acquire a lock.\n+    #[inline]\n+    pub fn with_locked<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {\n+        struct SpinMutexGuard<'a>(&'a AtomicBool);\n+\n+        impl Drop for SpinMutexGuard<'_> {\n+            #[inline]\n+            fn drop(&mut self) {\n+                self.0.store(false, Ordering::Release);\n+                unsafe { abi::ena_dsp() };\n+            }\n+        }\n+\n+        let _guard;\n+        if unsafe { abi::sns_dsp() } == 0 {\n+            let er = unsafe { abi::dis_dsp() };\n+            debug_assert!(er >= 0);\n+\n+            // Wait until the current processor acquires a lock.\n+            while self.locked.swap(true, Ordering::Acquire) {}\n+\n+            _guard = SpinMutexGuard(&self.locked);\n+        }\n+\n+        f(unsafe { &mut *self.data.get() })\n+    }\n+}\n+\n+/// `OnceCell<(abi::ID, T)>` implemented by `dis_dsp` (for intra-core\n+/// synchronization) and a spinlock (for inter-core synchronization).\n+///\n+/// It's assumed that `0` is not a valid ID, and all kernel\n+/// object IDs fall into range `1..=usize::MAX`.\n+pub struct SpinIdOnceCell<T = ()> {\n+    id: AtomicUsize,\n+    spin: SpinMutex<()>,\n+    extra: UnsafeCell<MaybeUninit<T>>,\n+}\n+\n+const ID_UNINIT: usize = 0;\n+\n+impl<T> SpinIdOnceCell<T> {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Self {\n+            id: AtomicUsize::new(ID_UNINIT),\n+            extra: UnsafeCell::new(MaybeUninit::uninit()),\n+            spin: SpinMutex::new(()),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get(&self) -> Option<(abi::ID, &T)> {\n+        match self.id.load(Ordering::Acquire) {\n+            ID_UNINIT => None,\n+            id => Some((id as abi::ID, unsafe { (&*self.extra.get()).assume_init_ref() })),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get_mut(&mut self) -> Option<(abi::ID, &mut T)> {\n+        match *self.id.get_mut() {\n+            ID_UNINIT => None,\n+            id => Some((id as abi::ID, unsafe { (&mut *self.extra.get()).assume_init_mut() })),\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn get_unchecked(&self) -> (abi::ID, &T) {\n+        (self.id.load(Ordering::Acquire) as abi::ID, unsafe {\n+            (&*self.extra.get()).assume_init_ref()\n+        })\n+    }\n+\n+    /// Assign the content without checking if it's already initialized or\n+    /// being initialized.\n+    pub unsafe fn set_unchecked(&self, (id, extra): (abi::ID, T)) {\n+        debug_assert!(self.get().is_none());\n+\n+        // Assumption: A positive `abi::ID` fits in `usize`.\n+        debug_assert!(id >= 0);\n+        debug_assert!(usize::try_from(id).is_ok());\n+        let id = id as usize;\n+\n+        unsafe { *self.extra.get() = MaybeUninit::new(extra) };\n+        self.id.store(id, Ordering::Release);\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if\n+    /// the cell was empty. If the cell was empty and `f` failed, an\n+    /// error is returned.\n+    ///\n+    /// Warning: `f` must not perform a blocking operation, which\n+    /// includes panicking.\n+    #[inline]\n+    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<(abi::ID, &T), E>\n+    where\n+        F: FnOnce() -> Result<(abi::ID, T), E>,\n+    {\n+        // Fast path\n+        if let Some(x) = self.get() {\n+            return Ok(x);\n+        }\n+\n+        self.initialize(f)?;\n+\n+        debug_assert!(self.get().is_some());\n+\n+        // Safety: The inner value has been initialized\n+        Ok(unsafe { self.get_unchecked() })\n+    }\n+\n+    fn initialize<F, E>(&self, f: F) -> Result<(), E>\n+    where\n+        F: FnOnce() -> Result<(abi::ID, T), E>,\n+    {\n+        self.spin.with_locked(|_| {\n+            if self.id.load(Ordering::Relaxed) == ID_UNINIT {\n+                let (initialized_id, initialized_extra) = f()?;\n+\n+                // Assumption: A positive `abi::ID` fits in `usize`.\n+                debug_assert!(initialized_id >= 0);\n+                debug_assert!(usize::try_from(initialized_id).is_ok());\n+                let initialized_id = initialized_id as usize;\n+\n+                // Store the initialized contents. Use the release ordering to\n+                // make sure the write is visible to the callers of `get`.\n+                unsafe { *self.extra.get() = MaybeUninit::new(initialized_extra) };\n+                self.id.store(initialized_id, Ordering::Release);\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<T> Drop for SpinIdOnceCell<T> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        if self.get_mut().is_some() {\n+            unsafe { (&mut *self.extra.get()).assume_init_drop() };\n+        }\n+    }\n+}"}, {"sha": "94beb50a2541b4cc0bc83135b15fc6a5a51dd570", "filename": "library/std/src/sys/itron/task.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftask.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,44 @@\n+use super::{\n+    abi,\n+    error::{fail, fail_aborting, ItronError},\n+};\n+\n+use crate::mem::MaybeUninit;\n+\n+/// Get the ID of the task in Running state. Panics on failure.\n+#[inline]\n+pub fn current_task_id() -> abi::ID {\n+    try_current_task_id().unwrap_or_else(|e| fail(e, &\"get_tid\"))\n+}\n+\n+/// Get the ID of the task in Running state. Aborts on failure.\n+#[inline]\n+pub fn current_task_id_aborting() -> abi::ID {\n+    try_current_task_id().unwrap_or_else(|e| fail_aborting(e, &\"get_tid\"))\n+}\n+\n+/// Get the ID of the task in Running state.\n+#[inline]\n+pub fn try_current_task_id() -> Result<abi::ID, ItronError> {\n+    unsafe {\n+        let mut out = MaybeUninit::uninit();\n+        ItronError::err_if_negative(abi::get_tid(out.as_mut_ptr()))?;\n+        Ok(out.assume_init())\n+    }\n+}\n+\n+/// Get the specified task's priority. Panics on failure.\n+#[inline]\n+pub fn task_priority(task: abi::ID) -> abi::PRI {\n+    try_task_priority(task).unwrap_or_else(|e| fail(e, &\"get_pri\"))\n+}\n+\n+/// Get the specified task's priority.\n+#[inline]\n+pub fn try_task_priority(task: abi::ID) -> Result<abi::PRI, ItronError> {\n+    unsafe {\n+        let mut out = MaybeUninit::uninit();\n+        ItronError::err_if_negative(abi::get_pri(task, out.as_mut_ptr()))?;\n+        Ok(out.assume_init())\n+    }\n+}"}, {"sha": "4feb9c5a6d74047155547994bab0c76fb931fa80", "filename": "library/std/src/sys/itron/thread.rs", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,352 @@\n+//! Thread implementation backed by \u03bcITRON tasks. Assumes `acre_tsk` and\n+//! `exd_tsk` are available.\n+use super::{\n+    abi,\n+    error::{expect_success, expect_success_aborting, ItronError},\n+    task,\n+    time::dur2reltims,\n+};\n+use crate::{\n+    cell::UnsafeCell,\n+    convert::TryFrom,\n+    ffi::CStr,\n+    hint, io,\n+    mem::ManuallyDrop,\n+    sync::atomic::{AtomicUsize, Ordering},\n+    sys::thread_local_dtor::run_dtors,\n+    time::Duration,\n+};\n+\n+pub struct Thread {\n+    inner: ManuallyDrop<Box<ThreadInner>>,\n+\n+    /// The ID of the underlying task.\n+    task: abi::ID,\n+}\n+\n+/// State data shared between a parent thread and child thread. It's dropped on\n+/// a transition to one of the final states.\n+struct ThreadInner {\n+    /// This field is used on thread creation to pass a closure from\n+    /// `Thread::new` to the created task.\n+    start: UnsafeCell<ManuallyDrop<Box<dyn FnOnce()>>>,\n+\n+    /// A state machine. Each transition is annotated with `[...]` in the\n+    /// source code.\n+    ///\n+    /// ```text\n+    ///\n+    ///    <P>: parent, <C>: child, (?): don't-care\n+    ///\n+    ///       DETACHED (-1)  -------------------->  EXITED (?)\n+    ///                        <C>finish/exd_tsk\n+    ///          ^\n+    ///          |\n+    ///          | <P>detach\n+    ///          |\n+    ///\n+    ///       INIT (0)  ----------------------->  FINISHED (-1)\n+    ///                        <C>finish\n+    ///          |                                    |\n+    ///          | <P>join/slp_tsk                    | <P>join/del_tsk\n+    ///          |                                    | <P>detach/del_tsk\n+    ///          v                                    v\n+    ///\n+    ///       JOINING                              JOINED (?)\n+    ///     (parent_tid)\n+    ///                                            ^\n+    ///             \\                             /\n+    ///              \\  <C>finish/wup_tsk        / <P>slp_tsk-complete/ter_tsk\n+    ///               \\                         /                      & del_tsk\n+    ///                \\                       /\n+    ///                 '--> JOIN_FINALIZE ---'\n+    ///                          (-1)\n+    ///\n+    lifecycle: AtomicUsize,\n+}\n+\n+// Safety: The only `!Sync` field, `ThreadInner::start`, is only touched by\n+//         the task represented by `ThreadInner`.\n+unsafe impl Sync for ThreadInner {}\n+\n+const LIFECYCLE_INIT: usize = 0;\n+const LIFECYCLE_FINISHED: usize = usize::MAX;\n+const LIFECYCLE_DETACHED: usize = usize::MAX;\n+const LIFECYCLE_JOIN_FINALIZE: usize = usize::MAX;\n+const LIFECYCLE_DETACHED_OR_JOINED: usize = usize::MAX;\n+const LIFECYCLE_EXITED_OR_FINISHED_OR_JOIN_FINALIZE: usize = usize::MAX;\n+// there's no single value for `JOINING`\n+\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * crate::mem::size_of::<usize>();\n+\n+impl Thread {\n+    /// # Safety\n+    ///\n+    /// See `thread::Builder::spawn_unchecked` for safety requirements.\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n+        // Inherit the current task's priority\n+        let current_task = task::try_current_task_id().map_err(|e| e.as_io_error())?;\n+        let priority = task::try_task_priority(current_task).map_err(|e| e.as_io_error())?;\n+\n+        let inner = Box::new(ThreadInner {\n+            start: UnsafeCell::new(ManuallyDrop::new(p)),\n+            lifecycle: AtomicUsize::new(LIFECYCLE_INIT),\n+        });\n+\n+        unsafe extern \"C\" fn trampoline(exinf: isize) {\n+            // Safety: `ThreadInner` is alive at this point\n+            let inner = unsafe { &*(exinf as *const ThreadInner) };\n+\n+            // Safety: Since `trampoline` is called only once for each\n+            //         `ThreadInner` and only `trampoline` touches `start`,\n+            //         `start` contains contents and is safe to mutably borrow.\n+            let p = unsafe { ManuallyDrop::take(&mut *inner.start.get()) };\n+            p();\n+\n+            // Fix the current thread's state just in case, so that the\n+            // destructors won't abort\n+            // Safety: Not really unsafe\n+            let _ = unsafe { abi::unl_cpu() };\n+            let _ = unsafe { abi::ena_dsp() };\n+\n+            // Run TLS destructors now because they are not\n+            // called automatically for terminated tasks.\n+            unsafe { run_dtors() };\n+\n+            let old_lifecycle = inner\n+                .lifecycle\n+                .swap(LIFECYCLE_EXITED_OR_FINISHED_OR_JOIN_FINALIZE, Ordering::Release);\n+\n+            match old_lifecycle {\n+                LIFECYCLE_DETACHED => {\n+                    // [DETACHED \u2192 EXITED]\n+                    // No one will ever join, so we'll ask the collector task to\n+                    // delete the task.\n+\n+                    // In this case, `inner`'s ownership has been moved to us,\n+                    // And we are responsible for dropping it. The acquire\n+                    // ordering is not necessary because the parent thread made\n+                    // no memory acccess needing synchronization since the call\n+                    // to `acre_tsk`.\n+                    // Safety: See above.\n+                    let _ = unsafe { Box::from_raw(inner as *const _ as *mut ThreadInner) };\n+\n+                    // Safety: There are no pinned references to the stack\n+                    unsafe { terminate_and_delete_current_task() };\n+                }\n+                LIFECYCLE_INIT => {\n+                    // [INIT \u2192 FINISHED]\n+                    // The parent hasn't decided whether to join or detach this\n+                    // thread yet. Whichever option the parent chooses,\n+                    // it'll have to delete this task.\n+                    // Since the parent might drop `*inner` as soon as it sees\n+                    // `FINISHED`, the release ordering must be used in the\n+                    // above `swap` call.\n+                }\n+                parent_tid => {\n+                    // Since the parent might drop `*inner` and terminate us as\n+                    // soon as it sees `JOIN_FINALIZE`, the release ordering\n+                    // must be used in the above `swap` call.\n+\n+                    // [JOINING \u2192 JOIN_FINALIZE]\n+                    // Wake up the parent task.\n+                    expect_success(\n+                        unsafe {\n+                            let mut er = abi::wup_tsk(parent_tid as _);\n+                            if er == abi::E_QOVR {\n+                                // `E_QOVR` indicates there's already\n+                                // a parking token\n+                                er = abi::E_OK;\n+                            }\n+                            er\n+                        },\n+                        &\"wup_tsk\",\n+                    );\n+                }\n+            }\n+        }\n+\n+        let inner_ptr = (&*inner) as *const ThreadInner;\n+\n+        let new_task = ItronError::err_if_negative(unsafe {\n+            abi::acre_tsk(&abi::T_CTSK {\n+                // Activate this task immediately\n+                tskatr: abi::TA_ACT,\n+                exinf: inner_ptr as abi::EXINF,\n+                // The entry point\n+                task: Some(trampoline),\n+                itskpri: priority,\n+                stksz: stack,\n+                // Let the kernel allocate the stack,\n+                stk: crate::ptr::null_mut(),\n+            })\n+        })\n+        .map_err(|e| e.as_io_error())?;\n+\n+        Ok(Self { inner: ManuallyDrop::new(inner), task: new_task })\n+    }\n+\n+    pub fn yield_now() {\n+        expect_success(unsafe { abi::rot_rdq(abi::TPRI_SELF) }, &\"rot_rdq\");\n+    }\n+\n+    pub fn set_name(_name: &CStr) {\n+        // nope\n+    }\n+\n+    pub fn sleep(dur: Duration) {\n+        for timeout in dur2reltims(dur) {\n+            expect_success(unsafe { abi::dly_tsk(timeout) }, &\"dly_tsk\");\n+        }\n+    }\n+\n+    pub fn join(mut self) {\n+        let inner = &*self.inner;\n+        // Get the current task ID. Panicking here would cause a resource leak,\n+        // so just abort on failure.\n+        let current_task = task::current_task_id_aborting();\n+        debug_assert!(usize::try_from(current_task).is_ok());\n+        debug_assert_ne!(current_task as usize, LIFECYCLE_INIT);\n+        debug_assert_ne!(current_task as usize, LIFECYCLE_DETACHED);\n+\n+        let current_task = current_task as usize;\n+\n+        match inner.lifecycle.swap(current_task, Ordering::Acquire) {\n+            LIFECYCLE_INIT => {\n+                // [INIT \u2192 JOINING]\n+                // The child task will transition the state to `JOIN_FINALIZE`\n+                // and wake us up.\n+                loop {\n+                    expect_success_aborting(unsafe { abi::slp_tsk() }, &\"slp_tsk\");\n+                    // To synchronize with the child task's memory accesses to\n+                    // `inner` up to the point of the assignment of\n+                    // `JOIN_FINALIZE`, `Ordering::Acquire` must be used for the\n+                    // `load`.\n+                    if inner.lifecycle.load(Ordering::Acquire) == LIFECYCLE_JOIN_FINALIZE {\n+                        break;\n+                    }\n+                }\n+\n+                // [JOIN_FINALIZE \u2192 JOINED]\n+            }\n+            LIFECYCLE_FINISHED => {\n+                // [FINISHED \u2192 JOINED]\n+                // To synchronize with the child task's memory accesses to\n+                // `inner` up to the point of the assignment of `FINISHED`,\n+                // `Ordering::Acquire` must be used for the above `swap` call`.\n+            }\n+            _ => unsafe { hint::unreachable_unchecked() },\n+        }\n+\n+        // Terminate and delete the task\n+        // Safety: `self.task` still represents a task we own (because this\n+        //         method or `detach_inner` is called only once for each\n+        //         `Thread`). The task indicated that it's safe to delete by\n+        //         entering the `FINISHED` or `JOIN_FINALIZE` state.\n+        unsafe { terminate_and_delete_task(self.task) };\n+\n+        // In either case, we are responsible for dropping `inner`.\n+        // Safety: The contents of `self.inner` will not be accessed hereafter\n+        let _inner = unsafe { ManuallyDrop::take(&mut self.inner) };\n+\n+        // Skip the destructor (because it would attempt to detach the thread)\n+        crate::mem::forget(self);\n+    }\n+}\n+\n+impl Drop for Thread {\n+    fn drop(&mut self) {\n+        // Detach the thread.\n+        match self.inner.lifecycle.swap(LIFECYCLE_DETACHED_OR_JOINED, Ordering::Acquire) {\n+            LIFECYCLE_INIT => {\n+                // [INIT \u2192 DETACHED]\n+                // When the time comes, the child will figure out that no\n+                // one will ever join it.\n+                // The ownership of `self.inner` is moved to the child thread.\n+                // However, the release ordering is not necessary because we\n+                // made no memory acccess needing synchronization since the call\n+                // to `acre_tsk`.\n+            }\n+            LIFECYCLE_FINISHED => {\n+                // [FINISHED \u2192 JOINED]\n+                // The task has already decided that we should delete the task.\n+                // To synchronize with the child task's memory accesses to\n+                // `inner` up to the point of the assignment of `FINISHED`,\n+                // the acquire ordering is required for the above `swap` call.\n+\n+                // Terminate and delete the task\n+                // Safety: `self.task` still represents a task we own (because\n+                //         this method or `join_inner` is called only once for\n+                //         each `Thread`). The task  indicated that it's safe to\n+                //         delete by entering the `FINISHED` state.\n+                unsafe { terminate_and_delete_task(self.task) };\n+\n+                // Wwe are responsible for dropping `inner`.\n+                // Safety: The contents of `self.inner` will not be accessed\n+                //         hereafter\n+                unsafe { ManuallyDrop::drop(&mut self.inner) };\n+            }\n+            _ => unsafe { hint::unreachable_unchecked() },\n+        }\n+    }\n+}\n+\n+pub mod guard {\n+    pub type Guard = !;\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n+}\n+\n+/// Terminate and delete the specified task.\n+///\n+/// This function will abort if `deleted_task` refers to the calling task.\n+///\n+/// It is assumed that the specified task is solely managed by the caller -\n+/// i.e., other threads must not \"resuscitate\" the specified task or delete it\n+/// prematurely while this function is still in progress. It is allowed for the\n+/// specified task to exit by its own.\n+///\n+/// # Safety\n+///\n+/// The task must be safe to terminate. This is in general not true\n+/// because there might be pinned references to the task's stack.\n+unsafe fn terminate_and_delete_task(deleted_task: abi::ID) {\n+    // Terminate the task\n+    // Safety: Upheld by the caller\n+    match unsafe { abi::ter_tsk(deleted_task) } {\n+        // Indicates the task is already dormant, ignore it\n+        abi::E_OBJ => {}\n+        er => {\n+            expect_success_aborting(er, &\"ter_tsk\");\n+        }\n+    }\n+\n+    // Delete the task\n+    // Safety: Upheld by the caller\n+    expect_success_aborting(unsafe { abi::del_tsk(deleted_task) }, &\"del_tsk\");\n+}\n+\n+/// Terminate and delete the calling task.\n+///\n+/// Atomicity is not required - i.e., it can be assumed that other threads won't\n+/// `ter_tsk` the calling task while this function is still in progress. (This\n+/// property makes it easy to implement this operation on \u03bcITRON-derived kernels\n+/// that don't support `exd_tsk`.)\n+///\n+/// # Safety\n+///\n+/// The task must be safe to terminate. This is in general not true\n+/// because there might be pinned references to the task's stack.\n+unsafe fn terminate_and_delete_current_task() -> ! {\n+    expect_success_aborting(unsafe { abi::exd_tsk() }, &\"exd_tsk\");\n+    // Safety: `exd_tsk` never returns on success\n+    unsafe { crate::hint::unreachable_unchecked() };\n+}\n+\n+pub fn available_concurrency() -> io::Result<crate::num::NonZeroUsize> {\n+    super::unsupported()\n+}"}, {"sha": "6a992ad1d3c755fbf3d034af0d34d94794832275", "filename": "library/std/src/sys/itron/time.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,123 @@\n+use super::{abi, error::expect_success};\n+use crate::{convert::TryInto, mem::MaybeUninit, time::Duration};\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct Instant(abi::SYSTIM);\n+\n+impl Instant {\n+    pub fn now() -> Instant {\n+        // Safety: The provided pointer is valid\n+        unsafe {\n+            let mut out = MaybeUninit::uninit();\n+            expect_success(abi::get_tim(out.as_mut_ptr()), &\"get_tim\");\n+            Instant(out.assume_init())\n+        }\n+    }\n+\n+    pub const fn zero() -> Instant {\n+        Instant(0)\n+    }\n+\n+    pub fn actually_monotonic() -> bool {\n+        // There are ways to change the system time\n+        false\n+    }\n+\n+    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n+        self.0.checked_sub(other.0).map(|ticks| {\n+            // `SYSTIM` is measured in microseconds\n+            Duration::from_micros(ticks)\n+        })\n+    }\n+\n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n+        // `SYSTIM` is measured in microseconds\n+        let ticks = other.as_micros();\n+\n+        Some(Instant(self.0.checked_add(ticks.try_into().ok()?)?))\n+    }\n+\n+    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n+        // `SYSTIM` is measured in microseconds\n+        let ticks = other.as_micros();\n+\n+        Some(Instant(self.0.checked_sub(ticks.try_into().ok()?)?))\n+    }\n+}\n+\n+/// Split `Duration` into zero or more `RELTIM`s.\n+#[inline]\n+pub fn dur2reltims(dur: Duration) -> impl Iterator<Item = abi::RELTIM> {\n+    // `RELTIM` is microseconds\n+    let mut ticks = dur.as_micros();\n+\n+    crate::iter::from_fn(move || {\n+        if ticks == 0 {\n+            None\n+        } else if ticks <= abi::TMAX_RELTIM as u128 {\n+            Some(crate::mem::replace(&mut ticks, 0) as abi::RELTIM)\n+        } else {\n+            ticks -= abi::TMAX_RELTIM as u128;\n+            Some(abi::TMAX_RELTIM)\n+        }\n+    })\n+}\n+\n+/// Split `Duration` into one or more `TMO`s.\n+#[inline]\n+fn dur2tmos(dur: Duration) -> impl Iterator<Item = abi::TMO> {\n+    // `TMO` is microseconds\n+    let mut ticks = dur.as_micros();\n+    let mut end = false;\n+\n+    crate::iter::from_fn(move || {\n+        if end {\n+            None\n+        } else if ticks <= abi::TMAX_RELTIM as u128 {\n+            end = true;\n+            Some(crate::mem::replace(&mut ticks, 0) as abi::TMO)\n+        } else {\n+            ticks -= abi::TMAX_RELTIM as u128;\n+            Some(abi::TMAX_RELTIM)\n+        }\n+    })\n+}\n+\n+/// Split `Duration` into one or more API calls with timeout.\n+#[inline]\n+pub fn with_tmos(dur: Duration, mut f: impl FnMut(abi::TMO) -> abi::ER) -> abi::ER {\n+    let mut er = abi::E_TMOUT;\n+    for tmo in dur2tmos(dur) {\n+        er = f(tmo);\n+        if er != abi::E_TMOUT {\n+            break;\n+        }\n+    }\n+    er\n+}\n+\n+/// Split `Duration` into one or more API calls with timeout. This function can\n+/// handle spurious wakeups.\n+#[inline]\n+pub fn with_tmos_strong(dur: Duration, mut f: impl FnMut(abi::TMO) -> abi::ER) -> abi::ER {\n+    // `TMO` and `SYSTIM` are microseconds.\n+    // Clamp at `SYSTIM::MAX` for performance reasons. This shouldn't cause\n+    // a problem in practice. (`u64::MAX` \u03bcs \u2248 584942 years)\n+    let ticks = dur.as_micros().min(abi::SYSTIM::MAX as u128) as abi::SYSTIM;\n+\n+    let start = Instant::now().0;\n+    let mut elapsed = 0;\n+    let mut er = abi::E_TMOUT;\n+    while elapsed <= ticks {\n+        er = f(elapsed.min(abi::TMAX_RELTIM as abi::SYSTIM) as abi::TMO);\n+        if er != abi::E_TMOUT {\n+            break;\n+        }\n+        elapsed = Instant::now().0.wrapping_sub(start);\n+    }\n+\n+    er\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "d14035d9da49f2e4f842f18dd4cf9ed8158e8927", "filename": "library/std/src/sys/itron/time/tests.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime%2Ftests.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,33 @@\n+use super::*;\n+\n+fn reltim2dur(t: u64) -> Duration {\n+    Duration::from_micros(t)\n+}\n+\n+#[test]\n+fn test_dur2reltims() {\n+    assert_eq!(dur2reltims(reltim2dur(0)).collect::<Vec<_>>(), vec![]);\n+    assert_eq!(dur2reltims(reltim2dur(42)).collect::<Vec<_>>(), vec![42]);\n+    assert_eq!(\n+        dur2reltims(reltim2dur(abi::TMAX_RELTIM as u64)).collect::<Vec<_>>(),\n+        vec![abi::TMAX_RELTIM]\n+    );\n+    assert_eq!(\n+        dur2reltims(reltim2dur(abi::TMAX_RELTIM as u64 + 10000)).collect::<Vec<_>>(),\n+        vec![abi::TMAX_RELTIM, 10000]\n+    );\n+}\n+\n+#[test]\n+fn test_dur2tmos() {\n+    assert_eq!(dur2tmos(reltim2dur(0)).collect::<Vec<_>>(), vec![0]);\n+    assert_eq!(dur2tmos(reltim2dur(42)).collect::<Vec<_>>(), vec![42]);\n+    assert_eq!(\n+        dur2tmos(reltim2dur(abi::TMAX_RELTIM as u64)).collect::<Vec<_>>(),\n+        vec![abi::TMAX_RELTIM]\n+    );\n+    assert_eq!(\n+        dur2tmos(reltim2dur(abi::TMAX_RELTIM as u64 + 10000)).collect::<Vec<_>>(),\n+        vec![abi::TMAX_RELTIM, 10000]\n+    );\n+}"}, {"sha": "8b8be6ebc2f55333cf6f68226b1d797dff09f2c1", "filename": "library/std/src/sys/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -31,6 +31,9 @@ cfg_if::cfg_if! {\n     } else if #[cfg(windows)] {\n         mod windows;\n         pub use self::windows::*;\n+    } else if #[cfg(target_os = \"solid_asp3\")] {\n+        mod solid;\n+        pub use self::solid::*;\n     } else if #[cfg(target_os = \"hermit\")] {\n         mod hermit;\n         pub use self::hermit::*;"}, {"sha": "32800bd9a9d0ad2790847cf9ba5230c69283f091", "filename": "library/std/src/sys/solid/abi/fs.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Ffs.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,53 @@\n+//! `solid_fs.h`\n+use crate::os::raw::{c_char, c_int, c_uchar};\n+pub use libc::{\n+    blksize_t, dev_t, ino_t, off_t, stat, time_t, O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR,\n+    O_TRUNC, O_WRONLY, SEEK_CUR, SEEK_END, SEEK_SET, S_IEXEC, S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO,\n+    S_IFMT, S_IFREG, S_IREAD, S_IWRITE,\n+};\n+\n+pub const O_ACCMODE: c_int = 0x3;\n+\n+pub const SOLID_MAX_PATH: usize = 256;\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct dirent {\n+    pub d_ino: ino_t,\n+    pub d_type: c_uchar,\n+    pub d_name: [c_char; 256usize],\n+}\n+\n+pub const DT_UNKNOWN: c_uchar = 0;\n+pub const DT_FIFO: c_uchar = 1;\n+pub const DT_CHR: c_uchar = 2;\n+pub const DT_DIR: c_uchar = 4;\n+pub const DT_BLK: c_uchar = 6;\n+pub const DT_REG: c_uchar = 8;\n+pub const DT_LNK: c_uchar = 10;\n+pub const DT_SOCK: c_uchar = 12;\n+pub const DT_WHT: c_uchar = 14;\n+\n+pub type S_DIR = c_int;\n+\n+extern \"C\" {\n+    pub fn SOLID_FS_Open(fd: *mut c_int, path: *const c_char, mode: c_int) -> c_int;\n+    pub fn SOLID_FS_Close(fd: c_int) -> c_int;\n+    pub fn SOLID_FS_Read(fd: c_int, buf: *mut u8, size: usize, result: *mut usize) -> c_int;\n+    pub fn SOLID_FS_Write(fd: c_int, buf: *const u8, size: usize, result: *mut usize) -> c_int;\n+    pub fn SOLID_FS_Lseek(fd: c_int, offset: off_t, whence: c_int) -> c_int;\n+    pub fn SOLID_FS_Sync(fd: c_int) -> c_int;\n+    pub fn SOLID_FS_Ftell(fd: c_int, result: *mut off_t) -> c_int;\n+    pub fn SOLID_FS_Feof(fd: c_int, result: *mut c_int) -> c_int;\n+    pub fn SOLID_FS_Fsize(fd: c_int, result: *mut usize) -> c_int;\n+    pub fn SOLID_FS_Truncate(path: *const c_char, size: off_t) -> c_int;\n+    pub fn SOLID_FS_OpenDir(path: *const c_char, pDir: *mut S_DIR) -> c_int;\n+    pub fn SOLID_FS_CloseDir(dir: S_DIR) -> c_int;\n+    pub fn SOLID_FS_ReadDir(dir: S_DIR, dirp: *mut dirent) -> c_int;\n+    pub fn SOLID_FS_Stat(path: *const c_char, buf: *mut stat) -> c_int;\n+    pub fn SOLID_FS_Unlink(path: *const c_char) -> c_int;\n+    pub fn SOLID_FS_Rename(oldpath: *const c_char, newpath: *const c_char) -> c_int;\n+    pub fn SOLID_FS_Chmod(path: *const c_char, mode: c_int) -> c_int;\n+    pub fn SOLID_FS_Utime(path: *const c_char, time: time_t) -> c_int;\n+    pub fn SOLID_FS_Mkdir(path: *const c_char) -> c_int;\n+}"}, {"sha": "3526440fb85f02a1d70348bf67326611199537c2", "filename": "library/std/src/sys/solid/abi/mod.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Fmod.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,92 @@\n+use crate::os::raw::c_int;\n+\n+mod fs;\n+pub mod sockets;\n+pub use self::fs::*;\n+\n+pub const SOLID_BP_PROGRAM_EXITED: usize = 15;\n+pub const SOLID_BP_CSABORT: usize = 16;\n+\n+#[inline(always)]\n+pub fn breakpoint_program_exited(tid: usize) {\n+    unsafe {\n+        match () {\n+            #[cfg(target_arch = \"arm\")]\n+            () => asm!(\"bkpt #{}\", const SOLID_BP_PROGRAM_EXITED, in(\"r0\") tid),\n+            #[cfg(target_arch = \"aarch64\")]\n+            () => asm!(\"hlt #{}\", const SOLID_BP_PROGRAM_EXITED, in(\"x0\") tid),\n+        }\n+    }\n+}\n+\n+#[inline(always)]\n+pub fn breakpoint_abort() {\n+    unsafe {\n+        match () {\n+            #[cfg(target_arch = \"arm\")]\n+            () => asm!(\"bkpt #{}\", const SOLID_BP_CSABORT),\n+            #[cfg(target_arch = \"aarch64\")]\n+            () => asm!(\"hlt #{}\", const SOLID_BP_CSABORT),\n+        }\n+    }\n+}\n+\n+// `solid_types.h`\n+pub use super::itron::abi::{ER, ER_ID, E_TMOUT, ID};\n+\n+pub const SOLID_ERR_NOTFOUND: ER = -1000;\n+pub const SOLID_ERR_NOTSUPPORTED: ER = -1001;\n+pub const SOLID_ERR_EBADF: ER = -1002;\n+pub const SOLID_ERR_INVALIDCONTENT: ER = -1003;\n+pub const SOLID_ERR_NOTUSED: ER = -1004;\n+pub const SOLID_ERR_ALREADYUSED: ER = -1005;\n+pub const SOLID_ERR_OUTOFBOUND: ER = -1006;\n+pub const SOLID_ERR_BADSEQUENCE: ER = -1007;\n+pub const SOLID_ERR_UNKNOWNDEVICE: ER = -1008;\n+pub const SOLID_ERR_BUSY: ER = -1009;\n+pub const SOLID_ERR_TIMEOUT: ER = -1010;\n+pub const SOLID_ERR_INVALIDACCESS: ER = -1011;\n+pub const SOLID_ERR_NOTREADY: ER = -1012;\n+\n+// `solid_rtc.h`\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct SOLID_RTC_TIME {\n+    pub tm_sec: c_int,\n+    pub tm_min: c_int,\n+    pub tm_hour: c_int,\n+    pub tm_mday: c_int,\n+    pub tm_mon: c_int,\n+    pub tm_year: c_int,\n+    pub tm_wday: c_int,\n+}\n+\n+extern \"C\" {\n+    pub fn SOLID_RTC_ReadTime(time: *mut SOLID_RTC_TIME) -> c_int;\n+}\n+\n+// `solid_log.h`\n+extern \"C\" {\n+    pub fn SOLID_LOG_write(s: *const u8, l: usize);\n+}\n+\n+// `solid_mem.h`\n+extern \"C\" {\n+    pub fn SOLID_TLS_AddDestructor(id: i32, dtor: unsafe extern \"C\" fn(*mut u8));\n+}\n+\n+// `solid_rng.h`\n+extern \"C\" {\n+    pub fn SOLID_RNG_SampleRandomBytes(buffer: *mut u8, length: usize) -> c_int;\n+}\n+\n+// `rwlock.h`\n+extern \"C\" {\n+    pub fn rwl_loc_rdl(id: ID) -> ER;\n+    pub fn rwl_loc_wrl(id: ID) -> ER;\n+    pub fn rwl_ploc_rdl(id: ID) -> ER;\n+    pub fn rwl_ploc_wrl(id: ID) -> ER;\n+    pub fn rwl_unl_rwl(id: ID) -> ER;\n+    pub fn rwl_acre_rwl() -> ER_ID;\n+    pub fn rwl_del_rwl(id: ID) -> ER;\n+}"}, {"sha": "7c21d0dd25e030eda97c308a3c9fcf8f39aaae3d", "filename": "library/std/src/sys/solid/abi/sockets.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Fsockets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Fsockets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fabi%2Fsockets.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,274 @@\n+use crate::os::raw::{c_char, c_uint, c_void};\n+pub use libc::{c_int, c_long, size_t, ssize_t, suseconds_t, time_t, timeval};\n+\n+pub const SOLID_NET_ERR_BASE: c_int = -2000;\n+pub const EINPROGRESS: c_int = SOLID_NET_ERR_BASE - libc::EINPROGRESS;\n+\n+pub const AF_INET6: i32 = 10;\n+pub const AF_INET: i32 = 2;\n+pub const IPPROTO_IP: i32 = 0;\n+pub const IPPROTO_IPV6: i32 = 41;\n+pub const IPPROTO_TCP: i32 = 6;\n+pub const IPV6_ADD_MEMBERSHIP: i32 = 12;\n+pub const IPV6_DROP_MEMBERSHIP: i32 = 13;\n+pub const IPV6_MULTICAST_LOOP: i32 = 19;\n+pub const IPV6_V6ONLY: i32 = 27;\n+pub const IP_TTL: i32 = 2;\n+pub const IP_MULTICAST_TTL: i32 = 5;\n+pub const IP_MULTICAST_LOOP: i32 = 7;\n+pub const IP_ADD_MEMBERSHIP: i32 = 3;\n+pub const IP_DROP_MEMBERSHIP: i32 = 4;\n+pub const SHUT_RD: i32 = 0;\n+pub const SHUT_RDWR: i32 = 2;\n+pub const SHUT_WR: i32 = 1;\n+pub const SOCK_DGRAM: i32 = 2;\n+pub const SOCK_STREAM: i32 = 1;\n+pub const SOL_SOCKET: i32 = 4095;\n+pub const SO_BROADCAST: i32 = 32;\n+pub const SO_ERROR: i32 = 4103;\n+pub const SO_RCVTIMEO: i32 = 4102;\n+pub const SO_REUSEADDR: i32 = 4;\n+pub const SO_SNDTIMEO: i32 = 4101;\n+pub const SO_LINGER: i32 = 128;\n+pub const TCP_NODELAY: i32 = 1;\n+pub const MSG_PEEK: c_int = 1;\n+pub const FIONBIO: c_long = 0x8008667eu32 as c_long;\n+pub const EAI_NONAME: i32 = -2200;\n+pub const EAI_SERVICE: i32 = -2201;\n+pub const EAI_FAIL: i32 = -2202;\n+pub const EAI_MEMORY: i32 = -2203;\n+pub const EAI_FAMILY: i32 = -2204;\n+\n+pub type sa_family_t = u8;\n+pub type socklen_t = u32;\n+pub type in_addr_t = u32;\n+pub type in_port_t = u16;\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct in_addr {\n+    pub s_addr: in_addr_t,\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct in6_addr {\n+    pub s6_addr: [u8; 16],\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ip_mreq {\n+    pub imr_multiaddr: in_addr,\n+    pub imr_interface: in_addr,\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ipv6_mreq {\n+    pub ipv6mr_multiaddr: in6_addr,\n+    pub ipv6mr_interface: c_uint,\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct msghdr {\n+    pub msg_name: *mut c_void,\n+    pub msg_namelen: socklen_t,\n+    pub msg_iov: *mut iovec,\n+    pub msg_iovlen: c_int,\n+    pub msg_control: *mut c_void,\n+    pub msg_controllen: socklen_t,\n+    pub msg_flags: c_int,\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct sockaddr {\n+    pub sa_len: u8,\n+    pub sa_family: sa_family_t,\n+    pub sa_data: [c_char; 14usize],\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct sockaddr_in {\n+    pub sin_len: u8,\n+    pub sin_family: sa_family_t,\n+    pub sin_port: in_port_t,\n+    pub sin_addr: in_addr,\n+    pub sin_zero: [c_char; 8usize],\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct sockaddr_in6 {\n+    pub sin6_len: u8,\n+    pub sin6_family: sa_family_t,\n+    pub sin6_port: in_port_t,\n+    pub sin6_flowinfo: u32,\n+    pub sin6_addr: in6_addr,\n+    pub sin6_scope_id: u32,\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct sockaddr_storage {\n+    pub s2_len: u8,\n+    pub ss_family: sa_family_t,\n+    pub s2_data1: [c_char; 2usize],\n+    pub s2_data2: [u32; 3usize],\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct addrinfo {\n+    pub ai_flags: c_int,\n+    pub ai_family: c_int,\n+    pub ai_socktype: c_int,\n+    pub ai_protocol: c_int,\n+    pub ai_addrlen: socklen_t,\n+    pub ai_addr: *mut sockaddr,\n+    pub ai_canonname: *mut c_char,\n+    pub ai_next: *mut addrinfo,\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct linger {\n+    pub l_onoff: c_int,\n+    pub l_linger: c_int,\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct iovec {\n+    pub iov_base: *mut c_void,\n+    pub iov_len: usize,\n+}\n+\n+/// This value can be chosen by an application\n+pub const SOLID_NET_FD_SETSIZE: usize = 1;\n+\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct fd_set {\n+    pub num_fds: usize,\n+    pub fds: [c_int; SOLID_NET_FD_SETSIZE],\n+}\n+\n+extern \"C\" {\n+    #[link_name = \"SOLID_NET_StrError\"]\n+    pub fn strerror(errnum: c_int) -> *const c_char;\n+\n+    pub fn SOLID_NET_GetLastError() -> c_int;\n+\n+    #[link_name = \"SOLID_NET_Accept\"]\n+    pub fn accept(s: c_int, addr: *mut sockaddr, addrlen: *mut socklen_t) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_Bind\"]\n+    pub fn bind(s: c_int, name: *const sockaddr, namelen: socklen_t) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_Connect\"]\n+    pub fn connect(s: c_int, name: *const sockaddr, namelen: socklen_t) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_Close\"]\n+    pub fn close(s: c_int) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_GetPeerName\"]\n+    pub fn getpeername(s: c_int, name: *mut sockaddr, namelen: *mut socklen_t) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_GetSockName\"]\n+    pub fn getsockname(s: c_int, name: *mut sockaddr, namelen: *mut socklen_t) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_GetSockOpt\"]\n+    pub fn getsockopt(\n+        s: c_int,\n+        level: c_int,\n+        optname: c_int,\n+        optval: *mut c_void,\n+        optlen: *mut socklen_t,\n+    ) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_SetSockOpt\"]\n+    pub fn setsockopt(\n+        s: c_int,\n+        level: c_int,\n+        optname: c_int,\n+        optval: *const c_void,\n+        optlen: socklen_t,\n+    ) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_Ioctl\"]\n+    pub fn ioctl(s: c_int, cmd: c_long, argp: *mut c_void) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_Listen\"]\n+    pub fn listen(s: c_int, backlog: c_int) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_Recv\"]\n+    pub fn recv(s: c_int, mem: *mut c_void, len: size_t, flags: c_int) -> ssize_t;\n+\n+    #[link_name = \"SOLID_NET_Read\"]\n+    pub fn read(s: c_int, mem: *mut c_void, len: size_t) -> ssize_t;\n+\n+    #[link_name = \"SOLID_NET_Readv\"]\n+    pub fn readv(s: c_int, bufs: *const iovec, bufcnt: c_int) -> ssize_t;\n+\n+    #[link_name = \"SOLID_NET_RecvFrom\"]\n+    pub fn recvfrom(\n+        s: c_int,\n+        mem: *mut c_void,\n+        len: size_t,\n+        flags: c_int,\n+        from: *mut sockaddr,\n+        fromlen: *mut socklen_t,\n+    ) -> ssize_t;\n+\n+    #[link_name = \"SOLID_NET_Send\"]\n+    pub fn send(s: c_int, mem: *const c_void, len: size_t, flags: c_int) -> ssize_t;\n+\n+    #[link_name = \"SOLID_NET_SendMsg\"]\n+    pub fn sendmsg(s: c_int, message: *const msghdr, flags: c_int) -> ssize_t;\n+\n+    #[link_name = \"SOLID_NET_SendTo\"]\n+    pub fn sendto(\n+        s: c_int,\n+        mem: *const c_void,\n+        len: size_t,\n+        flags: c_int,\n+        to: *const sockaddr,\n+        tolen: socklen_t,\n+    ) -> ssize_t;\n+\n+    #[link_name = \"SOLID_NET_Shutdown\"]\n+    pub fn shutdown(s: c_int, how: c_int) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_Socket\"]\n+    pub fn socket(domain: c_int, type_: c_int, protocol: c_int) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_Write\"]\n+    pub fn write(s: c_int, mem: *const c_void, len: size_t) -> ssize_t;\n+\n+    #[link_name = \"SOLID_NET_Writev\"]\n+    pub fn writev(s: c_int, bufs: *const iovec, bufcnt: c_int) -> ssize_t;\n+\n+    #[link_name = \"SOLID_NET_FreeAddrInfo\"]\n+    pub fn freeaddrinfo(ai: *mut addrinfo);\n+\n+    #[link_name = \"SOLID_NET_GetAddrInfo\"]\n+    pub fn getaddrinfo(\n+        nodename: *const c_char,\n+        servname: *const c_char,\n+        hints: *const addrinfo,\n+        res: *mut *mut addrinfo,\n+    ) -> c_int;\n+\n+    #[link_name = \"SOLID_NET_Select\"]\n+    pub fn select(\n+        maxfdp1: c_int,\n+        readset: *mut fd_set,\n+        writeset: *mut fd_set,\n+        exceptset: *mut fd_set,\n+        timeout: *mut timeval,\n+    ) -> c_int;\n+}"}, {"sha": "d013bd87610036aef63e72143da7002472d54574", "filename": "library/std/src/sys/solid/alloc.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Falloc.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,32 @@\n+use crate::{\n+    alloc::{GlobalAlloc, Layout, System},\n+    sys::common::alloc::{realloc_fallback, MIN_ALIGN},\n+};\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+            unsafe { libc::malloc(layout.size()) as *mut u8 }\n+        } else {\n+            unsafe { libc::memalign(layout.align(), layout.size()) as *mut u8 }\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n+        unsafe { libc::free(ptr as *mut libc::c_void) }\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        unsafe {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n+                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n+            } else {\n+                realloc_fallback(self, ptr, layout, new_size)\n+            }\n+        }\n+    }\n+}"}, {"sha": "6855c113b289321ba5005af255debb42f2e3cfcd", "filename": "library/std/src/sys/solid/env.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fenv.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,9 @@\n+pub mod os {\n+    pub const FAMILY: &str = \"itron\";\n+    pub const OS: &str = \"solid\";\n+    pub const DLL_PREFIX: &str = \"\";\n+    pub const DLL_SUFFIX: &str = \".so\";\n+    pub const DLL_EXTENSION: &str = \"so\";\n+    pub const EXE_SUFFIX: &str = \"\";\n+    pub const EXE_EXTENSION: &str = \"\";\n+}"}, {"sha": "547b4f3a9840e87fc77c77cabfb3a1e757c43577", "filename": "library/std/src/sys/solid/error.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ferror.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,55 @@\n+use super::{abi, itron, net};\n+use crate::io::ErrorKind;\n+\n+pub use self::itron::error::{expect_success, ItronError as SolidError};\n+\n+/// Describe the specified SOLID error code. Returns `None` if it's an\n+/// undefined error code.\n+///\n+/// The SOLID error codes are a superset of \u03bcITRON error codes.\n+pub fn error_name(er: abi::ER) -> Option<&'static str> {\n+    match er {\n+        // Success\n+        er if er >= 0 => None,\n+        er if er < abi::sockets::SOLID_NET_ERR_BASE => net::error_name(er),\n+\n+        abi::SOLID_ERR_NOTFOUND => Some(\"not found\"),\n+        abi::SOLID_ERR_NOTSUPPORTED => Some(\"not supported\"),\n+        abi::SOLID_ERR_EBADF => Some(\"bad flags\"),\n+        abi::SOLID_ERR_INVALIDCONTENT => Some(\"invalid content\"),\n+        abi::SOLID_ERR_NOTUSED => Some(\"not used\"),\n+        abi::SOLID_ERR_ALREADYUSED => Some(\"already used\"),\n+        abi::SOLID_ERR_OUTOFBOUND => Some(\"out of bounds\"),\n+        abi::SOLID_ERR_BADSEQUENCE => Some(\"bad sequence\"),\n+        abi::SOLID_ERR_UNKNOWNDEVICE => Some(\"unknown device\"),\n+        abi::SOLID_ERR_BUSY => Some(\"busy\"),\n+        abi::SOLID_ERR_TIMEOUT => Some(\"operation timed out\"),\n+        abi::SOLID_ERR_INVALIDACCESS => Some(\"invalid access\"),\n+        abi::SOLID_ERR_NOTREADY => Some(\"not ready\"),\n+\n+        _ => itron::error::error_name(er),\n+    }\n+}\n+\n+pub fn decode_error_kind(er: abi::ER) -> ErrorKind {\n+    match er {\n+        // Success\n+        er if er >= 0 => ErrorKind::Uncategorized,\n+        er if er < abi::sockets::SOLID_NET_ERR_BASE => net::decode_error_kind(er),\n+\n+        abi::SOLID_ERR_NOTFOUND => ErrorKind::NotFound,\n+        abi::SOLID_ERR_NOTSUPPORTED => ErrorKind::Unsupported,\n+        abi::SOLID_ERR_EBADF => ErrorKind::InvalidInput,\n+        abi::SOLID_ERR_INVALIDCONTENT => ErrorKind::InvalidData,\n+        // abi::SOLID_ERR_NOTUSED\n+        // abi::SOLID_ERR_ALREADYUSED\n+        abi::SOLID_ERR_OUTOFBOUND => ErrorKind::InvalidInput,\n+        // abi::SOLID_ERR_BADSEQUENCE\n+        abi::SOLID_ERR_UNKNOWNDEVICE => ErrorKind::NotFound,\n+        // abi::SOLID_ERR_BUSY\n+        abi::SOLID_ERR_TIMEOUT => ErrorKind::TimedOut,\n+        // abi::SOLID_ERR_INVALIDACCESS\n+        // abi::SOLID_ERR_NOTREADY\n+        _ => itron::error::decode_error_kind(er),\n+    }\n+}"}, {"sha": "abc60b56fbbe5b1886167adedebda25c434bf4b5", "filename": "library/std/src/sys/solid/fs.rs", "status": "added", "additions": 529, "deletions": 0, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,529 @@\n+use super::{abi, error};\n+use crate::{\n+    ffi::{CStr, CString, OsStr, OsString},\n+    fmt,\n+    io::{self, IoSlice, IoSliceMut, SeekFrom},\n+    mem::MaybeUninit,\n+    os::raw::{c_int, c_short},\n+    os::solid::ffi::OsStrExt,\n+    path::{Path, PathBuf},\n+    sync::Arc,\n+    sys::time::SystemTime,\n+    sys::unsupported,\n+};\n+\n+pub use crate::sys_common::fs::try_exists;\n+\n+/// A file descriptor.\n+#[derive(Clone, Copy)]\n+#[rustc_layout_scalar_valid_range_start(0)]\n+// libstd/os/raw/mod.rs assures me that every libstd-supported platform has a\n+// 32-bit c_int. Below is -2, in two's complement, but that only works out\n+// because c_int is 32 bits.\n+#[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\n+struct FileDesc {\n+    fd: c_int,\n+}\n+\n+impl FileDesc {\n+    #[inline]\n+    fn new(fd: c_int) -> FileDesc {\n+        assert_ne!(fd, -1i32);\n+        // Safety: we just asserted that the value is in the valid range and\n+        // isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n+        unsafe { FileDesc { fd } }\n+    }\n+\n+    #[inline]\n+    fn raw(&self) -> c_int {\n+        self.fd\n+    }\n+}\n+\n+pub struct File {\n+    fd: FileDesc,\n+}\n+\n+#[derive(Clone)]\n+pub struct FileAttr {\n+    stat: abi::stat,\n+}\n+\n+// all DirEntry's will have a reference to this struct\n+struct InnerReadDir {\n+    dirp: abi::S_DIR,\n+    root: PathBuf,\n+}\n+\n+pub struct ReadDir {\n+    inner: Arc<InnerReadDir>,\n+}\n+\n+pub struct DirEntry {\n+    entry: abi::dirent,\n+    inner: Arc<InnerReadDir>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct OpenOptions {\n+    // generic\n+    read: bool,\n+    write: bool,\n+    append: bool,\n+    truncate: bool,\n+    create: bool,\n+    create_new: bool,\n+    // system-specific\n+    custom_flags: i32,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct FilePermissions(c_short);\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct FileType(c_short);\n+\n+#[derive(Debug)]\n+pub struct DirBuilder {}\n+\n+impl FileAttr {\n+    pub fn size(&self) -> u64 {\n+        self.stat.st_size as u64\n+    }\n+\n+    pub fn perm(&self) -> FilePermissions {\n+        FilePermissions(self.stat.st_mode)\n+    }\n+\n+    pub fn file_type(&self) -> FileType {\n+        FileType(self.stat.st_mode)\n+    }\n+\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from_time_t(self.stat.st_mtime))\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from_time_t(self.stat.st_atime))\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from_time_t(self.stat.st_ctime))\n+    }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool {\n+        (self.0 & abi::S_IWRITE) == 0\n+    }\n+\n+    pub fn set_readonly(&mut self, readonly: bool) {\n+        if readonly {\n+            self.0 &= !abi::S_IWRITE;\n+        } else {\n+            self.0 |= abi::S_IWRITE;\n+        }\n+    }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool {\n+        self.is(abi::S_IFDIR)\n+    }\n+    pub fn is_file(&self) -> bool {\n+        self.is(abi::S_IFREG)\n+    }\n+    pub fn is_symlink(&self) -> bool {\n+        false\n+    }\n+\n+    pub fn is(&self, mode: c_short) -> bool {\n+        self.0 & abi::S_IFMT == mode\n+    }\n+}\n+\n+pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n+    unsafe {\n+        let mut dir = MaybeUninit::uninit();\n+        error::SolidError::err_if_negative(abi::SOLID_FS_OpenDir(\n+            cstr(p)?.as_ptr(),\n+            dir.as_mut_ptr(),\n+        ))\n+        .map_err(|e| e.as_io_error())?;\n+        let inner = Arc::new(InnerReadDir { dirp: dir.assume_init(), root: p.to_owned() });\n+        Ok(ReadDir { inner })\n+    }\n+}\n+\n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n+        // Thus the result will be e g 'ReadDir(\"/home\")'\n+        fmt::Debug::fmt(&*self.inner.root, f)\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        unsafe {\n+            let mut out_dirent = MaybeUninit::uninit();\n+            error::SolidError::err_if_negative(abi::SOLID_FS_ReadDir(\n+                self.inner.dirp,\n+                out_dirent.as_mut_ptr(),\n+            ))\n+            .ok()?;\n+            Some(Ok(DirEntry { entry: out_dirent.assume_init(), inner: Arc::clone(&self.inner) }))\n+        }\n+    }\n+}\n+\n+impl Drop for InnerReadDir {\n+    fn drop(&mut self) {\n+        unsafe { abi::SOLID_FS_CloseDir(self.dirp) };\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+        self.inner.root.join(OsStr::from_bytes(\n+            unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }.to_bytes(),\n+        ))\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n+        OsStr::from_bytes(unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }.to_bytes())\n+            .to_os_string()\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        lstat(&self.path())\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        match self.entry.d_type {\n+            abi::DT_CHR => Ok(FileType(abi::S_IFCHR)),\n+            abi::DT_FIFO => Ok(FileType(abi::S_IFIFO)),\n+            abi::DT_REG => Ok(FileType(abi::S_IFREG)),\n+            abi::DT_DIR => Ok(FileType(abi::S_IFDIR)),\n+            abi::DT_BLK => Ok(FileType(abi::S_IFBLK)),\n+            _ => lstat(&self.path()).map(|m| m.file_type()),\n+        }\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions {\n+            // generic\n+            read: false,\n+            write: false,\n+            append: false,\n+            truncate: false,\n+            create: false,\n+            create_new: false,\n+            // system-specific\n+            custom_flags: 0,\n+        }\n+    }\n+\n+    pub fn read(&mut self, read: bool) {\n+        self.read = read;\n+    }\n+    pub fn write(&mut self, write: bool) {\n+        self.write = write;\n+    }\n+    pub fn append(&mut self, append: bool) {\n+        self.append = append;\n+    }\n+    pub fn truncate(&mut self, truncate: bool) {\n+        self.truncate = truncate;\n+    }\n+    pub fn create(&mut self, create: bool) {\n+        self.create = create;\n+    }\n+    pub fn create_new(&mut self, create_new: bool) {\n+        self.create_new = create_new;\n+    }\n+\n+    pub fn custom_flags(&mut self, flags: i32) {\n+        self.custom_flags = flags;\n+    }\n+    pub fn mode(&mut self, _mode: u32) {}\n+\n+    fn get_access_mode(&self) -> io::Result<c_int> {\n+        match (self.read, self.write, self.append) {\n+            (true, false, false) => Ok(abi::O_RDONLY),\n+            (false, true, false) => Ok(abi::O_WRONLY),\n+            (true, true, false) => Ok(abi::O_RDWR),\n+            (false, _, true) => Ok(abi::O_WRONLY | abi::O_APPEND),\n+            (true, _, true) => Ok(abi::O_RDWR | abi::O_APPEND),\n+            (false, false, false) => Err(io::Error::from_raw_os_error(libc::EINVAL)),\n+        }\n+    }\n+\n+    fn get_creation_mode(&self) -> io::Result<c_int> {\n+        match (self.write, self.append) {\n+            (true, false) => {}\n+            (false, false) => {\n+                if self.truncate || self.create || self.create_new {\n+                    return Err(io::Error::from_raw_os_error(libc::EINVAL));\n+                }\n+            }\n+            (_, true) => {\n+                if self.truncate && !self.create_new {\n+                    return Err(io::Error::from_raw_os_error(libc::EINVAL));\n+                }\n+            }\n+        }\n+\n+        Ok(match (self.create, self.truncate, self.create_new) {\n+            (false, false, false) => 0,\n+            (true, false, false) => abi::O_CREAT,\n+            (false, true, false) => abi::O_TRUNC,\n+            (true, true, false) => abi::O_CREAT | abi::O_TRUNC,\n+            (_, _, true) => abi::O_CREAT | abi::O_EXCL,\n+        })\n+    }\n+}\n+\n+fn cstr(path: &Path) -> io::Result<CString> {\n+    Ok(CString::new(path.as_os_str().as_bytes())?)\n+}\n+\n+impl File {\n+    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        let flags = opts.get_access_mode()?\n+            | opts.get_creation_mode()?\n+            | (opts.custom_flags as c_int & !abi::O_ACCMODE);\n+        unsafe {\n+            let mut fd = MaybeUninit::uninit();\n+            error::SolidError::err_if_negative(abi::SOLID_FS_Open(\n+                fd.as_mut_ptr(),\n+                cstr(path)?.as_ptr(),\n+                flags,\n+            ))\n+            .map_err(|e| e.as_io_error())?;\n+            Ok(File { fd: FileDesc::new(fd.assume_init()) })\n+        }\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        unsupported()\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        self.flush()\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        self.flush()\n+    }\n+\n+    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n+        unsupported()\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        unsafe {\n+            let mut out_num_bytes = MaybeUninit::uninit();\n+            error::SolidError::err_if_negative(abi::SOLID_FS_Read(\n+                self.fd.raw(),\n+                buf.as_mut_ptr(),\n+                buf.len(),\n+                out_num_bytes.as_mut_ptr(),\n+            ))\n+            .map_err(|e| e.as_io_error())?;\n+            Ok(out_num_bytes.assume_init())\n+        }\n+    }\n+\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        crate::io::default_read_vectored(|buf| self.read(buf), bufs)\n+    }\n+\n+    pub fn is_read_vectored(&self) -> bool {\n+        false\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        unsafe {\n+            let mut out_num_bytes = MaybeUninit::uninit();\n+            error::SolidError::err_if_negative(abi::SOLID_FS_Write(\n+                self.fd.raw(),\n+                buf.as_ptr(),\n+                buf.len(),\n+                out_num_bytes.as_mut_ptr(),\n+            ))\n+            .map_err(|e| e.as_io_error())?;\n+            Ok(out_num_bytes.assume_init())\n+        }\n+    }\n+\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        crate::io::default_write_vectored(|buf| self.write(buf), bufs)\n+    }\n+\n+    pub fn is_write_vectored(&self) -> bool {\n+        false\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        error::SolidError::err_if_negative(unsafe { abi::SOLID_FS_Sync(self.fd.raw()) })\n+            .map_err(|e| e.as_io_error())?;\n+        Ok(())\n+    }\n+\n+    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n+        let (whence, pos) = match pos {\n+            // Casting to `i64` is fine, too large values will end up as\n+            // negative which will cause an error in `SOLID_FS_Lseek`.\n+            SeekFrom::Start(off) => (abi::SEEK_SET, off as i64),\n+            SeekFrom::End(off) => (abi::SEEK_END, off),\n+            SeekFrom::Current(off) => (abi::SEEK_CUR, off),\n+        };\n+        error::SolidError::err_if_negative(unsafe {\n+            abi::SOLID_FS_Lseek(self.fd.raw(), pos, whence)\n+        })\n+        .map_err(|e| e.as_io_error())?;\n+\n+        // Get the new offset\n+        unsafe {\n+            let mut out_offset = MaybeUninit::uninit();\n+            error::SolidError::err_if_negative(abi::SOLID_FS_Ftell(\n+                self.fd.raw(),\n+                out_offset.as_mut_ptr(),\n+            ))\n+            .map_err(|e| e.as_io_error())?;\n+            Ok(out_offset.assume_init() as u64)\n+        }\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<File> {\n+        unsupported()\n+    }\n+\n+    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n+        unsupported()\n+    }\n+}\n+\n+impl Drop for File {\n+    fn drop(&mut self) {\n+        unsafe { abi::SOLID_FS_Close(self.fd.raw()) };\n+    }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder {}\n+    }\n+\n+    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n+        error::SolidError::err_if_negative(unsafe { abi::SOLID_FS_Mkdir(cstr(p)?.as_ptr()) })\n+            .map_err(|e| e.as_io_error())?;\n+        Ok(())\n+    }\n+}\n+\n+impl fmt::Debug for File {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"File\").field(\"fd\", &self.fd.raw()).finish()\n+    }\n+}\n+\n+pub fn unlink(p: &Path) -> io::Result<()> {\n+    if stat(p)?.file_type().is_dir() {\n+        Err(io::Error::new_const(io::ErrorKind::IsADirectory, &\"is a directory\"))\n+    } else {\n+        error::SolidError::err_if_negative(unsafe { abi::SOLID_FS_Unlink(cstr(p)?.as_ptr()) })\n+            .map_err(|e| e.as_io_error())?;\n+        Ok(())\n+    }\n+}\n+\n+pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n+    error::SolidError::err_if_negative(unsafe {\n+        abi::SOLID_FS_Rename(cstr(old)?.as_ptr(), cstr(new)?.as_ptr())\n+    })\n+    .map_err(|e| e.as_io_error())?;\n+    Ok(())\n+}\n+\n+pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    error::SolidError::err_if_negative(unsafe {\n+        abi::SOLID_FS_Chmod(cstr(p)?.as_ptr(), perm.0.into())\n+    })\n+    .map_err(|e| e.as_io_error())?;\n+    Ok(())\n+}\n+\n+pub fn rmdir(p: &Path) -> io::Result<()> {\n+    if stat(p)?.file_type().is_dir() {\n+        error::SolidError::err_if_negative(unsafe { abi::SOLID_FS_Unlink(cstr(p)?.as_ptr()) })\n+            .map_err(|e| e.as_io_error())?;\n+        Ok(())\n+    } else {\n+        Err(io::Error::new_const(io::ErrorKind::NotADirectory, &\"not a directory\"))\n+    }\n+}\n+\n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    for child in readdir(path)? {\n+        let child = child?;\n+        let child_type = child.file_type()?;\n+        if child_type.is_dir() {\n+            remove_dir_all(&child.path())?;\n+        } else {\n+            unlink(&child.path())?;\n+        }\n+    }\n+    rmdir(path)\n+}\n+\n+pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n+    // This target doesn't support symlinks\n+    stat(p)?;\n+    Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"not a symbolic link\"))\n+}\n+\n+pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {\n+    // This target doesn't support symlinks\n+    unsupported()\n+}\n+\n+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    // This target doesn't support symlinks\n+    unsupported()\n+}\n+\n+pub fn stat(p: &Path) -> io::Result<FileAttr> {\n+    // This target doesn't support symlinks\n+    lstat(p)\n+}\n+\n+pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n+    unsafe {\n+        let mut out_stat = MaybeUninit::uninit();\n+        error::SolidError::err_if_negative(abi::SOLID_FS_Stat(\n+            cstr(p)?.as_ptr(),\n+            out_stat.as_mut_ptr(),\n+        ))\n+        .map_err(|e| e.as_io_error())?;\n+        Ok(FileAttr { stat: out_stat.assume_init() })\n+    }\n+}\n+\n+pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    use crate::fs::File;\n+\n+    let mut reader = File::open(from)?;\n+    let mut writer = File::create(to)?;\n+\n+    io::copy(&mut reader, &mut writer)\n+}"}, {"sha": "9eb17a10daa287175a8a3005fc96d274bf666741", "filename": "library/std/src/sys/solid/io.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fio.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,77 @@\n+use crate::marker::PhantomData;\n+use crate::slice;\n+\n+use super::abi::sockets::iovec;\n+use libc::c_void;\n+\n+#[derive(Copy, Clone)]\n+#[repr(transparent)]\n+pub struct IoSlice<'a> {\n+    vec: iovec,\n+    _p: PhantomData<&'a [u8]>,\n+}\n+\n+impl<'a> IoSlice<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n+        IoSlice {\n+            vec: iovec { iov_base: buf.as_ptr() as *mut u8 as *mut c_void, iov_len: buf.len() },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        if self.vec.iov_len < n {\n+            panic!(\"advancing IoSlice beyond its length\");\n+        }\n+\n+        unsafe {\n+            self.vec.iov_len -= n;\n+            self.vec.iov_base = self.vec.iov_base.add(n);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n+    }\n+}\n+\n+#[repr(transparent)]\n+pub struct IoSliceMut<'a> {\n+    vec: iovec,\n+    _p: PhantomData<&'a mut [u8]>,\n+}\n+\n+impl<'a> IoSliceMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n+        IoSliceMut {\n+            vec: iovec { iov_base: buf.as_mut_ptr() as *mut c_void, iov_len: buf.len() },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        if self.vec.iov_len < n {\n+            panic!(\"advancing IoSliceMut beyond its length\");\n+        }\n+\n+        unsafe {\n+            self.vec.iov_len -= n;\n+            self.vec.iov_base = self.vec.iov_base.add(n);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n+    }\n+}"}, {"sha": "452b7a3de1b332dc3dd882cd87d91ab3a44e8028", "filename": "library/std/src/sys/solid/memchr.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmemchr.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,21 @@\n+pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+    let p = unsafe {\n+        libc::memchr(\n+            haystack.as_ptr() as *const libc::c_void,\n+            needle as libc::c_int,\n+            haystack.len(),\n+        )\n+    };\n+    if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n+}\n+\n+pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+    let p = unsafe {\n+        libc::memrchr(\n+            haystack.as_ptr() as *const libc::c_void,\n+            needle as libc::c_int,\n+            haystack.len(),\n+        )\n+    };\n+    if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n+}"}, {"sha": "211b8d7de31f5dd80e9664217720b2c3565b9a15", "filename": "library/std/src/sys/solid/mod.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,96 @@\n+#![allow(dead_code)]\n+#![allow(missing_docs, nonstandard_style)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n+mod abi;\n+\n+#[path = \"../itron\"]\n+mod itron {\n+    pub(super) mod abi;\n+    pub mod condvar;\n+    pub(super) mod error;\n+    pub mod mutex;\n+    pub(super) mod spin;\n+    pub(super) mod task;\n+    pub mod thread;\n+    pub(super) mod time;\n+    use super::unsupported;\n+}\n+\n+pub mod alloc;\n+#[path = \"../unsupported/args.rs\"]\n+pub mod args;\n+#[path = \"../unix/cmath.rs\"]\n+pub mod cmath;\n+pub mod env;\n+// `error` is `pub(crate)` so that it can be accessed by `itron/error.rs` as\n+// `crate::sys::error`\n+pub(crate) mod error;\n+pub mod fs;\n+pub mod io;\n+pub mod net;\n+pub mod os;\n+#[path = \"../unix/os_str.rs\"]\n+pub mod os_str;\n+pub mod path;\n+#[path = \"../unsupported/pipe.rs\"]\n+pub mod pipe;\n+#[path = \"../unsupported/process.rs\"]\n+pub mod process;\n+pub mod rwlock;\n+pub mod stdio;\n+pub use self::itron::{condvar, mutex, thread};\n+pub mod memchr;\n+pub mod thread_local_dtor;\n+pub mod thread_local_key;\n+pub mod time;\n+\n+// SAFETY: must be called only once during runtime initialization.\n+// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n+pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n+\n+// SAFETY: must be called only once during runtime cleanup.\n+pub unsafe fn cleanup() {}\n+\n+pub fn unsupported<T>() -> crate::io::Result<T> {\n+    Err(unsupported_err())\n+}\n+\n+pub fn unsupported_err() -> crate::io::Error {\n+    crate::io::Error::new_const(\n+        crate::io::ErrorKind::Unsupported,\n+        &\"operation not supported on this platform\",\n+    )\n+}\n+\n+pub fn decode_error_kind(code: i32) -> crate::io::ErrorKind {\n+    error::decode_error_kind(code)\n+}\n+\n+#[inline(always)]\n+pub fn abort_internal() -> ! {\n+    loop {\n+        abi::breakpoint_abort();\n+    }\n+}\n+\n+// This function is needed by the panic runtime. The symbol is named in\n+// pre-link args for the target specification, so keep that in sync.\n+#[cfg(not(test))]\n+#[no_mangle]\n+// NB. used by both libunwind and libpanic_abort\n+pub extern \"C\" fn __rust_abort() {\n+    abort_internal();\n+}\n+\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    unsafe {\n+        let mut out = crate::mem::MaybeUninit::<[u64; 2]>::uninit();\n+        let result = abi::SOLID_RNG_SampleRandomBytes(out.as_mut_ptr() as *mut u8, 16);\n+        assert_eq!(result, 0, \"SOLID_RNG_SampleRandomBytes failed: {}\", result);\n+        let [x1, x2] = out.assume_init();\n+        (x1, x2)\n+    }\n+}\n+\n+pub use libc::strlen;"}, {"sha": "63ba6341c796cd776bd53faea212a1b21769504c", "filename": "library/std/src/sys/solid/net.rs", "status": "added", "additions": 469, "deletions": 0, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,469 @@\n+use super::abi;\n+use crate::{\n+    cmp,\n+    ffi::CStr,\n+    io::{self, ErrorKind, IoSlice, IoSliceMut},\n+    mem,\n+    net::{Shutdown, SocketAddr},\n+    ptr, str,\n+    sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr},\n+    sys_common::{AsInner, FromInner, IntoInner},\n+    time::Duration,\n+};\n+\n+use self::netc::{sockaddr, socklen_t, MSG_PEEK};\n+use libc::{c_int, c_void, size_t};\n+\n+pub mod netc {\n+    pub use super::super::abi::sockets::*;\n+}\n+\n+pub type wrlen_t = size_t;\n+\n+const READ_LIMIT: usize = libc::ssize_t::MAX as usize;\n+\n+const fn max_iov() -> usize {\n+    // Judging by the source code, it's unlimited, but specify a lower\n+    // value just in case.\n+    1024\n+}\n+\n+/// A file descriptor.\n+#[rustc_layout_scalar_valid_range_start(0)]\n+// libstd/os/raw/mod.rs assures me that every libstd-supported platform has a\n+// 32-bit c_int. Below is -2, in two's complement, but that only works out\n+// because c_int is 32 bits.\n+#[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\n+struct FileDesc {\n+    fd: c_int,\n+}\n+\n+impl FileDesc {\n+    #[inline]\n+    fn new(fd: c_int) -> FileDesc {\n+        assert_ne!(fd, -1i32);\n+        // Safety: we just asserted that the value is in the valid range and\n+        // isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n+        unsafe { FileDesc { fd } }\n+    }\n+\n+    #[inline]\n+    fn raw(&self) -> c_int {\n+        self.fd\n+    }\n+\n+    /// Extracts the actual file descriptor without closing it.\n+    #[inline]\n+    fn into_raw(self) -> c_int {\n+        let fd = self.fd;\n+        mem::forget(self);\n+        fd\n+    }\n+\n+    fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            netc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), READ_LIMIT))\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            netc::readv(\n+                self.fd,\n+                bufs.as_ptr() as *const netc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as c_int,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    #[inline]\n+    fn is_read_vectored(&self) -> bool {\n+        true\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            netc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), READ_LIMIT))\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            netc::writev(\n+                self.fd,\n+                bufs.as_ptr() as *const netc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as c_int,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        true\n+    }\n+\n+    fn duplicate(&self) -> io::Result<FileDesc> {\n+        super::unsupported()\n+    }\n+}\n+\n+impl AsInner<c_int> for FileDesc {\n+    fn as_inner(&self) -> &c_int {\n+        &self.fd\n+    }\n+}\n+\n+impl Drop for FileDesc {\n+    fn drop(&mut self) {\n+        unsafe { netc::close(self.fd) };\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub trait IsMinusOne {\n+    fn is_minus_one(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_minus_one {\n+    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n+        fn is_minus_one(&self) -> bool {\n+            *self == -1\n+        }\n+    })*)\n+}\n+\n+impl_is_minus_one! { i8 i16 i32 i64 isize }\n+\n+pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n+    if t.is_minus_one() { Err(last_error()) } else { Ok(t) }\n+}\n+\n+/// A variant of `cvt` for `getaddrinfo` which return 0 for a success.\n+pub fn cvt_gai(err: c_int) -> io::Result<()> {\n+    if err == 0 {\n+        Ok(())\n+    } else {\n+        let msg: &dyn crate::fmt::Display = match err {\n+            netc::EAI_NONAME => &\"name or service not known\",\n+            netc::EAI_SERVICE => &\"service not supported\",\n+            netc::EAI_FAIL => &\"non-recoverable failure in name resolution\",\n+            netc::EAI_MEMORY => &\"memory allocation failure\",\n+            netc::EAI_FAMILY => &\"family not supported\",\n+            _ => &err,\n+        };\n+        Err(io::Error::new(\n+            io::ErrorKind::Uncategorized,\n+            &format!(\"failed to lookup address information: {}\", msg)[..],\n+        ))\n+    }\n+}\n+\n+/// Just to provide the same interface as sys/unix/net.rs\n+pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n+where\n+    T: IsMinusOne,\n+    F: FnMut() -> T,\n+{\n+    cvt(f())\n+}\n+\n+/// Returns the last error from the network subsystem.\n+fn last_error() -> io::Error {\n+    io::Error::from_raw_os_error(unsafe { netc::SOLID_NET_GetLastError() })\n+}\n+\n+pub(super) fn error_name(er: abi::ER) -> Option<&'static str> {\n+    unsafe { CStr::from_ptr(netc::strerror(er)) }.to_str().ok()\n+}\n+\n+pub(super) fn decode_error_kind(er: abi::ER) -> ErrorKind {\n+    let errno = netc::SOLID_NET_ERR_BASE - er;\n+    match errno as libc::c_int {\n+        libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n+        libc::ECONNRESET => ErrorKind::ConnectionReset,\n+        libc::EPERM | libc::EACCES => ErrorKind::PermissionDenied,\n+        libc::EPIPE => ErrorKind::BrokenPipe,\n+        libc::ENOTCONN => ErrorKind::NotConnected,\n+        libc::ECONNABORTED => ErrorKind::ConnectionAborted,\n+        libc::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n+        libc::EADDRINUSE => ErrorKind::AddrInUse,\n+        libc::ENOENT => ErrorKind::NotFound,\n+        libc::EINTR => ErrorKind::Interrupted,\n+        libc::EINVAL => ErrorKind::InvalidInput,\n+        libc::ETIMEDOUT => ErrorKind::TimedOut,\n+        libc::EEXIST => ErrorKind::AlreadyExists,\n+        libc::ENOSYS => ErrorKind::Unsupported,\n+        libc::ENOMEM => ErrorKind::OutOfMemory,\n+        libc::EAGAIN => ErrorKind::WouldBlock,\n+\n+        _ => ErrorKind::Uncategorized,\n+    }\n+}\n+\n+pub fn init() {}\n+\n+pub struct Socket(FileDesc);\n+\n+impl Socket {\n+    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n+        let fam = match *addr {\n+            SocketAddr::V4(..) => netc::AF_INET,\n+            SocketAddr::V6(..) => netc::AF_INET6,\n+        };\n+        Socket::new_raw(fam, ty)\n+    }\n+\n+    pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n+        unsafe {\n+            let fd = cvt(netc::socket(fam, ty, 0))?;\n+            let fd = FileDesc::new(fd);\n+            let socket = Socket(fd);\n+\n+            Ok(socket)\n+        }\n+    }\n+\n+    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n+        self.set_nonblocking(true)?;\n+        let r = unsafe {\n+            let (addrp, len) = addr.into_inner();\n+            cvt(netc::connect(self.0.raw(), addrp, len))\n+        };\n+        self.set_nonblocking(false)?;\n+\n+        match r {\n+            Ok(_) => return Ok(()),\n+            // there's no ErrorKind for EINPROGRESS\n+            Err(ref e) if e.raw_os_error() == Some(netc::EINPROGRESS) => {}\n+            Err(e) => return Err(e),\n+        }\n+\n+        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n+            return Err(io::Error::new_const(\n+                io::ErrorKind::InvalidInput,\n+                &\"cannot set a 0 duration timeout\",\n+            ));\n+        }\n+\n+        let mut timeout =\n+            netc::timeval { tv_sec: timeout.as_secs() as _, tv_usec: timeout.subsec_micros() as _ };\n+        if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n+            timeout.tv_usec = 1;\n+        }\n+\n+        let fds = netc::fd_set { num_fds: 1, fds: [self.0.raw()] };\n+\n+        let mut writefds = fds;\n+        let mut errorfds = fds;\n+\n+        let n = unsafe {\n+            cvt(netc::select(\n+                self.0.raw() + 1,\n+                ptr::null_mut(),\n+                &mut writefds,\n+                &mut errorfds,\n+                &mut timeout,\n+            ))?\n+        };\n+\n+        match n {\n+            0 => Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\")),\n+            _ => {\n+                let can_write = writefds.num_fds != 0;\n+                if !can_write {\n+                    if let Some(e) = self.take_error()? {\n+                        return Err(e);\n+                    }\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n+        let fd = cvt_r(|| unsafe { netc::accept(self.0.raw(), storage, len) })?;\n+        let fd = FileDesc::new(fd);\n+        Ok(Socket(fd))\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<Socket> {\n+        self.0.duplicate().map(Socket)\n+    }\n+\n+    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            netc::recv(self.0.raw(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, MSG_PEEK)\n+    }\n+\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n+    #[inline]\n+    pub fn is_read_vectored(&self) -> bool {\n+        self.0.is_read_vectored()\n+    }\n+\n+    fn recv_from_with_flags(\n+        &self,\n+        buf: &mut [u8],\n+        flags: c_int,\n+    ) -> io::Result<(usize, SocketAddr)> {\n+        let mut storage: netc::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut addrlen = mem::size_of_val(&storage) as netc::socklen_t;\n+\n+        let n = cvt(unsafe {\n+            netc::recvfrom(\n+                self.0.raw(),\n+                buf.as_mut_ptr() as *mut c_void,\n+                buf.len(),\n+                flags,\n+                &mut storage as *mut _ as *mut _,\n+                &mut addrlen,\n+            )\n+        })?;\n+        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n+    }\n+\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, MSG_PEEK)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n+    #[inline]\n+    pub fn is_write_vectored(&self) -> bool {\n+        self.0.is_write_vectored()\n+    }\n+\n+    pub fn set_timeout(&self, dur: Option<Duration>, kind: c_int) -> io::Result<()> {\n+        let timeout = match dur {\n+            Some(dur) => {\n+                if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n+                    return Err(io::Error::new_const(\n+                        io::ErrorKind::InvalidInput,\n+                        &\"cannot set a 0 duration timeout\",\n+                    ));\n+                }\n+\n+                let secs = if dur.as_secs() > netc::c_long::MAX as u64 {\n+                    netc::c_long::MAX\n+                } else {\n+                    dur.as_secs() as netc::c_long\n+                };\n+                let mut timeout = netc::timeval { tv_sec: secs, tv_usec: dur.subsec_micros() as _ };\n+                if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n+                    timeout.tv_usec = 1;\n+                }\n+                timeout\n+            }\n+            None => netc::timeval { tv_sec: 0, tv_usec: 0 },\n+        };\n+        setsockopt(self, netc::SOL_SOCKET, kind, timeout)\n+    }\n+\n+    pub fn timeout(&self, kind: c_int) -> io::Result<Option<Duration>> {\n+        let raw: netc::timeval = getsockopt(self, netc::SOL_SOCKET, kind)?;\n+        if raw.tv_sec == 0 && raw.tv_usec == 0 {\n+            Ok(None)\n+        } else {\n+            let sec = raw.tv_sec as u64;\n+            let nsec = (raw.tv_usec as u32) * 1000;\n+            Ok(Some(Duration::new(sec, nsec)))\n+        }\n+    }\n+\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        let how = match how {\n+            Shutdown::Write => netc::SHUT_WR,\n+            Shutdown::Read => netc::SHUT_RD,\n+            Shutdown::Both => netc::SHUT_RDWR,\n+        };\n+        cvt(unsafe { netc::shutdown(self.0.raw(), how) })?;\n+        Ok(())\n+    }\n+\n+    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {\n+        let linger = netc::linger {\n+            l_onoff: linger.is_some() as netc::c_int,\n+            l_linger: linger.unwrap_or_default().as_secs() as netc::c_int,\n+        };\n+\n+        setsockopt(self, netc::SOL_SOCKET, netc::SO_LINGER, linger)\n+    }\n+\n+    pub fn linger(&self) -> io::Result<Option<Duration>> {\n+        let val: netc::linger = getsockopt(self, netc::SOL_SOCKET, netc::SO_LINGER)?;\n+\n+        Ok((val.l_onoff != 0).then(|| Duration::from_secs(val.l_linger as u64)))\n+    }\n+\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        setsockopt(self, netc::IPPROTO_TCP, netc::TCP_NODELAY, nodelay as c_int)\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        let raw: c_int = getsockopt(self, netc::IPPROTO_TCP, netc::TCP_NODELAY)?;\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        let mut nonblocking = nonblocking as c_int;\n+        cvt(unsafe {\n+            netc::ioctl(*self.as_inner(), netc::FIONBIO, (&mut nonblocking) as *mut c_int as _)\n+        })\n+        .map(drop)\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        let raw: c_int = getsockopt(self, netc::SOL_SOCKET, netc::SO_ERROR)?;\n+        if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }\n+    }\n+\n+    // This method is used by sys_common code to abstract over targets.\n+    pub fn as_raw(&self) -> c_int {\n+        *self.as_inner()\n+    }\n+}\n+\n+impl AsInner<c_int> for Socket {\n+    fn as_inner(&self) -> &c_int {\n+        self.0.as_inner()\n+    }\n+}\n+\n+impl FromInner<c_int> for Socket {\n+    fn from_inner(fd: c_int) -> Socket {\n+        Socket(FileDesc::new(fd))\n+    }\n+}\n+\n+impl IntoInner<c_int> for Socket {\n+    fn into_inner(self) -> c_int {\n+        self.0.into_raw()\n+    }\n+}"}, {"sha": "82542d81e6709c18792cf52c457be681798685e6", "filename": "library/std/src/sys/solid/os.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,200 @@\n+use super::unsupported;\n+use crate::error::Error as StdError;\n+use crate::ffi::{CStr, CString, OsStr, OsString};\n+use crate::fmt;\n+use crate::io;\n+use crate::os::{\n+    raw::{c_char, c_int},\n+    solid::ffi::{OsStrExt, OsStringExt},\n+};\n+use crate::path::{self, PathBuf};\n+use crate::sys_common::rwlock::StaticRWLock;\n+use crate::vec;\n+\n+use super::{abi, error, itron, memchr};\n+\n+// `solid` directly maps `errno`s to \u03bcITRON error codes.\n+impl itron::error::ItronError {\n+    #[inline]\n+    pub(crate) fn as_io_error(self) -> crate::io::Error {\n+        crate::io::Error::from_raw_os_error(self.as_raw())\n+    }\n+}\n+\n+pub fn errno() -> i32 {\n+    0\n+}\n+\n+pub fn error_string(errno: i32) -> String {\n+    if let Some(name) = error::error_name(errno) { name.to_owned() } else { format!(\"{}\", errno) }\n+}\n+\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn chdir(_: &path::Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub struct SplitPaths<'a>(&'a !);\n+\n+pub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {\n+    panic!(\"unsupported\")\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> {\n+        *self.0\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n+{\n+    Err(JoinPathsError)\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        \"not supported on this platform yet\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    #[allow(deprecated)]\n+    fn description(&self) -> &str {\n+        \"not supported on this platform yet\"\n+    }\n+}\n+\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+static ENV_LOCK: StaticRWLock = StaticRWLock::new();\n+\n+pub struct Env {\n+    iter: vec::IntoIter<(OsString, OsString)>,\n+}\n+\n+impl !Send for Env {}\n+impl !Sync for Env {}\n+\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+/// Returns a vector of (variable, value) byte-vector pairs for all the\n+/// environment variables of the current process.\n+pub fn env() -> Env {\n+    extern \"C\" {\n+        static mut environ: *const *const c_char;\n+    }\n+\n+    unsafe {\n+        let _guard = ENV_LOCK.read();\n+        let mut result = Vec::new();\n+        if !environ.is_null() {\n+            while !(*environ).is_null() {\n+                if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n+                    result.push(key_value);\n+                }\n+                environ = environ.add(1);\n+            }\n+        }\n+        return Env { iter: result.into_iter() };\n+    }\n+\n+    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n+        // Strategy (copied from glibc): Variable name and value are separated\n+        // by an ASCII equals sign '='. Since a variable name must not be\n+        // empty, allow variable names starting with an equals sign. Skip all\n+        // malformed lines.\n+        if input.is_empty() {\n+            return None;\n+        }\n+        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n+        pos.map(|p| {\n+            (\n+                OsStringExt::from_vec(input[..p].to_vec()),\n+                OsStringExt::from_vec(input[p + 1..].to_vec()),\n+            )\n+        })\n+    }\n+}\n+\n+pub fn getenv(k: &OsStr) -> Option<OsString> {\n+    // environment variables with a nul byte can't be set, so their value is\n+    // always None as well\n+    let k = CString::new(k.as_bytes()).ok()?;\n+    unsafe {\n+        let _guard = ENV_LOCK.read();\n+        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n+        if s.is_null() {\n+            None\n+        } else {\n+            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n+        }\n+    }\n+}\n+\n+pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n+    let k = CString::new(k.as_bytes())?;\n+    let v = CString::new(v.as_bytes())?;\n+\n+    unsafe {\n+        let _guard = ENV_LOCK.write();\n+        cvt_env(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n+    }\n+}\n+\n+pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n+    let nbuf = CString::new(n.as_bytes())?;\n+\n+    unsafe {\n+        let _guard = ENV_LOCK.write();\n+        cvt_env(libc::unsetenv(nbuf.as_ptr())).map(drop)\n+    }\n+}\n+\n+/// In kmclib, `setenv` and `unsetenv` don't always set `errno`, so this\n+/// function just returns a generic error.\n+fn cvt_env(t: c_int) -> io::Result<c_int> {\n+    if t == -1 {\n+        Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"failure\"))\n+    } else {\n+        Ok(t)\n+    }\n+}\n+\n+pub fn temp_dir() -> PathBuf {\n+    panic!(\"no standard temporary directory on this platform\")\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    None\n+}\n+\n+pub fn exit(_code: i32) -> ! {\n+    let tid = itron::task::try_current_task_id().unwrap_or(0);\n+    loop {\n+        abi::breakpoint_program_exited(tid as usize);\n+    }\n+}\n+\n+pub fn getpid() -> u32 {\n+    panic!(\"no pids on this platform\")\n+}"}, {"sha": "4a14332d4999cfda4e64e92aa33b7626955349e7", "filename": "library/std/src/sys/solid/path.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fpath.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,19 @@\n+use crate::ffi::OsStr;\n+use crate::path::Prefix;\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'\\\\'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'\\\\'\n+}\n+\n+pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n+    None\n+}\n+\n+pub const MAIN_SEP_STR: &str = \"\\\\\";\n+pub const MAIN_SEP: char = '\\\\';"}, {"sha": "4e39ac2a93071b72caa8e54f6dfc31d439845c83", "filename": "library/std/src/sys/solid/rwlock.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Frwlock.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,92 @@\n+//! A readers-writer lock implementation backed by the SOLID kernel extension.\n+use super::{\n+    abi,\n+    itron::{\n+        error::{expect_success, expect_success_aborting, fail, ItronError},\n+        spin::SpinIdOnceCell,\n+    },\n+};\n+\n+pub struct RWLock {\n+    /// The ID of the underlying mutex object\n+    rwl: SpinIdOnceCell<()>,\n+}\n+\n+pub type MovableRWLock = RWLock;\n+\n+// Safety: `num_readers` is protected by `mtx_num_readers`\n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {}\n+\n+fn new_rwl() -> Result<abi::ID, ItronError> {\n+    ItronError::err_if_negative(unsafe { abi::rwl_acre_rwl() })\n+}\n+\n+impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock { rwl: SpinIdOnceCell::new() }\n+    }\n+\n+    /// Get the inner mutex's ID, which is lazily created.\n+    fn raw(&self) -> abi::ID {\n+        match self.rwl.get_or_try_init(|| new_rwl().map(|id| (id, ()))) {\n+            Ok((id, ())) => id,\n+            Err(e) => fail(e, &\"rwl_acre_rwl\"),\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        let rwl = self.raw();\n+        expect_success(unsafe { abi::rwl_loc_rdl(rwl) }, &\"rwl_loc_rdl\");\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        let rwl = self.raw();\n+        match unsafe { abi::rwl_ploc_rdl(rwl) } {\n+            abi::E_TMOUT => false,\n+            er => {\n+                expect_success(er, &\"rwl_ploc_rdl\");\n+                true\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        let rwl = self.raw();\n+        expect_success(unsafe { abi::rwl_loc_wrl(rwl) }, &\"rwl_loc_wrl\");\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        let rwl = self.raw();\n+        match unsafe { abi::rwl_ploc_wrl(rwl) } {\n+            abi::E_TMOUT => false,\n+            er => {\n+                expect_success(er, &\"rwl_ploc_wrl\");\n+                true\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        let rwl = self.raw();\n+        expect_success_aborting(unsafe { abi::rwl_unl_rwl(rwl) }, &\"rwl_unl_rwl\");\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        let rwl = self.raw();\n+        expect_success_aborting(unsafe { abi::rwl_unl_rwl(rwl) }, &\"rwl_unl_rwl\");\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        if let Some(rwl) = self.rwl.get().map(|x| x.0) {\n+            expect_success_aborting(unsafe { abi::rwl_del_rwl(rwl) }, &\"rwl_del_rwl\");\n+        }\n+    }\n+}"}, {"sha": "50f0176967b2d518303126b8ddd12a287cbbbb77", "filename": "library/std/src/sys/solid/stdio.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fstdio.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,80 @@\n+use super::abi;\n+use crate::io;\n+\n+pub struct Stdin;\n+pub struct Stdout;\n+pub struct Stderr;\n+struct PanicOutput;\n+\n+impl Stdin {\n+    pub const fn new() -> Stdin {\n+        Stdin\n+    }\n+}\n+\n+impl io::Read for Stdin {\n+    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n+        Ok(0)\n+    }\n+}\n+\n+impl Stdout {\n+    pub const fn new() -> Stdout {\n+        Stdout\n+    }\n+}\n+\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        unsafe { abi::SOLID_LOG_write(buf.as_ptr(), buf.len()) };\n+        Ok(buf.len())\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl Stderr {\n+    pub const fn new() -> Stderr {\n+        Stderr\n+    }\n+}\n+\n+impl io::Write for Stderr {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        unsafe { abi::SOLID_LOG_write(buf.as_ptr(), buf.len()) };\n+        Ok(buf.len())\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl PanicOutput {\n+    pub const fn new() -> PanicOutput {\n+        PanicOutput\n+    }\n+}\n+\n+impl io::Write for PanicOutput {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        unsafe { abi::SOLID_LOG_write(buf.as_ptr(), buf.len()) };\n+        Ok(buf.len())\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+pub const STDIN_BUF_SIZE: usize = 0;\n+\n+pub fn is_ebadf(_err: &io::Error) -> bool {\n+    true\n+}\n+\n+pub fn panic_output() -> Option<impl io::Write> {\n+    Some(PanicOutput::new())\n+}"}, {"sha": "97356457057761014502ea74885732e75b42b248", "filename": "library/std/src/sys/solid/thread_local_dtor.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_dtor.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,50 @@\n+#![cfg(target_thread_local)]\n+#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n+\n+// Simplify dtor registration by using a list of destructors.\n+\n+use super::{abi, itron::task};\n+use crate::cell::Cell;\n+use crate::ptr;\n+\n+#[thread_local]\n+static DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n+\n+type List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n+\n+pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n+    if DTORS.get().is_null() {\n+        let tid = task::current_task_id_aborting();\n+        let v: Box<List> = box Vec::new();\n+        DTORS.set(Box::into_raw(v));\n+\n+        // Register `tls_dtor` to make sure the TLS destructors are called\n+        // for tasks created by other means than `std::thread`\n+        unsafe { abi::SOLID_TLS_AddDestructor(tid as i32, tls_dtor) };\n+    }\n+\n+    let list: &mut List = unsafe { &mut *DTORS.get() };\n+    list.push((t, dtor));\n+}\n+\n+pub unsafe fn run_dtors() {\n+    let ptr = DTORS.get();\n+    if !ptr.is_null() {\n+        // Swap the destructor list, call all registered destructors,\n+        // and repeat this until the list becomes permanently empty.\n+        while let Some(list) = Some(crate::mem::replace(unsafe { &mut *ptr }, Vec::new()))\n+            .filter(|list| !list.is_empty())\n+        {\n+            for (ptr, dtor) in list.into_iter() {\n+                unsafe { dtor(ptr) };\n+            }\n+        }\n+\n+        // Drop the destructor list\n+        unsafe { Box::from_raw(DTORS.replace(ptr::null_mut())) };\n+    }\n+}\n+\n+unsafe extern \"C\" fn tls_dtor(_unused: *mut u8) {\n+    unsafe { run_dtors() };\n+}"}, {"sha": "b17521f701daf99ad021118dc4cbb5ec1a0ef1bc", "filename": "library/std/src/sys/solid/thread_local_key.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_key.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,26 @@\n+pub type Key = usize;\n+\n+#[inline]\n+pub unsafe fn create(_dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n+    panic!(\"should not be used on the solid target\");\n+}\n+\n+#[inline]\n+pub unsafe fn set(_key: Key, _value: *mut u8) {\n+    panic!(\"should not be used on the solid target\");\n+}\n+\n+#[inline]\n+pub unsafe fn get(_key: Key) -> *mut u8 {\n+    panic!(\"should not be used on the solid target\");\n+}\n+\n+#[inline]\n+pub unsafe fn destroy(_key: Key) {\n+    panic!(\"should not be used on the solid target\");\n+}\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    panic!(\"should not be used on the solid target\");\n+}"}, {"sha": "c67a736a9032c551e4ea8d411081eeed691ba604", "filename": "library/std/src/sys/solid/time.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ftime.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,56 @@\n+use super::{abi, error::expect_success};\n+use crate::{convert::TryInto, mem::MaybeUninit, time::Duration};\n+\n+pub use super::itron::time::Instant;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct SystemTime(abi::time_t);\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime(0);\n+\n+impl SystemTime {\n+    pub fn now() -> SystemTime {\n+        let rtc = unsafe {\n+            let mut out = MaybeUninit::zeroed();\n+            expect_success(abi::SOLID_RTC_ReadTime(out.as_mut_ptr()), &\"SOLID_RTC_ReadTime\");\n+            out.assume_init()\n+        };\n+        let t = unsafe {\n+            libc::mktime(&mut libc::tm {\n+                tm_sec: rtc.tm_sec,\n+                tm_min: rtc.tm_min,\n+                tm_hour: rtc.tm_hour,\n+                tm_mday: rtc.tm_mday,\n+                tm_mon: rtc.tm_mon,\n+                tm_year: rtc.tm_year,\n+                tm_wday: rtc.tm_wday,\n+                tm_yday: 0,\n+                tm_isdst: 0,\n+                tm_gmtoff: 0,\n+                tm_zone: crate::ptr::null_mut(),\n+            })\n+        };\n+        assert_ne!(t, -1, \"mktime failed\");\n+        SystemTime(t)\n+    }\n+\n+    pub(super) fn from_time_t(t: abi::time_t) -> Self {\n+        Self(t)\n+    }\n+\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n+        if self.0 >= other.0 {\n+            Ok(Duration::from_secs((self.0 as u64).wrapping_sub(other.0 as u64)))\n+        } else {\n+            Err(Duration::from_secs((other.0 as u64).wrapping_sub(self.0 as u64)))\n+        }\n+    }\n+\n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        Some(SystemTime(self.0.checked_add(other.as_secs().try_into().ok()?)?))\n+    }\n+\n+    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        Some(SystemTime(self.0.checked_sub(other.as_secs().try_into().ok()?)?))\n+    }\n+}"}, {"sha": "358efd662f5683c3650ce38c47cd3f9aec09081d", "filename": "library/std/src/time.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -108,6 +108,7 @@ pub use core::time::FromSecsError;\n /// | UNIX      | [clock_gettime (Monotonic Clock)]                                    |\n /// | Darwin    | [mach_absolute_time]                                                 |\n /// | VXWorks   | [clock_gettime (Monotonic Clock)]                                    |\n+/// | SOLID     | `get_tim`                                                            |\n /// | WASI      | [__wasi_clock_time_get (Monotonic Clock)]                            |\n /// | Windows   | [QueryPerformanceCounter]                                            |\n ///\n@@ -184,6 +185,7 @@ pub struct Instant(time::Instant);\n /// | UNIX      | [clock_gettime (Realtime Clock)]                                     |\n /// | Darwin    | [gettimeofday]                                                       |\n /// | VXWorks   | [clock_gettime (Realtime Clock)]                                     |\n+/// | SOLID     | `SOLID_RTC_ReadTime`                                                 |\n /// | WASI      | [__wasi_clock_time_get (Realtime Clock)]                             |\n /// | Windows   | [GetSystemTimePreciseAsFileTime] / [GetSystemTimeAsFileTime]         |\n ///"}, {"sha": "25be9e7cc6c0cd217769d902ac6c89b7de8fd09a", "filename": "library/unwind/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Funwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/library%2Funwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flib.rs?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -23,6 +23,7 @@ cfg_if::cfg_if! {\n         unix,\n         windows,\n         target_os = \"psp\",\n+        target_os = \"solid_asp3\",\n         all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     ))] {\n         mod libunwind;"}, {"sha": "8c41835183797a7a11a3bc4f03a66fa7aee47eb5", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -14,6 +14,7 @@\n - [Tests](tests/index.md)\n - [Platform Support](platform-support.md)\n     - [aarch64-apple-ios-sim](platform-support/aarch64-apple-ios-sim.md)\n+    - [\\*-kmc-solid_\\*](platform-support/kmc-solid.md)\n - [Target Tier Policy](target-tier-policy.md)\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)"}, {"sha": "e871b08c5b13fe42ee0d9e5df03d4f6df5f74f29", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -202,6 +202,7 @@ target | std | host | notes\n -------|:---:|:----:|-------\n `aarch64-apple-ios-macabi` | ? |  | Apple Catalyst on ARM64\n `aarch64-apple-tvos` | * |  | ARM64 tvOS\n+[`aarch64-kmc-solid_asp3`](platform-support/kmc-solid.md) | \u2713 |  | ARM64 SOLID with TOPPERS/ASP3\n `aarch64-unknown-freebsd` | \u2713 | \u2713 | ARM64 FreeBSD\n `aarch64-unknown-hermit` | ? |  |\n `aarch64-unknown-uefi` | * |  | ARM64 UEFI\n@@ -222,6 +223,8 @@ target | std | host | notes\n `armv7-unknown-freebsd` | \u2713 | \u2713 | ARMv7 FreeBSD\n `armv7-unknown-netbsd-eabihf` | \u2713 | \u2713 |\n `armv7-wrs-vxworks-eabihf` | ? |  |\n+[`armv7a-kmc-solid_asp3-eabi`](platform-support/kmc-solid.md) | \u2713 |  | ARM SOLID with TOPPERS/ASP3\n+[`armv7a-kmc-solid_asp3-eabihf`](platform-support/kmc-solid.md) | \u2713 |  | ARM SOLID with TOPPERS/ASP3, hardfloat\n `armv7a-none-eabihf` | * | | ARM Cortex-A, hardfloat\n `armv7s-apple-ios` | \u2713 |  |\n `avr-unknown-gnu-atmega328` | * |  | AVR. Requires `-Z build-std=core`"}, {"sha": "bbcd0f711c663b35b369e151881a61ed9f876869", "filename": "src/doc/rustc/src/platform-support/kmc-solid.md", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fkmc-solid.md", "raw_url": "https://github.com/rust-lang/rust/raw/da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fkmc-solid.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fkmc-solid.md?ref=da9ca41c318aadcc0a9e8f72f86c1d36c8fe6d5d", "patch": "@@ -0,0 +1,65 @@\n+# \\*-kmc-solid_\\*\n+\n+**Tier: 3**\n+\n+[SOLID] embedded development platform by Kyoto Microcomputer Co., Ltd.\n+\n+[SOLID]: https://www.kmckk.co.jp/eng/SOLID/\n+\n+The target names follow this format: `$ARCH-kmc-solid_$KERNEL-$ABI`, where `$ARCH` specifies the target processor architecture, `$KERNEL` the base kernel, and `$ABI` the target ABI (optional). The following targets are currently defined:\n+\n+|          Target name           | `target_arch` | `target_vendor` | `target_os`  |\n+|--------------------------------|---------------|-----------------|--------------|\n+| `aarch64-kmc-solid_asp3`       | `aarch64`     | `kmc`           | `solid_asp3` |\n+| `armv7a-kmc-solid_asp3-eabi`   | `arm`         | `kmc`           | `solid_asp3` |\n+| `armv7a-kmc-solid_asp3-eabihf` | `arm`         | `kmc`           | `solid_asp3` |\n+\n+## Designated Developers\n+\n+- [@kawadakk](https://github.com/kawadakk)\n+\n+## Requirements\n+\n+This target is cross-compiled.\n+A platform-provided C compiler toolchain is required, though it can be substituted by [GNU Arm Embedded Toolchain](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm) for the purpose of building Rust and functional binaries.\n+\n+## Building\n+\n+The target can be built by enabling it for a `rustc` build.\n+\n+```toml\n+[build]\n+target = [\"aarch64-kmc-solid_asp3\"]\n+```\n+\n+Make sure `aarch64-kmc-elf-gcc` is included in `$PATH`. Alternatively, you can use GNU Arm Embedded Toolchain by adding the following to `config.toml`:\n+\n+```toml\n+[target.aarch64-kmc-solid_asp3]\n+cc = \"arm-none-eabi-gcc\"\n+```\n+\n+## Cross-compilation\n+\n+This target can be cross-compiled from any hosts.\n+\n+## Testing\n+\n+Currently there is no support to run the rustc test suite for this target.\n+\n+## Building Rust programs\n+\n+Building executables is not supported yet.\n+\n+If `rustc` has support for that target and the library artifacts are available, then Rust static libraries can be built for that target:\n+\n+```shell\n+$ rustc --target aarch64-kmc-solid_asp3 your-code.rs --crate-type staticlib\n+$ ls libyour_code.a\n+```\n+\n+On Rust Nightly it's possible to build without the target artifacts available:\n+\n+```text\n+cargo build -Z build-std --target aarch64-kmc-solid_asp3\n+```"}]}