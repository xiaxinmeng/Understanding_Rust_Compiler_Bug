{"sha": "181851fc6b70d85dca534a4428d69fa40dc65446", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MTg1MWZjNmI3MGQ4NWRjYTUzNGE0NDI4ZDY5ZmE0MGRjNjU0NDY=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-08T12:22:11Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-08T15:09:26Z"}, "message": "Always allocate for globals\n\nstatics are rare and constants are copied anyway.\nReading from a constant should then yield a `ByVal` again if possible.", "tree": {"sha": "fc6d6257f9002b5e1e27a878b59ac7a12c5d2e67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc6d6257f9002b5e1e27a878b59ac7a12c5d2e67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/181851fc6b70d85dca534a4428d69fa40dc65446", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmJ1CYACgkQpp+NIls6\n19mlMRAAqpONHmnvFD3r4uzhfoDujm88n0b5K7FtJJRegLnsYjyR4wxA8VwVXvfq\nztdDgzwJfl9j0Dc1Go+6vxeAEL279UYs2TQ3EhkiczO3txQcKbXyaBJtI+WAnWUG\nOHyX5n3DxqPDxpBZwUTS7ZjPartIQhGYuoKb0nViU5KB+rT+ZUz2jeV0njaBPgyj\ni7MNquQJYF+F5FuqT9CpXshwg0s/Uly+CAZVA9rc29+zKl26URugqUMoXLNa/SIg\naFX8oLNr4U+RI5YNaNVs054/WBq5p3+eIFMsGAzihOdguZelrZOVFXC5vUPlQyUL\nyhE8Hv+qHGdnXFRnIDC6yEHUf7WFwqoKIEHESwW/JvgYP+IbjMNU4NLWl8MkCsQH\nssAWasmOv6FUm+PR2ePS2aC/pACxVaOc2SP54iRIiLgxiYloAK/qyMEfGbaf4Nt0\nBeM6/Jn9Ikes3xaZeK9Fa3GhiLQwocOblARMlm1ctutVv16/fxng/Z2xmlYcZFX4\nXEaG2bI65Ujg9VI0Q1TyXutRBrdqmk56TBgJkiC5qK0t8HehBROw25KNxk9qjBPW\nmLTh58IzP9QwY7vVgSIWr4HT82yTe7OKg0mVW6l2tbXxVCS+cynXKaEcjaZryGy8\nbDLo25/pqYe4ASoGGqirhBXzauiLnKVzIkZ2W3/h1KLzFgHK1pY=\n=Od1v\n-----END PGP SIGNATURE-----", "payload": "tree fc6d6257f9002b5e1e27a878b59ac7a12c5d2e67\nparent 4ba2b82f3151c620edf442228de307fe71278555\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1502194931 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1502204966 +0200\n\nAlways allocate for globals\n\nstatics are rare and constants are copied anyway.\nReading from a constant should then yield a `ByVal` again if possible.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/181851fc6b70d85dca534a4428d69fa40dc65446", "html_url": "https://github.com/rust-lang/rust/commit/181851fc6b70d85dca534a4428d69fa40dc65446", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/181851fc6b70d85dca534a4428d69fa40dc65446/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ba2b82f3151c620edf442228de307fe71278555", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ba2b82f3151c620edf442228de307fe71278555", "html_url": "https://github.com/rust-lang/rust/commit/4ba2b82f3151c620edf442228de307fe71278555"}], "stats": {"total": 301, "additions": 91, "deletions": 210}, "files": [{"sha": "5cbad8c4f124f90120b5ba91f0b086b09726b6a9", "filename": "miri/fn_call.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -23,7 +23,7 @@ pub trait EvalContextExt<'tcx> {\n         &mut self,\n         def_id: DefId,\n         arg_operands: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_block: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n@@ -33,7 +33,7 @@ pub trait EvalContextExt<'tcx> {\n     fn call_missing_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         sig: ty::FnSig<'tcx>,\n         path: String,\n@@ -42,7 +42,7 @@ pub trait EvalContextExt<'tcx> {\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         &mut self,\n         def_id: DefId,\n         arg_operands: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_block: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n@@ -329,8 +329,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     if let Ok(instance) = self.resolve_path(path) {\n                         let cid = GlobalId { instance, promoted: None };\n                         // compute global if not cached\n-                        let val = match self.globals.get(&cid).map(|glob| glob.value) {\n-                            Some(value) => self.value_to_primval(value, usize)?.to_u64()?,\n+                        let val = match self.globals.get(&cid).map(|&ptr| ptr) {\n+                            Some(ptr) => self.value_to_primval(Value::by_ref(ptr.into()), usize)?.to_u64()?,\n                             None => eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n                         };\n                         if val == name {\n@@ -459,7 +459,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n     fn call_missing_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         sig: ty::FnSig<'tcx>,\n         path: String,"}, {"sha": "053b2da86f70bec3f4a68b20b994ef5407a92d3e", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -18,7 +18,7 @@ pub trait EvalContextExt<'tcx> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n         target: mir::BasicBlock,\n@@ -30,7 +30,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n         target: mir::BasicBlock,\n@@ -291,7 +291,6 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true } => self.memory.write_repeat(ptr, 0, size)?,\n                     Lvalue::Ptr { .. } => bug!(\"init intrinsic tried to write to fat or unaligned ptr target\"),\n-                    Lvalue::Global(cid) => self.modify_global(cid, init)?,\n                 }\n             }\n \n@@ -469,7 +468,6 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true } =>\n                         self.memory.mark_definedness(ptr, size, false)?,\n                     Lvalue::Ptr { .. } => bug!(\"uninit intrinsic tried to write to fat or unaligned ptr target\"),\n-                    Lvalue::Global(cid) => self.modify_global(cid, uninit)?,\n                 }\n             }\n "}, {"sha": "1dc1682b17f350a0a4be460bddc4c700a368296d", "filename": "miri/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -167,7 +167,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n@@ -179,7 +179,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         ecx: &mut rustc_miri::interpret::EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: ty::Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n         target: mir::BasicBlock,"}, {"sha": "f55c94e67c4747512afc907e0d5909b7ee05e19a", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -7,9 +7,10 @@ use syntax::codemap::Span;\n \n use super::{\n     EvalResult, EvalError, EvalErrorKind,\n-    Global, GlobalId, Lvalue,\n+    GlobalId, Lvalue, Value,\n     PrimVal,\n     EvalContext, StackPopCleanup,\n+    Kind,\n };\n \n use rustc_const_math::ConstInt;\n@@ -30,7 +31,10 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n     \n     let mir = ecx.load_mir(instance.def)?;\n     if !ecx.globals.contains_key(&cid) {\n-        ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n+        let size = ecx.type_size_with_substs(mir.return_ty, instance.substs)?.expect(\"unsized global\");\n+        let align = ecx.type_align_with_substs(mir.return_ty, instance.substs)?;\n+        let ptr = ecx.memory.allocate(size, align, Kind::UninitializedStatic)?;\n+        ecx.globals.insert(cid, ptr);\n         let mutable = !mir.return_ty.is_freeze(\n                 ecx.tcx,\n                 ty::ParamEnv::empty(Reveal::All),\n@@ -47,13 +51,13 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n             instance,\n             mir.span,\n             mir,\n-            Lvalue::Global(cid),\n+            Lvalue::from_ptr(ptr),\n             cleanup,\n         )?;\n \n         while ecx.step()? {}\n     }\n-    let value = ecx.globals.get(&cid).expect(\"global not cached\").value;\n+    let value = Value::by_ref(ecx.globals.get(&cid).expect(\"global not cached\").into());\n     Ok((ecx.value_to_primval(value, mir.return_ty)?, mir.return_ty))\n }\n \n@@ -132,7 +136,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         _arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         _sig: ty::FnSig<'tcx>,\n@@ -168,7 +172,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n         _ecx: &mut EvalContext<'a, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        _dest: Lvalue<'tcx>,\n+        _dest: Lvalue,\n         _dest_ty: Ty<'tcx>,\n         _dest_layout: &'tcx layout::Layout,\n         _target: mir::BasicBlock,"}, {"sha": "beeb07b4ce1b1fad23c6c6ed08a67e2a8b81c748", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 23, "deletions": 95, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -18,7 +18,7 @@ use syntax::abi::Abi;\n \n use super::{\n     EvalError, EvalResult, EvalErrorKind,\n-    Global, GlobalId, Lvalue, LvalueExtra,\n+    GlobalId, Lvalue, LvalueExtra,\n     Memory, MemoryPointer, HasMemory,\n     Kind as MemoryKind,\n     operator,\n@@ -41,7 +41,7 @@ pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n \n     /// Precomputed statics, constants and promoteds.\n-    pub globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n+    pub globals: HashMap<GlobalId<'tcx>, MemoryPointer>,\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'tcx>>,\n@@ -78,7 +78,7 @@ pub struct Frame<'tcx> {\n     pub return_to_block: StackPopCleanup,\n \n     /// The location where the result of the current stack frame should be written to.\n-    pub return_lvalue: Lvalue<'tcx>,\n+    pub return_lvalue: Lvalue,\n \n     /// The list of locals for this stack frame, stored in order as\n     /// `[arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n@@ -386,7 +386,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.type_align_with_substs(ty, self.substs())\n     }\n \n-    fn type_size_with_substs(\n+    pub fn type_size_with_substs(\n         &self,\n         ty: Ty<'tcx>,\n         substs: &'tcx Substs<'tcx>,\n@@ -399,7 +399,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, u64> {\n+    pub fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, u64> {\n         self.type_layout_with_substs(ty, substs).map(|layout| layout.align(&self.tcx.data_layout).abi())\n     }\n \n@@ -419,7 +419,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         instance: ty::Instance<'tcx>,\n         span: codemap::Span,\n         mir: &'tcx mir::Mir<'tcx>,\n-        return_lvalue: Lvalue<'tcx>,\n+        return_lvalue: Lvalue,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n@@ -485,31 +485,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             self.memory.set_cur_frame(cur_frame);\n         }\n         match frame.return_to_block {\n-            StackPopCleanup::MarkStatic(mutable) => if let Lvalue::Global(id) = frame.return_lvalue {\n-                let global_value = self.globals.get_mut(&id)\n-                    .expect(\"global should have been cached (static)\");\n-                match global_value.value {\n-                    // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n-                    Value::ByRef { ptr, aligned: _aligned } =>\n-                        // Alignment does not matter for this call\n-                        self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?,\n-                    Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n-                        self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n-                    },\n-                    Value::ByValPair(val1, val2) => {\n-                        if let PrimVal::Ptr(ptr) = val1 {\n-                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n-                        }\n-                        if let PrimVal::Ptr(ptr) = val2 {\n-                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n-                        }\n-                    },\n-                }\n-                // see comment on `initialized` field\n-                assert!(!global_value.initialized);\n-                global_value.initialized = true;\n-                assert_eq!(global_value.mutable, Mutability::Mutable);\n-                global_value.mutable = mutable;\n+            StackPopCleanup::MarkStatic(mutable) => if let Lvalue::Ptr{ ptr, .. } = frame.return_lvalue {\n+                // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n+                self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?\n             } else {\n                 bug!(\"StackPopCleanup::MarkStatic on: {:?}\", frame.return_lvalue);\n             },\n@@ -543,7 +521,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn assign_discr_and_fields(\n         &mut self,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         discr_offset: u64,\n         operands: &[mir::Operand<'tcx>],\n@@ -568,7 +546,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn assign_fields(\n         &mut self,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         operands: &[mir::Operand<'tcx>],\n     ) -> EvalResult<'tcx> {\n@@ -1046,15 +1024,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Literal::Item { def_id, substs } => {\n                         let instance = self.resolve_associated_const(def_id, substs);\n                         let cid = GlobalId { instance, promoted: None };\n-                        self.globals.get(&cid).expect(\"static/const not cached\").value\n+                        Value::by_ref(self.globals.get(&cid).expect(\"static/const not cached\").into())\n                     }\n \n                     Literal::Promoted { index } => {\n                         let cid = GlobalId {\n                             instance: self.frame().instance,\n                             promoted: Some(index),\n                         };\n-                        self.globals.get(&cid).expect(\"promoted not cached\").value\n+                        Value::by_ref(self.globals.get(&cid).expect(\"promoted not cached\").into())\n                     }\n                 };\n \n@@ -1076,8 +1054,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn force_allocation(\n         &mut self,\n-        lvalue: Lvalue<'tcx>,\n-    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+        lvalue: Lvalue,\n+    ) -> EvalResult<'tcx, Lvalue> {\n         let new_lvalue = match lvalue {\n             Lvalue::Local { frame, local } => {\n                 // -1 since we don't store the return value\n@@ -1098,28 +1076,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 }\n             }\n             Lvalue::Ptr { .. } => lvalue,\n-            Lvalue::Global(cid) => {\n-                let global_val = self.globals.get(&cid).expect(\"global not cached\").clone();\n-                match global_val.value {\n-                    Value::ByRef { ptr, aligned } =>\n-                        Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None },\n-                    _ => {\n-                        let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n-                        self.memory.mark_static(ptr.alloc_id);\n-                        self.write_value_to_ptr(global_val.value, ptr.into(), global_val.ty)?;\n-                        // see comment on `initialized` field\n-                        if global_val.initialized {\n-                            self.memory.mark_static_initalized(ptr.alloc_id, global_val.mutable)?;\n-                        }\n-                        let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n-                        *lval = Global {\n-                            value: Value::by_ref(ptr.into()),\n-                            .. global_val\n-                        };\n-                        Lvalue::from_ptr(ptr)\n-                    },\n-                }\n-            }\n         };\n         Ok(new_lvalue)\n     }\n@@ -1149,15 +1105,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn write_null(\n         &mut self,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         self.write_primval(dest, PrimVal::Bytes(0), dest_ty)\n     }\n \n     pub fn write_ptr(\n         &mut self,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         val: Pointer,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n@@ -1166,7 +1122,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn write_primval(\n         &mut self,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         val: PrimVal,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n@@ -1176,7 +1132,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn write_value(\n         &mut self,\n         src_val: Value,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         //trace!(\"Writing {:?} to {:?} at type {:?}\", src_val, dest, dest_ty);\n@@ -1185,21 +1141,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // correct if we never look at this data with the wrong type.\n \n         match dest {\n-            Lvalue::Global(cid) => {\n-                let dest = self.globals.get_mut(&cid).expect(\"global should be cached\").clone();\n-                if dest.mutable == Mutability::Immutable {\n-                    return err!(ModifiedConstantMemory);\n-                }\n-                let write_dest = |this: &mut Self, val| {\n-                    *this.globals.get_mut(&cid).expect(\"already checked\") = Global {\n-                        value: val,\n-                        ..dest\n-                    };\n-                    Ok(())\n-                };\n-                self.write_value_possibly_by_val(src_val, write_dest, dest.value, dest_ty)\n-            },\n-\n             Lvalue::Ptr { ptr, extra, aligned } => {\n                 assert_eq!(extra, LvalueExtra::None);\n                 self.write_maybe_aligned_mut(aligned,\n@@ -1542,7 +1483,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         src: Value,\n         src_ty: Ty<'tcx>,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         sty: Ty<'tcx>,\n         dty: Ty<'tcx>,\n@@ -1578,7 +1519,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         src: Value,\n         src_ty: Ty<'tcx>,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match (&src_ty.sty, &dest_ty.sty) {\n@@ -1640,7 +1581,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n+    pub fn dump_local(&self, lvalue: Lvalue) {\n         // Debug output\n         if let Lvalue::Local { frame, local } = lvalue {\n             let mut allocs = Vec::new();\n@@ -1680,20 +1621,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    /// Convenience function to ensure correct usage of globals and code-sharing with locals.\n-    pub fn modify_global<F>(&mut self, cid: GlobalId<'tcx>, f: F) -> EvalResult<'tcx>\n-        where F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n-    {\n-        let mut val = self.globals.get(&cid).expect(\"global not cached\").clone();\n-        if val.mutable == Mutability::Immutable {\n-            return err!(ModifiedConstantMemory);\n-        }\n-        val.value = f(self, val.value)?;\n-        *self.globals.get_mut(&cid).expect(\"already checked\") = val;\n-        Ok(())\n-    }\n-\n-    /// Convenience function to ensure correct usage of locals and code-sharing with globals.\n+    /// Convenience function to ensure correct usage of locals\n     pub fn modify_local<F>(\n         &mut self,\n         frame: usize,"}, {"sha": "4485e936b1e7efe60d3bafaf127edd3026f4c5f3", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 13, "deletions": 61, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -2,7 +2,6 @@ use rustc::mir;\n use rustc::ty::layout::{Size, Align};\n use rustc::ty::{self, Ty};\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax::ast::Mutability;\n \n use super::{\n     EvalResult,\n@@ -13,7 +12,7 @@ use super::{\n };\n \n #[derive(Copy, Clone, Debug)]\n-pub enum Lvalue<'tcx> {\n+pub enum Lvalue {\n     /// An lvalue referring to a value allocated in the `Memory` system.\n     Ptr {\n         /// An lvalue may have an invalid (integral or undef) pointer,\n@@ -31,9 +30,6 @@ pub enum Lvalue<'tcx> {\n         frame: usize,\n         local: mir::Local,\n     },\n-\n-    /// An lvalue referring to a global\n-    Global(GlobalId<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -55,19 +51,7 @@ pub struct GlobalId<'tcx> {\n     pub promoted: Option<mir::Promoted>,\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Global<'tcx> {\n-    pub value: Value,\n-    /// Only used in `force_allocation` to ensure we don't mark the memory\n-    /// before the static is initialized. It is possible to convert a\n-    /// global which initially is `Value::ByVal(PrimVal::Undef)` and gets\n-    /// lifted to an allocation before the static is fully initialized\n-    pub(super) initialized: bool,\n-    pub(super) mutable: Mutability,\n-    pub(super) ty: Ty<'tcx>,\n-}\n-\n-impl<'tcx> Lvalue<'tcx> {\n+impl<'tcx> Lvalue {\n     /// Produces an Lvalue that will error if attempted to be read from\n     pub fn undef() -> Self {\n         Self::from_primval_ptr(PrimVal::Undef.into())\n@@ -113,26 +97,6 @@ impl<'tcx> Lvalue<'tcx> {\n     }\n }\n \n-impl<'tcx> Global<'tcx> {\n-    pub(super) fn uninitialized(ty: Ty<'tcx>) -> Self {\n-        Global {\n-            value: Value::ByVal(PrimVal::Undef),\n-            mutable: Mutability::Mutable,\n-            ty,\n-            initialized: false,\n-        }\n-    }\n-\n-    pub(super) fn initialized(ty: Ty<'tcx>, value: Value, mutable: Mutability) -> Self {\n-        Global {\n-            value,\n-            mutable,\n-            ty,\n-            initialized: true,\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     /// Reads a value from the lvalue without going through the intermediate step of obtaining\n     /// a `miri::Lvalue`\n@@ -147,7 +111,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n                 let cid = GlobalId { instance, promoted: None };\n-                Ok(Some(self.globals.get(&cid).expect(\"global not cached\").value))\n+                Ok(Some(Value::by_ref(self.globals.get(&cid).expect(\"global not cached\").into())))\n             },\n             Projection(ref proj) => self.try_read_lvalue_projection(proj),\n         }\n@@ -195,7 +159,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.read_lvalue(lvalue)\n     }\n \n-    pub fn read_lvalue(&self, lvalue: Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn read_lvalue(&self, lvalue: Lvalue) -> EvalResult<'tcx, Value> {\n         match lvalue {\n             Lvalue::Ptr { ptr, extra, aligned } => {\n                 assert_eq!(extra, LvalueExtra::None);\n@@ -204,21 +168,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Lvalue::Local { frame, local } => {\n                 self.stack[frame].get_local(local)\n             }\n-            Lvalue::Global(cid) => {\n-                Ok(self.globals.get(&cid).expect(\"global not cached\").value)\n-            }\n         }\n     }\n \n-    pub fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n             Local(local) => Lvalue::Local { frame: self.cur_frame(), local },\n \n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n-                Lvalue::Global(GlobalId { instance, promoted: None })\n+                let gid = GlobalId { instance, promoted: None };\n+                Lvalue::from_ptr(*self.globals.get(&gid).expect(\"uncached global\"))\n             }\n \n             Projection(ref proj) => {\n@@ -237,11 +199,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn lvalue_field(\n         &mut self,\n-        base: Lvalue<'tcx>,\n+        base: Lvalue,\n         field_index: usize,\n         base_ty: Ty<'tcx>,\n         field_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    ) -> EvalResult<'tcx, Lvalue> {\n         let base_layout = self.type_layout(base_ty)?;\n         use rustc::ty::layout::Layout::*;\n         let (offset, packed) = match *base_layout {\n@@ -312,16 +274,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 Value::ByValPair(..) |\n                 Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n             },\n-            Lvalue::Global(cid) => match self.globals.get(&cid).expect(\"uncached global\").value {\n-                // in case the type has a single field, just return the value\n-                Value::ByVal(_) if self.get_field_count(base_ty).map(|c| c == 1).unwrap_or(false) => {\n-                    assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n-                    return Ok(base);\n-                },\n-                Value::ByRef{..} |\n-                Value::ByValPair(..) |\n-                Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n-            },\n         };\n \n         let offset = match base_extra {\n@@ -352,7 +304,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(Lvalue::Ptr { ptr, extra, aligned: aligned && !packed })\n     }\n \n-    pub(super) fn val_to_lvalue(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub(super) fn val_to_lvalue(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         Ok(match self.tcx.struct_tail(ty).sty {\n             ty::TyDynamic(..) => {\n                 let (ptr, vtable) = val.into_ptr_vtable_pair(&self.memory)?;\n@@ -366,7 +318,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         })\n     }\n \n-    pub(super) fn lvalue_index(&mut self, base: Lvalue<'tcx>, outer_ty: Ty<'tcx>, n: u64) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub(super) fn lvalue_index(&mut self, base: Lvalue, outer_ty: Ty<'tcx>, n: u64) -> EvalResult<'tcx, Lvalue> {\n         // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n         let base = self.force_allocation(base)?;\n         let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n@@ -380,10 +332,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub(super) fn eval_lvalue_projection(\n         &mut self,\n-        base: Lvalue<'tcx>,\n+        base: Lvalue,\n         base_ty: Ty<'tcx>,\n         proj_elem: &mir::ProjectionElem<'tcx, mir::Operand<'tcx>, Ty<'tcx>>,\n-    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    ) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::ProjectionElem::*;\n         let (ptr, extra, aligned) = match *proj_elem {\n             Field(field, field_ty) => {"}, {"sha": "c65c3f2e1038c2aed10e28b4ef0809a0806eb537", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -33,7 +33,7 @@ pub trait Machine<'tcx>: Sized {\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n@@ -44,7 +44,7 @@ pub trait Machine<'tcx>: Sized {\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: ty::Ty<'tcx>,\n         dest_layout: &'tcx ty::layout::Layout,\n         target: mir::BasicBlock,"}, {"sha": "1ea814d57141b3f31bfd0378a0982b4320d9b008", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -234,12 +234,6 @@ pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n     /// The AllocId to assign to the next new regular allocation. Always incremented, never gets smaller.\n     next_alloc_id: u64,\n \n-    /// Set of statics, constants, promoteds, vtables, ... to prevent `mark_static_initalized` from\n-    /// stepping out of its own allocations. This set only contains statics backed by an\n-    /// allocation. If they are ByVal or ByValPair they are not here, but will be inserted once\n-    /// they become ByRef.\n-    static_alloc: HashSet<AllocId>,\n-\n     /// Number of virtual bytes allocated.\n     memory_usage: u64,\n \n@@ -280,7 +274,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             layout,\n             memory_size: max_memory,\n             memory_usage: 0,\n-            static_alloc: HashSet::new(),\n             literal_alloc_cache: HashMap::new(),\n             reads_are_aligned: Cell::new(true),\n             writes_are_aligned: Cell::new(true),\n@@ -859,18 +852,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n /// Reading and writing\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n-    /// mark an allocation as being the entry point to a static (see `static_alloc` field)\n-    pub fn mark_static(&mut self, alloc_id: AllocId) {\n-        trace!(\"mark_static: {:?}\", alloc_id);\n-        if !self.static_alloc.insert(alloc_id) {\n-            bug!(\"tried to mark an allocation ({:?}) as static twice\", alloc_id);\n-        }\n-    }\n \n     /// mark an allocation pointed to by a static as static and initialized\n     pub fn mark_inner_allocation(&mut self, alloc: AllocId, mutability: Mutability) -> EvalResult<'tcx> {\n         // relocations into other statics are not \"inner allocations\"\n-        if !self.static_alloc.contains(&alloc) {\n+        if self.get(alloc).ok().map_or(false, |alloc| alloc.kind != Kind::UninitializedStatic) {\n             self.mark_static_initalized(alloc, mutability)?;\n         }\n         Ok(())"}, {"sha": "b2e5f134d3473672ac96ca0d1643bbc0e36a58eb", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -38,7 +38,6 @@ pub use self::eval_context::{\n pub use self::lvalue::{\n     Lvalue,\n     LvalueExtra,\n-    Global,\n     GlobalId,\n };\n "}, {"sha": "8880be6e848fb2b4a3896842461138cb550a3049", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n         right: &mir::Operand<'tcx>,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n@@ -54,7 +54,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n         right: &mir::Operand<'tcx>,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;"}, {"sha": "ca3c8490e7a7888b739ea3628cfff9e8a79296b6", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -14,9 +14,8 @@ use rustc::ty::subst::Substs;\n use super::{\n     EvalResult,\n     EvalContext, StackPopCleanup, TyAndPacked,\n-    Global, GlobalId, Lvalue,\n-    Value, PrimVal,\n-    HasMemory,\n+    GlobalId, Lvalue,\n+    HasMemory, Kind,\n     Machine,\n };\n \n@@ -179,11 +178,18 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         if self.tcx.has_attr(def_id, \"linkage\") {\n             // FIXME: check that it's `#[linkage = \"extern_weak\"]`\n             trace!(\"Initializing an extern global with NULL\");\n-            self.globals.insert(cid, Global::initialized(self.tcx.type_of(def_id), Value::ByVal(PrimVal::Bytes(0)), mutability));\n+            let ptr_size = self.memory.pointer_size();\n+            let ptr = self.memory.allocate(ptr_size, ptr_size, Kind::UninitializedStatic)?;\n+            self.memory.write_usize(ptr, 0)?;\n+            self.memory.mark_static_initalized(ptr.alloc_id, mutability)?;\n+            self.globals.insert(cid, ptr);\n             return Ok(false);\n         }\n         let mir = self.load_mir(instance.def)?;\n-        self.globals.insert(cid, Global::uninitialized(mir.return_ty));\n+        let size = self.type_size_with_substs(mir.return_ty, substs)?.expect(\"unsized global\");\n+        let align = self.type_align_with_substs(mir.return_ty, substs)?;\n+        let ptr = self.memory.allocate(size, align, Kind::UninitializedStatic)?;\n+        self.globals.insert(cid, ptr);\n         let internally_mutable = !mir.return_ty.is_freeze(\n                 self.tcx,\n                 ty::ParamEnv::empty(Reveal::All),\n@@ -200,7 +206,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             instance,\n             span,\n             mir,\n-            Lvalue::Global(cid),\n+            Lvalue::from_ptr(ptr),\n             cleanup,\n         )?;\n         Ok(true)\n@@ -256,13 +262,15 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                 }\n                 let mir = &self.mir.promoted[index];\n                 self.try(|this| {\n-                    let ty = this.ecx.monomorphize(mir.return_ty, this.instance.substs);\n-                    this.ecx.globals.insert(cid, Global::uninitialized(ty));\n+                    let size = this.ecx.type_size_with_substs(mir.return_ty, this.instance.substs)?.expect(\"unsized global\");\n+                    let align = this.ecx.type_align_with_substs(mir.return_ty, this.instance.substs)?;\n+                    let ptr = this.ecx.memory.allocate(size, align, Kind::UninitializedStatic)?;\n+                    this.ecx.globals.insert(cid, ptr);\n                     trace!(\"pushing stack frame for {:?}\", index);\n                     this.ecx.push_stack_frame(this.instance,\n                                               constant.span,\n                                               mir,\n-                                              Lvalue::Global(cid),\n+                                              Lvalue::from_ptr(ptr),\n                                               StackPopCleanup::MarkStatic(Mutability::Immutable),\n                     )?;\n                     Ok(true)"}, {"sha": "527d5917b6682eb8df52f213fa95fbf2190d68b9", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -11,7 +11,7 @@ use interpret::{\n };\n \n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n-    pub(crate) fn drop_lvalue(&mut self, lval: Lvalue<'tcx>, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n+    pub(crate) fn drop_lvalue(&mut self, lval: Lvalue, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n         trace!(\"drop_lvalue: {:#?}\", lval);\n         // We take the address of the object.  This may well be unaligned, which is fine for us here.\n         // However, unaligned accesses will probably make the actual drop implementation fail -- a problem shared"}, {"sha": "a6412dedd3bfe481bbaf71223d138e654160a89e", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,"}, {"sha": "459309abda7b7f214bbb61d133c1bd9bb25811d4", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -16,7 +16,7 @@ use super::{\n     Machine,\n };\n \n-pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue<'tcx>>;\n+pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue>;\n \n #[derive(Copy, Clone, Debug)]\n enum ValidationMode {\n@@ -242,8 +242,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         }\n                     }\n                 }\n-                Lvalue::Local { .. } | Lvalue::Global(..) => {\n-                    // These are not backed by memory, so we have nothing to do.\n+                Lvalue::Local { .. }  => {\n+                    // Not backed by memory, so we have nothing to do.\n                 }\n             }\n         }"}, {"sha": "cd1bde987fe50cdba207a4e99434e40945c94d49", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181851fc6b70d85dca534a4428d69fa40dc65446/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=181851fc6b70d85dca534a4428d69fa40dc65446", "patch": "@@ -133,6 +133,12 @@ impl ::std::convert::From<MemoryPointer> for Pointer {\n     }\n }\n \n+impl<'a> ::std::convert::From<&'a MemoryPointer> for Pointer {\n+    fn from(ptr: &'a MemoryPointer) -> Self {\n+        PrimVal::Ptr(*ptr).into()\n+    }\n+}\n+\n /// A `PrimVal` represents an immediate, primitive value existing outside of a\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `PrimVal` can either represent the raw bytes"}]}