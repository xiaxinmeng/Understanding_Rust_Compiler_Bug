{"sha": "6fb68f1c813657f0fe6b43be008480822767b891", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmYjY4ZjFjODEzNjU3ZjBmZTZiNDNiZTAwODQ4MDgyMjc2N2I4OTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-15T22:09:51Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-18T17:32:38Z"}, "message": "Introduce machinery for higher-ranked TraitRefs", "tree": {"sha": "89a68fcdb01198bb78adf276481643c6b78f2d3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89a68fcdb01198bb78adf276481643c6b78f2d3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fb68f1c813657f0fe6b43be008480822767b891", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fb68f1c813657f0fe6b43be008480822767b891", "html_url": "https://github.com/rust-lang/rust/commit/6fb68f1c813657f0fe6b43be008480822767b891", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fb68f1c813657f0fe6b43be008480822767b891/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecdb741df766e77789c7ad6ab632772a0992b3f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecdb741df766e77789c7ad6ab632772a0992b3f9", "html_url": "https://github.com/rust-lang/rust/commit/ecdb741df766e77789c7ad6ab632772a0992b3f9"}], "stats": {"total": 501, "additions": 334, "deletions": 167}, "files": [{"sha": "20a29465bbd29b5f9fde6e2332c06cd5cf2f79fb", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -21,11 +21,13 @@ pub use self::DefRegion::*;\n use self::ScopeChain::*;\n \n use session::Session;\n+use middle::def;\n+use middle::resolve::DefMap;\n use middle::subst;\n+use middle::ty;\n use std::fmt;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::print::pprust::{lifetime_to_string};\n@@ -52,7 +54,8 @@ pub type NamedRegionMap = NodeMap<DefRegion>;\n struct LifetimeContext<'a> {\n     sess: &'a Session,\n     named_region_map: &'a mut NamedRegionMap,\n-    scope: Scope<'a>\n+    scope: Scope<'a>,\n+    def_map: &'a DefMap,\n }\n \n enum ScopeChain<'a> {\n@@ -72,12 +75,13 @@ type Scope<'a> = &'a ScopeChain<'a>;\n \n static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n-pub fn krate(sess: &Session, krate: &ast::Crate) -> NamedRegionMap {\n+pub fn krate(sess: &Session, krate: &ast::Crate, def_map: &DefMap) -> NamedRegionMap {\n     let mut named_region_map = NodeMap::new();\n     visit::walk_crate(&mut LifetimeContext {\n         sess: sess,\n         named_region_map: &mut named_region_map,\n-        scope: &ROOT_SCOPE\n+        scope: &ROOT_SCOPE,\n+        def_map: def_map,\n     }, krate);\n     sess.abort_if_errors();\n     named_region_map\n@@ -151,6 +155,27 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                     visit::walk_ty(this, ty);\n                 });\n             }\n+            ast::TyPath(ref path, ref opt_bounds, id) => {\n+                // if this path references a trait, then this will resolve to\n+                // a trait ref, which introduces a binding scope.\n+                match self.def_map.borrow().get(&id) {\n+                    Some(&def::DefTrait(..)) => {\n+                        self.with(LateScope(&Vec::new(), self.scope), |this| {\n+                            this.visit_path(path, id);\n+                        });\n+\n+                        match *opt_bounds {\n+                            Some(ref bounds) => {\n+                                visit::walk_ty_param_bounds_helper(self, bounds);\n+                            }\n+                            None => { }\n+                        }\n+                    }\n+                    _ => {\n+                        visit::walk_ty(self, ty);\n+                    }\n+                }\n+            }\n             _ => {\n                 visit::walk_ty(self, ty)\n             }\n@@ -177,49 +202,22 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n     fn visit_generics(&mut self, generics: &ast::Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.visit_ty_param_bounds(&ty_param.bounds);\n+            visit::walk_ty_param_bounds_helper(self, &ty_param.bounds);\n             match ty_param.default {\n                 Some(ref ty) => self.visit_ty(&**ty),\n                 None => {}\n             }\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n             self.visit_ident(predicate.span, predicate.ident);\n-            self.visit_ty_param_bounds(&predicate.bounds);\n-        }\n-    }\n-}\n-\n-impl<'a> LifetimeContext<'a> {\n-    fn with(&mut self, wrap_scope: ScopeChain, f: |&mut LifetimeContext|) {\n-        let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n-        let mut this = LifetimeContext {\n-            sess: sess,\n-            named_region_map: *named_region_map,\n-            scope: &wrap_scope\n-        };\n-        debug!(\"entering scope {}\", this.scope);\n-        f(&mut this);\n-        debug!(\"exiting scope {}\", this.scope);\n-    }\n-\n-    fn visit_ty_param_bounds(&mut self,\n-                             bounds: &OwnedSlice<ast::TyParamBound>) {\n-        for bound in bounds.iter() {\n-            match *bound {\n-                ast::TraitTyParamBound(ref trait_ref) => {\n-                    self.visit_poly_trait_ref(trait_ref);\n-                }\n-                ast::RegionTyParamBound(ref lifetime) => {\n-                    self.visit_lifetime_ref(lifetime);\n-                }\n-            }\n+            visit::walk_ty_param_bounds_helper(self, &predicate.bounds);\n         }\n     }\n \n     fn visit_poly_trait_ref(&mut self, trait_ref: &ast::PolyTraitRef) {\n-        let ref_id = trait_ref.trait_ref.ref_id;\n-        self.with(LateScope(ref_id, &trait_ref.bound_lifetimes, self.scope), |this| {\n+        debug!(\"visit_poly_trait_ref trait_ref={}\", trait_ref);\n+\n+        self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |this| {\n             this.check_lifetime_defs(&trait_ref.bound_lifetimes);\n             for lifetime in trait_ref.bound_lifetimes.iter() {\n                 this.visit_lifetime_decl(lifetime);"}, {"sha": "ff5d80c8a16a21fa9d5c86bb8be57aa52ecdb17e", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -55,6 +55,7 @@ impl FulfillmentContext {\n                                obligation: Obligation)\n     {\n         debug!(\"register_obligation({})\", obligation.repr(tcx));\n+        assert!(!obligation.trait_ref.has_escaping_regions());\n         self.trait_obligations.push(obligation);\n     }\n "}, {"sha": "38e70ec389e94e578e8ec32299e29d1a70352890", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -31,9 +31,7 @@ use middle::fast_reject;\n use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::ty;\n-use middle::typeck::check::regionmanip;\n use middle::typeck::infer;\n-use middle::typeck::infer::LateBoundRegionConversionTime::*;\n use middle::typeck::infer::{InferCtxt, TypeSkolemizer};\n use middle::ty_fold::TypeFoldable;\n use std::cell::RefCell;\n@@ -211,6 +209,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n          */\n \n         debug!(\"select({})\", obligation.repr(self.tcx()));\n+        assert!(!obligation.trait_ref.has_escaping_regions());\n \n         let stack = self.push_stack(None, obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n@@ -263,6 +262,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n+        assert!(!obligation.trait_ref.has_escaping_regions());\n \n         let stack = self.push_stack(None, obligation);\n         self.evaluate_stack(&stack).may_apply()\n@@ -747,6 +747,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"candidate_from_obligation(cache_skol_trait_ref={}, obligation={})\",\n                cache_skol_trait_ref.repr(self.tcx()),\n                stack.repr(self.tcx()));\n+        assert!(!stack.obligation.trait_ref.has_escaping_regions());\n \n         match self.check_candidate_cache(cache_skol_trait_ref.clone()) {\n             Some(c) => {\n@@ -1707,27 +1708,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        // FIXME(pcwalton): This is a bogus thing to do, but\n-        // it'll do for now until we get the new trait-bound\n-        // region skolemization working.\n-        let (_, new_signature) =\n-            regionmanip::replace_late_bound_regions(\n-                self.tcx(),\n-                closure_type.sig.binder_id,\n-                &closure_type.sig,\n-                |br| self.infcx.next_region_var(\n-                         infer::LateBoundRegion(obligation.cause.span, br,\n-                                                infer::FnCall)));\n-\n-        let arguments_tuple = new_signature.inputs[0];\n-        let trait_ref = Rc::new(ty::TraitRef {\n-            def_id: obligation.trait_ref.def_id,\n-            substs: Substs::new_trait(\n+        let closure_sig = &closure_type.sig;\n+        let arguments_tuple = closure_sig.inputs[0];\n+        let substs =\n+            Substs::new_trait(\n                 vec![arguments_tuple.subst(self.tcx(), substs),\n-                     new_signature.output.unwrap().subst(self.tcx(), substs)],\n+                     closure_sig.output.unwrap().subst(self.tcx(), substs)],\n                 vec![],\n                 vec![],\n-                obligation.self_ty())\n+                obligation.self_ty());\n+        let trait_ref = Rc::new(ty::TraitRef {\n+            def_id: obligation.trait_ref.def_id,\n+            substs: substs,\n         });\n \n         self.confirm(obligation.cause,"}, {"sha": "ec8285c33de762230529b4207c04ad771bd965cb", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 120, "deletions": 2, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -1105,6 +1105,23 @@ pub struct TyTrait {\n     pub bounds: ExistentialBounds\n }\n \n+/**\n+ * A complete reference to a trait. These take numerous guises in syntax,\n+ * but perhaps the most recognizable form is in a where clause:\n+ *\n+ *     T : Foo<U>\n+ *\n+ * This would be represented by a trait-reference where the def-id is the\n+ * def-id for the trait `Foo` and the substs defines `T` as parameter 0 in the\n+ * `SelfSpace` and `U` as parameter 0 in the `TypeSpace`.\n+ *\n+ * Trait references also appear in object types like `Foo<U>`, but in\n+ * that case the `Self` parameter is absent from the substitutions.\n+ *\n+ * Note that a `TraitRef` introduces a level of region binding, to\n+ * account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n+ * U>` or higher-ranked object types.\n+ */\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TraitRef {\n     pub def_id: DefId,\n@@ -1410,6 +1427,14 @@ impl TraitRef {\n         // associated types.\n         self.substs.types.as_slice()\n     }\n+\n+    pub fn has_escaping_regions(&self) -> bool {\n+        self.substs.has_regions_escaping_depth(1)\n+    }\n+\n+    pub fn has_bound_regions(&self) -> bool {\n+        self.substs.has_regions_escaping_depth(0)\n+    }\n }\n \n /// When type checking, we use the `ParameterEnvironment` to track\n@@ -1826,7 +1851,10 @@ impl FlagComputation {\n             }\n \n             &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n-                self.add_substs(&principal.substs);\n+                let mut computation = FlagComputation::new();\n+                computation.add_substs(&principal.substs);\n+                self.add_bound_computation(&computation);\n+\n                 self.add_bounds(bounds);\n             }\n \n@@ -4708,9 +4736,99 @@ pub fn bounds_for_trait_ref(tcx: &ctxt,\n                             -> ty::ParamBounds\n {\n     let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n+\n     debug!(\"bounds_for_trait_ref(trait_def={}, trait_ref={})\",\n            trait_def.repr(tcx), trait_ref.repr(tcx));\n-    trait_def.bounds.subst(tcx, &trait_ref.substs)\n+\n+    // The interaction between HRTB and supertraits is not entirely\n+    // obvious. Let me walk you (and myself) through an example.\n+    //\n+    // Let's start with an easy case. Consider two traits:\n+    //\n+    //     trait Foo<'a> : Bar<'a,'a> { }\n+    //     trait Bar<'b,'c> { }\n+    //\n+    // Now, if we have a trait reference `for<'x> T : Foo<'x>`, then\n+    // we can deduce that `for<'x> T : Bar<'x,'x>`. Basically, if we\n+    // knew that `Foo<'x>` (for any 'x) then we also know that\n+    // `Bar<'x,'x>` (for any 'x). This more-or-less falls out from\n+    // normal substitution.\n+    //\n+    // In terms of why this is sound, the idea is that whenever there\n+    // is an impl of `T:Foo<'a>`, it must show that `T:Bar<'a,'a>`\n+    // holds.  So if there is an impl of `T:Foo<'a>` that applies to\n+    // all `'a`, then we must know that `T:Bar<'a,'a>` holds for all\n+    // `'a`.\n+    //\n+    // Another example to be careful of is this:\n+    //\n+    //     trait Foo1<'a> : for<'b> Bar1<'a,'b> { }\n+    //     trait Bar1<'b,'c> { }\n+    //\n+    // Here, if we have `for<'x> T : Foo1<'x>`, then what do we know?\n+    // The answer is that we know `for<'x,'b> T : Bar1<'x,'b>`. The\n+    // reason is similar to the previous example: any impl of\n+    // `T:Foo1<'x>` must show that `for<'b> T : Bar1<'x, 'b>`.  So\n+    // basically we would want to collapse the bound lifetimes from\n+    // the input (`trait_ref`) and the supertraits.\n+    //\n+    // To achieve this in practice is fairly straightforward. Let's\n+    // consider the more complicated scenario:\n+    //\n+    // - We start out with `for<'x> T : Foo1<'x>`. In this case, `'x`\n+    //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T : Bar1<'x,'b>`,\n+    //   where both `'x` and `'b` would have a DB index of 1.\n+    //   The substitution from the input trait-ref is therefore going to be\n+    //   `'a => 'x` (where `'x` has a DB index of 1).\n+    // - The super-trait-ref is `for<'b> Bar1<'a,'b>`, where `'a` is an\n+    //   early-bound parameter and `'b' is a late-bound parameter with a\n+    //   DB index of 1.\n+    // - If we replace `'a` with `'x` from the input, it too will have\n+    //   a DB index of 1, and thus we'll have `for<'x,'b> Bar1<'x,'b>`\n+    //   just as we wanted.\n+    //\n+    // There is only one catch. If we just apply the substitution `'a\n+    // => 'x` to `for<'b> Bar1<'a,'b>`, the substitution code will\n+    // adjust the DB index because we substituting into a binder (it\n+    // tries to be so smart...) resulting in `for<'x> for<'b>\n+    // Bar1<'x,'b>` (we have no syntax for this, so use your\n+    // imagination). Basically the 'x will have DB index of 2 and 'b\n+    // will have DB index of 1. Not quite what we want. So we apply\n+    // the substitution to the *contents* of the trait reference,\n+    // rather than the trait reference itself (put another way, the\n+    // substitution code expects equal binding levels in the values\n+    // from the substitution and the value being substituted into, and\n+    // this trick achieves that).\n+\n+    // Carefully avoid the binder introduced by each trait-ref by\n+    // substituting over the substs, not the trait-refs themselves,\n+    // thus achieving the \"collapse\" described in the big comment\n+    // above.\n+    let trait_bounds: Vec<_> =\n+        trait_def.bounds.trait_bounds\n+        .iter()\n+        .map(|bound_trait_ref| {\n+            ty::TraitRef::new(bound_trait_ref.def_id,\n+                              bound_trait_ref.substs.subst(tcx, &trait_ref.substs))\n+        })\n+        .map(|bound_trait_ref| Rc::new(bound_trait_ref))\n+        .collect();\n+\n+    debug!(\"bounds_for_trait_ref: trait_bounds={}\",\n+           trait_bounds.repr(tcx));\n+\n+    // The region bounds and builtin bounds do not currently introduce\n+    // binders so we can just substitute in a straightforward way here.\n+    let region_bounds =\n+        trait_def.bounds.region_bounds.subst(tcx, &trait_ref.substs);\n+    let builtin_bounds =\n+        trait_def.bounds.builtin_bounds.subst(tcx, &trait_ref.substs);\n+\n+    ty::ParamBounds {\n+        trait_bounds: trait_bounds,\n+        region_bounds: region_bounds,\n+        builtin_bounds: builtin_bounds,\n+    }\n }\n \n /// Iterate over attributes of a definition."}, {"sha": "52e6bcf5b6d913f1acadb1054f6d0bb4fe8c4205", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -42,7 +42,6 @@ use middle::ty;\n use middle::traits;\n use middle::typeck;\n use std::rc::Rc;\n-use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n use util::ppaux::Repr;\n \n@@ -477,6 +476,7 @@ impl TypeFoldable for traits::VtableParamData {\n // \"super\" routines: these are the default implementations for TypeFolder.\n //\n // They should invoke `foo.fold_with()` to do recursive folding.\n+\n pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                 t: ty::t)\n                                                 -> ty::t {\n@@ -550,9 +550,21 @@ pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         abi: fty.abi,\n     }\n }\n+\n pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                        t: &ty::TraitRef)\n-                                                       -> ty::TraitRef {\n+                                                       -> ty::TraitRef\n+{\n+    this.enter_region_binder();\n+    let result = super_fold_trait_ref_contents(this, t);\n+    this.exit_region_binder();\n+    result\n+}\n+\n+pub fn super_fold_trait_ref_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                                t: &ty::TraitRef)\n+                                                                -> ty::TraitRef\n+{\n     ty::TraitRef {\n         def_id: t.def_id,\n         substs: t.substs.fold_with(this),\n@@ -691,11 +703,26 @@ impl HigherRankedFoldable for ty::FnSig {\n         super_fold_fn_sig_contents(folder, self)\n     }\n }\n+\n+impl HigherRankedFoldable for ty::TraitRef {\n+    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef {\n+        super_fold_trait_ref_contents(folder, self)\n+    }\n+}\n+\n impl<T:TypeFoldable+Repr> HigherRankedFoldable for ty::Binder<T> {\n     fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         ty::bind(self.value.fold_with(folder))\n     }\n }\n+\n+impl<T:HigherRankedFoldable> HigherRankedFoldable for Rc<T> {\n+    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n+        Rc::new((**self).fold_contents(folder))\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n pub struct BottomUpFolder<'a, 'tcx: 'a> {"}, {"sha": "68677492649615936600652419b19e1af03cc29e", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 61, "deletions": 43, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -55,11 +55,10 @@ use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::typeck::lookup_def_tcx;\n-use middle::typeck::infer;\n-use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope, BindingRscope};\n+use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope,\n+                             ShiftedRscope, BindingRscope};\n use middle::typeck::rscope;\n use middle::typeck::TypeAndSubsts;\n-use middle::typeck;\n use util::nodemap::DefIdMap;\n use util::ppaux::{Repr, UserString};\n \n@@ -414,6 +413,16 @@ fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n     vec![input_ty, output]\n }\n \n+pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    ast_trait_ref: &ast::PolyTraitRef,\n+    self_ty: Option<ty::t>,\n+    associated_type: Option<ty::t>)\n+    -> Rc<ty::TraitRef>\n+    where AC: AstConv<'tcx>, RS: RegionScope\n+{\n+    instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, associated_type)\n }\n \n pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n@@ -434,16 +443,9 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n     match lookup_def_tcx(this.tcx(),\n                          ast_trait_ref.path.span,\n                          ast_trait_ref.ref_id) {\n-        def::DefTrait(trait_did) => {\n-            let trait_ref =\n-                Rc::new(ast_path_to_trait_ref(this,\n-                                              rscope,\n-                                              trait_did,\n-                                              self_ty,\n-                                              associated_type,\n-                                              &ast_trait_ref.path,\n-                                              ast_trait_ref.ref_id));\n-\n+        def::DefTrait(trait_def_id) => {\n+            let trait_ref = Rc::new(ast_path_to_trait_ref(this, rscope, trait_def_id, self_ty,\n+                                                          associated_type, &ast_trait_ref.path));\n             this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n                                                       trait_ref.clone());\n             trait_ref\n@@ -456,28 +458,45 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n     }\n }\n \n-pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n-                                         rscope: &RS,\n-                                         trait_def_id: ast::DefId,\n-                                         self_ty: Option<ty::t>,\n-                                         associated_type: Option<ty::t>,\n-                                         path: &ast::Path,\n-                                         binder_id: ast::NodeId)\n-                                         -> ty::TraitRef\n-                                         where AC: AstConv<'tcx>,\n-                                               RS: RegionScope {\n+fn ast_path_to_trait_ref<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    trait_def_id: ast::DefId,\n+    self_ty: Option<ty::t>,\n+    associated_type: Option<ty::t>,\n+    path: &ast::Path)\n+    -> ty::TraitRef\n+    where AC: AstConv<'tcx>, RS: RegionScope\n+{\n     let trait_def = this.get_trait_def(trait_def_id);\n-    ty::TraitRef {\n-        def_id: trait_def_id,\n-        substs: ast_path_substs(this,\n-                                rscope,\n-                                trait_def_id,\n-                                &trait_def.generics,\n-                                self_ty,\n-                                associated_type,\n-                                path,\n-                                binder_id)\n-    }\n+\n+    // the trait reference introduces a binding level here, so\n+    // we need to shift the `rscope`. It'd be nice if we could\n+    // do away with this rscope stuff and work this knowledge\n+    // into resolve_lifetimes, as we do with non-omitted\n+    // lifetimes. Oh well, not there yet.\n+    let shifted_rscope = ShiftedRscope::new(rscope);\n+\n+    let (regions, types) = match path.segments.last().unwrap().parameters {\n+        ast::AngleBracketedParameters(ref data) => {\n+            convert_angle_bracketed_parameters(this, &shifted_rscope, data)\n+        }\n+        ast::ParenthesizedParameters(ref data) => {\n+            (Vec::new(), convert_parenthesized_parameters(this, data))\n+        }\n+    };\n+\n+    let substs = create_substs_for_ast_path(this,\n+                                            &shifted_rscope,\n+                                            path.span,\n+                                            trait_def_id,\n+                                            &trait_def.generics,\n+                                            self_ty,\n+                                            types,\n+                                            regions,\n+                                            associated_type);\n+\n+    ty::TraitRef::new(trait_def_id, substs)\n }\n \n pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n@@ -923,9 +942,9 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                              ast_ty.span,\n                                                              &[Rc::new(result.clone())],\n                                                              ast_bounds);\n-                        ty::mk_trait(tcx,\n-                                     result,\n-                                     bounds)\n+                        let result_ty = ty::mk_trait(tcx, result, bounds);\n+                        debug!(\"ast_ty_to_ty: result_ty={}\", result_ty.repr(this.tcx()));\n+                        result_ty\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty\n@@ -1562,7 +1581,7 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n \n pub struct PartitionedBounds<'a> {\n     pub builtin_bounds: ty::BuiltinBounds,\n-    pub trait_bounds: Vec<&'a ast::TraitRef>,\n+    pub trait_bounds: Vec<&'a ast::PolyTraitRef>,\n     pub region_bounds: Vec<&'a ast::Lifetime>,\n }\n \n@@ -1584,19 +1603,18 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     for &ast_bound in ast_bounds.iter() {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b) => {\n-                let b = &b.trait_ref; // FIXME\n-                match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n+                match lookup_def_tcx(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n                     def::DefTrait(trait_did) => {\n                         match trait_def_ids.get(&trait_did) {\n                             // Already seen this trait. We forbid\n                             // duplicates in the list (for some\n                             // reason).\n                             Some(span) => {\n                                 span_err!(\n-                                    tcx.sess, b.path.span, E0127,\n+                                    tcx.sess, b.trait_ref.path.span, E0127,\n                                     \"trait `{}` already appears in the \\\n                                      list of bounds\",\n-                                    b.path.user_string(tcx));\n+                                    b.trait_ref.path.user_string(tcx));\n                                 tcx.sess.span_note(\n                                     *span,\n                                     \"previous appearance is here\");\n@@ -1607,7 +1625,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                             None => { }\n                         }\n \n-                        trait_def_ids.insert(trait_did, b.path.span);\n+                        trait_def_ids.insert(trait_did, b.trait_ref.path.span);\n \n                         if ty::try_add_builtin_trait(tcx,\n                                                      trait_did,"}, {"sha": "55ed6720dba690be760f2ca4c1a3f0e4908a0a89", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -2006,12 +2006,12 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n         astconv::partition_bounds(this.tcx(), span, all_bounds.as_slice());\n     let trait_bounds: Vec<Rc<ty::TraitRef>> =\n         trait_bounds.into_iter()\n-        .map(|b| {\n-            astconv::instantiate_trait_ref(this,\n-                                           &ExplicitRscope,\n-                                           b,\n-                                           Some(param_ty.to_ty(this.tcx())),\n-                                           Some(param_ty.to_ty(this.tcx())))\n+        .map(|bound| {\n+            astconv::instantiate_poly_trait_ref(this,\n+                                                &ExplicitRscope,\n+                                                bound,\n+                                                Some(param_ty.to_ty(this.tcx())),\n+                                                Some(param_ty.to_ty(this.tcx())))\n         })\n         .collect();\n     let region_bounds: Vec<ty::Region> ="}, {"sha": "0f9554cd417f7fa8ae46555902650a93176541e2", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -59,6 +59,7 @@ use syntax::codemap::Span;\n \n pub trait Combine<'tcx> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx>;\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n     fn tag(&self) -> String;\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n@@ -296,26 +297,14 @@ pub trait Combine<'tcx> {\n                 Err(ty::terr_trait_stores_differ(vk, expected_found(self, a, b)))\n             }\n         }\n-\n     }\n \n     fn trait_refs(&self,\n                   a: &ty::TraitRef,\n                   b: &ty::TraitRef)\n-                  -> cres<ty::TraitRef> {\n-        // Different traits cannot be related\n-\n-        // - NOTE in the future, expand out subtraits!\n-\n-        if a.def_id != b.def_id {\n-            Err(ty::terr_traits(\n-                                expected_found(self, a.def_id, b.def_id)))\n-        } else {\n-            let substs = try!(self.substs(a.def_id, &a.substs, &b.substs));\n-            Ok(ty::TraitRef { def_id: a.def_id,\n-                              substs: substs })\n-        }\n-    }\n+                  -> cres<ty::TraitRef>;\n+    // this must be overridden to do correctly, so as to account for higher-ranked\n+    // behavior\n }\n \n #[deriving(Clone)]"}, {"sha": "3874f5fc5e4aaa2ca4fb0e7386513fa08c661c7b", "filename": "src/librustc/middle/typeck/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -137,4 +137,9 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         try!(self.sub().fn_sigs(a, b));\n         self.sub().fn_sigs(b, a)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        try!(self.sub().trait_refs(a, b));\n+        self.sub().trait_refs(b, a)\n+    }\n }"}, {"sha": "f7e6cef99af93660c4521a97c96e18aa8e66560f", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -31,13 +31,12 @@\n  * a lattice.\n  */\n \n-use middle::ty::{RegionVid, TyVar};\n+use middle::ty::{TyVar};\n use middle::ty;\n use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n-use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n pub trait LatticeDir {\n@@ -101,27 +100,3 @@ pub fn super_lattice_tys<'tcx, L:LatticeDir+Combine<'tcx>>(this: &L,\n         }\n     }\n }\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Random utility functions used by LUB/GLB when computing LUB/GLB of\n-// fn types\n-\n-pub fn var_ids<'tcx, T: Combine<'tcx>>(this: &T,\n-                                       map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n-                                       -> Vec<RegionVid> {\n-    map.iter().map(|(_, r)| match *r {\n-            ty::ReInfer(ty::ReVar(r)) => { r }\n-            r => {\n-                this.infcx().tcx.sess.span_bug(\n-                    this.trace().origin.span(),\n-                    format!(\"found non-region-vid: {}\", r).as_slice());\n-            }\n-        }).collect()\n-}\n-\n-pub fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {\n-    match r {\n-        ty::ReInfer(ty::ReVar(ref v)) => new_vars.iter().any(|x| x == v),\n-        _ => false\n-    }\n-}"}, {"sha": "8856f42d1f5ab6d0fa5366a95dc409193012f58a", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -47,7 +47,7 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        let tcx = self.fields.infcx.tcx;\n+        let tcx = self.tcx();\n \n         debug!(\"{}.mts({}, {})\",\n                self.tag(),\n@@ -107,10 +107,10 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n-        Ok(self.fields.infcx.region_vars.lub_regions(Subtype(self.trace()), a, b))\n+        Ok(self.infcx().region_vars.lub_regions(Subtype(self.trace()), a, b))\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n@@ -120,4 +120,8 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         super_lattice_tys(self, a, b)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        self.higher_ranked_lub(a, b)\n+    }\n }"}, {"sha": "b4689ae098c98ef11814c267c59130fc0fee97a7", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -31,10 +31,9 @@ pub use self::skolemize::TypeSkolemizer;\n use middle::subst;\n use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n+use middle::ty::replace_late_bound_regions;\n use middle::ty;\n-use middle::ty_fold;\n-use middle::ty_fold::{TypeFolder, TypeFoldable};\n-use middle::typeck::check::regionmanip::replace_late_bound_regions;\n+use middle::ty_fold::{HigherRankedFoldable, TypeFolder, TypeFoldable};\n use std::cell::{RefCell};\n use std::rc::Rc;\n use syntax::ast;\n@@ -816,8 +815,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_string(&self, t: &ty::TraitRef) -> String {\n-        let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n+    pub fn trait_ref_to_string(&self, t: &Rc<ty::TraitRef>) -> String {\n+        let t = self.resolve_type_vars_in_trait_ref_if_possible(&**t);\n         trait_ref_to_string(self.tcx, &t)\n     }\n "}, {"sha": "f85cb85ff21a231c0e64c1d9d46c0ffaf5ed1aab", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -63,16 +63,16 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n-        self.fields.infcx.region_vars.make_subregion(Subtype(self.trace()), a, b);\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n+        self.infcx().region_vars.make_subregion(Subtype(self.trace()), a, b);\n         Ok(a)\n     }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         debug!(\"mts({} <: {})\",\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability);\n@@ -121,7 +121,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n+               a.repr(self.tcx()), b.repr(self.tcx()));\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n@@ -158,5 +158,9 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         self.higher_ranked_sub(a, b)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        self.higher_ranked_sub(a, b)\n+    }\n }\n "}, {"sha": "2f72d3cf50db1853dc64d35b903f313849f3d581", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -10,9 +10,9 @@\n \n \n use middle::ty;\n+use middle::ty_fold;\n \n use std::cell::Cell;\n-use syntax::ast;\n use syntax::codemap::Span;\n \n /// Defines strategies for handling regions that are omitted.  For\n@@ -136,3 +136,40 @@ impl RegionScope for BindingRscope {\n     }\n }\n \n+/// A scope which simply shifts the Debruijn index of other scopes\n+/// to account for binding levels.\n+pub struct ShiftedRscope<'r> {\n+    base_scope: &'r RegionScope+'r\n+}\n+\n+impl<'r> ShiftedRscope<'r> {\n+    pub fn new(base_scope: &'r RegionScope+'r) -> ShiftedRscope<'r> {\n+        ShiftedRscope { base_scope: base_scope }\n+    }\n+}\n+\n+impl<'r> RegionScope for ShiftedRscope<'r> {\n+    fn default_region_bound(&self, span: Span) -> Option<ty::Region>\n+    {\n+        self.base_scope.default_region_bound(span)\n+            .map(|r| ty_fold::shift_region(r, 1))\n+    }\n+\n+    fn anon_regions(&self,\n+                    span: Span,\n+                    count: uint)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n+    {\n+        match self.base_scope.anon_regions(span, count) {\n+            Ok(mut v) => {\n+                for r in v.iter_mut() {\n+                    *r = ty_fold::shift_region(*r, 1);\n+                }\n+                Ok(v)\n+            }\n+            Err(errs) => {\n+                Err(errs)\n+            }\n+        }\n+    }\n+}"}, {"sha": "a0e2bf07b830f94dc505173126b74530ac4959e5", "filename": "src/librustc_trans/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb68f1c813657f0fe6b43be008480822767b891/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs?ref=6fb68f1c813657f0fe6b43be008480822767b891", "patch": "@@ -385,7 +385,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     syntax::ext::mtwt::clear_tables();\n \n     let named_region_map = time(time_passes, \"lifetime resolution\", (),\n-                                |_| middle::resolve_lifetime::krate(&sess, krate));\n+                                |_| middle::resolve_lifetime::krate(&sess, krate, &def_map));\n \n     time(time_passes, \"looking for entry point\", (),\n          |_| middle::entry::find_entry_point(&sess, &ast_map));"}]}