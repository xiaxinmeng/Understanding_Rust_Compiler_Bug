{"sha": "2e997ef2d487525ea41e78ba793cb6e7c61cb204", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlOTk3ZWYyZDQ4NzUyNWVhNDFlNzhiYTc5M2NiNmU3YzYxY2IyMDQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-13T22:49:28Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-18T22:18:42Z"}, "message": "rustc: remove ownership of tcx from trans' context.", "tree": {"sha": "457e0d33787eaa096babe492b44fa6f72ce909e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/457e0d33787eaa096babe492b44fa6f72ce909e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e997ef2d487525ea41e78ba793cb6e7c61cb204", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e997ef2d487525ea41e78ba793cb6e7c61cb204", "html_url": "https://github.com/rust-lang/rust/commit/2e997ef2d487525ea41e78ba793cb6e7c61cb204", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e997ef2d487525ea41e78ba793cb6e7c61cb204/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "html_url": "https://github.com/rust-lang/rust/commit/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3"}], "stats": {"total": 357, "additions": 161, "deletions": 196}, "files": [{"sha": "fa7b1aa4fbe8959231a42a5e2c4eb59b3e76d441", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2e997ef2d487525ea41e78ba793cb6e7c61cb204", "patch": "@@ -101,11 +101,10 @@ pub const INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n /// The complete set of all analyses described in this module. This is\n /// produced by the driver and fed to trans and later passes.\n-pub struct CrateAnalysis<'tcx> {\n+pub struct CrateAnalysis {\n     pub export_map: ExportMap,\n     pub exported_items: middle::privacy::ExportedItems,\n     pub public_items: middle::privacy::PublicItems,\n-    pub ty_cx: ty::ctxt<'tcx>,\n     pub reachable: NodeSet,\n     pub name: String,\n     pub glob_map: Option<GlobMap>,"}, {"sha": "7297d9c00b4d7558399caf1647a97e3df42b92fc", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=2e997ef2d487525ea41e78ba793cb6e7c61cb204", "patch": "@@ -119,26 +119,26 @@ pub fn compile_input(sess: Session,\n                                                                      &ast_map.krate(),\n                                                                      &id[..]));\n \n-        let analysis = phase_3_run_analysis_passes(sess,\n-                                                   ast_map,\n-                                                   &arenas,\n-                                                   id,\n-                                                   control.make_glob_map);\n+        let (tcx, analysis) = phase_3_run_analysis_passes(sess,\n+                                                          ast_map,\n+                                                          &arenas,\n+                                                          id,\n+                                                          control.make_glob_map);\n \n         controller_entry_point!(after_analysis,\n-                                analysis.ty_cx.sess,\n+                                tcx.sess,\n                                 CompileState::state_after_analysis(input,\n-                                                                   &analysis.ty_cx.sess,\n+                                                                   &tcx.sess,\n                                                                    outdir,\n-                                                                   analysis.ty_cx.map.krate(),\n+                                                                   tcx.map.krate(),\n                                                                    &analysis,\n-                                                                   &analysis.ty_cx));\n+                                                                   &tcx));\n \n         if log_enabled!(::log::INFO) {\n             println!(\"Pre-trans\");\n-            analysis.ty_cx.print_debug_stats();\n+            tcx.print_debug_stats();\n         }\n-        let (tcx, trans) = phase_4_translate_to_llvm(analysis);\n+        let trans = phase_4_translate_to_llvm(&tcx, analysis);\n \n         if log_enabled!(::log::INFO) {\n             println!(\"Post-trans\");\n@@ -240,7 +240,7 @@ pub struct CompileState<'a, 'ast: 'a, 'tcx: 'a> {\n     pub out_dir: Option<&'a Path>,\n     pub expanded_crate: Option<&'a ast::Crate>,\n     pub ast_map: Option<&'a ast_map::Map<'ast>>,\n-    pub analysis: Option<&'a ty::CrateAnalysis<'tcx>>,\n+    pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<&'a ty::ctxt<'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n@@ -309,7 +309,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                             session: &'a Session,\n                             out_dir: &'a Option<PathBuf>,\n                             expanded_crate: &'a ast::Crate,\n-                            analysis: &'a ty::CrateAnalysis<'tcx>,\n+                            analysis: &'a ty::CrateAnalysis,\n                             tcx: &'a ty::ctxt<'tcx>)\n                             -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n@@ -583,7 +583,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                                          arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                          name: String,\n                                          make_glob_map: resolve::MakeGlobMap)\n-                                         -> ty::CrateAnalysis<'tcx> {\n+                                         -> (ty::ctxt<'tcx>, ty::CrateAnalysis) {\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();\n \n@@ -704,29 +704,28 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     // The above three passes generate errors w/o aborting\n     ty_cx.sess.abort_if_errors();\n \n-    ty::CrateAnalysis {\n+    (ty_cx, ty::CrateAnalysis {\n         export_map: export_map,\n-        ty_cx: ty_cx,\n         exported_items: exported_items,\n         public_items: public_items,\n         reachable: reachable_map,\n         name: name,\n         glob_map: glob_map,\n-    }\n+    })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n-                                       -> (ty::ctxt<'tcx>, trans::CrateTranslation) {\n-    let time_passes = analysis.ty_cx.sess.time_passes();\n+pub fn phase_4_translate_to_llvm(tcx: &ty::ctxt, analysis: ty::CrateAnalysis)\n+                                 -> trans::CrateTranslation {\n+    let time_passes = tcx.sess.time_passes();\n \n     time(time_passes, \"resolving dependency formats\", (), |_|\n-         dependency_format::calculate(&analysis.ty_cx));\n+         dependency_format::calculate(tcx));\n \n     // Option dance to work around the lack of stack once closures.\n     time(time_passes, \"translation\", analysis, |analysis|\n-         trans::trans_crate(analysis))\n+         trans::trans_crate(tcx, analysis))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file"}, {"sha": "96d1ab23ad5239983e9701171be469b9c331a7cd", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=2e997ef2d487525ea41e78ba793cb6e7c61cb204", "patch": "@@ -377,12 +377,10 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n         if sess.opts.debugging_opts.save_analysis {\n             control.after_analysis.callback = box |state| {\n                 time(state.session.time_passes(),\n-                     \"save analysis\",\n-                     state.expanded_crate.unwrap(),\n-                     |krate| save::process_crate(state.session,\n-                                                 krate,\n-                                                 state.analysis.unwrap(),\n-                                                 state.out_dir));\n+                     \"save analysis\", (),\n+                     |_| save::process_crate(state.tcx.unwrap(),\n+                                             state.analysis.unwrap(),\n+                                             state.out_dir));\n             };\n             control.make_glob_map = resolve::MakeGlobMap::Yes;\n         }"}, {"sha": "0dc636eb3ec9c477bdc12a6ccfeefb2b2bbd6905", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=2e997ef2d487525ea41e78ba793cb6e7c61cb204", "patch": "@@ -148,12 +148,12 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-                let analysis = driver::phase_3_run_analysis_passes(sess,\n+                let (tcx, _) = driver::phase_3_run_analysis_passes(sess,\n                                                                    ast_map,\n                                                                    arenas,\n                                                                    id,\n                                                                    resolve::MakeGlobMap::No);\n-                let annotation = TypedAnnotation { analysis: analysis };\n+                let annotation = TypedAnnotation { tcx: tcx };\n                 f(&annotation, payload)\n             }\n         }\n@@ -285,14 +285,14 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n \n \n struct TypedAnnotation<'tcx> {\n-    analysis: ty::CrateAnalysis<'tcx>,\n+    tcx: ty::ctxt<'tcx>,\n }\n \n impl<'tcx> PrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.analysis.ty_cx.sess }\n+    fn sess<'a>(&'a self) -> &'a Session { &self.tcx.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'tcx>> {\n-        Some(&self.analysis.ty_cx.map)\n+        Some(&self.tcx.map)\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n@@ -310,16 +310,15 @@ impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n     fn post(&self,\n             s: &mut pprust::State,\n             node: pprust::AnnNode) -> io::Result<()> {\n-        let tcx = &self.analysis.ty_cx;\n         match node {\n             pprust::NodeExpr(expr) => {\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s,\n                               &ppaux::ty_to_string(\n-                                  tcx,\n-                                  ty::expr_ty(tcx, expr))));\n+                                  &self.tcx,\n+                                  ty::expr_ty(&self.tcx, expr))));\n                 s.pclose()\n             }\n             _ => Ok(())\n@@ -646,12 +645,12 @@ pub fn pretty_print_input(sess: Session,\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n-                    let analysis = driver::phase_3_run_analysis_passes(sess,\n+                    let (tcx, _) = driver::phase_3_run_analysis_passes(sess,\n                                                                        ast_map,\n                                                                        &arenas,\n                                                                        id,\n                                                                        resolve::MakeGlobMap::No);\n-                    print_flowgraph(variants, analysis, code, mode, out)\n+                    print_flowgraph(variants, &tcx, code, mode, out)\n                 }\n                 None => {\n                     let message = format!(\"--pretty=flowgraph needs \\\n@@ -682,18 +681,17 @@ pub fn pretty_print_input(sess: Session,\n }\n \n fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                             analysis: ty::CrateAnalysis,\n+                             tcx: &ty::ctxt,\n                              code: blocks::Code,\n                              mode: PpFlowGraphMode,\n                              mut out: W) -> io::Result<()> {\n-    let ty_cx = &analysis.ty_cx;\n     let cfg = match code {\n-        blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),\n-        blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),\n+        blocks::BlockCode(block) => cfg::CFG::new(tcx, &*block),\n+        blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &*fn_like.body()),\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n-        ast_map: &ty_cx.map,\n+        ast_map: &tcx.map,\n         cfg: &cfg,\n         name: format!(\"node_{}\", code.id()),\n         labelled_edges: labelled_edges,\n@@ -705,14 +703,14 @@ fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n             return expand_err_details(r);\n         }\n         blocks::BlockCode(_) => {\n-            ty_cx.sess.err(\"--pretty flowgraph with -Z flowgraph-print \\\n-                            annotations requires fn-like node id.\");\n+            tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print \\\n+                          annotations requires fn-like node id.\");\n             return Ok(())\n         }\n         blocks::FnLikeCode(fn_like) => {\n             let fn_parts = borrowck::FnPartsWithCFG::from_fn_like(&fn_like, &cfg);\n             let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(ty_cx, fn_parts);\n+                borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_parts);\n \n             let lcfg = borrowck_dot::DataflowLabeller {\n                 inner: lcfg,"}, {"sha": "f68024656e03d9f21fea4f4c5f790297d6e60d31", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 50, "deletions": 66, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=2e997ef2d487525ea41e78ba793cb6e7c61cb204", "patch": "@@ -67,7 +67,8 @@ macro_rules! down_cast_data {\n pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     sess: &'l Session,\n-    analysis: &'l ty::CrateAnalysis<'tcx>,\n+    tcx: &'l ty::ctxt<'tcx>,\n+    analysis: &'l ty::CrateAnalysis,\n \n     span: SpanUtils<'l>,\n     fmt: FmtStrs<'l>,\n@@ -76,28 +77,23 @@ pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n }\n \n impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n-    pub fn new(sess: &'l Session,\n-               analysis: &'l ty::CrateAnalysis<'tcx>,\n+    pub fn new(tcx: &'l ty::ctxt<'tcx>,\n+               analysis: &'l ty::CrateAnalysis,\n                output_file: Box<File>) -> DumpCsvVisitor<'l, 'tcx> {\n+        let span_utils = SpanUtils {\n+            sess: &tcx.sess,\n+            err_count: Cell::new(0)\n+        };\n         DumpCsvVisitor {\n-            sess: sess,\n-            save_ctxt: SaveContext::new(sess, analysis, SpanUtils {\n-                sess: sess,\n-                err_count: Cell::new(0)\n-            }),\n+            sess: &tcx.sess,\n+            tcx: tcx,\n+            save_ctxt: SaveContext::new(tcx, span_utils.clone()),\n             analysis: analysis,\n-            span: SpanUtils {\n-                sess: sess,\n-                err_count: Cell::new(0)\n-            },\n+            span: span_utils.clone(),\n             fmt: FmtStrs::new(box Recorder {\n                                 out: output_file,\n                                 dump_spans: false,\n-                            },\n-                            SpanUtils {\n-                                sess: sess,\n-                                err_count: Cell::new(0)\n-                            }),\n+                              }, span_utils),\n             cur_scope: 0\n         }\n     }\n@@ -237,19 +233,19 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n     // looks up anything, not just a type\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n-        if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n+        if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n             self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n                                   ref_id));\n         }\n-        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n+        let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n             def::DefPrimTy(_) => None,\n             _ => Some(def.def_id()),\n         }\n     }\n \n     fn lookup_def_kind(&self, ref_id: NodeId, span: Span) -> Option<recorder::Row> {\n-        let def_map = self.analysis.ty_cx.def_map.borrow();\n+        let def_map = self.tcx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n             self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n                                              ref_id));\n@@ -293,8 +289,8 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             for &(id, ref p, _, _) in &collector.collected_paths {\n                 let typ =\n                     ppaux::ty_to_string(\n-                        &self.analysis.ty_cx,\n-                        *self.analysis.ty_cx.node_types().get(&id).unwrap());\n+                        self.tcx,\n+                        *self.tcx.node_types().get(&id).unwrap());\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -320,22 +316,20 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let mut scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n-                                                ast_util::local_def(id)) {\n-            Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n+        let qualname = match ty::impl_of_method(self.tcx, ast_util::local_def(id)) {\n+            Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n                     match item.node {\n                         ast::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&ty_to_string(&**ty));\n \n-                            match ty::trait_of_item(&self.analysis.ty_cx,\n-                                                    ast_util::local_def(id)) {\n+                            match ty::trait_of_item(self.tcx, ast_util::local_def(id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n-                                        &ty::item_path_str(&self.analysis.ty_cx, def_id));\n+                                        &ty::item_path_str(self.tcx, def_id));\n                                 },\n                                 None => {}\n                             }\n@@ -352,16 +346,15 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 _ => {\n                     self.sess.span_bug(span,\n                         &format!(\"Container {} for method {} is not a node item {:?}\",\n-                                 impl_id.node, id, self.analysis.ty_cx.map.get(impl_id.node)));\n+                                 impl_id.node, id, self.tcx.map.get(impl_id.node)));\n                 },\n             },\n-            None => match ty::trait_of_item(&self.analysis.ty_cx,\n-                                            ast_util::local_def(id)) {\n+            None => match ty::trait_of_item(self.tcx, ast_util::local_def(id)) {\n                 Some(def_id) => {\n                     scope_id = def_id.node;\n-                    match self.analysis.ty_cx.map.get(def_id.node) {\n+                    match self.tcx.map.get(def_id.node) {\n                         NodeItem(_) => {\n-                            format!(\"::{}\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n+                            format!(\"::{}\", ty::item_path_str(self.tcx, def_id))\n                         }\n                         _ => {\n                             self.sess.span_bug(span,\n@@ -380,8 +373,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let qualname = &format!(\"{}::{}\", qualname, &token::get_name(name));\n \n         // record the decl for this def (if it has one)\n-        let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n-                                             ast_util::local_def(id))\n+        let decl_id = ty::trait_item_of_item(self.tcx, ast_util::local_def(id))\n             .and_then(|new_id| {\n                 let def_id = new_id.def_id();\n                 if def_id.node != 0 && def_id != ast_util::local_def(id) {\n@@ -538,7 +530,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                      typ: &ast::Ty,\n                      expr: &ast::Expr)\n     {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(id));\n+        let qualname = format!(\"::{}\", self.tcx.map.path_to_string(id));\n \n         let sub_span = self.span.sub_span_after_keyword(span,\n                                                         keywords::Const);\n@@ -561,7 +553,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                       item: &ast::Item,\n                       def: &ast::StructDef,\n                       ty_params: &ast::Generics) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n \n         let ctor_id = match def.ctor_id {\n             Some(node_id) => node_id,\n@@ -691,7 +683,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                      generics: &ast::Generics,\n                      trait_refs: &OwnedSlice<ast::TyParamBound>,\n                      methods: &[P<ast::TraitItem>]) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         self.fmt.trait_str(item.span,\n@@ -758,7 +750,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             return\n         }\n \n-        let def_map = self.analysis.ty_cx.def_map.borrow();\n+        let def_map = self.tcx.def_map.borrow();\n         if !def_map.contains_key(&id) {\n             self.sess.span_bug(span,\n                                &format!(\"def_map has no key for {} in visit_expr\", id));\n@@ -789,12 +781,10 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             def::DefMethod(declid, provenence) => {\n                 let sub_span = self.span.sub_span_for_meth_name(span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n-                    let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n-                                                    declid);\n+                    let ti = ty::impl_or_trait_item(self.tcx, declid);\n                     match provenence {\n                         def::FromTrait(def_id) => {\n-                            Some(ty::trait_items(&self.analysis.ty_cx,\n-                                                 def_id)\n+                            Some(ty::trait_items(self.tcx, def_id)\n                                     .iter()\n                                     .find(|mr| {\n                                         mr.name() == ti.name()\n@@ -803,16 +793,13 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                     .def_id())\n                         }\n                         def::FromImpl(def_id) => {\n-                            let impl_items = self.analysis\n-                                                 .ty_cx\n-                                                 .impl_items\n-                                                 .borrow();\n+                            let impl_items = self.tcx.impl_items.borrow();\n                             Some(impl_items.get(&def_id)\n                                            .unwrap()\n                                            .iter()\n                                            .find(|mr| {\n                                                 ty::impl_or_trait_item(\n-                                                    &self.analysis.ty_cx,\n+                                                    self.tcx,\n                                                     mr.def_id()\n                                                 ).name() == ti.name()\n                                             })\n@@ -844,7 +831,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         // modules or types in the path prefix\n         match def {\n             def::DefMethod(did, _) => {\n-                let ti = ty::impl_or_trait_item(&self.analysis.ty_cx, did);\n+                let ti = ty::impl_or_trait_item(self.tcx, did);\n                 if let ty::MethodTraitItem(m) = ti {\n                     if m.explicit_self == ty::StaticExplicitSelfCategory {\n                         self.write_sub_path_trait_truncated(path);\n@@ -906,24 +893,21 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_method_call(&mut self,\n                            ex: &ast::Expr,\n                            args: &Vec<P<ast::Expr>>) {\n-        let method_map = self.analysis.ty_cx.method_map.borrow();\n+        let method_map = self.tcx.method_map.borrow();\n         let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n         let (def_id, decl_id) = match method_callee.origin {\n             ty::MethodStatic(def_id) |\n             ty::MethodStaticClosure(def_id) => {\n                 // method invoked on an object with a concrete type (not a static method)\n                 let decl_id =\n-                    match ty::trait_item_of_item(&self.analysis.ty_cx,\n-                                                 def_id) {\n+                    match ty::trait_item_of_item(self.tcx, def_id) {\n                         None => None,\n                         Some(decl_id) => Some(decl_id.def_id()),\n                     };\n \n                 // This incantation is required if the method referenced is a\n                 // trait's default implementation.\n-                let def_id = match ty::impl_or_trait_item(&self.analysis\n-                                                               .ty_cx,\n-                                                          def_id) {\n+                let def_id = match ty::impl_or_trait_item(self.tcx, def_id) {\n                     ty::MethodTraitItem(method) => {\n                         method.provided_source.unwrap_or(def_id)\n                     }\n@@ -936,14 +920,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             }\n             ty::MethodTypeParam(ref mp) => {\n                 // method invoked on a type parameter\n-                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n+                let trait_item = ty::trait_item(self.tcx,\n                                                 mp.trait_ref.def_id,\n                                                 mp.method_num);\n                 (None, Some(trait_item.def_id()))\n             }\n             ty::MethodTraitObject(ref mo) => {\n                 // method invoked on a trait instance\n-                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n+                let trait_item = ty::trait_item(self.tcx,\n                                                 mo.trait_ref.def_id,\n                                                 mo.method_num);\n                 (None, Some(trait_item.def_id()))\n@@ -969,12 +953,12 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             ast::PatStruct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n \n-                let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n+                let def = self.tcx.def_map.borrow().get(&p.id).unwrap().full_def();\n                 let struct_def = match def {\n                     def::DefConst(..) | def::DefAssociatedConst(..) => None,\n                     def::DefVariant(_, variant_id, _) => Some(variant_id),\n                     _ => {\n-                        match ty::ty_to_def_id(ty::node_id_to_type(&self.analysis.ty_cx, p.id)) {\n+                        match ty::ty_to_def_id(ty::node_id_to_type(self.tcx, p.id)) {\n                             None => {\n                                 self.sess.span_bug(p.span,\n                                                    &format!(\"Could not find struct_def for `{}`\",\n@@ -986,7 +970,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 };\n \n                 if let Some(struct_def) = struct_def {\n-                    let struct_fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n+                    let struct_fields = ty::lookup_struct_fields(self.tcx, struct_def);\n                     for &Spanned { node: ref field, span } in fields {\n                         let sub_span = self.span.span_for_first_ident(span);\n                         for f in &struct_fields {\n@@ -1145,7 +1129,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 self.nest(item.id, |v| visit::walk_mod(v, m));\n             }\n             ast::ItemTy(ref ty, ref ty_params) => {\n-                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let value = ty_to_string(&**ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 self.fmt.typedef_str(item.span,\n@@ -1273,10 +1257,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                let ty = &ty::expr_ty_adjusted(self.tcx, &**sub_ex).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n+                        let fields = ty::lookup_struct_fields(self.tcx, def_id);\n                         for (i, f) in fields.iter().enumerate() {\n                             if i == idx.node {\n                                 let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n@@ -1342,7 +1326,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n         let mut paths_to_process = vec![];\n         // process collected paths\n         for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n-            let def_map = self.analysis.ty_cx.def_map.borrow();\n+            let def_map = self.tcx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n                                    &format!(\"def_map has no key for {} in visit_arm\",\n@@ -1410,8 +1394,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             } else {\n                 \"<mutable>\".to_string()\n             };\n-            let types = self.analysis.ty_cx.node_types();\n-            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n+            let types = self.tcx.node_types();\n+            let typ = ppaux::ty_to_string(self.tcx, *types.get(&id).unwrap());\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);"}, {"sha": "5d5dbbd90a779a2f0399f1e770b37f1b8ccecb8f", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 41, "deletions": 47, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=2e997ef2d487525ea41e78ba793cb6e7c61cb204", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use session::Session;\n use middle::ty;\n use middle::def;\n \n@@ -35,8 +34,7 @@ mod recorder;\n mod dump_csv;\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n-    sess: &'l Session,\n-    analysis: &'l ty::CrateAnalysis<'tcx>,\n+    tcx: &'l ty::ctxt<'tcx>,\n     span_utils: SpanUtils<'l>,\n }\n \n@@ -143,13 +141,11 @@ pub struct TypeRefData {\n \n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(sess: &'l Session,\n-               analysis: &'l ty::CrateAnalysis<'tcx>,\n+    pub fn new(tcx: &'l ty::ctxt<'tcx>,\n                span_utils: SpanUtils<'l>)\n                -> SaveContext<'l, 'tcx> {\n         SaveContext {\n-            sess: sess,\n-            analysis: analysis,\n+            tcx: tcx,\n             span_utils: span_utils,\n         }\n     }\n@@ -158,7 +154,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_external_crates(&self) -> Vec<CrateData> {\n         let mut result = Vec::new();\n \n-        self.sess.cstore.iter_crate_data(|n, cmd| {\n+        self.tcx.sess.cstore.iter_crate_data(|n, cmd| {\n             result.push(CrateData { name: cmd.name.clone(), number: n });\n         });\n \n@@ -168,7 +164,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_item_data(&self, item: &ast::Item) -> Data {\n         match item.node {\n             ast::ItemFn(..) => {\n-                let name = self.analysis.ty_cx.map.path_to_string(item.id);\n+                let name = self.tcx.map.path_to_string(item.id);\n                 let qualname = format!(\"::{}\", name);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n \n@@ -178,11 +174,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     qualname: qualname,\n                     declaration: None,\n                     span: sub_span.unwrap(),\n-                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_parent(item.id),\n                 })\n             }\n             ast::ItemStatic(ref typ, mt, ref expr) => {\n-                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n \n                 // If the variable is immutable, save the initialising expression.\n                 let (value, keyword) = match mt {\n@@ -197,29 +193,29 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_parent(item.id),\n                     value: value,\n                     type_value: ty_to_string(&typ),\n                 })\n             }\n             ast::ItemConst(ref typ, ref expr) => {\n-                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Const);\n \n                 Data::VariableData(VariableData {\n                     id: item.id,\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_parent(item.id),\n                     value: self.span_utils.snippet(expr.span),\n                     type_value: ty_to_string(&typ),\n                 })\n             }\n             ast::ItemMod(ref m) => {\n-                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n \n-                let cm = self.sess.codemap();\n+                let cm = self.tcx.sess.codemap();\n                 let filename = cm.span_to_filename(m.inner);\n \n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Mod);\n@@ -229,12 +225,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_parent(item.id),\n                     filename: filename,\n                 })\n             },\n             ast::ItemEnum(..) => {\n-                let enum_name = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let enum_name = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let val = self.span_utils.snippet(item.span);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Enum);\n \n@@ -243,14 +239,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     value: val,\n                     span: sub_span.unwrap(),\n                     qualname: enum_name,\n-                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_parent(item.id),\n                 })\n             },\n             ast::ItemImpl(_, _, _, ref trait_ref, ref typ, _) => {\n                 let mut type_data = None;\n                 let sub_span;\n \n-                let parent = self.analysis.ty_cx.map.get_parent(item.id);\n+                let parent = self.tcx.map.get_parent(item.id);\n \n                 match typ.node {\n                     // Common case impl for a struct or something basic.\n@@ -294,10 +290,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::NamedField(ident, _) => {\n                 let name = get_ident(ident);\n                 let qualname = format!(\"::{}::{}\",\n-                                       self.analysis.ty_cx.map.path_to_string(parent),\n+                                       self.tcx.map.path_to_string(parent),\n                                        name);\n-                let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                                              *self.analysis.ty_cx.node_types()\n+                let typ = ppaux::ty_to_string(&self.tcx,\n+                                              *self.tcx.node_types()\n                                                   .get(&field.node.id).unwrap());\n                 let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n                 Some(Data::VariableData(VariableData {\n@@ -334,26 +330,25 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         match expr.node {\n             ast::ExprField(ref sub_ex, ident) => {\n-                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &sub_ex).sty;\n+                let ty = &ty::expr_ty_adjusted(self.tcx, &sub_ex).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n+                        let fields = ty::lookup_struct_fields(self.tcx, def_id);\n                         for f in &fields {\n                             if f.name == ident.node.name {\n                                 let sub_span = self.span_utils.span_for_last_ident(expr.span);\n                                 return Some(Data::VariableRefData(VariableRefData {\n                                     name: get_ident(ident.node).to_string(),\n                                     span: sub_span.unwrap(),\n-                                    scope: self.analysis.ty_cx.map.get_parent(expr.id),\n+                                    scope: self.tcx.map.get_parent(expr.id),\n                                     ref_id: f.id,\n                                 }));\n                             }\n                         }\n \n-                        self.sess.span_bug(expr.span,\n-                                           &format!(\"Couldn't find field {} on {:?}\",\n-                                                    &get_ident(ident.node),\n-                                                    ty))\n+                        self.tcx.sess.span_bug(expr.span,\n+                                               &format!(\"Couldn't find field {} on {:?}\",\n+                                                        &get_ident(ident.node), ty))\n                     }\n                     _ => {\n                         debug!(\"Expected struct type, found {:?}\", ty);\n@@ -362,13 +357,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprStruct(ref path, _, _) => {\n-                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, expr).sty;\n+                let ty = &ty::expr_ty_adjusted(&self.tcx, expr).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         Some(Data::TypeRefData(TypeRefData {\n                             span: sub_span.unwrap(),\n-                            scope: self.analysis.ty_cx.map.get_parent(expr.id),\n+                            scope: self.tcx.map.get_parent(expr.id),\n                             ref_id: def_id,\n                         }))\n                     }\n@@ -392,7 +387,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                               struct_id: DefId,\n                               parent: NodeId)\n                               -> VariableRefData {\n-        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_id);\n+        let fields = ty::lookup_struct_fields(&self.tcx, struct_id);\n         let field_name = get_ident(field_ref.ident.node).to_string();\n         for f in &fields {\n             if f.name == field_ref.ident.node.name {\n@@ -407,8 +402,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n         }\n \n-        self.sess.span_bug(field_ref.span,\n-                           &format!(\"Couldn't find field {}\", field_name));\n+        self.tcx.sess.span_bug(field_ref.span,\n+                               &format!(\"Couldn't find field {}\", field_name));\n     }\n \n     pub fn get_data_for_id(&self, _id: &NodeId) -> Data {\n@@ -417,11 +412,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n-            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id));\n+        if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n+            self.tcx.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n+                                       ref_id));\n         }\n-        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n+        let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n             def::DefPrimTy(_) => None,\n             _ => Some(def.def_id()),\n@@ -484,10 +479,10 @@ impl<'v> Visitor<'v> for PathCollector {\n }\n \n #[allow(deprecated)]\n-pub fn process_crate(sess: &Session,\n-                     krate: &ast::Crate,\n+pub fn process_crate(tcx: &ty::ctxt,\n                      analysis: &ty::CrateAnalysis,\n                      odir: Option<&Path>) {\n+    let krate = tcx.map.krate();\n     if generated_code(krate.span) {\n         return;\n     }\n@@ -512,10 +507,9 @@ pub fn process_crate(sess: &Session,\n         },\n     };\n \n-    match fs::create_dir_all(&root_path) {\n-        Err(e) => sess.err(&format!(\"Could not create directory {}: {}\",\n-                           root_path.display(), e)),\n-        _ => (),\n+    if let Err(e) = fs::create_dir_all(&root_path) {\n+        tcx.sess.err(&format!(\"Could not create directory {}: {}\",\n+                              root_path.display(), e));\n     }\n \n     {\n@@ -531,12 +525,12 @@ pub fn process_crate(sess: &Session,\n         Ok(f) => box f,\n         Err(e) => {\n             let disp = root_path.display();\n-            sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n+            tcx.sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n         }\n     };\n     root_path.pop();\n \n-    let mut visitor = dump_csv::DumpCsvVisitor::new(sess, analysis, output_file);\n+    let mut visitor = dump_csv::DumpCsvVisitor::new(tcx, analysis, output_file);\n \n     visitor.dump_crate_info(&cratename, krate);\n     visit::walk_crate(&mut visitor, krate);"}, {"sha": "ec92076d9c1b567aafa1359371c74dd3897e646b", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=2e997ef2d487525ea41e78ba793cb6e7c61cb204", "patch": "@@ -2491,7 +2491,7 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n     }\n }\n \n-pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'tcx>,\n+pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'a, 'tcx>,\n                                             ie: encoder::EncodeInlinedItem<'a>)\n                                             -> encoder::EncodeParams<'a, 'tcx> {\n     encoder::EncodeParams {\n@@ -2627,9 +2627,8 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n     }\n }\n \n-pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n-                         -> (ty::ctxt<'tcx>, CrateTranslation) {\n-    let ty::CrateAnalysis { ty_cx: tcx, export_map, reachable, name, .. } = analysis;\n+pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslation {\n+    let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n     let krate = tcx.map.krate();\n \n     let check_overflow = if let Some(v) = tcx.sess.opts.debugging_opts.force_overflow_checks {\n@@ -2769,15 +2768,13 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n-    let translation = CrateTranslation {\n+    CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,\n         link: link_meta,\n         metadata: metadata,\n         reachable: reachable,\n         crate_formats: formats,\n         no_builtins: no_builtins,\n-    };\n-\n-    (shared_ccx.take_tcx(), translation)\n+    }\n }"}, {"sha": "6bb6916176deb4a1e764e9516ae741e71084c797", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=2e997ef2d487525ea41e78ba793cb6e7c61cb204", "patch": "@@ -57,7 +57,7 @@ pub struct Stats {\n /// per crate.  The data here is shared between all compilation units of the\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n-pub struct SharedCrateContext<'tcx> {\n+pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     local_ccxs: Vec<LocalCrateContext<'tcx>>,\n \n     metadata_llmod: ModuleRef,\n@@ -68,7 +68,7 @@ pub struct SharedCrateContext<'tcx> {\n     item_symbols: RefCell<NodeMap<String>>,\n     link_meta: LinkMeta,\n     symbol_hasher: RefCell<Sha256>,\n-    tcx: ty::ctxt<'tcx>,\n+    tcx: &'a ty::ctxt<'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n     check_drop_flag_for_sanity: bool,\n@@ -159,15 +159,15 @@ pub struct LocalCrateContext<'tcx> {\n }\n \n pub struct CrateContext<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'tcx>,\n+    shared: &'a SharedCrateContext<'a, 'tcx>,\n     local: &'a LocalCrateContext<'tcx>,\n     /// The index of `local` in `shared.local_ccxs`.  This is used in\n     /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n     index: usize,\n }\n \n pub struct CrateContextIterator<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'tcx>,\n+    shared: &'a SharedCrateContext<'a, 'tcx>,\n     index: usize,\n }\n \n@@ -192,7 +192,7 @@ impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n \n /// The iterator produced by `CrateContext::maybe_iter`.\n pub struct CrateContextMaybeIterator<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'tcx>,\n+    shared: &'a SharedCrateContext<'a, 'tcx>,\n     index: usize,\n     single: bool,\n     origin: usize,\n@@ -237,17 +237,17 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n     (llcx, llmod)\n }\n \n-impl<'tcx> SharedCrateContext<'tcx> {\n+impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(crate_name: &str,\n                local_count: usize,\n-               tcx: ty::ctxt<'tcx>,\n+               tcx: &'b ty::ctxt<'tcx>,\n                export_map: ExportMap,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet,\n                check_overflow: bool,\n                check_drop_flag_for_sanity: bool)\n-               -> SharedCrateContext<'tcx> {\n+               -> SharedCrateContext<'b, 'tcx> {\n         let (metadata_llcx, metadata_llmod) = unsafe {\n             create_context_and_module(&tcx.sess, \"metadata\")\n         };\n@@ -397,10 +397,6 @@ impl<'tcx> SharedCrateContext<'tcx> {\n     }\n \n     pub fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-        &self.tcx\n-    }\n-\n-    pub fn take_tcx(self) -> ty::ctxt<'tcx> {\n         self.tcx\n     }\n \n@@ -418,7 +414,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n }\n \n impl<'tcx> LocalCrateContext<'tcx> {\n-    fn new(shared: &SharedCrateContext<'tcx>,\n+    fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n            name: &str)\n            -> LocalCrateContext<'tcx> {\n         unsafe {\n@@ -505,7 +501,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n     /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext<'tcx>)\n+    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext<'a, 'tcx>)\n                      -> CrateContext<'a, 'tcx> {\n         CrateContext {\n             shared: shared,\n@@ -516,7 +512,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n }\n \n impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n-    pub fn shared(&self) -> &'b SharedCrateContext<'tcx> {\n+    pub fn shared(&self) -> &'b SharedCrateContext<'b, 'tcx> {\n         self.shared\n     }\n \n@@ -548,7 +544,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n \n \n     pub fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-        &self.shared.tcx\n+        self.shared.tcx\n     }\n \n     pub fn sess<'a>(&'a self) -> &'a Session {"}, {"sha": "7d66253b378883c567fe0c3fb1173dd12cf73f81", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=2e997ef2d487525ea41e78ba793cb6e7c61cb204", "patch": "@@ -133,17 +133,17 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let arenas = ty::CtxtArenas::new();\n     let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n \n-    let ty::CrateAnalysis {\n-        exported_items, public_items, ty_cx, ..\n-    } = driver::phase_3_run_analysis_passes(sess,\n-                                            ast_map,\n-                                            &arenas,\n-                                            name,\n-                                            resolve::MakeGlobMap::No);\n+    let (tcx, ty::CrateAnalysis {\n+        exported_items, public_items, ..\n+    }) = driver::phase_3_run_analysis_passes(sess,\n+                                             ast_map,\n+                                             &arenas,\n+                                             name,\n+                                             resolve::MakeGlobMap::No);\n \n     let ctxt = DocContext {\n-        krate: ty_cx.map.krate(),\n-        maybe_typed: Typed(ty_cx),\n+        krate: tcx.map.krate(),\n+        maybe_typed: Typed(tcx),\n         input: input,\n         external_traits: RefCell::new(Some(HashMap::new())),\n         external_typarams: RefCell::new(Some(HashMap::new())),"}, {"sha": "64f66a6ea07b84bca065a351ddcca13d67662683", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e997ef2d487525ea41e78ba793cb6e7c61cb204/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=2e997ef2d487525ea41e78ba793cb6e7c61cb204", "patch": "@@ -221,10 +221,10 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n \n-        let analysis = driver::phase_3_run_analysis_passes(\n+        let (tcx, analysis) = driver::phase_3_run_analysis_passes(\n             sess, ast_map, &arenas, id, MakeGlobMap::No);\n \n-        let (tcx, trans) = driver::phase_4_translate_to_llvm(analysis);\n+        let trans = driver::phase_4_translate_to_llvm(&tcx, analysis);\n \n         let crates = tcx.sess.cstore.get_used_crates(RequireDynamic);\n "}]}