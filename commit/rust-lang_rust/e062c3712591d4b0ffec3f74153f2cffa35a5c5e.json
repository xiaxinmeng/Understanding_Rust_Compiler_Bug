{"sha": "e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "node_id": "C_kwDOAAsO6NoAKGUwNjJjMzcxMjU5MWQ0YjBmZmVjM2Y3NDE1M2YyY2ZmYTM1YTVjNWU", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2022-05-05T03:39:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-05T03:39:04Z"}, "message": "Merge pull request #172 from rust-lang/feature/more-simd\n\nImplement more SIMD intrinsics", "tree": {"sha": "6180c2b3b742367d6c93dc66aff564ee69eba60f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6180c2b3b742367d6c93dc66aff564ee69eba60f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJic0bYCRBK7hj4Ov3rIwAAA6cIAJceWHL5TdfKCsumsRv8LCJU\nwuJUcqt6CNQsdy2OyHYm0LcP0qcV7pz279UsXGolU1zo1qnMBb9/AiN/5CjEK8Xc\ndM0yaFBljjXUZJlQjPdLNjpeKEn3UUePrxD+p2c1mswxvDCdhUvuWIOWtXF9JBQz\nmbRe5RD7OwI0MQVWfAqYAHQ1YbLEQ5hJ7VQCrDCFRAnrF3xgJohVyuDRIhvUN0V3\nkwdspqzrjks8rT8bRViMaJlQV3eLAf1voY0ut7pmsFXKaM14ftXgVor8NDXnUmBU\naX/lf6wvSZvNn2CB18REqLsD4FPl3dvHGCqAQjMCbPp26F5y5GcAHNALKzpqwew=\n=Agwk\n-----END PGP SIGNATURE-----\n", "payload": "tree 6180c2b3b742367d6c93dc66aff564ee69eba60f\nparent 852735da05d741317014bc54cb5933820e19cc72\nparent 4a9744059f8617756c4ee981e033ad8b6f6e05d3\nauthor antoyo <antoyo@users.noreply.github.com> 1651721944 -0400\ncommitter GitHub <noreply@github.com> 1651721944 -0400\n\nMerge pull request #172 from rust-lang/feature/more-simd\n\nImplement more SIMD intrinsics"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "html_url": "https://github.com/rust-lang/rust/commit/e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "852735da05d741317014bc54cb5933820e19cc72", "url": "https://api.github.com/repos/rust-lang/rust/commits/852735da05d741317014bc54cb5933820e19cc72", "html_url": "https://github.com/rust-lang/rust/commit/852735da05d741317014bc54cb5933820e19cc72"}, {"sha": "4a9744059f8617756c4ee981e033ad8b6f6e05d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a9744059f8617756c4ee981e033ad8b6f6e05d3", "html_url": "https://github.com/rust-lang/rust/commit/4a9744059f8617756c4ee981e033ad8b6f6e05d3"}], "stats": {"total": 615, "additions": 580, "deletions": 35}, "files": [{"sha": "738c990fa827f622779784230d9e962729629e1c", "filename": "src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "patch": "@@ -595,7 +595,7 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n             | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => unimplemented!(),\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"Yk\",\n             InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n             InlineAsmRegClass::X86(\n                 X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg,"}, {"sha": "8fa78c7e189bff831aa54fe189c11a35ad9e8af3", "filename": "src/builder.rs", "status": "modified", "additions": 108, "deletions": 1, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "patch": "@@ -7,6 +7,7 @@ use gccjit::{\n     BinaryOp,\n     Block,\n     ComparisonOp,\n+    Context,\n     Function,\n     LValue,\n     RValue,\n@@ -47,6 +48,7 @@ use rustc_target::spec::{HasTargetSpec, Target};\n \n use crate::common::{SignType, TypeReflection, type_is_pointer};\n use crate::context::CodegenCx;\n+use crate::intrinsic::llvm;\n use crate::type_of::LayoutGccExt;\n \n // TODO(antoyo)\n@@ -216,11 +218,17 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             return Cow::Borrowed(args);\n         }\n \n+        let func_name = format!(\"{:?}\", func_ptr);\n+\n         let casted_args: Vec<_> = param_types\n             .into_iter()\n             .zip(args.iter())\n             .enumerate()\n             .map(|(index, (expected_ty, &actual_val))| {\n+                if llvm::ignore_arg_cast(&func_name, index, args.len()) {\n+                    return actual_val;\n+                }\n+\n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n                     if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() && actual_ty.get_size() != expected_ty.get_size() {\n@@ -297,6 +305,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n             let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            let func_name = format!(\"{:?}\", func_ptr);\n+            let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args, &func_name);\n             self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             result.to_rvalue()\n         }\n@@ -1316,6 +1326,11 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 element_type\n             }\n             else {\n+                #[cfg(feature=\"master\")]\n+                {\n+                    self.cx.type_ix(element_type.get_size() as u64 * 8)\n+                }\n+                #[cfg(not(feature=\"master\"))]\n                 self.int_type\n             };\n         for i in 0..mask_num_units {\n@@ -1343,7 +1358,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 }\n                 // TODO(antoyo): switch to using new_vector_access.\n                 let array = self.context.new_bitcast(None, v2, array_type);\n-                for i in 0..vec_num_units {\n+                for i in 0..(mask_num_units - vec_num_units) {\n                     elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n                 }\n                 let v1 = self.context.new_rvalue_from_vector(None, result_type, &elements);\n@@ -1380,6 +1395,98 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     pub fn shuffle_vector(&mut self, _v1: RValue<'gcc>, _v2: RValue<'gcc>, _mask: RValue<'gcc>) -> RValue<'gcc> {\n         unimplemented!();\n     }\n+\n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce<F>(&mut self, src: RValue<'gcc>, op: F) -> RValue<'gcc>\n+    where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n+    {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        let mut vector_elements = vec![];\n+        for i in 0..element_count {\n+            vector_elements.push(i);\n+        }\n+        let mask_type = self.context.new_vector_type(self.int_type, element_count as u64);\n+        let mut shift = 1;\n+        let mut res = src;\n+        while shift < element_count {\n+            let vector_elements: Vec<_> =\n+                vector_elements.iter()\n+                    .map(|i| self.context.new_rvalue_from_int(self.int_type, ((i + shift) % element_count) as i32))\n+                    .collect();\n+            let mask = self.context.new_rvalue_from_vector(None, mask_type, &vector_elements);\n+            let shifted = self.context.new_rvalue_vector_perm(None, res, res, mask);\n+            shift *= 2;\n+            res = op(res, shifted, &self.context);\n+        }\n+        self.context.new_vector_access(None, res, self.context.new_rvalue_zero(self.int_type))\n+            .to_rvalue()\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce<F>(&mut self, src: RValue<'gcc>, op: F) -> RValue<'gcc>\n+    where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n+    {\n+        unimplemented!();\n+    }\n+\n+    pub fn vector_reduce_op(&mut self, src: RValue<'gcc>, op: BinaryOp) -> RValue<'gcc> {\n+        self.vector_reduce(src, |a, b, context| context.new_binary_op(None, op, a.get_type(), a, b))\n+    }\n+\n+    pub fn vector_reduce_fadd_fast(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    pub fn vector_reduce_fmul_fast(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    // Inspired by Hacker's Delight min implementation.\n+    pub fn vector_reduce_min(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_reduce(src, |a, b, context| {\n+            let differences_or_zeros = difference_or_zero(a, b, context);\n+            context.new_binary_op(None, BinaryOp::Minus, a.get_type(), a, differences_or_zeros)\n+        })\n+    }\n+\n+    // Inspired by Hacker's Delight max implementation.\n+    pub fn vector_reduce_max(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_reduce(src, |a, b, context| {\n+            let differences_or_zeros = difference_or_zero(a, b, context);\n+            context.new_binary_op(None, BinaryOp::Plus, b.get_type(), b, differences_or_zeros)\n+        })\n+    }\n+\n+    pub fn vector_select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, else_val: RValue<'gcc>) -> RValue<'gcc> {\n+        // cond is a vector of integers, not of bools.\n+        let cond_type = cond.get_type();\n+        let vector_type = cond_type.unqualified().dyncast_vector().expect(\"vector type\");\n+        let num_units = vector_type.get_num_units();\n+        let element_type = vector_type.get_element_type();\n+        let zeros = vec![self.context.new_rvalue_zero(element_type); num_units];\n+        let zeros = self.context.new_rvalue_from_vector(None, cond_type, &zeros);\n+\n+        let masks = self.context.new_comparison(None, ComparisonOp::NotEquals, cond, zeros);\n+        let then_vals = masks & then_val;\n+\n+        let ones = vec![self.context.new_rvalue_one(element_type); num_units];\n+        let ones = self.context.new_rvalue_from_vector(None, cond_type, &ones);\n+        let inverted_masks = masks + ones;\n+        // NOTE: sometimes, the type of else_val can be different than the type of then_val in\n+        // libgccjit (vector of int vs vector of int32_t), but they should be the same for the AND\n+        // operation to work.\n+        let else_val = self.context.new_bitcast(None, else_val, then_val.get_type());\n+        let else_vals = inverted_masks & else_val;\n+\n+        then_vals | else_vals\n+    }\n+}\n+\n+fn difference_or_zero<'gcc>(a: RValue<'gcc>, b: RValue<'gcc>, context: &'gcc Context<'gcc>) -> RValue<'gcc> {\n+    let difference = a - b;\n+    let masks = context.new_comparison(None, ComparisonOp::GreaterThanEquals, b, a);\n+    difference & masks\n }\n \n impl<'a, 'gcc, 'tcx> StaticBuilderMethods for Builder<'a, 'gcc, 'tcx> {"}, {"sha": "e4a08da446bb116aac4687e841de8aad7cc8d0bc", "filename": "src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "patch": "@@ -117,8 +117,8 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         unimplemented!();\n     }\n \n-    fn const_real(&self, _t: Type<'gcc>, _val: f64) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn const_real(&self, typ: Type<'gcc>, val: f64) -> RValue<'gcc> {\n+        self.context.new_rvalue_from_double(typ, val)\n     }\n \n     fn const_str(&self, s: Symbol) -> (RValue<'gcc>, RValue<'gcc>) {"}, {"sha": "4b517fd85f052ab2db3a19737392ae1cf7ab314f", "filename": "src/consts.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "patch": "@@ -27,12 +27,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         }\n         // NOTE: since bitcast makes a value non-constant, don't bitcast if not necessary as some\n         // SIMD builtins require a constant value.\n-        if value.get_type() != typ {\n-            self.context.new_bitcast(None, value, typ)\n-        }\n-        else {\n-            value\n-        }\n+        self.bitcast_if_needed(value, typ)\n     }\n }\n \n@@ -86,13 +81,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n \n         // TODO(antoyo): set alignment.\n \n-        let value =\n-            if value.get_type() != gcc_type {\n-                self.context.new_bitcast(None, value, gcc_type)\n-            }\n-            else {\n-                value\n-            };\n+        let value = self.bitcast_if_needed(value, gcc_type);\n         global.global_set_initializer_rvalue(value);\n \n         // As an optimization, all shared statics which do not have interior"}, {"sha": "4bc8c5a6760e3e5afe30de20cd8e634ae03b025e", "filename": "src/context.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "patch": "@@ -35,6 +35,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n \n     pub functions: RefCell<FxHashMap<String, Function<'gcc>>>,\n+    pub intrinsics: RefCell<FxHashMap<String, Function<'gcc>>>,\n \n     pub tls_model: gccjit::TlsModel,\n \n@@ -184,6 +185,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             current_func: RefCell::new(None),\n             normal_function_addresses: Default::default(),\n             functions: RefCell::new(functions),\n+            intrinsics: RefCell::new(FxHashMap::default()),\n \n             tls_model,\n \n@@ -279,6 +281,15 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n+\n+    pub fn bitcast_if_needed(&self, value: RValue<'gcc>, expected_type: Type<'gcc>) -> RValue<'gcc> {\n+        if value.get_type() != expected_type {\n+            self.context.new_bitcast(None, value, expected_type)\n+        }\n+        else {\n+            value\n+        }\n+    }\n }\n \n impl<'gcc, 'tcx> BackendTypes for CodegenCx<'gcc, 'tcx> {\n@@ -306,8 +317,16 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn get_fn_addr(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n-        let func = get_fn(self, instance);\n-        let func = self.rvalue_as_function(func);\n+        let func_name = self.tcx.symbol_name(instance).name;\n+\n+        let func =\n+            if self.intrinsics.borrow().contains_key(func_name) {\n+                self.intrinsics.borrow()[func_name].clone()\n+            }\n+            else {\n+                let func = get_fn(self, instance);\n+                self.rvalue_as_function(func)\n+            };\n         let ptr = func.get_address(None);\n \n         // TODO(antoyo): don't do this twice: i.e. in declare_fn and here."}, {"sha": "a619e2f77125243a062ca7617c098f7a2ca562c7", "filename": "src/declare.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdeclare.rs?ref=e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "patch": "@@ -11,7 +11,7 @@ use crate::intrinsic::llvm;\n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn get_or_insert_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         if self.globals.borrow().contains_key(name) {\n-            let typ = self.globals.borrow().get(name).expect(\"global\").get_type();\n+            let typ = self.globals.borrow()[name].get_type();\n             let global = self.context.new_global(None, GlobalKind::Imported, typ, name);\n             if is_tls {\n                 global.set_tls_model(self.tls_model);\n@@ -103,11 +103,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n /// update the declaration and return existing Value instead.\n fn declare_raw_fn<'gcc>(cx: &CodegenCx<'gcc, '_>, name: &str, _callconv: () /*llvm::CallConv*/, return_type: Type<'gcc>, param_types: &[Type<'gcc>], variadic: bool) -> Function<'gcc> {\n     if name.starts_with(\"llvm.\") {\n-        return llvm::intrinsic(name, cx);\n+        let intrinsic = llvm::intrinsic(name, cx);\n+        cx.intrinsics.borrow_mut().insert(name.to_string(), intrinsic);\n+        return intrinsic;\n     }\n     let func =\n         if cx.functions.borrow().contains_key(name) {\n-            *cx.functions.borrow().get(name).expect(\"function\")\n+            cx.functions.borrow()[name]\n         }\n         else {\n             let params: Vec<_> = param_types.into_iter().enumerate()"}, {"sha": "1b089f08f764a066127b5669de791d39a466e047", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 221, "deletions": 2, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "patch": "@@ -1,6 +1,172 @@\n-use gccjit::Function;\n+use std::borrow::Cow;\n \n-use crate::context::CodegenCx;\n+use gccjit::{Function, FunctionPtrType, RValue, ToRValue};\n+\n+use crate::{context::CodegenCx, builder::Builder};\n+\n+pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, gcc_func: FunctionPtrType<'gcc>, mut args: Cow<'b, [RValue<'gcc>]>, func_name: &str) -> Cow<'b, [RValue<'gcc>]> {\n+    // Some LLVM intrinsics do not map 1-to-1 to GCC intrinsics, so we add the missing\n+    // arguments here.\n+    if gcc_func.get_param_count() != args.len() {\n+        match &*func_name {\n+            \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n+                // FIXME(antoyo): the following intrinsics has 4 (or 5) arguments according to the doc, but is defined with 2 (or 3) arguments in library/stdarch/crates/core_arch/src/x86/avx512f.rs.\n+                | \"__builtin_ia32_pmaxsd512_mask\" | \"__builtin_ia32_pmaxsq512_mask\" | \"__builtin_ia32_pmaxsq256_mask\"\n+                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\" | \"__builtin_ia32_pmaxuq256_mask\"\n+                | \"__builtin_ia32_pmaxuq128_mask\"\n+                | \"__builtin_ia32_pminsd512_mask\" | \"__builtin_ia32_pminsq512_mask\" | \"__builtin_ia32_pminsq256_mask\"\n+                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n+                | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\" | \"__builtin_ia32_pminuq256_mask\"\n+                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\"\n+                => {\n+                    // TODO: refactor by separating those intrinsics outside of this branch.\n+                    let add_before_last_arg =\n+                        match &*func_name {\n+                            \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                                | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n+                                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => true,\n+                            _ => false,\n+                        };\n+                    let new_first_arg_is_zero =\n+                        match &*func_name {\n+                            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\"\n+                                | \"__builtin_ia32_pminuq256_mask\" | \"__builtin_ia32_pminuq128_mask\" => true,\n+                            _ => false\n+                        };\n+                    let arg3_index =\n+                        match &*func_name {\n+                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 1,\n+                            _ => 2,\n+                        };\n+                    let mut new_args = args.to_vec();\n+                    let arg3_type = gcc_func.get_param_type(arg3_index);\n+                    let first_arg =\n+                        if new_first_arg_is_zero {\n+                            let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n+                            let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                            let num_units = vector_type.get_num_units();\n+                            builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units])\n+                        }\n+                        else {\n+                            builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue()\n+                        };\n+                    if add_before_last_arg {\n+                        new_args.insert(new_args.len() - 1, first_arg);\n+                    }\n+                    else {\n+                        new_args.push(first_arg);\n+                    }\n+                    let arg4_index =\n+                        match &*func_name {\n+                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 2,\n+                            _ => 3,\n+                        };\n+                    let arg4_type = gcc_func.get_param_type(arg4_index);\n+                    let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                    if add_before_last_arg {\n+                        new_args.insert(new_args.len() - 1, minus_one);\n+                    }\n+                    else {\n+                        new_args.push(minus_one);\n+                    }\n+                    args = new_args.into();\n+                },\n+                \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n+                    | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n+                    | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n+                        let mut new_args = args.to_vec();\n+                        let arg5_type = gcc_func.get_param_type(4);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                        new_args.push(minus_one);\n+                        args = new_args.into();\n+                    },\n+                    \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+                        let mut new_args = args.to_vec();\n+\n+                        let mut last_arg = None;\n+                        if args.len() == 4 {\n+                            last_arg = new_args.pop();\n+                        }\n+\n+                        let arg4_type = gcc_func.get_param_type(3);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                        new_args.push(minus_one);\n+\n+                        if args.len() == 3 {\n+                            // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n+                            // the same GCC intrinsic, but the former has 3 parameters and the\n+                            // latter has 4 so it doesn't require this additional argument.\n+                            let arg5_type = gcc_func.get_param_type(4);\n+                            new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n+                        }\n+\n+                        if let Some(last_arg) = last_arg {\n+                            new_args.push(last_arg);\n+                        }\n+\n+                        args = new_args.into();\n+                    },\n+                    \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n+                        | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n+                        | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n+                        | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\" => {\n+                        let mut new_args = args.to_vec();\n+                        let last_arg = new_args.pop().expect(\"last arg\");\n+                        let arg3_type = gcc_func.get_param_type(2);\n+                        let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                        new_args.push(undefined);\n+                        let arg4_type = gcc_func.get_param_type(3);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                        new_args.push(minus_one);\n+                        new_args.push(last_arg);\n+                        args = new_args.into();\n+                    },\n+                    \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+                        let mut new_args = args.to_vec();\n+                        let last_arg = new_args.pop().expect(\"last arg\");\n+                        let arg4_type = gcc_func.get_param_type(3);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                        new_args.push(minus_one);\n+                        new_args.push(last_arg);\n+                        args = new_args.into();\n+                    },\n+                    _ => (),\n+        }\n+    }\n+\n+    args\n+}\n+\n+pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n+    // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n+    // last argument type check.\n+    // FIXME(antoyo): find a way to refactor in order to avoid this hack.\n+    match func_name {\n+        \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+            | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" | \"__builtin_ia32_sqrtps512_mask\"\n+            | \"__builtin_ia32_sqrtpd512_mask\" | \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n+            | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n+            | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n+            | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n+            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+                if index == args_len - 1 {\n+                    return true;\n+                }\n+            },\n+        \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+            // Since there are two LLVM intrinsics that map to each of these GCC builtins and only\n+            // one of them has a missing parameter before the last one, we check the number of\n+            // arguments to distinguish those cases.\n+            if args_len == 4 && index == args_len - 1 {\n+                return true;\n+            }\n+        },\n+        _ => (),\n+    }\n+\n+    false\n+}\n \n #[cfg(not(feature=\"master\"))]\n pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n@@ -21,6 +187,59 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.xgetbv\" => \"__builtin_ia32_xgetbv\",\n         // NOTE: this doc specifies the equivalent GCC builtins: http://huonw.github.io/llvmint/llvmint/x86/index.html\n         \"llvm.sqrt.v2f64\" => \"__builtin_ia32_sqrtpd\",\n+        \"llvm.x86.avx512.pmul.dq.512\" => \"__builtin_ia32_pmuldq512_mask\",\n+        \"llvm.x86.avx512.pmulu.dq.512\" => \"__builtin_ia32_pmuludq512_mask\",\n+        \"llvm.x86.avx512.mask.pmaxs.q.256\" => \"__builtin_ia32_pmaxsq256_mask\",\n+        \"llvm.x86.avx512.mask.pmaxs.q.128\" => \"__builtin_ia32_pmaxsq128_mask\",\n+        \"llvm.x86.avx512.max.ps.512\" => \"__builtin_ia32_maxps512_mask\",\n+        \"llvm.x86.avx512.max.pd.512\" => \"__builtin_ia32_maxpd512_mask\",\n+        \"llvm.x86.avx512.mask.pmaxu.q.256\" => \"__builtin_ia32_pmaxuq256_mask\",\n+        \"llvm.x86.avx512.mask.pmaxu.q.128\" => \"__builtin_ia32_pmaxuq128_mask\",\n+        \"llvm.x86.avx512.mask.pmins.q.256\" => \"__builtin_ia32_pminsq256_mask\",\n+        \"llvm.x86.avx512.mask.pmins.q.128\" => \"__builtin_ia32_pminsq128_mask\",\n+        \"llvm.x86.avx512.min.ps.512\" => \"__builtin_ia32_minps512_mask\",\n+        \"llvm.x86.avx512.min.pd.512\" => \"__builtin_ia32_minpd512_mask\",\n+        \"llvm.x86.avx512.mask.pminu.q.256\" => \"__builtin_ia32_pminuq256_mask\",\n+        \"llvm.x86.avx512.mask.pminu.q.128\" => \"__builtin_ia32_pminuq128_mask\",\n+        \"llvm.fma.v16f32\" => \"__builtin_ia32_vfmaddps512_mask\",\n+        \"llvm.fma.v8f64\" => \"__builtin_ia32_vfmaddpd512_mask\",\n+        \"llvm.x86.avx512.vfmaddsub.ps.512\" => \"__builtin_ia32_vfmaddsubps512_mask\",\n+        \"llvm.x86.avx512.vfmaddsub.pd.512\" => \"__builtin_ia32_vfmaddsubpd512_mask\",\n+        \"llvm.x86.avx512.pternlog.d.512\" => \"__builtin_ia32_pternlogd512_mask\",\n+        \"llvm.x86.avx512.pternlog.d.256\" => \"__builtin_ia32_pternlogd256_mask\",\n+        \"llvm.x86.avx512.pternlog.d.128\" => \"__builtin_ia32_pternlogd128_mask\",\n+        \"llvm.x86.avx512.pternlog.q.512\" => \"__builtin_ia32_pternlogq512_mask\",\n+        \"llvm.x86.avx512.pternlog.q.256\" => \"__builtin_ia32_pternlogq256_mask\",\n+        \"llvm.x86.avx512.pternlog.q.128\" => \"__builtin_ia32_pternlogq128_mask\",\n+        \"llvm.x86.avx512.add.ps.512\" => \"__builtin_ia32_addps512_mask\",\n+        \"llvm.x86.avx512.add.pd.512\" => \"__builtin_ia32_addpd512_mask\",\n+        \"llvm.x86.avx512.sub.ps.512\" => \"__builtin_ia32_subps512_mask\",\n+        \"llvm.x86.avx512.sub.pd.512\" => \"__builtin_ia32_subpd512_mask\",\n+        \"llvm.x86.avx512.mul.ps.512\" => \"__builtin_ia32_mulps512_mask\",\n+        \"llvm.x86.avx512.mul.pd.512\" => \"__builtin_ia32_mulpd512_mask\",\n+        \"llvm.x86.avx512.div.ps.512\" => \"__builtin_ia32_divps512_mask\",\n+        \"llvm.x86.avx512.div.pd.512\" => \"__builtin_ia32_divpd512_mask\",\n+        \"llvm.x86.avx512.vfmadd.ps.512\" => \"__builtin_ia32_vfmaddps512_mask\",\n+        \"llvm.x86.avx512.vfmadd.pd.512\" => \"__builtin_ia32_vfmaddpd512_mask\",\n+\n+        // The above doc points to unknown builtins for the following, so override them:\n+        \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\",\n+        \"llvm.x86.avx2.gather.d.d.256\" => \"__builtin_ia32_gathersiv8si\",\n+        \"llvm.x86.avx2.gather.d.ps\" => \"__builtin_ia32_gathersiv4sf\",\n+        \"llvm.x86.avx2.gather.d.ps.256\" => \"__builtin_ia32_gathersiv8sf\",\n+        \"llvm.x86.avx2.gather.d.q\" => \"__builtin_ia32_gathersiv2di\",\n+        \"llvm.x86.avx2.gather.d.q.256\" => \"__builtin_ia32_gathersiv4di\",\n+        \"llvm.x86.avx2.gather.d.pd\" => \"__builtin_ia32_gathersiv2df\",\n+        \"llvm.x86.avx2.gather.d.pd.256\" => \"__builtin_ia32_gathersiv4df\",\n+        \"llvm.x86.avx2.gather.q.d\" => \"__builtin_ia32_gatherdiv4si\",\n+        \"llvm.x86.avx2.gather.q.d.256\" => \"__builtin_ia32_gatherdiv4si256\",\n+        \"llvm.x86.avx2.gather.q.ps\" => \"__builtin_ia32_gatherdiv4sf\",\n+        \"llvm.x86.avx2.gather.q.ps.256\" => \"__builtin_ia32_gatherdiv4sf256\",\n+        \"llvm.x86.avx2.gather.q.q\" => \"__builtin_ia32_gatherdiv2di\",\n+        \"llvm.x86.avx2.gather.q.q.256\" => \"__builtin_ia32_gatherdiv4di\",\n+        \"llvm.x86.avx2.gather.q.pd\" => \"__builtin_ia32_gatherdiv2df\",\n+        \"llvm.x86.avx2.gather.q.pd.256\" => \"__builtin_ia32_gatherdiv4df\",\n+        \"\" => \"\",\n         // NOTE: this file is generated by https://github.com/GuillaumeGomez/llvmint/blob/master/generate_list.py\n         _ => include!(\"archs.rs\"),\n     };"}, {"sha": "6c2834fccf30afa78c55f4c462c0256e92ebbc8e", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 216, "deletions": 11, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "patch": "@@ -1,15 +1,17 @@\n use std::cmp::Ordering;\n \n-use gccjit::{RValue, Type, ToRValue};\n+use gccjit::{BinaryOp, RValue, Type, ToRValue};\n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n use rustc_hir as hir;\n use rustc_middle::span_bug;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::{Span, Symbol, sym};\n+use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n use crate::intrinsic;\n@@ -55,7 +57,53 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     let sig =\n         tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), callee_ty.fn_sig(tcx));\n     let arg_tys = sig.inputs();\n-    let name_str = name.as_str();\n+\n+    if name == sym::simd_select_bitmask {\n+        require_simd!(arg_tys[1], \"argument\");\n+        let (len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+\n+        let expected_int_bits = (len.max(8) - 1).next_power_of_two();\n+        let expected_bytes = len / 8 + ((len % 8 > 0) as u64);\n+\n+        let mask_ty = arg_tys[0];\n+        let mut mask = match mask_ty.kind() {\n+            ty::Int(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                let place = PlaceRef::alloca(bx, args[0].layout);\n+                args[0].val.store(bx, place);\n+                let int_ty = bx.type_ix(expected_bytes * 8);\n+                let ptr = bx.pointercast(place.llval, bx.cx.type_ptr_to(int_ty));\n+                bx.load(int_ty, ptr, Align::ONE)\n+            }\n+            _ => return_error!(\n+                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n+                mask_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            ),\n+        };\n+\n+        let arg1 = args[1].immediate();\n+        let arg1_type = arg1.get_type();\n+        let arg1_vector_type = arg1_type.unqualified().dyncast_vector().expect(\"vector type\");\n+        let arg1_element_type = arg1_vector_type.get_element_type();\n+\n+        let mut elements = vec![];\n+        let one = bx.context.new_rvalue_one(mask.get_type());\n+        for _ in 0..len {\n+            let element = bx.context.new_cast(None, mask & one, arg1_element_type);\n+            elements.push(element);\n+            mask = mask >> one;\n+        }\n+        let vector_mask = bx.context.new_rvalue_from_vector(None, arg1_type, &elements);\n+\n+        return Ok(bx.vector_select(vector_mask, arg1, args[2].immediate()));\n+    }\n \n     // every intrinsic below takes a SIMD vector as its first argument\n     require_simd!(arg_tys[0], \"input\");\n@@ -102,7 +150,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         ));\n     }\n \n-    if let Some(stripped) = name_str.strip_prefix(\"simd_shuffle\") {\n+    if let Some(stripped) = name.as_str().strip_prefix(\"simd_shuffle\") {\n         let n: u64 =\n             if stripped.is_empty() {\n                 // Make sure this is actually an array, since typeck only checks the length-suffixed\n@@ -172,6 +220,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         // NOTE: we cannot cast to an array and assign to its element here because the value might\n         // not be an l-value. So, call a builtin to set the element.\n         // TODO(antoyo): perhaps we could create a new vector or maybe there's a GIMPLE instruction for that?\n+        // TODO(antoyo): don't use target specific builtins here.\n         let func_name =\n             match in_len {\n                 2 => {\n@@ -202,14 +251,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             };\n         let builtin = bx.context.get_target_builtin_function(func_name);\n         let param1_type = builtin.get_param(0).to_rvalue().get_type();\n-        let vector =\n-            if vector.get_type() != param1_type {\n-                // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-                bx.context.new_bitcast(None, vector, param1_type)\n-            }\n-            else {\n-                vector\n-            };\n+        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n+        let vector = bx.cx.bitcast_if_needed(vector, param1_type);\n         let result = bx.context.new_call(None, builtin, &[vector, value, bx.context.new_cast(None, index, bx.int_type)]);\n         // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n         return Ok(bx.context.new_bitcast(None, result, vector.get_type()));\n@@ -228,6 +271,24 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         return Ok(bx.context.new_vector_access(None, vector, args[1].immediate()).to_rvalue());\n     }\n \n+    if name == sym::simd_select {\n+        let m_elem_ty = in_elem;\n+        let m_len = in_len;\n+        require_simd!(arg_tys[1], \"argument\");\n+        let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        require!(\n+            m_len == v_len,\n+            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n+            m_len,\n+            v_len\n+        );\n+        match m_elem_ty.kind() {\n+            ty::Int(_) => {}\n+            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+        }\n+        return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n+    }\n+\n     if name == sym::simd_cast {\n         require_simd!(ret_ty, \"return\");\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n@@ -336,6 +397,10 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 });\n             }\n             (Style::Int(_), Style::Float) => {\n+                // TODO: add support for internal functions in libgccjit to get access to IFN_VEC_CONVERT which is\n+                // doing like __builtin_convertvector?\n+                // Or maybe provide convert_vector as an API since it might not easy to get the\n+                // types of internal functions.\n                 unimplemented!();\n             }\n             (Style::Float, Style::Int(_)) => {\n@@ -539,10 +604,150 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n \n         let func = bx.context.get_target_builtin_function(builtin_name);\n+        let param1_type = func.get_param(0).to_rvalue().get_type();\n+        let param2_type = func.get_param(1).to_rvalue().get_type();\n+        let lhs = bx.cx.bitcast_if_needed(lhs, param1_type);\n+        let rhs = bx.cx.bitcast_if_needed(rhs, param2_type);\n         let result = bx.context.new_call(None, func, &[lhs, rhs]);\n         // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n         return Ok(bx.context.new_bitcast(None, result, vec_ty));\n     }\n \n+    macro_rules! arith_red {\n+        ($name:ident : $vec_op:expr, $float_reduce:ident, $ordered:expr, $op:ident,\n+         $identity:expr) => {\n+            if name == sym::$name {\n+                require!(\n+                    ret_ty == in_elem,\n+                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                    in_elem,\n+                    in_ty,\n+                    ret_ty\n+                );\n+                return match in_elem.kind() {\n+                    ty::Int(_) | ty::Uint(_) => {\n+                        let r = bx.vector_reduce_op(args[0].immediate(), $vec_op);\n+                        if $ordered {\n+                            // if overflow occurs, the result is the\n+                            // mathematical result modulo 2^n:\n+                            Ok(bx.$op(args[1].immediate(), r))\n+                        }\n+                        else {\n+                            Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n+                        }\n+                    }\n+                    ty::Float(_) => {\n+                        if $ordered {\n+                            // ordered arithmetic reductions take an accumulator\n+                            let acc = args[1].immediate();\n+                            Ok(bx.$float_reduce(acc, args[0].immediate()))\n+                        }\n+                        else {\n+                            Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n+                        }\n+                    }\n+                    _ => return_error!(\n+                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                        sym::$name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty\n+                    ),\n+                };\n+            }\n+        };\n+    }\n+\n+    arith_red!(\n+        simd_reduce_add_unordered: BinaryOp::Plus,\n+        vector_reduce_fadd_fast,\n+        false,\n+        add,\n+        0.0 // TODO: Use this argument.\n+    );\n+    arith_red!(\n+        simd_reduce_mul_unordered: BinaryOp::Mult,\n+        vector_reduce_fmul_fast,\n+        false,\n+        mul,\n+        1.0\n+    );\n+\n+    macro_rules! minmax_red {\n+        ($name:ident: $reduction:ident) => {\n+            if name == sym::$name {\n+                require!(\n+                    ret_ty == in_elem,\n+                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                    in_elem,\n+                    in_ty,\n+                    ret_ty\n+                );\n+                return match in_elem.kind() {\n+                    ty::Int(_) | ty::Uint(_) | ty::Float(_) => Ok(bx.$reduction(args[0].immediate())),\n+                    _ => return_error!(\n+                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                        sym::$name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty\n+                    ),\n+                };\n+            }\n+        };\n+    }\n+\n+    minmax_red!(simd_reduce_min: vector_reduce_min);\n+    minmax_red!(simd_reduce_max: vector_reduce_max);\n+\n+    macro_rules! bitwise_red {\n+        ($name:ident : $op:expr, $boolean:expr) => {\n+            if name == sym::$name {\n+                let input = if !$boolean {\n+                    require!(\n+                        ret_ty == in_elem,\n+                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                        in_elem,\n+                        in_ty,\n+                        ret_ty\n+                    );\n+                    args[0].immediate()\n+                } else {\n+                    match in_elem.kind() {\n+                        ty::Int(_) | ty::Uint(_) => {}\n+                        _ => return_error!(\n+                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                            sym::$name,\n+                            in_ty,\n+                            in_elem,\n+                            ret_ty\n+                        ),\n+                    }\n+\n+                    // boolean reductions operate on vectors of i1s:\n+                    let i1 = bx.type_i1();\n+                    let i1xn = bx.type_vector(i1, in_len as u64);\n+                    bx.trunc(args[0].immediate(), i1xn)\n+                };\n+                return match in_elem.kind() {\n+                    ty::Int(_) | ty::Uint(_) => {\n+                        let r = bx.vector_reduce_op(input, $op);\n+                        Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n+                    }\n+                    _ => return_error!(\n+                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                        sym::$name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty\n+                    ),\n+                };\n+            }\n+        };\n+    }\n+\n+    bitwise_red!(simd_reduce_and: BinaryOp::BitwiseAnd, false);\n+    bitwise_red!(simd_reduce_or: BinaryOp::BitwiseOr, false);\n+\n     unimplemented!(\"simd {}\", name);\n }"}, {"sha": "002b95db36deef85e6b2a145bfe1e1415d8c1eb5", "filename": "src/type_.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e062c3712591d4b0ffec3f74153f2cffa35a5c5e/src%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_.rs?ref=e062c3712591d4b0ffec3f74153f2cffa35a5c5e", "patch": "@@ -247,6 +247,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n         self.context.new_array_type(None, ty, len)\n     }\n+\n+    pub fn type_bool(&self) -> Type<'gcc> {\n+        self.context.new_type::<bool>()\n+    }\n }\n \n pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>) -> (Vec<Type<'gcc>>, bool) {"}]}