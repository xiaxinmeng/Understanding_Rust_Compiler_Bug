{"sha": "d139a720a2c0ad7066c43edad6ec6c2aa9613740", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMzlhNzIwYTJjMGFkNzA2NmM0M2VkYWQ2ZWM2YzJhYTk2MTM3NDA=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-10T19:19:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-10T19:19:36Z"}, "message": "Merge pull request #2 from rust-lang/master\n\nupdate from origin 2020-06-10", "tree": {"sha": "f94c254be282b464db805e6fa9042266d66c47b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f94c254be282b464db805e6fa9042266d66c47b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d139a720a2c0ad7066c43edad6ec6c2aa9613740", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe4TJICRBK7hj4Ov3rIwAAdHIIAGyuKUt04EvJxhilE6+CGkeP\nb889I0sviDvaAlp4oS088ILV9sqyrgtOxDa7z+EC6wcYCA15H1Kk6TfOGPu/fROI\nkRbQQvLPTMx3qmLYkNGJv1F2EJPlm/NY9O/wD4JtSvHqVoqDww+31nqReUO9fbXZ\nEZeiZg74U2QIw1f6M0aKjInfie96O/S6ZHJ0MqQKagtOxzOW7nBvlxxWCCatpzVZ\nyosiOmqlm/aORk6Jcq2ONU7mly7SKtbHxufi2uihk1HK6vXNaKgi9ih8LMd+izA9\noe4vXHp9NQGg00gZ2aIAenPLmdbc3A+aweXa5sUbpxXnZLPjtogW9O7bC3pwPkQ=\n=ZmbJ\n-----END PGP SIGNATURE-----\n", "payload": "tree f94c254be282b464db805e6fa9042266d66c47b9\nparent a6127e3fde9e8d24388847ad1b442a4337f19965\nparent bb8674837a9cc5225020e07fc3f164762bb4c11c\nauthor Rich Kadel <richkadel@google.com> 1591816776 -0700\ncommitter GitHub <noreply@github.com> 1591816776 -0700\n\nMerge pull request #2 from rust-lang/master\n\nupdate from origin 2020-06-10"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d139a720a2c0ad7066c43edad6ec6c2aa9613740", "html_url": "https://github.com/rust-lang/rust/commit/d139a720a2c0ad7066c43edad6ec6c2aa9613740", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d139a720a2c0ad7066c43edad6ec6c2aa9613740/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6127e3fde9e8d24388847ad1b442a4337f19965", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6127e3fde9e8d24388847ad1b442a4337f19965", "html_url": "https://github.com/rust-lang/rust/commit/a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "bb8674837a9cc5225020e07fc3f164762bb4c11c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb8674837a9cc5225020e07fc3f164762bb4c11c", "html_url": "https://github.com/rust-lang/rust/commit/bb8674837a9cc5225020e07fc3f164762bb4c11c"}], "stats": {"total": 40416, "additions": 25355, "deletions": 15061}, "files": [{"sha": "c3c95226aebf6d83fd13d614489e64e1b71e6351", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -442,7 +442,7 @@ jobs:\n           - name: x86_64-msvc-cargo\n             env:\n               SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-lld\"\n               VCVARS_BAT: vcvars64.bat\n               NO_DEBUG_ASSERTIONS: 1\n               NO_LLVM_ASSERTIONS: 1"}, {"sha": "15ca403456a4ede8efd866b41fc16f2a1b104ad3", "filename": ".mailmap", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -44,6 +44,7 @@ Brian Anderson <banderson@mozilla.com> <andersrb@gmail.com>\n Brian Anderson <banderson@mozilla.com> <banderson@mozilla.org>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n+Camelid <camelidcamel@gmail.com> <37223377+camelid@users.noreply.github.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <193874+carols10cents@users.noreply.github.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <carol.nichols@gmail.com>\n@@ -70,6 +71,8 @@ David Manescu <david.manescu@gmail.com> <dman2626@uni.sydney.edu.au>\n David Ross <daboross@daboross.net>\n Derek Chiang <derekchiang93@gmail.com> Derek Chiang (Enchi Jiang) <derekchiang93@gmail.com>\n Diggory Hardy <diggory.hardy@gmail.com> Diggory Hardy <github@dhardy.name>\n+Donough Liu <ldm2993593805@163.com> <donoughliu@gmail.com>\n+Donough Liu <ldm2993593805@163.com> DingMing Liu <liudingming@bupt.edu.cn>\n Dustin Bensing <dustin.bensing@googlemail.com>\n Dylan Braithwaite <dylanbraithwaite1@gmail.com> <mail@dylanb.me>\n Dzmitry Malyshau <kvarkus@gmail.com>\n@@ -150,6 +153,10 @@ Kang Seonghoon <kang.seonghoon@mearie.org> <public+git@mearie.org>\n Keegan McAllister <mcallister.keegan@gmail.com> <kmcallister@mozilla.com>\n Kevin Butler <haqkrs@gmail.com>\n Kyeongwoon Lee <kyeongwoon.lee@samsung.com>\n+Kyle J Strand <batmanaod@gmail.com> <BatmanAoD@users.noreply.github.com>\n+Kyle J Strand <batmanaod@gmail.com> <kyle.j.strand@gmail.com>\n+Kyle J Strand <batmanaod@gmail.com> <kyle.strand@pieinsurance.com>\n+Kyle J Strand <batmanaod@gmail.com> <kyle.strand@rms.com>\n Lauren\u021biu Nicola <lnicola@dend.ro>\n Lee Jeffery <leejeffery@gmail.com> Lee Jeffery <lee@leejeffery.co.uk>\n Lee Wondong <wdlee91@gmail.com>\n@@ -259,6 +266,7 @@ Tim Chevalier <chevalier@alum.wellesley.edu> <catamorphism@gmail.com>\n Tim JIANG <p90eri@gmail.com>\n Tim Joseph Dumol <tim@timdumol.com>\n Torsten Weber <TorstenWeber12@gmail.com> <torstenweber12@gmail.com>\n+Trevor Spiteri <tspiteri@ieee.org> <trevor.spiteri@um.edu.mt>\n Ty Overby <ty@pre-alpha.com>\n Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss@users.noreply.github.com>\n Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss>"}, {"sha": "01510b716817234c17c2ca177987ab77763f781f", "filename": "Cargo.lock", "status": "modified", "additions": 232, "deletions": 269, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -8,9 +8,9 @@ checksum = \"7e522997b529f05601e05166c07ed17789691f562762c7f3b987263d2dedee5c\"\n \n [[package]]\n name = \"aho-corasick\"\n-version = \"0.7.3\"\n+version = \"0.7.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e6f484ae0c99fec2e858eb6134949117399f222608d84cadb3f58c1f97c2364c\"\n+checksum = \"8716408b8bc624ed7f65d223ddb9ac2d044c0547b6fa4b0d554f3a9540496ada\"\n dependencies = [\n  \"memchr\",\n ]\n@@ -32,7 +32,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9e266e1f4be5ffa05309f650e2586fe1d3ae6034eb24025a7ae1dfecc330823a\"\n dependencies = [\n  \"html5ever\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"maplit\",\n  \"matches\",\n  \"tendril\",\n@@ -48,6 +48,12 @@ dependencies = [\n  \"ansi_term\",\n ]\n \n+[[package]]\n+name = \"annotate-snippets\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d78ea013094e5ea606b1c05fe35f1dd7ea1eb1ea259908d040b25bd5ec677ee5\"\n+\n [[package]]\n name = \"ansi_term\"\n version = \"0.11.0\"\n@@ -69,14 +75,6 @@ version = \"0.3.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"1025aeae2b664ca0ea726a89d574fe8f4e77dd712d443236ad1de00379450cf6\"\n \n-[[package]]\n-name = \"arena\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"rustc_data_structures\",\n- \"smallvec 1.4.0\",\n-]\n-\n [[package]]\n name = \"argon2rs\"\n version = \"0.2.5\"\n@@ -98,12 +96,12 @@ dependencies = [\n \n [[package]]\n name = \"atty\"\n-version = \"0.2.11\"\n+version = \"0.2.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9a7d5b8723950951411ee34d271d99dddcc2035a16ab25310ea2c8cfd4369652\"\n+checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n dependencies = [\n+ \"hermit-abi\",\n  \"libc\",\n- \"termion\",\n  \"winapi 0.3.8\",\n ]\n \n@@ -210,9 +208,10 @@ dependencies = [\n  \"filetime\",\n  \"getopts\",\n  \"ignore\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"libc\",\n  \"num_cpus\",\n+ \"opener\",\n  \"pretty_assertions\",\n  \"serde\",\n  \"serde_json\",\n@@ -281,15 +280,6 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"716960a18f978640f25101b5cbf1c6f6b0d3192fab36a2d98ca96f0ecbe41010\"\n \n-[[package]]\n-name = \"c2-chacha\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"214238caa1bf3a496ec3392968969cab8549f96ff30652c9e56885329315f6bb\"\n-dependencies = [\n- \"ppv-lite86\",\n-]\n-\n [[package]]\n name = \"cargo\"\n version = \"0.46.0\"\n@@ -320,7 +310,7 @@ dependencies = [\n  \"ignore\",\n  \"im-rc\",\n  \"jobserver\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"lazycell\",\n  \"libc\",\n  \"libgit2-sys\",\n@@ -336,7 +326,7 @@ dependencies = [\n  \"rustc-workspace-hack\",\n  \"rustfix\",\n  \"same-file\",\n- \"semver\",\n+ \"semver 0.10.0\",\n  \"serde\",\n  \"serde_ignored\",\n  \"serde_json\",\n@@ -353,6 +343,19 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"cargo-miri\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"cargo_metadata 0.9.1\",\n+ \"directories\",\n+ \"rustc-workspace-hack\",\n+ \"rustc_version\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"vergen\",\n+]\n+\n [[package]]\n name = \"cargo-platform\"\n version = \"0.1.1\"\n@@ -374,7 +377,7 @@ dependencies = [\n  \"flate2\",\n  \"git2\",\n  \"glob\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"remove_dir_all\",\n  \"serde_json\",\n  \"tar\",\n@@ -388,7 +391,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"929766d993a2fde7a0ae962ee82429069cd7b68839cd9375b98efd719df65d3a\"\n dependencies = [\n  \"failure\",\n- \"semver\",\n+ \"semver 0.9.0\",\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n@@ -400,7 +403,7 @@ version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"46e3374c604fb39d1a2f35ed5e4a4e30e60d01fab49446e08f1b3e9a90aef202\"\n dependencies = [\n- \"semver\",\n+ \"semver 0.9.0\",\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n@@ -412,9 +415,9 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.52\"\n+version = \"1.0.54\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c3d87b23d6a92cd03af510a5ade527033f6aa6fa92161e2d5863a907d4c5e31d\"\n+checksum = \"7bbb73db36c1246e9034e307d0fba23f9a2e251faa47ade70c1bd252220c8311\"\n dependencies = [\n  \"jobserver\",\n ]\n@@ -468,7 +471,7 @@ version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9e4782d108e420a1fcf94d8a919cf248db33c5071678e87d9c2d4f20ed1feb32\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n ]\n \n [[package]]\n@@ -536,10 +539,10 @@ dependencies = [\n  \"clippy_lints\",\n  \"compiletest_rs\",\n  \"derive-new\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"rustc-workspace-hack\",\n  \"rustc_tools_util 0.2.0\",\n- \"semver\",\n+ \"semver 0.9.0\",\n  \"serde\",\n  \"tempfile\",\n  \"tester\",\n@@ -556,13 +559,15 @@ dependencies = [\n  \"cargo_metadata 0.9.1\",\n  \"if_chain\",\n  \"itertools 0.9.0\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"pulldown-cmark 0.7.1\",\n  \"quine-mc_cluskey\",\n+ \"quote 1.0.2\",\n  \"regex-syntax\",\n- \"semver\",\n+ \"semver 0.9.0\",\n  \"serde\",\n  \"smallvec 1.4.0\",\n+ \"syn 1.0.11\",\n  \"toml\",\n  \"unicode-normalization\",\n  \"url 2.1.0\",\n@@ -608,11 +613,13 @@ dependencies = [\n \n [[package]]\n name = \"colored\"\n-version = \"1.6.0\"\n+version = \"1.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b0aa3473e85a3161b59845d6096b289bb577874cafeaf75ea1b1beaa6572c7fc\"\n+checksum = \"f4ffc801dacf156c5854b9df4f425a626539c3a6ef7893cc0c5084a23f0b6c59\"\n dependencies = [\n- \"lazy_static 0.2.11\",\n+ \"atty\",\n+ \"lazy_static\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -635,9 +642,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.28\"\n+version = \"0.1.32\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"439a6fab343b1dab347823537734a5cd4ae6ae2000b465ab886f64cdb723bd14\"\n+checksum = \"7bc4ac2c824d2bfc612cba57708198547e9a26943af0632aff033e0693074d5c\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -650,7 +657,7 @@ dependencies = [\n  \"diff\",\n  \"env_logger 0.7.1\",\n  \"getopts\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"libc\",\n  \"log\",\n  \"miow 0.3.3\",\n@@ -807,7 +814,7 @@ dependencies = [\n  \"arrayvec\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.6.5\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"memoffset\",\n  \"scopeguard\",\n ]\n@@ -828,7 +835,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f8306fcef4a7b563b76b7dd949ca48f52bc1141aa067d2ea09565f3e2652aa5c\"\n dependencies = [\n  \"cfg-if\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n ]\n \n [[package]]\n@@ -839,7 +846,7 @@ checksum = \"c3c7c73a2d1e9fc0886a08b93e98eb643461230d5f1925e4036204d5f2e261a8\"\n dependencies = [\n  \"autocfg 1.0.0\",\n  \"cfg-if\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n ]\n \n [[package]]\n@@ -1045,7 +1052,7 @@ version = \"2.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a99a310cd1f9770e7bf8e48810c7bcbb0e078c8fb23a8c7bcf0da4c2bf61a455\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"regex\",\n  \"serde\",\n  \"serde_derive\",\n@@ -1191,14 +1198,6 @@ dependencies = [\n  \"miniz_oxide\",\n ]\n \n-[[package]]\n-name = \"fmt_macros\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"rustc_lexer\",\n- \"rustc_span\",\n-]\n-\n [[package]]\n name = \"fnv\"\n version = \"1.0.6\"\n@@ -1380,10 +1379,6 @@ dependencies = [\n  \"regex\",\n ]\n \n-[[package]]\n-name = \"graphviz\"\n-version = \"0.0.0\"\n-\n [[package]]\n name = \"h2\"\n version = \"0.1.25\"\n@@ -1613,12 +1608,12 @@ checksum = \"522daefc3b69036f80c7d2990b28ff9e0471c683bad05ca258e0a01dd22c5a1e\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"globset\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"log\",\n  \"memchr\",\n  \"regex\",\n  \"same-file\",\n- \"thread_local 1.0.1\",\n+ \"thread_local\",\n  \"walkdir\",\n  \"winapi-util\",\n ]\n@@ -1650,7 +1645,7 @@ dependencies = [\n  \"clap\",\n  \"failure\",\n  \"flate2\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"num_cpus\",\n  \"rayon\",\n  \"remove_dir_all\",\n@@ -1675,15 +1670,6 @@ version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7e5b386aef33a1c677be65237cb9d32c3f3ef56bd035949710c4bb13083eb053\"\n \n-[[package]]\n-name = \"itertools\"\n-version = \"0.7.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f58856976b776fedd95533137617a02fb25719f40e7d9b01c7043cd65474f450\"\n-dependencies = [\n- \"either\",\n-]\n-\n [[package]]\n name = \"itertools\"\n version = \"0.8.0\"\n@@ -1822,7 +1808,7 @@ dependencies = [\n  \"bytes\",\n  \"globset\",\n  \"jsonrpc-core\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"log\",\n  \"tokio\",\n  \"tokio-codec\",\n@@ -1839,12 +1825,6 @@ dependencies = [\n  \"winapi-build\",\n ]\n \n-[[package]]\n-name = \"lazy_static\"\n-version = \"0.2.11\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"76f033c7ad61445c5b347c7382dd1237847eb1bce590fe50365dcb33d546be73\"\n-\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\n@@ -1859,9 +1839,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.69\"\n+version = \"0.2.71\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99e85c08494b21a9054e7fe1374a732aeadaff3980b6990b94bfd3a70f690005\"\n+checksum = \"9457b06509d27052635f90d6466700c65095fdf75409b3fbdd903e988b886f49\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -1950,7 +1930,7 @@ version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"19af41f0565d7c19b2058153ad0b42d4d5ce89ec4dbf06ed6741114a8b63e7cd\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n ]\n \n [[package]]\n@@ -2054,7 +2034,7 @@ dependencies = [\n  \"error-chain\",\n  \"handlebars\",\n  \"itertools 0.8.0\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"log\",\n  \"memchr\",\n  \"open\",\n@@ -2089,7 +2069,7 @@ dependencies = [\n  \"rayon\",\n  \"regex\",\n  \"reqwest\",\n- \"semver\",\n+ \"semver 0.9.0\",\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n@@ -2110,9 +2090,9 @@ dependencies = [\n \n [[package]]\n name = \"memchr\"\n-version = \"2.3.2\"\n+version = \"2.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53445de381a1f436797497c61d851644d0e8e88e6140f22872ad33a704933978\"\n+checksum = \"3728d817d99e5ac407411fa471ff9800a778d88a24685968b36824eaf4bee400\"\n \n [[package]]\n name = \"memmap\"\n@@ -2239,22 +2219,17 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder\",\n- \"cargo_metadata 0.9.1\",\n  \"colored\",\n  \"compiletest_rs\",\n- \"directories\",\n  \"env_logger 0.7.1\",\n  \"getrandom\",\n  \"hex 0.4.0\",\n+ \"libc\",\n  \"log\",\n- \"num-traits\",\n  \"rand 0.7.3\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n- \"serde\",\n- \"serde_json\",\n  \"shell-escape\",\n- \"vergen\",\n ]\n \n [[package]]\n@@ -2263,7 +2238,7 @@ version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4b2df1a4c22fd44a62147fd8f13dd0f95c9d8ca7b2610299b2a2f9cf8964274e\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"libc\",\n  \"log\",\n  \"openssl\",\n@@ -2327,6 +2302,9 @@ name = \"once_cell\"\n version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d6a04cb71e910d0034815600180f62a95bf6e67942d7ab52a166a68c7d7e9cd0\"\n+dependencies = [\n+ \"parking_lot 0.9.0\",\n+]\n \n [[package]]\n name = \"opaque-debug\"\n@@ -2358,7 +2336,7 @@ dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n  \"foreign-types\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"libc\",\n  \"openssl-sys\",\n ]\n@@ -2633,9 +2611,9 @@ dependencies = [\n \n [[package]]\n name = \"ppv-lite86\"\n-version = \"0.2.6\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"74490b50b9fbe561ac330df47c08f3f33073d2d00c150f719147d7c54522fa1b\"\n+checksum = \"237a5ed80e274dbc66f86bd59c1e25edc039660be53194b5fe0a482e0f2612ea\"\n \n [[package]]\n name = \"precomputed-hash\"\n@@ -2736,7 +2714,7 @@ checksum = \"9bf259a81de2b2eb9850ec990ec78e6a25319715584fd7652b9b26f96fcb1510\"\n dependencies = [\n  \"error-chain\",\n  \"idna 0.2.0\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"regex\",\n  \"url 2.1.0\",\n ]\n@@ -2802,16 +2780,16 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.33\"\n+version = \"2.1.34\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"54322b696f7df20e0d79d0244a1088f387b7164a5f17987c4ab984dec1a23e42\"\n+checksum = \"cc9caecf1286a3ed28d3ae35207a178ba12e58de95540781e5c6cba05e0f0833\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n  \"derive_more\",\n  \"env_logger 0.7.1\",\n  \"humantime 2.0.0\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"log\",\n  \"rls-span\",\n  \"rustc-ap-rustc_ast\",\n@@ -2850,7 +2828,7 @@ checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n  \"getrandom\",\n  \"libc\",\n- \"rand_chacha 0.2.1\",\n+ \"rand_chacha 0.2.2\",\n  \"rand_core 0.5.1\",\n  \"rand_hc 0.2.0\",\n ]\n@@ -2867,11 +2845,11 @@ dependencies = [\n \n [[package]]\n name = \"rand_chacha\"\n-version = \"0.2.1\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"03a2a90da8c7523f554344f921aa97283eadf6ac484a6d2a7d0212fa7f8d6853\"\n+checksum = \"f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402\"\n dependencies = [\n- \"c2-chacha\",\n+ \"ppv-lite86\",\n  \"rand_core 0.5.1\",\n ]\n \n@@ -2994,7 +2972,7 @@ dependencies = [\n  \"crossbeam-deque\",\n  \"crossbeam-queue\",\n  \"crossbeam-utils 0.6.5\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"num_cpus\",\n ]\n \n@@ -3013,15 +2991,6 @@ version = \"0.1.56\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2439c63f3f6139d1b57529d16bc3b8bb855230c8efcc5d3a896c8bea7c3b1e84\"\n \n-[[package]]\n-name = \"redox_termios\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7e891cfe48e9100a70a3b6eb652fef28920c117d366339687bd5576160db0f76\"\n-dependencies = [\n- \"redox_syscall\",\n-]\n-\n [[package]]\n name = \"redox_users\"\n version = \"0.3.0\"\n@@ -3036,25 +3005,21 @@ dependencies = [\n \n [[package]]\n name = \"regex\"\n-version = \"1.1.6\"\n+version = \"1.3.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8f0a0bcab2fd7d1d7c54fa9eae6f43eddeb9ce2e7352f8518a814a4f65d60c58\"\n+checksum = \"a6020f034922e3194c711b82a627453881bc4682166cabb07134a10c26ba7692\"\n dependencies = [\n  \"aho-corasick\",\n  \"memchr\",\n  \"regex-syntax\",\n- \"thread_local 0.3.6\",\n- \"utf8-ranges\",\n+ \"thread_local\",\n ]\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.6.6\"\n+version = \"0.6.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dcfd8681eebe297b81d98498869d4aae052137651ad7b96822f09ceb690d0a96\"\n-dependencies = [\n- \"ucd-util\",\n-]\n+checksum = \"7fe5bd57d1d7414c6b5ed48563a2c855d995ff777729dcd91c369ec7fea395ae\"\n \n [[package]]\n name = \"remote-test-client\"\n@@ -3123,7 +3088,7 @@ dependencies = [\n  \"home\",\n  \"itertools 0.8.0\",\n  \"jsonrpc-core\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"log\",\n  \"lsp-codec\",\n  \"lsp-types\",\n@@ -3157,13 +3122,13 @@ dependencies = [\n \n [[package]]\n name = \"rls-analysis\"\n-version = \"0.18.0\"\n+version = \"0.18.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c0d208ad66717501222c74b42d9e823a7612592e85ed78b04074c8f58c0be0a\"\n+checksum = \"534032993e1b60e5db934eab2dde54da7afd1e46c3465fddb2b29eb47cb1ed3a\"\n dependencies = [\n  \"derive-new\",\n  \"fst\",\n- \"itertools 0.7.8\",\n+ \"itertools 0.8.0\",\n  \"json\",\n  \"log\",\n  \"rls-data\",\n@@ -3211,9 +3176,9 @@ dependencies = [\n \n [[package]]\n name = \"rls-span\"\n-version = \"0.5.1\"\n+version = \"0.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f1cb4694410d8d2ce43ccff3682f1c782158a018d5a9a92185675677f7533eb3\"\n+checksum = \"f2e9bed56f6272bd85d9d06d1aaeef80c5fddc78a82199eb36dceb5f94e7d934\"\n dependencies = [\n  \"serde\",\n ]\n@@ -3243,25 +3208,25 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-arena\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"81dfcfbb0ddfd533abf8c076e3b49d1e5042d1962526a12ce2c66d514b24cca3\"\n+checksum = \"fdaf0295fc40b10ec1091aad1a1760b4bb3b4e7c4f77d543d1a2e9d50a01e6b1\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-graphviz\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7490bb07b014a7f9531bde33c905a805e08095dbefdb4c9988a1b19fe6d019fd\"\n+checksum = \"8028e8cdb4eb71810d0c22a5a5e1e3106c81123be63ce7f044b6d4ac100d8941\"\n \n [[package]]\n name = \"rustc-ap-rustc_ast\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"189f16dbb8dd11089274c9ced58b0cae9e1ea3e434a58f3db683817eda849e58\"\n+checksum = \"16e9e502bb3a5568433db1cf2fb1f1e1074934636069cf744ad7c77b58e1428e\"\n dependencies = [\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3276,9 +3241,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_ast_passes\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bbe619609b56a617fa986332b066d53270093c816d8ff8281fc90e1dbe74c1cc\"\n+checksum = \"faf35ffecab28f97f7ac01cf6a13afaca6408529d15eb95f317a43b2ffb88933\"\n dependencies = [\n  \"itertools 0.8.0\",\n  \"log\",\n@@ -3295,21 +3260,20 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_ast_pretty\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"26ab1495f7b420e937688749c1da5763aaabd6ebe8cacb758665a0b8481da094\"\n+checksum = \"3684ed43dc552f1e030e3f7a5a300a7a834bdda4e9e00ab80284be4220d8c603\"\n dependencies = [\n  \"log\",\n  \"rustc-ap-rustc_ast\",\n- \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_span\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_attr\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2e057495724c60729c1d1d9d49374e0b3ebd6d3481cd161b2871f52fe017b7b5\"\n+checksum = \"31b413927daa666983b3b49227f9ac218aa29254546abdb585f20cd71c391870\"\n dependencies = [\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n@@ -3320,22 +3284,22 @@ dependencies = [\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n  \"rustc-ap-serialize\",\n- \"smallvec 1.4.0\",\n+ \"version_check\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d2130997667833692f4bec4681d0e73b066d5a01dac1d8a68f22068b82bf173a\"\n+checksum = \"4b1c6069e5c522657f1c6f5ab33074e097092f48e804cc896d337e319aacbd60\"\n dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.7.2\",\n- \"ena 0.13.1\",\n+ \"ena 0.14.0\",\n  \"indexmap\",\n  \"jobserver\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"libc\",\n  \"log\",\n  \"measureme\",\n@@ -3348,16 +3312,17 @@ dependencies = [\n  \"rustc-rayon-core\",\n  \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n+ \"stacker\",\n  \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"908e1ea187c6bb368af4ba6db980001e920515e67371ddc4086e749baabe6080\"\n+checksum = \"0c374e89b3c9714869ef86076942155383804ba6778c26be2169d324563c31f9\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.6.1\",\n  \"atty\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3371,9 +3336,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_expand\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"50066a75bca872ff933b0ee8a582d18ef1876c8054a392f60c39e538446bfb00\"\n+checksum = \"259d2a7aa7a12f3c99a4ce4123643ec065f1a26f8e89be1f9bedd9757ea53fdc\"\n dependencies = [\n  \"log\",\n  \"rustc-ap-rustc_ast\",\n@@ -3393,45 +3358,45 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_feature\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"96fb53e1710e6de7c2e371ca56c857b79f9b399aba58aa6b6fbed6e2f677d3f6\"\n+checksum = \"c0296fbc29b629d5ae2ebee1bbf0407bb22de04d26d87216c20899b79579ccb3\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_span\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_fs_util\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e3f91357e5e468fc2729211571d769723c728a34e200d90a70164e945f881e09\"\n+checksum = \"34734f6cc681399630acd836a14207c6b5b9671a290cc7cad0354b0a4d71b3c9\"\n \n [[package]]\n name = \"rustc-ap-rustc_index\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"32220c3e6cdf226f38e4474b747dca15f3106bb680c74f10b299af3f6cdb1663\"\n+checksum = \"d1e4508753d71d3523209c2ca5086db15a1413e71ebf17ad5412bb7ced5e44c2\"\n dependencies = [\n  \"rustc-ap-serialize\",\n  \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3b324d2a2bacad344e53e182e5ca04ffb74745b932849aa074f8f7fec8177da5\"\n+checksum = \"42b9fcd8407e322908a721262fbc0b35b5f3c35bb173a26dd1e0070bde336e33\"\n dependencies = [\n  \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"59686c56d5f1b3ed47d0f070c257ed35caf24ecf2d744dd11fe44b1014baee0f\"\n+checksum = \"3d104115a689367d2e0bcd99f37e0ebd6b9c8c78bab0d9cbea5bae86323601b5\"\n dependencies = [\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n@@ -3441,9 +3406,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_parse\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2dfb0c11c591ec5f87bbadb10819795abc9035ff79a26703c1b6c9487ac51f49\"\n+checksum = \"afaaab91853fc5a3916785ccae727a4433359d9787c260d42b96a2265fe5b287\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n@@ -3455,15 +3420,14 @@ dependencies = [\n  \"rustc-ap-rustc_lexer\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n- \"smallvec 1.4.0\",\n  \"unicode-normalization\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_session\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3d1a194b1a81d7233ee492847638dc9ebdb7d084300e5ade8dea0ceaa98f95b9\"\n+checksum = \"86e756a57ce6ce1b868e35e64a7e10ab28d49ece80d7c661b07aff5afc6e5d2d\"\n dependencies = [\n  \"getopts\",\n  \"log\",\n@@ -3481,9 +3445,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_span\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a648146050fed6b58e681ec22488e728f60e16036bb7497c9815e3debd1e4242\"\n+checksum = \"21031c3396ee452f4c6e994b67513a633055c57c86d00336afd9d63149518f34\"\n dependencies = [\n  \"cfg-if\",\n  \"log\",\n@@ -3500,9 +3464,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"28cf28798f0988b808e3616713630e4098d68c6f1f41052a2f7e922e094da744\"\n+checksum = \"ff21badfbead5b0050391eaad8840f2e4fcb03b6b0fc6006f447443529e9ae6e\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n@@ -3515,9 +3479,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"654.0.0\"\n+version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"756e8f526ec7906e132188bf25e3c10a6ee42ab77294ecb3b3602647f0508eef\"\n+checksum = \"768b5a305669d934522712bc13502962edfde5128ea63b9e7db4000410be1dc6\"\n dependencies = [\n  \"indexmap\",\n  \"smallvec 1.4.0\",\n@@ -3571,7 +3535,7 @@ dependencies = [\n  \"crossbeam-deque\",\n  \"crossbeam-queue\",\n  \"crossbeam-utils 0.6.5\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"num_cpus\",\n ]\n \n@@ -3621,6 +3585,14 @@ dependencies = [\n  \"smallvec 1.4.0\",\n ]\n \n+[[package]]\n+name = \"rustc_arena\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_data_structures\",\n+ \"smallvec 1.4.0\",\n+]\n+\n [[package]]\n name = \"rustc_ast\"\n version = \"0.0.0\"\n@@ -3631,18 +3603,18 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_lexer\",\n  \"rustc_macros\",\n+ \"rustc_serialize\",\n  \"rustc_span\",\n  \"scoped-tls\",\n- \"serialize\",\n  \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc_ast_lowering\"\n version = \"0.0.0\"\n dependencies = [\n- \"arena\",\n  \"log\",\n+ \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n@@ -3692,17 +3664,16 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_macros\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"serialize\",\n  \"version_check\",\n ]\n \n [[package]]\n name = \"rustc_builtin_macros\"\n version = \"0.0.0\"\n dependencies = [\n- \"fmt_macros\",\n  \"log\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n@@ -3712,6 +3683,7 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_feature\",\n  \"rustc_parse\",\n+ \"rustc_parse_format\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3740,10 +3712,10 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_llvm\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"serialize\",\n  \"smallvec 1.4.0\",\n ]\n \n@@ -3768,11 +3740,11 @@ dependencies = [\n  \"rustc_incremental\",\n  \"rustc_index\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n  \"rustc_target\",\n- \"serialize\",\n  \"tempfile\",\n ]\n \n@@ -3784,19 +3756,20 @@ dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils 0.7.2\",\n  \"ena 0.14.0\",\n- \"graphviz\",\n  \"indexmap\",\n  \"jobserver\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"libc\",\n  \"log\",\n  \"measureme\",\n+ \"once_cell\",\n  \"parking_lot 0.10.2\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n+ \"rustc_graphviz\",\n  \"rustc_index\",\n- \"serialize\",\n+ \"rustc_serialize\",\n  \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n  \"stacker\",\n@@ -3808,7 +3781,7 @@ name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n  \"env_logger 0.7.1\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"libc\",\n  \"log\",\n  \"rustc_ast\",\n@@ -3828,10 +3801,10 @@ dependencies = [\n  \"rustc_parse\",\n  \"rustc_plugin_impl\",\n  \"rustc_save_analysis\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"serialize\",\n  \"winapi 0.3.8\",\n ]\n \n@@ -3843,12 +3816,12 @@ version = \"0.0.0\"\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.8.0\",\n  \"atty\",\n  \"log\",\n  \"rustc_data_structures\",\n+ \"rustc_serialize\",\n  \"rustc_span\",\n- \"serialize\",\n  \"termcolor\",\n  \"termize\",\n  \"unicode-width\",\n@@ -3869,17 +3842,17 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_lexer\",\n  \"rustc_parse\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"serialize\",\n  \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc_feature\"\n version = \"0.0.0\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"rustc_data_structures\",\n  \"rustc_span\",\n ]\n@@ -3888,19 +3861,23 @@ dependencies = [\n name = \"rustc_fs_util\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"rustc_graphviz\"\n+version = \"0.0.0\"\n+\n [[package]]\n name = \"rustc_hir\"\n version = \"0.0.0\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"log\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"serialize\",\n  \"smallvec 1.4.0\",\n ]\n \n@@ -3919,44 +3896,44 @@ dependencies = [\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n dependencies = [\n- \"graphviz\",\n  \"log\",\n  \"rand 0.7.3\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n+ \"rustc_graphviz\",\n  \"rustc_hir\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"serialize\",\n ]\n \n [[package]]\n name = \"rustc_index\"\n version = \"0.0.0\"\n dependencies = [\n- \"serialize\",\n+ \"rustc_serialize\",\n  \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc_infer\"\n version = \"0.0.0\"\n dependencies = [\n- \"graphviz\",\n  \"log\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_graphviz\",\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"serialize\",\n  \"smallvec 1.4.0\",\n ]\n \n@@ -3990,6 +3967,7 @@ dependencies = [\n  \"rustc_plugin_impl\",\n  \"rustc_privacy\",\n  \"rustc_resolve\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n@@ -3998,7 +3976,6 @@ dependencies = [\n  \"rustc_traits\",\n  \"rustc_ty\",\n  \"rustc_typeck\",\n- \"serialize\",\n  \"smallvec 1.4.0\",\n  \"tempfile\",\n  \"winapi 0.3.8\",\n@@ -4068,10 +4045,10 @@ dependencies = [\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"serialize\",\n  \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n  \"winapi 0.3.8\",\n@@ -4081,7 +4058,6 @@ dependencies = [\n name = \"rustc_middle\"\n version = \"0.0.0\"\n dependencies = [\n- \"arena\",\n  \"bitflags\",\n  \"byteorder\",\n  \"chalk-ir\",\n@@ -4090,6 +4066,7 @@ dependencies = [\n  \"polonius-engine\",\n  \"rustc-rayon-core\",\n  \"rustc_apfloat\",\n+ \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -4099,11 +4076,11 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_query_system\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"scoped-tls\",\n- \"serialize\",\n  \"smallvec 1.4.0\",\n ]\n \n@@ -4112,7 +4089,6 @@ name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n  \"either\",\n- \"graphviz\",\n  \"itertools 0.8.0\",\n  \"log\",\n  \"log_settings\",\n@@ -4122,27 +4098,28 @@ dependencies = [\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_graphviz\",\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_lexer\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"serialize\",\n  \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc_mir_build\"\n version = \"0.0.0\"\n dependencies = [\n- \"arena\",\n  \"log\",\n  \"rustc_apfloat\",\n+ \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -4151,11 +4128,11 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"serialize\",\n  \"smallvec 1.4.0\",\n ]\n \n@@ -4176,6 +4153,14 @@ dependencies = [\n  \"unicode-normalization\",\n ]\n \n+[[package]]\n+name = \"rustc_parse_format\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_lexer\",\n+ \"rustc_span\",\n+]\n+\n [[package]]\n name = \"rustc_passes\"\n version = \"0.0.0\"\n@@ -4227,25 +4212,25 @@ dependencies = [\n name = \"rustc_query_system\"\n version = \"0.0.0\"\n dependencies = [\n- \"arena\",\n  \"log\",\n  \"parking_lot 0.10.2\",\n  \"rustc-rayon-core\",\n+ \"rustc_arena\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_index\",\n+ \"rustc_serialize\",\n  \"rustc_span\",\n- \"serialize\",\n  \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc_resolve\"\n version = \"0.0.0\"\n dependencies = [\n- \"arena\",\n  \"bitflags\",\n  \"log\",\n+ \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_ast_lowering\",\n  \"rustc_ast_pretty\",\n@@ -4281,6 +4266,14 @@ dependencies = [\n  \"serde_json\",\n ]\n \n+[[package]]\n+name = \"rustc_serialize\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"indexmap\",\n+ \"smallvec 1.4.0\",\n+]\n+\n [[package]]\n name = \"rustc_session\"\n version = \"0.0.0\"\n@@ -4293,24 +4286,24 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_fs_util\",\n+ \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"serialize\",\n ]\n \n [[package]]\n name = \"rustc_span\"\n version = \"0.0.0\"\n dependencies = [\n- \"arena\",\n  \"cfg-if\",\n  \"log\",\n  \"md-5\",\n+ \"rustc_arena\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_serialize\",\n  \"scoped-tls\",\n- \"serialize\",\n  \"sha-1\",\n  \"unicode-width\",\n ]\n@@ -4340,8 +4333,8 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_serialize\",\n  \"rustc_span\",\n- \"serialize\",\n ]\n \n [[package]]\n@@ -4358,7 +4351,6 @@ checksum = \"b725dadae9fabc488df69a287f5a99c5eaf5d10853842a8a3dfac52476f544ee\"\n name = \"rustc_trait_selection\"\n version = \"0.0.0\"\n dependencies = [\n- \"fmt_macros\",\n  \"log\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -4369,6 +4361,7 @@ dependencies = [\n  \"rustc_infer\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n+ \"rustc_parse_format\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4414,8 +4407,8 @@ dependencies = [\n name = \"rustc_typeck\"\n version = \"0.0.0\"\n dependencies = [\n- \"arena\",\n  \"log\",\n+ \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -4437,7 +4430,7 @@ version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n dependencies = [\n- \"semver\",\n+ \"semver 0.9.0\",\n ]\n \n [[package]]\n@@ -4488,9 +4481,9 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.14\"\n+version = \"1.4.15\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.6.1\",\n  \"bytecount\",\n  \"cargo_metadata 0.8.0\",\n  \"derive-new\",\n@@ -4501,11 +4494,12 @@ dependencies = [\n  \"getopts\",\n  \"ignore\",\n  \"itertools 0.8.0\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"log\",\n  \"regex\",\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n+ \"rustc-ap-rustc_attr\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_errors\",\n  \"rustc-ap-rustc_expand\",\n@@ -4545,7 +4539,7 @@ version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"87f550b06b6cba9c8b8be3ee73f391990116bf527450d2556e9b9ce263b9a021\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"winapi 0.3.8\",\n ]\n \n@@ -4598,6 +4592,16 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"semver\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"394cec28fa623e00903caf7ba4fa6fb9a0e260280bb8cdbbba029611108a0190\"\n+dependencies = [\n+ \"semver-parser\",\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"semver-parser\"\n version = \"0.7.0\"\n@@ -4667,14 +4671,6 @@ dependencies = [\n  \"url 1.7.2\",\n ]\n \n-[[package]]\n-name = \"serialize\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"indexmap\",\n- \"smallvec 1.4.0\",\n-]\n-\n [[package]]\n name = \"sha-1\"\n version = \"0.8.2\"\n@@ -4811,7 +4807,7 @@ version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"25d70109977172b127fe834e5449e5ab1740b9ba49fa18a2020f509174f25423\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"new_debug_unreachable\",\n  \"phf_shared\",\n  \"precomputed-hash\",\n@@ -4994,17 +4990,6 @@ dependencies = [\n  \"wincolor\",\n ]\n \n-[[package]]\n-name = \"termion\"\n-version = \"1.5.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"689a3bdfaab439fd92bc87df5c4c78417d3cbe537487274e9b0b2dce76e92096\"\n-dependencies = [\n- \"libc\",\n- \"redox_syscall\",\n- \"redox_termios\",\n-]\n-\n [[package]]\n name = \"termize\"\n version = \"0.1.1\"\n@@ -5069,30 +5054,21 @@ dependencies = [\n  \"syn 1.0.11\",\n ]\n \n-[[package]]\n-name = \"thread_local\"\n-version = \"0.3.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b\"\n-dependencies = [\n- \"lazy_static 1.4.0\",\n-]\n-\n [[package]]\n name = \"thread_local\"\n version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d40c6d1b69745a6ec6fb1ca717914848da4b44ae29d9b3080cbee91d72a69b14\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n ]\n \n [[package]]\n name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata 0.9.1\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"regex\",\n  \"walkdir\",\n ]\n@@ -5217,7 +5193,7 @@ checksum = \"afbd6ef1b8cc2bd2c2b580d882774d443ebb1c6ceefe35ba9ea4ab586c89dbe8\"\n dependencies = [\n  \"crossbeam-queue\",\n  \"futures\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"libc\",\n  \"log\",\n  \"mio\",\n@@ -5236,7 +5212,7 @@ checksum = \"6732fe6b53c8d11178dcb77ac6d9682af27fc6d4cb87789449152e5377377146\"\n dependencies = [\n  \"crossbeam-utils 0.6.5\",\n  \"futures\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"log\",\n  \"mio\",\n  \"num_cpus\",\n@@ -5307,7 +5283,7 @@ dependencies = [\n  \"crossbeam-queue\",\n  \"crossbeam-utils 0.6.5\",\n  \"futures\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"log\",\n  \"num_cpus\",\n  \"slab\",\n@@ -5377,7 +5353,7 @@ dependencies = [\n  \"failure\",\n  \"failure_derive\",\n  \"is-match\",\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"regex\",\n  \"toml\",\n  \"toml-query_derive\",\n@@ -5421,7 +5397,7 @@ version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ca6b52bf4da6512f0f07785a04769222e50d29639e7ecd016b7806fd2de306b4\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"regex\",\n ]\n \n@@ -5431,12 +5407,6 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"71a9c5b1fe77426cf144cc30e49e955270f5086e31a6441dfa8b32efc09b9d77\"\n \n-[[package]]\n-name = \"ucd-util\"\n-version = \"0.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"535c204ee4d8434478593480b8f86ab45ec9aae0e83c568ca81abf0fd0e88f86\"\n-\n [[package]]\n name = \"unicase\"\n version = \"2.6.0\"\n@@ -5570,12 +5540,6 @@ version = \"0.7.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f1262dfab4c30d5cb7c07026be00ee343a6cf5027fdc0104a9160f354e5db75c\"\n \n-[[package]]\n-name = \"utf8-ranges\"\n-version = \"1.0.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"796f7e48bef87609f7ade7e06495a87d5cd06c7866e6a5cbfceffc558a243737\"\n-\n [[package]]\n name = \"utf8parse\"\n version = \"0.1.1\"\n@@ -5605,13 +5569,12 @@ checksum = \"05c78687fb1a80548ae3250346c3db86a80a7cdd77bda190189f2d0a0987c81a\"\n \n [[package]]\n name = \"vergen\"\n-version = \"3.0.4\"\n+version = \"3.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6aba5e34f93dc7051dfad05b98a18e9156f27e7b431fe1d2398cb6061c0a1dba\"\n+checksum = \"4ce50d8996df1f85af15f2cd8d33daae6e479575123ef4314a51a70a230739cb\"\n dependencies = [\n  \"bitflags\",\n  \"chrono\",\n- \"failure\",\n ]\n \n [[package]]\n@@ -5758,7 +5721,7 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"59893318ba3ad2b704498c7761214a10eaf42c5f838bce9fc0145bf2ba658cfa\"\n dependencies = [\n- \"lazy_static 1.4.0\",\n+ \"lazy_static\",\n  \"thiserror\",\n  \"yaml-rust 0.4.3\",\n ]"}, {"sha": "f2177a99a9b88b09672694ee4a2ac60ab2293d65", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -22,6 +22,7 @@ members = [\n   \"src/tools/rls\",\n   \"src/tools/rustfmt\",\n   \"src/tools/miri\",\n+  \"src/tools/miri/cargo-miri\",\n   \"src/tools/rustdoc-themes\",\n   \"src/tools/unicode-table-generator\",\n   \"src/tools/expand-yaml-anchors\","}, {"sha": "42fc0a63c0ffbd9f87699a9f3fbddbd5341baa0d", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -23,7 +23,7 @@ or reading the [rustc dev guide][rustcguidebuild].\n \n [rustcguidebuild]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html\n \n-### Building on *nix\n+### Building on a Unix-like system\n 1. Make sure you have installed the dependencies:\n \n    * `g++` 5.1 or later or `clang++` 3.5 or later"}, {"sha": "3ae3417a9b464c1ddb942efd86ed09dc3d5668f8", "filename": "RELEASES.md", "status": "modified", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,3 +1,165 @@\n+Version 1.44.0 (2020-06-04)\n+==========================\n+\n+Language\n+--------\n+- [You can now use `async/.await` with `#[no_std]` enabled.][69033]\n+- [Added the `unused_braces` lint.][70081]\n+\n+**Syntax-only changes**\n+\n+- [Expansion-driven outline module parsing][69838]\n+```rust\n+#[cfg(FALSE)]\n+mod foo {\n+    mod bar {\n+        mod baz; // `foo/bar/baz.rs` doesn't exist, but no error!\n+    }\n+}\n+```\n+\n+These are still rejected semantically, so you will likely receive an error but\n+these changes can be seen and parsed by macros and conditional compilation.\n+\n+Compiler\n+--------\n+- [Rustc now respects the `-C codegen-units` flag in incremental mode.][70156]\n+  Additionally when in incremental mode rustc defaults to 256 codegen units.\n+- [Refactored `catch_unwind` to have zero-cost, unless unwinding is enabled and\n+  a panic is thrown.][67502]\n+- [Added tier 3\\* support for the `aarch64-unknown-none` and\n+  `aarch64-unknown-none-softfloat` targets.][68334]\n+- [Added tier 3 support for `arm64-apple-tvos` and\n+  `x86_64-apple-tvos` targets.][68191]\n+\n+\n+Libraries\n+---------\n+- [Special cased `vec![]` to map directly to `Vec::new()`.][70632] This allows\n+  `vec![]` to be able to be used in `const` contexts.\n+- [`convert::Infallible` now implements `Hash`.][70281]\n+- [`OsString` now implements `DerefMut` and `IndexMut` returning\n+  a `&mut OsStr`.][70048]\n+- [Unicode 13 is now supported.][69929]\n+- [`String` now implements `From<&mut str>`.][69661]\n+- [`IoSlice` now implements `Copy`.][69403]\n+- [`Vec<T>` now implements `From<[T; N]>`.][68692] Where `N` is at most 32.\n+- [`proc_macro::LexError` now implements `fmt::Display` and `Error`.][68899]\n+- [`from_le_bytes`, `to_le_bytes`, `from_be_bytes`, `to_be_bytes`,\n+  `from_ne_bytes`, and `to_ne_bytes` methods are now `const` for all\n+  integer types.][69373]\n+\n+Stabilized APIs\n+---------------\n+- [`PathBuf::with_capacity`]\n+- [`PathBuf::capacity`]\n+- [`PathBuf::clear`]\n+- [`PathBuf::reserve`]\n+- [`PathBuf::reserve_exact`]\n+- [`PathBuf::shrink_to_fit`]\n+- [`f32::to_int_unchecked`]\n+- [`f64::to_int_unchecked`]\n+- [`Layout::align_to`]\n+- [`Layout::pad_to_align`]\n+- [`Layout::array`]\n+- [`Layout::extend`]\n+\n+Cargo\n+-----\n+- [Added the `cargo tree` command which will print a tree graph of\n+  your dependencies.][cargo/8062] E.g.\n+  ```\n+    mdbook v0.3.2 (/Users/src/rust/mdbook)\n+  \u251c\u2500\u2500 ammonia v3.0.0\n+  \u2502   \u251c\u2500\u2500 html5ever v0.24.0\n+  \u2502   \u2502   \u251c\u2500\u2500 log v0.4.8\n+  \u2502   \u2502   \u2502   \u2514\u2500\u2500 cfg-if v0.1.9\n+  \u2502   \u2502   \u251c\u2500\u2500 mac v0.1.1\n+  \u2502   \u2502   \u2514\u2500\u2500 markup5ever v0.9.0\n+  \u2502   \u2502       \u251c\u2500\u2500 log v0.4.8 (*)\n+  \u2502   \u2502       \u251c\u2500\u2500 phf v0.7.24\n+  \u2502   \u2502       \u2502   \u2514\u2500\u2500 phf_shared v0.7.24\n+  \u2502   \u2502       \u2502       \u251c\u2500\u2500 siphasher v0.2.3\n+  \u2502   \u2502       \u2502       \u2514\u2500\u2500 unicase v1.4.2\n+  \u2502   \u2502       \u2502           [build-dependencies]\n+  \u2502   \u2502       \u2502           \u2514\u2500\u2500 version_check v0.1.5\n+  ...\n+  ```\n+  You can also display dependencies on multiple versions of the same crate with\n+  `cargo tree -d` (short for `cargo tree --duplicates`).\n+\n+Misc\n+----\n+- [Rustdoc now allows you to specify `--crate-version` to have rustdoc include\n+  the version in the sidebar.][69494]\n+\n+Compatibility Notes\n+-------------------\n+- [Rustc now correctly generates static libraries on Windows GNU targets with\n+  the `.a` extension, rather than the previous `.lib`.][70937]\n+- [Removed the `-C no_integrated_as` flag from rustc.][70345]\n+- [The `file_name` property in JSON output of macro errors now points the actual\n+  source file rather than the previous format of `<NAME macros>`.][70969]\n+  **Note:** this may not point to a file that actually exists on the user's system.\n+- [The minimum required external LLVM version has been bumped to LLVM 8.][71147]\n+- [`mem::{zeroed, uninitialised}` will now panic when used with types that do\n+  not allow zero initialization such as `NonZeroU8`.][66059] This was\n+  previously a warning.\n+- [In 1.45.0 (the next release) converting a `f64` to `u32` using the `as`\n+  operator has been defined as a saturating operation.][71269] This was previously\n+  undefined behaviour, but you can use the `{f64, f32}::to_int_unchecked` methods to\n+  continue using the current behaviour, which may be desirable in rare performance\n+  sensitive situations.\n+\n+Internal Only\n+-------------\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of rustc and\n+related tools.\n+\n+- [dep_graph Avoid allocating a set on when the number reads are small.][69778]\n+- [Replace big JS dict with JSON parsing.][71250]\n+\n+[69373]: https://github.com/rust-lang/rust/pull/69373/\n+[66059]: https://github.com/rust-lang/rust/pull/66059/\n+[68191]: https://github.com/rust-lang/rust/pull/68191/\n+[68899]: https://github.com/rust-lang/rust/pull/68899/\n+[71147]: https://github.com/rust-lang/rust/pull/71147/\n+[71250]: https://github.com/rust-lang/rust/pull/71250/\n+[70937]: https://github.com/rust-lang/rust/pull/70937/\n+[70969]: https://github.com/rust-lang/rust/pull/70969/\n+[70632]: https://github.com/rust-lang/rust/pull/70632/\n+[70281]: https://github.com/rust-lang/rust/pull/70281/\n+[70345]: https://github.com/rust-lang/rust/pull/70345/\n+[70048]: https://github.com/rust-lang/rust/pull/70048/\n+[70081]: https://github.com/rust-lang/rust/pull/70081/\n+[70156]: https://github.com/rust-lang/rust/pull/70156/\n+[71269]: https://github.com/rust-lang/rust/pull/71269/\n+[69838]: https://github.com/rust-lang/rust/pull/69838/\n+[69929]: https://github.com/rust-lang/rust/pull/69929/\n+[69661]: https://github.com/rust-lang/rust/pull/69661/\n+[69778]: https://github.com/rust-lang/rust/pull/69778/\n+[69494]: https://github.com/rust-lang/rust/pull/69494/\n+[69403]: https://github.com/rust-lang/rust/pull/69403/\n+[69033]: https://github.com/rust-lang/rust/pull/69033/\n+[68692]: https://github.com/rust-lang/rust/pull/68692/\n+[68334]: https://github.com/rust-lang/rust/pull/68334/\n+[67502]: https://github.com/rust-lang/rust/pull/67502/\n+[cargo/8062]: https://github.com/rust-lang/cargo/pull/8062/\n+[`PathBuf::with_capacity`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.with_capacity\n+[`PathBuf::capacity`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.capacity\n+[`PathBuf::clear`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.clear\n+[`PathBuf::reserve`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.reserve\n+[`PathBuf::reserve_exact`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.reserve_exact\n+[`PathBuf::shrink_to_fit`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.shrink_to_fit\n+[`f32::to_int_unchecked`]: https://doc.rust-lang.org/std/primitive.f32.html#method.to_int_unchecked\n+[`f64::to_int_unchecked`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_int_unchecked\n+[`Layout::align_to`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.align_to\n+[`Layout::pad_to_align`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.pad_to_align\n+[`Layout::array`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.array\n+[`Layout::extend`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.extend\n+\n+\n Version 1.43.1 (2020-05-07)\n ===========================\n "}, {"sha": "cf8fe4e082ac3928162140fc6d1fce74ddb6e998", "filename": "config.toml.example", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -312,11 +312,11 @@\n \n # Whether or not debug assertions are enabled for the compiler and standard\n # library.\n-#debug-assertions = false\n+#debug-assertions = debug\n \n # Whether or not debug assertions are enabled for the standard library.\n # Overrides the `debug-assertions` option, if defined.\n-#debug-assertions-std = false\n+#debug-assertions-std = debug-assertions\n \n # Debuginfo level for most of Rust code, corresponds to the `-C debuginfo=N` option of `rustc`.\n # `0` - no debug info"}, {"sha": "c4918d7f2e7146795f0d5fdf5ea485dc2d6386bc", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -48,6 +48,7 @@ toml = \"0.5\"\n lazy_static = \"1.3.0\"\n time = \"0.1\"\n ignore = \"0.4.10\"\n+opener = \"0.4\"\n \n [target.'cfg(windows)'.dependencies.winapi]\n version = \"0.3\""}, {"sha": "ffdd8485181f4665d4f25c54ab66bfda8c161077", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -344,10 +344,12 @@ impl<'a> Builder<'a> {\n                 tool::Rls,\n                 tool::Rustdoc,\n                 tool::Clippy,\n+                tool::CargoClippy,\n                 native::Llvm,\n                 native::Sanitizers,\n                 tool::Rustfmt,\n                 tool::Miri,\n+                tool::CargoMiri,\n                 native::Lld\n             ),\n             Kind::Check | Kind::Clippy | Kind::Fix | Kind::Format => {\n@@ -503,7 +505,7 @@ impl<'a> Builder<'a> {\n             Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n             Subcommand::Clippy { ref paths } => (Kind::Clippy, &paths[..]),\n             Subcommand::Fix { ref paths } => (Kind::Fix, &paths[..]),\n-            Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n+            Subcommand::Doc { ref paths, .. } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n             Subcommand::Dist { ref paths } => (Kind::Dist, &paths[..]),\n@@ -648,6 +650,7 @@ impl<'a> Builder<'a> {\n     pub fn sysroot_libdir_relative(&self, compiler: Compiler) -> &Path {\n         match self.config.libdir_relative() {\n             Some(relative_libdir) if compiler.stage >= 1 => relative_libdir,\n+            _ if compiler.stage == 0 => &self.build.initial_libdir,\n             _ => Path::new(\"lib\"),\n         }\n     }"}, {"sha": "ab16ca3732c1fc93a81d4ed8ac20855052155c5f", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -37,7 +37,9 @@ use crate::{Build, GitRepo};\n // try to infer the archiver path from the C compiler path.\n // In the future this logic should be replaced by calling into the `cc` crate.\n fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n-    if let Some(ar) = env::var_os(\"AR\") {\n+    if let Some(ar) = env::var_os(format!(\"AR_{}\", target.replace(\"-\", \"_\"))) {\n+        Some(PathBuf::from(ar))\n+    } else if let Some(ar) = env::var_os(\"AR\") {\n         Some(PathBuf::from(ar))\n     } else if target.contains(\"msvc\") {\n         None"}, {"sha": "a4115904ac76f16500d5c6fd6eb834a683041ec9", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -13,7 +13,7 @@ use build_helper::output;\n use crate::Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.45.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.46.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "b3999118e3de49c5a1bda72da9be7bfc8f35bb0f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -773,7 +773,8 @@ impl Step for Assemble {\n \n         // Ensure that `libLLVM.so` ends up in the newly build compiler directory,\n         // so that it can be found when the newly built `rustc` is run.\n-        dist::maybe_install_llvm_dylib(builder, target_compiler.host, &sysroot);\n+        dist::maybe_install_llvm_runtime(builder, target_compiler.host, &sysroot);\n+        dist::maybe_install_llvm_target(builder, target_compiler.host, &sysroot);\n \n         // Link the compiler binary itself into place\n         let out_dir = builder.cargo_out(build_compiler, Mode::Rustc, host);"}, {"sha": "5e966d7055bf36d5a079d94d3583f8ed71b6a7ff", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -514,7 +514,7 @@ impl Step for Rustc {\n             // components like the llvm tools and LLD. LLD is included below and\n             // tools/LLDB come later, so let's just throw it in the rustc\n             // component for now.\n-            maybe_install_llvm_dylib(builder, host, image);\n+            maybe_install_llvm_runtime(builder, host, image);\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n@@ -2228,27 +2228,18 @@ impl Step for HashSign {\n     }\n }\n \n-// Maybe add libLLVM.so to the lib-dir. It will only have been built if\n-// LLVM tools are linked dynamically.\n-//\n-// We add this to both the libdir of the rustc binary itself (for it to load at\n-// runtime) and also to the target directory so it can find it at link-time.\n-//\n-// Note: This function does no yet support Windows but we also don't support\n-//       linking LLVM tools dynamically on Windows yet.\n-pub fn maybe_install_llvm_dylib(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+/// Maybe add libLLVM.so to the given destination lib-dir. It will only have\n+/// been built if LLVM tools are linked dynamically.\n+///\n+/// Note: This function does not yet support Windows, but we also don't support\n+///       linking LLVM tools dynamically on Windows yet.\n+fn maybe_install_llvm(builder: &Builder<'_>, target: Interned<String>, dst_libdir: &Path) {\n     let src_libdir = builder.llvm_out(target).join(\"lib\");\n-    let dst_libdir1 = sysroot.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n-    let dst_libdir2 =\n-        sysroot.join(builder.sysroot_libdir_relative(Compiler { stage: 1, host: target }));\n-    t!(fs::create_dir_all(&dst_libdir1));\n-    t!(fs::create_dir_all(&dst_libdir2));\n \n     if target.contains(\"apple-darwin\") {\n         let llvm_dylib_path = src_libdir.join(\"libLLVM.dylib\");\n         if llvm_dylib_path.exists() {\n-            builder.install(&llvm_dylib_path, &dst_libdir1, 0o644);\n-            builder.install(&llvm_dylib_path, &dst_libdir2, 0o644);\n+            builder.install(&llvm_dylib_path, dst_libdir, 0o644);\n         }\n         return;\n     }\n@@ -2262,11 +2253,23 @@ pub fn maybe_install_llvm_dylib(builder: &Builder<'_>, target: Interned<String>,\n             panic!(\"dist: Error calling canonicalize path `{}`: {}\", llvm_dylib_path.display(), e);\n         });\n \n-        builder.install(&llvm_dylib_path, &dst_libdir1, 0o644);\n-        builder.install(&llvm_dylib_path, &dst_libdir2, 0o644);\n+        builder.install(&llvm_dylib_path, dst_libdir, 0o644);\n     }\n }\n \n+/// Maybe add libLLVM.so to the target lib-dir for linking.\n+pub fn maybe_install_llvm_target(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+    let dst_libdir = sysroot.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n+    maybe_install_llvm(builder, target, &dst_libdir);\n+}\n+\n+/// Maybe add libLLVM.so to the runtime lib-dir for rustc itself.\n+pub fn maybe_install_llvm_runtime(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+    let dst_libdir =\n+        sysroot.join(builder.sysroot_libdir_relative(Compiler { stage: 1, host: target }));\n+    maybe_install_llvm(builder, target, &dst_libdir);\n+}\n+\n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n pub struct LlvmTools {\n     pub target: Interned<String>,\n@@ -2314,6 +2317,12 @@ impl Step for LlvmTools {\n             builder.install(&exe, &dst_bindir, 0o755);\n         }\n \n+        // Copy libLLVM.so to the target lib dir as well, so the RPATH like\n+        // `$ORIGIN/../lib` can find it. It may also be used as a dependency\n+        // of `rustc-dev` to support the inherited `-lLLVM` when using the\n+        // compiler libraries.\n+        maybe_install_llvm_target(builder, target, &image);\n+\n         // Prepare the overlay\n         let overlay = tmp.join(\"llvm-tools-overlay\");\n         drop(fs::remove_dir_all(&overlay));"}, {"sha": "5c01c5e852c48caf781a96be2d71a6f0c10e767a", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -70,6 +70,35 @@ book!(\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n );\n \n+fn open(builder: &Builder<'_>, path: impl AsRef<Path>) {\n+    if builder.config.dry_run || !builder.config.cmd.open() {\n+        return;\n+    }\n+\n+    let path = path.as_ref();\n+    builder.info(&format!(\"Opening doc {}\", path.display()));\n+    if let Err(err) = opener::open(path) {\n+        builder.info(&format!(\"{}\\n\", err));\n+    }\n+}\n+\n+// \"src/libstd\" -> [\"src\", \"libstd\"]\n+//\n+// Used for deciding whether a particular step is one requested by the user on\n+// the `x.py doc` command line, which determines whether `--open` will open that\n+// page.\n+fn components_simplified(path: &PathBuf) -> Vec<&str> {\n+    path.iter().map(|component| component.to_str().unwrap_or(\"???\")).collect()\n+}\n+\n+fn is_explicit_request(builder: &Builder<'_>, path: &str) -> bool {\n+    builder\n+        .paths\n+        .iter()\n+        .map(components_simplified)\n+        .any(|requested| requested.iter().copied().eq(path.split(\"/\")))\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct UnstableBook {\n     target: Interned<String>,\n@@ -200,6 +229,12 @@ impl Step for TheBook {\n \n             invoke_rustdoc(builder, compiler, target, path);\n         }\n+\n+        if is_explicit_request(builder, \"src/doc/book\") {\n+            let out = builder.doc_out(target);\n+            let index = out.join(\"book\").join(\"index.html\");\n+            open(builder, &index);\n+        }\n     }\n }\n \n@@ -338,6 +373,13 @@ impl Step for Standalone {\n             }\n             builder.run(&mut cmd);\n         }\n+\n+        // We open doc/index.html as the default if invoked as `x.py doc --open`\n+        // with no particular explicit doc requested (e.g. src/libcore).\n+        if builder.paths.is_empty() || is_explicit_request(builder, \"src/doc\") {\n+            let index = out.join(\"index.html\");\n+            open(builder, &index);\n+        }\n     }\n }\n \n@@ -418,10 +460,25 @@ impl Step for Std {\n \n             builder.run(&mut cargo.into());\n         };\n-        for krate in &[\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"] {\n+        let krates = [\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"];\n+        for krate in &krates {\n             run_cargo_rustdoc_for(krate);\n         }\n         builder.cp_r(&my_out, &out);\n+\n+        // Look for src/libstd, src/libcore etc in the `x.py doc` arguments and\n+        // open the corresponding rendered docs.\n+        for path in builder.paths.iter().map(components_simplified) {\n+            if path.get(0) == Some(&\"src\")\n+                && path.get(1).map_or(false, |dir| dir.starts_with(\"lib\"))\n+            {\n+                let requested_crate = &path[1][3..];\n+                if krates.contains(&requested_crate) {\n+                    let index = out.join(requested_crate).join(\"index.html\");\n+                    open(builder, &index);\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "cfaa43f397095c30a4cf4046f28ca2ac8f2d62d7", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -61,6 +61,7 @@ pub enum Subcommand {\n     },\n     Doc {\n         paths: Vec<PathBuf>,\n+        open: bool,\n     },\n     Test {\n         paths: Vec<PathBuf>,\n@@ -248,6 +249,9 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"bench\" => {\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n             }\n+            \"doc\" => {\n+                opts.optflag(\"\", \"open\", \"open the docs in a browser\");\n+            }\n             \"clean\" => {\n                 opts.optflag(\"\", \"all\", \"clean all build artifacts\");\n             }\n@@ -404,6 +408,7 @@ Arguments:\n         ./x.py doc src/doc/book\n         ./x.py doc src/doc/nomicon\n         ./x.py doc src/doc/book src/libstd\n+        ./x.py doc src/libstd --open\n \n     If no arguments are passed then everything is documented:\n \n@@ -479,7 +484,7 @@ Arguments:\n                 },\n             },\n             \"bench\" => Subcommand::Bench { paths, test_args: matches.opt_strs(\"test-args\") },\n-            \"doc\" => Subcommand::Doc { paths },\n+            \"doc\" => Subcommand::Doc { paths, open: matches.opt_present(\"open\") },\n             \"clean\" => {\n                 if !paths.is_empty() {\n                     println!(\"\\nclean does not take a path argument\\n\");\n@@ -613,6 +618,13 @@ impl Subcommand {\n             _ => None,\n         }\n     }\n+\n+    pub fn open(&self) -> bool {\n+        match *self {\n+            Subcommand::Doc { open, .. } => open,\n+            _ => false,\n+        }\n+    }\n }\n \n fn split(s: &[String]) -> Vec<String> {"}, {"sha": "8d8a036caef88c8c4586a8a0f0e9f7456b1646a5", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -243,6 +243,7 @@ pub struct Build {\n     initial_rustc: PathBuf,\n     initial_cargo: PathBuf,\n     initial_lld: PathBuf,\n+    initial_libdir: PathBuf,\n \n     // Runtime state filled in later on\n     // C/C++ compilers and archiver for all targets\n@@ -344,18 +345,39 @@ impl Build {\n         // we always try to use git for LLVM builds\n         let in_tree_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-project\"));\n \n-        let initial_sysroot = config.initial_rustc.parent().unwrap().parent().unwrap();\n-        let initial_lld = initial_sysroot\n-            .join(\"lib\")\n-            .join(\"rustlib\")\n-            .join(config.build)\n-            .join(\"bin\")\n-            .join(\"rust-lld\");\n+        let initial_target_libdir_str = if config.dry_run {\n+            \"/dummy/lib/path/to/lib/\".to_string()\n+        } else {\n+            output(\n+                Command::new(&config.initial_rustc)\n+                    .arg(\"--target\")\n+                    .arg(config.build)\n+                    .arg(\"--print\")\n+                    .arg(\"target-libdir\"),\n+            )\n+        };\n+        let initial_target_dir = Path::new(&initial_target_libdir_str).parent().unwrap();\n+        let initial_lld = initial_target_dir.join(\"bin\").join(\"rust-lld\");\n+\n+        let initial_sysroot = if config.dry_run {\n+            \"/dummy\".to_string()\n+        } else {\n+            output(Command::new(&config.initial_rustc).arg(\"--print\").arg(\"sysroot\"))\n+        };\n+        let initial_libdir = initial_target_dir\n+            .parent()\n+            .unwrap()\n+            .parent()\n+            .unwrap()\n+            .strip_prefix(initial_sysroot.trim())\n+            .unwrap()\n+            .to_path_buf();\n \n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n             initial_lld,\n+            initial_libdir,\n             local_rebuild: config.local_rebuild,\n             fail_fast: config.cmd.fail_fast(),\n             doc_tests: config.cmd.doc_tests(),\n@@ -941,29 +963,15 @@ impl Build {\n             return s;\n         }\n \n-        let beta = output(\n-            Command::new(\"git\").arg(\"ls-remote\").arg(\"origin\").arg(\"beta\").current_dir(&self.src),\n-        );\n-        let beta = beta.trim().split_whitespace().next().unwrap();\n-        let master = output(\n-            Command::new(\"git\").arg(\"ls-remote\").arg(\"origin\").arg(\"master\").current_dir(&self.src),\n-        );\n-        let master = master.trim().split_whitespace().next().unwrap();\n-\n-        // Figure out where the current beta branch started.\n-        let base = output(\n-            Command::new(\"git\").arg(\"merge-base\").arg(beta).arg(master).current_dir(&self.src),\n-        );\n-        let base = base.trim();\n-\n-        // Next figure out how many merge commits happened since we branched off\n-        // beta. That's our beta number!\n+        // Figure out how many merge commits happened since we branched off master.\n+        // That's our beta number!\n+        // (Note that we use a `..` range, not the `...` symmetric difference.)\n         let count = output(\n             Command::new(\"git\")\n                 .arg(\"rev-list\")\n                 .arg(\"--count\")\n                 .arg(\"--merges\")\n-                .arg(format!(\"{}...HEAD\", base))\n+                .arg(\"refs/remotes/origin/master..HEAD\")\n                 .current_dir(&self.src),\n         );\n         let n = count.trim().parse().unwrap();"}, {"sha": "a99e39ed3542846296ab1b646f2b3de2d6260325", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -360,7 +360,12 @@ impl Step for Miri {\n \n         let miri =\n             builder.ensure(tool::Miri { compiler, target: self.host, extra_features: Vec::new() });\n-        if let Some(miri) = miri {\n+        let cargo_miri = builder.ensure(tool::CargoMiri {\n+            compiler,\n+            target: self.host,\n+            extra_features: Vec::new(),\n+        });\n+        if let (Some(miri), Some(_cargo_miri)) = (miri, cargo_miri) {\n             let mut cargo = builder.cargo(compiler, Mode::ToolRustc, host, \"install\");\n             cargo.arg(\"xargo\");\n             // Configure `cargo install` path. cargo adds a `bin/`.\n@@ -378,14 +383,16 @@ impl Step for Miri {\n                 Mode::ToolRustc,\n                 host,\n                 \"run\",\n-                \"src/tools/miri\",\n+                \"src/tools/miri/cargo-miri\",\n                 SourceType::Submodule,\n                 &[],\n             );\n-            cargo.arg(\"--bin\").arg(\"cargo-miri\").arg(\"--\").arg(\"miri\").arg(\"setup\");\n+            cargo.arg(\"--\").arg(\"miri\").arg(\"setup\");\n \n             // Tell `cargo miri setup` where to find the sources.\n             cargo.env(\"XARGO_RUST_SRC\", builder.src.join(\"src\"));\n+            // Tell it where to find Miri.\n+            cargo.env(\"MIRI\", &miri);\n             // Debug things.\n             cargo.env(\"RUST_BACKTRACE\", \"1\");\n             // Overwrite bootstrap's `rustc` wrapper overwriting our flags.\n@@ -437,7 +444,9 @@ impl Step for Miri {\n             // miri tests need to know about the stage sysroot\n             cargo.env(\"MIRI_SYSROOT\", miri_sysroot);\n             cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            cargo.env(\"MIRI_PATH\", miri);\n+            cargo.env(\"MIRI\", miri);\n+\n+            cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n             builder.add_rustc_lib_path(compiler, &mut cargo);\n \n@@ -514,43 +523,37 @@ impl Step for Clippy {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        let clippy = builder.ensure(tool::Clippy {\n+        let clippy = builder\n+            .ensure(tool::Clippy { compiler, target: self.host, extra_features: Vec::new() })\n+            .expect(\"in-tree tool\");\n+        let mut cargo = tool::prepare_tool_cargo(\n+            builder,\n             compiler,\n-            target: self.host,\n-            extra_features: Vec::new(),\n-        });\n-        if let Some(clippy) = clippy {\n-            let mut cargo = tool::prepare_tool_cargo(\n-                builder,\n-                compiler,\n-                Mode::ToolRustc,\n-                host,\n-                \"test\",\n-                \"src/tools/clippy\",\n-                SourceType::InTree,\n-                &[],\n-            );\n+            Mode::ToolRustc,\n+            host,\n+            \"test\",\n+            \"src/tools/clippy\",\n+            SourceType::InTree,\n+            &[],\n+        );\n \n-            // clippy tests need to know about the stage sysroot\n-            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());\n-            let target_libs = builder\n-                .stage_out(compiler, Mode::ToolRustc)\n-                .join(&self.host)\n-                .join(builder.cargo_dir());\n-            cargo.env(\"HOST_LIBS\", host_libs);\n-            cargo.env(\"TARGET_LIBS\", target_libs);\n-            // clippy tests need to find the driver\n-            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n+        // clippy tests need to know about the stage sysroot\n+        cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+        cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+        cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+        let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());\n+        let target_libs =\n+            builder.stage_out(compiler, Mode::ToolRustc).join(&self.host).join(builder.cargo_dir());\n+        cargo.env(\"HOST_LIBS\", host_libs);\n+        cargo.env(\"TARGET_LIBS\", target_libs);\n+        // clippy tests need to find the driver\n+        cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n \n-            builder.add_rustc_lib_path(compiler, &mut cargo);\n+        cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n-            try_run(builder, &mut cargo.into());\n-        } else {\n-            eprintln!(\"failed to test clippy: could not build\");\n-        }\n+        builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+        try_run(builder, &mut cargo.into());\n     }\n }\n \n@@ -1766,7 +1769,7 @@ impl Step for Crate {\n         } else if builder.remote_tested(target) {\n             cargo.env(\n                 format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                format!(\"{} run\", builder.tool_exe(Tool::RemoteTestClient).display()),\n+                format!(\"{} run 0\", builder.tool_exe(Tool::RemoteTestClient).display()),\n             );\n         }\n "}, {"sha": "6cd9f9029c948ac6996af4f193dc4e18107228aa", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -252,6 +252,10 @@ pub fn prepare_tool_cargo(\n     // own copy\n     cargo.env(\"LZMA_API_STATIC\", \"1\");\n \n+    // CFG_RELEASE is needed by rustfmt (and possibly other tools) which\n+    // import rustc-ap-rustc_attr which requires this to be set for the\n+    // `#[cfg(version(...))]` attribute.\n+    cargo.env(\"CFG_RELEASE\", builder.rust_release());\n     cargo.env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel);\n     cargo.env(\"CFG_VERSION\", builder.rust_version());\n     cargo.env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM);\n@@ -645,12 +649,14 @@ macro_rules! tool_extended {\n     }\n }\n \n+// Note: tools need to be also added to `Builder::get_step_descriptions` in `build.rs`\n+// to make `./x.py build <tool>` work.\n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n     CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {};\n     Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {};\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n-    CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {};\n+    CargoMiri, miri, \"src/tools/miri/cargo-miri\", \"cargo-miri\", {};\n     Rls, rls, \"src/tools/rls\", \"rls\", {\n         builder.ensure(Clippy {\n             compiler: self.compiler,"}, {"sha": "f8fa7b727d179f6fb94c60d5bb9a70eb9e2333d9", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -148,7 +148,7 @@ jobs:\n         INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n       x86_64-msvc-cargo:\n         SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n-        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-lld\n         VCVARS_BAT: vcvars64.bat\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1"}, {"sha": "43f5581f996ea437b6fd32bcb5651407d858dadc", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -28,6 +28,29 @@ RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y --no\n RUN apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys 74DA7924C5513486\n RUN add-apt-repository -y 'deb http://apt.dilos.org/dilos dilos2 main'\n \n+ENV \\\n+    AR_x86_64_fuchsia=x86_64-fuchsia-ar \\\n+    CC_x86_64_fuchsia=x86_64-fuchsia-clang \\\n+    CXX_x86_64_fuchsia=x86_64-fuchsia-clang++ \\\n+    AR_aarch64_fuchsia=aarch64-fuchsia-ar \\\n+    CC_aarch64_fuchsia=aarch64-fuchsia-clang \\\n+    CXX_aarch64_fuchsia=aarch64-fuchsia-clang++ \\\n+    AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n+    CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n+    CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n+    AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n+    CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n+    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++ \\\n+    CC_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-gcc-7 \\\n+    CXX_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-g++-7 \\\n+    AR_x86_64_fortanix_unknown_sgx=ar \\\n+    CC_x86_64_fortanix_unknown_sgx=x86_64-fortanix-unknown-sgx-clang-11 \\\n+    CFLAGS_x86_64_fortanix_unknown_sgx=\"-mlvi-hardening -mllvm -x86-experimental-lvi-inline-asm-hardening\" \\\n+    CXX_x86_64_fortanix_unknown_sgx=x86_64-fortanix-unknown-sgx-clang++-11 \\\n+    CXXFLAGS_x86_64_fortanix_unknown_sgx=\"-mlvi-hardening -mllvm -x86-experimental-lvi-inline-asm-hardening\" \\\n+    CC=gcc-7 \\\n+    CXX=g++-7\n+\n WORKDIR /build\n COPY scripts/musl.sh /build\n RUN env \\\n@@ -46,34 +69,18 @@ COPY dist-various-2/build-solaris-toolchain.sh /tmp/\n RUN /tmp/build-solaris-toolchain.sh x86_64  amd64   solaris-i386\n RUN /tmp/build-solaris-toolchain.sh sparcv9 sparcv9 solaris-sparc\n COPY dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh /tmp/\n+COPY dist-various-2/x86_64-fortanix-unknown-sgx-clang-wrap.sh /usr/bin/x86_64-fortanix-unknown-sgx-clang-11\n+RUN ln -s /usr/bin/x86_64-fortanix-unknown-sgx-clang-11 /usr/bin/x86_64-fortanix-unknown-sgx-clang++-11\n # We pass the commit id of the port of LLVM's libunwind to the build script.\n # Any update to the commit id here, should cause the container image to be re-built from this point on.\n-RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"5125c169b30837208a842f85f7ae44a83533bd0e\"\n+RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"800f95131fe6acd20b96b6f4723ca3c820f3d379\"\n \n COPY dist-various-2/build-wasi-toolchain.sh /tmp/\n RUN /tmp/build-wasi-toolchain.sh\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENV \\\n-    AR_x86_64_fuchsia=x86_64-fuchsia-ar \\\n-    CC_x86_64_fuchsia=x86_64-fuchsia-clang \\\n-    CXX_x86_64_fuchsia=x86_64-fuchsia-clang++ \\\n-    AR_aarch64_fuchsia=aarch64-fuchsia-ar \\\n-    CC_aarch64_fuchsia=aarch64-fuchsia-clang \\\n-    CXX_aarch64_fuchsia=aarch64-fuchsia-clang++ \\\n-    AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n-    CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n-    CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n-    AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n-    CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n-    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++ \\\n-    CC_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-gcc-7 \\\n-    CXX_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-g++-7 \\\n-    CC=gcc-7 \\\n-    CXX=g++-7\n-\n ENV CARGO_TARGET_X86_64_FUCHSIA_AR /usr/local/bin/llvm-ar\n ENV CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS \\\n -C link-arg=--sysroot=/usr/local/x86_64-fuchsia \\"}, {"sha": "4294b1ef93dd825226241d9dbe2236a46c752944", "filename": "src/ci/docker/dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -13,12 +13,15 @@ url=\"https://github.com/fortanix/llvm-project/archive/${1}.tar.gz\"\n repo_name=\"llvm-project\"\n \n install_prereq() {\n+    curl https://apt.llvm.org/llvm-snapshot.gpg.key|apt-key add -\n+    add-apt-repository -y 'deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main'\n     apt-get update\n     apt-get install -y --no-install-recommends \\\n             build-essential \\\n             ca-certificates \\\n             cmake \\\n-            git\n+            git \\\n+            clang-11\n }\n \n build_unwind() {\n@@ -35,7 +38,14 @@ build_unwind() {\n     # Build libunwind\n     mkdir -p build\n     cd build\n+    target_CC=\"CC_${target//-/_}\"\n+    target_CXX=\"CXX_${target//-/_}\"\n+    target_CFLAGS=\"CFLAGS_${target//-/_}\"\n+    target_CXXFLAGS=\"CXXFLAGS_${target//-/_}\"\n     cmake -DCMAKE_BUILD_TYPE=\"RELEASE\" -DRUST_SGX=1 -G \"Unix Makefiles\" \\\n+        -DCMAKE_C_COMPILER=\"${!target_CC}\" -DCMAKE_CXX_COMPILER=\"${!target_CXX}\" \\\n+        -DCMAKE_C_FLAGS=\"${!target_CFLAGS}\" -DCMAKE_CXX_FLAGS=\"${!target_CXXFLAGS}\" \\\n+        -DCMAKE_C_COMPILER_TARGET=$target -DCMAKE_CXX_COMPILER_TARGET=$target \\\n         -DLLVM_ENABLE_WARNINGS=1 -DLIBUNWIND_ENABLE_WERROR=1 -DLIBUNWIND_ENABLE_PEDANTIC=0 \\\n         -DLLVM_PATH=../../llvm/ ../\n     make unwind_static"}, {"sha": "c4ff44c37b1e35aa6e1a2d441d8fcfbaaaa305eb", "filename": "src/ci/docker/dist-various-2/x86_64-fortanix-unknown-sgx-clang-wrap.sh", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fdocker%2Fdist-various-2%2Fx86_64-fortanix-unknown-sgx-clang-wrap.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fdocker%2Fdist-various-2%2Fx86_64-fortanix-unknown-sgx-clang-wrap.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fx86_64-fortanix-unknown-sgx-clang-wrap.sh?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -0,0 +1,14 @@\n+#!/bin/bash\n+\n+args=(\"$@\")\n+\n+for i in \"${!args[@]}\"; do\n+    # x86_64-fortanix-unknown-sgx doesn't have a C sysroot for things like\n+    # stdint.h and the C++ STL. Unlike GCC, clang will not use the host's\n+    # sysroot instead. Force it.\n+    if [ \"${args[$i]}\" = \"--target=x86_64-fortanix-unknown-sgx\" ]; then\n+        args[$i]=\"--target=x86_64-unknown-linux-gnu\"\n+    fi\n+done\n+\n+exec \"${0/x86_64-fortanix-unknown-sgx-clang/clang}\" \"${args[@]}\""}, {"sha": "92fec593a5410544bf1485ff4d3c626e9c77b0f1", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -505,7 +505,7 @@ jobs:\n           - name: x86_64-msvc-cargo\n             env:\n               SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n-              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-lld\n               VCVARS_BAT: vcvars64.bat\n               # FIXME(#59637)\n               NO_DEBUG_ASSERTIONS: 1"}, {"sha": "ff7479c05d04e5d7821b220646862ea03290bbcf", "filename": "src/ci/scripts/install-msys2-packages.sh", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -6,17 +6,6 @@ IFS=$'\\n\\t'\n source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n \n if isWindows; then\n-    # FIXME(mati865): temporary workaround until chocolatey updates their MSYS2\n-    base_url='https://ci-mirrors.rust-lang.org/rustc/msys2-repo/msys/x86_64'\n-    curl ${base_url}/libzstd-1.4.4-2-x86_64.pkg.tar.xz -o libzstd-1.4.4-2-x86_64.pkg.tar.xz\n-    curl ${base_url}/pacman-5.2.1-6-x86_64.pkg.tar.xz -o pacman-5.2.1-6-x86_64.pkg.tar.xz\n-    curl ${base_url}/zstd-1.4.4-2-x86_64.pkg.tar.xz -o zstd-1.4.4-2-x86_64.pkg.tar.xz\n-    pacman -U --noconfirm libzstd-1.4.4-2-x86_64.pkg.tar.xz pacman-5.2.1-6-x86_64.pkg.tar.xz \\\n-        zstd-1.4.4-2-x86_64.pkg.tar.xz\n-    rm libzstd-1.4.4-2-x86_64.pkg.tar.xz pacman-5.2.1-6-x86_64.pkg.tar.xz \\\n-        zstd-1.4.4-2-x86_64.pkg.tar.xz\n-    pacman -Sy\n-\n     pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar \\\n         binutils\n "}, {"sha": "3c3b5007f869780ea3809433c235f36a09e4763f", "filename": "src/ci/scripts/install-msys2.sh", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fscripts%2Finstall-msys2.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fscripts%2Finstall-msys2.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2.sh?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -17,9 +17,8 @@ if isWindows; then\n         msys2.nupkg\n     curl -sSL https://packages.chocolatey.org/chocolatey-core.extension.1.3.5.1.nupkg > \\\n         chocolatey-core.extension.nupkg\n-    # FIXME(mati865): remove `/NoUpdate` once chocolatey updates MSYS2\n     choco install -s . msys2 \\\n-        --params=\"/InstallDir:$(ciCheckoutPath)/msys2 /NoPath /NoUpdate\" -y --no-progress\n+        --params=\"/InstallDir:$(ciCheckoutPath)/msys2 /NoPath\" -y --no-progress\n     rm msys2.nupkg chocolatey-core.extension.nupkg\n     mkdir -p \"$(ciCheckoutPath)/msys2/home/${USERNAME}\"\n     ciCommandAddPath \"$(ciCheckoutPath)/msys2/usr/bin\""}, {"sha": "30cd9dfe71c446de63826bb4472627af45acc9db", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1 +1 @@\n-Subproject commit 6247be15a7f7509559f7981ee2209b9e0cc121df\n+Subproject commit 30cd9dfe71c446de63826bb4472627af45acc9db"}, {"sha": "82bec5877c77cfad530ca11095db4456d757f668", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1 +1 @@\n-Subproject commit 49270740c7a4bff2763e6bc730b191d45b7d5167\n+Subproject commit 82bec5877c77cfad530ca11095db4456d757f668"}, {"sha": "5555a97f04ad7974ac6fb8fb47c267c4274adf4a", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1 +1 @@\n-Subproject commit 366c50a03bed928589771eba8a6f18e0c0c01d23\n+Subproject commit 5555a97f04ad7974ac6fb8fb47c267c4274adf4a"}, {"sha": "bfe1ab96d717d1dda50e499b360f2e2f57e1750a", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1 +1 @@\n-Subproject commit d1517d4e3f29264c5c67bce2658516bb5202c800\n+Subproject commit bfe1ab96d717d1dda50e499b360f2e2f57e1750a"}, {"sha": "5d40ba5c2515caffa7790cda621239dc21ef5a72", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1 +1 @@\n-Subproject commit 892b928b565e35d25b6f9c47faee03b94bc41489\n+Subproject commit 5d40ba5c2515caffa7790cda621239dc21ef5a72"}, {"sha": "7aa82129aa23e7e181efbeb8da03a2a897ef6afc", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1 +1 @@\n-Subproject commit ab072b14393cbd9e8a1d1d75879bf51e27217bbb\n+Subproject commit 7aa82129aa23e7e181efbeb8da03a2a897ef6afc"}, {"sha": "b626923bcb59cfd8ae48872f0bd7cc758a9b8e8a", "filename": "src/doc/rustc-ux-guidelines.md", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,90 +0,0 @@\n-% Rustc UX guidelines\n-\n-Don't forget the user. Whether human or another program, such as an IDE, a\n-good user experience with the compiler goes a long way toward making developers'\n-lives better. We do not want users to be baffled by compiler output or\n-learn arcane patterns to compile their program.\n-\n-## Error, Warning, Help, Note Messages\n-\n-When the compiler detects a problem, it can emit one of the following: an error, a warning,\n-a note, or a help message.\n-\n-An `error` is emitted when the compiler detects a problem that makes it unable\n- to compile the program, either because the program is invalid or the\n- programmer has decided to make a specific `warning` into an error.\n-\n-A `warning` is emitted when the compiler detects something odd about a\n-program. For instance, dead code and unused `Result` values.\n-\n-A `help` message is emitted following an `error` or `warning` to give additional\n-information to the user about how to solve their problem.\n-\n-A `note` is emitted to identify additional circumstances and parts of the code\n-that caused the warning or error. For example, the borrow checker will note any\n-previous conflicting borrows.\n-\n-* Write in plain simple English. If your message, when shown on a \u2013 possibly\n-small \u2013 screen (which hasn't been cleaned for a while), cannot be understood\n-by a normal programmer, who just came out of bed after a night partying, it's\n-too complex.\n-* `Errors` and `Warnings` should not suggest how to fix the problem. A `Help`\n-message should be emitted instead.\n-* `Error`, `Warning`, `Note`, and `Help` messages start with a lowercase\n-letter and do not end with punctuation.\n-* Error messages should be succinct. Users will see these error messages many\n-times, and more verbose descriptions can be viewed with the `--explain` flag.\n-That said, don't make it so terse that it's hard to understand.\n-* The word \"illegal\" is illegal. Prefer \"invalid\" or a more specific word\n-instead.\n-* Errors should document the span of code where they occur \u2013 the `span_..`\n-methods allow to easily do this. Also `note` other spans that have contributed\n-to the error if the span isn't too large.\n-* When emitting a message with span, try to reduce the span to the smallest\n-amount possible that still signifies the issue\n-* Try not to emit multiple error messages for the same error. This may require\n-detecting duplicates.\n-* When the compiler has too little information for a specific error message,\n-lobby for annotations for library code that allow adding more. For example see\n-`#[on_unimplemented]`. Use these annotations when available!\n-* Keep in mind that Rust's learning curve is rather steep, and that the\n-compiler messages are an important learning tool.\n-\n-## Error Explanations\n-\n-Error explanations are long form descriptions of error messages provided with\n-the compiler. They are accessible via the `--explain` flag. Each explanation\n-comes with an example of how to trigger it and advice on how to fix it.\n-\n-Please read [RFC 1567](https://github.com/rust-lang/rfcs/blob/master/text/1567-long-error-codes-explanation-normalization.md)\n-for details on how to format and write long error codes.\n-\n-* All of them are accessible [online](http://doc.rust-lang.org/error-index.html),\n-  which are auto-generated from rustc source code in different places:\n-  [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/error_codes.rs),\n-  [librustc_ast](https://github.com/rust-lang/rust/blob/master/src/librustc_ast/error_codes.rs),\n-  [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/error_codes.rs),\n-  [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/error_codes.rs),\n-  [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/error_codes.rs),\n-  [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/error_codes.rs),\n-  [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/error_codes.rs),\n-  [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/error_codes.rs),\n-  [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/error_codes.rs),\n-  [librustc_plugin_impl](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/error_codes.rs),\n-  [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/error_codes.rs).\n-* Explanations have full markdown support. Use it, especially to highlight\n-code with backticks.\n-* When talking about the compiler, call it `the compiler`, not `Rust` or\n-`rustc`.\n-\n-## Compiler Flags\n-\n-* Flags should be orthogonal to each other. For example, if we'd have a\n-json-emitting variant of multiple actions `foo` and `bar`, an additional\n---json flag is better than adding `--foo-json` and `--bar-json`.\n-* Always give options a long descriptive name, if only for more\n-understandable compiler scripts.\n-* The `--verbose` flag is for adding verbose information to `rustc` output\n-when not compiling a program. For example, using it with the `--version` flag\n-gives information about the hashes of the code.\n-* Experimental flags and options must be guarded behind the `-Z unstable-options` flag."}, {"sha": "48dea213e8cee040f5d8427ac08273dfe9b5862f", "filename": "src/doc/unstable-book/src/compiler-flags/control-flow-guard.md", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -4,30 +4,54 @@ The tracking issue for this feature is: [#68793](https://github.com/rust-lang/ru\n \n ------------------------\n \n-The `-Zcontrol_flow_guard=checks` compiler flag enables the Windows [Control Flow Guard][cfguard-docs] platform security feature. When enabled, the compiler outputs a list of valid indirect call targets, and inserts runtime checks on all indirect jump instructions to ensure that the destination is in the list of valid call targets.\n+The rustc flag `-Z control_flow_guard=checks` enables the Windows [Control Flow Guard](https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard) (CFG) platform security feature.\n \n-[cfguard-docs]: https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard\n+CFG is an exploit mitigation designed to enforce control-flow integrity for software running on supported Windows platforms (Windows 8.1 onwards). Specifically, CFG uses runtime checks to validate the target address of every indirect call/jump before allowing the call to complete. \n \n-For testing purposes, the `-Zcontrol_flow_guard=nochecks` compiler flag can be used to emit only the list of valid call targets, but not the runtime checks.\n+During compilation, the compiler identifies all indirect calls/jumps and adds CFG checks. It also emits metadata containing the relative addresses of all address-taken functions. At runtime, if the binary is run on a CFG-aware operating system, the loader uses the CFG metadata to generate a bitmap of the address space and marks those addresses that contain valid targets. On each indirect call, the inserted check determines whether the target address is marked in this bitmap. If the target is not valid, the process is terminated.\n \n-It is strongly recommended to also enable Control Flow Guard checks in all linked libraries, including the standard library. \n+In terms of interoperability:\n+- Code compiled with CFG enabled can be linked with libraries and object files that are not compiled with CFG. In this case, a CFG-aware linker can identify address-taken functions in the non-CFG libraries.\n+- Libraries compiled with CFG can linked into non-CFG programs. In this case, the CFG runtime checks in the libraries are not used (i.e. the mitigation is completely disabled).\n \n-To enable Control Flow Guard in the standard library, you can use the [cargo `-Zbuild-std` functionality][build-std] to recompile the standard library with the same configuration options as the main program. \n+CFG functionality is completely implemented in the LLVM backend and is supported for X86 (32-bit and 64-bit), ARM, and Aarch64 targets. The rustc flag adds the relevant LLVM module flags to enable the feature. This flag will be ignored for all non-Windows targets.\n+\n+\n+## When to use Control Flow Guard\n+\n+The primary motivation for enabling CFG in Rust is to enhance security when linking against non-Rust code, especially C/C++ code. To achieve full CFG protection, all indirect calls (including any from Rust code) must have the appropriate CFG checks, as added by this flag. CFG can also improve security for Rust code that uses the `unsafe` keyword\n+\n+\n+## Overhead of Control Flow Guard\n+\n+The CFG checks and metadata can potentially increase binary size and runtime overhead. The magnitude of any increase depends on the number and frequency of indirect calls. For example, enabling CFG for the Rust standard library increases binary size by approximately 0.14%. Enabling CFG in the SPEC CPU 2017 Integer Speed benchmark suite (compiled with Clang/LLVM) incurs approximate runtime overheads of between 0% and 8%, with a geometric mean of 2.9%.\n+\n+\n+## Testing Control Flow Guard\n+\n+The rustc flag `-Z control_flow_guard=nochecks` instructs LLVM to emit the list of valid call targets without inserting runtime checks. This flag should only be used for testing purposes as it does not provide security enforcement.\n+\n+\n+## Control Flow Guard in libraries\n+\n+It is strongly recommended to also enable CFG checks for all linked libraries, including the standard library. \n+\n+To enable CFG in the standard library, use the [cargo `-Z build-std` functionality][build-std] to recompile the standard library with the same configuration options as the main program.\n \n [build-std]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std\n \n For example:\n ```cmd\n rustup toolchain install --force nightly\n rustup component add rust-src\n-SET RUSTFLAGS=-Zcontrol_flow_guard=checks\n+SET RUSTFLAGS=-Z control_flow_guard=checks\n cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n ```\n \n ```PowerShell\n rustup toolchain install --force nightly\n rustup component add rust-src\n-$Env:RUSTFLAGS = \"-Zcontrol_flow_guard=checks\"\n+$Env:RUSTFLAGS = \"-Z control_flow_guard=checks\"\n cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n ```\n "}, {"sha": "7973b3e4f2f322ad40bd1bcea87f85742de9e193", "filename": "src/doc/unstable-book/src/compiler-flags/profile.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -12,10 +12,16 @@ For example:\n ```Bash\n cargo new testgcov --bin\n cd testgcov\n-export RUSTFLAGS=\"-Zprofile\"\n+export RUSTFLAGS=\"-Zprofile -Ccodegen-units=1 -Copt-level=0 -Clink-dead-code -Coverflow-checks=off -Zpanic_abort_tests -Cpanic=abort\"\n+export CARGO_INCREMENTAL=0\n cargo build\n cargo run\n ```\n \n Once you've built and run your program, files with the `gcno` (after build) and `gcda` (after execution) extensions will be created.\n You can parse them with [llvm-cov gcov](https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-gcov) or [grcov](https://github.com/mozilla/grcov).\n+\n+Please note that `RUSTFLAGS` by default applies to everything that cargo builds and runs during a build!\n+When the `--target` flag is explicitly passed to cargo, the `RUSTFLAGS` no longer apply to build scripts and procedural macros. \n+For more fine-grained control consider passing a `RUSTC_WRAPPER` program to cargo that only adds the profiling flags to \n+rustc for the specific crates you want to profile."}, {"sha": "68265d8a9e8108562776d0319f30fa2aadb79d14", "filename": "src/doc/unstable-book/src/compiler-flags/report-time.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -22,7 +22,7 @@ Available options:\n \n ```sh\n --report-time [plain|colored]\n-                Show execution time of each test. Awailable values:\n+                Show execution time of each test. Available values:\n                 plain = do not colorize the execution time (default);\n                 colored = colorize output according to the `color`\n                 parameter value;"}, {"sha": "ea560a6d70915a1d51d7bf1cd7e75c29084cceb3", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -468,12 +468,17 @@ Here is the list of currently supported register classes:\n | ARM | `qreg` | `q[0-15]` | `w` |\n | ARM | `qreg_low8` | `q[0-7]` | `t` |\n | ARM | `qreg_low4` | `q[0-3]` | `x` |\n+| NVPTX | `reg16` | None\\* | `h` |\n+| NVPTX | `reg32` | None\\* | `r` |\n+| NVPTX | `reg64` | None\\* | `l` |\n | RISC-V | `reg` | `x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E) | `r` |\n | RISC-V | `freg` | `f[0-31]` | `f` |\n \n > **Note**: On x86 we treat `reg_byte` differently from `reg` because the compiler can allocate `al` and `ah` separately whereas `reg` reserves the whole register.\n >\n > Note #2: On x86-64 the high byte registers (e.g. `ah`) are only available when used as an explicit register. Specifying the `reg_byte` register class for an operand will always allocate a low byte register.\n+>\n+> Note #3: NVPTX doesn't have a fixed register set, so named registers are not supported.\n \n Additional register classes may be added in the future based on demand (e.g. MMX, x87, etc).\n \n@@ -495,6 +500,9 @@ Each register class has constraints on which value types they can be used with.\n | ARM | `sreg` | `vfp2` | `i32`, `f32` |\n | ARM | `dreg` | `vfp2` | `i64`, `f64`, `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2` |\n | ARM | `qreg` | `neon` | `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4` |\n+| NVPTX | `reg16` | None | `i8`, `i16` |\n+| NVPTX | `reg32` | None | `i8`, `i16`, `i32`, `f32` |\n+| NVPTX | `reg64` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n | RISC-V32 | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n | RISC-V64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n | RISC-V | `freg` | `f` | `f32` |\n@@ -610,6 +618,9 @@ The supported modifiers are a subset of LLVM's (and GCC's) [asm template argumen\n | ARM | `dreg` | None | `d0` | `P` |\n | ARM | `qreg` | None | `q0` | `q` |\n | ARM | `qreg` | `e` / `f` | `d0` / `d1` | `e` / `f` |\n+| NVPTX | `reg16` | None | `rs0` | None |\n+| NVPTX | `reg32` | None | `r0` | None |\n+| NVPTX | `reg64` | None | `rd0` | None |\n | RISC-V | `reg` | None | `x1` | None |\n | RISC-V | `freg` | None | `f0` | None |\n "}, {"sha": "5dff73a94dd872c956aa1c231719290d5791271a", "filename": "src/doc/unstable-book/src/library-features/default-free-fn.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -0,0 +1,45 @@\n+# `default_free_fn`\n+\n+The tracking issue for this feature is: [#73014]\n+\n+[#73014]: https://github.com/rust-lang/rust/issues/73014\n+\n+------------------------\n+\n+Adds a free `default()` function to the `std::default` module.  This function\n+just forwards to [`Default::default()`], but may remove repetition of the word\n+\"default\" from the call site.\n+\n+Here is an example:\n+\n+```rust\n+#![feature(default_free_fn)]\n+use std::default::default;\n+\n+#[derive(Default)]\n+struct AppConfig {\n+    foo: FooConfig,\n+    bar: BarConfig,\n+}\n+\n+#[derive(Default)]\n+struct FooConfig {\n+    foo: i32,\n+}\n+\n+#[derive(Default)]\n+struct BarConfig {\n+    bar: f32,\n+    baz: u8,\n+}\n+\n+fn main() {\n+    let options = AppConfig {\n+        foo: default(),\n+        bar: BarConfig {\n+            bar: 10.1,\n+            ..default()\n+        },\n+    };\n+}\n+```"}, {"sha": "22c344323a2edd6354b99a61e77fcb1ec3f14953", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -865,6 +865,25 @@ impl From<Box<str>> for Box<[u8]> {\n     }\n }\n \n+#[stable(feature = \"box_from_array\", since = \"1.45.0\")]\n+impl<T, const N: usize> From<[T; N]> for Box<[T]>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// Converts a `[T; N]` into a `Box<[T]>`\n+    ///\n+    /// This conversion moves the array to newly heap-allocated memory.\n+    ///\n+    /// # Examples\n+    /// ```rust\n+    /// let boxed: Box<[u8]> = Box::from([4, 2]);\n+    /// println!(\"{:?}\", boxed);\n+    /// ```\n+    fn from(array: [T; N]) -> Box<[T]> {\n+        box array\n+    }\n+}\n+\n #[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\n impl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]>\n where\n@@ -1090,6 +1109,14 @@ impl<T: Clone> Clone for Box<[T]> {\n     fn clone(&self) -> Self {\n         self.to_vec().into_boxed_slice()\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        if self.len() == other.len() {\n+            self.clone_from_slice(&other);\n+        } else {\n+            *self = other.clone();\n+        }\n+    }\n }\n \n #[stable(feature = \"box_borrow\", since = \"1.1.0\")]"}, {"sha": "c2fe4691b34c098f689b7d27a42e81ae1829fd0e", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1376,6 +1376,16 @@ impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<I>>::spec_extend(self, iter);\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, item: T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n impl<T: Ord, I: IntoIterator<Item = T>> SpecExtend<I> for BinaryHeap<T> {\n@@ -1406,4 +1416,14 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &item: &'a T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }"}, {"sha": "fa1c09d9ece87141bd839841e27cade56d3570c8", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1901,13 +1901,23 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n             self.insert(k, v);\n         });\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (k, v): (K, V)) {\n+        self.insert(k, v);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n     fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (&k, &v): (&'a K, &'a V)) {\n+        self.insert(k, v);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "525ef38c32fa269f2e31fefbbb3074a85bc9548a", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1152,13 +1152,23 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n             self.insert(elem);\n         });\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: T) {\n+        self.insert(elem);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BTreeSet<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &'a T) {\n+        self.insert(elem);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "85f2505f756aa256ea6d3077e1bbe9299ed443fe", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1748,6 +1748,11 @@ impl<T> Extend<T> for LinkedList<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<I>>::spec_extend(self, iter);\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: T) {\n+        self.push_back(elem);\n+    }\n }\n \n impl<I: IntoIterator> SpecExtend<I> for LinkedList<I::Item> {\n@@ -1767,6 +1772,11 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &'a T) {\n+        self.push_back(elem);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "ae54d3971baac42ee57703b401ced2808ce1fabd", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -2881,13 +2881,33 @@ impl<A> Extend<A> for VecDeque<A> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: A) {\n+        self.push_back(elem);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &T) {\n+        self.push_back(elem);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "9bcfc9457f50eeeddb839efdfeb8e94a02dcf5a1", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -93,6 +93,7 @@\n #![feature(container_error_extra)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n+#![feature(extend_one)]\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n #![feature(fundamental)]"}, {"sha": "805dbfe277584f58c2c699931dc5bff56174af08", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 60, "deletions": 112, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -9,7 +9,7 @@ use core::ptr::{NonNull, Unique};\n use core::slice;\n \n use crate::alloc::{\n-    handle_alloc_error, AllocErr,\n+    handle_alloc_error,\n     AllocInit::{self, *},\n     AllocRef, Global, Layout,\n     ReallocPlacement::{self, *},\n@@ -118,6 +118,30 @@ impl<T> RawVec<T, Global> {\n             RawVec::from_raw_parts(slice.as_mut_ptr(), slice.len())\n         }\n     }\n+\n+    /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n+    ///\n+    /// Note that this will correctly reconstitute any `cap` changes\n+    /// that may have been performed. (See description of type for details.)\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `len` must be greater than or equal to the most recently requested capacity, and\n+    /// * `len` must be less than or equal to `self.capacity()`.\n+    ///\n+    /// Note, that the requested capacity and `self.capacity()` could differ, as\n+    /// an allocator could overallocate and return a greater memory block than requested.\n+    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>]> {\n+        // Sanity-check one half of the safety requirement (we cannot check the other half).\n+        debug_assert!(\n+            len <= self.capacity(),\n+            \"`len` must be smaller than or equal to `self.capacity()`\"\n+        );\n+\n+        let me = ManuallyDrop::new(self);\n+        let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n+        Box::from_raw(slice)\n+    }\n }\n \n impl<T, A: AllocRef> RawVec<T, A> {\n@@ -211,13 +235,13 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         }\n     }\n \n-    /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n-    /// enough capacity, will reallocate enough space plus comfortable slack\n-    /// space to get amortized `O(1)` behavior. Will limit this behavior\n-    /// if it would needlessly cause itself to panic.\n+    /// Ensures that the buffer contains at least enough space to hold `len +\n+    /// additional` elements. If it doesn't already have enough capacity, will\n+    /// reallocate enough space plus comfortable slack space to get amortized\n+    /// `O(1)` behavior. Will limit this behavior if it would needlessly cause\n+    /// itself to panic.\n     ///\n-    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n+    /// If `len` exceeds `self.capacity()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n@@ -263,64 +287,32 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n-    pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n-        match self.try_reserve(used_capacity, needed_extra_capacity) {\n+    pub fn reserve(&mut self, len: usize, additional: usize) {\n+        match self.try_reserve(len, additional) {\n             Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n             Ok(()) => { /* yay */ }\n         }\n     }\n \n     /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve(\n-        &mut self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n-    ) -> Result<(), TryReserveError> {\n-        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow_amortized(used_capacity, needed_extra_capacity, MayMove)\n+    pub fn try_reserve(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {\n+        if self.needs_to_grow(len, additional) {\n+            self.grow_amortized(len, additional)\n         } else {\n             Ok(())\n         }\n     }\n \n-    /// Attempts to ensure that the buffer contains at least enough space to hold\n-    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n-    /// enough capacity, will reallocate in place enough space plus comfortable slack\n-    /// space to get amortized `O(1)` behavior. Will limit this behaviour\n-    /// if it would needlessly cause itself to panic.\n+    /// Ensures that the buffer contains at least enough space to hold `len +\n+    /// additional` elements. If it doesn't already, will reallocate the\n+    /// minimum possible amount of memory necessary. Generally this will be\n+    /// exactly the amount of memory necessary, but in principle the allocator\n+    /// is free to give back more than we asked for.\n     ///\n-    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n-    /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behavior of this function may break.\n-    ///\n-    /// Returns `true` if the reallocation attempt has succeeded.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    pub fn reserve_in_place(&mut self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n-        // This is more readable than putting this in one line:\n-        // `!self.needs_to_grow(...) || self.grow(...).is_ok()`\n-        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow_amortized(used_capacity, needed_extra_capacity, InPlace).is_ok()\n-        } else {\n-            true\n-        }\n-    }\n-\n-    /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already,\n-    /// will reallocate the minimum possible amount of memory necessary.\n-    /// Generally this will be exactly the amount of memory necessary,\n-    /// but in principle the allocator is free to give back more than\n-    /// we asked for.\n-    ///\n-    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n-    /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behavior of this function may break.\n+    /// If `len` exceeds `self.capacity()`, this may fail to actually allocate\n+    /// the requested space. This is not really unsafe, but the unsafe code\n+    /// *you* write that relies on the behavior of this function may break.\n     ///\n     /// # Panics\n     ///\n@@ -331,8 +323,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM.\n-    pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n-        match self.try_reserve_exact(used_capacity, needed_extra_capacity) {\n+    pub fn reserve_exact(&mut self, len: usize, additional: usize) {\n+        match self.try_reserve_exact(len, additional) {\n             Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n             Ok(()) => { /* yay */ }\n@@ -342,14 +334,10 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n     pub fn try_reserve_exact(\n         &mut self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n+        len: usize,\n+        additional: usize,\n     ) -> Result<(), TryReserveError> {\n-        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow_exact(used_capacity, needed_extra_capacity)\n-        } else {\n-            Ok(())\n-        }\n+        if self.needs_to_grow(len, additional) { self.grow_exact(len, additional) } else { Ok(()) }\n     }\n \n     /// Shrinks the allocation down to the specified amount. If the given amount\n@@ -374,8 +362,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n impl<T, A: AllocRef> RawVec<T, A> {\n     /// Returns if the buffer needs to grow to fulfill the needed extra capacity.\n     /// Mainly used to make inlining reserve-calls possible without inlining `grow`.\n-    fn needs_to_grow(&self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n-        needed_extra_capacity > self.capacity().wrapping_sub(used_capacity)\n+    fn needs_to_grow(&self, len: usize, additional: usize) -> bool {\n+        additional > self.capacity().wrapping_sub(len)\n     }\n \n     fn capacity_from_bytes(excess: usize) -> usize {\n@@ -395,14 +383,9 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     // so that all of the code that depends on `T` is within it, while as much\n     // of the code that doesn't depend on `T` as possible is in functions that\n     // are non-generic over `T`.\n-    fn grow_amortized(\n-        &mut self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n-        placement: ReallocPlacement,\n-    ) -> Result<(), TryReserveError> {\n+    fn grow_amortized(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {\n         // This is ensured by the calling contexts.\n-        debug_assert!(needed_extra_capacity > 0);\n+        debug_assert!(additional > 0);\n \n         if mem::size_of::<T>() == 0 {\n             // Since we return a capacity of `usize::MAX` when `elem_size` is\n@@ -411,8 +394,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         }\n \n         // Nothing we can really do about these checks, sadly.\n-        let required_cap =\n-            used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n+        let required_cap = len.checked_add(additional).ok_or(CapacityOverflow)?;\n \n         // This guarantees exponential growth. The doubling cannot overflow\n         // because `cap <= isize::MAX` and the type of `cap` is `usize`.\n@@ -437,30 +419,26 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         let new_layout = Layout::array::<T>(cap);\n \n         // `finish_grow` is non-generic over `T`.\n-        let memory = finish_grow(new_layout, placement, self.current_memory(), &mut self.alloc)?;\n+        let memory = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n         self.set_memory(memory);\n         Ok(())\n     }\n \n     // The constraints on this method are much the same as those on\n     // `grow_amortized`, but this method is usually instantiated less often so\n     // it's less critical.\n-    fn grow_exact(\n-        &mut self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n-    ) -> Result<(), TryReserveError> {\n+    fn grow_exact(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {\n         if mem::size_of::<T>() == 0 {\n             // Since we return a capacity of `usize::MAX` when the type size is\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             return Err(CapacityOverflow);\n         }\n \n-        let cap = used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n+        let cap = len.checked_add(additional).ok_or(CapacityOverflow)?;\n         let new_layout = Layout::array::<T>(cap);\n \n         // `finish_grow` is non-generic over `T`.\n-        let memory = finish_grow(new_layout, MayMove, self.current_memory(), &mut self.alloc)?;\n+        let memory = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n         self.set_memory(memory);\n         Ok(())\n     }\n@@ -494,7 +472,6 @@ impl<T, A: AllocRef> RawVec<T, A> {\n // much smaller than the number of `T` types.)\n fn finish_grow<A>(\n     new_layout: Result<Layout, LayoutErr>,\n-    placement: ReallocPlacement,\n     current_memory: Option<(NonNull<u8>, Layout)>,\n     alloc: &mut A,\n ) -> Result<MemoryBlock, TryReserveError>\n@@ -508,44 +485,15 @@ where\n \n     let memory = if let Some((ptr, old_layout)) = current_memory {\n         debug_assert_eq!(old_layout.align(), new_layout.align());\n-        unsafe { alloc.grow(ptr, old_layout, new_layout.size(), placement, Uninitialized) }\n+        unsafe { alloc.grow(ptr, old_layout, new_layout.size(), MayMove, Uninitialized) }\n     } else {\n-        match placement {\n-            MayMove => alloc.alloc(new_layout, Uninitialized),\n-            InPlace => Err(AllocErr),\n-        }\n+        alloc.alloc(new_layout, Uninitialized)\n     }\n     .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?;\n \n     Ok(memory)\n }\n \n-impl<T> RawVec<T, Global> {\n-    /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n-    ///\n-    /// Note that this will correctly reconstitute any `cap` changes\n-    /// that may have been performed. (See description of type for details.)\n-    ///\n-    /// # Safety\n-    ///\n-    /// * `len` must be greater than or equal to the most recently requested capacity, and\n-    /// * `len` must be less than or equal to `self.capacity()`.\n-    ///\n-    /// Note, that the requested capacity and `self.capacity()` could differ, as\n-    /// an allocator could overallocate and return a greater memory block than requested.\n-    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>]> {\n-        // Sanity-check one half of the safety requirement (we cannot check the other half).\n-        debug_assert!(\n-            len <= self.capacity(),\n-            \"`len` must be smaller than or equal to `self.capacity()`\"\n-        );\n-\n-        let me = ManuallyDrop::new(self);\n-        let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n-        Box::from_raw(slice)\n-    }\n-}\n-\n unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {"}, {"sha": "925bc7d3c024e065b8993107d48839259817d5a5", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -580,8 +580,6 @@ impl<T: ?Sized> Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::Rc;\n     ///\n     /// let x = Rc::new(\"hello\".to_owned());\n@@ -590,7 +588,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert_eq!(x_ptr, Rc::as_ptr(&y));\n     /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n     /// ```\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut RcBox<T> = NonNull::as_ptr(this.ptr);\n         let fake_ptr = ptr as *mut T;\n@@ -1681,8 +1679,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::Rc;\n     /// use std::ptr;\n     ///\n@@ -1700,7 +1696,7 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n         let offset = data_offset_sized::<T>();\n         let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n@@ -1718,8 +1714,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::{Rc, Weak};\n     ///\n     /// let strong = Rc::new(\"hello\".to_owned());\n@@ -1735,7 +1729,7 @@ impl<T> Weak<T> {\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n     /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn into_raw(self) -> *const T {\n         let result = self.as_ptr();\n         mem::forget(self);\n@@ -1762,8 +1756,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::{Rc, Weak};\n     ///\n     /// let strong = Rc::new(\"hello\".to_owned());\n@@ -1788,7 +1780,7 @@ impl<T> Weak<T> {\n     /// [`Weak`]: struct.Weak.html\n     /// [`new`]: struct.Weak.html#method.new\n     /// [`forget`]: ../../std/mem/fn.forget.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {\n             Self::new()\n@@ -2043,11 +2035,7 @@ trait RcBoxPtr<T: ?Sized> {\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n         if strong == 0 || strong == usize::max_value() {\n-            // remove `unsafe` on bootstrap bump\n-            #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n-            unsafe {\n-                abort();\n-            }\n+            abort();\n         }\n         self.inner().strong.set(strong + 1);\n     }\n@@ -2071,11 +2059,7 @@ trait RcBoxPtr<T: ?Sized> {\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n         if weak == 0 || weak == usize::max_value() {\n-            // remove `unsafe` on bootstrap bump\n-            #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n-            unsafe {\n-                abort();\n-            }\n+            abort();\n         }\n         self.inner().weak.set(weak + 1);\n     }"}, {"sha": "0378ff5362a8b9b0af6e2036e6d0ae1d128030f7", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1799,34 +1799,69 @@ impl Extend<char> for String {\n         self.reserve(lower_bound);\n         iterator.for_each(move |c| self.push(c));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, c: char) {\n+        self.push(c);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a> Extend<&'a char> for String {\n     fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &c: &'a char) {\n+        self.push(c);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |s| self.push_str(s));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, s: &'a str) {\n+        self.push_str(s);\n+    }\n }\n \n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl Extend<String> for String {\n     fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |s| self.push_str(&s));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, s: String) {\n+        self.push_str(&s);\n+    }\n }\n \n #[stable(feature = \"herd_cows\", since = \"1.19.0\")]\n impl<'a> Extend<Cow<'a, str>> for String {\n     fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |s| self.push_str(&s));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, s: Cow<'a, str>) {\n+        self.push_str(&s);\n+    }\n }\n \n /// A convenience impl that delegates to the impl for `&str`."}, {"sha": "cd4172d6a2d249eed56a0c461f266d5c4f9cd76b", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -579,8 +579,6 @@ impl<T: ?Sized> Arc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// let x = Arc::new(\"hello\".to_owned());\n@@ -589,7 +587,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert_eq!(x_ptr, Arc::as_ptr(&y));\n     /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n     /// ```\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut ArcInner<T> = NonNull::as_ptr(this.ptr);\n         let fake_ptr = ptr as *mut T;\n@@ -867,12 +865,10 @@ impl<T: ?Sized> Arc<T> {\n     unsafe fn drop_slow(&mut self) {\n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n-        ptr::drop_in_place(&mut self.ptr.as_mut().data);\n+        ptr::drop_in_place(Self::get_mut_unchecked(self));\n \n-        if self.inner().weak.fetch_sub(1, Release) == 1 {\n-            acquire!(self.inner().weak);\n-            Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n-        }\n+        // Drop the weak ref collectively held by all strong references\n+        drop(Weak { ptr: self.ptr });\n     }\n \n     #[inline]\n@@ -1097,11 +1093,7 @@ impl<T: ?Sized> Clone for Arc<T> {\n         // We abort because such a program is incredibly degenerate, and we\n         // don't care to support it.\n         if old_size > MAX_REFCOUNT {\n-            // remove `unsafe` on bootstrap bump\n-            #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n-            unsafe {\n-                abort();\n-            }\n+            abort();\n         }\n \n         Self::from_inner(self.ptr)\n@@ -1204,7 +1196,7 @@ impl<T: Clone> Arc<T> {\n \n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n-        unsafe { &mut this.ptr.as_mut().data }\n+        unsafe { Self::get_mut_unchecked(this) }\n     }\n }\n \n@@ -1280,7 +1272,9 @@ impl<T: ?Sized> Arc<T> {\n     #[inline]\n     #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n     pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n-        &mut this.ptr.as_mut().data\n+        // We are careful to *not* create a reference covering the \"count\" fields, as\n+        // this would alias with concurrent access to the reference counts (e.g. by `Weak`).\n+        &mut (*this.ptr.as_ptr()).data\n     }\n \n     /// Determine whether this is the unique reference (including weak refs) to\n@@ -1449,8 +1443,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::Arc;\n     /// use std::ptr;\n     ///\n@@ -1468,7 +1460,7 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n         let offset = data_offset_sized::<T>();\n         let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n@@ -1486,8 +1478,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::{Arc, Weak};\n     ///\n     /// let strong = Arc::new(\"hello\".to_owned());\n@@ -1503,7 +1493,7 @@ impl<T> Weak<T> {\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n     /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn into_raw(self) -> *const T {\n         let result = self.as_ptr();\n         mem::forget(self);\n@@ -1531,8 +1521,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::{Arc, Weak};\n     ///\n     /// let strong = Arc::new(\"hello\".to_owned());\n@@ -1557,7 +1545,7 @@ impl<T> Weak<T> {\n     /// [`Weak`]: struct.Weak.html\n     /// [`Arc`]: struct.Arc.html\n     /// [`forget`]: ../../std/mem/fn.forget.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {\n             Self::new()\n@@ -1571,6 +1559,13 @@ impl<T> Weak<T> {\n     }\n }\n \n+/// Helper type to allow accessing the reference counts without\n+/// making any assertions about the data field.\n+struct WeakInner<'a> {\n+    weak: &'a atomic::AtomicUsize,\n+    strong: &'a atomic::AtomicUsize,\n+}\n+\n impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Arc`], delaying\n     /// dropping of the inner value if successful.\n@@ -1617,11 +1612,7 @@ impl<T: ?Sized> Weak<T> {\n \n             // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n             if n > MAX_REFCOUNT {\n-                // remove `unsafe` on bootstrap bump\n-                #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n-                unsafe {\n-                    abort();\n-                }\n+                abort();\n             }\n \n             // Relaxed is valid for the same reason it is on Arc's Clone impl\n@@ -1678,8 +1669,18 @@ impl<T: ?Sized> Weak<T> {\n     /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,\n     /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n-    fn inner(&self) -> Option<&ArcInner<T>> {\n-        if is_dangling(self.ptr) { None } else { Some(unsafe { self.ptr.as_ref() }) }\n+    fn inner(&self) -> Option<WeakInner<'_>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            // We are careful to *not* create a reference covering the \"data\" field, as\n+            // the field may be mutated concurrently (for example, if the last `Arc`\n+            // is dropped, the data field will be dropped in-place).\n+            Some(unsafe {\n+                let ptr = self.ptr.as_ptr();\n+                WeakInner { strong: &(*ptr).strong, weak: &(*ptr).weak }\n+            })\n+        }\n     }\n \n     /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n@@ -1758,10 +1759,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n \n         // See comments in Arc::clone() for why we do this (for mem::forget).\n         if old_size > MAX_REFCOUNT {\n-            #[cfg_attr(not(bootstrap), allow(unused_unsafe))] // remove `unsafe` on bootstrap bump\n-            unsafe {\n-                abort();\n-            }\n+            abort();\n         }\n \n         Weak { ptr: self.ptr }"}, {"sha": "5377485da8f3b7def467ee749689494cd6399b72", "filename": "src/liballoc/tests/boxed.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fboxed.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -16,3 +16,36 @@ fn unitialized_zero_size_box() {\n         NonNull::<MaybeUninit<String>>::dangling().as_ptr(),\n     );\n }\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+struct Dummy {\n+    _data: u8,\n+}\n+\n+#[test]\n+fn box_clone_and_clone_from_equivalence() {\n+    for size in (0..8).map(|i| 2usize.pow(i)) {\n+        let control = vec![Dummy { _data: 42 }; size].into_boxed_slice();\n+        let clone = control.clone();\n+        let mut copy = vec![Dummy { _data: 84 }; size].into_boxed_slice();\n+        copy.clone_from(&control);\n+        assert_eq!(control, clone);\n+        assert_eq!(control, copy);\n+    }\n+}\n+\n+/// This test might give a false positive in case the box realocates, but the alocator keeps the\n+/// original pointer.\n+///\n+/// On the other hand it won't give a false negative, if it fails than the memory was definitly not\n+/// reused\n+#[test]\n+fn box_clone_from_ptr_stability() {\n+    for size in (0..8).map(|i| 2usize.pow(i)) {\n+        let control = vec![Dummy { _data: 42 }; size].into_boxed_slice();\n+        let mut copy = vec![Dummy { _data: 84 }; size].into_boxed_slice();\n+        let copy_raw = copy.as_ptr() as usize;\n+        copy.clone_from(&control);\n+        assert_eq!(copy.as_ptr() as usize, copy_raw);\n+    }\n+}"}, {"sha": "b73fd95ab6a86d8ac6aff8383364210ed3d3ed97", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -16,7 +16,7 @@ impl Drop for DropCounter<'_> {\n \n #[test]\n fn test_small_vec_struct() {\n-    assert!(size_of::<Vec<u8>>() == size_of::<usize>() * 3);\n+    assert_eq!(size_of::<Vec<u8>>(), size_of::<usize>() * 3);\n }\n \n #[test]"}, {"sha": "2226737757bc5bf91c2d1ef205ce9b03ecdd86ce", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 53, "deletions": 21, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -343,14 +343,19 @@ impl<T> Vec<T> {\n     ///\n     /// // The vector contains no items, even though it has capacity for more\n     /// assert_eq!(vec.len(), 0);\n+    /// assert_eq!(vec.capacity(), 10);\n     ///\n     /// // These are all done without reallocating...\n     /// for i in 0..10 {\n     ///     vec.push(i);\n     /// }\n+    /// assert_eq!(vec.len(), 10);\n+    /// assert_eq!(vec.capacity(), 10);\n     ///\n     /// // ...but this may make the vector reallocate\n     /// vec.push(11);\n+    /// assert_eq!(vec.len(), 11);\n+    /// assert!(vec.capacity() >= 11);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -979,7 +984,7 @@ impl<T> Vec<T> {\n             // bounds check above succeeds there must be a last element (which\n             // can be self[index] itself).\n             let last = ptr::read(self.as_ptr().add(len - 1));\n-            let hole: *mut T = self.as_mut_ptr().add(index);\n+            let hole = self.as_mut_ptr().add(index);\n             self.set_len(len - 1);\n             ptr::replace(hole, last)\n         }\n@@ -1900,6 +1905,22 @@ unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ops::Deref for Vec<T> {\n+    type Target = [T];\n+\n+    fn deref(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ops::DerefMut for Vec<T> {\n+    fn deref_mut(&mut self) -> &mut [T] {\n+        unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for Vec<T> {\n     #[cfg(not(test))]\n@@ -1955,22 +1976,6 @@ impl<T, I: SliceIndex<[T]>> IndexMut<I> for Vec<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Deref for Vec<T> {\n-    type Target = [T];\n-\n-    fn deref(&self) -> &[T] {\n-        unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::DerefMut for Vec<T> {\n-    fn deref_mut(&mut self) -> &mut [T] {\n-        unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n@@ -2045,6 +2050,16 @@ impl<T> Extend<T> for Vec<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<T, I::IntoIter>>::spec_extend(self, iter.into_iter())\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, item: T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n // Specialization trait used for Vec::from_iter and Vec::extend\n@@ -2316,6 +2331,16 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.spec_extend(iter.into_iter())\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &item: &'a T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n macro_rules! __impl_slice_eq1 {\n@@ -2603,6 +2628,13 @@ impl<T> IntoIter<T> {\n     }\n }\n \n+#[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]\n+impl<T> AsRef<[T]> for IntoIter<T> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Send> Send for IntoIter<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2945,12 +2977,12 @@ impl<T> Drain<'_, T> {\n     }\n \n     /// Makes room for inserting more elements before the tail.\n-    unsafe fn move_tail(&mut self, extra_capacity: usize) {\n+    unsafe fn move_tail(&mut self, additional: usize) {\n         let vec = self.vec.as_mut();\n-        let used_capacity = self.tail_start + self.tail_len;\n-        vec.buf.reserve(used_capacity, extra_capacity);\n+        let len = self.tail_start + self.tail_len;\n+        vec.buf.reserve(len, additional);\n \n-        let new_tail_start = self.tail_start + extra_capacity;\n+        let new_tail_start = self.tail_start + additional;\n         let src = vec.as_ptr().add(self.tail_start);\n         let dst = vec.as_mut_ptr().add(new_tail_start);\n         ptr::copy(src, dst, self.tail_len);"}, {"sha": "c4c1d2824b0980626c45ab850ebd6de88120a7c3", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -849,11 +849,11 @@ impl<T: ?Sized> RefCell<T> {\n     /// ```\n     /// use std::cell::RefCell;\n     ///\n-    /// let c = RefCell::new(5);\n+    /// let c = RefCell::new(\"hello\".to_owned());\n     ///\n-    /// *c.borrow_mut() = 7;\n+    /// *c.borrow_mut() = \"bonjour\".to_owned();\n     ///\n-    /// assert_eq!(*c.borrow(), 7);\n+    /// assert_eq!(&*c.borrow(), \"bonjour\");\n     /// ```\n     ///\n     /// An example of panic:"}, {"sha": "87c56c4b0a1059b50bf5cf22577536196500e4b5", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -99,7 +99,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n #[inline]\n #[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n pub unsafe fn from_u32_unchecked(i: u32) -> char {\n-    transmute(i)\n+    if cfg!(debug_assertions) { char::from_u32(i).unwrap() } else { transmute(i) }\n }\n \n #[stable(feature = \"char_convert\", since = \"1.13.0\")]\n@@ -218,7 +218,7 @@ impl TryFrom<u32> for char {\n             Err(CharTryFromError(()))\n         } else {\n             // SAFETY: checked that it's a legal unicode value\n-            Ok(unsafe { from_u32_unchecked(i) })\n+            Ok(unsafe { transmute(i) })\n         }\n     }\n }"}, {"sha": "bf09b28ff693e1430aea78d31360c825b25901c4", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 101, "deletions": 62, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -593,16 +593,7 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn len_utf8(self) -> usize {\n-        let code = self as u32;\n-        if code < MAX_ONE_B {\n-            1\n-        } else if code < MAX_TWO_B {\n-            2\n-        } else if code < MAX_THREE_B {\n-            3\n-        } else {\n-            4\n-        }\n+        len_utf8(self as u32)\n     }\n \n     /// Returns the number of 16-bit code units this `char` would need if\n@@ -670,36 +661,8 @@ impl char {\n     #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n     #[inline]\n     pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n-        let code = self as u32;\n-        let len = self.len_utf8();\n-        match (len, &mut dst[..]) {\n-            (1, [a, ..]) => {\n-                *a = code as u8;\n-            }\n-            (2, [a, b, ..]) => {\n-                *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n-                *b = (code & 0x3F) as u8 | TAG_CONT;\n-            }\n-            (3, [a, b, c, ..]) => {\n-                *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-                *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n-                *c = (code & 0x3F) as u8 | TAG_CONT;\n-            }\n-            (4, [a, b, c, d, ..]) => {\n-                *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n-                *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-                *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n-                *d = (code & 0x3F) as u8 | TAG_CONT;\n-            }\n-            _ => panic!(\n-                \"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n-                len,\n-                code,\n-                dst.len(),\n-            ),\n-        };\n-        // SAFETY: We just wrote UTF-8 content in, so converting to str is fine.\n-        unsafe { from_utf8_unchecked_mut(&mut dst[..len]) }\n+        // SAFETY: `char` is not a surrogate, so this is valid UTF-8.\n+        unsafe { from_utf8_unchecked_mut(encode_utf8_raw(self as u32, dst)) }\n     }\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n@@ -739,28 +702,7 @@ impl char {\n     #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n     #[inline]\n     pub fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n-        let mut code = self as u32;\n-        // SAFETY: each arm checks whether there are enough bits to write into\n-        unsafe {\n-            if (code & 0xFFFF) == code && !dst.is_empty() {\n-                // The BMP falls through (assuming non-surrogate, as it should)\n-                *dst.get_unchecked_mut(0) = code as u16;\n-                slice::from_raw_parts_mut(dst.as_mut_ptr(), 1)\n-            } else if dst.len() >= 2 {\n-                // Supplementary planes break into surrogates.\n-                code -= 0x1_0000;\n-                *dst.get_unchecked_mut(0) = 0xD800 | ((code >> 10) as u16);\n-                *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n-                slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n-            } else {\n-                panic!(\n-                    \"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n-                    from_u32_unchecked(code).len_utf16(),\n-                    code,\n-                    dst.len(),\n-                )\n-            }\n-        }\n+        encode_utf16_raw(self as u32, dst)\n     }\n \n     /// Returns `true` if this `char` has the `Alphabetic` property.\n@@ -1673,3 +1615,100 @@ impl char {\n         }\n     }\n }\n+\n+#[inline]\n+fn len_utf8(code: u32) -> usize {\n+    if code < MAX_ONE_B {\n+        1\n+    } else if code < MAX_TWO_B {\n+        2\n+    } else if code < MAX_THREE_B {\n+        3\n+    } else {\n+        4\n+    }\n+}\n+\n+/// Encodes a raw u32 value as UTF-8 into the provided byte buffer,\n+/// and then returns the subslice of the buffer that contains the encoded character.\n+///\n+/// Unlike `char::encode_utf8`, this method also handles codepoints in the surrogate range.\n+/// (Creating a `char` in the surrogate range is UB.)\n+/// The result is valid [generalized UTF-8] but not valid UTF-8.\n+///\n+/// [generalized UTF-8]: https://simonsapin.github.io/wtf-8/#generalized-utf8\n+///\n+/// # Panics\n+///\n+/// Panics if the buffer is not large enough.\n+/// A buffer of length four is large enough to encode any `char`.\n+#[unstable(feature = \"char_internals\", reason = \"exposed only for libstd\", issue = \"none\")]\n+#[doc(hidden)]\n+#[inline]\n+pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> &mut [u8] {\n+    let len = len_utf8(code);\n+    match (len, &mut dst[..]) {\n+        (1, [a, ..]) => {\n+            *a = code as u8;\n+        }\n+        (2, [a, b, ..]) => {\n+            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+            *b = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        (3, [a, b, c, ..]) => {\n+            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            *c = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        (4, [a, b, c, d, ..]) => {\n+            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            *d = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        _ => panic!(\n+            \"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n+            len,\n+            code,\n+            dst.len(),\n+        ),\n+    };\n+    &mut dst[..len]\n+}\n+\n+/// Encodes a raw u32 value as UTF-16 into the provided `u16` buffer,\n+/// and then returns the subslice of the buffer that contains the encoded character.\n+///\n+/// Unlike `char::encode_utf16`, this method also handles codepoints in the surrogate range.\n+/// (Creating a `char` in the surrogate range is UB.)\n+///\n+/// # Panics\n+///\n+/// Panics if the buffer is not large enough.\n+/// A buffer of length 2 is large enough to encode any `char`.\n+#[unstable(feature = \"char_internals\", reason = \"exposed only for libstd\", issue = \"none\")]\n+#[doc(hidden)]\n+#[inline]\n+pub fn encode_utf16_raw(mut code: u32, dst: &mut [u16]) -> &mut [u16] {\n+    // SAFETY: each arm checks whether there are enough bits to write into\n+    unsafe {\n+        if (code & 0xFFFF) == code && !dst.is_empty() {\n+            // The BMP falls through\n+            *dst.get_unchecked_mut(0) = code as u16;\n+            slice::from_raw_parts_mut(dst.as_mut_ptr(), 1)\n+        } else if dst.len() >= 2 {\n+            // Supplementary planes break into surrogates.\n+            code -= 0x1_0000;\n+            *dst.get_unchecked_mut(0) = 0xD800 | ((code >> 10) as u16);\n+            *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n+            slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n+        } else {\n+            panic!(\n+                \"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n+                from_u32_unchecked(code).len_utf16(),\n+                code,\n+                dst.len(),\n+            )\n+        }\n+    }\n+}"}, {"sha": "1b4e906e4e47523615759379f91b63c7636db132", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -37,6 +37,12 @@ pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n #[stable(feature = \"unicode_version\", since = \"1.45.0\")]\n pub use crate::unicode::UNICODE_VERSION;\n \n+// perma-unstable re-exports\n+#[unstable(feature = \"char_internals\", reason = \"exposed only for libstd\", issue = \"none\")]\n+pub use self::methods::encode_utf16_raw;\n+#[unstable(feature = \"char_internals\", reason = \"exposed only for libstd\", issue = \"none\")]\n+pub use self::methods::encode_utf8_raw;\n+\n use crate::fmt::{self, Write};\n use crate::iter::FusedIterator;\n "}, {"sha": "9a8d65cd4e06b93e37e075f100a589b18e97eba5", "filename": "src/libcore/default.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -115,6 +115,50 @@ pub trait Default: Sized {\n     fn default() -> Self;\n }\n \n+/// Return the default value of a type according to the `Default` trait.\n+///\n+/// The type to return is inferred from context; this is equivalent to\n+/// `Default::default()` but shorter to type.\n+///\n+/// For example:\n+/// ```\n+/// #![feature(default_free_fn)]\n+///\n+/// use std::default::default;\n+///\n+/// #[derive(Default)]\n+/// struct AppConfig {\n+///     foo: FooConfig,\n+///     bar: BarConfig,\n+/// }\n+///\n+/// #[derive(Default)]\n+/// struct FooConfig {\n+///     foo: i32,\n+/// }\n+///\n+/// #[derive(Default)]\n+/// struct BarConfig {\n+///     bar: f32,\n+///     baz: u8,\n+/// }\n+///\n+/// fn main() {\n+///     let options = AppConfig {\n+///         foo: default(),\n+///         bar: BarConfig {\n+///             bar: 10.1,\n+///             ..default()\n+///         },\n+///     };\n+/// }\n+/// ```\n+#[unstable(feature = \"default_free_fn\", issue = \"73014\")]\n+#[inline]\n+pub fn default<T: Default>() -> T {\n+    Default::default()\n+}\n+\n /// Derive macro generating an impl of the trait `Default`.\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]"}, {"sha": "9c5dbb5e6f3567fd567be94c44d00038e638d58b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -441,6 +441,13 @@ impl Display for Arguments<'_> {\n /// `enum`s, it will use the name of the variant and, if applicable, `(`, then the\n /// `Debug` values of the fields, then `)`.\n ///\n+/// # Stability\n+///\n+/// Derived `Debug` formats are not stable, and so may change with future Rust\n+/// versions. Additionally, `Debug` implementations of types provided by the\n+/// standard library (`libstd`, `libcore`, `liballoc`, etc.) are not stable, and\n+/// may also change with future Rust versions.\n+///\n /// # Examples\n ///\n /// Deriving an implementation:\n@@ -1611,7 +1618,8 @@ impl<'a> Formatter<'a> {\n         self.width\n     }\n \n-    /// Optionally specified precision for numeric types.\n+    /// Optionally specified precision for numeric types. Alternatively, the\n+    /// maximum width for string types.\n     ///\n     /// # Examples\n     ///"}, {"sha": "4020c254446e3eb2c10dcf878810467df5e753c3", "filename": "src/libcore/future/into_future.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ffuture%2Finto_future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ffuture%2Finto_future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Finto_future.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -0,0 +1,27 @@\n+use crate::future::Future;\n+\n+/// Conversion into a `Future`.\n+#[unstable(feature = \"into_future\", issue = \"67644\")]\n+pub trait IntoFuture {\n+    /// The output that the future will produce on completion.\n+    #[unstable(feature = \"into_future\", issue = \"67644\")]\n+    type Output;\n+\n+    /// Which kind of future are we turning this into?\n+    #[unstable(feature = \"into_future\", issue = \"67644\")]\n+    type Future: Future<Output = Self::Output>;\n+\n+    /// Creates a future from a value.\n+    #[unstable(feature = \"into_future\", issue = \"67644\")]\n+    fn into_future(self) -> Self::Future;\n+}\n+\n+#[unstable(feature = \"into_future\", issue = \"67644\")]\n+impl<F: Future> IntoFuture for F {\n+    type Output = F::Output;\n+    type Future = F;\n+\n+    fn into_future(self) -> Self::Future {\n+        self\n+    }\n+}"}, {"sha": "6f6009b47e67246f73740900c81f011a8609d9b1", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,12 +10,16 @@ use crate::{\n };\n \n mod future;\n+mod into_future;\n mod pending;\n mod ready;\n \n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::future::Future;\n \n+#[unstable(feature = \"into_future\", issue = \"67644\")]\n+pub use into_future::IntoFuture;\n+\n #[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n pub use pending::{pending, Pending};\n #[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]"}, {"sha": "85076a573b5282b5f5e5c021fd825cf40414ef71", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -54,7 +54,6 @@\n )]\n #![allow(missing_docs)]\n \n-#[cfg(not(bootstrap))]\n use crate::marker::DiscriminantKind;\n use crate::mem;\n \n@@ -1314,6 +1313,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`std::pointer::offset`](../../std/primitive.pointer.html#method.offset).\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Calculates the offset from a pointer, potentially wrapping.\n@@ -1331,6 +1331,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`std::pointer::wrapping_offset`](../../std/primitive.pointer.html#method.wrapping_offset).\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n@@ -1914,11 +1915,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`std::mem::discriminant`](../../std/mem/fn.discriminant.html)\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n-    #[cfg(not(bootstrap))]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n-    #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n-    #[cfg(bootstrap)]\n-    pub fn discriminant_value<T>(v: &T) -> u64;\n \n     /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`\n     /// with the data pointer `data`."}, {"sha": "00529f0e2d54f4dcc0ac8ad3ea1c30bfab8efe42", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1619,6 +1619,69 @@ impl<I: Iterator> Peekable<I> {\n         let iter = &mut self.iter;\n         self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n     }\n+\n+    /// Consume the next value of this iterator if a condition is true.\n+    ///\n+    /// If `func` returns `true` for the next value of this iterator, consume and return it.\n+    /// Otherwise, return `None`.\n+    ///\n+    /// # Examples\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), None);\n+    /// // `next_if` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    ///\n+    /// Consume any number less than 10.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (1..20).peekable();\n+    /// // Consume all numbers less than 10\n+    /// while iter.next_if(|&x| x < 10).is_some() {}\n+    /// // The next value returned will be 10\n+    /// assert_eq!(iter.next(), Some(10));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if(&mut self, func: impl FnOnce(&I::Item) -> bool) -> Option<I::Item> {\n+        match self.next() {\n+            Some(matched) if func(&matched) => Some(matched),\n+            other => {\n+                // Since we called `self.next()`, we consumed `self.peeked`.\n+                assert!(self.peeked.is_none());\n+                self.peeked = Some(other);\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Consume the next item if it is equal to `expected`.\n+    ///\n+    /// # Example\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if_eq(&0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if_eq(&0), None);\n+    /// // `next_if_eq` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if_eq<R>(&mut self, expected: &R) -> Option<I::Item>\n+    where\n+        R: ?Sized,\n+        I::Item: PartialEq<R>,\n+    {\n+        self.next_if(|next| next == expected)\n+    }\n }\n \n /// An iterator that rejects elements while `predicate` returns `true`."}, {"sha": "bd7e6cfa5a750116009b7b407ebfeef82d9f1ecc", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 74, "deletions": 10, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,3 +1,4 @@\n+use crate::char;\n use crate::convert::TryFrom;\n use crate::mem;\n use crate::ops::{self, Add, Sub, Try};\n@@ -400,6 +401,73 @@ step_integer_impls! {\n     wider than usize: [u32 i32], [u64 i64], [u128 i128];\n }\n \n+#[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+unsafe impl Step for char {\n+    #[inline]\n+    fn steps_between(&start: &char, &end: &char) -> Option<usize> {\n+        let start = start as u32;\n+        let end = end as u32;\n+        if start <= end {\n+            let count = end - start;\n+            if start < 0xD800 && 0xE000 <= end {\n+                usize::try_from(count - 0x800).ok()\n+            } else {\n+                usize::try_from(count).ok()\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn forward_checked(start: char, count: usize) -> Option<char> {\n+        let start = start as u32;\n+        let mut res = Step::forward_checked(start, count)?;\n+        if start < 0xD800 && 0xD800 <= res {\n+            res = Step::forward_checked(res, 0x800)?;\n+        }\n+        if res <= char::MAX as u32 {\n+            // SAFETY: res is a valid unicode scalar\n+            // (below 0x110000 and not in 0xD800..0xE000)\n+            Some(unsafe { char::from_u32_unchecked(res) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn backward_checked(start: char, count: usize) -> Option<char> {\n+        let start = start as u32;\n+        let mut res = Step::backward_checked(start, count)?;\n+        if start >= 0xE000 && 0xE000 > res {\n+            res = Step::backward_checked(res, 0x800)?;\n+        }\n+        // SAFETY: res is a valid unicode scalar\n+        // (below 0x110000 and not in 0xD800..0xE000)\n+        Some(unsafe { char::from_u32_unchecked(res) })\n+    }\n+\n+    #[inline]\n+    unsafe fn forward_unchecked(start: char, count: usize) -> char {\n+        let start = start as u32;\n+        let mut res = Step::forward_unchecked(start, count);\n+        if start < 0xD800 && 0xD800 <= res {\n+            res = Step::forward_unchecked(res, 0x800);\n+        }\n+        char::from_u32_unchecked(res)\n+    }\n+\n+    #[inline]\n+    unsafe fn backward_unchecked(start: char, count: usize) -> char {\n+        let start = start as u32;\n+        let mut res = Step::backward_unchecked(start, count);\n+        if start >= 0xE000 && 0xE000 > res {\n+            res = Step::backward_unchecked(res, 0x800);\n+        }\n+        char::from_u32_unchecked(res)\n+    }\n+}\n+\n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -551,15 +619,7 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        // If we would jump over the maximum value, panic immediately.\n-        // This is consistent with behavior before the Step redesign,\n-        // even though it's inconsistent with n `next` calls.\n-        // To get consistent behavior, change it to use `forward` instead.\n-        // This change should go through FCP separately to the redesign, so is for now left as a\n-        // FIXME: make this consistent\n-        let plus_n =\n-            Step::forward_checked(self.start.clone(), n).expect(\"overflow in RangeFrom::nth\");\n-        // The final step should always be debug-checked.\n+        let plus_n = Step::forward(self.start.clone(), n);\n         self.start = Step::forward(plus_n.clone(), 1);\n         Some(plus_n)\n     }\n@@ -582,7 +642,11 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         }\n         let is_iterating = self.start < self.end;\n         Some(if is_iterating {\n-            let n = Step::forward(self.start.clone(), 1);\n+            // SAFETY: just checked precondition\n+            // We use the unchecked version here, because\n+            // otherwise `for _ in '\\0'..=char::MAX`\n+            // does not successfully remove panicking code.\n+            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n             mem::replace(&mut self.start, n)\n         } else {\n             self.exhausted = true;"}, {"sha": "9d20022b6ed6db75bd787773d4b4cc7e6ba7e772", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -322,7 +322,7 @@ impl<I: Iterator> IntoIterator for I {\n pub trait Extend<A> {\n     /// Extends a collection with the contents of an iterator.\n     ///\n-    /// As this is the only method for this trait, the [trait-level] docs\n+    /// As this is the only required method for this trait, the [trait-level] docs\n     /// contain more details.\n     ///\n     /// [trait-level]: trait.Extend.html\n@@ -341,11 +341,26 @@ pub trait Extend<A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T);\n+\n+    /// Extends a collection with exactly one element.\n+    #[unstable(feature = \"extend_one\", issue = \"72631\")]\n+    fn extend_one(&mut self, item: A) {\n+        self.extend(Some(item));\n+    }\n+\n+    /// Reserves capacity in a collection for the given number of additional elements.\n+    ///\n+    /// The default implementation does nothing.\n+    #[unstable(feature = \"extend_one\", issue = \"72631\")]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        let _ = additional;\n+    }\n }\n \n #[stable(feature = \"extend_for_unit\", since = \"1.28.0\")]\n impl Extend<()> for () {\n     fn extend<T: IntoIterator<Item = ()>>(&mut self, iter: T) {\n         iter.into_iter().for_each(drop)\n     }\n+    fn extend_one(&mut self, _item: ()) {}\n }"}, {"sha": "f6329c6c593ed778a52f9b20b5df28a0a2b54ed3", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -63,6 +63,32 @@ pub trait DoubleEndedIterator: Iterator {\n     /// assert_eq!(None, iter.next());\n     /// assert_eq!(None, iter.next_back());\n     /// ```\n+    ///\n+    /// # Remarks\n+    ///\n+    /// The elements yielded by `DoubleEndedIterator`'s methods may differ from\n+    /// the ones yielded by `Iterator`'s methods:\n+    ///\n+    /// ```\n+    /// let vec = vec![(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b')];\n+    /// let uniq_by_fst_comp = || {\n+    ///     let mut seen = std::collections::HashSet::new();\n+    ///     vec.iter().copied().filter(move |x| seen.insert(x.0))\n+    /// };\n+    ///\n+    /// assert_eq!(uniq_by_fst_comp().last(), Some((2, 'a')));\n+    /// assert_eq!(uniq_by_fst_comp().next_back(), Some((2, 'b')));\n+    ///\n+    /// assert_eq!(\n+    ///     uniq_by_fst_comp().fold(vec![], |mut v, x| {v.push(x); v}),\n+    ///     vec![(1, 'a'), (2, 'a')]\n+    /// );\n+    /// assert_eq!(\n+    ///     uniq_by_fst_comp().rfold(vec![], |mut v, x| {v.push(x); v}),\n+    ///     vec![(2, 'b'), (1, 'c')]\n+    /// );\n+    /// ```\n+    ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n "}, {"sha": "a10b34d931d10a9080d90db05fcb6ab67a03204d", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1180,6 +1180,17 @@ pub trait Iterator {\n     /// assert_eq!(iter.next(), Some(2));\n     /// assert_eq!(iter.next(), None);\n     /// ```\n+    ///\n+    /// If less than `n` elements are available,\n+    /// `take` will limit itself to the size of the underlying iterator:\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2];\n+    /// let mut iter = v.into_iter().take(5);\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, n: usize) -> Take<Self>\n@@ -1700,9 +1711,9 @@ pub trait Iterator {\n         ) -> impl FnMut((), T) + 'a {\n             move |(), x| {\n                 if f(&x) {\n-                    left.extend(Some(x));\n+                    left.extend_one(x);\n                 } else {\n-                    right.extend(Some(x));\n+                    right.extend_one(x);\n                 }\n             }\n         }\n@@ -2675,14 +2686,20 @@ pub trait Iterator {\n             us: &'a mut impl Extend<B>,\n         ) -> impl FnMut((), (A, B)) + 'a {\n             move |(), (t, u)| {\n-                ts.extend(Some(t));\n-                us.extend(Some(u));\n+                ts.extend_one(t);\n+                us.extend_one(u);\n             }\n         }\n \n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n+        let (lower_bound, _) = self.size_hint();\n+        if lower_bound > 0 {\n+            ts.extend_reserve(lower_bound);\n+            us.extend_reserve(lower_bound);\n+        }\n+\n         self.fold((), extend(&mut ts, &mut us));\n \n         (ts, us)"}, {"sha": "7d21f9a9a66d0479038e91284f0d03fc638e103b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -85,8 +85,11 @@\n #![feature(const_panic)]\n #![feature(const_fn_union)]\n #![feature(const_generics)]\n+#![feature(const_ptr_offset)]\n #![feature(const_ptr_offset_from)]\n #![feature(const_result)]\n+#![feature(const_slice_from_raw_parts)]\n+#![feature(const_slice_ptr_len)]\n #![feature(const_type_name)]\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]"}, {"sha": "3cfdde60135b77d905939f54d0b52d301fca673b", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1315,7 +1315,7 @@ pub(crate) mod builtin {\n     #[unstable(\n         feature = \"llvm_asm\",\n         issue = \"70173\",\n-        reason = \"LLVM-style inline assembly will never be stabilized, prefer using asm! instead\"\n+        reason = \"prefer using the new asm! syntax instead\"\n     )]\n     #[rustc_builtin_macro]\n     #[macro_export]"}, {"sha": "6040dd31847a9f26f3999525d8e13ab90c5ed683", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -692,25 +692,13 @@ mod impls {\n     issue = \"none\",\n     reason = \"this trait is unlikely to ever be stabilized, use `mem::discriminant` instead\"\n )]\n-#[cfg_attr(not(bootstrap), lang = \"discriminant_kind\")]\n+#[lang = \"discriminant_kind\"]\n pub trait DiscriminantKind {\n     /// The type of the dicriminant, which must satisfy the trait\n     /// bounds required by `mem::Discriminant`.\n     type Discriminant: Clone + Copy + Debug + Eq + PartialEq + Hash + Send + Sync + Unpin;\n }\n \n-// Manually implement `DiscriminantKind` for all types during bootstrap\n-// to reduce the required amount of conditional compilation.\n-#[unstable(\n-    feature = \"discriminant_kind\",\n-    issue = \"none\",\n-    reason = \"this trait is unlikely to ever be stabilized, use `mem::discriminant` instead\"\n-)]\n-#[cfg(bootstrap)]\n-impl<T: ?Sized> DiscriminantKind for T {\n-    type Discriminant = u64;\n-}\n-\n /// Compiler-internal trait used to determine whether a type contains\n /// any `UnsafeCell` internally, but not through an indirection.\n /// This affects, for example, whether a `static` of that type is"}, {"sha": "499016545e967c769231a14ced30b1c06f5edd50", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -20,9 +20,9 @@ use crate::mem::ManuallyDrop;\n /// # #![allow(invalid_value)]\n /// use std::mem::{self, MaybeUninit};\n ///\n-/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n+/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior! \u26a0\ufe0f\n /// // The equivalent code with `MaybeUninit<&i32>`:\n-/// let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior!\n+/// let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior! \u26a0\ufe0f\n /// ```\n ///\n /// This is exploited by the compiler for various optimizations, such as eliding\n@@ -35,9 +35,9 @@ use crate::mem::ManuallyDrop;\n /// # #![allow(invalid_value)]\n /// use std::mem::{self, MaybeUninit};\n ///\n-/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior! \u26a0\ufe0f\n /// // The equivalent code with `MaybeUninit<bool>`:\n-/// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n+/// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! \u26a0\ufe0f\n /// ```\n ///\n /// Moreover, uninitialized memory is special in that the compiler knows that\n@@ -49,9 +49,9 @@ use crate::mem::ManuallyDrop;\n /// # #![allow(invalid_value)]\n /// use std::mem::{self, MaybeUninit};\n ///\n-/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior! \u26a0\ufe0f\n /// // The equivalent code with `MaybeUninit<i32>`:\n-/// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n+/// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! \u26a0\ufe0f\n /// ```\n /// (Notice that the rules around uninitialized integers are not finalized yet, but\n /// until they are, it is advisable to avoid them.)\n@@ -214,7 +214,6 @@ use crate::mem::ManuallyDrop;\n /// remain `#[repr(transparent)]`. That said, `MaybeUninit<T>` will *always* guarantee that it has\n /// the same size, alignment, and ABI as `T`; it's just that the way `MaybeUninit` implements that\n /// guarantee may evolve.\n-#[allow(missing_debug_implementations)]\n #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n // Lang item so we can wrap other types in it. This is useful for generators.\n #[lang = \"maybe_uninit\"]\n@@ -348,7 +347,7 @@ impl<T> MaybeUninit<T> {\n     /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n     /// let x = unsafe { x.assume_init() };\n     /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n-    /// // This is undefined behavior.\n+    /// // This is undefined behavior. \u26a0\ufe0f\n     /// ```\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline]\n@@ -400,7 +399,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let x = MaybeUninit::<Vec<u32>>::uninit();\n     /// let x_vec = unsafe { &*x.as_ptr() };\n-    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior. \u26a0\ufe0f\n     /// ```\n     ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n@@ -437,7 +436,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n     /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n-    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior. \u26a0\ufe0f\n     /// ```\n     ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n@@ -489,7 +488,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let x = MaybeUninit::<Vec<u32>>::uninit();\n     /// let x_init = unsafe { x.assume_init() };\n-    /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n+    /// // `x` had not been initialized yet, so this last line caused undefined behavior. \u26a0\ufe0f\n     /// ```\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n@@ -553,7 +552,7 @@ impl<T> MaybeUninit<T> {\n     /// x.write(Some(vec![0,1,2]));\n     /// let x1 = unsafe { x.read() };\n     /// let x2 = unsafe { x.read() };\n-    /// // We now created two copies of the same vector, leading to a double-free when\n+    /// // We now created two copies of the same vector, leading to a double-free \u26a0\ufe0f when\n     /// // they both get dropped!\n     /// ```\n     #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n@@ -603,7 +602,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let x = MaybeUninit::<Vec<u32>>::uninit();\n     /// let x_vec: &Vec<u32> = unsafe { x.get_ref() };\n-    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior. \u26a0\ufe0f\n     /// ```\n     ///\n     /// ```rust,no_run\n@@ -686,7 +685,7 @@ impl<T> MaybeUninit<T> {\n     /// unsafe {\n     ///     *b.get_mut() = true;\n     ///     // We have created a (mutable) reference to an uninitialized `bool`!\n-    ///     // This is undefined behavior.\n+    ///     // This is undefined behavior. \u26a0\ufe0f\n     /// }\n     /// ```\n     ///"}, {"sha": "d1f5cb44913db583337c938f234012380a421dcb", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -808,7 +808,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n \n /// Disposes of a value.\n ///\n-/// This does call the argument's implementation of [`Drop`][drop].\n+/// This does so by calling the argument's implementation of [`Drop`][drop].\n ///\n /// This effectively does nothing for types which implement `Copy`, e.g.\n /// integers. Such values are copied and _then_ moved into the function, so the"}, {"sha": "6313de31ce4d582dfc2f7b33e57216ed7d1f1070", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -810,4 +810,78 @@ impl f32 {\n     pub fn from_ne_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_ne_bytes(bytes))\n     }\n+\n+    /// Returns an ordering between self and other values.\n+    /// Unlike the standard partial comparison between floating point numbers,\n+    /// this comparison always produces an ordering in accordance to\n+    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n+    /// floating point standard. The values are ordered in following order:\n+    /// - Negative quiet NaN\n+    /// - Negative signaling NaN\n+    /// - Negative infinity\n+    /// - Negative numbers\n+    /// - Negative subnormal numbers\n+    /// - Negative zero\n+    /// - Positive zero\n+    /// - Positive subnormal numbers\n+    /// - Positive numbers\n+    /// - Positive infinity\n+    /// - Positive signaling NaN\n+    /// - Positive quiet NaN\n+    ///\n+    /// # Example\n+    /// ```\n+    /// #![feature(total_cmp)]\n+    /// struct GoodBoy {\n+    ///     name: String,\n+    ///     weight: f32,\n+    /// }\n+    ///\n+    /// let mut bois = vec![\n+    ///     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n+    ///     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n+    ///     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n+    ///     GoodBoy { name: \"Chonk\".to_owned(), weight: f32::INFINITY },\n+    ///     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f32::NAN },\n+    ///     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n+    /// ];\n+    ///\n+    /// bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n+    /// # assert!(bois.into_iter().map(|b| b.weight)\n+    /// #     .zip([-5.0, 0.1, 10.0, 99.0, f32::INFINITY, f32::NAN].iter())\n+    /// #     .all(|(a, b)| a.to_bits() == b.to_bits()))\n+    /// ```\n+    #[unstable(feature = \"total_cmp\", issue = \"72599\")]\n+    #[inline]\n+    pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering {\n+        let mut left = self.to_bits() as i32;\n+        let mut right = other.to_bits() as i32;\n+\n+        // In case of negatives, flip all the bits except the sign\n+        // to achieve a similar layout as two's complement integers\n+        //\n+        // Why does this work? IEEE 754 floats consist of three fields:\n+        // Sign bit, exponent and mantissa. The set of exponent and mantissa\n+        // fields as a whole have the property that their bitwise order is\n+        // equal to the numeric magnitude where the magnitude is defined.\n+        // The magnitude is not normally defined on NaN values, but\n+        // IEEE 754 totalOrder defines the NaN values also to follow the\n+        // bitwise order. This leads to order explained in the doc comment.\n+        // However, the representation of magnitude is the same for negative\n+        // and positive numbers \u2013 only the sign bit is different.\n+        // To easily compare the floats as signed integers, we need to\n+        // flip the exponent and mantissa bits in case of negative numbers.\n+        // We effectively convert the numbers to \"two's complement\" form.\n+        //\n+        // To do the flipping, we construct a mask and XOR against it.\n+        // We branchlessly calculate an \"all-ones except for the sign bit\"\n+        // mask from negative-signed values: right shifting sign-extends\n+        // the integer, so we \"fill\" the mask with sign bits, and then\n+        // convert to unsigned to push one more zero bit.\n+        // On positive values, the mask is all zeros, so it's a no-op.\n+        left ^= (((left >> 31) as u32) >> 1) as i32;\n+        right ^= (((right >> 31) as u32) >> 1) as i32;\n+\n+        left.cmp(&right)\n+    }\n }"}, {"sha": "d42e5392c586347af9dd092d4033342b46349e3c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -824,4 +824,78 @@ impl f64 {\n     pub fn from_ne_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_ne_bytes(bytes))\n     }\n+\n+    /// Returns an ordering between self and other values.\n+    /// Unlike the standard partial comparison between floating point numbers,\n+    /// this comparison always produces an ordering in accordance to\n+    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n+    /// floating point standard. The values are ordered in following order:\n+    /// - Negative quiet NaN\n+    /// - Negative signaling NaN\n+    /// - Negative infinity\n+    /// - Negative numbers\n+    /// - Negative subnormal numbers\n+    /// - Negative zero\n+    /// - Positive zero\n+    /// - Positive subnormal numbers\n+    /// - Positive numbers\n+    /// - Positive infinity\n+    /// - Positive signaling NaN\n+    /// - Positive quiet NaN\n+    ///\n+    /// # Example\n+    /// ```\n+    /// #![feature(total_cmp)]\n+    /// struct GoodBoy {\n+    ///     name: String,\n+    ///     weight: f64,\n+    /// }\n+    ///\n+    /// let mut bois = vec![\n+    ///     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n+    ///     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n+    ///     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n+    ///     GoodBoy { name: \"Chonk\".to_owned(), weight: f64::INFINITY },\n+    ///     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f64::NAN },\n+    ///     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n+    /// ];\n+    ///\n+    /// bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n+    /// # assert!(bois.into_iter().map(|b| b.weight)\n+    /// #     .zip([-5.0, 0.1, 10.0, 99.0, f64::INFINITY, f64::NAN].iter())\n+    /// #     .all(|(a, b)| a.to_bits() == b.to_bits()))\n+    /// ```\n+    #[unstable(feature = \"total_cmp\", issue = \"72599\")]\n+    #[inline]\n+    pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering {\n+        let mut left = self.to_bits() as i64;\n+        let mut right = other.to_bits() as i64;\n+\n+        // In case of negatives, flip all the bits except the sign\n+        // to achieve a similar layout as two's complement integers\n+        //\n+        // Why does this work? IEEE 754 floats consist of three fields:\n+        // Sign bit, exponent and mantissa. The set of exponent and mantissa\n+        // fields as a whole have the property that their bitwise order is\n+        // equal to the numeric magnitude where the magnitude is defined.\n+        // The magnitude is not normally defined on NaN values, but\n+        // IEEE 754 totalOrder defines the NaN values also to follow the\n+        // bitwise order. This leads to order explained in the doc comment.\n+        // However, the representation of magnitude is the same for negative\n+        // and positive numbers \u2013 only the sign bit is different.\n+        // To easily compare the floats as signed integers, we need to\n+        // flip the exponent and mantissa bits in case of negative numbers.\n+        // We effectively convert the numbers to \"two's complement\" form.\n+        //\n+        // To do the flipping, we construct a mask and XOR against it.\n+        // We branchlessly calculate an \"all-ones except for the sign bit\"\n+        // mask from negative-signed values: right shifting sign-extends\n+        // the integer, so we \"fill\" the mask with sign bits, and then\n+        // convert to unsigned to push one more zero bit.\n+        // On positive values, the mask is all zeros, so it's a no-op.\n+        left ^= (((left >> 63) as u64) >> 1) as i64;\n+        right ^= (((right >> 63) as u64) >> 1) as i64;\n+\n+        left.cmp(&right)\n+    }\n }"}, {"sha": "bb648ba8c25de69e6eee3b8f9e34a214b973f355", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -337,14 +337,10 @@ Basic usage:\n #![feature(wrapping_int_impl)]\n use std::num::Wrapping;\n \n-assert_eq!(<Wrapping<\", stringify!($t), \">>::min_value(), \",\n-\"Wrapping(\", stringify!($t), \"::min_value()));\n+assert_eq!(<Wrapping<\", stringify!($t), \">>::MIN, Wrapping(\", stringify!($t), \"::MIN));\n ```\"),\n                 #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                #[inline]\n-                pub const fn min_value() -> Self {\n-                    Wrapping(<$t>::min_value())\n-                }\n+                pub const MIN: Self = Self(<$t>::MIN);\n             }\n \n             doc_comment! {\n@@ -358,14 +354,10 @@ Basic usage:\n #![feature(wrapping_int_impl)]\n use std::num::Wrapping;\n \n-assert_eq!(<Wrapping<\", stringify!($t), \">>::max_value(), \",\n-\"Wrapping(\", stringify!($t), \"::max_value()));\n+assert_eq!(<Wrapping<\", stringify!($t), \">>::MAX, Wrapping(\", stringify!($t), \"::MAX));\n ```\"),\n                 #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                #[inline]\n-                pub const fn max_value() -> Self {\n-                    Wrapping(<$t>::max_value())\n-                }\n+                pub const MAX: Self = Self(<$t>::MAX);\n             }\n \n             doc_comment! {"}, {"sha": "3faeb170b0637626090dcdb9dd1fba9c0b999cb3", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -18,8 +18,8 @@\n ///\n /// If `T` implements `Deref<Target = U>`, and `x` is a value of type `T`, then:\n ///\n-/// * In immutable contexts, `*x` on non-pointer types is equivalent to\n-///   `*Deref::deref(&x)`.\n+/// * In immutable contexts, `*x` (where `T` is neither a reference nor a raw pointer)\n+///   is equivalent to `*Deref::deref(&x)`.\n /// * Values of type `&T` are coerced to values of type `&U`\n /// * `T` implicitly implements all the (immutable) methods of the type `U`.\n ///\n@@ -115,8 +115,8 @@ impl<T: ?Sized> Deref for &mut T {\n /// If `T` implements `DerefMut<Target = U>`, and `x` is a value of type `T`,\n /// then:\n ///\n-/// * In mutable contexts, `*x` on non-pointer types is equivalent to\n-///   `*DerefMut::deref_mut(&mut x)`.\n+/// * In mutable contexts, `*x` (where `T` is neither a reference nor a raw pointer)\n+///   is equivalent to `*DerefMut::deref_mut(&mut x)`.\n /// * Values of type `&mut T` are coerced to values of type `&mut U`\n /// * `T` implicitly implements all the (mutable) methods of the type `U`.\n ///"}, {"sha": "d86f39c4550c843fc3aa8f5212ccc5c633710e46", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -151,10 +151,16 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n ///\n /// The `RangeFrom` `start..` contains all values with `x >= start`.\n ///\n-/// *Note*: Currently, no overflow checking is done for the [`Iterator`]\n-/// implementation; if you use an integer range and the integer overflows, it\n-/// might panic in debug mode or create an endless loop in release mode. **This\n-/// overflow behavior might change in the future.**\n+/// *Note*: Overflow in the [`Iterator`] implementation (when the contained\n+/// data type reaches its numerical limit) is allowed to panic, wrap, or\n+/// saturate. This behavior is defined by the implementation of the [`Step`]\n+/// trait. For primitive integers, this follows the normal rules, and respects\n+/// the overflow checks profile (panic in debug, wrap in release). Note also\n+/// that overflow happens earlier than you might assume: the overflow happens\n+/// in the call to `next` that yields the maximum value, as the range must be\n+/// set to a state to yield the next value.\n+///\n+/// [`Step`]: crate::iter::Step\n ///\n /// # Examples\n ///"}, {"sha": "9bc35ae1f5c280bf59aabcabb6525943f2a663cb", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -25,6 +25,7 @@\n     )\n )]\n #[doc(alias = \"?\")]\n+#[lang = \"try\"]\n pub trait Try {\n     /// The type of this value when viewed as successful.\n     #[unstable(feature = \"try_trait\", issue = \"42327\")]"}, {"sha": "3ed5e65e11c628684c1ea073b539305ee8a37ee6", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -39,12 +39,7 @@ use crate::panic::{Location, PanicInfo};\n #[lang = \"panic\"] // needed by codegen for panic on overflow and other `Assert` MIR terminators\n pub fn panic(expr: &str) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n-        // remove `unsafe` (and safety comment) on bootstrap bump\n-        #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n-        // SAFETY: the `abort` intrinsic has no requirements to be called.\n-        unsafe {\n-            super::intrinsics::abort()\n-        }\n+        super::intrinsics::abort()\n     }\n \n     // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n@@ -62,12 +57,7 @@ pub fn panic(expr: &str) -> ! {\n #[lang = \"panic_bounds_check\"] // needed by codegen for panic on OOB array/slice access\n fn panic_bounds_check(index: usize, len: usize) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n-        // remove `unsafe` (and safety comment) on bootstrap bump\n-        #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n-        // SAFETY: the `abort` intrinsic has no requirements to be called.\n-        unsafe {\n-            super::intrinsics::abort()\n-        }\n+        super::intrinsics::abort()\n     }\n \n     panic!(\"index out of bounds: the len is {} but the index is {}\", len, index)\n@@ -80,12 +70,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n #[track_caller]\n pub fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n-        // remove `unsafe` (and safety comment) on bootstrap bump\n-        #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n-        // SAFETY: the `abort` intrinsic has no requirements to be called.\n-        unsafe {\n-            super::intrinsics::abort()\n-        }\n+        super::intrinsics::abort()\n     }\n \n     // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call"}, {"sha": "6f5bf7ad9da52e1e40fae1383d77c813eb6f99fe", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -139,10 +139,12 @@\n //! otherwise invalidating the memory used to store the data is restricted, too.\n //! Concretely, for pinned data you have to maintain the invariant\n //! that *its memory will not get invalidated or repurposed from the moment it gets pinned until\n-//! when [`drop`] is called*. Memory can be invalidated by deallocation, but also by\n+//! when [`drop`] is called*.  Only once [`drop`] returns or panics, the memory may be reused.\n+//!\n+//! Memory can be \"invalidated\" by deallocation, but also by\n //! replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n //! off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n-//! calling the destructor first.\n+//! calling the destructor first. None of this is allowed for pinned data without calling [`drop`].\n //!\n //! This is exactly the kind of guarantee that the intrusive linked list from the previous\n //! section needs to function correctly."}, {"sha": "835183d171a794877d1167a2a238c1173f6f6e7a", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -151,8 +151,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn offset(self, count: isize) -> *const T\n+    pub const unsafe fn offset(self, count: isize) -> *const T\n     where\n         T: Sized,\n     {\n@@ -210,8 +211,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_offset(self, count: isize) -> *const T\n+    pub const fn wrapping_offset(self, count: isize) -> *const T\n     where\n         T: Sized,\n     {\n@@ -393,8 +395,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn add(self, count: usize) -> Self\n+    pub const unsafe fn add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -455,8 +458,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn sub(self, count: usize) -> Self\n+    pub const unsafe fn sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -511,8 +515,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_add(self, count: usize) -> Self\n+    pub const fn wrapping_add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -567,8 +572,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_sub(self, count: usize) -> Self\n+    pub const fn wrapping_sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {"}, {"sha": "40b5e4e22340e9844ae05862645811a2c110980b", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -145,8 +145,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn offset(self, count: isize) -> *mut T\n+    pub const unsafe fn offset(self, count: isize) -> *mut T\n     where\n         T: Sized,\n     {\n@@ -203,8 +204,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_offset(self, count: isize) -> *mut T\n+    pub const fn wrapping_offset(self, count: isize) -> *mut T\n     where\n         T: Sized,\n     {\n@@ -439,8 +441,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn add(self, count: usize) -> Self\n+    pub const unsafe fn add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -501,8 +504,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn sub(self, count: usize) -> Self\n+    pub const unsafe fn sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -557,8 +561,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_add(self, count: usize) -> Self\n+    pub const fn wrapping_add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -613,8 +618,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_sub(self, count: usize) -> Self\n+    pub const fn wrapping_sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {"}, {"sha": "870364a61dd47c9bfbe072c4bf383e52c3826be0", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -142,6 +142,65 @@ impl<T: ?Sized> NonNull<T> {\n     }\n }\n \n+impl<T> NonNull<[T]> {\n+    /// Creates a non-null raw slice from a thin pointer and a length.\n+    ///\n+    /// The `len` argument is the number of **elements**, not the number of bytes.\n+    ///\n+    /// This function is safe, but dereferencing the return value is unsafe.\n+    /// See the documentation of [`slice::from_raw_parts`] for slice safety requirements.\n+    ///\n+    /// [`slice::from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(nonnull_slice_from_raw_parts)]\n+    ///\n+    /// use std::ptr::NonNull;\n+    ///\n+    /// // create a slice pointer when starting out with a pointer to the first element\n+    /// let mut x = [5, 6, 7];\n+    /// let nonnull_pointer = NonNull::new(x.as_mut_ptr()).unwrap();\n+    /// let slice = NonNull::slice_from_raw_parts(nonnull_pointer, 3);\n+    /// assert_eq!(unsafe { slice.as_ref()[2] }, 7);\n+    /// ```\n+    ///\n+    /// (Note that this example artifically demonstrates a use of this method,\n+    /// but `let slice = NonNull::from(&x[..]);` would be a better way to write code like this.)\n+    #[unstable(feature = \"nonnull_slice_from_raw_parts\", issue = \"71941\")]\n+    #[rustc_const_unstable(feature = \"const_nonnull_slice_from_raw_parts\", issue = \"71941\")]\n+    #[inline]\n+    pub const fn slice_from_raw_parts(data: NonNull<T>, len: usize) -> Self {\n+        // SAFETY: `data` is a `NonNull` pointer which is necessarily non-null\n+        unsafe { Self::new_unchecked(super::slice_from_raw_parts_mut(data.as_ptr(), len)) }\n+    }\n+\n+    /// Returns the length of a non-null raw slice.\n+    ///\n+    /// The returned value is the number of **elements**, not the number of bytes.\n+    ///\n+    /// This function is safe, even when the non-null raw slice cannot be dereferenced to a slice\n+    /// because the pointer does not have a valid address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(slice_ptr_len, nonnull_slice_from_raw_parts)]\n+    ///\n+    /// use std::ptr::NonNull;\n+    ///\n+    /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n+    /// assert_eq!(slice.len(), 3);\n+    /// ```\n+    #[unstable(feature = \"slice_ptr_len\", issue = \"71146\")]\n+    #[rustc_const_unstable(feature = \"const_slice_ptr_len\", issue = \"71146\")]\n+    #[inline]\n+    pub const fn len(self) -> usize {\n+        self.as_ptr().len()\n+    }\n+}\n+\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> Clone for NonNull<T> {\n     #[inline]"}, {"sha": "741a9dc8797becd6351f4599905e7f1b9139f1a3", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -9,15 +9,15 @@\n //! Their definition should always match the ABI defined in\n //! `rustc_middle::ty::layout`.\n \n-/// The representation of a trait object like `&SomeTrait`.\n+/// The representation of a trait object like `&dyn SomeTrait`.\n ///\n-/// This struct has the same layout as types like `&SomeTrait` and\n+/// This struct has the same layout as types like `&dyn SomeTrait` and\n /// `Box<dyn AnotherTrait>`.\n ///\n /// `TraitObject` is guaranteed to match layouts, but it is not the\n /// type of trait objects (e.g., the fields are not directly accessible\n-/// on a `&SomeTrait`) nor does it control that layout (changing the\n-/// definition will not change the layout of a `&SomeTrait`). It is\n+/// on a `&dyn SomeTrait`) nor does it control that layout (changing the\n+/// definition will not change the layout of a `&dyn SomeTrait`). It is\n /// only designed to be used by unsafe code that needs to manipulate\n /// the low-level details.\n ///"}, {"sha": "4efb1db7a1a68b1cb3c7da985ac9719c91804043", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -409,7 +409,7 @@ impl<T> [T] {\n     /// The returned range is half-open, which means that the end pointer\n     /// points *one past* the last element of the slice. This way, an empty\n     /// slice is represented by two equal pointers, and the difference between\n-    /// the two pointers represents the size of the size.\n+    /// the two pointers represents the size of the slice.\n     ///\n     /// See [`as_ptr`] for warnings on using these pointers. The end pointer\n     /// requires extra caution, as it does not point to a valid element in the\n@@ -464,7 +464,7 @@ impl<T> [T] {\n     /// The returned range is half-open, which means that the end pointer\n     /// points *one past* the last element of the slice. This way, an empty\n     /// slice is represented by two equal pointers, and the difference between\n-    /// the two pointers represents the size of the size.\n+    /// the two pointers represents the size of the slice.\n     ///\n     /// See [`as_mut_ptr`] for warnings on using these pointers. The end\n     /// pointer requires extra caution, as it does not point to a valid element\n@@ -1654,7 +1654,7 @@ impl<T> [T] {\n     ///\n     /// ```\n     /// let mut floats = [5f64, 4.0, 1.0, 3.0, 2.0];\n-    /// floats.sort_by(|a, b| a.partial_cmp(b).unwrap());\n+    /// floats.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());\n     /// assert_eq!(floats, [1.0, 2.0, 3.0, 4.0, 5.0]);\n     /// ```\n     ///\n@@ -2173,7 +2173,7 @@ impl<T> [T] {\n     ///\n     /// The length of `src` must be the same as `self`.\n     ///\n-    /// If `src` implements `Copy`, it can be more performant to use\n+    /// If `T` implements `Copy`, it can be more performant to use\n     /// [`copy_from_slice`].\n     ///\n     /// # Panics\n@@ -2244,7 +2244,7 @@ impl<T> [T] {\n     ///\n     /// The length of `src` must be the same as `self`.\n     ///\n-    /// If `src` does not implement `Copy`, use [`clone_from_slice`].\n+    /// If `T` does not implement `Copy`, use [`clone_from_slice`].\n     ///\n     /// # Panics\n     ///\n@@ -5740,7 +5740,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n ///   and it must be properly aligned. This means in particular:\n ///\n ///     * The entire memory range of this slice must be contained within a single allocated object!\n-///       Slices can never span across multiple allocated objects.\n+///       Slices can never span across multiple allocated objects. See [below](#incorrect-usage)\n+///       for an example incorrectly not taking this into account.\n ///     * `data` must be non-null and aligned even for zero-length slices. One\n ///       reason for this is that enum layout optimizations may rely on references\n ///       (including slices of any length) being aligned and non-null to distinguish\n@@ -5773,6 +5774,34 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n /// assert_eq!(slice[0], 42);\n /// ```\n ///\n+/// ### Incorrect usage\n+///\n+/// The following `join_slices` function is **unsound** \u26a0\ufe0f\n+///\n+/// ```rust,no_run\n+/// use std::slice;\n+///\n+/// fn join_slices<'a, T>(fst: &'a [T], snd: &'a [T]) -> &'a [T] {\n+///     let fst_end = fst.as_ptr().wrapping_add(fst.len());\n+///     let snd_start = snd.as_ptr();\n+///     assert_eq!(fst_end, snd_start, \"Slices must be contiguous!\");\n+///     unsafe {\n+///         // The assertion above ensures `fst` and `snd` are contiguous, but they might\n+///         // still be contained within _different allocated objects_, in which case\n+///         // creating this slice is undefined behavior.\n+///         slice::from_raw_parts(fst.as_ptr(), fst.len() + snd.len())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     // `a` and `b` are different allocated objects...\n+///     let a = 42;\n+///     let b = 27;\n+///     // ... which may nevertheless be laid out contiguously in memory: | a | b |\n+///     let _ = join_slices(slice::from_ref(&a), slice::from_ref(&b)); // UB\n+/// }\n+/// ```\n+///\n /// [valid]: ../../std/ptr/index.html#safety\n /// [`NonNull::dangling()`]: ../../std/ptr/struct.NonNull.html#method.dangling\n /// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset"}, {"sha": "316c2cd55aceaf60527b454354f737ee5ce0fc88", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -2270,12 +2270,11 @@ impl str {\n         self.len() == 0\n     }\n \n-    /// Checks that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n+    /// Checks that `index`-th byte is the first byte in a UTF-8 code point\n+    /// sequence or the end of the string.\n     ///\n     /// The start and end of the string (when `index == self.len()`) are\n-    /// considered to be\n-    /// boundaries.\n+    /// considered to be boundaries.\n     ///\n     /// Returns `false` if `index` is greater than `self.len()`.\n     ///\n@@ -4052,15 +4051,13 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_strip)]\n-    ///\n     /// assert_eq!(\"foo:bar\".strip_prefix(\"foo:\"), Some(\"bar\"));\n     /// assert_eq!(\"foo:bar\".strip_prefix(\"bar\"), None);\n     /// assert_eq!(\"foofoo\".strip_prefix(\"foo\"), Some(\"foo\"));\n     /// ```\n     #[must_use = \"this returns the remaining substring as a new slice, \\\n                   without modifying the original\"]\n-    #[unstable(feature = \"str_strip\", reason = \"newly added\", issue = \"67302\")]\n+    #[stable(feature = \"str_strip\", since = \"1.45.0\")]\n     pub fn strip_prefix<'a, P: Pattern<'a>>(&'a self, prefix: P) -> Option<&'a str> {\n         prefix.strip_prefix_of(self)\n     }\n@@ -4082,14 +4079,13 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_strip)]\n     /// assert_eq!(\"bar:foo\".strip_suffix(\":foo\"), Some(\"bar\"));\n     /// assert_eq!(\"bar:foo\".strip_suffix(\"bar\"), None);\n     /// assert_eq!(\"foofoo\".strip_suffix(\"foo\"), Some(\"foo\"));\n     /// ```\n     #[must_use = \"this returns the remaining substring as a new slice, \\\n                   without modifying the original\"]\n-    #[unstable(feature = \"str_strip\", reason = \"newly added\", issue = \"67302\")]\n+    #[stable(feature = \"str_strip\", since = \"1.45.0\")]\n     pub fn strip_suffix<'a, P>(&'a self, suffix: P) -> Option<&'a str>\n     where\n         P: Pattern<'a>,"}, {"sha": "477cb24d6be67ad57747b46b024f56f251d38709", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 100, "deletions": 25, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -153,6 +153,9 @@ pub fn spin_loop_hint() {\n ///\n /// This type has the same in-memory representation as a [`bool`].\n ///\n+/// **Note**: This type is only available on platforms that support atomic\n+/// loads and stores of `u8`.\n+///\n /// [`bool`]: ../../../std/primitive.bool.html\n #[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -178,6 +181,9 @@ unsafe impl Sync for AtomicBool {}\n /// A raw pointer type which can be safely shared between threads.\n ///\n /// This type has the same in-memory representation as a `*mut T`.\n+///\n+/// **Note**: This type is only available on platforms that support atomic\n+/// loads and stores of pointers. Its size depends on the target pointer's size.\n #[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(target_pointer_width = \"16\", repr(C, align(2)))]\n@@ -447,6 +453,9 @@ impl AtomicBool {\n     /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n     /// using [`Release`] makes the load part [`Relaxed`].\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on `u8`.\n+    ///\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n@@ -481,6 +490,9 @@ impl AtomicBool {\n     /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n     /// happens, and using [`Release`] makes the load part [`Relaxed`].\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on `u8`.\n+    ///\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n@@ -524,6 +536,8 @@ impl AtomicBool {\n     /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n     /// and must be equivalent to or weaker than the success ordering.\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on `u8`.\n     ///\n     /// [`bool`]: ../../../std/primitive.bool.html\n     /// [`Ordering`]: enum.Ordering.html\n@@ -586,6 +600,9 @@ impl AtomicBool {\n     /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n     /// and must be equivalent to or weaker than the success ordering.\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on `u8`.\n+    ///\n     /// [`bool`]: ../../../std/primitive.bool.html\n     /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n@@ -646,6 +663,9 @@ impl AtomicBool {\n     /// [`Release`]: enum.Ordering.html#variant.Release\n     /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on `u8`.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -683,6 +703,9 @@ impl AtomicBool {\n     /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n     /// using [`Release`] makes the load part [`Relaxed`].\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on `u8`.\n+    ///\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n@@ -737,6 +760,9 @@ impl AtomicBool {\n     /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n     /// using [`Release`] makes the load part [`Relaxed`].\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on `u8`.\n+    ///\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n@@ -779,6 +805,9 @@ impl AtomicBool {\n     /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n     /// using [`Release`] makes the load part [`Relaxed`].\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on `u8`.\n+    ///\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n@@ -981,6 +1010,9 @@ impl<T> AtomicPtr<T> {\n     /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n     /// using [`Release`] makes the load part [`Relaxed`].\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on pointers.\n+    ///\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n@@ -1017,6 +1049,9 @@ impl<T> AtomicPtr<T> {\n     /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n     /// happens, and using [`Release`] makes the load part [`Relaxed`].\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on pointers.\n+    ///\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n@@ -1058,6 +1093,9 @@ impl<T> AtomicPtr<T> {\n     /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n     /// and must be equivalent to or weaker than the success ordering.\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on pointers.\n+    ///\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n@@ -1118,6 +1156,9 @@ impl<T> AtomicPtr<T> {\n     /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n     /// and must be equivalent to or weaker than the success ordering.\n     ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on pointers.\n+    ///\n     /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n@@ -1223,6 +1264,13 @@ macro_rules! atomic_int {\n         /// non-atomic types as well as information about the portability of\n         /// this type, please see the [module-level documentation].\n         ///\n+        /// **Note:** This type is only available on platforms that support\n+        /// atomic loads and stores of [`\n+        #[doc = $s_int_type]\n+        /// `](\n+        #[doc = $int_ref]\n+        /// ).\n+        ///\n         /// [module-level documentation]: index.html\n         #[$stable]\n         #[repr(C, align($align))]\n@@ -1408,6 +1456,9 @@ of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`Ordering`]: enum.Ordering.html\n [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n@@ -1444,6 +1495,9 @@ might fail and hence just perform an `Acquire` load, but not have `Release` sema\n Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n happens, and using [`Release`] makes the load part [`Relaxed`].\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`Ordering`]: enum.Ordering.html\n [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n@@ -1496,6 +1550,9 @@ of this operation [`Relaxed`], and using [`Release`] makes the successful load\n [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n and must be equivalent to or weaker than the success ordering.\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`Ordering`]: enum.Ordering.html\n [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n@@ -1558,6 +1615,9 @@ and must be equivalent to or weaker than the success ordering.\n [`Acquire`]: enum.Ordering.html#variant.Acquire\n [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n # Examples\n \n ```\n@@ -1599,6 +1659,9 @@ of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`Ordering`]: enum.Ordering.html\n [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n@@ -1632,6 +1695,9 @@ of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`Ordering`]: enum.Ordering.html\n [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n@@ -1668,6 +1734,9 @@ of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`Ordering`]: enum.Ordering.html\n [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n@@ -1704,6 +1773,9 @@ of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`Ordering`]: enum.Ordering.html\n [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n@@ -1741,6 +1813,9 @@ of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`Ordering`]: enum.Ordering.html\n [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n@@ -1777,6 +1852,9 @@ of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`Ordering`]: enum.Ordering.html\n [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n@@ -1807,19 +1885,21 @@ new value. Returns a `Result` of `Ok(previous_value)` if the function returned `\n \n Note: This may call the function multiple times if the value has been changed from other threads in\n the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n-but once to the stored value.\n+only once to the stored value.\n \n-`fetch_update` takes two [`Ordering`] arguments to describe the memory\n-ordering of this operation. The first describes the required ordering for loads\n-and failed updates while the second describes the required ordering when the\n-operation finally succeeds. Beware that this is different from the two\n-modes in [`compare_exchange`]!\n+`fetch_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n+The first describes the required ordering for when the operation finally succeeds while the second\n+describes the required ordering for loads. These correspond to the success and failure orderings of\n+[`compare_exchange`] respectively.\n \n Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n and must be equivalent to or weaker than the success ordering.\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`bool`]: ../../../std/primitive.bool.html\n [`compare_exchange`]: #method.compare_exchange\n [`Ordering`]: enum.Ordering.html\n@@ -1831,24 +1911,21 @@ and must be equivalent to or weaker than the success ordering.\n # Examples\n \n ```rust\n-#![feature(no_more_cas)]\n \", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n \n let x = \", stringify!($atomic_type), \"::new(7);\n-assert_eq!(x.fetch_update(|_| None, Ordering::SeqCst, Ordering::SeqCst), Err(7));\n-assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(7));\n-assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(8));\n+assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(7));\n+assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(7));\n+assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(8));\n assert_eq!(x.load(Ordering::SeqCst), 9);\n ```\"),\n                 #[inline]\n-                #[unstable(feature = \"no_more_cas\",\n-                       reason = \"no more CAS loops in user code\",\n-                       issue = \"48655\")]\n+                #[stable(feature = \"no_more_cas\", since = \"1.45.0\")]\n                 #[$cfg_cas]\n                 pub fn fetch_update<F>(&self,\n-                                       mut f: F,\n+                                       set_order: Ordering,\n                                        fetch_order: Ordering,\n-                                       set_order: Ordering) -> Result<$int_type, $int_type>\n+                                       mut f: F) -> Result<$int_type, $int_type>\n                 where F: FnMut($int_type) -> Option<$int_type> {\n                     let mut prev = self.load(fetch_order);\n                     while let Some(next) = f(prev) {\n@@ -1874,6 +1951,9 @@ of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`Ordering`]: enum.Ordering.html\n [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n@@ -1882,7 +1962,6 @@ using [`Release`] makes the load part [`Relaxed`].\n # Examples\n \n ```\n-#![feature(atomic_min_max)]\n \", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n \n let foo = \", stringify!($atomic_type), \"::new(23);\n@@ -1893,7 +1972,6 @@ assert_eq!(foo.load(Ordering::SeqCst), 42);\n If you want to obtain the maximum value in one step, you can use the following:\n \n ```\n-#![feature(atomic_min_max)]\n \", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n \n let foo = \", stringify!($atomic_type), \"::new(23);\n@@ -1902,9 +1980,7 @@ let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n assert!(max_foo == 42);\n ```\"),\n                 #[inline]\n-                #[unstable(feature = \"atomic_min_max\",\n-                       reason = \"easier and faster min/max than writing manual CAS loop\",\n-                       issue = \"48655\")]\n+                #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n                 #[$cfg_cas]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                     // SAFETY: data races are prevented by atomic intrinsics.\n@@ -1925,6 +2001,9 @@ of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n \n+**Note**: This method is only available on platforms that support atomic\n+operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n+\n [`Ordering`]: enum.Ordering.html\n [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n@@ -1933,7 +2012,6 @@ using [`Release`] makes the load part [`Relaxed`].\n # Examples\n \n ```\n-#![feature(atomic_min_max)]\n \", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n \n let foo = \", stringify!($atomic_type), \"::new(23);\n@@ -1946,7 +2024,6 @@ assert_eq!(foo.load(Ordering::Relaxed), 22);\n If you want to obtain the minimum value in one step, you can use the following:\n \n ```\n-#![feature(atomic_min_max)]\n \", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n \n let foo = \", stringify!($atomic_type), \"::new(23);\n@@ -1955,9 +2032,7 @@ let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n assert_eq!(min_foo, 12);\n ```\"),\n                 #[inline]\n-                #[unstable(feature = \"atomic_min_max\",\n-                       reason = \"easier and faster min/max than writing manual CAS loop\",\n-                       issue = \"48655\")]\n+                #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n                 #[$cfg_cas]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                     // SAFETY: data races are prevented by atomic intrinsics."}, {"sha": "3b854b56c320dcc7007a8c00edfb6993a12b2577", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -813,6 +813,30 @@ fn test_iterator_peekable_rfold() {\n     assert_eq!(i, xs.len());\n }\n \n+#[test]\n+fn test_iterator_peekable_next_if_eq() {\n+    // first, try on references\n+    let xs = vec![\"Heart\", \"of\", \"Gold\"];\n+    let mut it = xs.into_iter().peekable();\n+    // try before `peek()`\n+    assert_eq!(it.next_if_eq(&\"trillian\"), None);\n+    assert_eq!(it.next_if_eq(&\"Heart\"), Some(\"Heart\"));\n+    // try after peek()\n+    assert_eq!(it.peek(), Some(&\"of\"));\n+    assert_eq!(it.next_if_eq(&\"of\"), Some(\"of\"));\n+    assert_eq!(it.next_if_eq(&\"zaphod\"), None);\n+    // make sure `next()` still behaves\n+    assert_eq!(it.next(), Some(\"Gold\"));\n+\n+    // make sure comparison works for owned values\n+    let xs = vec![String::from(\"Ludicrous\"), \"speed\".into()];\n+    let mut it = xs.into_iter().peekable();\n+    // make sure basic functionality works\n+    assert_eq!(it.next_if_eq(\"Ludicrous\"), Some(\"Ludicrous\".into()));\n+    assert_eq!(it.next_if_eq(\"speed\"), Some(\"speed\".into()));\n+    assert_eq!(it.next_if_eq(\"\"), None);\n+}\n+\n /// This is an iterator that follows the Iterator contract,\n /// but it is not fused. After having returned None once, it will start\n /// producing elements if .next() is called again.\n@@ -1932,6 +1956,21 @@ fn test_range() {\n     );\n }\n \n+#[test]\n+fn test_char_range() {\n+    use std::char;\n+    // Miri is too slow\n+    let from = if cfg!(miri) { char::from_u32(0xD800 - 10).unwrap() } else { '\\0' };\n+    let to = if cfg!(miri) { char::from_u32(0xDFFF + 10).unwrap() } else { char::MAX };\n+    assert!((from..=to).eq((from as u32..=to as u32).filter_map(char::from_u32)));\n+    assert!((from..=to).rev().eq((from as u32..=to as u32).filter_map(char::from_u32).rev()));\n+\n+    assert_eq!(('\\u{D7FF}'..='\\u{E000}').count(), 2);\n+    assert_eq!(('\\u{D7FF}'..='\\u{E000}').size_hint(), (2, Some(2)));\n+    assert_eq!(('\\u{D7FF}'..'\\u{E000}').count(), 1);\n+    assert_eq!(('\\u{D7FF}'..'\\u{E000}').size_hint(), (1, Some(1)));\n+}\n+\n #[test]\n fn test_range_exhaustion() {\n     let mut r = 10..10;"}, {"sha": "37ebf4112808e77ecfeb193acb91e3887ea5e28a", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -43,6 +43,7 @@\n #![feature(leading_trailing_ones)]\n #![feature(const_forget)]\n #![feature(option_unwrap_none)]\n+#![feature(peekable_next_if)]\n \n extern crate test;\n "}, {"sha": "e2ceaf80c0cda6770f30083a8d1bcdc05d70b61b", "filename": "src/libcore/time.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -152,7 +152,6 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n-    #[rustc_promotable]\n     #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     pub const fn from_secs(secs: u64) -> Duration {\n         Duration { secs, nanos: 0 }"}, {"sha": "1f812f8df6122092ceeb2026bb1ed045ac1889a6", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -327,8 +327,5 @@ pub unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send> {\n #[lang = \"eh_personality\"]\n #[cfg(not(test))]\n fn rust_eh_personality() {\n-    #[cfg_attr(not(bootstrap), allow(unused_unsafe))] // remove `unsafe` on bootstrap bump\n-    unsafe {\n-        core::intrinsics::abort()\n-    }\n+    core::intrinsics::abort()\n }"}, {"sha": "2d5bd7e872bd5923856cbb0dbfbf256f899ea4c3", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -39,6 +39,7 @@ mod diagnostic;\n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n pub use diagnostic::{Diagnostic, Level, MultiSpan};\n \n+use std::cmp::Ordering;\n use std::ops::{Bound, RangeBounds};\n use std::path::PathBuf;\n use std::str::FromStr;\n@@ -420,6 +421,20 @@ impl !Send for LineColumn {}\n #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n impl !Sync for LineColumn {}\n \n+#[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n+impl Ord for LineColumn {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.line.cmp(&other.line).then(self.column.cmp(&other.column))\n+    }\n+}\n+\n+#[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n+impl PartialOrd for LineColumn {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n /// The source file of a given `Span`.\n #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n #[derive(Clone)]"}, {"sha": "331b330cf29f06326d9c34b621cceb41c20d4465", "filename": "src/libproc_macro/tests/test.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibproc_macro%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibproc_macro%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Ftests%2Ftest.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -0,0 +1,12 @@\n+#![feature(proc_macro_span)]\n+\n+use proc_macro::LineColumn;\n+\n+#[test]\n+fn test_line_column_ord() {\n+    let line0_column0 = LineColumn { line: 0, column: 0 };\n+    let line0_column1 = LineColumn { line: 0, column: 1 };\n+    let line1_column0 = LineColumn { line: 1, column: 0 };\n+    assert!(line0_column0 < line0_column1);\n+    assert!(line0_column1 < line1_column0);\n+}"}, {"sha": "dfae956e2b6d53c15066faef640d9299345389c4", "filename": "src/librustc_arena/Cargo.toml", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_arena%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,11 +1,11 @@\n [package]\n authors = [\"The Rust Project Developers\"]\n-name = \"arena\"\n+name = \"rustc_arena\"\n version = \"0.0.0\"\n edition = \"2018\"\n \n [lib]\n-name = \"arena\"\n+name = \"rustc_arena\"\n path = \"lib.rs\"\n \n [dependencies]", "previous_filename": "src/libarena/Cargo.toml"}, {"sha": "4da336f8e288da9eb243b11dec0330e825e274ef", "filename": "src/librustc_arena/lib.rs", "status": "renamed", "additions": 39, "deletions": 47, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_arena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_arena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_arena%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -146,18 +146,18 @@ impl<T> TypedArena<T> {\n     }\n \n     #[inline]\n-    fn can_allocate(&self, len: usize) -> bool {\n-        let available_capacity_bytes = self.end.get() as usize - self.ptr.get() as usize;\n-        let at_least_bytes = len.checked_mul(mem::size_of::<T>()).unwrap();\n-        available_capacity_bytes >= at_least_bytes\n+    fn can_allocate(&self, additional: usize) -> bool {\n+        let available_bytes = self.end.get() as usize - self.ptr.get() as usize;\n+        let additional_bytes = additional.checked_mul(mem::size_of::<T>()).unwrap();\n+        available_bytes >= additional_bytes\n     }\n \n     /// Ensures there's enough space in the current chunk to fit `len` objects.\n     #[inline]\n-    fn ensure_capacity(&self, len: usize) {\n-        if !self.can_allocate(len) {\n-            self.grow(len);\n-            debug_assert!(self.can_allocate(len));\n+    fn ensure_capacity(&self, additional: usize) {\n+        if !self.can_allocate(additional) {\n+            self.grow(additional);\n+            debug_assert!(self.can_allocate(additional));\n         }\n     }\n \n@@ -214,36 +214,31 @@ impl<T> TypedArena<T> {\n     /// Grows the arena.\n     #[inline(never)]\n     #[cold]\n-    fn grow(&self, n: usize) {\n+    fn grow(&self, additional: usize) {\n         unsafe {\n-            // We need the element size in to convert chunk sizes (ranging from\n+            // We need the element size to convert chunk sizes (ranging from\n             // PAGE to HUGE_PAGE bytes) to element counts.\n             let elem_size = cmp::max(1, mem::size_of::<T>());\n             let mut chunks = self.chunks.borrow_mut();\n-            let (chunk, mut new_capacity);\n+            let mut new_cap;\n             if let Some(last_chunk) = chunks.last_mut() {\n                 let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n-                let currently_used_cap = used_bytes / mem::size_of::<T>();\n-                last_chunk.entries = currently_used_cap;\n-                if last_chunk.storage.reserve_in_place(currently_used_cap, n) {\n-                    self.end.set(last_chunk.end());\n-                    return;\n-                } else {\n-                    // If the previous chunk's capacity is less than HUGE_PAGE\n-                    // bytes, then this chunk will be least double the previous\n-                    // chunk's size.\n-                    new_capacity = last_chunk.storage.capacity();\n-                    if new_capacity < HUGE_PAGE / elem_size {\n-                        new_capacity = new_capacity.checked_mul(2).unwrap();\n-                    }\n+                last_chunk.entries = used_bytes / mem::size_of::<T>();\n+\n+                // If the previous chunk's capacity is less than HUGE_PAGE\n+                // bytes, then this chunk will be least double the previous\n+                // chunk's size.\n+                new_cap = last_chunk.storage.capacity();\n+                if new_cap < HUGE_PAGE / elem_size {\n+                    new_cap = new_cap.checked_mul(2).unwrap();\n                 }\n             } else {\n-                new_capacity = PAGE / elem_size;\n+                new_cap = PAGE / elem_size;\n             }\n-            // Also ensure that this chunk can fit `n`.\n-            new_capacity = cmp::max(n, new_capacity);\n+            // Also ensure that this chunk can fit `additional`.\n+            new_cap = cmp::max(additional, new_cap);\n \n-            chunk = TypedArenaChunk::<T>::new(new_capacity);\n+            let chunk = TypedArenaChunk::<T>::new(new_cap);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());\n             chunks.push(chunk);\n@@ -347,31 +342,28 @@ impl DroplessArena {\n \n     #[inline(never)]\n     #[cold]\n-    fn grow(&self, needed_bytes: usize) {\n+    fn grow(&self, additional: usize) {\n         unsafe {\n             let mut chunks = self.chunks.borrow_mut();\n-            let (chunk, mut new_capacity);\n+            let mut new_cap;\n             if let Some(last_chunk) = chunks.last_mut() {\n-                let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n-                if last_chunk.storage.reserve_in_place(used_bytes, needed_bytes) {\n-                    self.end.set(last_chunk.end());\n-                    return;\n-                } else {\n-                    // If the previous chunk's capacity is less than HUGE_PAGE\n-                    // bytes, then this chunk will be least double the previous\n-                    // chunk's size.\n-                    new_capacity = last_chunk.storage.capacity();\n-                    if new_capacity < HUGE_PAGE {\n-                        new_capacity = new_capacity.checked_mul(2).unwrap();\n-                    }\n+                // There is no need to update `last_chunk.entries` because that\n+                // field isn't used by `DroplessArena`.\n+\n+                // If the previous chunk's capacity is less than HUGE_PAGE\n+                // bytes, then this chunk will be least double the previous\n+                // chunk's size.\n+                new_cap = last_chunk.storage.capacity();\n+                if new_cap < HUGE_PAGE {\n+                    new_cap = new_cap.checked_mul(2).unwrap();\n                 }\n             } else {\n-                new_capacity = PAGE;\n+                new_cap = PAGE;\n             }\n-            // Also ensure that this chunk can fit `needed_bytes`.\n-            new_capacity = cmp::max(needed_bytes, new_capacity);\n+            // Also ensure that this chunk can fit `additional`.\n+            new_cap = cmp::max(additional, new_cap);\n \n-            chunk = TypedArenaChunk::<u8>::new(new_capacity);\n+            let chunk = TypedArenaChunk::<u8>::new(new_cap);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());\n             chunks.push(chunk);\n@@ -386,7 +378,7 @@ impl DroplessArena {\n             self.align(align);\n \n             let future_end = intrinsics::arith_offset(self.ptr.get(), bytes as isize);\n-            if (future_end as *mut u8) >= self.end.get() {\n+            if (future_end as *mut u8) > self.end.get() {\n                 self.grow(bytes);\n             }\n ", "previous_filename": "src/libarena/lib.rs"}, {"sha": "8e63bdf545841b727ff59e1dd41eb1430750c9d4", "filename": "src/librustc_arena/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_arena%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_arena%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_arena%2Ftests.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "previous_filename": "src/libarena/tests.rs"}, {"sha": "6bd65fd5f96c752831372875e11bfc7f92377e85", "filename": "src/librustc_ast/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n log = \"0.4\"\n scoped-tls = \"1.0\"\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "efcf95ec706b811b668971d22e60f9377bc1407c", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1006,11 +1006,12 @@ pub struct Expr {\n     pub kind: ExprKind,\n     pub span: Span,\n     pub attrs: AttrVec,\n+    pub tokens: Option<TokenStream>,\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-rustc_data_structures::static_assert_size!(Expr, 96);\n+rustc_data_structures::static_assert_size!(Expr, 104);\n \n impl Expr {\n     /// Returns `true` if this expression would be valid somewhere that expects a value;\n@@ -1251,7 +1252,7 @@ pub enum ExprKind {\n     Ret(Option<P<Expr>>),\n \n     /// Output of the `asm!()` macro.\n-    InlineAsm(InlineAsm),\n+    InlineAsm(P<InlineAsm>),\n     /// Output of the `llvm_asm!()` macro.\n     LlvmInlineAsm(P<LlvmInlineAsm>),\n \n@@ -1970,6 +1971,7 @@ pub struct InlineAsm {\n     pub template: Vec<InlineAsmTemplatePiece>,\n     pub operands: Vec<(InlineAsmOperand, Span)>,\n     pub options: InlineAsmOptions,\n+    pub line_spans: Vec<Span>,\n }\n \n /// Inline assembly dialect."}, {"sha": "7ececb814a6a3e567bce8ff994f473077ccafdb2", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1095,7 +1095,10 @@ pub fn noop_visit_anon_const<T: MutVisitor>(AnonConst { id, value }: &mut AnonCo\n     vis.visit_expr(value);\n }\n \n-pub fn noop_visit_expr<T: MutVisitor>(Expr { kind, id, span, attrs }: &mut Expr, vis: &mut T) {\n+pub fn noop_visit_expr<T: MutVisitor>(\n+    Expr { kind, id, span, attrs, tokens: _ }: &mut Expr,\n+    vis: &mut T,\n+) {\n     match kind {\n         ExprKind::Box(expr) => vis.visit_expr(expr),\n         ExprKind::Array(exprs) => visit_exprs(exprs, vis),"}, {"sha": "075aaa7e5bc013dd5b0d9744d6ec73efda73de18", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -21,6 +21,8 @@ use rustc_macros::HashStable_Generic;\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n+use log::debug;\n+\n use std::{iter, mem};\n \n /// When the main rust parser encounters a syntax-extension invocation, it\n@@ -338,8 +340,71 @@ impl TokenStream {\n             true\n         }\n \n-        let mut t1 = self.trees().filter(semantic_tree);\n-        let mut t2 = other.trees().filter(semantic_tree);\n+        // When comparing two `TokenStream`s, we ignore the `IsJoint` information.\n+        //\n+        // However, `rustc_parse::lexer::tokentrees::TokenStreamBuilder` will\n+        // use `Token.glue` on adjacent tokens with the proper `IsJoint`.\n+        // Since we are ignoreing `IsJoint`, a 'glued' token (e.g. `BinOp(Shr)`)\n+        // and its 'split'/'unglued' compoenents (e.g. `Gt, Gt`) are equivalent\n+        // when determining if two `TokenStream`s are 'probably equal'.\n+        //\n+        // Therefore, we use `break_two_token_op` to convert all tokens\n+        // to the 'unglued' form (if it exists). This ensures that two\n+        // `TokenStream`s which differ only in how their tokens are glued\n+        // will be considered 'probably equal', which allows us to keep spans.\n+        //\n+        // This is important when the original `TokenStream` contained\n+        // extra spaces (e.g. `f :: < Vec < _ > > ( ) ;'). These extra spaces\n+        // will be omitted when we pretty-print, which can cause the original\n+        // and reparsed `TokenStream`s to differ in the assignment of `IsJoint`,\n+        // leading to some tokens being 'glued' together in one stream but not\n+        // the other. See #68489 for more details.\n+        fn break_tokens(tree: TokenTree) -> impl Iterator<Item = TokenTree> {\n+            // In almost all cases, we should have either zero or one levels\n+            // of 'unglueing'. However, in some unusual cases, we may need\n+            // to iterate breaking tokens mutliple times. For example:\n+            // '[BinOpEq(Shr)] => [Gt, Ge] -> [Gt, Gt, Eq]'\n+            let mut token_trees: SmallVec<[_; 2]>;\n+            if let TokenTree::Token(token) = &tree {\n+                let mut out = SmallVec::<[_; 2]>::new();\n+                out.push(token.clone());\n+                // Iterate to fixpoint:\n+                // * We start off with 'out' containing our initial token, and `temp` empty\n+                // * If we are able to break any tokens in `out`, then `out` will have\n+                //   at least one more element than 'temp', so we will try to break tokens\n+                //   again.\n+                // * If we cannot break any tokens in 'out', we are done\n+                loop {\n+                    let mut temp = SmallVec::<[_; 2]>::new();\n+                    let mut changed = false;\n+\n+                    for token in out.into_iter() {\n+                        if let Some((first, second)) = token.kind.break_two_token_op() {\n+                            temp.push(Token::new(first, DUMMY_SP));\n+                            temp.push(Token::new(second, DUMMY_SP));\n+                            changed = true;\n+                        } else {\n+                            temp.push(token);\n+                        }\n+                    }\n+                    out = temp;\n+                    if !changed {\n+                        break;\n+                    }\n+                }\n+                token_trees = out.into_iter().map(|t| TokenTree::Token(t)).collect();\n+                if token_trees.len() != 1 {\n+                    debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n+                }\n+            } else {\n+                token_trees = SmallVec::new();\n+                token_trees.push(tree);\n+            }\n+            token_trees.into_iter()\n+        }\n+\n+        let mut t1 = self.trees().filter(semantic_tree).flat_map(break_tokens);\n+        let mut t2 = other.trees().filter(semantic_tree).flat_map(break_tokens);\n         for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n             if !t1.probably_equal_for_proc_macro(&t2) {\n                 return false;"}, {"sha": "d71eb4fcd5c275120fa6034099fef93464f821d4", "filename": "src/librustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-arena = { path = \"../libarena\" }\n+rustc_arena = { path = \"../librustc_arena\" }\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_hir = { path = \"../librustc_hir\" }"}, {"sha": "c9037da377ebb3d32f41b5d2ed5751647c0cf7a7", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -974,20 +974,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_expr_asm(&mut self, sp: Span, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n-        let asm_arch = if let Some(asm_arch) = self.sess.asm_arch {\n-            asm_arch\n-        } else {\n+        if self.sess.asm_arch.is_none() {\n             struct_span_err!(self.sess, sp, E0472, \"asm! is unsupported on this target\").emit();\n-            return hir::ExprKind::Err;\n-        };\n-        if asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-            match asm_arch {\n-                asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64 => {}\n-                _ => self\n-                    .sess\n-                    .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n-                    .emit(),\n-            }\n+        }\n+        if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n+            && !matches!(\n+                self.sess.asm_arch,\n+                Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64)\n+            )\n+        {\n+            self.sess\n+                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n+                .emit();\n         }\n \n         // Lower operands to HIR, filter_map skips any operands with invalid\n@@ -1001,10 +999,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     Some(match reg {\n                         InlineAsmRegOrRegClass::Reg(s) => asm::InlineAsmRegOrRegClass::Reg(\n                             asm::InlineAsmReg::parse(\n-                                asm_arch,\n-                                |feature| {\n-                                    self.sess.target_features.contains(&Symbol::intern(feature))\n-                                },\n+                                sess.asm_arch?,\n+                                |feature| sess.target_features.contains(&Symbol::intern(feature)),\n                                 s,\n                             )\n                             .map_err(|e| {\n@@ -1015,7 +1011,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ),\n                         InlineAsmRegOrRegClass::RegClass(s) => {\n                             asm::InlineAsmRegOrRegClass::RegClass(\n-                                asm::InlineAsmRegClass::parse(asm_arch, s)\n+                                asm::InlineAsmRegClass::parse(sess.asm_arch?, s)\n                                     .map_err(|e| {\n                                         let msg = format!(\n                                             \"invalid register class `{}`: {}\",\n@@ -1029,33 +1025,38 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n                     })\n                 };\n-                let op = match op {\n-                    InlineAsmOperand::In { reg, expr } => hir::InlineAsmOperand::In {\n-                        reg: lower_reg(*reg)?,\n+\n+                // lower_reg is executed last because we need to lower all\n+                // sub-expressions even if we throw them away later.\n+                let op = match *op {\n+                    InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n                         expr: self.lower_expr_mut(expr),\n+                        reg: lower_reg(reg)?,\n                     },\n-                    InlineAsmOperand::Out { reg, late, expr } => hir::InlineAsmOperand::Out {\n-                        reg: lower_reg(*reg)?,\n-                        late: *late,\n+                    InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                        late,\n                         expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                        reg: lower_reg(reg)?,\n                     },\n-                    InlineAsmOperand::InOut { reg, late, expr } => hir::InlineAsmOperand::InOut {\n-                        reg: lower_reg(*reg)?,\n-                        late: *late,\n-                        expr: self.lower_expr_mut(expr),\n-                    },\n-                    InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                    InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                        hir::InlineAsmOperand::InOut {\n+                            late,\n+                            expr: self.lower_expr_mut(expr),\n+                            reg: lower_reg(reg)?,\n+                        }\n+                    }\n+                    InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n-                            reg: lower_reg(*reg)?,\n-                            late: *late,\n+                            late,\n                             in_expr: self.lower_expr_mut(in_expr),\n                             out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                            reg: lower_reg(reg)?,\n                         }\n                     }\n-                    InlineAsmOperand::Const { expr } => {\n+                    InlineAsmOperand::Const { ref expr } => {\n                         hir::InlineAsmOperand::Const { expr: self.lower_expr_mut(expr) }\n                     }\n-                    InlineAsmOperand::Sym { expr } => {\n+                    InlineAsmOperand::Sym { ref expr } => {\n                         hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n                     }\n                 };\n@@ -1069,6 +1070,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n \n         // Validate template modifiers against the register classes for the operands\n+        let asm_arch = sess.asm_arch.unwrap();\n         for p in &asm.template {\n             if let InlineAsmTemplatePiece::Placeholder {\n                 operand_idx,\n@@ -1265,7 +1267,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let operands = self.arena.alloc_from_iter(operands);\n         let template = self.arena.alloc_from_iter(asm.template.iter().cloned());\n-        let hir_asm = hir::InlineAsm { template, operands, options: asm.options };\n+        let line_spans = self.arena.alloc_slice(&asm.line_spans[..]);\n+        let hir_asm = hir::InlineAsm { template, operands, options: asm.options, line_spans };\n         hir::ExprKind::InlineAsm(self.arena.alloc(hir_asm))\n     }\n "}, {"sha": "47d10f86d03e27550d2a33e89bcce69c55d9c22c", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1321,12 +1321,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                     .get_partial_res(bound_pred.bounded_ty.id)\n                                     .map(|d| d.base_res())\n                                 {\n-                                    if let Some(node_id) =\n-                                        self.resolver.definitions().as_local_node_id(def_id)\n-                                    {\n+                                    if let Some(def_id) = def_id.as_local() {\n                                         for param in &generics.params {\n                                             if let GenericParamKind::Type { .. } = param.kind {\n-                                                if node_id == param.id {\n+                                                if def_id\n+                                                    == self\n+                                                        .resolver\n+                                                        .definitions()\n+                                                        .local_def_id(param.id)\n+                                                {\n                                                     add_bounds\n                                                         .entry(param.id)\n                                                         .or_default()"}, {"sha": "1f8c68f75e943bc62d7aae4cb73c52208b34306c", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -85,7 +85,7 @@ mod path;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n-rustc_hir::arena_types!(::arena::declare_arena, [], 'tcx);\n+rustc_hir::arena_types!(rustc_arena::declare_arena, [], 'tcx);\n \n struct LoweringContext<'a, 'hir: 'a> {\n     crate_root: Option<Symbol>,\n@@ -269,7 +269,7 @@ pub fn lower_crate<'a, 'hir>(\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n     LoweringContext {\n-        crate_root: sess.parse_sess.injected_crate_name.try_get().copied(),\n+        crate_root: sess.parse_sess.injected_crate_name.get().copied(),\n         sess,\n         resolver,\n         nt_to_tokenstream,\n@@ -688,7 +688,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> Span {\n         span.fresh_expansion(ExpnData {\n             allow_internal_unstable,\n-            ..ExpnData::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n+            ..ExpnData::default(ExpnKind::Desugaring(reason), span, self.sess.edition(), None)\n         })\n     }\n \n@@ -1126,6 +1126,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 kind: ExprKind::Path(qself.clone(), path.clone()),\n                                 span: ty.span,\n                                 attrs: AttrVec::new(),\n+                                tokens: None,\n                             };\n \n                             let ct = self.with_new_scopes(|this| hir::AnonConst {"}, {"sha": "55c1f8026633702acdff8688200a5d4793cf0c7d", "filename": "src/librustc_ast_lowering/pat.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -3,6 +3,7 @@ use super::{ImplTraitContext, LoweringContext, ParamMode};\n use rustc_ast::ast::*;\n use rustc_ast::ptr::P;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n+use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_span::symbol::Ident;\n@@ -102,10 +103,36 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // Note that unlike for slice patterns,\n             // where `xs @ ..` is a legal sub-slice pattern,\n             // it is not a legal sub-tuple pattern.\n-            if pat.is_rest() {\n-                rest = Some((idx, pat.span));\n-                break;\n+            match pat.kind {\n+                // Found a sub-tuple rest pattern\n+                PatKind::Rest => {\n+                    rest = Some((idx, pat.span));\n+                    break;\n+                }\n+                // Found a sub-tuple pattern `$binding_mode $ident @ ..`.\n+                // This is not allowed as a sub-tuple pattern\n+                PatKind::Ident(ref _bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    rest = Some((idx, pat.span));\n+                    let sp = pat.span;\n+                    self.diagnostic()\n+                        .struct_span_err(\n+                            sp,\n+                            &format!(\"`{} @` is not allowed in a {}\", ident.name, ctx),\n+                        )\n+                        .span_label(sp, \"this is only allowed in slice patterns\")\n+                        .help(\"remove this and bind each tuple field independently\")\n+                        .span_suggestion_verbose(\n+                            sp,\n+                            &format!(\"if you don't need to use the contents of {}, discard the tuple's remaining fields\", ident),\n+                            \"..\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                    break;\n+                }\n+                _ => {}\n             }\n+\n             // It was not a sub-tuple pattern so lower it normally.\n             elems.push(self.lower_pat(pat));\n         }"}, {"sha": "677796a8df0b37a89cc427c8754d7b8b190df517", "filename": "src/librustc_attr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_attr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_attr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -12,7 +12,7 @@ doctest = false\n \n [dependencies]\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "fdb6c359052d0b467f606b1fa2d8bc01e87f04a9", "filename": "src/librustc_builtin_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-fmt_macros = { path = \"../libfmt_macros\" }\n+rustc_parse_format = { path = \"../librustc_parse_format\" }\n log = \"0.4\"\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_attr = { path = \"../librustc_attr\" }"}, {"sha": "aabd5b5b5c31b31075cd5e649fb8f0470023aaf4", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,5 +1,3 @@\n-use fmt_macros as parse;\n-\n use rustc_ast::ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n@@ -8,6 +6,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_expand::base::{self, *};\n use rustc_parse::parser::Parser;\n+use rustc_parse_format as parse;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{InnerSpan, Span};\n \n@@ -33,7 +32,10 @@ fn parse_args<'a>(\n \n     // Detect use of the legacy llvm_asm! syntax (which used to be called asm!)\n     if p.look_ahead(1, |t| *t == token::Colon || *t == token::ModSep) {\n-        let mut err = ecx.struct_span_err(sp, \"legacy asm! syntax is no longer supported\");\n+        let mut err =\n+            ecx.struct_span_err(sp, \"the legacy LLVM-style asm! syntax is no longer supported\");\n+        err.note(\"consider migrating to the new asm! syntax specified in RFC 2873\");\n+        err.note(\"alternatively, switch to llvm_asm! to keep your code working as it is\");\n \n         // Find the span of the \"asm!\" so that we can offer an automatic suggestion\n         let asm_span = sp.from_inner(InnerSpan::new(0, 4));\n@@ -513,12 +515,19 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n         }\n     }\n \n-    let inline_asm = ast::InlineAsm { template, operands, options: args.options };\n+    let line_spans = if parser.line_spans.is_empty() {\n+        vec![template_sp]\n+    } else {\n+        parser.line_spans.iter().map(|span| template_span.from_inner(*span)).collect()\n+    };\n+\n+    let inline_asm = ast::InlineAsm { template, operands, options: args.options, line_spans };\n     P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        kind: ast::ExprKind::InlineAsm(inline_asm),\n+        kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n         span: sp,\n         attrs: ast::AttrVec::new(),\n+        tokens: None,\n     })\n }\n "}, {"sha": "fdf05ac3880b5c60c16b72e4d971c2508f70ecdf", "filename": "src/librustc_builtin_macros/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fconcat_idents.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -52,6 +52,7 @@ pub fn expand_concat_idents<'cx>(\n                 kind: ast::ExprKind::Path(None, ast::Path::from_ident(self.ident)),\n                 span: self.ident.span,\n                 attrs: ast::AttrVec::new(),\n+                tokens: None,\n             }))\n         }\n "}, {"sha": "d769ebb1f5520d621ef27b299eccee1217607d49", "filename": "src/librustc_builtin_macros/env.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fenv.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -77,6 +77,7 @@ pub fn expand_env<'cx>(\n         return DummyResult::any(sp);\n     }\n \n+    let sp = cx.with_def_site_ctxt(sp);\n     let e = match env::var(&*var.as_str()) {\n         Err(_) => {\n             cx.span_err(sp, &msg.as_str());"}, {"sha": "e574b076bf84c8d68ba8cd9e79e0606448c6167e", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,15 +1,14 @@\n use ArgumentType::*;\n use Position::*;\n \n-use fmt_macros as parse;\n-\n use rustc_ast::ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, Applicability, DiagnosticBuilder};\n use rustc_expand::base::{self, *};\n+use rustc_parse_format as parse;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span};\n "}, {"sha": "0f4efc153b941712f2db69dd217e1f2f6248ca02", "filename": "src/librustc_builtin_macros/llvm_asm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2Fllvm_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_builtin_macros%2Fllvm_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fllvm_asm.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -61,6 +61,7 @@ pub fn expand_llvm_asm<'cx>(\n         kind: ast::ExprKind::LlvmInlineAsm(P(inline_asm)),\n         span: cx.with_def_site_ctxt(sp),\n         attrs: ast::AttrVec::new(),\n+        tokens: None,\n     }))\n }\n "}, {"sha": "bedefcc30ed8c2a7b4b0533a3fca8bd06056808d", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -29,7 +29,7 @@ rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_session = { path = \"../librustc_session\" }\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "9d4a30f23a20934286ffa491a4710f098da2de78", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_middle::span_bug;\n use rustc_middle::ty::layout::TyAndLayout;\n-use rustc_span::Span;\n+use rustc_span::{Pos, Span};\n use rustc_target::abi::*;\n use rustc_target::asm::*;\n \n@@ -97,7 +97,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             ia.volatile,\n             ia.alignstack,\n             ia.dialect,\n-            span,\n+            &[span],\n         );\n         if r.is_none() {\n             return false;\n@@ -119,7 +119,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         template: &[InlineAsmTemplatePiece],\n         operands: &[InlineAsmOperandRef<'tcx, Self>],\n         options: InlineAsmOptions,\n-        span: Span,\n+        line_spans: &[Span],\n     ) {\n         let asm_arch = self.tcx.sess.asm_arch.unwrap();\n \n@@ -254,6 +254,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     ]);\n                 }\n                 InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {}\n+                InlineAsmArch::Nvptx64 => {}\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -286,9 +287,9 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             volatile,\n             alignstack,\n             dialect,\n-            span,\n+            line_spans,\n         )\n-        .unwrap_or_else(|| span_bug!(span, \"LLVM asm constraint validation failed\"));\n+        .unwrap_or_else(|| span_bug!(line_spans[0], \"LLVM asm constraint validation failed\"));\n \n         if options.contains(InlineAsmOptions::PURE) {\n             if options.contains(InlineAsmOptions::NOMEM) {\n@@ -340,7 +341,7 @@ fn inline_asm_call(\n     volatile: bool,\n     alignstack: bool,\n     dia: LlvmAsmDialect,\n-    span: Span,\n+    line_spans: &[Span],\n ) -> Option<&'ll Value> {\n     let volatile = if volatile { llvm::True } else { llvm::False };\n     let alignstack = if alignstack { llvm::True } else { llvm::False };\n@@ -381,8 +382,24 @@ fn inline_asm_call(\n                 key.len() as c_uint,\n             );\n \n-            let val: &'ll Value = bx.const_i32(span.ctxt().outer_expn().as_u32() as i32);\n-            llvm::LLVMSetMetadata(call, kind, llvm::LLVMMDNodeInContext(bx.llcx, &val, 1));\n+            // srcloc contains one integer for each line of assembly code.\n+            // Unfortunately this isn't enough to encode a full span so instead\n+            // we just encode the start position of each line.\n+            // FIXME: Figure out a way to pass the entire line spans.\n+            let mut srcloc = vec![];\n+            if dia == LlvmAsmDialect::Intel && line_spans.len() > 1 {\n+                // LLVM inserts an extra line to add the \".intel_syntax\", so add\n+                // a dummy srcloc entry for it.\n+                //\n+                // Don't do this if we only have 1 line span since that may be\n+                // due to the asm template string coming from a macro. LLVM will\n+                // default to the first srcloc for lines that don't have an\n+                // associated srcloc.\n+                srcloc.push(bx.const_i32(0));\n+            }\n+            srcloc.extend(line_spans.iter().map(|span| bx.const_i32(span.lo().to_u32() as i32)));\n+            let md = llvm::LLVMMDNodeInContext(bx.llcx, srcloc.as_ptr(), srcloc.len() as u32);\n+            llvm::LLVMSetMetadata(call, kind, md);\n \n             Some(call)\n         } else {\n@@ -410,6 +427,9 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass) -> String {\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => \"x\",\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"w\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => \"r\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => \"l\",\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n@@ -452,6 +472,7 @@ fn modifier_to_llvm(\n                 modifier\n             }\n         }\n+        InlineAsmRegClass::Nvptx(_) => None,\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n         | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n@@ -502,6 +523,9 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n             cx.type_vector(cx.type_i64(), 2)\n         }\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)"}, {"sha": "a4e17a5f675be355115099f04ec98899bf38bb01", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -367,8 +367,8 @@ pub fn provide(providers: &mut Providers<'_>) {\n \n pub fn provide_extern(providers: &mut Providers<'_>) {\n     providers.wasm_import_module_map = |tcx, cnum| {\n-        // Build up a map from DefId to a `NativeLibrary` structure, where\n-        // `NativeLibrary` internally contains information about\n+        // Build up a map from DefId to a `NativeLib` structure, where\n+        // `NativeLib` internally contains information about\n         // `#[link(wasm_import_module = \"...\")]` for example.\n         let native_libs = tcx.native_libraries(cnum);\n "}, {"sha": "02a9294930d2b12bb7ee652f63c7120ba6275d75", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -6,7 +6,6 @@ use crate::back::profiling::{\n use crate::base;\n use crate::common;\n use crate::consts;\n-use crate::context::all_outputs_are_pic_executables;\n use crate::llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic};\n use crate::llvm_util;\n use crate::type_::Type;\n@@ -24,6 +23,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, Lto, OutputType, Passes, Sanitizer, SwitchWithOptPath};\n use rustc_session::Session;\n+use rustc_span::InnerSpan;\n use rustc_target::spec::{CodeModel, RelocModel};\n \n use libc::{c_char, c_int, c_uint, c_void, size_t};\n@@ -150,7 +150,6 @@ pub fn target_machine_factory(\n     let features = features.join(\",\");\n     let features = CString::new(features).unwrap();\n     let abi = SmallCStr::new(&sess.target.target.options.llvm_abiname);\n-    let pic_is_pie = all_outputs_are_pic_executables(sess);\n     let trap_unreachable = sess.target.target.options.trap_unreachable;\n     let emit_stack_size_section = sess.opts.debugging_opts.emit_stack_sizes;\n \n@@ -174,7 +173,6 @@ pub fn target_machine_factory(\n                 reloc_model,\n                 opt_level,\n                 use_softfp,\n-                pic_is_pie,\n                 ffunction_sections,\n                 fdata_sections,\n                 trap_unreachable,\n@@ -241,12 +239,19 @@ impl<'a> Drop for DiagnosticHandlers<'a> {\n     }\n }\n \n-unsafe extern \"C\" fn report_inline_asm(\n+fn report_inline_asm(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n-    msg: &str,\n-    cookie: c_uint,\n+    msg: String,\n+    mut cookie: c_uint,\n+    source: Option<(String, Vec<InnerSpan>)>,\n ) {\n-    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_owned());\n+    // In LTO build we may get srcloc values from other crates which are invalid\n+    // since they use a different source map. To be safe we just suppress these\n+    // in LTO builds.\n+    if matches!(cgcx.lto, Lto::Fat | Lto::Thin) {\n+        cookie = 0;\n+    }\n+    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg, source);\n }\n \n unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic, user: *const c_void, cookie: c_uint) {\n@@ -255,10 +260,37 @@ unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic, user: *const c_void\n     }\n     let (cgcx, _) = *(user as *const (&CodegenContext<LlvmCodegenBackend>, &Handler));\n \n-    let msg = llvm::build_string(|s| llvm::LLVMRustWriteSMDiagnosticToString(diag, s))\n-        .expect(\"non-UTF8 SMDiagnostic\");\n+    // Recover the post-substitution assembly code from LLVM for better\n+    // diagnostics.\n+    let mut have_source = false;\n+    let mut buffer = String::new();\n+    let mut loc = 0;\n+    let mut ranges = [0; 8];\n+    let mut num_ranges = ranges.len() / 2;\n+    let msg = llvm::build_string(|msg| {\n+        buffer = llvm::build_string(|buffer| {\n+            have_source = llvm::LLVMRustUnpackSMDiagnostic(\n+                diag,\n+                msg,\n+                buffer,\n+                &mut loc,\n+                ranges.as_mut_ptr(),\n+                &mut num_ranges,\n+            );\n+        })\n+        .expect(\"non-UTF8 inline asm\");\n+    })\n+    .expect(\"non-UTF8 SMDiagnostic\");\n+\n+    let source = have_source.then(|| {\n+        let mut spans = vec![InnerSpan::new(loc as usize, loc as usize)];\n+        for i in 0..num_ranges {\n+            spans.push(InnerSpan::new(ranges[i * 2] as usize, ranges[i * 2 + 1] as usize));\n+        }\n+        (buffer, spans)\n+    });\n \n-    report_inline_asm(cgcx, &msg, cookie);\n+    report_inline_asm(cgcx, msg, cookie, source);\n }\n \n unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void) {\n@@ -269,7 +301,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {\n-            report_inline_asm(cgcx, &llvm::twine_to_string(inline.message), inline.cookie);\n+            report_inline_asm(cgcx, llvm::twine_to_string(inline.message), inline.cookie, None);\n         }\n \n         llvm::diagnostic::Optimization(opt) => {"}, {"sha": "3e17a51528e3eb70a368c9855e4023fc658b5f15", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -100,7 +100,7 @@ pub fn compile_codegen_unit(\n     tcx: TyCtxt<'tcx>,\n     cgu_name: Symbol,\n ) -> (ModuleCodegen<ModuleLlvm>, u64) {\n-    let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n+    let prof_timer = tcx.prof.generic_activity_with_arg(\"codegen_module\", cgu_name.to_string());\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);"}, {"sha": "a5cda5949eec3971d737d39b56ea4fc280613da1", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -259,6 +259,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     GlobalAlloc::Function(fn_instance) => self.get_fn_addr(fn_instance),\n                     GlobalAlloc::Static(def_id) => {\n                         assert!(self.tcx.is_static(def_id));\n+                        assert!(!self.tcx.is_thread_local_static(def_id));\n                         self.get_static(def_id)\n                     }\n                 };"}, {"sha": "4c810a37d418068bf441597173d9c69bd7f6649f", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -97,17 +97,6 @@ fn to_llvm_tls_model(tls_model: TlsModel) -> llvm::ThreadLocalMode {\n     }\n }\n \n-/// PIE is potentially more effective than PIC, but can only be used in executables.\n-/// If all our outputs are executables, then we can relax PIC to PIE when producing object code.\n-/// If the list of crate types is not yet known we conservatively return `false`.\n-pub fn all_outputs_are_pic_executables(sess: &Session) -> bool {\n-    sess.relocation_model() == RelocModel::Pic\n-        && sess\n-            .crate_types\n-            .try_get()\n-            .map_or(false, |crate_types| crate_types.iter().all(|ty| *ty == CrateType::Executable))\n-}\n-\n fn strip_function_ptr_alignment(data_layout: String) -> String {\n     // FIXME: Make this more general.\n     data_layout.replace(\"-Fi8-\", \"-\")\n@@ -183,10 +172,11 @@ pub unsafe fn create_module(\n \n     if sess.relocation_model() == RelocModel::Pic {\n         llvm::LLVMRustSetModulePICLevel(llmod);\n-    }\n-\n-    if all_outputs_are_pic_executables(sess) {\n-        llvm::LLVMRustSetModulePIELevel(llmod);\n+        // PIE is potentially more effective than PIC, but can only be used in executables.\n+        // If all our outputs are executables, then we can relax PIC to PIE.\n+        if sess.crate_types().iter().all(|ty| *ty == CrateType::Executable) {\n+            llvm::LLVMRustSetModulePIELevel(llmod);\n+        }\n     }\n \n     // If skipping the PLT is enabled, we need to add some module metadata"}, {"sha": "333eb805221ff0fda5ec6b462fde4dd76a60c0b2", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -447,7 +447,6 @@ fn subroutine_type_metadata(\n         unsafe {\n             llvm::LLVMRustDIBuilderCreateSubroutineType(\n                 DIB(cx),\n-                unknown_file_metadata(cx),\n                 create_DIArray(DIB(cx), &signature_metadata[..]),\n             )\n         },\n@@ -635,14 +634,12 @@ pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Sp\n                     // anything reading the debuginfo for a recursive\n                     // type is going to see *something* weird - the only\n                     // question is what exactly it will see.\n-                    let (size, align) = cx.size_and_align_of(t);\n                     let name = \"<recur_type>\";\n                     llvm::LLVMRustDIBuilderCreateBasicType(\n                         DIB(cx),\n                         name.as_ptr().cast(),\n                         name.len(),\n-                        size.bits(),\n-                        align.bits() as u32,\n+                        cx.size_of(t).bits(),\n                         DW_ATE_unsigned,\n                     )\n                 }\n@@ -841,14 +838,12 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n         _ => bug!(\"debuginfo::basic_type_metadata - `t` is invalid type\"),\n     };\n \n-    let (size, align) = cx.size_and_align_of(t);\n     let ty_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateBasicType(\n             DIB(cx),\n             name.as_ptr().cast(),\n             name.len(),\n-            size.bits(),\n-            align.bits() as u32,\n+            cx.size_of(t).bits(),\n             encoding,\n         )\n     };\n@@ -964,16 +959,16 @@ pub fn compile_unit_metadata(\n         if tcx.sess.opts.debugging_opts.profile {\n             let cu_desc_metadata =\n                 llvm::LLVMRustMetadataAsValue(debug_context.llcontext, unit_metadata);\n+            let default_gcda_path = &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcda\");\n+            let gcda_path =\n+                tcx.sess.opts.debugging_opts.profile_emit.as_ref().unwrap_or(default_gcda_path);\n \n             let gcov_cu_info = [\n                 path_to_mdstring(\n                     debug_context.llcontext,\n                     &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcno\"),\n                 ),\n-                path_to_mdstring(\n-                    debug_context.llcontext,\n-                    &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcda\"),\n-                ),\n+                path_to_mdstring(debug_context.llcontext, &gcda_path),\n                 cu_desc_metadata,\n             ];\n             let gcov_metadata = llvm::LLVMMDNodeInContext(\n@@ -2187,9 +2182,6 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'\n                                 name.as_ptr().cast(),\n                                 name.len(),\n                                 actual_type_metadata,\n-                                unknown_file_metadata(cx),\n-                                0,\n-                                0,\n                             ))\n                         })\n                     } else {"}, {"sha": "8c580847ef8fdad866019975ef219134b26efa0a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -252,7 +252,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         let function_type_metadata = unsafe {\n             let fn_signature = get_function_signature(self, fn_abi);\n-            llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(self), file_metadata, fn_signature)\n+            llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(self), fn_signature)\n         };\n \n         // Find the enclosing function, in case this is a closure.\n@@ -265,8 +265,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         // name if necessary.\n         let generics = self.tcx().generics_of(enclosing_fn_def_id);\n         let substs = instance.substs.truncate_to(self.tcx(), generics);\n-        let template_parameters =\n-            get_template_parameters(self, &generics, substs, file_metadata, &mut name);\n+        let template_parameters = get_template_parameters(self, &generics, substs, &mut name);\n \n         // Get the linkage_name, which is just the symbol name\n         let linkage_name = mangled_name_of_instance(self, instance);\n@@ -388,7 +387,6 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             cx: &CodegenCx<'ll, 'tcx>,\n             generics: &ty::Generics,\n             substs: SubstsRef<'tcx>,\n-            file_metadata: &'ll DIFile,\n             name_to_append_suffix_to: &mut String,\n         ) -> &'ll DIArray {\n             if substs.types().next().is_none() {\n@@ -429,9 +427,6 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                                     name.as_ptr().cast(),\n                                     name.len(),\n                                     actual_type_metadata,\n-                                    file_metadata,\n-                                    0,\n-                                    0,\n                                 ))\n                             })\n                         } else {"}, {"sha": "759c2bf1b85f4f5cb4efcc048e8703652a1277d6", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1655,7 +1655,6 @@ extern \"C\" {\n \n     pub fn LLVMRustDIBuilderCreateSubroutineType(\n         Builder: &DIBuilder<'a>,\n-        File: &'a DIFile,\n         ParameterTypes: &'a DIArray,\n     ) -> &'a DICompositeType;\n \n@@ -1682,7 +1681,6 @@ extern \"C\" {\n         Name: *const c_char,\n         NameLen: size_t,\n         SizeInBits: u64,\n-        AlignInBits: u32,\n         Encoding: c_uint,\n     ) -> &'a DIBasicType;\n \n@@ -1880,9 +1878,6 @@ extern \"C\" {\n         Name: *const c_char,\n         NameLen: size_t,\n         Ty: &'a DIType,\n-        File: &'a DIFile,\n-        LineNo: c_uint,\n-        ColumnNo: c_uint,\n     ) -> &'a DITemplateTypeParameter;\n \n     pub fn LLVMRustDIBuilderCreateNameSpace(\n@@ -1948,7 +1943,6 @@ extern \"C\" {\n         Reloc: RelocModel,\n         Level: CodeGenOptLevel,\n         UseSoftFP: bool,\n-        PositionIndependentExecutable: bool,\n         FunctionSections: bool,\n         DataSections: bool,\n         TrapUnreachable: bool,\n@@ -2076,7 +2070,14 @@ extern \"C\" {\n     );\n \n     #[allow(improper_ctypes)]\n-    pub fn LLVMRustWriteSMDiagnosticToString(d: &SMDiagnostic, s: &RustString);\n+    pub fn LLVMRustUnpackSMDiagnostic(\n+        d: &SMDiagnostic,\n+        message_out: &RustString,\n+        buffer_out: &RustString,\n+        loc_out: &mut c_uint,\n+        ranges_out: *mut c_uint,\n+        num_ranges: &mut usize,\n+    ) -> bool;\n \n     pub fn LLVMRustWriteArchive(\n         Dst: *const c_char,"}, {"sha": "67a2251e8593ebb8ff211a0f0c315f1e18ce0424", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -170,6 +170,7 @@ const AARCH64_WHITELIST: &[(&str, Option<Symbol>)] = &[\n     (\"fp16\", Some(sym::aarch64_target_feature)),\n     (\"rcpc\", Some(sym::aarch64_target_feature)),\n     (\"dotprod\", Some(sym::aarch64_target_feature)),\n+    (\"tme\", Some(sym::aarch64_target_feature)),\n     (\"v8.1a\", Some(sym::aarch64_target_feature)),\n     (\"v8.2a\", Some(sym::aarch64_target_feature)),\n     (\"v8.3a\", Some(sym::aarch64_target_feature)),"}, {"sha": "eeb6b4aabcf29c8e83a9e633cd3188102d293f94", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -19,7 +19,7 @@ libc = \"0.2.50\"\n jobserver = \"0.1.11\"\n tempfile = \"3.1\"\n \n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_middle = { path = \"../librustc_middle\" }"}, {"sha": "53e3da3c0baf0bc40c0e111e71c6b23d029d079a", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 95, "deletions": 73, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,17 +1,18 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n-use rustc_middle::middle::cstore::{EncodedMetadata, LibSource, NativeLibrary, NativeLibraryKind};\n+use rustc_middle::middle::cstore::{EncodedMetadata, LibSource, NativeLib};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo};\n use rustc_session::config::{OutputFilenames, OutputType, PrintRequest, Sanitizer};\n use rustc_session::output::{check_file_is_writeable, invalid_output_for_target, out_filename};\n use rustc_session::search_paths::PathKind;\n+use rustc_session::utils::NativeLibKind;\n /// For all the linkers we support, and information they might\n /// need out of the shared crate context before we get rid of it.\n use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n-use rustc_target::spec::crt_objects::CrtObjectsFallback;\n+use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel};\n \n@@ -24,16 +25,10 @@ use crate::{looks_like_rust_object_file, CodegenResults, CrateInfo, METADATA_FIL\n use cc::windows_registry;\n use tempfile::{Builder as TempFileBuilder, TempDir};\n \n-use std::ascii;\n-use std::char;\n-use std::env;\n use std::ffi::OsString;\n-use std::fmt;\n-use std::fs;\n-use std::io;\n use std::path::{Path, PathBuf};\n use std::process::{ExitStatus, Output, Stdio};\n-use std::str;\n+use std::{ascii, char, env, fmt, fs, io, mem, str};\n \n pub fn remove(sess: &Session, path: &Path) {\n     if let Err(e) = fs::remove_file(path) {\n@@ -52,7 +47,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n ) {\n     let _timer = sess.timer(\"link_binary\");\n     let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n-    for &crate_type in sess.crate_types.borrow().iter() {\n+    for &crate_type in sess.crate_types().iter() {\n         // Ignore executable crates if we have -Z no-codegen, as they will error.\n         if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen())\n             && !output_metadata\n@@ -183,6 +178,7 @@ fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> Command {\n                     \"x86_64\" => Some(\"x64\".to_string()),\n                     \"x86\" => Some(\"x86\".to_string()),\n                     \"aarch64\" => Some(\"arm64\".to_string()),\n+                    \"arm\" => Some(\"arm\".to_string()),\n                     _ => None,\n                 };\n                 if let Some(ref a) = arch {\n@@ -327,11 +323,12 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     // metadata of the rlib we're generating somehow.\n     for lib in codegen_results.crate_info.used_libraries.iter() {\n         match lib.kind {\n-            NativeLibraryKind::NativeStatic => {}\n-            NativeLibraryKind::NativeStaticNobundle\n-            | NativeLibraryKind::NativeFramework\n-            | NativeLibraryKind::NativeRawDylib\n-            | NativeLibraryKind::NativeUnknown => continue,\n+            NativeLibKind::StaticBundle => {}\n+            NativeLibKind::StaticNoBundle\n+            | NativeLibKind::Dylib\n+            | NativeLibKind::Framework\n+            | NativeLibKind::RawDylib\n+            | NativeLibKind::Unspecified => continue,\n         }\n         if let Some(name) = lib.name {\n             ab.add_native_library(name);\n@@ -430,7 +427,7 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n         // object files come from where and selectively skip them.\n         let skip_object_files = native_libs\n             .iter()\n-            .any(|lib| lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib));\n+            .any(|lib| lib.kind == NativeLibKind::StaticBundle && !relevant_lib(sess, lib));\n         ab.add_rlib(\n             path,\n             &name.as_str(),\n@@ -540,6 +537,61 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n             continue;\n         }\n \n+        // Detect '-static-pie' used with an older version of gcc or clang not supporting it.\n+        // Fallback from '-static-pie' to '-static' in that case.\n+        if sess.target.target.options.linker_is_gnu\n+            && flavor != LinkerFlavor::Ld\n+            && (out.contains(\"unrecognized command line option\")\n+                || out.contains(\"unknown argument\"))\n+            && (out.contains(\"-static-pie\") || out.contains(\"--no-dynamic-linker\"))\n+            && cmd.get_args().iter().any(|e| e.to_string_lossy() == \"-static-pie\")\n+        {\n+            info!(\"linker output: {:?}\", out);\n+            warn!(\n+                \"Linker does not support -static-pie command line option. Retrying with -static instead.\"\n+            );\n+            // Mirror `add_(pre,post)_link_objects` to replace CRT objects.\n+            let fallback = crt_objects_fallback(sess, crate_type);\n+            let opts = &sess.target.target.options;\n+            let pre_objects =\n+                if fallback { &opts.pre_link_objects_fallback } else { &opts.pre_link_objects };\n+            let post_objects =\n+                if fallback { &opts.post_link_objects_fallback } else { &opts.post_link_objects };\n+            let get_objects = |objects: &CrtObjects, kind| {\n+                objects\n+                    .get(&kind)\n+                    .iter()\n+                    .copied()\n+                    .flatten()\n+                    .map(|obj| get_object_file_path(sess, obj).into_os_string())\n+                    .collect::<Vec<_>>()\n+            };\n+            let pre_objects_static_pie = get_objects(pre_objects, LinkOutputKind::StaticPicExe);\n+            let post_objects_static_pie = get_objects(post_objects, LinkOutputKind::StaticPicExe);\n+            let mut pre_objects_static = get_objects(pre_objects, LinkOutputKind::StaticNoPicExe);\n+            let mut post_objects_static = get_objects(post_objects, LinkOutputKind::StaticNoPicExe);\n+            // Assume that we know insertion positions for the replacement arguments from replaced\n+            // arguments, which is true for all supported targets.\n+            assert!(pre_objects_static.is_empty() || !pre_objects_static_pie.is_empty());\n+            assert!(post_objects_static.is_empty() || !post_objects_static_pie.is_empty());\n+            for arg in cmd.take_args() {\n+                if arg.to_string_lossy() == \"-static-pie\" {\n+                    // Replace the output kind.\n+                    cmd.arg(\"-static\");\n+                } else if pre_objects_static_pie.contains(&arg) {\n+                    // Replace the pre-link objects (replace the first and remove the rest).\n+                    cmd.args(mem::take(&mut pre_objects_static));\n+                } else if post_objects_static_pie.contains(&arg) {\n+                    // Replace the post-link objects (replace the first and remove the rest).\n+                    cmd.args(mem::take(&mut post_objects_static));\n+                } else {\n+                    cmd.arg(arg);\n+                }\n+            }\n+            info!(\"{:?}\", &cmd);\n+            continue;\n+        }\n+\n         // Here's a terribly awful hack that really shouldn't be present in any\n         // compiler. Here an environment variable is supported to automatically\n         // retry the linker invocation if the linker looks like it segfaulted.\n@@ -872,11 +924,8 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n \n     // If we're only producing artifacts that are archives, no need to preserve\n     // the objects as they're losslessly contained inside the archives.\n-    let output_linked = sess\n-        .crate_types\n-        .borrow()\n-        .iter()\n-        .any(|&x| x != CrateType::Rlib && x != CrateType::Staticlib);\n+    let output_linked =\n+        sess.crate_types().iter().any(|&x| x != CrateType::Rlib && x != CrateType::Staticlib);\n     if !output_linked {\n         return false;\n     }\n@@ -907,26 +956,28 @@ enum RlibFlavor {\n     StaticlibBase,\n }\n \n-fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n+fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n     let lib_args: Vec<_> = all_native_libs\n         .iter()\n         .filter(|l| relevant_lib(sess, l))\n         .filter_map(|lib| {\n             let name = lib.name?;\n             match lib.kind {\n-                NativeLibraryKind::NativeStaticNobundle | NativeLibraryKind::NativeUnknown => {\n+                NativeLibKind::StaticNoBundle\n+                | NativeLibKind::Dylib\n+                | NativeLibKind::Unspecified => {\n                     if sess.target.target.options.is_like_msvc {\n                         Some(format!(\"{}.lib\", name))\n                     } else {\n                         Some(format!(\"-l{}\", name))\n                     }\n                 }\n-                NativeLibraryKind::NativeFramework => {\n+                NativeLibKind::Framework => {\n                     // ld-only syntax, since there are no frameworks in MSVC\n                     Some(format!(\"-framework {}\", name))\n                 }\n                 // These are included, no need to print them\n-                NativeLibraryKind::NativeStatic | NativeLibraryKind::NativeRawDylib => None,\n+                NativeLibKind::StaticBundle | NativeLibKind::RawDylib => None,\n             }\n         })\n         .collect();\n@@ -1192,9 +1243,10 @@ fn link_output_kind(sess: &Session, crate_type: CrateType) -> LinkOutputKind {\n     };\n \n     // Adjust the output kind to target capabilities.\n-    let pic_exe_supported = sess.target.target.options.position_independent_executables;\n-    let static_pic_exe_supported = false; // FIXME: Add this option to target specs.\n-    let static_dylib_supported = sess.target.target.options.crt_static_allows_dylibs;\n+    let opts = &sess.target.target.options;\n+    let pic_exe_supported = opts.position_independent_executables;\n+    let static_pic_exe_supported = opts.static_position_independent_executables;\n+    let static_dylib_supported = opts.crt_static_allows_dylibs;\n     match kind {\n         LinkOutputKind::DynamicPicExe if !pic_exe_supported => LinkOutputKind::DynamicNoPicExe,\n         LinkOutputKind::StaticPicExe if !static_pic_exe_supported => LinkOutputKind::StaticNoPicExe,\n@@ -1250,20 +1302,10 @@ fn add_post_link_objects(\n \n /// Add arbitrary \"pre-link\" args defined by the target spec or from command line.\n /// FIXME: Determine where exactly these args need to be inserted.\n-fn add_pre_link_args(\n-    cmd: &mut dyn Linker,\n-    sess: &Session,\n-    flavor: LinkerFlavor,\n-    crate_type: CrateType,\n-) {\n+fn add_pre_link_args(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n     if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n-    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n-        if sess.crt_static(Some(crate_type)) {\n-            cmd.args(args);\n-        }\n-    }\n     cmd.args(&sess.opts.debugging_opts.pre_link_args);\n }\n \n@@ -1499,7 +1541,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     let crt_objects_fallback = crt_objects_fallback(sess, crate_type);\n \n     // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n-    add_pre_link_args(cmd, sess, flavor, crate_type);\n+    add_pre_link_args(cmd, sess, flavor);\n \n     // NO-OPT-OUT\n     add_link_script(cmd, sess, tmpdir, crate_type);\n@@ -1578,16 +1620,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    // FIXME: Support `StaticPicExe` correctly.\n-    match link_output_kind {\n-        LinkOutputKind::DynamicPicExe | LinkOutputKind::StaticPicExe => {\n-            cmd.position_independent_executable()\n-        }\n-        LinkOutputKind::DynamicNoPicExe | LinkOutputKind::StaticNoPicExe => {\n-            cmd.no_position_independent_executable()\n-        }\n-        _ => {}\n-    }\n+    cmd.set_output_kind(link_output_kind, out_filename);\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n     add_relro_args(cmd, sess);\n@@ -1616,17 +1649,6 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n         tmpdir,\n     );\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    // FIXME: Merge with the previous `link_output_kind` match,\n-    // and support `StaticPicExe` and `StaticDylib` correctly.\n-    match link_output_kind {\n-        LinkOutputKind::StaticNoPicExe | LinkOutputKind::StaticPicExe => {\n-            cmd.build_static_executable()\n-        }\n-        LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => cmd.build_dylib(out_filename),\n-        _ => {}\n-    }\n-\n     // OBJECT-FILES-NO, AUDIT-ORDER\n     if sess.opts.cg.profile_generate.enabled() {\n         cmd.pgo_gen();\n@@ -1696,11 +1718,11 @@ fn add_local_native_libraries(\n             None => continue,\n         };\n         match lib.kind {\n-            NativeLibraryKind::NativeUnknown => cmd.link_dylib(name),\n-            NativeLibraryKind::NativeFramework => cmd.link_framework(name),\n-            NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(name),\n-            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(name, &search_path),\n-            NativeLibraryKind::NativeRawDylib => {\n+            NativeLibKind::Dylib | NativeLibKind::Unspecified => cmd.link_dylib(name),\n+            NativeLibKind::Framework => cmd.link_framework(name),\n+            NativeLibKind::StaticNoBundle => cmd.link_staticlib(name),\n+            NativeLibKind::StaticBundle => cmd.link_whole_staticlib(name, &search_path),\n+            NativeLibKind::RawDylib => {\n                 // FIXME(#58713): Proper handling for raw dylibs.\n                 bug!(\"raw_dylib feature not yet implemented\");\n             }\n@@ -1890,7 +1912,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n         let skip_native = native_libs\n             .iter()\n-            .any(|lib| lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib));\n+            .any(|lib| lib.kind == NativeLibKind::StaticBundle && !relevant_lib(sess, lib));\n \n         if (!are_upstream_rust_objects_already_included(sess)\n             || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n@@ -2032,9 +2054,9 @@ fn add_upstream_native_libraries(\n                 continue;\n             }\n             match lib.kind {\n-                NativeLibraryKind::NativeUnknown => cmd.link_dylib(name),\n-                NativeLibraryKind::NativeFramework => cmd.link_framework(name),\n-                NativeLibraryKind::NativeStaticNobundle => {\n+                NativeLibKind::Dylib | NativeLibKind::Unspecified => cmd.link_dylib(name),\n+                NativeLibKind::Framework => cmd.link_framework(name),\n+                NativeLibKind::StaticNoBundle => {\n                     // Link \"static-nobundle\" native libs only if the crate they originate from\n                     // is being linked statically to the current crate.  If it's linked dynamically\n                     // or is an rlib already included via some other dylib crate, the symbols from\n@@ -2046,8 +2068,8 @@ fn add_upstream_native_libraries(\n                 // ignore statically included native libraries here as we've\n                 // already included them when we included the rust library\n                 // previously\n-                NativeLibraryKind::NativeStatic => {}\n-                NativeLibraryKind::NativeRawDylib => {\n+                NativeLibKind::StaticBundle => {}\n+                NativeLibKind::RawDylib => {\n                     // FIXME(#58713): Proper handling for raw dylibs.\n                     bug!(\"raw_dylib feature not yet implemented\");\n                 }\n@@ -2056,7 +2078,7 @@ fn add_upstream_native_libraries(\n     }\n }\n \n-fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => rustc_attr::cfg_matches(cfg, &sess.parse_sess, None),\n         None => true,"}, {"sha": "b17c36782074881f4dc47afffdb783cf80b5dbdf", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 137, "deletions": 118, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -17,7 +17,7 @@ use rustc_serialize::{json, Encoder};\n use rustc_session::config::{self, CrateType, DebugInfo, LinkerPluginLto, Lto, OptLevel, Strip};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n-use rustc_target::spec::{LinkerFlavor, LldFlavor};\n+use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n \n /// Disables non-English messages from localized linkers.\n /// Such messages may cause issues with text encoding on Windows (#35785)\n@@ -44,8 +44,7 @@ impl LinkerInfo {\n         LinkerInfo {\n             exports: tcx\n                 .sess\n-                .crate_types\n-                .borrow()\n+                .crate_types()\n                 .iter()\n                 .map(|&c| (c, exported_symbols(tcx, c)))\n                 .collect(),\n@@ -102,6 +101,7 @@ impl LinkerInfo {\n /// MSVC linker (e.g., `link.exe`) is being used.\n pub trait Linker {\n     fn cmd(&mut self) -> &mut Command;\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path);\n     fn link_dylib(&mut self, lib: Symbol);\n     fn link_rust_dylib(&mut self, lib: Symbol, path: &Path);\n     fn link_framework(&mut self, framework: Symbol);\n@@ -114,8 +114,6 @@ pub trait Linker {\n     fn output_filename(&mut self, path: &Path);\n     fn add_object(&mut self, path: &Path);\n     fn gc_sections(&mut self, keep_metadata: bool);\n-    fn position_independent_executable(&mut self);\n-    fn no_position_independent_executable(&mut self);\n     fn full_relro(&mut self);\n     fn partial_relro(&mut self);\n     fn no_relro(&mut self);\n@@ -125,8 +123,6 @@ pub trait Linker {\n     fn debuginfo(&mut self, strip: Strip);\n     fn no_crt_objects(&mut self);\n     fn no_default_libraries(&mut self);\n-    fn build_dylib(&mut self, out_filename: &Path);\n-    fn build_static_executable(&mut self);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n     fn subsystem(&mut self, subsystem: &str);\n     fn group_start(&mut self);\n@@ -233,12 +229,109 @@ impl<'a> GccLinker<'a> {\n         let target_cpu = self.target_cpu;\n         self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", target_cpu));\n     }\n+\n+    fn build_dylib(&mut self, out_filename: &Path) {\n+        // On mac we need to tell the linker to let this library be rpathed\n+        if self.sess.target.target.options.is_like_osx {\n+            self.cmd.arg(\"-dynamiclib\");\n+            self.linker_arg(\"-dylib\");\n+\n+            // Note that the `osx_rpath_install_name` option here is a hack\n+            // purely to support rustbuild right now, we should get a more\n+            // principled solution at some point to force the compiler to pass\n+            // the right `-Wl,-install_name` with an `@rpath` in it.\n+            if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n+                self.linker_arg(\"-install_name\");\n+                let mut v = OsString::from(\"@rpath/\");\n+                v.push(out_filename.file_name().unwrap());\n+                self.linker_arg(&v);\n+            }\n+        } else {\n+            self.cmd.arg(\"-shared\");\n+            if self.sess.target.target.options.is_like_windows {\n+                // The output filename already contains `dll_suffix` so\n+                // the resulting import library will have a name in the\n+                // form of libfoo.dll.a\n+                let implib_name =\n+                    out_filename.file_name().and_then(|file| file.to_str()).map(|file| {\n+                        format!(\n+                            \"{}{}{}\",\n+                            self.sess.target.target.options.staticlib_prefix,\n+                            file,\n+                            self.sess.target.target.options.staticlib_suffix\n+                        )\n+                    });\n+                if let Some(implib_name) = implib_name {\n+                    let implib = out_filename.parent().map(|dir| dir.join(&implib_name));\n+                    if let Some(implib) = implib {\n+                        self.linker_arg(&format!(\"--out-implib,{}\", (*implib).to_str().unwrap()));\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<'a> Linker for GccLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe => {\n+                if !self.is_ld {\n+                    self.cmd.arg(\"-no-pie\");\n+                }\n+            }\n+            LinkOutputKind::DynamicPicExe => {\n+                // `-pie` works for both gcc wrapper and ld.\n+                self.cmd.arg(\"-pie\");\n+            }\n+            LinkOutputKind::StaticNoPicExe => {\n+                // `-static` works for both gcc wrapper and ld.\n+                self.cmd.arg(\"-static\");\n+                if !self.is_ld {\n+                    self.cmd.arg(\"-no-pie\");\n+                }\n+            }\n+            LinkOutputKind::StaticPicExe => {\n+                if !self.is_ld {\n+                    // Note that combination `-static -pie` doesn't work as expected\n+                    // for the gcc wrapper, `-static` in that case suppresses `-pie`.\n+                    self.cmd.arg(\"-static-pie\");\n+                } else {\n+                    // `--no-dynamic-linker` and `-z text` are not strictly necessary for producing\n+                    // a static pie, but currently passed because gcc and clang pass them.\n+                    // The former suppresses the `INTERP` ELF header specifying dynamic linker,\n+                    // which is otherwise implicitly injected by ld (but not lld).\n+                    // The latter doesn't change anything, only ensures that everything is pic.\n+                    self.cmd.args(&[\"-static\", \"-pie\", \"--no-dynamic-linker\", \"-z\", \"text\"]);\n+                }\n+            }\n+            LinkOutputKind::DynamicDylib => self.build_dylib(out_filename),\n+            LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"-static\");\n+                self.build_dylib(out_filename);\n+            }\n+        }\n+        // VxWorks compiler driver introduced `--static-crt` flag specifically for rustc,\n+        // it switches linking for libc and similar system libraries to static without using\n+        // any `#[link]` attributes in the `libc` crate, see #72782 for details.\n+        // FIXME: Switch to using `#[link]` attributes in the `libc` crate\n+        // similarly to other targets.\n+        if self.sess.target.target.target_os == \"vxworks\"\n+            && matches!(\n+                output_kind,\n+                LinkOutputKind::StaticNoPicExe\n+                    | LinkOutputKind::StaticPicExe\n+                    | LinkOutputKind::StaticDylib\n+            )\n+        {\n+            self.cmd.arg(\"--static-crt\");\n+        }\n+    }\n+\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.hint_dynamic();\n         self.cmd.arg(format!(\"-l{}\", lib));\n@@ -263,14 +356,6 @@ impl<'a> Linker for GccLinker<'a> {\n     fn add_object(&mut self, path: &Path) {\n         self.cmd.arg(path);\n     }\n-    fn position_independent_executable(&mut self) {\n-        self.cmd.arg(\"-pie\");\n-    }\n-    fn no_position_independent_executable(&mut self) {\n-        if !self.is_ld {\n-            self.cmd.arg(\"-no-pie\");\n-        }\n-    }\n     fn full_relro(&mut self) {\n         self.linker_arg(\"-zrelro\");\n         self.linker_arg(\"-znow\");\n@@ -281,9 +366,6 @@ impl<'a> Linker for GccLinker<'a> {\n     fn no_relro(&mut self) {\n         self.linker_arg(\"-znorelro\");\n     }\n-    fn build_static_executable(&mut self) {\n-        self.cmd.arg(\"-static\");\n-    }\n \n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.hint_dynamic();\n@@ -399,10 +481,12 @@ impl<'a> Linker for GccLinker<'a> {\n         match strip {\n             Strip::None => {}\n             Strip::Debuginfo => {\n-                self.linker_arg(\"--strip-debug\");\n+                // MacOS linker does not support longhand argument --strip-debug\n+                self.linker_arg(\"-S\");\n             }\n             Strip::Symbols => {\n-                self.linker_arg(\"--strip-all\");\n+                // MacOS linker does not support longhand argument --strip-all\n+                self.linker_arg(\"-s\");\n             }\n         }\n     }\n@@ -419,47 +503,6 @@ impl<'a> Linker for GccLinker<'a> {\n         }\n     }\n \n-    fn build_dylib(&mut self, out_filename: &Path) {\n-        // On mac we need to tell the linker to let this library be rpathed\n-        if self.sess.target.target.options.is_like_osx {\n-            self.cmd.arg(\"-dynamiclib\");\n-            self.linker_arg(\"-dylib\");\n-\n-            // Note that the `osx_rpath_install_name` option here is a hack\n-            // purely to support rustbuild right now, we should get a more\n-            // principled solution at some point to force the compiler to pass\n-            // the right `-Wl,-install_name` with an `@rpath` in it.\n-            if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n-                self.linker_arg(\"-install_name\");\n-                let mut v = OsString::from(\"@rpath/\");\n-                v.push(out_filename.file_name().unwrap());\n-                self.linker_arg(&v);\n-            }\n-        } else {\n-            self.cmd.arg(\"-shared\");\n-            if self.sess.target.target.options.is_like_windows {\n-                // The output filename already contains `dll_suffix` so\n-                // the resulting import library will have a name in the\n-                // form of libfoo.dll.a\n-                let implib_name =\n-                    out_filename.file_name().and_then(|file| file.to_str()).map(|file| {\n-                        format!(\n-                            \"{}{}{}\",\n-                            self.sess.target.target.options.staticlib_prefix,\n-                            file,\n-                            self.sess.target.target.options.staticlib_suffix\n-                        )\n-                    });\n-                if let Some(implib_name) = implib_name {\n-                    let implib = out_filename.parent().map(|dir| dir.join(&implib_name));\n-                    if let Some(implib) = implib {\n-                        self.linker_arg(&format!(\"--out-implib,{}\", (*implib).to_str().unwrap()));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n         // Symbol visibility in object files typically takes care of this.\n         if crate_type == CrateType::Executable\n@@ -583,24 +626,29 @@ impl<'a> Linker for MsvcLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe\n+            | LinkOutputKind::DynamicPicExe\n+            | LinkOutputKind::StaticNoPicExe\n+            | LinkOutputKind::StaticPicExe => {}\n+            LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"/DLL\");\n+                let mut arg: OsString = \"/IMPLIB:\".into();\n+                arg.push(out_filename.with_extension(\"dll.lib\"));\n+                self.cmd.arg(arg);\n+            }\n+        }\n+    }\n+\n     fn link_rlib(&mut self, lib: &Path) {\n         self.cmd.arg(lib);\n     }\n     fn add_object(&mut self, path: &Path) {\n         self.cmd.arg(path);\n     }\n \n-    fn build_dylib(&mut self, out_filename: &Path) {\n-        self.cmd.arg(\"/DLL\");\n-        let mut arg: OsString = \"/IMPLIB:\".into();\n-        arg.push(out_filename.with_extension(\"dll.lib\"));\n-        self.cmd.arg(arg);\n-    }\n-\n-    fn build_static_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn gc_sections(&mut self, _keep_metadata: bool) {\n         // MSVC's ICF (Identical COMDAT Folding) link optimization is\n         // slow for Rust and thus we disable it by default when not in\n@@ -633,14 +681,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n         self.cmd.arg(&format!(\"{}.lib\", lib));\n     }\n \n-    fn position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n-    fn no_position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn full_relro(&mut self) {\n         // noop\n     }\n@@ -818,6 +858,9 @@ impl<'a> Linker for EmLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, _output_kind: LinkOutputKind, _out_filename: &Path) {}\n+\n     fn include_path(&mut self, path: &Path) {\n         self.cmd.arg(\"-L\").arg(path);\n     }\n@@ -857,14 +900,6 @@ impl<'a> Linker for EmLinker<'a> {\n         self.add_object(lib);\n     }\n \n-    fn position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n-    fn no_position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn full_relro(&mut self) {\n         // noop\n     }\n@@ -926,14 +961,6 @@ impl<'a> Linker for EmLinker<'a> {\n         self.cmd.args(&[\"-s\", \"DEFAULT_LIBRARY_FUNCS_TO_INCLUDE=[]\"]);\n     }\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {\n-        bug!(\"building dynamic library is unsupported on Emscripten\")\n-    }\n-\n-    fn build_static_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n         let symbols = &self.info.exports[&crate_type];\n \n@@ -1000,9 +1027,6 @@ impl<'a> WasmLd<'a> {\n         //   sharing memory and instantiating the module multiple times. As a\n         //   result if it were exported then we'd just have no sharing.\n         //\n-        // * `--passive-segments` - all memory segments should be passive to\n-        //   prevent each module instantiation from reinitializing memory.\n-        //\n         // * `--export=__wasm_init_memory` - when using `--passive-segments` the\n         //   linker will synthesize this function, and so we need to make sure\n         //   that our usage of `--export` below won't accidentally cause this\n@@ -1016,7 +1040,6 @@ impl<'a> WasmLd<'a> {\n             cmd.arg(\"--shared-memory\");\n             cmd.arg(\"--max-memory=1073741824\");\n             cmd.arg(\"--import-memory\");\n-            cmd.arg(\"--passive-segments\");\n             cmd.arg(\"--export=__wasm_init_memory\");\n             cmd.arg(\"--export=__wasm_init_tls\");\n             cmd.arg(\"--export=__tls_size\");\n@@ -1032,6 +1055,18 @@ impl<'a> Linker for WasmLd<'a> {\n         &mut self.cmd\n     }\n \n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, _out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe\n+            | LinkOutputKind::DynamicPicExe\n+            | LinkOutputKind::StaticNoPicExe\n+            | LinkOutputKind::StaticPicExe => {}\n+            LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"--no-entry\");\n+            }\n+        }\n+    }\n+\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1060,16 +1095,12 @@ impl<'a> Linker for WasmLd<'a> {\n         self.cmd.arg(path);\n     }\n \n-    fn position_independent_executable(&mut self) {}\n-\n     fn full_relro(&mut self) {}\n \n     fn partial_relro(&mut self) {}\n \n     fn no_relro(&mut self) {}\n \n-    fn build_static_executable(&mut self) {}\n-\n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1125,10 +1156,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn no_default_libraries(&mut self) {}\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {\n-        self.cmd.arg(\"--no-entry\");\n-    }\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n         for sym in self.info.exports[&crate_type].iter() {\n             self.cmd.arg(\"--export\").arg(&sym);\n@@ -1144,8 +1171,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    fn no_position_independent_executable(&mut self) {}\n-\n     fn finalize(&mut self) {}\n \n     // Not needed for now with LLD\n@@ -1208,6 +1233,8 @@ impl<'a> Linker for PtxLinker<'a> {\n         &mut self.cmd\n     }\n \n+    fn set_output_kind(&mut self, _output_kind: LinkOutputKind, _out_filename: &Path) {}\n+\n     fn link_rlib(&mut self, path: &Path) {\n         self.cmd.arg(\"--rlib\").arg(path);\n     }\n@@ -1274,16 +1301,12 @@ impl<'a> Linker for PtxLinker<'a> {\n         panic!(\"frameworks not supported\")\n     }\n \n-    fn position_independent_executable(&mut self) {}\n-\n     fn full_relro(&mut self) {}\n \n     fn partial_relro(&mut self) {}\n \n     fn no_relro(&mut self) {}\n \n-    fn build_static_executable(&mut self) {}\n-\n     fn gc_sections(&mut self, _keep_metadata: bool) {}\n \n     fn pgo_gen(&mut self) {}\n@@ -1296,14 +1319,10 @@ impl<'a> Linker for PtxLinker<'a> {\n         self.sess.warn(\"Windows Control Flow Guard is not supported by this linker.\");\n     }\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {}\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, _crate_type: CrateType) {}\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    fn no_position_independent_executable(&mut self) {}\n-\n     fn group_start(&mut self) {}\n \n     fn group_end(&mut self) {}"}, {"sha": "970d13b30c04e28feb7a6ba41fd268627a2d0b1c", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::ty::{SymbolName, TyCtxt};\n use rustc_session::config::{CrateType, Sanitizer};\n \n pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n-    crates_export_threshold(&tcx.sess.crate_types.borrow())\n+    crates_export_threshold(&tcx.sess.crate_types())\n }\n \n fn crate_export_threshold(crate_type: CrateType) -> SymbolExportLevel {\n@@ -212,7 +212,7 @@ fn exported_symbols_provider_local(\n         }));\n     }\n \n-    if tcx.sess.crate_types.borrow().contains(&CrateType::Dylib) {\n+    if tcx.sess.crate_types().contains(&CrateType::Dylib) {\n         let symbol_name = metadata_symbol_name(tcx);\n         let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n "}, {"sha": "cb5c95c11fad823d9e9cdc7ce0206499e357a40c", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -31,9 +31,9 @@ use rustc_session::cgu_reuse_tracker::CguReuseTracker;\n use rustc_session::config::{self, CrateType, Lto, OutputFilenames, OutputType};\n use rustc_session::config::{Passes, Sanitizer, SwitchWithOptPath};\n use rustc_session::Session;\n-use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::{BytePos, FileName, InnerSpan, Pos, Span};\n use rustc_target::spec::{MergeFunctions, PanicStrategy};\n \n use std::any::Any;\n@@ -142,8 +142,22 @@ impl ModuleConfig {\n         let emit_obj = if !should_emit_obj {\n             EmitObj::None\n         } else if sess.target.target.options.obj_is_bitcode\n-            || sess.opts.cg.linker_plugin_lto.enabled()\n+            || (sess.opts.cg.linker_plugin_lto.enabled() && !no_builtins)\n         {\n+            // This case is selected if the target uses objects as bitcode, or\n+            // if linker plugin LTO is enabled. In the linker plugin LTO case\n+            // the assumption is that the final link-step will read the bitcode\n+            // and convert it to object code. This may be done by either the\n+            // native linker or rustc itself.\n+            //\n+            // Note, however, that the linker-plugin-lto requested here is\n+            // explicitly ignored for `#![no_builtins]` crates. These crates are\n+            // specifically ignored by rustc's LTO passes and wouldn't work if\n+            // loaded into the linker. These crates define symbols that LLVM\n+            // lowers intrinsics to, and these symbol dependencies aren't known\n+            // until after codegen. As a result any crate marked\n+            // `#![no_builtins]` is assumed to not participate in LTO and\n+            // instead goes on to generate object code.\n             EmitObj::Bitcode\n         } else if need_bitcode_in_object(sess) {\n             EmitObj::ObjectCode(BitcodeSection::Full)\n@@ -368,7 +382,7 @@ pub struct CompiledModules {\n \n fn need_bitcode_in_object(sess: &Session) -> bool {\n     let requested_for_rlib = sess.opts.cg.embed_bitcode\n-        && sess.crate_types.borrow().contains(&CrateType::Rlib)\n+        && sess.crate_types().contains(&CrateType::Rlib)\n         && sess.opts.output_types.contains_key(&OutputType::Exe);\n     let forced_by_target = sess.target.target.options.forces_embed_bitcode;\n     requested_for_rlib || forced_by_target\n@@ -977,7 +991,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     };\n     let cgcx = CodegenContext::<B> {\n         backend: backend.clone(),\n-        crate_types: sess.crate_types.borrow().clone(),\n+        crate_types: sess.crate_types().to_vec(),\n         each_linked_rlib_for_lto,\n         lto: sess.lto(),\n         no_landing_pads: sess.panic_strategy() == PanicStrategy::Abort,\n@@ -1537,7 +1551,7 @@ fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>\n \n enum SharedEmitterMessage {\n     Diagnostic(Diagnostic),\n-    InlineAsmError(u32, String),\n+    InlineAsmError(u32, String, Option<(String, Vec<InnerSpan>)>),\n     AbortIfErrors,\n     Fatal(String),\n }\n@@ -1558,8 +1572,13 @@ impl SharedEmitter {\n         (SharedEmitter { sender }, SharedEmitterMain { receiver })\n     }\n \n-    pub fn inline_asm_error(&self, cookie: u32, msg: String) {\n-        drop(self.sender.send(SharedEmitterMessage::InlineAsmError(cookie, msg)));\n+    pub fn inline_asm_error(\n+        &self,\n+        cookie: u32,\n+        msg: String,\n+        source: Option<(String, Vec<InnerSpan>)>,\n+    ) {\n+        drop(self.sender.send(SharedEmitterMessage::InlineAsmError(cookie, msg, source)));\n     }\n \n     pub fn fatal(&self, msg: &str) {\n@@ -1612,8 +1631,30 @@ impl SharedEmitterMain {\n                     }\n                     handler.emit_diagnostic(&d);\n                 }\n-                Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n-                    sess.span_err(ExpnId::from_u32(cookie).expn_data().call_site, &msg)\n+                Ok(SharedEmitterMessage::InlineAsmError(cookie, msg, source)) => {\n+                    let msg = msg.strip_prefix(\"error: \").unwrap_or(&msg);\n+\n+                    // If the cookie is 0 then we don't have span information.\n+                    let mut err = if cookie == 0 {\n+                        sess.struct_err(&msg)\n+                    } else {\n+                        let pos = BytePos::from_u32(cookie);\n+                        let span = Span::with_root_ctxt(pos, pos);\n+                        sess.struct_span_err(span, &msg)\n+                    };\n+\n+                    // Point to the generated assembly if it is available.\n+                    if let Some((buffer, spans)) = source {\n+                        let source = sess\n+                            .source_map()\n+                            .new_source_file(FileName::inline_asm_source_code(&buffer), buffer);\n+                        let source_span = Span::with_root_ctxt(source.start_pos, source.end_pos);\n+                        let spans: Vec<_> =\n+                            spans.iter().map(|sp| source_span.from_inner(*sp)).collect();\n+                        err.span_note(spans, \"instantiated into assembly here\");\n+                    }\n+\n+                    err.emit();\n                 }\n                 Ok(SharedEmitterMessage::AbortIfErrors) => {\n                     sess.abort_if_errors();\n@@ -1798,7 +1839,7 @@ fn msvc_imps_needed(tcx: TyCtxt<'_>) -> bool {\n     );\n \n     tcx.sess.target.target.options.is_like_msvc &&\n-        tcx.sess.crate_types.borrow().iter().any(|ct| *ct == CrateType::Rlib) &&\n+        tcx.sess.crate_types().iter().any(|ct| *ct == CrateType::Rlib) &&\n     // ThinLTO can't handle this workaround in all cases, so we don't\n     // emit the `__imp_` symbols. Instead we make them unnecessary by disallowing\n     // dynamic linking when linker plugin LTO is enabled."}, {"sha": "5b14258bd25beb3a7e1045e603dfb1e0359b64e9", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -44,6 +44,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{self, EntryFnType};\n+use rustc_session::utils::NativeLibKind;\n use rustc_session::Session;\n use rustc_span::Span;\n use rustc_symbol_mangling::test as symbol_names_test;\n@@ -895,7 +896,7 @@ pub fn provide_both(providers: &mut Providers<'_>) {\n             .native_libraries(krate)\n             .iter()\n             .filter(|lib| {\n-                if lib.kind != cstore::NativeLibraryKind::NativeUnknown {\n+                if !matches!(lib.kind, NativeLibKind::Dylib | NativeLibKind::Unspecified) {\n                     return false;\n                 }\n                 let cfg = match lib.cfg {\n@@ -947,7 +948,7 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         match compute_per_cgu_lto_type(\n             &tcx.sess.lto(),\n             &tcx.sess.opts,\n-            &tcx.sess.crate_types.borrow(),\n+            &tcx.sess.crate_types(),\n             ModuleKind::Regular,\n         ) {\n             ComputedLtoType::No => CguReuse::PostLto,"}, {"sha": "57a3d8b5edcafc0b30f47061ef1a5a69d0361794", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -48,7 +48,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n         }\n         ty::Tuple(component_types) => {\n             output.push('(');\n-            for &component_type in component_types {\n+            for component_type in component_types {\n                 push_debuginfo_type_name(tcx, component_type.expect_ty(), true, output, visited);\n                 output.push_str(\", \");\n             }"}, {"sha": "bd3721850f35f995105dfc923d7a3323370bd22b", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -24,7 +24,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::LangItem;\n use rustc_middle::dep_graph::WorkProduct;\n-use rustc_middle::middle::cstore::{CrateSource, LibSource, NativeLibrary};\n+use rustc_middle::middle::cstore::{CrateSource, LibSource, NativeLib};\n use rustc_middle::middle::dependency_format::Dependencies;\n use rustc_middle::ty::query::Providers;\n use rustc_session::config::{OutputFilenames, OutputType, RUST_CGU_EXT};\n@@ -112,9 +112,9 @@ pub struct CrateInfo {\n     pub compiler_builtins: Option<CrateNum>,\n     pub profiler_runtime: Option<CrateNum>,\n     pub is_no_builtins: FxHashSet<CrateNum>,\n-    pub native_libraries: FxHashMap<CrateNum, Lrc<Vec<NativeLibrary>>>,\n+    pub native_libraries: FxHashMap<CrateNum, Lrc<Vec<NativeLib>>>,\n     pub crate_name: FxHashMap<CrateNum, String>,\n-    pub used_libraries: Lrc<Vec<NativeLibrary>>,\n+    pub used_libraries: Lrc<Vec<NativeLib>>,\n     pub link_args: Lrc<Vec<String>>,\n     pub used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n     pub used_crates_static: Vec<(CrateNum, LibSource)>,"}, {"sha": "61692280d2a775e3ef4b4a271a9a9c33eaf936af", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -104,7 +104,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n     ) {\n         let cx = self.fx.cx;\n \n-        if let [proj_base @ .., elem] = place_ref.projection {\n+        if let &[ref proj_base @ .., elem] = place_ref.projection {\n             let mut base_context = if context.is_mutating_use() {\n                 PlaceContext::MutatingUse(MutatingUseContext::Projection)\n             } else {\n@@ -186,7 +186,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             // now that we have moved to the \"slice of projections\" representation.\n             if let mir::ProjectionElem::Index(local) = elem {\n                 self.visit_local(\n-                    local,\n+                    &local,\n                     PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                     location,\n                 );\n@@ -357,7 +357,7 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n                 | TerminatorKind::Unreachable\n                 | TerminatorKind::SwitchInt { .. }\n                 | TerminatorKind::Yield { .. }\n-                | TerminatorKind::FalseEdges { .. }\n+                | TerminatorKind::FalseEdge { .. }\n                 | TerminatorKind::FalseUnwind { .. }\n                 | TerminatorKind::InlineAsm { .. } => { /* nothing to do */ }\n                 TerminatorKind::Call { cleanup: unwind, .. }"}, {"sha": "30a84c4e47b03a183088afe5d4b90f1cf7c9e418", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -831,6 +831,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         template: &[ast::InlineAsmTemplatePiece],\n         operands: &[mir::InlineAsmOperand<'tcx>],\n         options: ast::InlineAsmOptions,\n+        line_spans: &[Span],\n         destination: Option<mir::BasicBlock>,\n     ) {\n         let span = terminator.source_info.span;\n@@ -908,13 +909,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 mir::InlineAsmOperand::SymFn { ref value } => {\n                     let literal = self.monomorphize(&value.literal);\n                     if let ty::FnDef(def_id, substs) = literal.ty.kind {\n-                        let instance = ty::Instance::resolve(\n+                        let instance = ty::Instance::resolve_for_fn_ptr(\n                             bx.tcx(),\n                             ty::ParamEnv::reveal_all(),\n                             def_id,\n                             substs,\n                         )\n-                        .unwrap()\n                         .unwrap();\n                         InlineAsmOperandRef::SymFn { instance }\n                     } else {\n@@ -931,7 +931,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             })\n             .collect();\n \n-        bx.codegen_inline_asm(template, &operands, options, span);\n+        bx.codegen_inline_asm(template, &operands, options, line_spans);\n \n         if let Some(target) = destination {\n             helper.funclet_br(self, &mut bx, target);\n@@ -1030,18 +1030,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::TerminatorKind::GeneratorDrop | mir::TerminatorKind::Yield { .. } => {\n                 bug!(\"generator ops in codegen\")\n             }\n-            mir::TerminatorKind::FalseEdges { .. } | mir::TerminatorKind::FalseUnwind { .. } => {\n+            mir::TerminatorKind::FalseEdge { .. } | mir::TerminatorKind::FalseUnwind { .. } => {\n                 bug!(\"borrowck false edges in codegen\")\n             }\n \n-            mir::TerminatorKind::InlineAsm { template, ref operands, options, destination } => {\n+            mir::TerminatorKind::InlineAsm {\n+                template,\n+                ref operands,\n+                options,\n+                line_spans,\n+                destination,\n+            } => {\n                 self.codegen_asm_terminator(\n                     helper,\n                     bx,\n                     terminator,\n                     template,\n                     operands,\n                     options,\n+                    line_spans,\n                     destination,\n                 );\n             }"}, {"sha": "574f91e5b4d813d54e57475c83534b0c96288908", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,6 +1,5 @@\n use crate::mir::operand::OperandRef;\n use crate::traits::*;\n-use rustc_index::vec::Idx;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::layout::HasTyCtxt;\n@@ -59,17 +58,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant\n             .map(|val| {\n                 let field_ty = ty.builtin_index().unwrap();\n-                let fields = match ty.kind {\n-                    ty::Array(_, n) => n.eval_usize(bx.tcx(), ty::ParamEnv::reveal_all()),\n-                    _ => bug!(\"invalid simd shuffle type: {}\", ty),\n-                };\n                 let c = ty::Const::from_value(bx.tcx(), val, ty);\n-                let values: Vec<_> = (0..fields)\n+                let values: Vec<_> = bx\n+                    .tcx()\n+                    .destructure_const(ty::ParamEnv::reveal_all().and(&c))\n+                    .fields\n+                    .into_iter()\n                     .map(|field| {\n-                        let field = bx.tcx().const_field(\n-                            ty::ParamEnv::reveal_all().and((&c, mir::Field::new(field as usize))),\n-                        );\n-                        if let Some(prim) = field.try_to_scalar() {\n+                        if let Some(prim) = field.val.try_to_scalar() {\n                             let layout = bx.layout_of(field_ty);\n                             let scalar = match layout.abi {\n                                 Abi::Scalar(ref x) => x,"}, {"sha": "2be0679382900650e9494f3f5e71a77eeacb9f4a", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -429,7 +429,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 self.codegen_consume(bx, mir::PlaceRef { local, projection: proj_base })\n                     .deref(bx.cx())\n             }\n-            mir::PlaceRef { local, projection: [proj_base @ .., elem] } => {\n+            mir::PlaceRef { local, projection: &[ref proj_base @ .., elem] } => {\n                 // FIXME turn this recursion into iteration\n                 let cg_base =\n                     self.codegen_place(bx, mir::PlaceRef { local, projection: proj_base });\n@@ -440,7 +440,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         cg_base.project_field(bx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Copy(mir::Place::from(*index));\n+                        let index = &mir::Operand::Copy(mir::Place::from(index));\n                         let index = self.codegen_operand(bx, index);\n                         let llindex = index.immediate();\n                         cg_base.project_index(bx, llindex)\n@@ -450,22 +450,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         from_end: false,\n                         min_length: _,\n                     } => {\n-                        let lloffset = bx.cx().const_usize(*offset as u64);\n+                        let lloffset = bx.cx().const_usize(offset as u64);\n                         cg_base.project_index(bx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex {\n                         offset,\n                         from_end: true,\n                         min_length: _,\n                     } => {\n-                        let lloffset = bx.cx().const_usize(*offset as u64);\n+                        let lloffset = bx.cx().const_usize(offset as u64);\n                         let lllen = cg_base.len(bx.cx());\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to, from_end } => {\n                         let mut subslice =\n-                            cg_base.project_index(bx, bx.cx().const_usize(*from as u64));\n+                            cg_base.project_index(bx, bx.cx().const_usize(from as u64));\n                         let projected_ty =\n                             PlaceTy::from_ty(cg_base.layout.ty).projection_ty(tcx, elem).ty;\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n@@ -474,7 +474,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             assert!(from_end, \"slice subslices should be `from_end`\");\n                             subslice.llextra = Some(bx.sub(\n                                 cg_base.llextra.unwrap(),\n-                                bx.cx().const_usize((*from as u64) + (*to as u64)),\n+                                bx.cx().const_usize((from as u64) + (to as u64)),\n                             ));\n                         }\n \n@@ -487,7 +487,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                         subslice\n                     }\n-                    mir::ProjectionElem::Downcast(_, v) => cg_base.project_downcast(bx, *v),\n+                    mir::ProjectionElem::Downcast(_, v) => cg_base.project_downcast(bx, v),\n                 }\n             }\n         };"}, {"sha": "57f72b1065d05a609f352f011546dcc8f1ee5473", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -522,6 +522,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let operand = OperandRef { val: OperandValue::Immediate(val), layout: box_layout };\n                 (bx, operand)\n             }\n+            mir::Rvalue::ThreadLocalRef(def_id) => {\n+                assert!(bx.cx().tcx().is_static(def_id));\n+                let static_ = bx.get_static(def_id);\n+                let layout = bx.layout_of(bx.cx().tcx().static_ptr_ty(def_id));\n+                let operand = OperandRef::from_immediate_or_packed_pair(&mut bx, static_, layout);\n+                (bx, operand)\n+            }\n             mir::Rvalue::Use(ref operand) => {\n                 let operand = self.codegen_operand(&mut bx, operand);\n                 (bx, operand)\n@@ -745,6 +752,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::UnaryOp(..) |\n             mir::Rvalue::Discriminant(..) |\n             mir::Rvalue::NullaryOp(..) |\n+            mir::Rvalue::ThreadLocalRef(_) |\n             mir::Rvalue::Use(..) => // (*)\n                 true,\n             mir::Rvalue::Repeat(..) |"}, {"sha": "b6b57744f95b61ca02f829c7573645ec75cffb78", "filename": "src/librustc_codegen_ssa/traits/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -52,7 +52,7 @@ pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n         template: &[InlineAsmTemplatePiece],\n         operands: &[InlineAsmOperandRef<'tcx, Self>],\n         options: InlineAsmOptions,\n-        span: Span,\n+        line_spans: &[Span],\n     );\n }\n "}, {"sha": "bf2ab0787cb7073bbabeebe0deb8de1dbf8047b2", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -15,8 +15,9 @@ indexmap = \"1\"\n log = \"0.4\"\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n lazy_static = \"1\"\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n-graphviz = { path = \"../libgraphviz\" }\n+once_cell = { version = \"1\", features = [\"parking_lot\"] }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n+rustc_graphviz = { path = \"../librustc_graphviz\" }\n cfg-if = \"0.1.2\"\n crossbeam-utils = { version = \"0.7\", features = [\"nightly\"] }\n stable_deref_trait = \"1.0.0\""}, {"sha": "9383be474fd5a6224094a66f676875ec367681d5", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 57, "deletions": 24, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -7,18 +7,22 @@\n #![allow(non_camel_case_types)]\n #![allow(nonstandard_style)]\n \n+use std::fs::{File, OpenOptions};\n use std::io;\n use std::path::Path;\n \n cfg_if! {\n-    if #[cfg(unix)] {\n-        use std::ffi::{CString, OsStr};\n-        use std::mem;\n+    // We use `flock` rather than `fcntl` on Linux, because WSL1 does not support\n+    // `fcntl`-style advisory locks properly (rust-lang/rust#72157).\n+    //\n+    // For other Unix targets we still use `fcntl` because it's more portable than\n+    // `flock`.\n+    if #[cfg(target_os = \"linux\")] {\n         use std::os::unix::prelude::*;\n \n         #[derive(Debug)]\n         pub struct Lock {\n-            fd: libc::c_int,\n+            _file: File,\n         }\n \n         impl Lock {\n@@ -27,22 +31,55 @@ cfg_if! {\n                        create: bool,\n                        exclusive: bool)\n                        -> io::Result<Lock> {\n-                let os: &OsStr = p.as_ref();\n-                let buf = CString::new(os.as_bytes()).unwrap();\n-                let open_flags = if create {\n-                    libc::O_RDWR | libc::O_CREAT\n+                let file = OpenOptions::new()\n+                    .read(true)\n+                    .write(true)\n+                    .create(create)\n+                    .mode(libc::S_IRWXU as u32)\n+                    .open(p)?;\n+\n+                let mut operation = if exclusive {\n+                    libc::LOCK_EX\n                 } else {\n-                    libc::O_RDWR\n-                };\n-\n-                let fd = unsafe {\n-                    libc::open(buf.as_ptr(), open_flags,\n-                               libc::S_IRWXU as libc::c_int)\n+                    libc::LOCK_SH\n                 };\n+                if !wait {\n+                    operation |= libc::LOCK_NB\n+                }\n \n-                if fd < 0 {\n-                    return Err(io::Error::last_os_error());\n+                let ret = unsafe { libc::flock(file.as_raw_fd(), operation) };\n+                if ret == -1 {\n+                    Err(io::Error::last_os_error())\n+                } else {\n+                    Ok(Lock { _file: file })\n                 }\n+            }\n+        }\n+\n+        // Note that we don't need a Drop impl to execute `flock(fd, LOCK_UN)`. Lock acquired by\n+        // `flock` is associated with the file descriptor and closing the file release it\n+        // automatically.\n+    } else if #[cfg(unix)] {\n+        use std::mem;\n+        use std::os::unix::prelude::*;\n+\n+        #[derive(Debug)]\n+        pub struct Lock {\n+            file: File,\n+        }\n+\n+        impl Lock {\n+            pub fn new(p: &Path,\n+                       wait: bool,\n+                       create: bool,\n+                       exclusive: bool)\n+                       -> io::Result<Lock> {\n+                let file = OpenOptions::new()\n+                    .read(true)\n+                    .write(true)\n+                    .create(create)\n+                    .mode(libc::S_IRWXU as u32)\n+                    .open(p)?;\n \n                 let lock_type = if exclusive {\n                     libc::F_WRLCK\n@@ -58,14 +95,12 @@ cfg_if! {\n \n                 let cmd = if wait { libc::F_SETLKW } else { libc::F_SETLK };\n                 let ret = unsafe {\n-                    libc::fcntl(fd, cmd, &flock)\n+                    libc::fcntl(file.as_raw_fd(), cmd, &flock)\n                 };\n                 if ret == -1 {\n-                    let err = io::Error::last_os_error();\n-                    unsafe { libc::close(fd); }\n-                    Err(err)\n+                    Err(io::Error::last_os_error())\n                 } else {\n-                    Ok(Lock { fd })\n+                    Ok(Lock { file })\n                 }\n             }\n         }\n@@ -79,15 +114,13 @@ cfg_if! {\n                 flock.l_len = 0;\n \n                 unsafe {\n-                    libc::fcntl(self.fd, libc::F_SETLK, &flock);\n-                    libc::close(self.fd);\n+                    libc::fcntl(self.file.as_raw_fd(), libc::F_SETLK, &flock);\n                 }\n             }\n         }\n     } else if #[cfg(windows)] {\n         use std::mem;\n         use std::os::windows::prelude::*;\n-        use std::fs::{File, OpenOptions};\n \n         use winapi::um::minwinbase::{OVERLAPPED, LOCKFILE_FAIL_IMMEDIATELY, LOCKFILE_EXCLUSIVE_LOCK};\n         use winapi::um::fileapi::LockFileEx;"}, {"sha": "0b2e7cda1b4ccdc774ab014e26852f58ca4ea849", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -22,6 +22,7 @@\n #![feature(test)]\n #![feature(associated_type_bounds)]\n #![feature(thread_id_value)]\n+#![feature(extend_one)]\n #![allow(rustc::default_hash_types)]\n \n #[macro_use]"}, {"sha": "3a268e4b4f43224a5f60a8fbeee19feaaaa1c608", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,5 +1,5 @@\n use crate::obligation_forest::{ForestObligation, ObligationForest};\n-use graphviz as dot;\n+use rustc_graphviz as dot;\n use std::env::var_os;\n use std::fs::File;\n use std::io::BufWriter;"}, {"sha": "b4cc85293f7c19b84d27b612d0b09f56a25f7cd6", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -37,6 +37,7 @@ pub enum UndoLog<K, V> {\n }\n \n impl<K, V, M, L> SnapshotMap<K, V, M, L> {\n+    #[inline]\n     pub fn with_log<L2>(&mut self, undo_log: L2) -> SnapshotMap<K, V, &mut M, L2> {\n         SnapshotMap { map: &mut self.map, undo_log, _marker: PhantomData }\n     }"}, {"sha": "39afb3d82ff5aae9ef943718051b9709ff5229c5", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 4, "deletions": 129, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -20,7 +20,6 @@\n use crate::owning_ref::{Erased, OwningRef};\n use std::collections::HashMap;\n use std::hash::{BuildHasher, Hash};\n-use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n \n pub use std::sync::atomic::Ordering;\n@@ -230,6 +229,8 @@ cfg_if! {\n         pub use std::cell::RefMut as LockGuard;\n         pub use std::cell::RefMut as MappedLockGuard;\n \n+        pub use once_cell::unsync::OnceCell;\n+\n         use std::cell::RefCell as InnerRwLock;\n         use std::cell::RefCell as InnerLock;\n \n@@ -313,6 +314,8 @@ cfg_if! {\n         pub use parking_lot::MutexGuard as LockGuard;\n         pub use parking_lot::MappedMutexGuard as MappedLockGuard;\n \n+        pub use once_cell::sync::OnceCell;\n+\n         pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU32, AtomicU64};\n \n         pub use crossbeam_utils::atomic::AtomicCell;\n@@ -432,134 +435,6 @@ impl<K: Eq + Hash, V: Eq, S: BuildHasher> HashMapExt<K, V> for HashMap<K, V, S>\n     }\n }\n \n-/// A type whose inner value can be written once and then will stay read-only\n-// This contains a PhantomData<T> since this type conceptually owns a T outside the Mutex once\n-// initialized. This ensures that Once<T> is Sync only if T is. If we did not have PhantomData<T>\n-// we could send a &Once<Cell<bool>> to multiple threads and call `get` on it to get access\n-// to &Cell<bool> on those threads.\n-pub struct Once<T>(Lock<Option<T>>, PhantomData<T>);\n-\n-impl<T> Once<T> {\n-    /// Creates an Once value which is uninitialized\n-    #[inline(always)]\n-    pub fn new() -> Self {\n-        Once(Lock::new(None), PhantomData)\n-    }\n-\n-    /// Consumes the value and returns Some(T) if it was initialized\n-    #[inline(always)]\n-    pub fn into_inner(self) -> Option<T> {\n-        self.0.into_inner()\n-    }\n-\n-    /// Tries to initialize the inner value to `value`.\n-    /// Returns `None` if the inner value was uninitialized and `value` was consumed setting it\n-    /// otherwise if the inner value was already set it returns `value` back to the caller\n-    #[inline]\n-    pub fn try_set(&self, value: T) -> Option<T> {\n-        let mut lock = self.0.lock();\n-        if lock.is_some() {\n-            return Some(value);\n-        }\n-        *lock = Some(value);\n-        None\n-    }\n-\n-    /// Tries to initialize the inner value to `value`.\n-    /// Returns `None` if the inner value was uninitialized and `value` was consumed setting it\n-    /// otherwise if the inner value was already set it asserts that `value` is equal to the inner\n-    /// value and then returns `value` back to the caller\n-    #[inline]\n-    pub fn try_set_same(&self, value: T) -> Option<T>\n-    where\n-        T: Eq,\n-    {\n-        let mut lock = self.0.lock();\n-        if let Some(ref inner) = *lock {\n-            assert!(*inner == value);\n-            return Some(value);\n-        }\n-        *lock = Some(value);\n-        None\n-    }\n-\n-    /// Tries to initialize the inner value to `value` and panics if it was already initialized\n-    #[inline]\n-    pub fn set(&self, value: T) {\n-        assert!(self.try_set(value).is_none());\n-    }\n-\n-    /// Initializes the inner value if it wasn't already done by calling the provided closure. It\n-    /// ensures that no-one else can access the value in the mean time by holding a lock for the\n-    /// duration of the closure.\n-    /// A reference to the inner value is returned.\n-    #[inline]\n-    pub fn init_locking<F: FnOnce() -> T>(&self, f: F) -> &T {\n-        {\n-            let mut lock = self.0.lock();\n-            if lock.is_none() {\n-                *lock = Some(f());\n-            }\n-        }\n-\n-        self.borrow()\n-    }\n-\n-    /// Tries to initialize the inner value by calling the closure without ensuring that no-one\n-    /// else can access it. This mean when this is called from multiple threads, multiple\n-    /// closures may concurrently be computing a value which the inner value should take.\n-    /// Only one of these closures are used to actually initialize the value.\n-    /// If some other closure already set the value,\n-    /// we return the value our closure computed wrapped in a `Option`.\n-    /// If our closure set the value, `None` is returned.\n-    /// If the value is already initialized, the closure is not called and `None` is returned.\n-    #[inline]\n-    pub fn init_nonlocking<F: FnOnce() -> T>(&self, f: F) -> Option<T> {\n-        if self.0.lock().is_some() { None } else { self.try_set(f()) }\n-    }\n-\n-    /// Tries to initialize the inner value by calling the closure without ensuring that no-one\n-    /// else can access it. This mean when this is called from multiple threads, multiple\n-    /// closures may concurrently be computing a value which the inner value should take.\n-    /// Only one of these closures are used to actually initialize the value.\n-    /// If some other closure already set the value, we assert that it our closure computed\n-    /// a value equal to the value already set and then\n-    /// we return the value our closure computed wrapped in a `Option`.\n-    /// If our closure set the value, `None` is returned.\n-    /// If the value is already initialized, the closure is not called and `None` is returned.\n-    #[inline]\n-    pub fn init_nonlocking_same<F: FnOnce() -> T>(&self, f: F) -> Option<T>\n-    where\n-        T: Eq,\n-    {\n-        if self.0.lock().is_some() { None } else { self.try_set_same(f()) }\n-    }\n-\n-    /// Tries to get a reference to the inner value, returns `None` if it is not yet initialized\n-    #[inline(always)]\n-    pub fn try_get(&self) -> Option<&T> {\n-        let lock = &*self.0.lock();\n-        if let Some(ref inner) = *lock {\n-            // This is safe since we won't mutate the inner value\n-            unsafe { Some(&*(inner as *const T)) }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Gets reference to the inner value, panics if it is not yet initialized\n-    #[inline(always)]\n-    pub fn get(&self) -> &T {\n-        self.try_get().expect(\"value was not set\")\n-    }\n-\n-    /// Gets reference to the inner value, panics if it is not yet initialized\n-    #[inline(always)]\n-    pub fn borrow(&self) -> &T {\n-        self.get()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct Lock<T>(InnerLock<T>);\n "}, {"sha": "43002178eb9717478e23ca88a3ffad7647adda14", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -53,6 +53,20 @@ impl<T> Extend<T> for ThinVec<T> {\n             ThinVec(None) => *self = iter.into_iter().collect::<Vec<_>>().into(),\n         }\n     }\n+\n+    fn extend_one(&mut self, item: T) {\n+        match *self {\n+            ThinVec(Some(ref mut vec)) => vec.push(item),\n+            ThinVec(None) => *self = vec![item].into(),\n+        }\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        match *self {\n+            ThinVec(Some(ref mut vec)) => vec.reserve(additional),\n+            ThinVec(None) => *self = Vec::with_capacity(additional).into(),\n+        }\n+    }\n }\n \n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ThinVec<T> {"}, {"sha": "75d6592076655508093a0328b0b49f67b3e74087", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -32,7 +32,7 @@ rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_error_codes = { path = \"../librustc_error_codes\" }\n rustc_interface = { path = \"../librustc_interface\" }\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n "}, {"sha": "ccea041699ee18c6ff85acef69d34c94c5e7c739", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -346,20 +346,22 @@ pub fn run_compiler(\n \n             queries.global_ctxt()?;\n \n+            // Drop AST after creating GlobalCtxt to free memory\n+            let _timer = sess.prof.generic_activity(\"drop_ast\");\n+            mem::drop(queries.expansion()?.take());\n+\n             if sess.opts.debugging_opts.no_analysis || sess.opts.debugging_opts.ast_json {\n                 return early_exit();\n             }\n \n             if sess.opts.debugging_opts.save_analysis {\n-                let expanded_crate = &queries.expansion()?.peek().0;\n                 let crate_name = queries.crate_name()?.peek().clone();\n                 queries.global_ctxt()?.peek_mut().enter(|tcx| {\n                     let result = tcx.analysis(LOCAL_CRATE);\n \n                     sess.time(\"save_analysis\", || {\n                         save::process_crate(\n                             tcx,\n-                            &expanded_crate,\n                             &crate_name,\n                             &compiler.input(),\n                             None,\n@@ -371,13 +373,7 @@ pub fn run_compiler(\n                     });\n \n                     result\n-                    // AST will be dropped *after* the `after_analysis` callback\n-                    // (needed by the RLS)\n                 })?;\n-            } else {\n-                // Drop AST after creating GlobalCtxt to free memory\n-                let _timer = sess.prof.generic_activity(\"drop_ast\");\n-                mem::drop(queries.expansion()?.take());\n             }\n \n             queries.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n@@ -386,10 +382,6 @@ pub fn run_compiler(\n                 return early_exit();\n             }\n \n-            if sess.opts.debugging_opts.save_analysis {\n-                mem::drop(queries.expansion()?.take());\n-            }\n-\n             queries.ongoing_codegen()?;\n \n             if sess.opts.debugging_opts.print_type_sizes {\n@@ -586,7 +578,7 @@ impl RustcDefaultCalls {\n         if let Input::File(file) = compiler.input() {\n             // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n             let attrs = vec![];\n-            sess.crate_types.set(collect_crate_types(sess, &attrs));\n+            sess.init_crate_types(collect_crate_types(sess, &attrs));\n             let outputs = compiler.build_output_filenames(&sess, &attrs);\n             let rlink_data = fs::read_to_string(file).unwrap_or_else(|err| {\n                 sess.fatal(&format!(\"failed to read rlink file: {}\", err));"}, {"sha": "0a21eb8de059ced1fd38b371d0e28c89a808c415", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -396,7 +396,7 @@ pub fn print_after_parsing(\n                 annotation.pp_ann(),\n                 false,\n                 parse.edition,\n-                parse.injected_crate_name.try_get().is_some(),\n+                parse.injected_crate_name.get().is_some(),\n             )\n         })\n     } else {\n@@ -438,7 +438,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                     annotation.pp_ann(),\n                     true,\n                     parse.edition,\n-                    parse.injected_crate_name.try_get().is_some(),\n+                    parse.injected_crate_name.get().is_some(),\n                 )\n             })\n         }"}, {"sha": "ec5b3251e6883b250e00a8cc094ba756ddac1568", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -437,6 +437,9 @@ E0751: include_str!(\"./error_codes/E0751.md\"),\n E0752: include_str!(\"./error_codes/E0752.md\"),\n E0753: include_str!(\"./error_codes/E0753.md\"),\n E0754: include_str!(\"./error_codes/E0754.md\"),\n+E0758: include_str!(\"./error_codes/E0758.md\"),\n+E0760: include_str!(\"./error_codes/E0760.md\"),\n+E0761: include_str!(\"./error_codes/E0761.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "223ba4000298614bf3bb6498f3a2531d7dcc22f6", "filename": "src/librustc_error_codes/error_codes/E0055.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -6,7 +6,7 @@ recursion limit (which can be set via the `recursion_limit` attribute).\n For a somewhat artificial example:\n \n ```compile_fail,E0055\n-#![recursion_limit=\"5\"]\n+#![recursion_limit=\"4\"]\n \n struct Foo;\n "}, {"sha": "cb4f5d5157d9bf6c629f870d13bee250b3c0d59e", "filename": "src/librustc_error_codes/error_codes/E0207.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0207.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0207.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0207.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,4 +1,4 @@\n-A type or lifetime parameter that is specified for `impl` is not constrained.\n+A type parameter that is specified for `impl` is not constrained.\n \n Erroneous code example:\n \n@@ -14,7 +14,7 @@ impl<T: Default> Foo {\n }\n ```\n \n-Any type parameter or lifetime parameter of an `impl` must meet at least one of\n+Any type parameter parameter of an `impl` must meet at least one of\n the following criteria:\n \n  - it appears in the _implementing type_ of the impl, e.g. `impl<T> Foo<T>`"}, {"sha": "701900bb0cd4be8d966b3ff8c084bd678f2b4a6e", "filename": "src/librustc_error_codes/error_codes/E0583.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0583.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0583.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0583.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -2,7 +2,7 @@ A file wasn't found for an out-of-line module.\n \n Erroneous code example:\n \n-```ignore (compile_fail not working here; see Issue #43707)\n+```compile_fail,E0583\n mod file_that_doesnt_exist; // error: file not found for module\n \n fn main() {}"}, {"sha": "11005b8336fcae927cb51692ed303202ffd2039a", "filename": "src/librustc_error_codes/error_codes/E0590.md", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0590.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0590.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0590.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,13 +1,17 @@\n-`break` or `continue` must include a label when used in the condition of a\n-`while` loop.\n+`break` or `continue` keywords were used in a condition of a `while` loop\n+without a label.\n \n-Example of erroneous code:\n+Erroneous code code:\n \n ```compile_fail,E0590\n while break {}\n ```\n \n+`break` or `continue` must include a label when used in the condition of a\n+`while` loop.\n+\n To fix this, add a label specifying which loop is being broken out of:\n+\n ```\n 'foo: while break 'foo {}\n ```"}, {"sha": "1902d73f4d00ca2a90257c91e7a3ebbb16d906c1", "filename": "src/librustc_error_codes/error_codes/E0593.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0593.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0593.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0593.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -11,3 +11,14 @@ fn main() {\n     foo(|y| { });\n }\n ```\n+\n+You have to provide the same number of arguments as expected by the `Fn`-based\n+type. So to fix the previous example, we need to remove the `y` argument:\n+\n+```\n+fn foo<F: Fn()>(x: F) { }\n+\n+fn main() {\n+    foo(|| { }); // ok!\n+}\n+```"}, {"sha": "5b1590b29998f489c07b8e6af17b3f5434b3c1c2", "filename": "src/librustc_error_codes/error_codes/E0599.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0599.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0599.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0599.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -9,3 +9,18 @@ let x = Mouth;\n x.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n                //        in the current scope\n ```\n+\n+In this case, you need to implement the `chocolate` method to fix the error:\n+\n+```\n+struct Mouth;\n+\n+impl Mouth {\n+    fn chocolate(&self) { // We implement the `chocolate` method here.\n+        println!(\"Hmmm! I love chocolate!\");\n+    }\n+}\n+\n+let x = Mouth;\n+x.chocolate(); // ok!\n+```"}, {"sha": "356006c72f3d1d74a180143ee2cd864269270bda", "filename": "src/librustc_error_codes/error_codes/E0600.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0600.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0600.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0600.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,6 +1,6 @@\n An unary operator was used on a type which doesn't implement it.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0600\n enum Question {"}, {"sha": "7194b7971d38f168a374d48bf4d2e231a0102738", "filename": "src/librustc_error_codes/error_codes/E0601.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0601.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0601.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0601.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,5 +1,6 @@\n-No `main` function was found in a binary crate. To fix this error, add a\n-`main` function. For example:\n+No `main` function was found in a binary crate.\n+\n+To fix this error, add a `main` function:\n \n ```\n fn main() {"}, {"sha": "dcaf251a96b5b23bc2c2bde3ab60175215fce721", "filename": "src/librustc_error_codes/error_codes/E0602.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0602.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0602.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0602.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,9 +1,9 @@\n An unknown lint was used on the command line.\n \n-Erroneous example:\n+Erroneous code example:\n \n ```sh\n-rustc -D bogus omse_file.rs\n+rustc -D bogus rust_file.rs\n ```\n \n Maybe you just misspelled the lint name or the lint doesn't exist anymore."}, {"sha": "d0ebc3a26f082b82f58fea689130f23e15036bdf", "filename": "src/librustc_error_codes/error_codes/E0608.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0608.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0608.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0608.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,4 +1,4 @@\n-An attempt to index into a type which doesn't implement the `std::ops::Index`\n+An attempt to use index on a type which doesn't implement the `std::ops::Index`\n trait was performed.\n \n Erroneous code example:"}, {"sha": "61b56766c26e2807b7099daeb73f4211bca7b501", "filename": "src/librustc_error_codes/error_codes/E0617.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0617.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0617.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0617.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -17,3 +17,14 @@ Certain Rust types must be cast before passing them to a variadic function,\n because of arcane ABI rules dictated by the C standard. To fix the error,\n cast the value to the type specified by the error message (which you may need\n to import from `std::os::raw`).\n+\n+In this case, `c_double` has the same size as `f64` so we can use it directly:\n+\n+```no_run\n+# extern {\n+#     fn printf(c: *const i8, ...);\n+# }\n+unsafe {\n+    printf(::std::ptr::null(), 0f64); // ok!\n+}\n+```"}, {"sha": "f516de43095bd4dd3f0d19c9a045a4cc5aea3898", "filename": "src/librustc_error_codes/error_codes/E0619.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0619.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0619.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0619.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,4 +1,5 @@\n #### Note: this error code is no longer emitted by the compiler.\n+\n The type-checker needed to know the type of an expression, but that type had not\n yet been inferred.\n "}, {"sha": "990a25494129e7b2b5365a2f71dcfc4083f735f7", "filename": "src/librustc_error_codes/error_codes/E0622.md", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0622.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0622.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0622.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -5,13 +5,21 @@ Erroneous code example:\n ```compile_fail,E0622\n #![feature(intrinsics)]\n extern \"rust-intrinsic\" {\n-    pub static breakpoint : unsafe extern \"rust-intrinsic\" fn();\n-    // error: intrinsic must be a function\n+    pub static breakpoint : fn(); // error: intrinsic must be a function\n }\n \n fn main() { unsafe { breakpoint(); } }\n ```\n \n An intrinsic is a function available for use in a given programming language\n whose implementation is handled specially by the compiler. In order to fix this\n-error, just declare a function.\n+error, just declare a function. Example:\n+\n+```no_run\n+#![feature(intrinsics)]\n+extern \"rust-intrinsic\" {\n+    pub fn breakpoint(); // ok!\n+}\n+\n+fn main() { unsafe { breakpoint(); } }\n+```"}, {"sha": "d9068950bdfee67361ed6702156762c564ea663e", "filename": "src/librustc_error_codes/error_codes/E0637.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0637.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0637.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0637.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,6 +1,7 @@\n An underscore `_` character has been used as the identifier for a lifetime.\n \n-Erroneous example:\n+Erroneous code example:\n+\n ```compile_fail,E0106,E0637\n fn longest<'_>(str1: &'_ str, str2: &'_ str) -> &'_ str {\n          //^^ `'_` is a reserved lifetime name\n@@ -11,13 +12,15 @@ fn longest<'_>(str1: &'_ str, str2: &'_ str) -> &'_ str {\n     }\n }\n ```\n+\n `'_`, cannot be used as a lifetime identifier because it is a reserved for the\n anonymous lifetime. To fix this, use a lowercase letter such as 'a, or a series\n of lowercase letters such as `'foo`.  For more information, see [the\n book][bk-no].  For more information on using the anonymous lifetime in rust\n nightly, see [the nightly book][bk-al].\n \n Corrected example:\n+\n ```\n fn longest<'a>(str1: &'a str, str2: &'a str) -> &'a str {\n     if str1.len() > str2.len() {"}, {"sha": "5848e9b5c05ca60700d71fca68cc4a00acfe3f30", "filename": "src/librustc_error_codes/error_codes/E0641.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0641.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0641.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0641.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,19 +1,19 @@\n Attempted to cast to/from a pointer with an unknown kind.\n \n-Erroneous code examples:\n+Erroneous code example:\n \n ```compile_fail,E0641\n let b = 0 as *const _; // error\n ```\n \n-Must give information for type of pointer that is being cast from/to if the\n-type cannot be inferred.\n+Type information must be provided if a pointer type being cast from/into another\n+type which cannot be inferred:\n \n ```\n // Creating a pointer from reference: type can be inferred\n-let a = &(String::from(\"Hello world!\")) as *const _; // Ok\n+let a = &(String::from(\"Hello world!\")) as *const _; // ok!\n \n-let b = 0 as *const i32; // Ok\n+let b = 0 as *const i32; // ok!\n \n-let c: *const i32 = 0 as *const _; // Ok\n+let c: *const i32 = 0 as *const _; // ok!\n ```"}, {"sha": "8c68da3b2f310efafcd8a51a3af11fb1ea3cca32", "filename": "src/librustc_error_codes/error_codes/E0644.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,6 +1,6 @@\n A closure or generator was constructed that references its own type.\n \n-Erroneous example:\n+Erroneous code example:\n \n ```compile_fail,E0644\n fn fix<F>(f: &F)"}, {"sha": "1e9ec7d4380adb56050f447f500e56f3a8844b3a", "filename": "src/librustc_error_codes/error_codes/E0646.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0646.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0646.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0646.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,4 +1,5 @@\n It is not possible to define `main` with a where clause.\n+\n Erroneous code example:\n \n ```compile_fail,E0646"}, {"sha": "8ca6e777f301da4d21b1750a07b802f8d47ab946", "filename": "src/librustc_error_codes/error_codes/E0647.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0647.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0647.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0647.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,4 +1,5 @@\n-It is not possible to define `start` with a where clause.\n+The `start` function was defined with a where clause.\n+\n Erroneous code example:\n \n ```compile_fail,E0647"}, {"sha": "ddca4b3d75f77d736b07e6b7c54db34f897143ee", "filename": "src/librustc_error_codes/error_codes/E0758.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0758.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0758.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0758.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -0,0 +1,20 @@\n+A multi-line (doc-)comment is unterminated.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0758\n+/* I am not terminated!\n+```\n+\n+The same goes for doc comments:\n+\n+```compile_fail,E0758\n+/*! I am not terminated!\n+```\n+\n+You need to end your multi-line comment with `*/` in order to fix this error:\n+\n+```\n+/* I am terminated! */\n+/*! I am also terminated! */\n+```"}, {"sha": "e1dcfefebcd762187aba9a1d49a0b44154696787", "filename": "src/librustc_error_codes/error_codes/E0760.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0760.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0760.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0760.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -0,0 +1,32 @@\n+`async fn`/`impl trait` return type cannot contain a projection\n+or `Self` that references lifetimes from a parent scope.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0760,edition2018\n+struct S<'a>(&'a i32);\n+\n+impl<'a> S<'a> {\n+    async fn new(i: &'a i32) -> Self {\n+        S(&22)\n+    }\n+}\n+```\n+\n+To fix this error we need to spell out `Self` to `S<'a>`:\n+\n+```edition2018\n+struct S<'a>(&'a i32);\n+\n+impl<'a> S<'a> {\n+    async fn new(i: &'a i32) -> S<'a> {\n+        S(&22)\n+    }\n+}\n+```\n+\n+This will be allowed at some point in the future,\n+but the implementation is not yet complete.\n+See the [issue-61949] for this limitation.\n+\n+[issue-61949]: https://github.com/rust-lang/rust/issues/61949"}, {"sha": "c01574e413cfaa62ec8077e3b6ce3075b373299c", "filename": "src/librustc_error_codes/error_codes/E0761.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0761.md", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_error_codes%2Ferror_codes%2FE0761.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0761.md?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -0,0 +1,25 @@\n+Multiple candidate files were found for an out-of-line module.\n+\n+Erroneous code example:\n+\n+```rust\n+// file: ambiguous_module/mod.rs\n+\n+fn foo() {}\n+```\n+\n+```rust\n+// file: ambiguous_module.rs\n+\n+fn foo() {}\n+```\n+\n+```ignore (multiple source files required for compile_fail)\n+mod ambiguous_module; // error: file for module `ambiguous_module`\n+                      // found at both ambiguous_module.rs and\n+                      // ambiguous_module.rs/mod.rs\n+\n+fn main() {}\n+```\n+\n+Please remove this ambiguity by deleting/renaming one of the candidate files."}, {"sha": "7f72161aff826a09091bc7012cdabd0582c67b52", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -11,13 +11,13 @@ doctest = false\n \n [dependencies]\n log = \"0.4\"\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n-annotate-snippets = \"0.6.1\"\n+annotate-snippets = \"0.8.0\"\n termize = \"0.1.1\"\n \n [target.'cfg(windows)'.dependencies]"}, {"sha": "5b47364e714e910dbf6792c98af13e119944a74b", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 92, "deletions": 123, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -8,12 +8,11 @@\n use crate::emitter::FileWithAnnotatedLines;\n use crate::snippet::Line;\n use crate::{CodeSuggestion, Diagnostic, DiagnosticId, Emitter, Level, SubDiagnostic};\n-use annotate_snippets::display_list::DisplayList;\n-use annotate_snippets::formatter::DisplayListFormatter;\n+use annotate_snippets::display_list::{DisplayList, FormatOptions};\n use annotate_snippets::snippet::*;\n use rustc_data_structures::sync::Lrc;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::{Loc, MultiSpan, SourceFile};\n+use rustc_span::{MultiSpan, SourceFile};\n \n /// Generates diagnostics using annotate-snippet\n pub struct AnnotateSnippetEmitterWriter {\n@@ -59,112 +58,20 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n     }\n }\n \n-/// Collects all the data needed to generate the data structures needed for the\n-/// `annotate-snippets` library.\n-struct DiagnosticConverter<'a> {\n-    source_map: Option<Lrc<SourceMap>>,\n-    level: Level,\n-    message: String,\n-    code: Option<DiagnosticId>,\n-    msp: MultiSpan,\n-    #[allow(dead_code)]\n-    children: &'a [SubDiagnostic],\n-    #[allow(dead_code)]\n-    suggestions: &'a [CodeSuggestion],\n+/// Provides the source string for the given `line` of `file`\n+fn source_string(file: Lrc<SourceFile>, line: &Line) -> String {\n+    file.get_line(line.line_index - 1).map(|a| a.to_string()).unwrap_or_default()\n }\n \n-impl<'a> DiagnosticConverter<'a> {\n-    /// Turns rustc Diagnostic information into a `annotate_snippets::snippet::Snippet`.\n-    fn to_annotation_snippet(&self) -> Option<Snippet> {\n-        if let Some(source_map) = &self.source_map {\n-            // Make sure our primary file comes first\n-            let primary_lo = if let Some(ref primary_span) = self.msp.primary_span().as_ref() {\n-                source_map.lookup_char_pos(primary_span.lo())\n-            } else {\n-                // FIXME(#59346): Not sure when this is the case and what\n-                // should be done if it happens\n-                return None;\n-            };\n-            let annotated_files =\n-                FileWithAnnotatedLines::collect_annotations(&self.msp, &self.source_map);\n-            let slices = self.slices_for_files(annotated_files, primary_lo);\n-\n-            Some(Snippet {\n-                title: Some(Annotation {\n-                    label: Some(self.message.to_string()),\n-                    id: self.code.clone().map(|c| match c {\n-                        DiagnosticId::Error(val) | DiagnosticId::Lint(val) => val,\n-                    }),\n-                    annotation_type: Self::annotation_type_for_level(self.level),\n-                }),\n-                footer: vec![],\n-                slices,\n-            })\n-        } else {\n-            // FIXME(#59346): Is it ok to return None if there's no source_map?\n-            None\n-        }\n-    }\n-\n-    fn slices_for_files(\n-        &self,\n-        annotated_files: Vec<FileWithAnnotatedLines>,\n-        primary_lo: Loc,\n-    ) -> Vec<Slice> {\n-        // FIXME(#64205): Provide a test case where `annotated_files` is > 1\n-        annotated_files\n-            .iter()\n-            .flat_map(|annotated_file| {\n-                annotated_file\n-                    .lines\n-                    .iter()\n-                    .map(|line| {\n-                        let line_source = Self::source_string(annotated_file.file.clone(), &line);\n-                        Slice {\n-                            source: line_source,\n-                            line_start: line.line_index,\n-                            origin: Some(primary_lo.file.name.to_string()),\n-                            // FIXME(#59346): Not really sure when `fold` should be true or false\n-                            fold: false,\n-                            annotations: line\n-                                .annotations\n-                                .iter()\n-                                .map(|a| self.annotation_to_source_annotation(a.clone()))\n-                                .collect(),\n-                        }\n-                    })\n-                    .collect::<Vec<Slice>>()\n-            })\n-            .collect::<Vec<Slice>>()\n-    }\n-\n-    /// Turns a `crate::snippet::Annotation` into a `SourceAnnotation`\n-    fn annotation_to_source_annotation(\n-        &self,\n-        annotation: crate::snippet::Annotation,\n-    ) -> SourceAnnotation {\n-        SourceAnnotation {\n-            range: (annotation.start_col, annotation.end_col),\n-            label: annotation.label.unwrap_or(\"\".to_string()),\n-            annotation_type: Self::annotation_type_for_level(self.level),\n-        }\n-    }\n-\n-    /// Provides the source string for the given `line` of `file`\n-    fn source_string(file: Lrc<SourceFile>, line: &Line) -> String {\n-        file.get_line(line.line_index - 1).map(|a| a.to_string()).unwrap_or(String::new())\n-    }\n-\n-    /// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n-    fn annotation_type_for_level(level: Level) -> AnnotationType {\n-        match level {\n-            Level::Bug | Level::Fatal | Level::Error => AnnotationType::Error,\n-            Level::Warning => AnnotationType::Warning,\n-            Level::Note => AnnotationType::Note,\n-            Level::Help => AnnotationType::Help,\n-            // FIXME(#59346): Not sure how to map these two levels\n-            Level::Cancelled | Level::FailureNote => AnnotationType::Error,\n-        }\n+/// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n+fn annotation_type_for_level(level: Level) -> AnnotationType {\n+    match level {\n+        Level::Bug | Level::Fatal | Level::Error => AnnotationType::Error,\n+        Level::Warning => AnnotationType::Warning,\n+        Level::Note => AnnotationType::Note,\n+        Level::Help => AnnotationType::Help,\n+        // FIXME(#59346): Not sure how to map these two levels\n+        Level::Cancelled | Level::FailureNote => AnnotationType::Error,\n     }\n }\n \n@@ -191,25 +98,87 @@ impl AnnotateSnippetEmitterWriter {\n         message: String,\n         code: &Option<DiagnosticId>,\n         msp: &MultiSpan,\n-        children: &[SubDiagnostic],\n-        suggestions: &[CodeSuggestion],\n+        _children: &[SubDiagnostic],\n+        _suggestions: &[CodeSuggestion],\n     ) {\n-        let converter = DiagnosticConverter {\n-            source_map: self.source_map.clone(),\n-            level: *level,\n-            message,\n-            code: code.clone(),\n-            msp: msp.clone(),\n-            children,\n-            suggestions,\n-        };\n-        if let Some(snippet) = converter.to_annotation_snippet() {\n-            let dl = DisplayList::from(snippet);\n-            let dlf = DisplayListFormatter::new(true, self.ui_testing);\n+        if let Some(source_map) = &self.source_map {\n+            // Make sure our primary file comes first\n+            let primary_lo = if let Some(ref primary_span) = msp.primary_span().as_ref() {\n+                if primary_span.is_dummy() {\n+                    // FIXME(#59346): Not sure when this is the case and what\n+                    // should be done if it happens\n+                    return;\n+                } else {\n+                    source_map.lookup_char_pos(primary_span.lo())\n+                }\n+            } else {\n+                // FIXME(#59346): Not sure when this is the case and what\n+                // should be done if it happens\n+                return;\n+            };\n+            let mut annotated_files =\n+                FileWithAnnotatedLines::collect_annotations(msp, &self.source_map);\n+            if let Ok(pos) =\n+                annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name))\n+            {\n+                annotated_files.swap(0, pos);\n+            }\n+            // owned: line source, line index, annotations\n+            type Owned = (String, usize, Vec<crate::snippet::Annotation>);\n+            let origin = primary_lo.file.name.to_string();\n+            let annotated_files: Vec<Owned> = annotated_files\n+                .into_iter()\n+                .flat_map(|annotated_file| {\n+                    let file = annotated_file.file;\n+                    annotated_file\n+                        .lines\n+                        .into_iter()\n+                        .map(|line| {\n+                            (source_string(file.clone(), &line), line.line_index, line.annotations)\n+                        })\n+                        .collect::<Vec<Owned>>()\n+                })\n+                .collect();\n+            let snippet = Snippet {\n+                title: Some(Annotation {\n+                    label: Some(&message),\n+                    id: code.as_ref().map(|c| match c {\n+                        DiagnosticId::Error(val) | DiagnosticId::Lint(val) => val.as_str(),\n+                    }),\n+                    annotation_type: annotation_type_for_level(*level),\n+                }),\n+                footer: vec![],\n+                opt: FormatOptions { color: true, anonymized_line_numbers: self.ui_testing },\n+                slices: annotated_files\n+                    .iter()\n+                    .map(|(source, line_index, annotations)| {\n+                        Slice {\n+                            source,\n+                            line_start: *line_index,\n+                            origin: Some(&origin),\n+                            // FIXME(#59346): Not really sure when `fold` should be true or false\n+                            fold: false,\n+                            annotations: annotations\n+                                .into_iter()\n+                                .map(|annotation| SourceAnnotation {\n+                                    range: (annotation.start_col, annotation.end_col),\n+                                    label: annotation\n+                                        .label\n+                                        .as_ref()\n+                                        .map(|s| s.as_str())\n+                                        .unwrap_or_default(),\n+                                    annotation_type: annotation_type_for_level(*level),\n+                                })\n+                                .collect(),\n+                        }\n+                    })\n+                    .collect(),\n+            };\n             // FIXME(#59346): Figure out if we can _always_ print to stderr or not.\n             // `emitter.rs` has the `Destination` enum that lists various possible output\n             // destinations.\n-            eprintln!(\"{}\", dlf.format(&dl));\n-        };\n+            eprintln!(\"{}\", DisplayList::from(snippet))\n+        }\n+        // FIXME(#59346): Is it ok to return None if there's no source_map?\n     }\n }"}, {"sha": "cff83c3d5cda2a7e39e0520b479d8b0f47b93148", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -193,9 +193,18 @@ impl Diagnostic {\n         expected_extra: &dyn fmt::Display,\n         found_extra: &dyn fmt::Display,\n     ) -> &mut Self {\n-        let expected_label = format!(\"expected {}\", expected_label);\n-\n-        let found_label = format!(\"found {}\", found_label);\n+        let expected_label = expected_label.to_string();\n+        let expected_label = if expected_label.is_empty() {\n+            \"expected\".to_string()\n+        } else {\n+            format!(\"expected {}\", expected_label)\n+        };\n+        let found_label = found_label.to_string();\n+        let found_label = if found_label.is_empty() {\n+            \"found\".to_string()\n+        } else {\n+            format!(\"found {}\", found_label)\n+        };\n         let (found_padding, expected_padding) = if expected_label.len() > found_label.len() {\n             (expected_label.len() - found_label.len(), 0)\n         } else {"}, {"sha": "ef617acfe131454c06dbf0ba6c3bcfd76125b075", "filename": "src/librustc_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -11,7 +11,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n log = \"0.4\"\n rustc_span = { path = \"../librustc_span\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }"}, {"sha": "13637e58c93645b4edfc20921245be3f649117b5", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -12,7 +12,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{DiagnosticBuilder, ErrorReported};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n-use rustc_session::parse::ParseSess;\n+use rustc_session::{parse::ParseSess, Limit};\n+use rustc_span::def_id::DefId;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnId, ExpnKind};\n use rustc_span::source_map::SourceMap;\n@@ -593,6 +594,7 @@ impl DummyResult {\n             kind: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(Vec::new()) },\n             span: sp,\n             attrs: ast::AttrVec::new(),\n+            tokens: None,\n         })\n     }\n \n@@ -857,7 +859,13 @@ impl SyntaxExtension {\n         SyntaxExtension::default(SyntaxExtensionKind::NonMacroAttr { mark_used }, edition)\n     }\n \n-    pub fn expn_data(&self, parent: ExpnId, call_site: Span, descr: Symbol) -> ExpnData {\n+    pub fn expn_data(\n+        &self,\n+        parent: ExpnId,\n+        call_site: Span,\n+        descr: Symbol,\n+        macro_def_id: Option<DefId>,\n+    ) -> ExpnData {\n         ExpnData {\n             kind: ExpnKind::Macro(self.macro_kind(), descr),\n             parent,\n@@ -867,6 +875,7 @@ impl SyntaxExtension {\n             allow_internal_unsafe: self.allow_internal_unsafe,\n             local_inner_macros: self.local_inner_macros,\n             edition: self.edition,\n+            macro_def_id,\n         }\n     }\n }\n@@ -932,7 +941,7 @@ pub struct ExpansionData {\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n-    pub reduced_recursion_limit: Option<usize>,\n+    pub reduced_recursion_limit: Option<Limit>,\n     pub root_path: PathBuf,\n     pub resolver: &'a mut dyn Resolver,\n     pub current_expansion: ExpansionData,\n@@ -1086,7 +1095,7 @@ impl<'a> ExtCtxt<'a> {\n         if !path.is_absolute() {\n             let callsite = span.source_callsite();\n             let mut result = match self.source_map().span_to_unmapped_path(callsite) {\n-                FileName::Real(path) => path,\n+                FileName::Real(name) => name.into_local_path(),\n                 FileName::DocTest(path, _) => path,\n                 other => {\n                     return Err(self.struct_span_err("}, {"sha": "6185e014d3c531fcd6400c3c506a247816b5c993", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -70,7 +70,13 @@ impl<'a> ExtCtxt<'a> {\n     pub fn anon_const(&self, span: Span, kind: ast::ExprKind) -> ast::AnonConst {\n         ast::AnonConst {\n             id: ast::DUMMY_NODE_ID,\n-            value: P(ast::Expr { id: ast::DUMMY_NODE_ID, kind, span, attrs: AttrVec::new() }),\n+            value: P(ast::Expr {\n+                id: ast::DUMMY_NODE_ID,\n+                kind,\n+                span,\n+                attrs: AttrVec::new(),\n+                tokens: None,\n+            }),\n         }\n     }\n \n@@ -205,7 +211,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn expr(&self, span: Span, kind: ast::ExprKind) -> P<ast::Expr> {\n-        P(ast::Expr { id: ast::DUMMY_NODE_ID, kind, span, attrs: AttrVec::new() })\n+        P(ast::Expr { id: ast::DUMMY_NODE_ID, kind, span, attrs: AttrVec::new(), tokens: None })\n     }\n \n     pub fn expr_path(&self, path: ast::Path) -> P<ast::Expr> {"}, {"sha": "4e41bd4bbfa08c42532c299ff3093698b44e3142", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -24,6 +24,7 @@ use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n+use rustc_session::Limit;\n use rustc_span::source_map::respan;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{FileName, Span, DUMMY_SP};\n@@ -340,7 +341,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut module = ModuleData {\n             mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n             directory: match self.cx.source_map().span_to_unmapped_path(krate.span) {\n-                FileName::Real(path) => path,\n+                FileName::Real(name) => name.into_local_path(),\n                 other => PathBuf::from(other.to_string()),\n             },\n         };\n@@ -664,7 +665,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     ) -> ExpandResult<AstFragment, Invocation> {\n         let recursion_limit =\n             self.cx.reduced_recursion_limit.unwrap_or(self.cx.ecfg.recursion_limit);\n-        if self.cx.current_expansion.depth > recursion_limit {\n+        if !recursion_limit.value_within_limit(self.cx.current_expansion.depth) {\n             if self.cx.reduced_recursion_limit.is_none() {\n                 self.error_recursion_limit_reached();\n             }\n@@ -988,6 +989,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                     ExpnKind::Macro(MacroKind::Attr, sym::derive),\n                     item.span(),\n                     self.cx.parse_sess.edition,\n+                    None,\n                 )\n             }),\n             _ => None,\n@@ -1783,21 +1785,23 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n pub struct ExpansionConfig<'feat> {\n     pub crate_name: String,\n     pub features: Option<&'feat Features>,\n-    pub recursion_limit: usize,\n+    pub recursion_limit: Limit,\n     pub trace_mac: bool,\n     pub should_test: bool, // If false, strip `#[test]` nodes\n     pub keep_macs: bool,\n+    pub span_debug: bool, // If true, use verbose debugging for `proc_macro::Span`\n }\n \n impl<'feat> ExpansionConfig<'feat> {\n     pub fn default(crate_name: String) -> ExpansionConfig<'static> {\n         ExpansionConfig {\n             crate_name,\n             features: None,\n-            recursion_limit: 1024,\n+            recursion_limit: Limit::new(1024),\n             trace_mac: false,\n             should_test: false,\n             keep_macs: false,\n+            span_debug: false,\n         }\n     }\n "}, {"sha": "535c1dbad04a9dab1e3f9a5370795577f6f57715", "filename": "src/librustc_expand/module.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmodule.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -71,7 +71,7 @@ crate fn parse_external_mod(\n     // Extract the directory path for submodules of `module`.\n     let path = sess.source_map().span_to_unmapped_path(module.inner);\n     let mut path = match path {\n-        FileName::Real(path) => path,\n+        FileName::Real(name) => name.into_local_path(),\n         other => PathBuf::from(other.to_string()),\n     };\n     path.pop();\n@@ -189,7 +189,8 @@ fn error_cannot_declare_mod_here<'a, T>(\n     let mut err =\n         sess.span_diagnostic.struct_span_err(span, \"cannot declare a new module at this location\");\n     if !span.is_dummy() {\n-        if let FileName::Real(src_path) = sess.source_map().span_to_filename(span) {\n+        if let FileName::Real(src_name) = sess.source_map().span_to_filename(span) {\n+            let src_path = src_name.into_local_path();\n             if let Some(stem) = src_path.file_stem() {\n                 let mut dest_path = src_path.clone();\n                 dest_path.set_file_name(stem);\n@@ -290,7 +291,7 @@ pub fn default_submod_path<'a>(\n             let mut err = struct_span_err!(\n                 sess.span_diagnostic,\n                 span,\n-                E0584,\n+                E0761,\n                 \"file for module `{}` found at both {} and {}\",\n                 mod_name,\n                 default_path_str,"}, {"sha": "b4ffd714feffafa837007d217ec7d7951f871141", "filename": "src/librustc_expand/placeholders.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fplaceholders.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -34,6 +34,7 @@ pub fn placeholder(\n             span,\n             attrs: ast::AttrVec::new(),\n             kind: ast::ExprKind::MacCall(mac_placeholder()),\n+            tokens: None,\n         })\n     };\n     let ty = || P(ast::Ty { id, kind: ast::TyKind::MacCall(mac_placeholder()), span });"}, {"sha": "79fa091ba180888e17d73986e103e6a2737df634", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -352,6 +352,7 @@ pub(crate) struct Rustc<'a> {\n     def_site: Span,\n     call_site: Span,\n     mixed_site: Span,\n+    span_debug: bool,\n }\n \n impl<'a> Rustc<'a> {\n@@ -362,6 +363,7 @@ impl<'a> Rustc<'a> {\n             def_site: cx.with_def_site_ctxt(expn_data.def_site),\n             call_site: cx.with_call_site_ctxt(expn_data.call_site),\n             mixed_site: cx.with_mixed_site_ctxt(expn_data.call_site),\n+            span_debug: cx.ecfg.span_debug,\n         }\n     }\n \n@@ -602,7 +604,8 @@ impl server::SourceFile for Rustc<'_> {\n     }\n     fn path(&mut self, file: &Self::SourceFile) -> String {\n         match file.name {\n-            FileName::Real(ref path) => path\n+            FileName::Real(ref name) => name\n+                .local_path()\n                 .to_str()\n                 .expect(\"non-UTF8 file path in `proc_macro::SourceFile::path`\")\n                 .to_string(),\n@@ -645,7 +648,11 @@ impl server::Diagnostic for Rustc<'_> {\n \n impl server::Span for Rustc<'_> {\n     fn debug(&mut self, span: Self::Span) -> String {\n-        format!(\"{:?} bytes({}..{})\", span.ctxt(), span.lo().0, span.hi().0)\n+        if self.span_debug {\n+            format!(\"{:?}\", span)\n+        } else {\n+            format!(\"{:?} bytes({}..{})\", span.ctxt(), span.lo().0, span.hi().0)\n+        }\n     }\n     fn def_site(&mut self) -> Self::Span {\n         self.def_site"}, {"sha": "fd35cb6c3f78557354c2912ff274620eb8dd6d37", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -571,6 +571,9 @@ declare_features! (\n     /// Allows the use of `#[ffi_const]` on foreign functions.\n     (active, ffi_const, \"1.45.0\", Some(58328), None),\n \n+    /// No longer treat an unsafe function as an unsafe block.\n+    (active, unsafe_block_in_unsafe_fn, \"1.45.0\", Some(71668), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "524a35797102917acd4a601019fd2718f3bbc824", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -366,7 +366,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // FIXME(#14407)\n     ungated!(rustc_const_stable, Whitelisted, template!(List: r#\"feature = \"name\"\"#)),\n     gated!(\n-        allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"),\n+        allow_internal_unstable, Whitelisted, template!(Word, List: \"feat1, feat2, ...\"),\n         \"allow_internal_unstable side-steps feature gating and stability checks\",\n     ),\n     gated!("}, {"sha": "9a5e78a560cf05cdcabebebc3ebfc6b10bf955da", "filename": "src/librustc_graphviz/Cargo.toml", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_graphviz%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_graphviz%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_graphviz%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,9 +1,9 @@\n [package]\n authors = [\"The Rust Project Developers\"]\n-name = \"graphviz\"\n+name = \"rustc_graphviz\"\n version = \"0.0.0\"\n edition = \"2018\"\n \n [lib]\n-name = \"graphviz\"\n+name = \"rustc_graphviz\"\n path = \"lib.rs\"", "previous_filename": "src/libgraphviz/Cargo.toml"}, {"sha": "4339092b63e85cd28da48f33e3aad538267b723d", "filename": "src/librustc_graphviz/lib.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_graphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_graphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_graphviz%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -40,7 +40,7 @@\n //! #![feature(rustc_private)]\n //!\n //! use std::io::Write;\n-//! use graphviz as dot;\n+//! use rustc_graphviz as dot;\n //!\n //! type Nd = isize;\n //! type Ed = (isize,isize);\n@@ -145,7 +145,7 @@\n //! #![feature(rustc_private)]\n //!\n //! use std::io::Write;\n-//! use graphviz as dot;\n+//! use rustc_graphviz as dot;\n //!\n //! type Nd = usize;\n //! type Ed<'a> = &'a (usize, usize);\n@@ -207,7 +207,7 @@\n //! #![feature(rustc_private)]\n //!\n //! use std::io::Write;\n-//! use graphviz as dot;\n+//! use rustc_graphviz as dot;\n //!\n //! type Nd<'a> = (usize, &'a str);\n //! type Ed<'a> = (Nd<'a>, Nd<'a>);", "previous_filename": "src/libgraphviz/lib.rs"}, {"sha": "055e13156ae84e3cb682d3caaa656e66cbd2b9b9", "filename": "src/librustc_graphviz/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_graphviz%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_graphviz%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_graphviz%2Ftests.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "previous_filename": "src/libgraphviz/tests.rs"}, {"sha": "1b91d769c7047cec151875cf2b0fe743cb3fa37f", "filename": "src/librustc_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -15,7 +15,7 @@ rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_span = { path = \"../librustc_span\" }\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n lazy_static = \"1\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }"}, {"sha": "2dd5e27ead2658b79dd7c11aeb41a8bd3add30e6", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -327,18 +327,9 @@ impl Definitions {\n \n     #[inline]\n     pub fn local_def_id(&self, node: ast::NodeId) -> LocalDefId {\n-        self.opt_local_def_id(node).unwrap()\n-    }\n-\n-    #[inline]\n-    pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n-        if let Some(def_id) = def_id.as_local() {\n-            let node_id = self.def_id_to_node_id[def_id];\n-            if node_id != ast::DUMMY_NODE_ID {\n-                return Some(node_id);\n-            }\n-        }\n-        None\n+        self.opt_local_def_id(node).unwrap_or_else(|| {\n+            panic!(\"no entry for node id: `{:?}` / `{:?}`\", node, self.opt_node_id_to_hir_id(node))\n+        })\n     }\n \n     #[inline]\n@@ -373,6 +364,12 @@ impl Definitions {\n         self.node_id_to_hir_id[node_id]\n     }\n \n+    #[inline]\n+    pub fn opt_hir_id_to_local_def_id(&self, hir_id: hir::HirId) -> Option<LocalDefId> {\n+        let node_id = self.hir_id_to_node_id(hir_id);\n+        self.opt_local_def_id(node_id)\n+    }\n+\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {"}, {"sha": "1e305c6d32d6ad2a0fd5310890c0f5208707120f", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,7 +10,6 @@ pub use rustc_ast::ast::{CaptureBy, Movability, Mutability};\n use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::util::parser::ExprPrecedence;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_macros::HashStable_Generic;\n use rustc_span::source_map::{SourceMap, Spanned};\n@@ -525,6 +524,13 @@ impl WhereClause<'_> {\n     pub fn span_for_predicates_or_empty_place(&self) -> Span {\n         self.span\n     }\n+\n+    /// `Span` where further predicates would be suggested, accounting for trailing commas, like\n+    ///  in `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n+    pub fn tail_span_for_suggestion(&self) -> Span {\n+        let end = self.span_for_predicates_or_empty_place().shrink_to_hi();\n+        self.predicates.last().map(|p| p.span()).unwrap_or(end).shrink_to_hi().to(end)\n+    }\n }\n \n /// A single predicate in a where-clause.\n@@ -2107,6 +2113,7 @@ pub struct InlineAsm<'hir> {\n     pub template: &'hir [InlineAsmTemplatePiece],\n     pub operands: &'hir [InlineAsmOperand<'hir>],\n     pub options: InlineAsmOptions,\n+    pub line_spans: &'hir [Span],\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic, PartialEq)]\n@@ -2664,10 +2671,6 @@ impl<ID> TraitCandidate<ID> {\n // Trait method resolution\n pub type TraitMap<ID = HirId> = NodeMap<Vec<TraitCandidate<ID>>>;\n \n-// Map from the NodeId of a glob import to a list of items which are actually\n-// imported.\n-pub type GlobMap = NodeMap<FxHashSet<Symbol>>;\n-\n #[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum Node<'hir> {\n     Param(&'hir Param<'hir>),"}, {"sha": "83bada4041963deec529489e623e952b9fc98939", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -257,4 +257,6 @@ language_item_table! {\n     AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n \n     TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n+\n+    TryTraitLangItem,            \"try\",                try_trait,               Target::Trait;\n }"}, {"sha": "e642915b86a5e322ccf00d72ce721ee941e40936", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -203,6 +203,30 @@ pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility<'_\n     })\n }\n \n+pub fn generic_params_to_string(generic_params: &[GenericParam<'_>]) -> String {\n+    to_string(NO_ANN, |s| s.print_generic_params(generic_params))\n+}\n+\n+pub fn bounds_to_string<'b>(bounds: impl IntoIterator<Item = &'b hir::GenericBound<'b>>) -> String {\n+    to_string(NO_ANN, |s| s.print_bounds(\"\", bounds))\n+}\n+\n+pub fn param_to_string(arg: &hir::Param<'_>) -> String {\n+    to_string(NO_ANN, |s| s.print_param(arg))\n+}\n+\n+pub fn ty_to_string(ty: &hir::Ty<'_>) -> String {\n+    to_string(NO_ANN, |s| s.print_type(ty))\n+}\n+\n+pub fn path_segment_to_string(segment: &hir::PathSegment<'_>) -> String {\n+    to_string(NO_ANN, |s| s.print_path_segment(segment))\n+}\n+\n+pub fn path_to_string(segment: &hir::Path<'_>) -> String {\n+    to_string(NO_ANN, |s| s.print_path(segment, false))\n+}\n+\n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) {\n         self.s.cbox(u);"}, {"sha": "7b3030fa1d9c1a4c0a8005a4b0a87bbecd421aa5", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,13 +10,13 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-graphviz = { path = \"../libgraphviz\" }\n+rustc_graphviz = { path = \"../librustc_graphviz\" }\n log = \"0.4\"\n rand = \"0.7\"\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_fs_util = { path = \"../librustc_fs_util\" }"}, {"sha": "b1665d9e1aeb3a1aaa09d53d0721cfd13d5afb35", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -33,10 +33,10 @@\n //! fn baz() { foo(); }\n //! ```\n \n-use graphviz as dot;\n use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{Direction, NodeIndex, INCOMING, OUTGOING};\n+use rustc_graphviz as dot;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};"}, {"sha": "f0422b1af1b973618979affefc8cc3fb04561021", "filename": "src/librustc_index/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,5 +10,5 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "3effc4164501155007c3006929201b2e9042d0d9", "filename": "src/librustc_index/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_index%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_index%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -2,6 +2,7 @@\n #![feature(const_if_match)]\n #![feature(const_fn)]\n #![feature(const_panic)]\n+#![feature(extend_one)]\n #![feature(unboxed_closures)]\n #![feature(test)]\n #![feature(fn_traits)]"}, {"sha": "4dde33283f575bab63edc8ec1b077798de874052", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -736,6 +736,16 @@ impl<I: Idx, T> Extend<T> for IndexVec<I, T> {\n     fn extend<J: IntoIterator<Item = T>>(&mut self, iter: J) {\n         self.raw.extend(iter);\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, item: T) {\n+        self.raw.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.raw.reserve(additional);\n+    }\n }\n \n impl<I: Idx, T> FromIterator<T> for IndexVec<I, T> {"}, {"sha": "06fc7ecf95f26bceac876f68575e4206d93de854", "filename": "src/librustc_infer/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-graphviz = { path = \"../libgraphviz\" }\n+rustc_graphviz = { path = \"../librustc_graphviz\" }\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n@@ -19,7 +19,7 @@ rustc_hir = { path = \"../librustc_hir\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_session = { path = \"../librustc_session\" }\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "c2dae6ba4f83db32e9e5dfe0120e35f21d092950", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -332,7 +332,6 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n-            | ty::ReScope(_)\n             | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n             | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),"}, {"sha": "7310d2c3bdcf8318fc1d304069798bd98afa6331", "filename": "src/librustc_infer/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -87,7 +87,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ) -> CanonicalVarValues<'tcx> {\n         let var_values: IndexVec<BoundVar, GenericArg<'tcx>> = variables\n             .iter()\n-            .map(|info| self.instantiate_canonical_var(span, *info, &universe_map))\n+            .map(|info| self.instantiate_canonical_var(span, info, &universe_map))\n             .collect();\n \n         CanonicalVarValues { var_values }"}, {"sha": "ab2393918c35420072b38b59010728123e16b3c2", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, BoundVar, Const, Ty, TyCtxt};\n+use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n use std::fmt::Debug;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n@@ -464,12 +464,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     if info.is_existential() {\n                         match opt_values[BoundVar::new(index)] {\n                             Some(k) => k,\n-                            None => self.instantiate_canonical_var(cause.span, *info, |u| {\n+                            None => self.instantiate_canonical_var(cause.span, info, |u| {\n                                 universe_map[u.as_usize()]\n                             }),\n                         }\n                     } else {\n-                        self.instantiate_canonical_var(cause.span, *info, |u| {\n+                        self.instantiate_canonical_var(cause.span, info, |u| {\n                             universe_map[u.as_usize()]\n                         })\n                     }\n@@ -532,12 +532,14 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 cause.clone(),\n                 param_env,\n                 match k1.unpack() {\n-                    GenericArgKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n+                    GenericArgKind::Lifetime(r1) => ty::PredicateKind::RegionOutlives(\n                         ty::Binder::bind(ty::OutlivesPredicate(r1, r2)),\n-                    ),\n-                    GenericArgKind::Type(t1) => {\n-                        ty::Predicate::TypeOutlives(ty::Binder::bind(ty::OutlivesPredicate(t1, r2)))\n-                    }\n+                    )\n+                    .to_predicate(self.tcx),\n+                    GenericArgKind::Type(t1) => ty::PredicateKind::TypeOutlives(ty::Binder::bind(\n+                        ty::OutlivesPredicate(t1, r2),\n+                    ))\n+                    .to_predicate(self.tcx),\n                     GenericArgKind::Const(..) => {\n                         // Consts cannot outlive one another, so we don't expect to\n                         // ecounter this branch.\n@@ -664,9 +666,10 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         self.obligations.push(Obligation {\n             cause: self.cause.clone(),\n             param_env: self.param_env,\n-            predicate: ty::Predicate::RegionOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n+            predicate: ty::PredicateKind::RegionOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n                 sup, sub,\n-            ))),\n+            )))\n+            .to_predicate(self.infcx.tcx),\n             recursion_depth: 0,\n         });\n     }"}, {"sha": "4ef4ed47cb11a8b20543d907e80c2c5e3275b0e7", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -39,7 +39,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, InferConst, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, InferConst, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{IntType, UintType};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -307,7 +307,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             self.obligations.push(Obligation::new(\n                 self.trace.cause.clone(),\n                 self.param_env,\n-                ty::Predicate::WellFormed(b_ty),\n+                ty::PredicateKind::WellFormed(b_ty.into()).to_predicate(self.infcx.tcx),\n             ));\n         }\n \n@@ -398,11 +398,15 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         b: &'tcx ty::Const<'tcx>,\n     ) {\n         let predicate = if a_is_expected {\n-            ty::Predicate::ConstEquate(a, b)\n+            ty::PredicateKind::ConstEquate(a, b)\n         } else {\n-            ty::Predicate::ConstEquate(b, a)\n+            ty::PredicateKind::ConstEquate(b, a)\n         };\n-        self.obligations.push(Obligation::new(self.trace.cause.clone(), self.param_env, predicate));\n+        self.obligations.push(Obligation::new(\n+            self.trace.cause.clone(),\n+            self.param_env,\n+            predicate.to_predicate(self.tcx()),\n+        ));\n     }\n }\n \n@@ -615,7 +619,6 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n             | ty::ReVar(..)\n             | ty::ReEmpty(_)\n             | ty::ReStatic\n-            | ty::ReScope(..)\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(..) => {\n                 // see common code below"}, {"sha": "a59a91e3005aacda59f9429c41b5f6e9e483124b", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 178, "deletions": 195, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -60,8 +60,7 @@ use rustc_errors::{pluralize, struct_span_err};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::Node;\n-use rustc_middle::middle::region;\n+use rustc_hir::{Item, ItemKind, Node};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{\n     self,\n@@ -81,58 +80,12 @@ pub mod nice_region_error;\n \n pub(super) fn note_and_explain_region(\n     tcx: TyCtxt<'tcx>,\n-    region_scope_tree: &region::ScopeTree,\n     err: &mut DiagnosticBuilder<'_>,\n     prefix: &str,\n     region: ty::Region<'tcx>,\n     suffix: &str,\n ) {\n     let (description, span) = match *region {\n-        ty::ReScope(scope) => {\n-            let new_string;\n-            let unknown_scope =\n-                || format!(\"{}unknown scope: {:?}{}.  Please report a bug.\", prefix, scope, suffix);\n-            let span = scope.span(tcx, region_scope_tree);\n-            let hir_id = scope.hir_id(region_scope_tree);\n-            let tag = match hir_id.and_then(|hir_id| tcx.hir().find(hir_id)) {\n-                Some(Node::Block(_)) => \"block\",\n-                Some(Node::Expr(expr)) => match expr.kind {\n-                    hir::ExprKind::Call(..) => \"call\",\n-                    hir::ExprKind::MethodCall(..) => \"method call\",\n-                    hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                    hir::ExprKind::Match(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n-                    hir::ExprKind::Match(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n-                    hir::ExprKind::Match(..) => \"match\",\n-                    _ => \"expression\",\n-                },\n-                Some(Node::Stmt(_)) => \"statement\",\n-                Some(Node::Item(it)) => item_scope_tag(&it),\n-                Some(Node::TraitItem(it)) => trait_item_scope_tag(&it),\n-                Some(Node::ImplItem(it)) => impl_item_scope_tag(&it),\n-                Some(_) | None => {\n-                    err.span_note(span, &unknown_scope());\n-                    return;\n-                }\n-            };\n-            let scope_decorated_tag = match scope.data {\n-                region::ScopeData::Node => tag,\n-                region::ScopeData::CallSite => \"scope of call-site for function\",\n-                region::ScopeData::Arguments => \"scope of function body\",\n-                region::ScopeData::Destruction => {\n-                    new_string = format!(\"destruction scope surrounding {}\", tag);\n-                    &new_string[..]\n-                }\n-                region::ScopeData::Remainder(first_statement_index) => {\n-                    new_string = format!(\n-                        \"block suffix following statement {}\",\n-                        first_statement_index.index()\n-                    );\n-                    &new_string[..]\n-                }\n-            };\n-            explain_span(tcx, scope_decorated_tag, span)\n-        }\n-\n         ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n             msg_span_from_free_region(tcx, region)\n         }\n@@ -284,7 +237,6 @@ fn explain_span(tcx: TyCtxt<'tcx>, heading: &str, span: Span) -> (String, Option\n \n pub fn unexpected_hidden_region_diagnostic(\n     tcx: TyCtxt<'tcx>,\n-    region_scope_tree: Option<&region::ScopeTree>,\n     span: Span,\n     hidden_ty: Ty<'tcx>,\n     hidden_region: ty::Region<'tcx>,\n@@ -297,64 +249,56 @@ pub fn unexpected_hidden_region_diagnostic(\n     );\n \n     // Explain the region we are capturing.\n-    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) = hidden_region {\n-        // Assuming regionck succeeded (*), we ought to always be\n-        // capturing *some* region from the fn header, and hence it\n-        // ought to be free. So under normal circumstances, we will go\n-        // down this path which gives a decent human readable\n-        // explanation.\n-        //\n-        // (*) if not, the `tainted_by_errors` field would be set to\n-        // `Some(ErrorReported)` in any case, so we wouldn't be here at all.\n-        note_and_explain_free_region(\n-            tcx,\n-            &mut err,\n-            &format!(\"hidden type `{}` captures \", hidden_ty),\n-            hidden_region,\n-            \"\",\n-        );\n-    } else {\n-        // Ugh. This is a painful case: the hidden region is not one\n-        // that we can easily summarize or explain. This can happen\n-        // in a case like\n-        // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n-        //\n-        // ```\n-        // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n-        //   if condition() { a } else { b }\n-        // }\n-        // ```\n-        //\n-        // Here the captured lifetime is the intersection of `'a` and\n-        // `'b`, which we can't quite express.\n-\n-        if let Some(region_scope_tree) = region_scope_tree {\n-            // If the `region_scope_tree` is available, this is being\n-            // invoked from the \"region inferencer error\". We can at\n-            // least report a really cryptic error for now.\n-            note_and_explain_region(\n+    match hidden_region {\n+        ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n+            // All lifetimes shorter than the function body are `empty` in\n+            // lexical region resolution. The default explanation of \"an empty\n+            // lifetime\" isn't really accurate here.\n+            let message = format!(\n+                \"hidden type `{}` captures lifetime smaller than the function body\",\n+                hidden_ty\n+            );\n+            err.span_note(span, &message);\n+        }\n+        ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) => {\n+            // Assuming regionck succeeded (*), we ought to always be\n+            // capturing *some* region from the fn header, and hence it\n+            // ought to be free. So under normal circumstances, we will go\n+            // down this path which gives a decent human readable\n+            // explanation.\n+            //\n+            // (*) if not, the `tainted_by_errors` field would be set to\n+            // `Some(ErrorReported)` in any case, so we wouldn't be here at all.\n+            note_and_explain_free_region(\n                 tcx,\n-                region_scope_tree,\n                 &mut err,\n                 &format!(\"hidden type `{}` captures \", hidden_ty),\n                 hidden_region,\n                 \"\",\n             );\n-        } else {\n-            // If the `region_scope_tree` is *unavailable*, this is\n-            // being invoked by the code that comes *after* region\n-            // inferencing. This is a bug, as the region inferencer\n-            // ought to have noticed the failed constraint and invoked\n-            // error reporting, which in turn should have prevented us\n-            // from getting trying to infer the hidden type\n-            // completely.\n-            tcx.sess.delay_span_bug(\n-                span,\n-                &format!(\n-                    \"hidden type captures unexpected lifetime `{:?}` \\\n-                     but no region inference failure\",\n-                    hidden_region,\n-                ),\n+        }\n+        _ => {\n+            // Ugh. This is a painful case: the hidden region is not one\n+            // that we can easily summarize or explain. This can happen\n+            // in a case like\n+            // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n+            //\n+            // ```\n+            // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n+            //   if condition() { a } else { b }\n+            // }\n+            // ```\n+            //\n+            // Here the captured lifetime is the intersection of `'a` and\n+            // `'b`, which we can't quite express.\n+\n+            // We can at least report a really cryptic error for now.\n+            note_and_explain_region(\n+                tcx,\n+                &mut err,\n+                &format!(\"hidden type `{}` captures \", hidden_ty),\n+                hidden_region,\n+                \"\",\n             );\n         }\n     }\n@@ -363,11 +307,7 @@ pub fn unexpected_hidden_region_diagnostic(\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn report_region_errors(\n-        &self,\n-        region_scope_tree: &region::ScopeTree,\n-        errors: &Vec<RegionResolutionError<'tcx>>,\n-    ) {\n+    pub fn report_region_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -390,17 +330,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // general bit of code that displays the error information\n                     RegionResolutionError::ConcreteFailure(origin, sub, sup) => {\n                         if sub.is_placeholder() || sup.is_placeholder() {\n-                            self.report_placeholder_failure(region_scope_tree, origin, sub, sup)\n-                                .emit();\n+                            self.report_placeholder_failure(origin, sub, sup).emit();\n                         } else {\n-                            self.report_concrete_failure(region_scope_tree, origin, sub, sup)\n-                                .emit();\n+                            self.report_concrete_failure(origin, sub, sup).emit();\n                         }\n                     }\n \n                     RegionResolutionError::GenericBoundFailure(origin, param_ty, sub) => {\n                         self.report_generic_bound_failure(\n-                            region_scope_tree,\n                             origin.span(),\n                             Some(origin),\n                             param_ty,\n@@ -417,29 +354,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         sup_r,\n                     ) => {\n                         if sub_r.is_placeholder() {\n-                            self.report_placeholder_failure(\n-                                region_scope_tree,\n-                                sub_origin,\n-                                sub_r,\n-                                sup_r,\n-                            )\n-                            .emit();\n+                            self.report_placeholder_failure(sub_origin, sub_r, sup_r).emit();\n                         } else if sup_r.is_placeholder() {\n-                            self.report_placeholder_failure(\n-                                region_scope_tree,\n-                                sup_origin,\n-                                sub_r,\n-                                sup_r,\n-                            )\n-                            .emit();\n+                            self.report_placeholder_failure(sup_origin, sub_r, sup_r).emit();\n                         } else {\n                             self.report_sub_sup_conflict(\n-                                region_scope_tree,\n-                                var_origin,\n-                                sub_origin,\n-                                sub_r,\n-                                sup_origin,\n-                                sup_r,\n+                                var_origin, sub_origin, sub_r, sup_origin, sup_r,\n                             );\n                         }\n                     }\n@@ -460,13 +380,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // value.\n                         let sub_r = self.tcx.mk_region(ty::ReEmpty(var_universe));\n \n-                        self.report_placeholder_failure(\n-                            region_scope_tree,\n-                            sup_origin,\n-                            sub_r,\n-                            sup_r,\n-                        )\n-                        .emit();\n+                        self.report_placeholder_failure(sup_origin, sub_r, sup_r).emit();\n                     }\n \n                     RegionResolutionError::MemberConstraintFailure {\n@@ -477,7 +391,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n                         unexpected_hidden_region_diagnostic(\n                             self.tcx,\n-                            Some(region_scope_tree),\n                             span,\n                             hidden_ty,\n                             member_region,\n@@ -1074,12 +987,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         fn push_ty_ref<'tcx>(\n-            r: &ty::Region<'tcx>,\n+            region: &ty::Region<'tcx>,\n             ty: Ty<'tcx>,\n             mutbl: hir::Mutability,\n             s: &mut DiagnosticStyledString,\n         ) {\n-            let mut r = r.to_string();\n+            let mut r = region.to_string();\n             if r == \"'_\" {\n                 r.clear();\n             } else {\n@@ -1754,67 +1667,107 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn report_generic_bound_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         span: Span,\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) {\n-        self.construct_generic_bound_failure(region_scope_tree, span, origin, bound_kind, sub)\n-            .emit();\n+        self.construct_generic_bound_failure(span, origin, bound_kind, sub).emit();\n     }\n \n     pub fn construct_generic_bound_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         span: Span,\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) -> DiagnosticBuilder<'a> {\n+        let hir = &self.tcx.hir();\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n-        let type_param_span = match (self.in_progress_tables, bound_kind) {\n-            (Some(ref table), GenericKind::Param(ref param)) => {\n-                let table_owner = table.borrow().hir_owner;\n-                table_owner.and_then(|table_owner| {\n-                    let generics = self.tcx.generics_of(table_owner.to_def_id());\n-                    // Account for the case where `param` corresponds to `Self`,\n-                    // which doesn't have the expected type argument.\n-                    if !(generics.has_self && param.index == 0) {\n-                        let type_param = generics.type_param(param, self.tcx);\n-                        let hir = &self.tcx.hir();\n-                        type_param.def_id.as_local().map(|def_id| {\n-                            // Get the `hir::Param` to verify whether it already has any bounds.\n-                            // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n-                            // instead we suggest `T: 'a + 'b` in that case.\n-                            let id = hir.as_local_hir_id(def_id);\n-                            let mut has_bounds = false;\n-                            if let Node::GenericParam(param) = hir.get(id) {\n-                                has_bounds = !param.bounds.is_empty();\n-                            }\n-                            let sp = hir.span(id);\n-                            // `sp` only covers `T`, change it so that it covers\n-                            // `T:` when appropriate\n-                            let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n-                            let sp = if has_bounds && !is_impl_trait {\n-                                sp.to(self\n-                                    .tcx\n-                                    .sess\n-                                    .source_map()\n-                                    .next_point(self.tcx.sess.source_map().next_point(sp)))\n-                            } else {\n-                                sp\n-                            };\n-                            (sp, has_bounds, is_impl_trait)\n-                        })\n+        let generics =\n+            self.in_progress_tables.and_then(|table| table.borrow().hir_owner).map(|table_owner| {\n+                let hir_id = hir.as_local_hir_id(table_owner);\n+                let parent_id = hir.get_parent_item(hir_id);\n+                (\n+                    // Parent item could be a `mod`, so we check the HIR before calling:\n+                    if let Some(Node::Item(Item {\n+                        kind: ItemKind::Trait(..) | ItemKind::Impl { .. },\n+                        ..\n+                    })) = hir.find(parent_id)\n+                    {\n+                        Some(self.tcx.generics_of(hir.local_def_id(parent_id).to_def_id()))\n                     } else {\n                         None\n-                    }\n-                })\n+                    },\n+                    self.tcx.generics_of(table_owner.to_def_id()),\n+                )\n+            });\n+        let type_param_span = match (generics, bound_kind) {\n+            (Some((_, ref generics)), GenericKind::Param(ref param)) => {\n+                // Account for the case where `param` corresponds to `Self`,\n+                // which doesn't have the expected type argument.\n+                if !(generics.has_self && param.index == 0) {\n+                    let type_param = generics.type_param(param, self.tcx);\n+                    type_param.def_id.as_local().map(|def_id| {\n+                        // Get the `hir::Param` to verify whether it already has any bounds.\n+                        // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n+                        // instead we suggest `T: 'a + 'b` in that case.\n+                        let id = hir.as_local_hir_id(def_id);\n+                        let mut has_bounds = false;\n+                        if let Node::GenericParam(param) = hir.get(id) {\n+                            has_bounds = !param.bounds.is_empty();\n+                        }\n+                        let sp = hir.span(id);\n+                        // `sp` only covers `T`, change it so that it covers\n+                        // `T:` when appropriate\n+                        let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n+                        let sp = if has_bounds && !is_impl_trait {\n+                            sp.to(self\n+                                .tcx\n+                                .sess\n+                                .source_map()\n+                                .next_point(self.tcx.sess.source_map().next_point(sp)))\n+                        } else {\n+                            sp\n+                        };\n+                        (sp, has_bounds, is_impl_trait)\n+                    })\n+                } else {\n+                    None\n+                }\n             }\n             _ => None,\n         };\n+        let new_lt = generics\n+            .as_ref()\n+            .and_then(|(parent_g, g)| {\n+                let possible: Vec<_> = (b'a'..=b'z').map(|c| format!(\"'{}\", c as char)).collect();\n+                let mut lts_names = g\n+                    .params\n+                    .iter()\n+                    .filter(|p| matches!(p.kind, ty::GenericParamDefKind::Lifetime))\n+                    .map(|p| p.name.as_str())\n+                    .collect::<Vec<_>>();\n+                if let Some(g) = parent_g {\n+                    lts_names.extend(\n+                        g.params\n+                            .iter()\n+                            .filter(|p| matches!(p.kind, ty::GenericParamDefKind::Lifetime))\n+                            .map(|p| p.name.as_str()),\n+                    );\n+                }\n+                let lts = lts_names.iter().map(|s| -> &str { &*s }).collect::<Vec<_>>();\n+                possible.into_iter().find(|candidate| !lts.contains(&candidate.as_str()))\n+            })\n+            .unwrap_or(\"'lt\".to_string());\n+        let add_lt_sugg = generics\n+            .as_ref()\n+            .and_then(|(_, g)| g.params.first())\n+            .and_then(|param| param.def_id.as_local())\n+            .map(|def_id| {\n+                (hir.span(hir.as_local_hir_id(def_id)).shrink_to_lo(), format!(\"{}, \", new_lt))\n+            });\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n@@ -1871,6 +1824,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n+        let new_binding_suggestion =\n+            |err: &mut DiagnosticBuilder<'tcx>,\n+             type_param_span: Option<(Span, bool, bool)>,\n+             bound_kind: GenericKind<'tcx>| {\n+                let msg = \"consider introducing an explicit lifetime bound\";\n+                if let Some((sp, has_lifetimes, is_impl_trait)) = type_param_span {\n+                    let suggestion = if is_impl_trait {\n+                        (sp.shrink_to_hi(), format!(\" + {}\", new_lt))\n+                    } else {\n+                        let tail = if has_lifetimes { \" +\" } else { \"\" };\n+                        (sp, format!(\"{}: {}{}\", bound_kind, new_lt, tail))\n+                    };\n+                    let mut sugg =\n+                        vec![suggestion, (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n+                    if let Some(lt) = add_lt_sugg {\n+                        sugg.push(lt);\n+                        sugg.rotate_right(1);\n+                    }\n+                    // `MaybeIncorrect` due to issue #41966.\n+                    err.multipart_suggestion(msg, sugg, Applicability::MaybeIncorrect);\n+                }\n+            };\n+\n         let mut err = match *sub {\n             ty::ReEarlyBound(ty::EarlyBoundRegion { name, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: ty::BrNamed(_, name), .. }) => {\n@@ -1912,18 +1888,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"{} may not live long enough\",\n                     labeled_user_string\n                 );\n-                err.help(&format!(\n-                    \"consider adding an explicit lifetime bound for `{}`\",\n-                    bound_kind\n-                ));\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n                     \"...\",\n                 );\n+                if let Some(infer::RelateParamBound(_, t)) = origin {\n+                    let t = self.resolve_vars_if_possible(&t);\n+                    match t.kind {\n+                        // We've got:\n+                        // fn get_later<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+                        // suggest:\n+                        // fn get_later<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+                        ty::Closure(_, _substs) | ty::Opaque(_, _substs) => {\n+                            new_binding_suggestion(&mut err, type_param_span, bound_kind);\n+                        }\n+                        _ => {\n+                            binding_suggestion(&mut err, type_param_span, bound_kind, new_lt);\n+                        }\n+                    }\n+                }\n                 err\n             }\n         };\n@@ -1936,7 +1922,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     fn report_sub_sup_conflict(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         var_origin: RegionVariableOrigin,\n         sub_origin: SubregionOrigin<'tcx>,\n         sub_region: Region<'tcx>,\n@@ -1947,21 +1932,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         note_and_explain_region(\n             self.tcx,\n-            region_scope_tree,\n             &mut err,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n             \"...\",\n         );\n \n+        debug!(\"report_sub_sup_conflict: var_origin={:?}\", var_origin);\n+        debug!(\"report_sub_sup_conflict: sub_region={:?}\", sub_region);\n+        debug!(\"report_sub_sup_conflict: sub_origin={:?}\", sub_origin);\n+        debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n+        debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n+\n         if let (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) =\n             (&sup_origin, &sub_origin)\n         {\n-            debug!(\"report_sub_sup_conflict: var_origin={:?}\", var_origin);\n-            debug!(\"report_sub_sup_conflict: sub_region={:?}\", sub_region);\n-            debug!(\"report_sub_sup_conflict: sub_origin={:?}\", sub_origin);\n-            debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n-            debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n             debug!(\"report_sub_sup_conflict: sup_trace={:?}\", sup_trace);\n             debug!(\"report_sub_sup_conflict: sub_trace={:?}\", sub_trace);\n             debug!(\"report_sub_sup_conflict: sup_trace.values={:?}\", sup_trace.values);\n@@ -1973,7 +1958,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if sub_expected == sup_expected && sub_found == sup_found {\n                     note_and_explain_region(\n                         self.tcx,\n-                        region_scope_tree,\n                         &mut err,\n                         \"...but the lifetime must also be valid for \",\n                         sub_region,\n@@ -1995,7 +1979,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         note_and_explain_region(\n             self.tcx,\n-            region_scope_tree,\n             &mut err,\n             \"but, the lifetime must be valid for \",\n             sub_region,"}, {"sha": "7ab18e54f7ea2342210629fa6af0286ccbf5f140", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -121,16 +121,14 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             (Some(ret_span), _) => (\n                 ty_sub.span,\n                 ret_span,\n-                \"this parameter and the return type are declared \\\n-                 with different lifetimes...\"\n+                \"this parameter and the return type are declared with different lifetimes...\"\n                     .to_owned(),\n                 format!(\"...but data{} is returned here\", span_label_var1),\n             ),\n             (_, Some(ret_span)) => (\n                 ty_sup.span,\n                 ret_span,\n-                \"this parameter and the return type are declared \\\n-                 with different lifetimes...\"\n+                \"this parameter and the return type are declared with different lifetimes...\"\n                     .to_owned(),\n                 format!(\"...but data{} is returned here\", span_label_var1),\n             ),"}, {"sha": "cc8f1816bc3f4a10ac6fccef165ce0fc55937a70", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -8,7 +8,6 @@ use rustc_span::source_map::Span;\n mod different_lifetimes;\n mod find_anon_type;\n mod named_anon_conflict;\n-mod outlives_closure;\n mod placeholder_error;\n mod static_impl_trait;\n mod trait_impl_difference;\n@@ -56,10 +55,9 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n                 diag.emit();\n                 ErrorReported\n             })\n+            .or_else(|| self.try_report_impl_not_conforming_to_trait())\n             .or_else(|| self.try_report_anon_anon_conflict())\n-            .or_else(|| self.try_report_outlives_closure())\n             .or_else(|| self.try_report_static_impl_trait())\n-            .or_else(|| self.try_report_impl_not_conforming_to_trait())\n     }\n \n     pub fn regions(&self) -> Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)> {"}, {"sha": "acaf47469927625fb8da0cb7bb7346c4487d5022", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -21,8 +21,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         // where the anonymous region appears (there must always be one; we\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n-        // with the named one.//scope_def_id\n-        let (named, anon, anon_param_info, region_info) = if self.is_named_region(sub)\n+        // with the named one.\n+        let (named, anon, anon_param_info, region_info) = if sub.has_name()\n             && self.tcx().is_suitable_region(sup).is_some()\n             && self.find_param_with_region(sup, sub).is_some()\n         {\n@@ -32,7 +32,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 self.find_param_with_region(sup, sub).unwrap(),\n                 self.tcx().is_suitable_region(sup).unwrap(),\n             )\n-        } else if self.is_named_region(sup)\n+        } else if sup.has_name()\n             && self.tcx().is_suitable_region(sub).is_some()\n             && self.find_param_with_region(sub, sup).is_some()\n         {\n@@ -74,15 +74,21 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n \n         if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n-            if self.is_return_type_anon(scope_def_id, br, fndecl).is_some()\n-                || self.is_self_anon(is_first, scope_def_id)\n-            {\n+            let is_self_anon = self.is_self_anon(is_first, scope_def_id);\n+            if is_self_anon {\n                 return None;\n             }\n+\n             if let FnRetTy::Return(ty) = &fndecl.output {\n-                if let (TyKind::Def(_, _), ty::ReStatic) = (&ty.kind, sub) {\n-                    // This is an impl Trait return that evaluates de need of 'static.\n-                    // We handle this case better in `static_impl_trait`.\n+                let mut v = ty::TraitObjectVisitor(vec![]);\n+                rustc_hir::intravisit::walk_ty(&mut v, ty);\n+\n+                debug!(\"try_report_named_anon_conflict: ret ty {:?}\", ty);\n+                if sub == &ty::ReStatic && (matches!(ty.kind, TyKind::Def(_, _)) || v.0.len() == 1)\n+                {\n+                    debug!(\"try_report_named_anon_conflict: impl Trait + 'static\");\n+                    // This is an `impl Trait` or `dyn Trait` return that evaluates de need of\n+                    // `'static`. We handle this case better in `static_impl_trait`.\n                     return None;\n                 }\n             }\n@@ -114,17 +120,4 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         Some(diag)\n     }\n-\n-    // This method returns whether the given Region is Named\n-    pub(super) fn is_named_region(&self, region: ty::Region<'tcx>) -> bool {\n-        match *region {\n-            ty::ReStatic => true,\n-            ty::ReFree(ref free_region) => match free_region.bound_region {\n-                ty::BrNamed(..) => true,\n-                _ => false,\n-            },\n-            ty::ReEarlyBound(ebr) => ebr.has_name(),\n-            _ => false,\n-        }\n-    }\n }"}, {"sha": "fc858a497597e5bad0f2e02bd935c33089a201d5", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,117 +0,0 @@\n-//! Error Reporting for Anonymous Region Lifetime Errors\n-//! where both the regions are anonymous.\n-\n-use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n-use crate::infer::SubregionOrigin;\n-use rustc_errors::ErrorReported;\n-use rustc_hir::{Expr, ExprKind::Closure, Node};\n-use rustc_middle::ty::RegionKind;\n-\n-impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    /// Print the error message for lifetime errors when binding escapes a closure.\n-    ///\n-    /// Consider a case where we have\n-    ///\n-    /// ```no_run\n-    /// fn with_int<F>(f: F) where F: FnOnce(&isize) {\n-    ///     let x = 3;\n-    ///     f(&x);\n-    /// }\n-    /// fn main() {\n-    ///     let mut x = None;\n-    ///     with_int(|y| x = Some(y));\n-    /// }\n-    /// ```\n-    ///\n-    /// the output will be\n-    ///\n-    /// ```text\n-    ///     let mut x = None;\n-    ///         ----- borrowed data cannot be stored into here...\n-    ///     with_int(|y| x = Some(y));\n-    ///              ---          ^ cannot be stored outside of its closure\n-    ///              |\n-    ///              ...because it cannot outlive this closure\n-    /// ```\n-    pub(super) fn try_report_outlives_closure(&self) -> Option<ErrorReported> {\n-        if let Some(SubSupConflict(_, origin, ref sub_origin, _, ref sup_origin, sup_region)) =\n-            self.error\n-        {\n-            // #45983: when trying to assign the contents of an argument to a binding outside of a\n-            // closure, provide a specific message pointing this out.\n-            if let (\n-                &SubregionOrigin::BindingTypeIsNotValidAtDecl(ref external_span),\n-                &RegionKind::ReFree(ref free_region),\n-            ) = (&sub_origin, sup_region)\n-            {\n-                let hir = &self.tcx().hir();\n-                if let Some(def_id) = free_region.scope.as_local() {\n-                    let hir_id = hir.as_local_hir_id(def_id);\n-                    if let Node::Expr(Expr { kind: Closure(_, _, _, closure_span, None), .. }) =\n-                        hir.get(hir_id)\n-                    {\n-                        let sup_sp = sup_origin.span();\n-                        let origin_sp = origin.span();\n-                        let mut err = self.tcx().sess.struct_span_err(\n-                            sup_sp,\n-                            \"borrowed data cannot be stored outside of its closure\",\n-                        );\n-                        err.span_label(sup_sp, \"cannot be stored outside of its closure\");\n-                        if origin_sp == sup_sp || origin_sp.contains(sup_sp) {\n-                            // // sup_sp == origin.span():\n-                            //\n-                            // let mut x = None;\n-                            //     ----- borrowed data cannot be stored into here...\n-                            // with_int(|y| x = Some(y));\n-                            //          ---          ^ cannot be stored outside of its closure\n-                            //          |\n-                            //          ...because it cannot outlive this closure\n-                            //\n-                            // // origin.contains(&sup_sp):\n-                            //\n-                            // let mut f: Option<&u32> = None;\n-                            //     ----- borrowed data cannot be stored into here...\n-                            // closure_expecting_bound(|x: &'x u32| {\n-                            //                         ------------ ... because it cannot outlive this closure\n-                            //     f = Some(x);\n-                            //              ^ cannot be stored outside of its closure\n-                            err.span_label(\n-                                *external_span,\n-                                \"borrowed data cannot be stored into here...\",\n-                            );\n-                            err.span_label(\n-                                *closure_span,\n-                                \"...because it cannot outlive this closure\",\n-                            );\n-                        } else {\n-                            // FIXME: the wording for this case could be much improved\n-                            //\n-                            // let mut lines_to_use: Vec<&CrateId> = Vec::new();\n-                            //                           - cannot infer an appropriate lifetime...\n-                            // let push_id = |installed_id: &CrateId| {\n-                            //     -------   ------------------------ borrowed data cannot outlive this closure\n-                            //     |\n-                            //     ...so that variable is valid at time of its declaration\n-                            //     lines_to_use.push(installed_id);\n-                            //                       ^^^^^^^^^^^^ cannot be stored outside of its closure\n-                            err.span_label(origin_sp, \"cannot infer an appropriate lifetime...\");\n-                            err.span_label(\n-                                *external_span,\n-                                \"...so that variable is valid at time of its \\\n-                                            declaration\",\n-                            );\n-                            err.span_label(\n-                                *closure_span,\n-                                \"borrowed data cannot outlive this closure\",\n-                            );\n-                        }\n-                        err.emit();\n-                        return Some(ErrorReported);\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-}"}, {"sha": "f4c86ddae604e2b0297484bb6ee3b53a4505ddea", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -4,7 +4,7 @@ use crate::infer::error_reporting::msg_span_from_free_region;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use rustc_errors::{Applicability, ErrorReported};\n-use rustc_middle::ty::{BoundRegion, FreeRegion, RegionKind};\n+use rustc_middle::ty::RegionKind;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n@@ -20,48 +20,59 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             ) = error.clone()\n             {\n                 let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n-                let return_ty = self.tcx().return_type_impl_trait(anon_reg_sup.def_id);\n-                if sub_r == &RegionKind::ReStatic && return_ty.is_some() {\n+                let (fn_return_span, is_dyn) =\n+                    self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id)?;\n+                if sub_r == &RegionKind::ReStatic {\n                     let sp = var_origin.span();\n                     let return_sp = sub_origin.span();\n                     let mut err =\n                         self.tcx().sess.struct_span_err(sp, \"cannot infer an appropriate lifetime\");\n-                    err.span_label(\n-                        return_sp,\n-                        \"this return type evaluates to the `'static` lifetime...\",\n-                    );\n-                    err.span_label(sup_origin.span(), \"...but this borrow...\");\n+                    let param_info = self.find_param_with_region(sup_r, sub_r)?;\n+                    err.span_label(param_info.param_ty_span, \"data with this lifetime...\");\n \n-                    let (lifetime, lt_sp_opt) = msg_span_from_free_region(self.tcx(), sup_r);\n-                    if let Some(lifetime_sp) = lt_sp_opt {\n-                        err.span_note(lifetime_sp, &format!(\"...can't outlive {}\", lifetime));\n-                    }\n-\n-                    let lifetime_name = match sup_r {\n-                        RegionKind::ReFree(FreeRegion {\n-                            bound_region: BoundRegion::BrNamed(_, ref name),\n-                            ..\n-                        }) => name.to_string(),\n-                        _ => \"'_\".to_owned(),\n-                    };\n-                    let fn_return_span = return_ty.unwrap().1;\n-                    if let Ok(snippet) =\n-                        self.tcx().sess.source_map().span_to_snippet(fn_return_span)\n+                    // We try to make the output have fewer overlapping spans if possible.\n+                    if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n+                        && sup_origin.span() != return_sp\n                     {\n-                        // only apply this suggestion onto functions with\n-                        // explicit non-desugar'able return.\n-                        if fn_return_span.desugaring_kind().is_none() {\n-                            err.span_suggestion(\n-                                fn_return_span,\n-                                &format!(\n-                                    \"you can add a bound to the return type to make it last \\\n-                                 less than `'static` and match {}\",\n-                                    lifetime,\n-                                ),\n-                                format!(\"{} + {}\", snippet, lifetime_name),\n-                                Applicability::Unspecified,\n-                            );\n+                        // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n+\n+                        // Customize the spans and labels depending on their relative order so\n+                        // that split sentences flow correctly.\n+                        if sup_origin.span().shrink_to_hi() <= return_sp.shrink_to_lo() {\n+                            err.span_label(sup_origin.span(), \"...is captured here...\");\n+                            err.span_label(return_sp, \"...and required to be `'static` by this\");\n+                        } else {\n+                            err.span_label(return_sp, \"...is required to be `'static` by this...\");\n+                            err.span_label(sup_origin.span(), \"...and is captured here\");\n                         }\n+                    } else {\n+                        err.span_label(\n+                            return_sp,\n+                            \"...is captured and required to be `'static` here\",\n+                        );\n+                    }\n+\n+                    let (lifetime, _) = msg_span_from_free_region(self.tcx(), sup_r);\n+\n+                    let lifetime_name =\n+                        if sup_r.has_name() { sup_r.to_string() } else { \"'_\".to_owned() };\n+                    // only apply this suggestion onto functions with\n+                    // explicit non-desugar'able return.\n+                    if fn_return_span.desugaring_kind().is_none() {\n+                        let msg = format!(\n+                            \"to permit non-static references in {} `{} Trait` value, you can add \\\n+                             an explicit bound for {}\",\n+                            if is_dyn { \"a\" } else { \"an\" },\n+                            if is_dyn { \"dyn\" } else { \"impl\" },\n+                            lifetime,\n+                        );\n+                        // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n+                        err.span_suggestion_verbose(\n+                            fn_return_span.shrink_to_hi(),\n+                            &msg,\n+                            format!(\" + {}\", lifetime_name),\n+                            Applicability::MaybeIncorrect,\n+                        );\n                     }\n                     err.emit();\n                     return Some(ErrorReported);"}, {"sha": "5f14f799fc7aa89868ae29a70191967ce33803ed", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 99, "deletions": 8, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -2,11 +2,16 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use crate::infer::{Subtype, ValuePairs};\n+use crate::infer::{Subtype, TyCtxtInferExt, ValuePairs};\n use crate::traits::ObligationCauseCode::CompareImplMethodObligation;\n use rustc_errors::ErrorReported;\n-use rustc_middle::ty::Ty;\n-use rustc_span::Span;\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::{MultiSpan, Span};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the `impl` doesn't conform to the `trait`.\n@@ -36,7 +41,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                 var_origin.span(),\n                                 sub_expected_found.expected,\n                                 sub_expected_found.found,\n-                                self.tcx().def_span(*trait_item_def_id),\n+                                *trait_item_def_id,\n                             );\n                             return Some(ErrorReported);\n                         }\n@@ -47,14 +52,100 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         None\n     }\n \n-    fn emit_err(&self, sp: Span, expected: Ty<'tcx>, found: Ty<'tcx>, impl_sp: Span) {\n+    fn emit_err(&self, sp: Span, expected: Ty<'tcx>, found: Ty<'tcx>, trait_def_id: DefId) {\n+        let tcx = self.tcx();\n+        let trait_sp = self.tcx().def_span(trait_def_id);\n         let mut err = self\n             .tcx()\n             .sess\n             .struct_span_err(sp, \"`impl` item signature doesn't match `trait` item signature\");\n-        err.note(&format!(\"expected `{:?}`\\n   found `{:?}`\", expected, found));\n-        err.span_label(sp, &format!(\"found {:?}\", found));\n-        err.span_label(impl_sp, &format!(\"expected {:?}\", expected));\n+        err.span_label(sp, &format!(\"found `{:?}`\", found));\n+        err.span_label(trait_sp, &format!(\"expected `{:?}`\", expected));\n+\n+        // Get the span of all the used type parameters in the method.\n+        let assoc_item = self.tcx().associated_item(trait_def_id);\n+        let mut visitor = TypeParamSpanVisitor { tcx: self.tcx(), types: vec![] };\n+        match assoc_item.kind {\n+            ty::AssocKind::Fn => {\n+                let hir = self.tcx().hir();\n+                if let Some(hir_id) = assoc_item.def_id.as_local().map(|id| hir.as_local_hir_id(id))\n+                {\n+                    if let Some(decl) = hir.fn_decl_by_hir_id(hir_id) {\n+                        visitor.visit_fn_decl(decl);\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        let mut type_param_span: MultiSpan =\n+            visitor.types.iter().cloned().collect::<Vec<_>>().into();\n+        for &span in &visitor.types {\n+            type_param_span.push_span_label(\n+                span,\n+                \"consider borrowing this type parameter in the trait\".to_string(),\n+            );\n+        }\n+\n+        if let Some((expected, found)) = tcx\n+            .infer_ctxt()\n+            .enter(|infcx| infcx.expected_found_str_ty(&ExpectedFound { expected, found }))\n+        {\n+            // Highlighted the differences when showing the \"expected/found\" note.\n+            err.note_expected_found(&\"\", expected, &\"\", found);\n+        } else {\n+            // This fallback shouldn't be necessary, but let's keep it in just in case.\n+            err.note(&format!(\"expected `{:?}`\\n   found `{:?}`\", expected, found));\n+        }\n+        err.span_help(\n+            type_param_span,\n+            \"the lifetime requirements from the `impl` do not correspond to the requirements in \\\n+             the `trait`\",\n+        );\n+        if visitor.types.is_empty() {\n+            err.help(\n+                \"verify the lifetime relationships in the `trait` and `impl` between the `self` \\\n+                 argument, the other inputs and its output\",\n+            );\n+        }\n         err.emit();\n     }\n }\n+\n+struct TypeParamSpanVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    types: Vec<Span>,\n+}\n+\n+impl Visitor<'tcx> for TypeParamSpanVisitor<'tcx> {\n+    type Map = rustc_middle::hir::map::Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+        hir::intravisit::NestedVisitorMap::OnlyBodies(self.tcx.hir())\n+    }\n+\n+    fn visit_ty(&mut self, arg: &'tcx hir::Ty<'tcx>) {\n+        match arg.kind {\n+            hir::TyKind::Rptr(_, ref mut_ty) => {\n+                // We don't want to suggest looking into borrowing `&T` or `&Self`.\n+                hir::intravisit::walk_ty(self, mut_ty.ty);\n+                return;\n+            }\n+            hir::TyKind::Path(hir::QPath::Resolved(None, path)) => match &path.segments {\n+                [segment]\n+                    if segment\n+                        .res\n+                        .map(|res| match res {\n+                            Res::SelfTy(_, _) | Res::Def(hir::def::DefKind::TyParam, _) => true,\n+                            _ => false,\n+                        })\n+                        .unwrap_or(false) =>\n+                {\n+                    self.types.push(path.span);\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+        hir::intravisit::walk_ty(self, arg);\n+    }\n+}"}, {"sha": "9ac27030adeeac0a1e1f11ea6ff5c53e612095c7", "filename": "src/librustc_infer/infer/error_reporting/note.rs", "status": "modified", "additions": 42, "deletions": 445, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,7 +1,6 @@\n use crate::infer::error_reporting::{note_and_explain_region, ObligationCauseExt};\n use crate::infer::{self, InferCtxt, SubregionOrigin};\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n-use rustc_middle::middle::region;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{self, Region};\n \n@@ -11,10 +10,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         origin: &SubregionOrigin<'tcx>,\n     ) {\n+        let mut label_or_note = |span, msg| {\n+            let sub_count = err.children.iter().filter(|d| d.span.is_dummy()).count();\n+            let expanded_sub_count = err.children.iter().filter(|d| !d.span.is_dummy()).count();\n+            let span_is_primary = err.span.primary_spans().iter().all(|&sp| sp == span);\n+            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n+                err.span_label(span, msg);\n+            } else if span_is_primary && expanded_sub_count == 0 {\n+                err.note(msg);\n+            } else {\n+                err.span_note(span, msg);\n+            }\n+        };\n         match *origin {\n             infer::Subtype(ref trace) => {\n                 if let Some((expected, found)) = self.values_str(&trace.values) {\n-                    err.span_note(\n+                    label_or_note(\n                         trace.cause.span,\n                         &format!(\"...so that the {}\", trace.cause.as_requirement_str()),\n                     );\n@@ -25,80 +36,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // handling of region checking when type errors are present is\n                     // *terrible*.\n \n-                    err.span_note(\n+                    label_or_note(\n                         trace.cause.span,\n                         &format!(\"...so that {}\", trace.cause.as_requirement_str()),\n                     );\n                 }\n             }\n             infer::Reborrow(span) => {\n-                err.span_note(span, \"...so that reference does not outlive borrowed content\");\n+                label_or_note(span, \"...so that reference does not outlive borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                err.span_note(span, &format!(\"...so that closure can access `{}`\", var_name));\n-            }\n-            infer::InfStackClosure(span) => {\n-                err.span_note(span, \"...so that closure does not outlive its stack frame\");\n-            }\n-            infer::InvokeClosure(span) => {\n-                err.span_note(span, \"...so that closure is not invoked outside its lifetime\");\n-            }\n-            infer::DerefPointer(span) => {\n-                err.span_note(span, \"...so that pointer is not dereferenced outside its lifetime\");\n-            }\n-            infer::ClosureCapture(span, id) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so that captured variable `{}` does not outlive the \\\n-                                        enclosing closure\",\n-                        self.tcx.hir().name(id)\n-                    ),\n-                );\n-            }\n-            infer::IndexSlice(span) => {\n-                err.span_note(span, \"...so that slice is not indexed outside the lifetime\");\n+                label_or_note(span, &format!(\"...so that closure can access `{}`\", var_name));\n             }\n             infer::RelateObjectBound(span) => {\n-                err.span_note(span, \"...so that it can be closed over into an object\");\n-            }\n-            infer::CallRcvr(span) => {\n-                err.span_note(span, \"...so that method receiver is valid for the method call\");\n-            }\n-            infer::CallArg(span) => {\n-                err.span_note(span, \"...so that argument is valid for the call\");\n+                label_or_note(span, \"...so that it can be closed over into an object\");\n             }\n             infer::CallReturn(span) => {\n-                err.span_note(span, \"...so that return value is valid for the call\");\n-            }\n-            infer::Operand(span) => {\n-                err.span_note(span, \"...so that operand is valid for operation\");\n-            }\n-            infer::AddrOf(span) => {\n-                err.span_note(span, \"...so that reference is valid at the time of borrow\");\n-            }\n-            infer::AutoBorrow(span) => {\n-                err.span_note(span, \"...so that auto-reference is valid at the time of borrow\");\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so type `{}` of expression is valid during the \\\n-                                        expression\",\n-                        self.ty_to_string(t)\n-                    ),\n-                );\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                err.span_note(span, \"...so that variable is valid at time of its declaration\");\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                err.span_note(span, \"...so that a type/lifetime parameter is in scope here\");\n+                label_or_note(span, \"...so that return value is valid for the call\");\n             }\n             infer::DataBorrowed(ty, span) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     &format!(\n                         \"...so that the type `{}` is not borrowed for too long\",\n@@ -107,57 +65,40 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     &format!(\n-                        \"...so that the reference type `{}` does not outlive the \\\n-                                        data it points at\",\n+                        \"...so that the reference type `{}` does not outlive the data it points at\",\n                         self.ty_to_string(ty)\n                     ),\n                 );\n             }\n             infer::RelateParamBound(span, t) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so that the type `{}` will meet its required \\\n-                                        lifetime bounds\",\n-                        self.ty_to_string(t)\n-                    ),\n-                );\n-            }\n-            infer::RelateDefaultParamBound(span, t) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     &format!(\n-                        \"...so that type parameter instantiated with `{}`, will \\\n-                                        meet its declared lifetime bounds\",\n+                        \"...so that the type `{}` will meet its required lifetime bounds\",\n                         self.ty_to_string(t)\n                     ),\n                 );\n             }\n             infer::RelateRegionParamBound(span) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     \"...so that the declared lifetime parameter bounds are satisfied\",\n                 );\n             }\n-            infer::SafeDestructor(span) => {\n-                err.span_note(span, \"...so that references are valid when the destructor runs\");\n-            }\n             infer::CompareImplMethodObligation { span, .. } => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n-                    \"...so that the definition in impl matches the definition from the \\\n-                               trait\",\n+                    \"...so that the definition in impl matches the definition from the trait\",\n                 );\n             }\n         }\n     }\n \n     pub(super) fn report_concrete_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n         sup: Region<'tcx>,\n@@ -166,10 +107,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 let mut err = self.report_and_explain_type_error(trace, &terr);\n-                note_and_explain_region(self.tcx, region_scope_tree, &mut err, \"\", sup, \"...\");\n+                note_and_explain_region(self.tcx, &mut err, \"\", sup, \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...does not necessarily outlive \",\n                     sub,\n@@ -182,20 +122,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0312,\n-                    \"lifetime of reference outlives lifetime of \\\n-                                                borrowed content...\"\n+                    \"lifetime of reference outlives lifetime of borrowed content...\"\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...the reference is valid for \",\n                     sub,\n                     \"...\",\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...but the borrowed content is only valid for \",\n                     sup,\n@@ -209,147 +146,36 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0313,\n-                    \"lifetime of borrowed pointer outlives lifetime \\\n-                                                of captured variable `{}`...\",\n+                    \"lifetime of borrowed pointer outlives lifetime of captured variable `{}`...\",\n                     var_name\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...the borrowed pointer is valid for \",\n                     sub,\n                     \"...\",\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     &format!(\"...but `{}` is only valid for \", var_name),\n                     sup,\n                     \"\",\n                 );\n                 err\n             }\n-            infer::InfStackClosure(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"...the closure must be valid for \",\n-                    sub,\n-                    \"...\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"...but the closure's stack frame is only valid \\\n-                                                  for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::InvokeClosure(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0315,\n-                    \"cannot invoke closure outside of its lifetime\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the closure is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::DerefPointer(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0473,\n-                    \"dereference of reference outside its lifetime\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the reference is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::ClosureCapture(span, id) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0474,\n-                    \"captured variable `{}` does not outlive the \\\n-                                                enclosing closure\",\n-                    self.tcx.hir().name(id)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"captured variable is valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"closure is valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::IndexSlice(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0475,\n-                    \"index of slice outside its lifetime\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the slice is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n             infer::RelateObjectBound(span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     span,\n                     E0476,\n-                    \"lifetime of the source pointer does not outlive \\\n-                                                lifetime bound of the object type\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"object type is valid for \",\n-                    sub,\n-                    \"\",\n+                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n+                     object type\"\n                 );\n+                note_and_explain_region(self.tcx, &mut err, \"object type is valid for \", sub, \"\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"source pointer is only valid for \",\n                     sup,\n@@ -362,27 +188,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0477,\n-                    \"the type `{}` does not fulfill the required \\\n-                                                lifetime\",\n+                    \"the type `{}` does not fulfill the required lifetime\",\n                     self.ty_to_string(ty)\n                 );\n                 match *sub {\n-                    ty::ReStatic => note_and_explain_region(\n-                        self.tcx,\n-                        region_scope_tree,\n-                        &mut err,\n-                        \"type must satisfy \",\n-                        sub,\n-                        \"\",\n-                    ),\n-                    _ => note_and_explain_region(\n-                        self.tcx,\n-                        region_scope_tree,\n-                        &mut err,\n-                        \"type must outlive \",\n-                        sub,\n-                        \"\",\n-                    ),\n+                    ty::ReStatic => {\n+                        note_and_explain_region(self.tcx, &mut err, \"type must satisfy \", sub, \"\")\n+                    }\n+                    _ => note_and_explain_region(self.tcx, &mut err, \"type must outlive \", sub, \"\"),\n                 }\n                 err\n             }\n@@ -391,229 +204,36 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"lifetime parameter instantiated with \",\n                     sup,\n                     \"\",\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"but lifetime parameter must outlive \",\n                     sub,\n                     \"\",\n                 );\n                 err\n             }\n-            infer::RelateDefaultParamBound(span, ty) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0479,\n-                    \"the type `{}` (provided as the value of a type \\\n-                                                parameter) is not valid at this point\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"type must outlive \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::CallRcvr(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0480,\n-                    \"lifetime of method receiver does not outlive the \\\n-                                                method call\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the receiver is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::CallArg(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0481,\n-                    \"lifetime of function argument does not outlive \\\n-                                                the function call\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the function argument is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n             infer::CallReturn(span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     span,\n                     E0482,\n-                    \"lifetime of return value does not outlive the \\\n-                                                function call\"\n+                    \"lifetime of return value does not outlive the function call\"\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"the return value is only valid for \",\n                     sup,\n                     \"\",\n                 );\n                 err\n             }\n-            infer::Operand(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0483,\n-                    \"lifetime of operand does not outlive the \\\n-                                                operation\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the operand is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::AddrOf(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0484,\n-                    \"reference is not valid at the time of borrow\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the borrow is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::AutoBorrow(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0485,\n-                    \"automatically reference is not valid at the time \\\n-                                                of borrow\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the automatic borrow is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0486,\n-                    \"type of expression contains references that are \\\n-                                                not valid during the expression: `{}`\",\n-                    self.ty_to_string(t)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"type is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::SafeDestructor(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0487,\n-                    \"unsafe use of destructor: destructor might be \\\n-                                                called while references are dead\"\n-                );\n-                // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"superregion: \",\n-                    sup,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"subregion: \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0488,\n-                    \"lifetime of variable does not enclose its \\\n-                                                declaration\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the variable is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0489,\n-                    \"type/lifetime parameter not in scope here\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the parameter is only valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n             infer::DataBorrowed(ty, span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n@@ -622,22 +242,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"a value of type `{}` is borrowed for too long\",\n                     self.ty_to_string(ty)\n                 );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the type is valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"but the borrow lasts for \",\n-                    sup,\n-                    \"\",\n-                );\n+                note_and_explain_region(self.tcx, &mut err, \"the type is valid for \", sub, \"\");\n+                note_and_explain_region(self.tcx, &mut err, \"but the borrow lasts for \", sup, \"\");\n                 err\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n@@ -648,17 +254,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"in type `{}`, reference has a longer lifetime than the data it references\",\n                     self.ty_to_string(ty)\n                 );\n+                note_and_explain_region(self.tcx, &mut err, \"the pointer is valid for \", sub, \"\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the pointer is valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"but the referenced data is only valid for \",\n                     sup,\n@@ -683,7 +281,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub(super) fn report_placeholder_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         placeholder_origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n         sup: Region<'tcx>,\n@@ -695,7 +292,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 self.report_and_explain_type_error(trace, &terr)\n             }\n \n-            _ => self.report_concrete_failure(region_scope_tree, placeholder_origin, sub, sup),\n+            _ => self.report_concrete_failure(placeholder_origin, sub, sup),\n         }\n     }\n }"}, {"sha": "d975038b010b9dabdd320349117a621a5fc8ad49", "filename": "src/librustc_infer/infer/free_regions.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -5,7 +5,6 @@\n \n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::middle::region;\n use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n \n /// Combines a `region::ScopeTree` (which governs relationships between\n@@ -21,21 +20,13 @@ pub struct RegionRelations<'a, 'tcx> {\n     /// The context used to fetch the region maps.\n     pub context: DefId,\n \n-    /// The region maps for the given context.\n-    pub region_scope_tree: &'a region::ScopeTree,\n-\n     /// Free-region relationships.\n     pub free_regions: &'a FreeRegionMap<'tcx>,\n }\n \n impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        context: DefId,\n-        region_scope_tree: &'a region::ScopeTree,\n-        free_regions: &'a FreeRegionMap<'tcx>,\n-    ) -> Self {\n-        Self { tcx, context, region_scope_tree, free_regions }\n+    pub fn new(tcx: TyCtxt<'tcx>, context: DefId, free_regions: &'a FreeRegionMap<'tcx>) -> Self {\n+        Self { tcx, context, free_regions }\n     }\n \n     pub fn lub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> Region<'tcx> {"}, {"sha": "b4cfcb3a1c3256c708450472cad47b7cf2c9d33e", "filename": "src/librustc_infer/infer/freshen.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -127,7 +127,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n-            | ty::ReScope(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)"}, {"sha": "5d3e8f440d6fd6fd44785b99c6907f6a20f45fd4", "filename": "src/librustc_infer/infer/lexical_region_resolve/graphviz.rs", "status": "removed", "additions": 0, "deletions": 253, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,253 +0,0 @@\n-//! This module provides linkage between libgraphviz traits and\n-//! `rustc_trait_selection::infer::region_constraints`, generating a\n-//! rendering of the graph represented by the list of `Constraint`\n-//! instances (which make up the edges of the graph), as well as the\n-//! origin for each constraint (which are attached to the labels on\n-//! each edge).\n-\n-/// For clarity, rename the graphviz crate locally to dot.\n-use graphviz as dot;\n-\n-use super::Constraint;\n-use crate::infer::region_constraints::RegionConstraintData;\n-use crate::infer::RegionRelations;\n-use crate::infer::SubregionOrigin;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::DefIndex;\n-use rustc_middle::middle::region;\n-use rustc_middle::ty;\n-\n-use std::borrow::Cow;\n-use std::collections::btree_map::BTreeMap;\n-use std::collections::hash_map::Entry::Vacant;\n-use std::env;\n-use std::fs;\n-use std::io;\n-use std::sync::atomic::{AtomicBool, Ordering};\n-\n-fn print_help_message() {\n-    println!(\n-        \"\\\n--Z print-region-graph by default prints a region constraint graph for every \\n\\\n-function body, to the path `constraints.nodeXXX.dot`, where the XXX is \\n\\\n-replaced with the node id of the function under analysis.                   \\n\\\n-                                                                            \\n\\\n-To select one particular function body, set `RUST_REGION_GRAPH_NODE=XXX`,   \\n\\\n-where XXX is the node id desired.                                           \\n\\\n-                                                                            \\n\\\n-To generate output to some path other than the default                      \\n\\\n-`constraints.nodeXXX.dot`, set `RUST_REGION_GRAPH=/path/desired.dot`;  \\n\\\n-occurrences of the character `%` in the requested path will be replaced with\\n\\\n-the node id of the function under analysis.                                 \\n\\\n-                                                                            \\n\\\n-(Since you requested help via RUST_REGION_GRAPH=help, no region constraint  \\n\\\n-graphs will be printed.                                                     \\n\\\n-\"\n-    );\n-}\n-\n-pub fn maybe_print_constraints_for<'a, 'tcx>(\n-    region_data: &RegionConstraintData<'tcx>,\n-    region_rels: &RegionRelations<'a, 'tcx>,\n-) {\n-    let tcx = region_rels.tcx;\n-    let context = region_rels.context;\n-\n-    if !tcx.sess.opts.debugging_opts.print_region_graph {\n-        return;\n-    }\n-\n-    let requested_node = env::var(\"RUST_REGION_GRAPH_NODE\")\n-        .ok()\n-        .and_then(|s| s.parse().map(DefIndex::from_u32).ok());\n-\n-    if requested_node.is_some() && requested_node != Some(context.index) {\n-        return;\n-    }\n-\n-    let requested_output = env::var(\"RUST_REGION_GRAPH\");\n-    debug!(\"requested_output: {:?} requested_node: {:?}\", requested_output, requested_node);\n-\n-    let output_path = {\n-        let output_template = match requested_output {\n-            Ok(ref s) if s == \"help\" => {\n-                static PRINTED_YET: AtomicBool = AtomicBool::new(false);\n-                if !PRINTED_YET.load(Ordering::SeqCst) {\n-                    print_help_message();\n-                    PRINTED_YET.store(true, Ordering::SeqCst);\n-                }\n-                return;\n-            }\n-\n-            Ok(other_path) => other_path,\n-            Err(_) => \"constraints.node%.dot\".to_string(),\n-        };\n-\n-        if output_template.is_empty() {\n-            panic!(\"empty string provided as RUST_REGION_GRAPH\");\n-        }\n-\n-        if output_template.contains('%') {\n-            let mut new_str = String::new();\n-            for c in output_template.chars() {\n-                if c == '%' {\n-                    new_str.push_str(&context.index.as_u32().to_string());\n-                } else {\n-                    new_str.push(c);\n-                }\n-            }\n-            new_str\n-        } else {\n-            output_template\n-        }\n-    };\n-\n-    if let Err(e) = dump_region_data_to(region_rels, &region_data.constraints, &output_path) {\n-        let msg = format!(\"io error dumping region constraints: {}\", e);\n-        tcx.sess.err(&msg)\n-    }\n-}\n-\n-struct ConstraintGraph<'a, 'tcx> {\n-    graph_name: String,\n-    region_rels: &'a RegionRelations<'a, 'tcx>,\n-    map: &'a BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n-    node_ids: FxHashMap<Node, usize>,\n-}\n-\n-#[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]\n-enum Node {\n-    RegionVid(ty::RegionVid),\n-    Region(ty::RegionKind),\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Copy)]\n-enum Edge<'tcx> {\n-    Constraint(Constraint<'tcx>),\n-    EnclScope(region::Scope, region::Scope),\n-}\n-\n-impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n-    fn new(\n-        name: String,\n-        region_rels: &'a RegionRelations<'a, 'tcx>,\n-        map: &'a ConstraintMap<'tcx>,\n-    ) -> ConstraintGraph<'a, 'tcx> {\n-        let mut i = 0;\n-        let mut node_ids = FxHashMap::default();\n-        {\n-            let mut add_node = |node| {\n-                if let Vacant(e) = node_ids.entry(node) {\n-                    e.insert(i);\n-                    i += 1;\n-                }\n-            };\n-\n-            for (n1, n2) in map.keys().map(|c| constraint_to_nodes(c)) {\n-                add_node(n1);\n-                add_node(n2);\n-            }\n-\n-            region_rels.region_scope_tree.each_encl_scope(|sub, sup| {\n-                add_node(Node::Region(ty::ReScope(sub)));\n-                add_node(Node::Region(ty::ReScope(sup)));\n-            });\n-        }\n-\n-        ConstraintGraph { map, node_ids, region_rels, graph_name: name }\n-    }\n-}\n-\n-impl<'a, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'tcx> {\n-    type Node = Node;\n-    type Edge = Edge<'tcx>;\n-    fn graph_id(&self) -> dot::Id<'_> {\n-        dot::Id::new(&*self.graph_name).unwrap()\n-    }\n-    fn node_id(&self, n: &Node) -> dot::Id<'_> {\n-        let node_id = match self.node_ids.get(n) {\n-            Some(node_id) => node_id,\n-            None => bug!(\"no node_id found for node: {:?}\", n),\n-        };\n-        let name = || format!(\"node_{}\", node_id);\n-\n-        dot::Id::new(name())\n-            .unwrap_or_else(|_| bug!(\"failed to create graphviz node identified by {}\", name()))\n-    }\n-    fn node_label(&self, n: &Node) -> dot::LabelText<'_> {\n-        match *n {\n-            Node::RegionVid(n_vid) => dot::LabelText::label(format!(\"{:?}\", n_vid)),\n-            Node::Region(n_rgn) => dot::LabelText::label(format!(\"{:?}\", n_rgn)),\n-        }\n-    }\n-    fn edge_label(&self, e: &Edge<'_>) -> dot::LabelText<'_> {\n-        match *e {\n-            Edge::Constraint(ref c) => {\n-                dot::LabelText::label(format!(\"{:?}\", self.map.get(c).unwrap()))\n-            }\n-            Edge::EnclScope(..) => dot::LabelText::label(\"(enclosed)\".to_owned()),\n-        }\n-    }\n-}\n-\n-fn constraint_to_nodes(c: &Constraint<'_>) -> (Node, Node) {\n-    match *c {\n-        Constraint::VarSubVar(rv_1, rv_2) => (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n-        Constraint::RegSubVar(r_1, rv_2) => (Node::Region(*r_1), Node::RegionVid(rv_2)),\n-        Constraint::VarSubReg(rv_1, r_2) => (Node::RegionVid(rv_1), Node::Region(*r_2)),\n-        Constraint::RegSubReg(r_1, r_2) => (Node::Region(*r_1), Node::Region(*r_2)),\n-    }\n-}\n-\n-fn edge_to_nodes(e: &Edge<'_>) -> (Node, Node) {\n-    match *e {\n-        Edge::Constraint(ref c) => constraint_to_nodes(c),\n-        Edge::EnclScope(sub, sup) => {\n-            (Node::Region(ty::ReScope(sub)), Node::Region(ty::ReScope(sup)))\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n-    type Node = Node;\n-    type Edge = Edge<'tcx>;\n-    fn nodes(&self) -> dot::Nodes<'_, Node> {\n-        let set = self.node_ids.keys().cloned().collect::<FxHashSet<_>>();\n-        debug!(\"constraint graph has {} nodes\", set.len());\n-        set.into_iter().collect()\n-    }\n-    fn edges(&self) -> dot::Edges<'_, Edge<'tcx>> {\n-        debug!(\"constraint graph has {} edges\", self.map.len());\n-        let mut v: Vec<_> = self.map.keys().map(|e| Edge::Constraint(*e)).collect();\n-        self.region_rels\n-            .region_scope_tree\n-            .each_encl_scope(|sub, sup| v.push(Edge::EnclScope(sub, sup)));\n-        debug!(\"region graph has {} edges\", v.len());\n-        Cow::Owned(v)\n-    }\n-    fn source(&self, edge: &Edge<'tcx>) -> Node {\n-        let (n1, _) = edge_to_nodes(edge);\n-        debug!(\"edge {:?} has source {:?}\", edge, n1);\n-        n1\n-    }\n-    fn target(&self, edge: &Edge<'tcx>) -> Node {\n-        let (_, n2) = edge_to_nodes(edge);\n-        debug!(\"edge {:?} has target {:?}\", edge, n2);\n-        n2\n-    }\n-}\n-\n-pub type ConstraintMap<'tcx> = BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n-\n-fn dump_region_data_to<'a, 'tcx>(\n-    region_rels: &RegionRelations<'a, 'tcx>,\n-    map: &ConstraintMap<'tcx>,\n-    path: &str,\n-) -> io::Result<()> {\n-    debug!(\"dump_region_data map (len: {}) path: {}\", map.len(), path);\n-    let g = ConstraintGraph::new(\"region_data\".to_string(), region_rels, map);\n-    debug!(\"dump_region_data calling render\");\n-    let mut v = Vec::new();\n-    dot::render(&g, &mut v).unwrap();\n-    fs::write(path, &v)\n-}"}, {"sha": "fcf1949933b1137c58437b279143a0a4e43f62ce", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 41, "deletions": 74, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -18,13 +18,11 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use rustc_middle::ty::{ReLateBound, RePlaceholder, ReScope, ReVar};\n+use rustc_middle::ty::{ReLateBound, RePlaceholder, ReVar};\n use rustc_middle::ty::{Region, RegionVid};\n use rustc_span::Span;\n use std::fmt;\n \n-mod graphviz;\n-\n /// This function performs lexical region resolution given a complete\n /// set of constraints and variable origins. It performs a fixed-point\n /// iteration to find region values which satisfy all constraints,\n@@ -49,7 +47,10 @@ pub fn resolve<'tcx>(\n             let mut values = resolver.infer_variable_values(&mut errors);\n             let re_erased = region_rels.tcx.lifetimes.re_erased;\n \n-            values.values.iter_mut().for_each(|v| *v = VarValue::Value(re_erased));\n+            values.values.iter_mut().for_each(|v| match *v {\n+                VarValue::Value(ref mut r) => *r = re_erased,\n+                VarValue::ErrorValue => {}\n+            });\n             (values, errors)\n         }\n         RegionckMode::Erase { suppress_errors: true } => {\n@@ -146,7 +147,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             self.region_rels.context,\n             self.dump_constraints(self.region_rels)\n         );\n-        graphviz::maybe_print_constraints_for(&self.data, self.region_rels);\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n@@ -290,8 +290,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         // Find all the \"upper bounds\" -- that is, each region `b` such that\n         // `r0 <= b` must hold.\n-        let (member_upper_bounds, _) =\n-            self.collect_concrete_regions(graph, member_vid, OUTGOING, None);\n+        let (member_upper_bounds, ..) =\n+            self.collect_bounding_regions(graph, member_vid, OUTGOING, None);\n \n         // Get an iterator over the *available choice* -- that is,\n         // each choice region `c` where `lb <= c` and `c <= ub` for all the\n@@ -423,15 +423,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         match *b_data {\n             VarValue::Value(cur_region) => {\n-                // Identical scopes can show up quite often, if the fixed point\n-                // iteration converges slowly. Skip them. This is purely an\n-                // optimization.\n-                if let (ReScope(a_scope), ReScope(cur_scope)) = (a_region, cur_region) {\n-                    if a_scope == cur_scope {\n-                        return false;\n-                    }\n-                }\n-\n                 // This is a specialized version of the `lub_concrete_regions`\n                 // check below for a common case, here purely as an\n                 // optimization.\n@@ -525,8 +516,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 self.tcx().lifetimes.re_static\n             }\n \n-            (&ReEmpty(_), r @ (ReEarlyBound(_) | ReFree(_) | ReScope(_)))\n-            | (r @ (ReEarlyBound(_) | ReFree(_) | ReScope(_)), &ReEmpty(_)) => {\n+            (&ReEmpty(_), r @ (ReEarlyBound(_) | ReFree(_)))\n+            | (r @ (ReEarlyBound(_) | ReFree(_)), &ReEmpty(_)) => {\n                 // All empty regions are less than early-bound, free,\n                 // and scope regions.\n                 r\n@@ -551,46 +542,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 }\n             }\n \n-            (&ReEarlyBound(_) | &ReFree(_), &ReScope(s_id))\n-            | (&ReScope(s_id), &ReEarlyBound(_) | &ReFree(_)) => {\n-                // A \"free\" region can be interpreted as \"some region\n-                // at least as big as fr.scope\".  So, we can\n-                // reasonably compare free regions and scopes:\n-                let fr_scope = match (a, b) {\n-                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n-                        self.region_rels.region_scope_tree.early_free_scope(self.tcx(), br)\n-                    }\n-                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n-                        self.region_rels.region_scope_tree.free_scope(self.tcx(), fr)\n-                    }\n-                    _ => bug!(),\n-                };\n-                let r_id =\n-                    self.region_rels.region_scope_tree.nearest_common_ancestor(fr_scope, s_id);\n-                if r_id == fr_scope {\n-                    // if the free region's scope `fr.scope` is bigger than\n-                    // the scope region `s_id`, then the LUB is the free\n-                    // region itself:\n-                    match (a, b) {\n-                        (_, &ReScope(_)) => return a,\n-                        (&ReScope(_), _) => return b,\n-                        _ => bug!(),\n-                    }\n-                }\n-\n-                // otherwise, we don't know what the free region is,\n-                // so we must conservatively say the LUB is static:\n-                self.tcx().lifetimes.re_static\n-            }\n-\n-            (&ReScope(a_id), &ReScope(b_id)) => {\n-                // The region corresponding to an outer block is a\n-                // subtype of the region corresponding to an inner\n-                // block.\n-                let lub = self.region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n-                self.tcx().mk_region(ReScope(lub))\n-            }\n-\n             (&ReEarlyBound(_) | &ReFree(_), &ReEarlyBound(_) | &ReFree(_)) => {\n                 self.region_rels.lub_free_regions(a, b)\n             }\n@@ -659,7 +610,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     if !self.sub_concrete_regions(a_region, b_region) {\n                         debug!(\n                             \"collect_errors: region error at {:?}: \\\n-                             cannot verify that {:?}={:?} <= {:?}\",\n+                            cannot verify that {:?}={:?} <= {:?}\",\n                             origin, a_vid, a_region, b_region\n                         );\n                         *a_data = VarValue::ErrorValue;\n@@ -716,7 +667,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         graph: &RegionGraph<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n-        debug!(\"collect_var_errors\");\n+        debug!(\"collect_var_errors, var_data = {:#?}\", var_data.values);\n \n         // This is the best way that I have found to suppress\n         // duplicate and related errors. Basically we keep a set of\n@@ -815,10 +766,10 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n-        let (mut lower_bounds, lower_dup) =\n-            self.collect_concrete_regions(graph, node_idx, INCOMING, Some(dup_vec));\n-        let (mut upper_bounds, upper_dup) =\n-            self.collect_concrete_regions(graph, node_idx, OUTGOING, Some(dup_vec));\n+        let (mut lower_bounds, lower_vid_bounds, lower_dup) =\n+            self.collect_bounding_regions(graph, node_idx, INCOMING, Some(dup_vec));\n+        let (mut upper_bounds, _, upper_dup) =\n+            self.collect_bounding_regions(graph, node_idx, OUTGOING, Some(dup_vec));\n \n         if lower_dup || upper_dup {\n             return;\n@@ -874,15 +825,22 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // If we have a scenario like `exists<'a> { forall<'b> { 'b:\n         // 'a } }`, we wind up without any lower-bound -- all we have\n         // are placeholders as upper bounds, but the universe of the\n-        // variable `'a` doesn't permit those placeholders.\n+        // variable `'a`, or some variable that `'a` has to outlive, doesn't\n+        // permit those placeholders.\n+        let min_universe = lower_vid_bounds\n+            .into_iter()\n+            .map(|vid| self.var_infos[vid].universe)\n+            .min()\n+            .expect(\"lower_vid_bounds should at least include `node_idx`\");\n+\n         for upper_bound in &upper_bounds {\n             if let ty::RePlaceholder(p) = upper_bound.region {\n-                if node_universe.cannot_name(p.universe) {\n+                if min_universe.cannot_name(p.universe) {\n                     let origin = self.var_infos[node_idx].origin;\n                     errors.push(RegionResolutionError::UpperBoundUniverseConflict(\n                         node_idx,\n                         origin,\n-                        node_universe,\n+                        min_universe,\n                         upper_bound.origin.clone(),\n                         upper_bound.region,\n                     ));\n@@ -904,13 +862,24 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         );\n     }\n \n-    fn collect_concrete_regions(\n+    /// Collects all regions that \"bound\" the variable `orig_node_idx` in the\n+    /// given direction.\n+    ///\n+    /// If `dup_vec` is `Some` it's used to track duplicates between successive\n+    /// calls of this function.\n+    ///\n+    /// The return tuple fields are:\n+    /// - a list of all concrete regions bounding the given region.\n+    /// - the set of all region variables bounding the given region.\n+    /// - a `bool` that's true if the returned region variables overlap with\n+    ///   those returned by a previous call for another region.\n+    fn collect_bounding_regions(\n         &self,\n         graph: &RegionGraph<'tcx>,\n         orig_node_idx: RegionVid,\n         dir: Direction,\n         mut dup_vec: Option<&mut IndexVec<RegionVid, Option<RegionVid>>>,\n-    ) -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n+    ) -> (Vec<RegionAndOrigin<'tcx>>, FxHashSet<RegionVid>, bool) {\n         struct WalkState<'tcx> {\n             set: FxHashSet<RegionVid>,\n             stack: Vec<RegionVid>,\n@@ -929,9 +898,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // direction specified\n         process_edges(&self.data, &mut state, graph, orig_node_idx, dir);\n \n-        while !state.stack.is_empty() {\n-            let node_idx = state.stack.pop().unwrap();\n-\n+        while let Some(node_idx) = state.stack.pop() {\n             // check whether we've visited this node on some previous walk\n             if let Some(dup_vec) = &mut dup_vec {\n                 if dup_vec[node_idx].is_none() {\n@@ -949,8 +916,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             process_edges(&self.data, &mut state, graph, node_idx, dir);\n         }\n \n-        let WalkState { result, dup_found, .. } = state;\n-        return (result, dup_found);\n+        let WalkState { result, dup_found, set, .. } = state;\n+        return (result, set, dup_found);\n \n         fn process_edges<'tcx>(\n             this: &RegionConstraintData<'tcx>,"}, {"sha": "92387f753f55ecdea5ad7f3e59bcec5e72685409", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 80, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -20,7 +20,6 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-use rustc_middle::middle::region;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::ConstEvalResult;\n use rustc_middle::traits::select;\n@@ -218,18 +217,22 @@ impl<'tcx> InferCtxtInner<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn region_obligations(&self) -> &[(hir::HirId, RegionObligation<'tcx>)] {\n         &self.region_obligations\n     }\n \n+    #[inline]\n     pub fn projection_cache(&mut self) -> traits::ProjectionCache<'_, 'tcx> {\n         self.projection_cache.with_log(&mut self.undo_log)\n     }\n \n+    #[inline]\n     fn type_variables(&mut self) -> type_variable::TypeVariableTable<'_, 'tcx> {\n         self.type_variable_storage.with_log(&mut self.undo_log)\n     }\n \n+    #[inline]\n     fn int_unification_table(\n         &mut self,\n     ) -> ut::UnificationTable<\n@@ -242,6 +245,7 @@ impl<'tcx> InferCtxtInner<'tcx> {\n         self.int_unification_storage.with_log(&mut self.undo_log)\n     }\n \n+    #[inline]\n     fn float_unification_table(\n         &mut self,\n     ) -> ut::UnificationTable<\n@@ -254,6 +258,7 @@ impl<'tcx> InferCtxtInner<'tcx> {\n         self.float_unification_storage.with_log(&mut self.undo_log)\n     }\n \n+    #[inline]\n     fn const_unification_table(\n         &mut self,\n     ) -> ut::UnificationTable<\n@@ -266,6 +271,7 @@ impl<'tcx> InferCtxtInner<'tcx> {\n         self.const_unification_storage.with_log(&mut self.undo_log)\n     }\n \n+    #[inline]\n     pub fn unwrap_region_constraints(&mut self) -> RegionConstraintCollector<'_, 'tcx> {\n         self.region_constraint_storage\n             .as_mut()\n@@ -378,22 +384,6 @@ pub enum SubregionOrigin<'tcx> {\n     /// Arose from a subtyping relation\n     Subtype(Box<TypeTrace<'tcx>>),\n \n-    /// Stack-allocated closures cannot outlive innermost loop\n-    /// or function so as to ensure we only require finite stack\n-    InfStackClosure(Span),\n-\n-    /// Invocation of closure must be within its lifetime\n-    InvokeClosure(Span),\n-\n-    /// Dereference of reference must be within its lifetime\n-    DerefPointer(Span),\n-\n-    /// Closure bound must not outlive captured variables\n-    ClosureCapture(Span, hir::HirId),\n-\n-    /// Index into slice must be within its lifetime\n-    IndexSlice(Span),\n-\n     /// When casting `&'a T` to an `&'b Trait` object,\n     /// relating `'a` to `'b`\n     RelateObjectBound(Span),\n@@ -406,10 +396,6 @@ pub enum SubregionOrigin<'tcx> {\n     /// that must outlive some other region.\n     RelateRegionParamBound(Span),\n \n-    /// A bound placed on type parameters that states that must outlive\n-    /// the moment of their instantiation.\n-    RelateDefaultParamBound(Span, Ty<'tcx>),\n-\n     /// Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n \n@@ -422,36 +408,9 @@ pub enum SubregionOrigin<'tcx> {\n     /// (&'a &'b T) where a >= b\n     ReferenceOutlivesReferent(Ty<'tcx>, Span),\n \n-    /// Type or region parameters must be in scope.\n-    ParameterInScope(ParameterOrigin, Span),\n-\n-    /// The type T of an expression E must outlive the lifetime for E.\n-    ExprTypeIsNotInScope(Ty<'tcx>, Span),\n-\n-    /// A `ref b` whose region does not enclose the decl site\n-    BindingTypeIsNotValidAtDecl(Span),\n-\n-    /// Regions appearing in a method receiver must outlive method call\n-    CallRcvr(Span),\n-\n-    /// Regions appearing in a function argument must outlive func call\n-    CallArg(Span),\n-\n     /// Region in return type of invoked fn must enclose call\n     CallReturn(Span),\n \n-    /// Operands must be in scope\n-    Operand(Span),\n-\n-    /// Region resulting from a `&` expr must enclose the `&` expr\n-    AddrOf(Span),\n-\n-    /// An auto-borrow that does not enclose the expr where it occurs\n-    AutoBorrow(Span),\n-\n-    /// Region constraint arriving from destructor safety\n-    SafeDestructor(Span),\n-\n     /// Comparing the signature and requirements of an impl method against\n     /// the containing trait.\n     CompareImplMethodObligation {\n@@ -1011,7 +970,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        predicate: &ty::PolySubtypePredicate<'tcx>,\n+        predicate: ty::PolySubtypePredicate<'tcx>,\n     ) -> Option<InferResult<'tcx, ()>> {\n         // Subtle: it's ok to skip the binder here and resolve because\n         // `shallow_resolve` just ignores anything that is not a type\n@@ -1034,7 +993,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         Some(self.commit_if_ok(|snapshot| {\n             let (ty::SubtypePredicate { a_is_expected, a, b }, placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n+                self.replace_bound_vars_with_placeholders(&predicate);\n \n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n \n@@ -1047,11 +1006,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn region_outlives_predicate(\n         &self,\n         cause: &traits::ObligationCause<'tcx>,\n-        predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n+        predicate: ty::PolyRegionOutlivesPredicate<'tcx>,\n     ) -> UnitResult<'tcx> {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n+                self.replace_bound_vars_with_placeholders(&predicate);\n             let origin = SubregionOrigin::from_obligation_cause(cause, || {\n                 RelateRegionParamBound(cause.span)\n             });\n@@ -1260,7 +1219,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn resolve_regions_and_report_errors(\n         &self,\n         region_context: DefId,\n-        region_map: &region::ScopeTree,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n         mode: RegionckMode,\n     ) {\n@@ -1280,12 +1238,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .into_infos_and_data()\n         };\n \n-        let region_rels = &RegionRelations::new(\n-            self.tcx,\n-            region_context,\n-            region_map,\n-            outlives_env.free_region_map(),\n-        );\n+        let region_rels =\n+            &RegionRelations::new(self.tcx, region_context, outlives_env.free_region_map());\n \n         let (lexical_region_resolutions, errors) =\n             lexical_region_resolve::resolve(region_rels, var_infos, data, mode);\n@@ -1299,7 +1253,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(region_map, &errors);\n+            self.report_region_errors(&errors);\n         }\n     }\n \n@@ -1655,14 +1609,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// having to resort to storing full `GenericArg`s in `stalled_on`.\n     #[inline(always)]\n     pub fn ty_or_const_infer_var_changed(&self, infer_var: TyOrConstInferVar<'tcx>) -> bool {\n-        let mut inner = self.inner.borrow_mut();\n         match infer_var {\n             TyOrConstInferVar::Ty(v) => {\n                 use self::type_variable::TypeVariableValue;\n \n                 // If `inlined_probe` returns a `Known` value, it never equals\n                 // `ty::Infer(ty::TyVar(v))`.\n-                match inner.type_variables().inlined_probe(v) {\n+                match self.inner.borrow_mut().type_variables().inlined_probe(v) {\n                     TypeVariableValue::Unknown { .. } => false,\n                     TypeVariableValue::Known { .. } => true,\n                 }\n@@ -1672,23 +1625,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // If `inlined_probe_value` returns a value it's always a\n                 // `ty::Int(_)` or `ty::UInt(_)`, which never matches a\n                 // `ty::Infer(_)`.\n-                inner.int_unification_table().inlined_probe_value(v).is_some()\n+                self.inner.borrow_mut().int_unification_table().inlined_probe_value(v).is_some()\n             }\n \n             TyOrConstInferVar::TyFloat(v) => {\n                 // If `probe_value` returns a value it's always a\n                 // `ty::Float(_)`, which never matches a `ty::Infer(_)`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                inner.float_unification_table().probe_value(v).is_some()\n+                self.inner.borrow_mut().float_unification_table().probe_value(v).is_some()\n             }\n \n             TyOrConstInferVar::Const(v) => {\n                 // If `probe_value` returns a `Known` value, it never equals\n                 // `ty::ConstKind::Infer(ty::InferConst::Var(v))`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                match inner.const_unification_table().probe_value(v).val {\n+                match self.inner.borrow_mut().const_unification_table().probe_value(v).val {\n                     ConstVariableValue::Unknown { .. } => false,\n                     ConstVariableValue::Known { .. } => true,\n                 }\n@@ -1809,29 +1762,14 @@ impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n             Subtype(ref a) => a.span(),\n-            InfStackClosure(a) => a,\n-            InvokeClosure(a) => a,\n-            DerefPointer(a) => a,\n-            ClosureCapture(a, _) => a,\n-            IndexSlice(a) => a,\n             RelateObjectBound(a) => a,\n             RelateParamBound(a, _) => a,\n             RelateRegionParamBound(a) => a,\n-            RelateDefaultParamBound(a, _) => a,\n             Reborrow(a) => a,\n             ReborrowUpvar(a, _) => a,\n             DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n-            ParameterInScope(_, a) => a,\n-            ExprTypeIsNotInScope(_, a) => a,\n-            BindingTypeIsNotValidAtDecl(a) => a,\n-            CallRcvr(a) => a,\n-            CallArg(a) => a,\n             CallReturn(a) => a,\n-            Operand(a) => a,\n-            AddrOf(a) => a,\n-            AutoBorrow(a) => a,\n-            SafeDestructor(a) => a,\n             CompareImplMethodObligation { span, .. } => span,\n         }\n     }"}, {"sha": "fd3b38e9d67b0e3b670f41c432ed836556d2c87f", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -11,17 +11,17 @@ pub fn explicit_outlives_bounds<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n ) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n     debug!(\"explicit_outlives_bounds()\");\n-    param_env.caller_bounds.into_iter().filter_map(move |predicate| match predicate {\n-        ty::Predicate::Projection(..)\n-        | ty::Predicate::Trait(..)\n-        | ty::Predicate::Subtype(..)\n-        | ty::Predicate::WellFormed(..)\n-        | ty::Predicate::ObjectSafe(..)\n-        | ty::Predicate::ClosureKind(..)\n-        | ty::Predicate::TypeOutlives(..)\n-        | ty::Predicate::ConstEvaluatable(..)\n-        | ty::Predicate::ConstEquate(..) => None,\n-        ty::Predicate::RegionOutlives(ref data) => data\n+    param_env.caller_bounds.into_iter().filter_map(move |predicate| match predicate.kind() {\n+        ty::PredicateKind::Projection(..)\n+        | ty::PredicateKind::Trait(..)\n+        | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::TypeOutlives(..)\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..) => None,\n+        ty::PredicateKind::RegionOutlives(ref data) => data\n             .no_bound_vars()\n             .map(|ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a)),\n     })"}, {"sha": "82d32b008088ddde01bfa257e0d8537aca3b12b8", "filename": "src/librustc_infer/infer/outlives/verify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -50,7 +50,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                 // for further background and discussion.\n                 let mut bounds = substs\n                     .iter()\n-                    .filter_map(|&child| match child.unpack() {\n+                    .filter_map(|child| match child.unpack() {\n                         GenericArgKind::Type(ty) => Some(self.type_bound(ty)),\n                         GenericArgKind::Lifetime(_) => None,\n                         GenericArgKind::Const(_) => Some(self.recursive_bound(child)),\n@@ -334,10 +334,10 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     fn collect_outlives_from_predicate_list(\n         &self,\n         compare_ty: impl Fn(Ty<'tcx>) -> bool,\n-        predicates: impl Iterator<Item = impl AsRef<ty::Predicate<'tcx>>>,\n+        predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         predicates\n-            .filter_map(|p| p.as_ref().to_opt_type_outlives())\n+            .filter_map(|p| p.to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())\n             .filter(move |p| compare_ty(p.0))\n     }"}, {"sha": "626774617a67a24c9dc50c807015db9da18638bb", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -68,12 +68,14 @@ pub struct RegionConstraintCollector<'a, 'tcx> {\n \n impl std::ops::Deref for RegionConstraintCollector<'_, 'tcx> {\n     type Target = RegionConstraintStorage<'tcx>;\n+    #[inline]\n     fn deref(&self) -> &RegionConstraintStorage<'tcx> {\n         self.storage\n     }\n }\n \n impl std::ops::DerefMut for RegionConstraintCollector<'_, 'tcx> {\n+    #[inline]\n     fn deref_mut(&mut self) -> &mut RegionConstraintStorage<'tcx> {\n         self.storage\n     }\n@@ -345,6 +347,7 @@ impl<'tcx> RegionConstraintStorage<'tcx> {\n         Self::default()\n     }\n \n+    #[inline]\n     pub(crate) fn with_log<'a>(\n         &'a mut self,\n         undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n@@ -758,11 +761,9 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n \n     pub fn universe(&self, region: Region<'tcx>) -> ty::UniverseIndex {\n         match *region {\n-            ty::ReScope(..)\n-            | ty::ReStatic\n-            | ty::ReErased\n-            | ty::ReFree(..)\n-            | ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n+            ty::ReStatic | ty::ReErased | ty::ReFree(..) | ty::ReEarlyBound(..) => {\n+                ty::UniverseIndex::ROOT\n+            }\n             ty::ReEmpty(ui) => ui,\n             ty::RePlaceholder(placeholder) => placeholder.universe,\n             ty::ReVar(vid) => self.var_universe(vid),\n@@ -784,7 +785,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         )\n     }\n \n-    /// See [`RegionInference::region_constraints_added_in_snapshot`].\n+    /// See `InferCtxt::region_constraints_added_in_snapshot`.\n     pub fn region_constraints_added_in_snapshot(&self, mark: &Snapshot<'tcx>) -> Option<bool> {\n         self.undo_log\n             .region_constraints_in_snapshot(mark)\n@@ -796,6 +797,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n             .unwrap_or(None)\n     }\n \n+    #[inline]\n     fn unification_table(&mut self) -> super::UnificationTable<'_, 'tcx, ty::RegionVid> {\n         ut::UnificationTable::with_log(&mut self.storage.unification_table, self.undo_log)\n     }"}, {"sha": "b51af19883fdd82e4be7f0347b052d589e6a2e73", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -6,7 +6,7 @@ use crate::traits::Obligation;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::TyVar;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -100,11 +100,12 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,\n-                    ty::Predicate::Subtype(ty::Binder::dummy(ty::SubtypePredicate {\n+                    ty::PredicateKind::Subtype(ty::Binder::dummy(ty::SubtypePredicate {\n                         a_is_expected: self.a_is_expected,\n                         a,\n                         b,\n-                    })),\n+                    }))\n+                    .to_predicate(self.tcx()),\n                 ));\n \n                 Ok(a)"}, {"sha": "53c7dcc6377184c02cae803e1a30b2e14a525d81", "filename": "src/librustc_infer/infer/type_variable.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -87,11 +87,7 @@ pub struct TypeVariableStorage<'tcx> {\n }\n \n pub struct TypeVariableTable<'a, 'tcx> {\n-    values: &'a mut sv::SnapshotVecStorage<Delegate>,\n-\n-    eq_relations: &'a mut ut::UnificationTableStorage<TyVidEqKey<'tcx>>,\n-\n-    sub_relations: &'a mut ut::UnificationTableStorage<ty::TyVid>,\n+    storage: &'a mut TypeVariableStorage<'tcx>,\n \n     undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n }\n@@ -165,12 +161,12 @@ impl<'tcx> TypeVariableStorage<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub(crate) fn with_log<'a>(\n         &'a mut self,\n         undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n     ) -> TypeVariableTable<'a, 'tcx> {\n-        let TypeVariableStorage { values, eq_relations, sub_relations } = self;\n-        TypeVariableTable { values, eq_relations, sub_relations, undo_log }\n+        TypeVariableTable { storage: self, undo_log }\n     }\n }\n \n@@ -180,15 +176,15 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n     /// Note that this function does not return care whether\n     /// `vid` has been unified with something else or not.\n     pub fn var_diverges(&self, vid: ty::TyVid) -> bool {\n-        self.values.get(vid.index as usize).diverging\n+        self.storage.values.get(vid.index as usize).diverging\n     }\n \n     /// Returns the origin that was given when `vid` was created.\n     ///\n     /// Note that this function does not return care whether\n     /// `vid` has been unified with something else or not.\n     pub fn var_origin(&self, vid: ty::TyVid) -> &TypeVariableOrigin {\n-        &self.values.get(vid.index as usize).origin\n+        &self.storage.values.get(vid.index as usize).origin\n     }\n \n     /// Records that `a == b`, depending on `dir`.\n@@ -265,7 +261,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n \n     /// Returns the number of type variables created thus far.\n     pub fn num_vars(&self) -> usize {\n-        self.values.len()\n+        self.storage.values.len()\n     }\n \n     /// Returns the \"root\" variable of `vid` in the `eq_relations`\n@@ -319,18 +315,21 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n         }\n     }\n \n+    #[inline]\n     fn values(\n         &mut self,\n     ) -> sv::SnapshotVec<Delegate, &mut Vec<TypeVariableData>, &mut InferCtxtUndoLogs<'tcx>> {\n-        self.values.with_log(self.undo_log)\n+        self.storage.values.with_log(self.undo_log)\n     }\n \n+    #[inline]\n     fn eq_relations(&mut self) -> super::UnificationTable<'_, 'tcx, TyVidEqKey<'tcx>> {\n-        self.eq_relations.with_log(self.undo_log)\n+        self.storage.eq_relations.with_log(self.undo_log)\n     }\n \n+    #[inline]\n     fn sub_relations(&mut self) -> super::UnificationTable<'_, 'tcx, ty::TyVid> {\n-        self.sub_relations.with_log(self.undo_log)\n+        self.storage.sub_relations.with_log(self.undo_log)\n     }\n \n     /// Returns a range of the type variables created during the snapshot.\n@@ -342,7 +341,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n         (\n             range.start..range.end,\n             (range.start.index..range.end.index)\n-                .map(|index| self.values.get(index as usize).origin)\n+                .map(|index| self.storage.values.get(index as usize).origin)\n                 .collect(),\n         )\n     }\n@@ -378,7 +377,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not.\n                         let mut eq_relations = ut::UnificationTable::with_log(\n-                            &mut *self.eq_relations,\n+                            &mut self.storage.eq_relations,\n                             &mut *self.undo_log,\n                         );\n                         let escaping_type = match eq_relations.probe_value(vid) {\n@@ -400,7 +399,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n     /// Returns indices of all variables that are not yet\n     /// instantiated.\n     pub fn unsolved_variables(&mut self) -> Vec<ty::TyVid> {\n-        (0..self.values.len())\n+        (0..self.storage.values.len())\n             .filter_map(|i| {\n                 let vid = ty::TyVid { index: i as u32 };\n                 match self.probe(vid) {"}, {"sha": "e7f1869955d20cd84944370a6908fc48326f8d64", "filename": "src/librustc_infer/infer/undo_log.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -100,10 +100,12 @@ impl<'tcx, T> UndoLogs<T> for InferCtxtUndoLogs<'tcx>\n where\n     UndoLog<'tcx>: From<T>,\n {\n+    #[inline]\n     fn num_open_snapshots(&self) -> usize {\n         self.num_open_snapshots\n     }\n \n+    #[inline]\n     fn push(&mut self, undo: T) {\n         if self.in_snapshot() {\n             self.logs.push(undo.into())"}, {"sha": "ed04ee02b7203c6028ec3329d4401e4250873867", "filename": "src/librustc_infer/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -16,6 +16,7 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(extend_one)]\n #![feature(never_type)]\n #![feature(or_patterns)]\n #![feature(range_is_empty)]"}, {"sha": "2710debea9478b44e2106bcd26b37726d7768104", "filename": "src/librustc_infer/traits/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fengine.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -33,7 +33,7 @@ pub trait TraitEngine<'tcx>: 'tcx {\n                 cause,\n                 recursion_depth: 0,\n                 param_env,\n-                predicate: trait_ref.without_const().to_predicate(),\n+                predicate: trait_ref.without_const().to_predicate(infcx.tcx),\n             },\n         );\n     }"}, {"sha": "c4f1fa2cb26b359ac27f3d0a1461bd2621c14409", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -14,9 +14,9 @@ use rustc_middle::ty::{self, Const, Ty};\n use rustc_span::Span;\n \n pub use self::FulfillmentErrorCode::*;\n+pub use self::ImplSource::*;\n pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n-pub use self::Vtable::*;\n \n pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::project::MismatchedProjectionTypes;\n@@ -30,10 +30,10 @@ crate use self::util::elaborate_predicates;\n pub use rustc_middle::traits::*;\n \n /// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n-/// which the vtable must be found. The process of finding a vtable is\n+/// which the \"impl_source\" must be found. The process of finding a \"impl_source\" is\n /// called \"resolving\" the `Obligation`. This process consists of\n /// either identifying an `impl` (e.g., `impl Eq for int`) that\n-/// provides the required vtable, or else finding a bound that is in\n+/// satisfies the obligation, or else finding a bound that is in\n /// scope. The eventual result is usually a `Selection` (defined below).\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Obligation<'tcx, T> {\n@@ -59,13 +59,13 @@ pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n // `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PredicateObligation<'_>, 112);\n+static_assert_size!(PredicateObligation<'_>, 88);\n \n pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n-pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n+pub type Selection<'tcx> = ImplSource<'tcx, PredicateObligation<'tcx>>;\n \n pub struct FulfillmentError<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,"}, {"sha": "65284bcee912c446d44df88659d67548098f4286", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -95,6 +95,7 @@ pub enum ProjectionCacheEntry<'tcx> {\n }\n \n impl<'tcx> ProjectionCacheStorage<'tcx> {\n+    #[inline]\n     pub(crate) fn with_log<'a>(\n         &'a mut self,\n         undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n@@ -104,6 +105,7 @@ impl<'tcx> ProjectionCacheStorage<'tcx> {\n }\n \n impl<'tcx> ProjectionCache<'_, 'tcx> {\n+    #[inline]\n     fn map(\n         &mut self,\n     ) -> SnapshotMapRef<"}, {"sha": "8081cac0067f172821c84a07cf6d4a4c22ff8d3d", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 56, "deletions": 44, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -8,43 +8,46 @@ use rustc_span::Span;\n \n pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    pred: &ty::Predicate<'tcx>,\n+    pred: ty::Predicate<'tcx>,\n ) -> ty::Predicate<'tcx> {\n-    match *pred {\n-        ty::Predicate::Trait(ref data, constness) => {\n-            ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data), constness)\n+    let kind = pred.kind();\n+    let new = match kind {\n+        &ty::PredicateKind::Trait(ref data, constness) => {\n+            ty::PredicateKind::Trait(tcx.anonymize_late_bound_regions(data), constness)\n         }\n \n-        ty::Predicate::RegionOutlives(ref data) => {\n-            ty::Predicate::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::RegionOutlives(data) => {\n+            ty::PredicateKind::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n         }\n \n-        ty::Predicate::TypeOutlives(ref data) => {\n-            ty::Predicate::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::TypeOutlives(data) => {\n+            ty::PredicateKind::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n         }\n \n-        ty::Predicate::Projection(ref data) => {\n-            ty::Predicate::Projection(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::Projection(data) => {\n+            ty::PredicateKind::Projection(tcx.anonymize_late_bound_regions(data))\n         }\n \n-        ty::Predicate::WellFormed(data) => ty::Predicate::WellFormed(data),\n+        &ty::PredicateKind::WellFormed(data) => ty::PredicateKind::WellFormed(data),\n \n-        ty::Predicate::ObjectSafe(data) => ty::Predicate::ObjectSafe(data),\n+        &ty::PredicateKind::ObjectSafe(data) => ty::PredicateKind::ObjectSafe(data),\n \n-        ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind)\n+        &ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n         }\n \n-        ty::Predicate::Subtype(ref data) => {\n-            ty::Predicate::Subtype(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::Subtype(data) => {\n+            ty::PredicateKind::Subtype(tcx.anonymize_late_bound_regions(data))\n         }\n \n-        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-            ty::Predicate::ConstEvaluatable(def_id, substs)\n+        &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs)\n         }\n \n-        ty::Predicate::ConstEquate(c1, c2) => ty::Predicate::ConstEquate(c1, c2),\n-    }\n+        ty::PredicateKind::ConstEquate(c1, c2) => ty::PredicateKind::ConstEquate(c1, c2),\n+    };\n+\n+    if new != *kind { new.to_predicate(tcx) } else { pred }\n }\n \n struct PredicateSet<'tcx> {\n@@ -57,7 +60,7 @@ impl PredicateSet<'tcx> {\n         Self { tcx, set: Default::default() }\n     }\n \n-    fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n+    fn insert(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n         // We have to be careful here because we want\n         //\n         //    for<'a> Foo<&'a int>\n@@ -72,12 +75,20 @@ impl PredicateSet<'tcx> {\n     }\n }\n \n-impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'tcx> {\n-    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+impl Extend<ty::Predicate<'tcx>> for PredicateSet<'tcx> {\n+    fn extend<I: IntoIterator<Item = ty::Predicate<'tcx>>>(&mut self, iter: I) {\n         for pred in iter {\n-            self.insert(pred.as_ref());\n+            self.insert(pred);\n         }\n     }\n+\n+    fn extend_one(&mut self, pred: ty::Predicate<'tcx>) {\n+        self.insert(pred);\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        Extend::<ty::Predicate<'tcx>>::extend_reserve(&mut self.set, additional);\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -99,14 +110,14 @@ pub fn elaborate_trait_ref<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> Elaborator<'tcx> {\n-    elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate()))\n+    elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate(tcx)))\n }\n \n pub fn elaborate_trait_refs<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n ) -> Elaborator<'tcx> {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate());\n+    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate(tcx));\n     elaborate_predicates(tcx, predicates)\n }\n \n@@ -123,7 +134,7 @@ pub fn elaborate_obligations<'tcx>(\n     mut obligations: Vec<PredicateObligation<'tcx>>,\n ) -> Elaborator<'tcx> {\n     let mut visited = PredicateSet::new(tcx);\n-    obligations.retain(|obligation| visited.insert(&obligation.predicate));\n+    obligations.retain(|obligation| visited.insert(obligation.predicate));\n     Elaborator { stack: obligations, visited }\n }\n \n@@ -145,8 +156,8 @@ impl Elaborator<'tcx> {\n \n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n-        match obligation.predicate {\n-            ty::Predicate::Trait(ref data, _) => {\n+        match obligation.predicate.kind() {\n+            ty::PredicateKind::Trait(ref data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n@@ -163,40 +174,40 @@ impl Elaborator<'tcx> {\n                 // cases. One common case is when people define\n                 // `trait Sized: Sized { }` rather than `trait Sized { }`.\n                 let visited = &mut self.visited;\n-                let obligations = obligations.filter(|o| visited.insert(&o.predicate));\n+                let obligations = obligations.filter(|o| visited.insert(o.predicate));\n \n                 self.stack.extend(obligations);\n             }\n-            ty::Predicate::WellFormed(..) => {\n+            ty::PredicateKind::WellFormed(..) => {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could.\n             }\n-            ty::Predicate::ObjectSafe(..) => {\n+            ty::PredicateKind::ObjectSafe(..) => {\n                 // Currently, we do not elaborate object-safe\n                 // predicates.\n             }\n-            ty::Predicate::Subtype(..) => {\n+            ty::PredicateKind::Subtype(..) => {\n                 // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n                 // though conceivably we might.\n             }\n-            ty::Predicate::Projection(..) => {\n+            ty::PredicateKind::Projection(..) => {\n                 // Nothing to elaborate in a projection predicate.\n             }\n-            ty::Predicate::ClosureKind(..) => {\n+            ty::PredicateKind::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n-            ty::Predicate::ConstEvaluatable(..) => {\n+            ty::PredicateKind::ConstEvaluatable(..) => {\n                 // Currently, we do not elaborate const-evaluatable\n                 // predicates.\n             }\n-            ty::Predicate::ConstEquate(..) => {\n+            ty::PredicateKind::ConstEquate(..) => {\n                 // Currently, we do not elaborate const-equate\n                 // predicates.\n             }\n-            ty::Predicate::RegionOutlives(..) => {\n+            ty::PredicateKind::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }\n-            ty::Predicate::TypeOutlives(ref data) => {\n+            ty::PredicateKind::TypeOutlives(ref data) => {\n                 // We know that `T: 'a` for some type `T`. We can\n                 // often elaborate this. For example, if we know that\n                 // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n@@ -228,15 +239,15 @@ impl Elaborator<'tcx> {\n                                 if r.is_late_bound() {\n                                     None\n                                 } else {\n-                                    Some(ty::Predicate::RegionOutlives(ty::Binder::dummy(\n+                                    Some(ty::PredicateKind::RegionOutlives(ty::Binder::dummy(\n                                         ty::OutlivesPredicate(r, r_min),\n                                     )))\n                                 }\n                             }\n \n                             Component::Param(p) => {\n                                 let ty = tcx.mk_ty_param(p.index, p.name);\n-                                Some(ty::Predicate::TypeOutlives(ty::Binder::dummy(\n+                                Some(ty::PredicateKind::TypeOutlives(ty::Binder::dummy(\n                                     ty::OutlivesPredicate(ty, r_min),\n                                 )))\n                             }\n@@ -250,8 +261,9 @@ impl Elaborator<'tcx> {\n                                 None\n                             }\n                         })\n-                        .filter(|p| visited.insert(p))\n-                        .map(|p| predicate_obligation(p, None)),\n+                        .map(|predicate_kind| predicate_kind.to_predicate(tcx))\n+                        .filter(|&predicate| visited.insert(predicate))\n+                        .map(|predicate| predicate_obligation(predicate, None)),\n                 );\n             }\n         }\n@@ -317,7 +329,7 @@ impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToT\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         while let Some(obligation) = self.base_iterator.next() {\n-            if let ty::Predicate::Trait(data, _) = obligation.predicate {\n+            if let ty::PredicateKind::Trait(data, _) = obligation.predicate.kind() {\n                 return Some(data.to_poly_trait_ref());\n             }\n         }"}, {"sha": "112dc7037f5880e385972bef84d4bc21d909d185", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -21,7 +21,7 @@ rustc_expand = { path = \"../librustc_expand\" }\n rustc_parse = { path = \"../librustc_parse\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_ast_lowering = { path = \"../librustc_ast_lowering\" }\n rustc_ast_passes = { path = \"../librustc_ast_passes\" }"}, {"sha": "5aad64f84cee3ac9368307f318e52ecedbc7ac5c", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -18,7 +18,7 @@ use rustc_session::lint;\n use rustc_session::parse::{CrateConfig, ParseSess};\n use rustc_session::{DiagnosticOutput, Session};\n use rustc_span::edition;\n-use rustc_span::source_map::{FileLoader, FileName, SourceMap};\n+use rustc_span::source_map::{FileLoader, FileName};\n use std::path::PathBuf;\n use std::result;\n use std::sync::{Arc, Mutex};\n@@ -31,7 +31,6 @@ pub type Result<T> = result::Result<T, ErrorReported>;\n pub struct Compiler {\n     pub(crate) sess: Lrc<Session>,\n     codegen_backend: Lrc<Box<dyn CodegenBackend>>,\n-    source_map: Lrc<SourceMap>,\n     pub(crate) input: Input,\n     pub(crate) input_path: Option<PathBuf>,\n     pub(crate) output_dir: Option<PathBuf>,\n@@ -49,9 +48,6 @@ impl Compiler {\n     pub fn codegen_backend(&self) -> &Lrc<Box<dyn CodegenBackend>> {\n         &self.codegen_backend\n     }\n-    pub fn source_map(&self) -> &Lrc<SourceMap> {\n-        &self.source_map\n-    }\n     pub fn input(&self) -> &Input {\n         &self.input\n     }\n@@ -168,7 +164,7 @@ pub fn run_compiler_in_existing_thread_pool<R>(\n     f: impl FnOnce(&Compiler) -> R,\n ) -> R {\n     let registry = &config.registry;\n-    let (sess, codegen_backend, source_map) = util::create_session(\n+    let (sess, codegen_backend) = util::create_session(\n         config.opts,\n         config.crate_cfg,\n         config.diagnostic_output,\n@@ -181,7 +177,6 @@ pub fn run_compiler_in_existing_thread_pool<R>(\n     let compiler = Compiler {\n         sess,\n         codegen_backend,\n-        source_map,\n         input: config.input,\n         input_path: config.input_path,\n         output_dir: config.output_dir,\n@@ -191,17 +186,19 @@ pub fn run_compiler_in_existing_thread_pool<R>(\n         override_queries: config.override_queries,\n     };\n \n-    let r = {\n-        let _sess_abort_error = OnDrop(|| {\n-            compiler.sess.finish_diagnostics(registry);\n-        });\n+    rustc_span::with_source_map(compiler.sess.parse_sess.clone_source_map(), move || {\n+        let r = {\n+            let _sess_abort_error = OnDrop(|| {\n+                compiler.sess.finish_diagnostics(registry);\n+            });\n \n-        f(&compiler)\n-    };\n+            f(&compiler)\n+        };\n \n-    let prof = compiler.sess.prof.clone();\n-    prof.generic_activity(\"drop_compiler\").run(move || drop(compiler));\n-    r\n+        let prof = compiler.sess.prof.clone();\n+        prof.generic_activity(\"drop_compiler\").run(move || drop(compiler));\n+        r\n+    })\n }\n \n pub fn run_compiler<R: Send>(mut config: Config, f: impl FnOnce(&Compiler) -> R + Send) -> R {"}, {"sha": "9a60e74d94d01fe9055cb12fb34185c5552da9c5", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self, ast, visit};\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n-use rustc_data_structures::sync::{par_iter, Lrc, Once, ParallelIterator, WorkerLocal};\n+use rustc_data_structures::sync::{par_iter, Lrc, OnceCell, ParallelIterator, WorkerLocal};\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_errors::{ErrorReported, PResult};\n use rustc_expand::base::ExtCtxt;\n@@ -33,7 +33,7 @@ use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n-use rustc_span::FileName;\n+use rustc_span::{FileName, RealFileName};\n use rustc_trait_selection::traits;\n use rustc_typeck as typeck;\n \n@@ -169,10 +169,10 @@ pub fn register_plugins<'a>(\n     sess.init_features(features);\n \n     let crate_types = util::collect_crate_types(sess, &krate.attrs);\n-    sess.crate_types.set(crate_types);\n+    sess.init_crate_types(crate_types);\n \n     let disambiguator = util::compute_crate_disambiguator(sess);\n-    sess.crate_disambiguator.set(disambiguator);\n+    sess.crate_disambiguator.set(disambiguator).expect(\"not yet initialized\");\n     rustc_incremental::prepare_session_directory(sess, &crate_name, disambiguator);\n \n     if sess.opts.incremental.is_some() {\n@@ -244,7 +244,7 @@ fn configure_and_expand_inner<'a>(\n             alt_std_name,\n         );\n         if let Some(name) = name {\n-            sess.parse_sess.injected_crate_name.set(name);\n+            sess.parse_sess.injected_crate_name.set(name).expect(\"not yet initialized\");\n         }\n         krate\n     });\n@@ -288,9 +288,10 @@ fn configure_and_expand_inner<'a>(\n         let features = sess.features_untracked();\n         let cfg = rustc_expand::expand::ExpansionConfig {\n             features: Some(&features),\n-            recursion_limit: *sess.recursion_limit.get(),\n+            recursion_limit: sess.recursion_limit(),\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n             should_test: sess.opts.test,\n+            span_debug: sess.opts.debugging_opts.span_debug,\n             ..rustc_expand::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n \n@@ -358,7 +359,7 @@ fn configure_and_expand_inner<'a>(\n         rustc_ast_passes::ast_validation::check_crate(sess, &krate, &mut resolver.lint_buffer())\n     });\n \n-    let crate_types = sess.crate_types.borrow();\n+    let crate_types = sess.crate_types();\n     let is_proc_macro_crate = crate_types.contains(&CrateType::ProcMacro);\n \n     // For backwards compatibility, we don't try to run proc macro injection\n@@ -488,7 +489,7 @@ fn generated_output_paths(\n             // If the filename has been overridden using `-o`, it will not be modified\n             // by appending `.rlib`, `.exe`, etc., so we can skip this transformation.\n             OutputType::Exe if !exact_name => {\n-                for crate_type in sess.crate_types.borrow().iter() {\n+                for crate_type in sess.crate_types().iter() {\n                     let p = filename_for_input(sess, *crate_type, crate_name, outputs);\n                     out_filenames.push(p);\n                 }\n@@ -569,13 +570,16 @@ fn write_out_deps(\n                 for cnum in resolver.cstore().crates_untracked() {\n                     let source = resolver.cstore().crate_source_untracked(cnum);\n                     if let Some((path, _)) = source.dylib {\n-                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                        let file_name = FileName::Real(RealFileName::Named(path));\n+                        files.push(escape_dep_filename(&file_name));\n                     }\n                     if let Some((path, _)) = source.rlib {\n-                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                        let file_name = FileName::Real(RealFileName::Named(path));\n+                        files.push(escape_dep_filename(&file_name));\n                     }\n                     if let Some((path, _)) = source.rmeta {\n-                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                        let file_name = FileName::Real(RealFileName::Named(path));\n+                        files.push(escape_dep_filename(&file_name));\n                     }\n                 }\n             });\n@@ -721,7 +725,7 @@ pub fn create_global_ctxt<'tcx>(\n     mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n-    global_ctxt: &'tcx Once<GlobalCtxt<'tcx>>,\n+    global_ctxt: &'tcx OnceCell<GlobalCtxt<'tcx>>,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n ) -> QueryContext<'tcx> {\n     let sess = &compiler.session();\n@@ -743,7 +747,7 @@ pub fn create_global_ctxt<'tcx>(\n     }\n \n     let gcx = sess.time(\"setup_global_ctxt\", || {\n-        global_ctxt.init_locking(|| {\n+        global_ctxt.get_or_init(|| {\n             TyCtxt::create_global_ctxt(\n                 sess,\n                 lint_store,\n@@ -838,7 +842,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n \n     sess.time(\"MIR_effect_checking\", || {\n         for def_id in tcx.body_owners() {\n-            mir::transform::check_unsafety::check_unsafety(tcx, def_id.to_def_id())\n+            mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n         }\n     });\n \n@@ -905,8 +909,7 @@ fn encode_and_write_metadata(\n \n     let metadata_kind = tcx\n         .sess\n-        .crate_types\n-        .borrow()\n+        .crate_types()\n         .iter()\n         .map(|ty| match *ty {\n             CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => MetadataKind::None,"}, {"sha": "283be165c192c17ddd07d197bf27d794a06936fc", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -3,7 +3,7 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n \n use rustc_ast::{self, ast};\n use rustc_codegen_ssa::traits::CodegenBackend;\n-use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n+use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_hir::Crate;\n@@ -65,7 +65,7 @@ impl<T> Default for Query<T> {\n \n pub struct Queries<'tcx> {\n     compiler: &'tcx Compiler,\n-    gcx: Once<GlobalCtxt<'tcx>>,\n+    gcx: OnceCell<GlobalCtxt<'tcx>>,\n \n     arena: WorkerLocal<Arena<'tcx>>,\n     hir_arena: WorkerLocal<rustc_ast_lowering::Arena<'tcx>>,\n@@ -86,7 +86,7 @@ impl<'tcx> Queries<'tcx> {\n     pub fn new(compiler: &'tcx Compiler) -> Queries<'tcx> {\n         Queries {\n             compiler,\n-            gcx: Once::new(),\n+            gcx: OnceCell::new(),\n             arena: WorkerLocal::new(|_| Arena::default()),\n             hir_arena: WorkerLocal::new(|_| rustc_ast_lowering::Arena::default()),\n             dep_graph_future: Default::default(),"}, {"sha": "87647f3b0b017c84dadc9d46803043794f040cdd", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -2,16 +2,15 @@ use crate::interface::parse_cfgspecs;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{emitter::HumanReadableErrorType, registry, ColorConfig};\n-use rustc_middle::middle::cstore;\n use rustc_session::config::Strip;\n use rustc_session::config::{build_configuration, build_session_options, to_crate_config};\n use rustc_session::config::{rustc_optgroups, ErrorOutputType, ExternLocation, Options, Passes};\n use rustc_session::config::{CFGuard, ExternEntry, LinkerPluginLto, LtoCli, SwitchWithOptPath};\n use rustc_session::config::{Externs, OutputType, OutputTypes, Sanitizer, SymbolManglingVersion};\n-use rustc_session::getopts;\n use rustc_session::lint::Level;\n use rustc_session::search_paths::SearchPath;\n-use rustc_session::{build_session, Session};\n+use rustc_session::utils::NativeLibKind;\n+use rustc_session::{build_session, getopts, DiagnosticOutput, Session};\n use rustc_span::edition::{Edition, DEFAULT_EDITION};\n use rustc_span::symbol::sym;\n use rustc_span::SourceFileHashAlgorithm;\n@@ -32,7 +31,14 @@ fn build_session_options_and_crate_config(matches: getopts::Matches) -> (Options\n fn mk_session(matches: getopts::Matches) -> (Session, CfgSpecs) {\n     let registry = registry::Registry::new(&[]);\n     let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n-    let sess = build_session(sessopts, None, registry);\n+    let sess = build_session(\n+        sessopts,\n+        None,\n+        registry,\n+        DiagnosticOutput::Default,\n+        Default::default(),\n+        None,\n+    );\n     (sess, cfg)\n }\n \n@@ -300,30 +306,30 @@ fn test_native_libs_tracking_hash_different_values() {\n \n     // Reference\n     v1.libs = vec![\n-        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        (String::from(\"a\"), None, NativeLibKind::StaticBundle),\n+        (String::from(\"b\"), None, NativeLibKind::Framework),\n+        (String::from(\"c\"), None, NativeLibKind::Unspecified),\n     ];\n \n     // Change label\n     v2.libs = vec![\n-        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-        (String::from(\"X\"), None, Some(cstore::NativeFramework)),\n-        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        (String::from(\"a\"), None, NativeLibKind::StaticBundle),\n+        (String::from(\"X\"), None, NativeLibKind::Framework),\n+        (String::from(\"c\"), None, NativeLibKind::Unspecified),\n     ];\n \n     // Change kind\n     v3.libs = vec![\n-        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-        (String::from(\"b\"), None, Some(cstore::NativeStatic)),\n-        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        (String::from(\"a\"), None, NativeLibKind::StaticBundle),\n+        (String::from(\"b\"), None, NativeLibKind::StaticBundle),\n+        (String::from(\"c\"), None, NativeLibKind::Unspecified),\n     ];\n \n     // Change new-name\n     v4.libs = vec![\n-        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-        (String::from(\"b\"), Some(String::from(\"X\")), Some(cstore::NativeFramework)),\n-        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        (String::from(\"a\"), None, NativeLibKind::StaticBundle),\n+        (String::from(\"b\"), Some(String::from(\"X\")), NativeLibKind::Framework),\n+        (String::from(\"c\"), None, NativeLibKind::Unspecified),\n     ];\n \n     assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n@@ -345,21 +351,21 @@ fn test_native_libs_tracking_hash_different_order() {\n \n     // Reference\n     v1.libs = vec![\n-        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        (String::from(\"a\"), None, NativeLibKind::StaticBundle),\n+        (String::from(\"b\"), None, NativeLibKind::Framework),\n+        (String::from(\"c\"), None, NativeLibKind::Unspecified),\n     ];\n \n     v2.libs = vec![\n-        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        (String::from(\"b\"), None, NativeLibKind::Framework),\n+        (String::from(\"a\"), None, NativeLibKind::StaticBundle),\n+        (String::from(\"c\"), None, NativeLibKind::Unspecified),\n     ];\n \n     v3.libs = vec![\n-        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+        (String::from(\"c\"), None, NativeLibKind::Unspecified),\n+        (String::from(\"a\"), None, NativeLibKind::StaticBundle),\n+        (String::from(\"b\"), None, NativeLibKind::Framework),\n     ];\n \n     assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n@@ -500,6 +506,7 @@ fn test_debugging_options_tracking_hash() {\n     untracked!(save_analysis, true);\n     untracked!(self_profile, SwitchWithOptPath::Enabled(None));\n     untracked!(self_profile_events, Some(vec![String::new()]));\n+    untracked!(span_debug, true);\n     untracked!(span_free_formats, true);\n     untracked!(strip, Strip::None);\n     untracked!(terminal_width, Some(80));\n@@ -511,6 +518,7 @@ fn test_debugging_options_tracking_hash() {\n     untracked!(ui_testing, true);\n     untracked!(unpretty, Some(\"expanded\".to_string()));\n     untracked!(unstable_options, true);\n+    untracked!(validate_mir, true);\n     untracked!(verbose, true);\n \n     macro_rules! tracked {\n@@ -556,6 +564,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(plt, Some(true));\n     tracked!(print_fuel, Some(\"abc\".to_string()));\n     tracked!(profile, true);\n+    tracked!(profile_emit, Some(PathBuf::from(\"abc\")));\n     tracked!(relro_level, Some(RelroLevel::Full));\n     tracked!(report_delayed_bugs, true);\n     tracked!(run_dsymutil, false);"}, {"sha": "924908e57248760986a543c1a84660ec39774c77", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -23,7 +23,7 @@ use rustc_session::parse::CrateConfig;\n use rustc_session::CrateDisambiguator;\n use rustc_session::{early_error, filesearch, output, DiagnosticOutput, Session};\n use rustc_span::edition::Edition;\n-use rustc_span::source_map::{FileLoader, SourceMap};\n+use rustc_span::source_map::FileLoader;\n use rustc_span::symbol::{sym, Symbol};\n use smallvec::SmallVec;\n use std::env;\n@@ -65,8 +65,8 @@ pub fn create_session(\n     input_path: Option<PathBuf>,\n     lint_caps: FxHashMap<lint::LintId, lint::Level>,\n     descriptions: Registry,\n-) -> (Lrc<Session>, Lrc<Box<dyn CodegenBackend>>, Lrc<SourceMap>) {\n-    let (mut sess, source_map) = session::build_session_with_source_map(\n+) -> (Lrc<Session>, Lrc<Box<dyn CodegenBackend>>) {\n+    let mut sess = session::build_session(\n         sopts,\n         input_path,\n         descriptions,\n@@ -81,7 +81,7 @@ pub fn create_session(\n     add_configuration(&mut cfg, &mut sess, &*codegen_backend);\n     sess.parse_sess.config = cfg;\n \n-    (Lrc::new(sess), Lrc::new(codegen_backend), source_map)\n+    (Lrc::new(sess), Lrc::new(codegen_backend))\n }\n \n const STACK_SIZE: usize = 8 * 1024 * 1024;\n@@ -406,7 +406,7 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n \n     // Also incorporate crate type, so that we don't get symbol conflicts when\n     // linking against a library of the same name, if this is an executable.\n-    let is_exe = session.crate_types.borrow().contains(&CrateType::Executable);\n+    let is_exe = session.crate_types().contains(&CrateType::Executable);\n     hasher.write(if is_exe { b\"exe\" } else { b\"lib\" });\n \n     CrateDisambiguator::from(hasher.finish::<Fingerprint>())\n@@ -713,6 +713,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n                 kind: ast::ExprKind::Block(P(b), None),\n                 span: rustc_span::DUMMY_SP,\n                 attrs: AttrVec::new(),\n+                tokens: None,\n             });\n \n             ast::Stmt {\n@@ -728,6 +729,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n             id: self.resolver.next_node_id(),\n             span: rustc_span::DUMMY_SP,\n             attrs: AttrVec::new(),\n+            tokens: None,\n         });\n \n         let loop_stmt = ast::Stmt {"}, {"sha": "cf90c6d838635b12c85465930e371c5419668ba7", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 64, "deletions": 113, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -29,7 +29,7 @@ mod tests;\n use self::LiteralKind::*;\n use self::TokenKind::*;\n use crate::cursor::{Cursor, EOF_CHAR};\n-use std::convert::TryInto;\n+use std::convert::TryFrom;\n \n /// Parsed token.\n /// It doesn't contain information about data that has been parsed,\n@@ -142,84 +142,24 @@ pub enum LiteralKind {\n     /// \"b\"abc\"\", \"b\"abc\"\n     ByteStr { terminated: bool },\n     /// \"r\"abc\"\", \"r#\"abc\"#\", \"r####\"ab\"###\"c\"####\", \"r#\"a\"\n-    RawStr(UnvalidatedRawStr),\n+    RawStr { n_hashes: u16, err: Option<RawStrError> },\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\"\n-    RawByteStr(UnvalidatedRawStr),\n-}\n-\n-/// Represents something that looks like a raw string, but may have some\n-/// problems. Use `.validate()` to convert it into something\n-/// usable.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct UnvalidatedRawStr {\n-    /// The prefix (`r###\"`) is valid\n-    valid_start: bool,\n-\n-    /// The postfix (`\"###`) is valid\n-    valid_end: bool,\n-\n-    /// The number of leading `#`\n-    n_start_hashes: usize,\n-    /// The number of trailing `#`. `n_end_hashes` <= `n_start_hashes`\n-    n_end_hashes: usize,\n-    /// The offset starting at `r` or `br` where the user may have intended to end the string.\n-    /// Currently, it is the longest sequence of pattern `\"#+\"`.\n-    possible_terminator_offset: Option<usize>,\n+    RawByteStr { n_hashes: u16, err: Option<RawStrError> },\n }\n \n /// Error produced validating a raw string. Represents cases like:\n-/// - `r##~\"abcde\"##`: `LexRawStrError::InvalidStarter`\n-/// - `r###\"abcde\"##`: `LexRawStrError::NoTerminator { expected: 3, found: 2, possible_terminator_offset: Some(11)`\n-/// - Too many `#`s (>65536): `TooManyDelimiters`\n+/// - `r##~\"abcde\"##`: `InvalidStarter`\n+/// - `r###\"abcde\"##`: `NoTerminator { expected: 3, found: 2, possible_terminator_offset: Some(11)`\n+/// - Too many `#`s (>65535): `TooManyDelimiters`\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-pub enum LexRawStrError {\n+pub enum RawStrError {\n     /// Non `#` characters exist between `r` and `\"` eg. `r#~\"..`\n-    InvalidStarter,\n+    InvalidStarter { bad_char: char },\n     /// The string was never terminated. `possible_terminator_offset` is the number of characters after `r` or `br` where they\n     /// may have intended to terminate it.\n     NoTerminator { expected: usize, found: usize, possible_terminator_offset: Option<usize> },\n-    /// More than 65536 `#`s exist.\n-    TooManyDelimiters,\n-}\n-\n-/// Raw String that contains a valid prefix (`#+\"`) and postfix (`\"#+`) where\n-/// there are a matching number of `#` characters in both. Note that this will\n-/// not consume extra trailing `#` characters: `r###\"abcde\"####` is lexed as a\n-/// `ValidatedRawString { n_hashes: 3 }` followed by a `#` token.\n-#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n-pub struct ValidatedRawStr {\n-    n_hashes: u16,\n-}\n-\n-impl ValidatedRawStr {\n-    pub fn num_hashes(&self) -> u16 {\n-        self.n_hashes\n-    }\n-}\n-\n-impl UnvalidatedRawStr {\n-    pub fn validate(self) -> Result<ValidatedRawStr, LexRawStrError> {\n-        if !self.valid_start {\n-            return Err(LexRawStrError::InvalidStarter);\n-        }\n-\n-        // Only up to 65535 `#`s are allowed in raw strings\n-        let n_start_safe: u16 =\n-            self.n_start_hashes.try_into().map_err(|_| LexRawStrError::TooManyDelimiters)?;\n-\n-        if self.n_start_hashes > self.n_end_hashes || !self.valid_end {\n-            Err(LexRawStrError::NoTerminator {\n-                expected: self.n_start_hashes,\n-                found: self.n_end_hashes,\n-                possible_terminator_offset: self.possible_terminator_offset,\n-            })\n-        } else {\n-            // Since the lexer should never produce a literal with n_end > n_start, if n_start <= n_end,\n-            // they must be equal.\n-            debug_assert_eq!(self.n_start_hashes, self.n_end_hashes);\n-            Ok(ValidatedRawStr { n_hashes: n_start_safe })\n-        }\n-    }\n+    /// More than 65535 `#`s exist.\n+    TooManyDelimiters { found: usize },\n }\n \n /// Base of numeric literal encoding according to its prefix.\n@@ -236,16 +176,27 @@ pub enum Base {\n }\n \n /// `rustc` allows files to have a shebang, e.g. \"#!/usr/bin/rustrun\",\n-/// but shebang isn't a part of rust syntax, so this function\n-/// skips the line if it starts with a shebang (\"#!\").\n-/// Line won't be skipped if it represents a valid Rust syntax\n-/// (e.g. \"#![deny(missing_docs)]\").\n+/// but shebang isn't a part of rust syntax.\n pub fn strip_shebang(input: &str) -> Option<usize> {\n-    debug_assert!(!input.is_empty());\n-    if !input.starts_with(\"#!\") || input.starts_with(\"#![\") {\n-        return None;\n+    // Shebang must start with `#!` literally, without any preceding whitespace.\n+    if input.starts_with(\"#!\") {\n+        let input_tail = &input[2..];\n+        // Shebang must have something non-whitespace after `#!` on the first line.\n+        let first_line_tail = input_tail.lines().next()?;\n+        if first_line_tail.contains(|c| !is_whitespace(c)) {\n+            // Ok, this is a shebang but if the next non-whitespace token is `[` or maybe\n+            // a doc comment (due to `TokenKind::(Line,Block)Comment` ambiguity at lexer level),\n+            // then it may be valid Rust code, so consider it Rust code.\n+            let next_non_whitespace_token = tokenize(input_tail).map(|tok| tok.kind).filter(|tok|\n+                !matches!(tok, TokenKind::Whitespace | TokenKind::LineComment | TokenKind::BlockComment { .. })\n+            ).next();\n+            if next_non_whitespace_token != Some(TokenKind::OpenBracket) {\n+                // No other choice than to consider this a shebang.\n+                return Some(2 + first_line_tail.len());\n+            }\n+        }\n     }\n-    Some(input.find('\\n').unwrap_or(input.len()))\n+    None\n }\n \n /// Parses the first token from the provided input string.\n@@ -343,12 +294,12 @@ impl Cursor<'_> {\n             'r' => match (self.first(), self.second()) {\n                 ('#', c1) if is_id_start(c1) => self.raw_ident(),\n                 ('#', _) | ('\"', _) => {\n-                    let raw_str_i = self.raw_double_quoted_string(1);\n+                    let (n_hashes, err) = self.raw_double_quoted_string(1);\n                     let suffix_start = self.len_consumed();\n-                    if raw_str_i.n_end_hashes == raw_str_i.n_start_hashes {\n+                    if err.is_none() {\n                         self.eat_literal_suffix();\n                     }\n-                    let kind = RawStr(raw_str_i);\n+                    let kind = RawStr { n_hashes, err };\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -378,14 +329,12 @@ impl Cursor<'_> {\n                 }\n                 ('r', '\"') | ('r', '#') => {\n                     self.bump();\n-                    let raw_str_i = self.raw_double_quoted_string(2);\n+                    let (n_hashes, err) = self.raw_double_quoted_string(2);\n                     let suffix_start = self.len_consumed();\n-                    let terminated = raw_str_i.n_start_hashes == raw_str_i.n_end_hashes;\n-                    if terminated {\n+                    if err.is_none() {\n                         self.eat_literal_suffix();\n                     }\n-\n-                    let kind = RawByteStr(raw_str_i);\n+                    let kind = RawByteStr { n_hashes, err };\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -681,27 +630,34 @@ impl Cursor<'_> {\n         false\n     }\n \n-    /// Eats the double-quoted string and returns an `UnvalidatedRawStr`.\n-    fn raw_double_quoted_string(&mut self, prefix_len: usize) -> UnvalidatedRawStr {\n+    /// Eats the double-quoted string and returns `n_hashes` and an error if encountered.\n+    fn raw_double_quoted_string(&mut self, prefix_len: usize) -> (u16, Option<RawStrError>) {\n+        // Wrap the actual function to handle the error with too many hashes.\n+        // This way, it eats the whole raw string.\n+        let (n_hashes, err) = self.raw_string_unvalidated(prefix_len);\n+        // Only up to 65535 `#`s are allowed in raw strings\n+        match u16::try_from(n_hashes) {\n+            Ok(num) => (num, err),\n+            // We lie about the number of hashes here :P\n+            Err(_) => (0, Some(RawStrError::TooManyDelimiters { found: n_hashes })),\n+        }\n+    }\n+\n+    fn raw_string_unvalidated(&mut self, prefix_len: usize) -> (usize, Option<RawStrError>) {\n         debug_assert!(self.prev() == 'r');\n-        let mut valid_start: bool = false;\n         let start_pos = self.len_consumed();\n-        let (mut possible_terminator_offset, mut max_hashes) = (None, 0);\n+        let mut possible_terminator_offset = None;\n+        let mut max_hashes = 0;\n \n         // Count opening '#' symbols.\n         let n_start_hashes = self.eat_while(|c| c == '#');\n \n         // Check that string is started.\n         match self.bump() {\n-            Some('\"') => valid_start = true,\n-            _ => {\n-                return UnvalidatedRawStr {\n-                    valid_start,\n-                    valid_end: false,\n-                    n_start_hashes,\n-                    n_end_hashes: 0,\n-                    possible_terminator_offset,\n-                };\n+            Some('\"') => (),\n+            c => {\n+                let c = c.unwrap_or(EOF_CHAR);\n+                return (n_start_hashes, Some(RawStrError::InvalidStarter { bad_char: c }));\n             }\n         }\n \n@@ -711,13 +667,14 @@ impl Cursor<'_> {\n             self.eat_while(|c| c != '\"');\n \n             if self.is_eof() {\n-                return UnvalidatedRawStr {\n-                    valid_start,\n-                    valid_end: false,\n+                return (\n                     n_start_hashes,\n-                    n_end_hashes: max_hashes,\n-                    possible_terminator_offset,\n-                };\n+                    Some(RawStrError::NoTerminator {\n+                        expected: n_start_hashes,\n+                        found: max_hashes,\n+                        possible_terminator_offset,\n+                    }),\n+                );\n             }\n \n             // Eat closing double quote.\n@@ -726,7 +683,7 @@ impl Cursor<'_> {\n             // Check that amount of closing '#' symbols\n             // is equal to the amount of opening ones.\n             // Note that this will not consume extra trailing `#` characters:\n-            // `r###\"abcde\"####` is lexed as a `LexedRawString { n_hashes: 3 }`\n+            // `r###\"abcde\"####` is lexed as a `RawStr { n_hashes: 3 }`\n             // followed by a `#` token.\n             let mut hashes_left = n_start_hashes;\n             let is_closing_hash = |c| {\n@@ -740,13 +697,7 @@ impl Cursor<'_> {\n             let n_end_hashes = self.eat_while(is_closing_hash);\n \n             if n_end_hashes == n_start_hashes {\n-                return UnvalidatedRawStr {\n-                    valid_start,\n-                    valid_end: true,\n-                    n_start_hashes,\n-                    n_end_hashes,\n-                    possible_terminator_offset: None,\n-                };\n+                return (n_start_hashes, None);\n             } else if n_end_hashes > max_hashes {\n                 // Keep track of possible terminators to give a hint about\n                 // where there might be a missing terminator"}, {"sha": "e6acc26ec2f343e6645755f6032eff88e8e385d3", "filename": "src/librustc_lexer/src/tests.rs", "status": "modified", "additions": 73, "deletions": 84, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -2,92 +2,46 @@\n mod tests {\n     use crate::*;\n \n-    fn check_raw_str(\n-        s: &str,\n-        expected: UnvalidatedRawStr,\n-        validated: Result<ValidatedRawStr, LexRawStrError>,\n-    ) {\n+    fn check_raw_str(s: &str, expected_hashes: u16, expected_err: Option<RawStrError>) {\n         let s = &format!(\"r{}\", s);\n         let mut cursor = Cursor::new(s);\n         cursor.bump();\n-        let tok = cursor.raw_double_quoted_string(0);\n-        assert_eq!(tok, expected);\n-        assert_eq!(tok.validate(), validated);\n+        let (n_hashes, err) = cursor.raw_double_quoted_string(0);\n+        assert_eq!(n_hashes, expected_hashes);\n+        assert_eq!(err, expected_err);\n     }\n \n     #[test]\n     fn test_naked_raw_str() {\n-        check_raw_str(\n-            r#\"\"abc\"\"#,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 0,\n-                n_end_hashes: 0,\n-                valid_start: true,\n-                valid_end: true,\n-                possible_terminator_offset: None,\n-            },\n-            Ok(ValidatedRawStr { n_hashes: 0 }),\n-        );\n+        check_raw_str(r#\"\"abc\"\"#, 0, None);\n     }\n \n     #[test]\n     fn test_raw_no_start() {\n-        check_raw_str(\n-            r##\"\"abc\"#\"##,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 0,\n-                n_end_hashes: 0,\n-                valid_start: true,\n-                valid_end: true,\n-                possible_terminator_offset: None,\n-            },\n-            Ok(ValidatedRawStr { n_hashes: 0 }),\n-        );\n+        check_raw_str(r##\"\"abc\"#\"##, 0, None);\n     }\n \n     #[test]\n     fn test_too_many_terminators() {\n         // this error is handled in the parser later\n-        check_raw_str(\n-            r###\"#\"abc\"##\"###,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 1,\n-                n_end_hashes: 1,\n-                valid_end: true,\n-                valid_start: true,\n-                possible_terminator_offset: None,\n-            },\n-            Ok(ValidatedRawStr { n_hashes: 1 }),\n-        );\n+        check_raw_str(r###\"#\"abc\"##\"###, 1, None);\n     }\n \n     #[test]\n     fn test_unterminated() {\n         check_raw_str(\n             r#\"#\"abc\"#,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 1,\n-                n_end_hashes: 0,\n-                valid_end: false,\n-                valid_start: true,\n-                possible_terminator_offset: None,\n-            },\n-            Err(LexRawStrError::NoTerminator {\n+            1,\n+            Some(RawStrError::NoTerminator {\n                 expected: 1,\n                 found: 0,\n                 possible_terminator_offset: None,\n             }),\n         );\n         check_raw_str(\n             r###\"##\"abc\"#\"###,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 2,\n-                n_end_hashes: 1,\n-                valid_start: true,\n-                valid_end: false,\n-                possible_terminator_offset: Some(7),\n-            },\n-            Err(LexRawStrError::NoTerminator {\n+            2,\n+            Some(RawStrError::NoTerminator {\n                 expected: 2,\n                 found: 1,\n                 possible_terminator_offset: Some(7),\n@@ -96,14 +50,8 @@ mod tests {\n         // We're looking for \"# not just any #\n         check_raw_str(\n             r###\"##\"abc#\"###,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 2,\n-                n_end_hashes: 0,\n-                valid_start: true,\n-                valid_end: false,\n-                possible_terminator_offset: None,\n-            },\n-            Err(LexRawStrError::NoTerminator {\n+            2,\n+            Some(RawStrError::NoTerminator {\n                 expected: 2,\n                 found: 0,\n                 possible_terminator_offset: None,\n@@ -113,36 +61,77 @@ mod tests {\n \n     #[test]\n     fn test_invalid_start() {\n-        check_raw_str(\n-            r##\"#~\"abc\"#\"##,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 1,\n-                n_end_hashes: 0,\n-                valid_start: false,\n-                valid_end: false,\n-                possible_terminator_offset: None,\n-            },\n-            Err(LexRawStrError::InvalidStarter),\n-        );\n+        check_raw_str(r##\"#~\"abc\"#\"##, 1, Some(RawStrError::InvalidStarter { bad_char: '~' }));\n     }\n \n     #[test]\n     fn test_unterminated_no_pound() {\n         // https://github.com/rust-lang/rust/issues/70677\n         check_raw_str(\n             r#\"\"\"#,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 0,\n-                n_end_hashes: 0,\n-                valid_start: true,\n-                valid_end: false,\n-                possible_terminator_offset: None,\n-            },\n-            Err(LexRawStrError::NoTerminator {\n+            0,\n+            Some(RawStrError::NoTerminator {\n                 expected: 0,\n                 found: 0,\n                 possible_terminator_offset: None,\n             }),\n         );\n     }\n+\n+    #[test]\n+    fn test_valid_shebang() {\n+        // https://github.com/rust-lang/rust/issues/70528\n+        let input = \"#!/usr/bin/rustrun\\nlet x = 5;\";\n+        assert_eq!(strip_shebang(input), Some(18));\n+    }\n+\n+    #[test]\n+    fn test_invalid_shebang_valid_rust_syntax() {\n+        // https://github.com/rust-lang/rust/issues/70528\n+        let input = \"#!    [bad_attribute]\";\n+        assert_eq!(strip_shebang(input), None);\n+    }\n+\n+    #[test]\n+    fn test_shebang_second_line() {\n+        // Because shebangs are interpreted by the kernel, they must be on the first line\n+        let input = \"\\n#!/bin/bash\";\n+        assert_eq!(strip_shebang(input), None);\n+    }\n+\n+    #[test]\n+    fn test_shebang_space() {\n+        let input = \"#!    /bin/bash\";\n+        assert_eq!(strip_shebang(input), Some(input.len()));\n+    }\n+\n+    #[test]\n+    fn test_shebang_empty_shebang() {\n+        let input = \"#!    \\n[attribute(foo)]\";\n+        assert_eq!(strip_shebang(input), None);\n+    }\n+\n+    #[test]\n+    fn test_invalid_shebang_comment() {\n+        let input = \"#!//bin/ami/a/comment\\n[\";\n+        assert_eq!(strip_shebang(input), None)\n+    }\n+\n+    #[test]\n+    fn test_invalid_shebang_another_comment() {\n+        let input = \"#!/*bin/ami/a/comment*/\\n[attribute\";\n+        assert_eq!(strip_shebang(input), None)\n+    }\n+\n+    #[test]\n+    fn test_shebang_valid_rust_after() {\n+        let input = \"#!/*bin/ami/a/comment*/\\npub fn main() {}\";\n+        assert_eq!(strip_shebang(input), Some(23))\n+    }\n+\n+    #[test]\n+    fn test_shebang_followed_by_attrib() {\n+        let input = \"#!/bin/rust-scripts\\n#![allow_unused(true)]\";\n+        assert_eq!(strip_shebang(input), Some(19));\n+    }\n }"}, {"sha": "e17e8b7b9640e8e8dfd334f088859da67a06d1b3", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1202,13 +1202,13 @@ declare_lint_pass!(\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::fold::TypeFoldable;\n-        use rustc_middle::ty::Predicate::*;\n+        use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n             for &(predicate, span) in predicates.predicates {\n-                let predicate_kind_name = match predicate {\n+                let predicate_kind_name = match predicate.kind() {\n                     Trait(..) => \"Trait\",\n                     TypeOutlives(..) |\n                     RegionOutlives(..) => \"Lifetime\",\n@@ -1497,8 +1497,8 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred {\n-                ty::Predicate::RegionOutlives(outlives) => {\n+            .filter_map(|(pred, _)| match pred.kind() {\n+                ty::PredicateKind::RegionOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n                     match outlives.0 {\n                         ty::ReEarlyBound(ebr) if ebr.index == index => Some(outlives.1),\n@@ -1516,8 +1516,8 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred {\n-                ty::Predicate::TypeOutlives(outlives) => {\n+            .filter_map(|(pred, _)| match pred.kind() {\n+                ty::PredicateKind::TypeOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n                     outlives.0.is_param(index).then_some(outlives.1)\n                 }"}, {"sha": "05e7c9a0c780de86898cb28e32a1118872a05495", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -14,11 +14,11 @@ use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::lint::{struct_lint_level, LintLevelMap, LintLevelSets, LintSet, LintSource};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::lint::{builtin, Level, Lint};\n+use rustc_session::lint::{builtin, Level, Lint, LintId};\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n-use rustc_span::source_map::MultiSpan;\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::{source_map::MultiSpan, Span, DUMMY_SP};\n \n use std::cmp;\n \n@@ -80,11 +80,13 @@ impl<'s> LintLevelsBuilder<'s> {\n             let level = cmp::min(level, self.sets.lint_cap);\n \n             let lint_flag_val = Symbol::intern(lint_name);\n+\n             let ids = match store.find_lints(&lint_name) {\n                 Ok(ids) => ids,\n                 Err(_) => continue, // errors handled in check_lint_name_cmdline above\n             };\n             for id in ids {\n+                self.check_gated_lint(id, DUMMY_SP);\n                 let src = LintSource::CommandLine(lint_flag_val);\n                 specs.insert(id, (level, src));\n             }\n@@ -212,8 +214,9 @@ impl<'s> LintLevelsBuilder<'s> {\n                 match store.check_lint_name(&name.as_str(), tool_name) {\n                     CheckLintNameResult::Ok(ids) => {\n                         let src = LintSource::Node(name, li.span(), reason);\n-                        for id in ids {\n-                            specs.insert(*id, (level, src));\n+                        for &id in ids {\n+                            self.check_gated_lint(id, attr.span);\n+                            specs.insert(id, (level, src));\n                         }\n                     }\n \n@@ -383,6 +386,21 @@ impl<'s> LintLevelsBuilder<'s> {\n         BuilderPush { prev, changed: prev != self.cur }\n     }\n \n+    /// Checks if the lint is gated on a feature that is not enabled.\n+    fn check_gated_lint(&self, lint_id: LintId, span: Span) {\n+        if let Some(feature) = lint_id.lint.feature_gate {\n+            if !self.sess.features_untracked().enabled(feature) {\n+                feature_err(\n+                    &self.sess.parse_sess,\n+                    feature,\n+                    span,\n+                    &format!(\"the `{}` lint is unstable\", lint_id.lint.name_lower()),\n+                )\n+                .emit();\n+            }\n+        }\n+    }\n+\n     /// Called after `push` when the scope of a set of attributes are exited.\n     pub fn pop(&mut self, push: BuilderPush) {\n         self.cur = push.prev;"}, {"sha": "dea829343137064da7097f6781cb76c9c859d7e7", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -146,7 +146,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 ty::Opaque(def, _) => {\n                     let mut has_emitted = false;\n                     for (predicate, _) in cx.tcx.predicates_of(def).predicates {\n-                        if let ty::Predicate::Trait(ref poly_trait_predicate, _) = predicate {\n+                        if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) =\n+                            predicate.kind()\n+                        {\n                             let trait_ref = poly_trait_predicate.skip_binder().trait_ref;\n                             let def_id = trait_ref.def_id;\n                             let descr_pre ="}, {"sha": "41a49a38a19cf757c79b4866df92b64c688724cd", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -199,7 +199,7 @@ impl Parse for Group {\n \n struct QueryModifiers {\n     /// The description of the query.\n-    desc: Option<(Option<Ident>, Punctuated<Expr, Token![,]>)>,\n+    desc: (Option<Ident>, Punctuated<Expr, Token![,]>),\n \n     /// Use this type for the in-memory cache.\n     storage: Option<Type>,\n@@ -295,6 +295,9 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n             }\n         }\n     }\n+    let desc = desc.unwrap_or_else(|| {\n+        panic!(\"no description provided for query `{}`\", query.name);\n+    });\n     QueryModifiers {\n         load_cached,\n         storage,\n@@ -319,7 +322,7 @@ fn add_query_description_impl(\n     let key = &query.key.0;\n \n     // Find out if we should cache the query on disk\n-    let cache = modifiers.cache.as_ref().map(|(args, expr)| {\n+    let cache = if let Some((args, expr)) = modifiers.cache.as_ref() {\n         let try_load_from_disk = if let Some((tcx, id, block)) = modifiers.load_cached.as_ref() {\n             // Use custom code to load the query from disk\n             quote! {\n@@ -373,36 +376,32 @@ fn add_query_description_impl(\n \n             #try_load_from_disk\n         }\n-    });\n-\n-    if cache.is_none() && modifiers.load_cached.is_some() {\n-        panic!(\"load_cached modifier on query `{}` without a cache modifier\", name);\n-    }\n+    } else {\n+        if modifiers.load_cached.is_some() {\n+            panic!(\"load_cached modifier on query `{}` without a cache modifier\", name);\n+        }\n+        quote! {}\n+    };\n+\n+    let (tcx, desc) = modifiers.desc;\n+    let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n+\n+    let desc = quote! {\n+        #[allow(unused_variables)]\n+        fn describe(\n+            #tcx: TyCtxt<'tcx>,\n+            #key: #arg,\n+        ) -> Cow<'static, str> {\n+            format!(#desc).into()\n+        }\n+    };\n \n-    let desc = modifiers.desc.as_ref().map(|(tcx, desc)| {\n-        let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n-        quote! {\n-            #[allow(unused_variables)]\n-            fn describe(\n-                #tcx: TyCtxt<'tcx>,\n-                #key: #arg,\n-            ) -> Cow<'static, str> {\n-                format!(#desc).into()\n-            }\n+    impls.extend(quote! {\n+        impl<'tcx> QueryDescription<TyCtxt<'tcx>> for queries::#name<'tcx> {\n+            #desc\n+            #cache\n         }\n     });\n-\n-    if desc.is_some() || cache.is_some() {\n-        let cache = cache.unwrap_or(quote! {});\n-        let desc = desc.unwrap_or(quote! {});\n-\n-        impls.extend(quote! {\n-            impl<'tcx> QueryDescription<TyCtxt<'tcx>> for queries::#name<'tcx> {\n-                #desc\n-                #cache\n-            }\n-        });\n-    }\n }\n \n pub fn rustc_queries(input: TokenStream) -> TokenStream {"}, {"sha": "7bbe7567d2924eb966bfdcc3e178a112777689dc", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -23,7 +23,7 @@ rustc_hir = { path = \"../librustc_hir\" }\n rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_index = { path = \"../librustc_index\" }\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n stable_deref_trait = \"1.0.0\"\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_expand = { path = \"../librustc_expand\" }"}, {"sha": "7e902f0ade2eff6109c27a0f29d0d73f32ca464e", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -5,6 +5,7 @@ use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob\n \n use rustc_ast::expand::allocator::{global_allocator_spans, AllocatorKind};\n use rustc_ast::{ast, attr};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n@@ -17,7 +18,8 @@ use rustc_middle::middle::cstore::{\n     CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn,\n };\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{self, CrateType};\n+use rustc_session::config::{self, CrateType, ExternLocation};\n+use rustc_session::lint;\n use rustc_session::output::validate_crate_name;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{CrateDisambiguator, Session};\n@@ -49,6 +51,7 @@ pub struct CrateLoader<'a> {\n     local_crate_name: Symbol,\n     // Mutable output.\n     cstore: CStore,\n+    used_extern_options: FxHashSet<Symbol>,\n }\n \n pub enum LoadedMacro {\n@@ -205,6 +208,7 @@ impl<'a> CrateLoader<'a> {\n                 allocator_kind: None,\n                 has_global_allocator: false,\n             },\n+            used_extern_options: Default::default(),\n         }\n     }\n \n@@ -445,6 +449,9 @@ impl<'a> CrateLoader<'a> {\n         dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n     ) -> CrateNum {\n+        if dep.is_none() {\n+            self.used_extern_options.insert(name);\n+        }\n         self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n     }\n \n@@ -615,7 +622,7 @@ impl<'a> CrateLoader<'a> {\n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n-        let any_non_rlib = self.sess.crate_types.borrow().iter().any(|ct| *ct != CrateType::Rlib);\n+        let any_non_rlib = self.sess.crate_types().iter().any(|ct| *ct != CrateType::Rlib);\n         if !any_non_rlib {\n             info!(\"panic runtime injection skipped, only generating rlib\");\n             return;\n@@ -734,7 +741,7 @@ impl<'a> CrateLoader<'a> {\n         // At this point we've determined that we need an allocator. Let's see\n         // if our compilation session actually needs an allocator based on what\n         // we're emitting.\n-        let all_rlib = self.sess.crate_types.borrow().iter().all(|ct| match *ct {\n+        let all_rlib = self.sess.crate_types().iter().all(|ct| match *ct {\n             CrateType::Rlib => true,\n             _ => false,\n         });\n@@ -839,6 +846,30 @@ impl<'a> CrateLoader<'a> {\n         });\n     }\n \n+    fn report_unused_deps(&mut self, krate: &ast::Crate) {\n+        // Make a point span rather than covering the whole file\n+        let span = krate.span.shrink_to_lo();\n+        // Complain about anything left over\n+        for (name, entry) in self.sess.opts.externs.iter() {\n+            if let ExternLocation::FoundInLibrarySearchDirectories = entry.location {\n+                // Don't worry about pathless `--extern foo` sysroot references\n+                continue;\n+            }\n+            if !self.used_extern_options.contains(&Symbol::intern(name)) {\n+                self.sess.parse_sess.buffer_lint(\n+                    lint::builtin::UNUSED_CRATE_DEPENDENCIES,\n+                    span,\n+                    ast::CRATE_NODE_ID,\n+                    &format!(\n+                        \"external crate `{}` unused in `{}`: remove the dependency or add `use {} as _;`\",\n+                        name,\n+                        self.local_crate_name,\n+                        name),\n+                );\n+            }\n+        }\n+    }\n+\n     pub fn postprocess(&mut self, krate: &ast::Crate) {\n         self.inject_profiler_runtime();\n         self.inject_allocator_crate(krate);\n@@ -847,6 +878,8 @@ impl<'a> CrateLoader<'a> {\n         if log_enabled!(log::Level::Info) {\n             dump_crates(&self.cstore);\n         }\n+\n+        self.report_unused_deps(krate);\n     }\n \n     pub fn process_extern_crate("}, {"sha": "aa5fafcc614b655ddcda11bd344451320861a7bc", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -64,8 +64,7 @@ use rustc_target::spec::PanicStrategy;\n \n crate fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n     tcx.sess\n-        .crate_types\n-        .borrow()\n+        .crate_types()\n         .iter()\n         .map(|&ty| {\n             let linkage = calculate_type(tcx, ty);"}, {"sha": "5a4862d4521833f38c12ead3abf493d8ca4c770b", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -670,7 +670,7 @@ impl<'a> CrateLocator<'a> {\n \n         // The all loop is because `--crate-type=rlib --crate-type=rlib` is\n         // legal and produces both inside this type.\n-        let is_rlib = self.sess.crate_types.borrow().iter().all(|c| *c == CrateType::Rlib);\n+        let is_rlib = self.sess.crate_types().iter().all(|c| *c == CrateType::Rlib);\n         let needs_object_code = self.sess.opts.output_types.should_codegen();\n         // If we're producing an rlib, then we don't need object code.\n         // Or, if we're not producing object code, then we don't need it either"}, {"sha": "fc4235a3eda098c652ecf0b7764d1ef8d848b712", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -3,22 +3,23 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_middle::middle::cstore::{self, NativeLibrary};\n+use rustc_middle::middle::cstore::NativeLib;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::parse::feature_err;\n+use rustc_session::utils::NativeLibKind;\n use rustc_session::Session;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n-crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n+crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n     let mut collector = Collector { tcx, libs: Vec::new() };\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n     collector.process_command_line();\n     collector.libs\n }\n \n-crate fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+crate fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n         None => true,\n@@ -27,7 +28,7 @@ crate fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n \n struct Collector<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    libs: Vec<NativeLibrary>,\n+    libs: Vec<NativeLib>,\n }\n \n impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n@@ -47,9 +48,9 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                 Some(item) => item,\n                 None => continue,\n             };\n-            let mut lib = NativeLibrary {\n+            let mut lib = NativeLib {\n                 name: None,\n-                kind: cstore::NativeUnknown,\n+                kind: NativeLibKind::Unspecified,\n                 cfg: None,\n                 foreign_module: Some(self.tcx.hir().local_def_id(it.hir_id).to_def_id()),\n                 wasm_import_module: None,\n@@ -64,11 +65,11 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                         None => continue, // skip like historical compilers\n                     };\n                     lib.kind = match &*kind.as_str() {\n-                        \"static\" => cstore::NativeStatic,\n-                        \"static-nobundle\" => cstore::NativeStaticNobundle,\n-                        \"dylib\" => cstore::NativeUnknown,\n-                        \"framework\" => cstore::NativeFramework,\n-                        \"raw-dylib\" => cstore::NativeRawDylib,\n+                        \"static\" => NativeLibKind::StaticBundle,\n+                        \"static-nobundle\" => NativeLibKind::StaticNoBundle,\n+                        \"dylib\" => NativeLibKind::Dylib,\n+                        \"framework\" => NativeLibKind::Framework,\n+                        \"raw-dylib\" => NativeLibKind::RawDylib,\n                         k => {\n                             struct_span_err!(\n                                 self.tcx.sess,\n@@ -80,7 +81,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                             .span_label(item.span(), \"unknown kind\")\n                             .span_label(m.span, \"\")\n                             .emit();\n-                            cstore::NativeUnknown\n+                            NativeLibKind::Unspecified\n                         }\n                     };\n                 } else if item.check_name(sym::name) {\n@@ -134,7 +135,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n }\n \n impl Collector<'tcx> {\n-    fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLibrary) {\n+    fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLib) {\n         if lib.name.as_ref().map(|&s| s == kw::Invalid).unwrap_or(false) {\n             match span {\n                 Some(span) => {\n@@ -154,7 +155,7 @@ impl Collector<'tcx> {\n             return;\n         }\n         let is_osx = self.tcx.sess.target.target.options.is_like_osx;\n-        if lib.kind == cstore::NativeFramework && !is_osx {\n+        if lib.kind == NativeLibKind::Framework && !is_osx {\n             let msg = \"native frameworks are only available on macOS targets\";\n             match span {\n                 Some(span) => struct_span_err!(self.tcx.sess, span, E0455, \"{}\", msg).emit(),\n@@ -170,7 +171,7 @@ impl Collector<'tcx> {\n             )\n             .emit();\n         }\n-        if lib.kind == cstore::NativeStaticNobundle && !self.tcx.features().static_nobundle {\n+        if lib.kind == NativeLibKind::StaticNoBundle && !self.tcx.features().static_nobundle {\n             feature_err(\n                 &self.tcx.sess.parse_sess,\n                 sym::static_nobundle,\n@@ -179,7 +180,7 @@ impl Collector<'tcx> {\n             )\n             .emit();\n         }\n-        if lib.kind == cstore::NativeRawDylib && !self.tcx.features().raw_dylib {\n+        if lib.kind == NativeLibKind::RawDylib && !self.tcx.features().raw_dylib {\n             feature_err(\n                 &self.tcx.sess.parse_sess,\n                 sym::raw_dylib,\n@@ -240,8 +241,8 @@ impl Collector<'tcx> {\n                 .drain_filter(|lib| {\n                     if let Some(lib_name) = lib.name {\n                         if lib_name.as_str() == *name {\n-                            if let Some(k) = kind {\n-                                lib.kind = k;\n+                            if kind != NativeLibKind::Unspecified {\n+                                lib.kind = kind;\n                             }\n                             if let &Some(ref new_name) = new_name {\n                                 lib.name = Some(Symbol::intern(new_name));\n@@ -255,9 +256,9 @@ impl Collector<'tcx> {\n             if existing.is_empty() {\n                 // Add if not found\n                 let new_name = new_name.as_ref().map(|s| &**s); // &Option<String> -> Option<&str>\n-                let lib = NativeLibrary {\n+                let lib = NativeLib {\n                     name: Some(Symbol::intern(new_name.unwrap_or(name))),\n-                    kind: if let Some(k) = kind { k } else { cstore::NativeUnknown },\n+                    kind,\n                     cfg: None,\n                     foreign_module: None,\n                     wasm_import_module: None,"}, {"sha": "f5a9dceb78295707c2b5fc7b9dc66787ddac40cf", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{AtomicCell, Lock, LockGuard, Lrc, Once};\n+use rustc_data_structures::sync::{AtomicCell, Lock, LockGuard, Lrc, OnceCell};\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n use rustc_hir as hir;\n@@ -23,7 +23,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::dep_graph::{self, DepNode, DepNodeExt, DepNodeIndex};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::middle::cstore::{CrateSource, ExternCrate};\n-use rustc_middle::middle::cstore::{ForeignModule, LinkagePreference, NativeLibrary};\n+use rustc_middle::middle::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, interpret, Body, Promoted};\n@@ -79,7 +79,7 @@ crate struct CrateMetadata {\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n-    source_map_import_info: Once<Vec<ImportedSourceFile>>,\n+    source_map_import_info: OnceCell<Vec<ImportedSourceFile>>,\n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n     alloc_decoding_state: AllocDecodingState,\n     /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n@@ -1278,7 +1278,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         })\n     }\n \n-    fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n+    fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLib> {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n@@ -1471,22 +1471,29 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n             if let Some(virtual_dir) = virtual_rust_source_base_dir {\n                 if let Some(real_dir) = &sess.real_rust_source_base_dir {\n-                    if let rustc_span::FileName::Real(path) = name {\n-                        if let Ok(rest) = path.strip_prefix(virtual_dir) {\n-                            let new_path = real_dir.join(rest);\n-                            debug!(\n-                                \"try_to_translate_virtual_to_real: `{}` -> `{}`\",\n-                                path.display(),\n-                                new_path.display(),\n-                            );\n-                            *path = new_path;\n+                    if let rustc_span::FileName::Real(old_name) = name {\n+                        if let rustc_span::RealFileName::Named(one_path) = old_name {\n+                            if let Ok(rest) = one_path.strip_prefix(virtual_dir) {\n+                                let virtual_name = one_path.clone();\n+                                let new_path = real_dir.join(rest);\n+                                debug!(\n+                                    \"try_to_translate_virtual_to_real: `{}` -> `{}`\",\n+                                    virtual_name.display(),\n+                                    new_path.display(),\n+                                );\n+                                let new_name = rustc_span::RealFileName::Devirtualized {\n+                                    local_path: new_path,\n+                                    virtual_name,\n+                                };\n+                                *old_name = new_name;\n+                            }\n                         }\n                     }\n                 }\n             }\n         };\n \n-        self.cdata.source_map_import_info.init_locking(|| {\n+        self.cdata.source_map_import_info.get_or_init(|| {\n             let external_source_map = self.root.source_map.decode(self);\n \n             external_source_map\n@@ -1600,7 +1607,7 @@ impl CrateMetadata {\n             def_path_table,\n             trait_impls,\n             raw_proc_macros,\n-            source_map_import_info: Once::new(),\n+            source_map_import_info: OnceCell::new(),\n             alloc_decoding_state,\n             dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n             cnum,"}, {"sha": "1b168bf01178c17c2c304b30641e1891fb878a36", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -13,12 +13,13 @@ use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE}\n use rustc_hir::definitions::DefPathTable;\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_middle::hir::exports::Export;\n-use rustc_middle::middle::cstore::{CrateSource, CrateStore, EncodedMetadata, NativeLibraryKind};\n+use rustc_middle::middle::cstore::{CrateSource, CrateStore, EncodedMetadata};\n use rustc_middle::middle::exported_symbols::ExportedSymbol;\n use rustc_middle::middle::stability::DeprecationEntry;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::query::QueryConfig;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_session::utils::NativeLibKind;\n use rustc_session::{CrateDisambiguator, Session};\n use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{Ident, Symbol};\n@@ -246,11 +247,13 @@ pub fn provide(providers: &mut Providers<'_>) {\n     // resolve! Does this work? Unsure! That's what the issue is about\n     *providers = Providers {\n         is_dllimport_foreign_item: |tcx, id| match tcx.native_library_kind(id) {\n-            Some(NativeLibraryKind::NativeUnknown | NativeLibraryKind::NativeRawDylib) => true,\n+            Some(NativeLibKind::Dylib | NativeLibKind::RawDylib | NativeLibKind::Unspecified) => {\n+                true\n+            }\n             _ => false,\n         },\n         is_statically_included_foreign_item: |tcx, id| match tcx.native_library_kind(id) {\n-            Some(NativeLibraryKind::NativeStatic | NativeLibraryKind::NativeStaticNobundle) => true,\n+            Some(NativeLibKind::StaticBundle | NativeLibKind::StaticNoBundle) => true,\n             _ => false,\n         },\n         native_library_kind: |tcx, id| {"}, {"sha": "64ccd46a744f503b110212acad386e1768c6c605", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -18,9 +18,7 @@ use rustc_hir::lang_items;\n use rustc_hir::{AnonConst, GenericParamKind};\n use rustc_index::vec::Idx;\n use rustc_middle::hir::map::Map;\n-use rustc_middle::middle::cstore::{\n-    EncodedMetadata, ForeignModule, LinkagePreference, NativeLibrary,\n-};\n+use rustc_middle::middle::cstore::{EncodedMetadata, ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportLevel,\n@@ -398,6 +396,7 @@ impl<'tcx> EncodeContext<'tcx> {\n                     // any relative paths are potentially relative to a\n                     // wrong directory.\n                     FileName::Real(ref name) => {\n+                        let name = name.stable_name();\n                         let mut adapted = (**source_file).clone();\n                         adapted.name = Path::new(&working_dir).join(name).into();\n                         adapted.name_hash = {\n@@ -418,7 +417,7 @@ impl<'tcx> EncodeContext<'tcx> {\n     }\n \n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n-        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+        let is_proc_macro = self.tcx.sess.crate_types().contains(&CrateType::ProcMacro);\n \n         let mut i = self.position();\n \n@@ -694,16 +693,25 @@ impl EncodeContext<'tcx> {\n         vis: &hir::Visibility<'_>,\n     ) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id(id).to_def_id();\n+        let def_id = tcx.hir().local_def_id(id);\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n             reexports: match tcx.module_exports(def_id) {\n-                Some(exports) => self.lazy(exports),\n+                Some(exports) => {\n+                    let hir_map = self.tcx.hir();\n+                    self.lazy(\n+                        exports\n+                            .iter()\n+                            .map(|export| export.map_id(|id| hir_map.as_local_hir_id(id))),\n+                    )\n+                }\n                 _ => Lazy::empty(),\n             },\n         };\n \n+        let def_id = def_id.to_def_id();\n+\n         record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n         record!(self.tables.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n@@ -1355,7 +1363,7 @@ impl EncodeContext<'tcx> {\n         self.encode_promoted_mir(def_id);\n     }\n \n-    fn encode_native_libraries(&mut self) -> Lazy<[NativeLibrary]> {\n+    fn encode_native_libraries(&mut self) -> Lazy<[NativeLib]> {\n         let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n         self.lazy(used_libraries.iter().cloned())\n     }\n@@ -1366,7 +1374,7 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_proc_macros(&mut self) -> Option<Lazy<[DefIndex]>> {\n-        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+        let is_proc_macro = self.tcx.sess.crate_types().contains(&CrateType::ProcMacro);\n         if is_proc_macro {\n             let tcx = self.tcx;\n             Some(self.lazy(tcx.hir().krate().proc_macros.iter().map(|p| p.owner.local_def_index)))"}, {"sha": "89d525eb80b8c4c2db5f243ebf7a7dac56922d8f", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::def_id::{DefId, DefIndex};\n use rustc_hir::lang_items;\n use rustc_index::vec::IndexVec;\n use rustc_middle::hir::exports::Export;\n-use rustc_middle::middle::cstore::{DepKind, ForeignModule, LinkagePreference, NativeLibrary};\n+use rustc_middle::middle::cstore::{DepKind, ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n@@ -190,7 +190,7 @@ crate struct CrateRoot<'tcx> {\n     lang_items: Lazy<[(DefIndex, usize)]>,\n     lang_items_missing: Lazy<[lang_items::LangItem]>,\n     diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n-    native_libraries: Lazy<[NativeLibrary]>,\n+    native_libraries: Lazy<[NativeLib]>,\n     foreign_modules: Lazy<[ForeignModule]>,\n     source_map: Lazy<[rustc_span::SourceFile]>,\n     def_path_table: Lazy<rustc_hir::definitions::DefPathTable>,"}, {"sha": "0c22672d5fb7d90fb20371b9054519012cad23a9", "filename": "src/librustc_middle/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-arena = { path = \"../libarena\" }\n+rustc_arena = { path = \"../librustc_arena\" }\n bitflags = \"1.2.1\"\n scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n@@ -26,7 +26,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_query_system = { path = \"../librustc_query_system\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_index = { path = \"../librustc_index\" }\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n byteorder = { version = \"1.3\" }"}, {"sha": "75228350c6c450888ba81d376f5d775851bafe46", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -61,7 +61,7 @@ macro_rules! arena_types {\n             [few] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels,\n             [few] foreign_module: rustc_middle::middle::cstore::ForeignModule,\n             [few] foreign_modules: Vec<rustc_middle::middle::cstore::ForeignModule>,\n-            [] upvars: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n+            [] upvars_mentioned: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n             [] object_safety_violations: rustc_middle::traits::ObjectSafetyViolation,\n             [] codegen_unit: rustc_middle::mir::mono::CodegenUnit<$tcx>,\n             [] attribute: rustc_ast::ast::Attribute,\n@@ -76,8 +76,16 @@ macro_rules! arena_types {\n             [few] hir_definitions: rustc_hir::definitions::Definitions,\n             [] hir_owner: rustc_middle::hir::Owner<$tcx>,\n             [] hir_owner_nodes: rustc_middle::hir::OwnerNodes<$tcx>,\n+\n+            // Note that this deliberately duplicates items in the `rustc_hir::arena`,\n+            // since we need to allocate this type on both the `rustc_hir` arena\n+            // (during lowering) and the `librustc_middle` arena (for decoding MIR)\n+            [decode] asm_template: rustc_ast::ast::InlineAsmTemplatePiece,\n+\n+            // This is used to decode the &'tcx [Span] for InlineAsm's line_spans.\n+            [decode] span: rustc_span::Span,\n         ], $tcx);\n     )\n }\n \n-arena_types!(arena::declare_arena, [], 'tcx);\n+arena_types!(rustc_arena::declare_arena, [], 'tcx);"}, {"sha": "2c0524fa9910212c0b6f425fbee24bd149883c27", "filename": "src/librustc_middle/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -49,7 +49,6 @@\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n \n-use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n use crate::traits;\n use crate::traits::query::{"}, {"sha": "af48c9e94ff82a0167a8478ab18200311a7d22af", "filename": "src/librustc_middle/hir/exports.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fhir%2Fexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fhir%2Fexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fexports.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,7 +1,8 @@\n use crate::ty;\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::Res;\n-use rustc_hir::def_id::DefIdMap;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_macros::HashStable;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n@@ -10,7 +11,7 @@ use std::fmt::Debug;\n \n /// This is the replacement export map. It maps a module to all of the exports\n /// within.\n-pub type ExportMap<Id> = DefIdMap<Vec<Export<Id>>>;\n+pub type ExportMap<Id> = FxHashMap<LocalDefId, Vec<Export<Id>>>;\n \n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Export<Id> {"}, {"sha": "53e88787323f4c9e16f472f9928f70132ad7b49b", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -3,7 +3,7 @@ use self::collector::NodeCollector;\n use crate::hir::{Owner, OwnerNodes};\n use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n-use rustc_ast::ast::{self, NodeId};\n+use rustc_ast::ast::{self};\n use rustc_data_structures::svh::Svh;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -157,19 +157,6 @@ impl<'hir> Map<'hir> {\n         self.tcx.definitions.def_path(def_id)\n     }\n \n-    #[inline]\n-    pub fn local_def_id_from_node_id(&self, node: NodeId) -> LocalDefId {\n-        self.opt_local_def_id_from_node_id(node).unwrap_or_else(|| {\n-            let hir_id = self.node_id_to_hir_id(node);\n-            bug!(\n-                \"local_def_id_from_node_id: no entry for `{}`, which has a map of `{:?}`\",\n-                node,\n-                self.find_entry(hir_id)\n-            )\n-        })\n-    }\n-\n-    // FIXME(eddyb) this function can and should return `LocalDefId`.\n     #[inline]\n     pub fn local_def_id(&self, hir_id: HirId) -> LocalDefId {\n         self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n@@ -183,40 +170,14 @@ impl<'hir> Map<'hir> {\n \n     #[inline]\n     pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<LocalDefId> {\n-        let node_id = self.hir_id_to_node_id(hir_id);\n-        self.opt_local_def_id_from_node_id(node_id)\n-    }\n-\n-    #[inline]\n-    pub fn opt_local_def_id_from_node_id(&self, node: NodeId) -> Option<LocalDefId> {\n-        self.tcx.definitions.opt_local_def_id(node)\n-    }\n-\n-    #[inline]\n-    pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n-        self.tcx.definitions.as_local_node_id(def_id)\n+        self.tcx.definitions.opt_hir_id_to_local_def_id(hir_id)\n     }\n \n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: LocalDefId) -> HirId {\n         self.tcx.definitions.as_local_hir_id(def_id)\n     }\n \n-    #[inline]\n-    pub fn hir_id_to_node_id(&self, hir_id: HirId) -> NodeId {\n-        self.tcx.definitions.hir_id_to_node_id(hir_id)\n-    }\n-\n-    #[inline]\n-    pub fn node_id_to_hir_id(&self, node_id: NodeId) -> HirId {\n-        self.tcx.definitions.node_id_to_hir_id(node_id)\n-    }\n-\n-    #[inline]\n-    pub fn opt_node_id_to_hir_id(&self, node_id: NodeId) -> Option<HirId> {\n-        self.tcx.definitions.opt_node_id_to_hir_id(node_id)\n-    }\n-\n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n         self.tcx.definitions.local_def_id_to_hir_id(def_id)"}, {"sha": "ef6247881c0be12995dba134bf176f38d38046ff", "filename": "src/librustc_middle/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -87,9 +87,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n                 index.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n-            ty::ReScope(scope) => {\n-                scope.hash_stable(hcx, hasher);\n-            }\n             ty::ReFree(ref free_region) => {\n                 free_region.hash_stable(hcx, hasher);\n             }"}, {"sha": "97e877df96663956e1db36d22c8c0e75672d9657", "filename": "src/librustc_middle/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -2,8 +2,6 @@\n //! are *mostly* used as a part of that interface, but these should\n //! probably get a better home if someone can find one.\n \n-pub use self::NativeLibraryKind::*;\n-\n use crate::ty::TyCtxt;\n \n use rustc_ast::ast;\n@@ -14,7 +12,7 @@ use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash, DefPathTable};\n use rustc_macros::HashStable;\n use rustc_session::search_paths::PathKind;\n-pub use rustc_session::utils::NativeLibraryKind;\n+use rustc_session::utils::NativeLibKind;\n use rustc_session::CrateDisambiguator;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -89,8 +87,8 @@ pub enum LinkagePreference {\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct NativeLibrary {\n-    pub kind: NativeLibraryKind,\n+pub struct NativeLib {\n+    pub kind: NativeLibKind,\n     pub name: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n     pub foreign_module: Option<DefId>,"}, {"sha": "85198482bd380a4b32c49aabb7d2ea1711e9b5eb", "filename": "src/librustc_middle/middle/limits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -7,8 +7,8 @@\n \n use crate::bug;\n use rustc_ast::ast;\n-use rustc_data_structures::sync::Once;\n-use rustc_session::Session;\n+use rustc_data_structures::sync::OnceCell;\n+use rustc_session::{Limit, Session};\n use rustc_span::symbol::{sym, Symbol};\n \n use std::num::IntErrorKind;\n@@ -22,7 +22,7 @@ pub fn update_limits(sess: &Session, krate: &ast::Crate) {\n fn update_limit(\n     sess: &Session,\n     krate: &ast::Crate,\n-    limit: &Once<usize>,\n+    limit: &OnceCell<Limit>,\n     name: Symbol,\n     default: usize,\n ) {\n@@ -34,7 +34,7 @@ fn update_limit(\n         if let Some(s) = attr.value_str() {\n             match s.as_str().parse() {\n                 Ok(n) => {\n-                    limit.set(n);\n+                    limit.set(Limit::new(n)).unwrap();\n                     return;\n                 }\n                 Err(e) => {\n@@ -62,5 +62,5 @@ fn update_limit(\n             }\n         }\n     }\n-    limit.set(default);\n+    limit.set(Limit::new(default)).unwrap();\n }"}, {"sha": "943a065a8b5e8ef0fed990a8e4bd799bb8fd2eee", "filename": "src/librustc_middle/middle/region.rs", "status": "modified", "additions": 2, "deletions": 158, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -7,7 +7,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/borrow_check.html\n \n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n-use crate::ty::{self, DefIdTree, TyCtxt};\n+use crate::ty::TyCtxt;\n use rustc_hir as hir;\n use rustc_hir::Node;\n \n@@ -333,7 +333,7 @@ pub struct YieldData {\n     pub source: hir::YieldSource,\n }\n \n-impl<'tcx> ScopeTree {\n+impl ScopeTree {\n     pub fn record_scope_parent(&mut self, child: Scope, parent: Option<(Scope, ScopeDepth)>) {\n         debug!(\"{:?}.parent = {:?}\", child, parent);\n \n@@ -348,24 +348,6 @@ impl<'tcx> ScopeTree {\n         }\n     }\n \n-    pub fn each_encl_scope<E>(&self, mut e: E)\n-    where\n-        E: FnMut(Scope, Scope),\n-    {\n-        for (&child, &parent) in &self.parent_map {\n-            e(child, parent.0)\n-        }\n-    }\n-\n-    pub fn each_var_scope<E>(&self, mut e: E)\n-    where\n-        E: FnMut(&hir::ItemLocalId, Scope),\n-    {\n-        for (child, &parent) in self.var_map.iter() {\n-            e(child, parent)\n-        }\n-    }\n-\n     pub fn opt_destruction_scope(&self, n: hir::ItemLocalId) -> Option<Scope> {\n         self.destruction_scopes.get(&n).cloned()\n     }\n@@ -406,12 +388,6 @@ impl<'tcx> ScopeTree {\n         self.parent_map.get(&id).cloned().map(|(p, _)| p)\n     }\n \n-    /// Returns the narrowest scope that encloses `id`, if any.\n-    #[allow(dead_code)] // used in cfg\n-    pub fn encl_scope(&self, id: Scope) -> Scope {\n-        self.opt_encl_scope(id).unwrap()\n-    }\n-\n     /// Returns the lifetime of the local variable `var_id`\n     pub fn var_scope(&self, var_id: hir::ItemLocalId) -> Scope {\n         self.var_map\n@@ -448,17 +424,6 @@ impl<'tcx> ScopeTree {\n         None\n     }\n \n-    /// Returns the lifetime of the variable `id`.\n-    pub fn var_region(&self, id: hir::ItemLocalId) -> ty::RegionKind {\n-        let scope = ty::ReScope(self.var_scope(id));\n-        debug!(\"var_region({:?}) = {:?}\", id, scope);\n-        scope\n-    }\n-\n-    pub fn scopes_intersect(&self, scope1: Scope, scope2: Scope) -> bool {\n-        self.is_subscope_of(scope1, scope2) || self.is_subscope_of(scope2, scope1)\n-    }\n-\n     /// Returns `true` if `subscope` is equal to or is lexically nested inside `superscope`, and\n     /// `false` otherwise.\n     pub fn is_subscope_of(&self, subscope: Scope, superscope: Scope) -> bool {\n@@ -479,127 +444,6 @@ impl<'tcx> ScopeTree {\n         true\n     }\n \n-    /// Returns the ID of the innermost containing body.\n-    pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n-        loop {\n-            if let ScopeData::CallSite = scope.data {\n-                return Some(scope.item_local_id());\n-            }\n-\n-            scope = self.opt_encl_scope(scope)?;\n-        }\n-    }\n-\n-    /// Finds the nearest common ancestor of two scopes. That is, finds the\n-    /// smallest scope which is greater than or equal to both `scope_a` and\n-    /// `scope_b`.\n-    pub fn nearest_common_ancestor(&self, scope_a: Scope, scope_b: Scope) -> Scope {\n-        if scope_a == scope_b {\n-            return scope_a;\n-        }\n-\n-        let mut a = scope_a;\n-        let mut b = scope_b;\n-\n-        // Get the depth of each scope's parent. If either scope has no parent,\n-        // it must be the root, which means we can stop immediately because the\n-        // root must be the nearest common ancestor. (In practice, this is\n-        // moderately common.)\n-        let (parent_a, parent_a_depth) = match self.parent_map.get(&a) {\n-            Some(pd) => *pd,\n-            None => return a,\n-        };\n-        let (parent_b, parent_b_depth) = match self.parent_map.get(&b) {\n-            Some(pd) => *pd,\n-            None => return b,\n-        };\n-\n-        if parent_a_depth > parent_b_depth {\n-            // `a` is lower than `b`. Move `a` up until it's at the same depth\n-            // as `b`. The first move up is trivial because we already found\n-            // `parent_a` above; the loop does the remaining N-1 moves.\n-            a = parent_a;\n-            for _ in 0..(parent_a_depth - parent_b_depth - 1) {\n-                a = self.parent_map.get(&a).unwrap().0;\n-            }\n-        } else if parent_b_depth > parent_a_depth {\n-            // `b` is lower than `a`.\n-            b = parent_b;\n-            for _ in 0..(parent_b_depth - parent_a_depth - 1) {\n-                b = self.parent_map.get(&b).unwrap().0;\n-            }\n-        } else {\n-            // Both scopes are at the same depth, and we know they're not equal\n-            // because that case was tested for at the top of this function. So\n-            // we can trivially move them both up one level now.\n-            assert!(parent_a_depth != 0);\n-            a = parent_a;\n-            b = parent_b;\n-        }\n-\n-        // Now both scopes are at the same level. We move upwards in lockstep\n-        // until they match. In practice, this loop is almost always executed\n-        // zero times because `a` is almost always a direct ancestor of `b` or\n-        // vice versa.\n-        while a != b {\n-            a = self.parent_map.get(&a).unwrap().0;\n-            b = self.parent_map.get(&b).unwrap().0;\n-        }\n-\n-        a\n-    }\n-\n-    /// Assuming that the provided region was defined within this `ScopeTree`,\n-    /// returns the outermost `Scope` that the region outlives.\n-    pub fn early_free_scope(&self, tcx: TyCtxt<'tcx>, br: &ty::EarlyBoundRegion) -> Scope {\n-        let param_owner = tcx.parent(br.def_id).unwrap();\n-\n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local());\n-        let scope = tcx\n-            .hir()\n-            .maybe_body_owned_by(param_owner_id)\n-            .map(|body_id| tcx.hir().body(body_id).value.hir_id.local_id)\n-            .unwrap_or_else(|| {\n-                // The lifetime was defined on node that doesn't own a body,\n-                // which in practice can only mean a trait or an impl, that\n-                // is the parent of a method, and that is enforced below.\n-                if Some(param_owner_id) != self.root_parent {\n-                    tcx.sess.delay_span_bug(\n-                        DUMMY_SP,\n-                        &format!(\n-                            \"free_scope: {:?} not recognized by the \\\n-                              region scope tree for {:?} / {:?}\",\n-                            param_owner,\n-                            self.root_parent.map(|id| tcx.hir().local_def_id(id)),\n-                            self.root_body.map(|hir_id| hir_id.owner)\n-                        ),\n-                    );\n-                }\n-\n-                // The trait/impl lifetime is in scope for the method's body.\n-                self.root_body.unwrap().local_id\n-            });\n-\n-        Scope { id: scope, data: ScopeData::CallSite }\n-    }\n-\n-    /// Assuming that the provided region was defined within this `ScopeTree`,\n-    /// returns the outermost `Scope` that the region outlives.\n-    pub fn free_scope(&self, tcx: TyCtxt<'tcx>, fr: &ty::FreeRegion) -> Scope {\n-        let param_owner = match fr.bound_region {\n-            ty::BoundRegion::BrNamed(def_id, _) => tcx.parent(def_id).unwrap(),\n-            _ => fr.scope,\n-        };\n-\n-        // Ensure that the named late-bound lifetimes were defined\n-        // on the same function that they ended up being freed in.\n-        assert_eq!(param_owner, fr.scope);\n-\n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local());\n-        let body_id = tcx.hir().body_owned_by(param_owner_id);\n-        Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n-    }\n-\n     /// Checks whether the given scope contains a `yield`. If so,\n     /// returns `Some((span, expr_count))` with the span of a yield we found and\n     /// the number of expressions and patterns appearing before the `yield` in the body + 1."}, {"sha": "96195db0bacd227aecb090741694413dadf3d798", "filename": "src/librustc_middle/mir/interpret/allocation.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -11,6 +11,7 @@ use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n     read_target_uint, write_target_uint, AllocId, InterpResult, Pointer, Scalar, ScalarMaybeUninit,\n+    UninitBytesAccess,\n };\n \n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n@@ -545,17 +546,23 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Checks whether the given range  is entirely defined.\n     ///\n-    /// Returns `Ok(())` if it's defined. Otherwise returns the index of the byte\n-    /// at which the first undefined access begins.\n-    fn is_defined(&self, ptr: Pointer<Tag>, size: Size) -> Result<(), Size> {\n+    /// Returns `Ok(())` if it's defined. Otherwise returns the range of byte\n+    /// indexes of the first contiguous undefined access.\n+    fn is_defined(&self, ptr: Pointer<Tag>, size: Size) -> Result<(), Range<Size>> {\n         self.init_mask.is_range_initialized(ptr.offset, ptr.offset + size) // `Size` addition\n     }\n \n-    /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n-    /// error which will report the first byte which is undefined.\n+    /// Checks that a range of bytes is defined. If not, returns the `InvalidUndefBytes`\n+    /// error which will report the first range of bytes which is undefined.\n     fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n-        self.is_defined(ptr, size)\n-            .or_else(|idx| throw_ub!(InvalidUninitBytes(Some(Pointer::new(ptr.alloc_id, idx)))))\n+        self.is_defined(ptr, size).or_else(|idx_range| {\n+            throw_ub!(InvalidUninitBytes(Some(Box::new(UninitBytesAccess {\n+                access_ptr: ptr.erase_tag(),\n+                access_size: size,\n+                uninit_ptr: Pointer::new(ptr.alloc_id, idx_range.start),\n+                uninit_size: idx_range.end - idx_range.start, // `Size` subtraction\n+            }))))\n+        })\n     }\n \n     pub fn mark_definedness(&mut self, ptr: Pointer<Tag>, size: Size, new_state: bool) {\n@@ -758,19 +765,25 @@ impl InitMask {\n \n     /// Checks whether the range `start..end` (end-exclusive) is entirely initialized.\n     ///\n-    /// Returns `Ok(())` if it's initialized. Otherwise returns the index of the byte\n-    /// at which the first uninitialized access begins.\n+    /// Returns `Ok(())` if it's initialized. Otherwise returns a range of byte\n+    /// indexes for the first contiguous span of the uninitialized access.\n     #[inline]\n-    pub fn is_range_initialized(&self, start: Size, end: Size) -> Result<(), Size> {\n+    pub fn is_range_initialized(&self, start: Size, end: Size) -> Result<(), Range<Size>> {\n         if end > self.len {\n-            return Err(self.len);\n+            return Err(self.len..end);\n         }\n \n         // FIXME(oli-obk): optimize this for allocations larger than a block.\n         let idx = (start.bytes()..end.bytes()).map(Size::from_bytes).find(|&i| !self.get(i));\n \n         match idx {\n-            Some(idx) => Err(idx),\n+            Some(idx) => {\n+                let undef_end = (idx.bytes()..end.bytes())\n+                    .map(Size::from_bytes)\n+                    .find(|&i| self.get(i))\n+                    .unwrap_or(end);\n+                Err(idx..undef_end)\n+            }\n             None => Ok(()),\n         }\n     }"}, {"sha": "1b3ede40f023a002b98182f4f07364035c1fecc0", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,12 +1,12 @@\n-use super::{AllocId, Pointer, RawConst, ScalarMaybeUninit};\n+use super::{AllocId, Pointer, RawConst, Scalar};\n \n use crate::mir::interpret::ConstValue;\n use crate::ty::layout::LayoutError;\n use crate::ty::query::TyCtxtAt;\n use crate::ty::{self, layout, tls, FnSig, Ty};\n \n use rustc_data_structures::sync::Lock;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorReported};\n+use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::definitions::DefPathData;\n use rustc_macros::HashStable;\n@@ -327,6 +327,19 @@ impl fmt::Display for CheckInAllocMsg {\n     }\n }\n \n+/// Details of an access to uninitialized bytes where it is not allowed.\n+#[derive(Debug)]\n+pub struct UninitBytesAccess {\n+    /// Location of the original memory access.\n+    pub access_ptr: Pointer,\n+    /// Size of the original memory access.\n+    pub access_size: Size,\n+    /// Location of the first uninitialized byte that was accessed.\n+    pub uninit_ptr: Pointer,\n+    /// Number of consecutive uninitialized bytes that were accessed.\n+    pub uninit_size: Size,\n+}\n+\n /// Error information for when the program caused Undefined Behavior.\n pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n@@ -378,13 +391,13 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Using a non-character `u32` as character.\n     InvalidChar(u32),\n     /// An enum discriminant was set to a value which was outside the range of valid values.\n-    InvalidDiscriminant(ScalarMaybeUninit),\n+    InvalidDiscriminant(Scalar),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n     /// Using a string that is not valid UTF-8,\n     InvalidStr(std::str::Utf8Error),\n     /// Using uninitialized data where it is not allowed.\n-    InvalidUninitBytes(Option<Pointer>),\n+    InvalidUninitBytes(Option<Box<UninitBytesAccess>>),\n     /// Working with a local that is not currently live.\n     DeadLocal,\n     /// Data size is not equal to target size.\n@@ -455,10 +468,18 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n                 write!(f, \"using {} as function pointer but it does not point to a function\", p)\n             }\n             InvalidStr(err) => write!(f, \"this string is not valid UTF-8: {}\", err),\n-            InvalidUninitBytes(Some(p)) => write!(\n+            InvalidUninitBytes(Some(access)) => write!(\n                 f,\n-                \"reading uninitialized memory at {}, but this operation requires initialized memory\",\n-                p\n+                \"reading {} byte{} of memory starting at {}, \\\n+                 but {} byte{} {} uninitialized starting at {}, \\\n+                 and this operation requires initialized memory\",\n+                access.access_size.bytes(),\n+                pluralize!(access.access_size.bytes()),\n+                access.access_ptr,\n+                access.uninit_size.bytes(),\n+                pluralize!(access.uninit_size.bytes()),\n+                if access.uninit_size.bytes() != 1 { \"are\" } else { \"is\" },\n+                access.uninit_ptr,\n             ),\n             InvalidUninitBytes(None) => write!(\n                 f,\n@@ -492,6 +513,8 @@ pub enum UnsupportedOpInfo {\n     //\n     /// Encountered raw bytes where we needed a pointer.\n     ReadBytesAsPointer,\n+    /// Accessing thread local statics\n+    ThreadLocalStatic(DefId),\n }\n \n impl fmt::Display for UnsupportedOpInfo {\n@@ -500,11 +523,12 @@ impl fmt::Display for UnsupportedOpInfo {\n         match self {\n             Unsupported(ref msg) => write!(f, \"{}\", msg),\n             ReadForeignStatic(did) => {\n-                write!(f, \"cannot read from foreign (extern) static {:?}\", did)\n+                write!(f, \"cannot read from foreign (extern) static ({:?})\", did)\n             }\n             NoMirFor(did) => write!(f, \"no MIR body is available for {:?}\", did),\n             ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\",),\n             ReadBytesAsPointer => write!(f, \"unable to turn bytes into a pointer\"),\n+            ThreadLocalStatic(did) => write!(f, \"cannot access thread local static ({:?})\", did),\n         }\n     }\n }\n@@ -556,6 +580,9 @@ impl dyn MachineStopType {\n     }\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(InterpError<'_>, 40);\n+\n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior.\n     UndefinedBehavior(UndefinedBehaviorInfo<'tcx>),\n@@ -604,7 +631,10 @@ impl InterpError<'_> {\n             InterpError::MachineStop(b) => mem::size_of_val::<dyn MachineStopType>(&**b) > 0,\n             InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::ValidationFailure(_))\n-            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_)) => true,\n+            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n+            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some(_))) => {\n+                true\n+            }\n             _ => false,\n         }\n     }"}, {"sha": "5e57b60894a588d07cc29561c057131e919508de", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -119,7 +119,7 @@ use crate::ty::{self, Instance, Ty, TyCtxt};\n pub use self::error::{\n     struct_error, CheckInAllocMsg, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled,\n     FrameInfo, InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n-    ResourceExhaustionInfo, UndefinedBehaviorInfo, UnsupportedOpInfo,\n+    ResourceExhaustionInfo, UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUninit};\n@@ -209,6 +209,7 @@ pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n             fn_instance.encode(encoder)?;\n         }\n         GlobalAlloc::Static(did) => {\n+            assert!(!tcx.is_thread_local_static(did));\n             // References to statics doesn't need to know about their allocations,\n             // just about its `DefId`.\n             AllocDiscriminant::Static.encode(encoder)?;\n@@ -598,3 +599,12 @@ pub fn truncate(value: u128, size: Size) -> u128 {\n     // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n     (value << shift) >> shift\n }\n+\n+/// Computes the unsigned absolute value without wrapping or panicking.\n+#[inline]\n+pub fn uabs(value: i64) -> u64 {\n+    // The only tricky part here is if value == i64::MIN. In that case,\n+    // wrapping_abs() returns i64::MIN == -2^63. Casting this value to a u64\n+    // gives 2^63, the correct value.\n+    value.wrapping_abs() as u64\n+}"}, {"sha": "ccad4f0a135a16d3557c7d5603b6222d39149709", "filename": "src/librustc_middle/mir/interpret/pointer.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,4 +1,4 @@\n-use super::{AllocId, InterpResult};\n+use super::{uabs, AllocId, InterpResult};\n \n use rustc_macros::HashStable;\n use rustc_target::abi::{HasDataLayout, Size};\n@@ -24,6 +24,12 @@ pub trait PointerArithmetic: HasDataLayout {\n         u64::try_from(max_usize_plus_1 - 1).unwrap()\n     }\n \n+    #[inline]\n+    fn machine_isize_min(&self) -> i64 {\n+        let max_isize_plus_1 = 1i128 << (self.pointer_size().bits() - 1);\n+        i64::try_from(-max_isize_plus_1).unwrap()\n+    }\n+\n     #[inline]\n     fn machine_isize_max(&self) -> i64 {\n         let max_isize_plus_1 = 1u128 << (self.pointer_size().bits() - 1);\n@@ -42,21 +48,23 @@ pub trait PointerArithmetic: HasDataLayout {\n \n     #[inline]\n     fn overflowing_offset(&self, val: u64, i: u64) -> (u64, bool) {\n+        // We do not need to check if i fits in a machine usize. If it doesn't,\n+        // either the wrapping_add will wrap or res will not fit in a pointer.\n         let res = val.overflowing_add(i);\n         self.truncate_to_ptr(res)\n     }\n \n     #[inline]\n     fn overflowing_signed_offset(&self, val: u64, i: i64) -> (u64, bool) {\n-        if i < 0 {\n-            // Trickery to ensure that `i64::MIN` works fine: compute `n = -i`.\n-            // This formula only works for true negative values; it overflows for zero!\n-            let n = u64::MAX - (i as u64) + 1;\n-            let res = val.overflowing_sub(n);\n-            self.truncate_to_ptr(res)\n+        // We need to make sure that i fits in a machine isize.\n+        let n = uabs(i);\n+        if i >= 0 {\n+            let (val, over) = self.overflowing_offset(val, n);\n+            (val, over || i > self.machine_isize_max())\n         } else {\n-            // `i >= 0`, so the cast is safe.\n-            self.overflowing_offset(val, i as u64)\n+            let res = val.overflowing_sub(n);\n+            let (val, over) = self.truncate_to_ptr(res);\n+            (val, over || i < self.machine_isize_min())\n         }\n     }\n "}, {"sha": "98973f1b6fb7d889270d3a42f72795fbe04e7d44", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -408,7 +408,7 @@ impl<'tcx> Body<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Safety {\n     Safe,\n     /// Unsafe because of a PushUnsafeBlock\n@@ -1072,7 +1072,8 @@ pub enum TerminatorKind<'tcx> {\n     Abort,\n \n     /// Indicates a normal return. The return place should have\n-    /// been filled in by now. This should occur at most once.\n+    /// been filled in before this executes. This can occur multiple times\n+    /// in different basic blocks.\n     Return,\n \n     /// Indicates a terminator that can never be reached.\n@@ -1159,7 +1160,7 @@ pub enum TerminatorKind<'tcx> {\n \n     /// A block where control flow only ever takes one real path, but borrowck\n     /// needs to be more conservative.\n-    FalseEdges {\n+    FalseEdge {\n         /// The target normal control flow will take.\n         real_target: BasicBlock,\n         /// A block control flow could conceptually jump to, but won't in\n@@ -1193,6 +1194,10 @@ pub enum TerminatorKind<'tcx> {\n         /// Miscellaneous options for the inline assembly.\n         options: InlineAsmOptions,\n \n+        /// Source spans for each line of the inline assembly code. These are\n+        /// used to map assembler errors back to the line in the source code.\n+        line_spans: &'tcx [Span],\n+\n         /// Destination block after the inline assembly returns, unless it is\n         /// diverging (InlineAsmOptions::NORETURN).\n         destination: Option<BasicBlock>,\n@@ -1309,7 +1314,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 Some(t).into_iter().chain(slice::from_ref(u))\n             }\n             SwitchInt { ref targets, .. } => None.into_iter().chain(&targets[..]),\n-            FalseEdges { ref real_target, ref imaginary_target } => {\n+            FalseEdge { ref real_target, ref imaginary_target } => {\n                 Some(real_target).into_iter().chain(slice::from_ref(imaginary_target))\n             }\n         }\n@@ -1343,7 +1348,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 Some(t).into_iter().chain(slice::from_mut(u))\n             }\n             SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets[..]),\n-            FalseEdges { ref mut real_target, ref mut imaginary_target } => {\n+            FalseEdge { ref mut real_target, ref mut imaginary_target } => {\n                 Some(real_target).into_iter().chain(slice::from_mut(imaginary_target))\n             }\n         }\n@@ -1359,7 +1364,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::InlineAsm { .. } => None,\n             TerminatorKind::Call { cleanup: ref unwind, .. }\n             | TerminatorKind::Assert { cleanup: ref unwind, .. }\n@@ -1379,7 +1384,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::InlineAsm { .. } => None,\n             TerminatorKind::Call { cleanup: ref mut unwind, .. }\n             | TerminatorKind::Assert { cleanup: ref mut unwind, .. }\n@@ -1593,9 +1598,9 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 msg.fmt_assert_args(fmt)?;\n                 write!(fmt, \")\")\n             }\n-            FalseEdges { .. } => write!(fmt, \"falseEdges\"),\n+            FalseEdge { .. } => write!(fmt, \"falseEdge\"),\n             FalseUnwind { .. } => write!(fmt, \"falseUnwind\"),\n-            InlineAsm { template, ref operands, options, destination: _ } => {\n+            InlineAsm { template, ref operands, options, .. } => {\n                 write!(fmt, \"asm!(\\\"{}\\\"\", InlineAsmTemplatePiece::to_string(template))?;\n                 for op in operands {\n                     write!(fmt, \", \")?;\n@@ -1678,7 +1683,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             }\n             Assert { cleanup: None, .. } => vec![\"\".into()],\n             Assert { .. } => vec![\"success\".into(), \"unwind\".into()],\n-            FalseEdges { .. } => vec![\"real\".into(), \"imaginary\".into()],\n+            FalseEdge { .. } => vec![\"real\".into(), \"imaginary\".into()],\n             FalseUnwind { unwind: Some(_), .. } => vec![\"real\".into(), \"cleanup\".into()],\n             FalseUnwind { unwind: None, .. } => vec![\"real\".into()],\n             InlineAsm { destination: Some(_), .. } => vec![\"\".into()],\n@@ -2077,10 +2082,10 @@ impl Debug for Place<'_> {\n                 ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n                     write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n                 }\n-                ProjectionElem::Subslice { from, to, from_end: true } if *to == 0 => {\n+                ProjectionElem::Subslice { from, to, from_end: true } if to == 0 => {\n                     write!(fmt, \"[{:?}:]\", from)?;\n                 }\n-                ProjectionElem::Subslice { from, to, from_end: true } if *from == 0 => {\n+                ProjectionElem::Subslice { from, to, from_end: true } if from == 0 => {\n                     write!(fmt, \"[:-{:?}]\", to)?;\n                 }\n                 ProjectionElem::Subslice { from, to, from_end: true } => {\n@@ -2209,6 +2214,11 @@ pub enum Rvalue<'tcx> {\n     /// &x or &mut x\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n \n+    /// Accessing a thread local static. This is inherently a runtime operation, even if llvm\n+    /// treats it as an access to a static. This `Rvalue` yields a reference to the thread local\n+    /// static.\n+    ThreadLocalRef(DefId),\n+\n     /// Create a raw pointer to the given place\n     /// Can be generated by raw address of expressions (`&raw const x`),\n     /// or when casting a reference to a raw pointer.\n@@ -2348,6 +2358,10 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n             Discriminant(ref place) => write!(fmt, \"discriminant({:?})\", place),\n             NullaryOp(ref op, ref t) => write!(fmt, \"{:?}({:?})\", op, t),\n+            ThreadLocalRef(did) => ty::tls::with(|tcx| {\n+                let muta = tcx.static_mutability(did).unwrap().prefix_str();\n+                write!(fmt, \"&/*tls*/ {}{}\", muta, tcx.def_path_str(did))\n+            }),\n             Ref(region, borrow_kind, ref place) => {\n                 let kind_str = match borrow_kind {\n                     BorrowKind::Shared => \"\",\n@@ -2439,7 +2453,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            if let Some(upvars) = tcx.upvars(def_id) {\n+                            if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n                                 for (&var_id, place) in upvars.keys().zip(places) {\n                                     let var_name = tcx.hir().name(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);\n@@ -2458,7 +2472,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let name = format!(\"[generator@{:?}]\", tcx.hir().span(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            if let Some(upvars) = tcx.upvars(def_id) {\n+                            if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n                                 for (&var_id, place) in upvars.keys().zip(places) {\n                                     let var_name = tcx.hir().name(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);\n@@ -2501,7 +2515,10 @@ impl Constant<'tcx> {\n     pub fn check_static_ptr(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n         match self.literal.val.try_to_scalar() {\n             Some(Scalar::Ptr(ptr)) => match tcx.global_alloc(ptr.alloc_id) {\n-                GlobalAlloc::Static(def_id) => Some(def_id),\n+                GlobalAlloc::Static(def_id) => {\n+                    assert!(!tcx.is_thread_local_static(def_id));\n+                    Some(def_id)\n+                }\n                 _ => None,\n             },\n             _ => None,"}, {"sha": "7508c0239397f6fe2d96d82bb2c1842511ea0f6a", "filename": "src/librustc_middle/mir/predecessors.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,7 +1,7 @@\n //! Lazily compute the reverse control-flow graph for the MIR.\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_data_structures::sync::OnceCell;\n use rustc_index::vec::IndexVec;\n use rustc_serialize as serialize;\n use smallvec::SmallVec;\n@@ -13,37 +13,33 @@ pub type Predecessors = IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>;\n \n #[derive(Clone, Debug)]\n pub(super) struct PredecessorCache {\n-    cache: Lock<Option<Lrc<Predecessors>>>,\n+    cache: OnceCell<Predecessors>,\n }\n \n impl PredecessorCache {\n     #[inline]\n     pub(super) fn new() -> Self {\n-        PredecessorCache { cache: Lock::new(None) }\n+        PredecessorCache { cache: OnceCell::new() }\n     }\n \n     /// Invalidates the predecessor cache.\n-    ///\n-    /// Invalidating the predecessor cache requires mutating the MIR, which in turn requires a\n-    /// unique reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n-    /// callers of `invalidate` have a unique reference to the MIR and thus to the predecessor\n-    /// cache. This means we don't actually need to take a lock when `invalidate` is called.\n     #[inline]\n     pub(super) fn invalidate(&mut self) {\n-        *self.cache.get_mut() = None;\n+        // Invalidating the predecessor cache requires mutating the MIR, which in turn requires a\n+        // unique reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n+        // callers of `invalidate` have a unique reference to the MIR and thus to the predecessor\n+        // cache. This means we never need to do synchronization when `invalidate` is called, we can\n+        // simply reinitialize the `OnceCell`.\n+        self.cache = OnceCell::new();\n     }\n \n-    /// Returns a ref-counted smart pointer containing the predecessor graph for this MIR.\n-    ///\n-    /// We use ref-counting instead of a mapped `LockGuard` here to ensure that the lock for\n-    /// `cache` is only held inside this function. As long as no other locks are taken while\n-    /// computing the predecessor graph, deadlock is impossible.\n+    /// Returns the the predecessor graph for this MIR.\n     #[inline]\n     pub(super) fn compute(\n         &self,\n         basic_blocks: &IndexVec<BasicBlock, BasicBlockData<'_>>,\n-    ) -> Lrc<Predecessors> {\n-        Lrc::clone(self.cache.lock().get_or_insert_with(|| {\n+    ) -> &Predecessors {\n+        self.cache.get_or_init(|| {\n             let mut preds = IndexVec::from_elem(SmallVec::new(), basic_blocks);\n             for (bb, data) in basic_blocks.iter_enumerated() {\n                 if let Some(term) = &data.terminator {\n@@ -53,8 +49,8 @@ impl PredecessorCache {\n                 }\n             }\n \n-            Lrc::new(preds)\n-        }))\n+            preds\n+        })\n     }\n }\n "}, {"sha": "99bfb74c243b47c7742c4d30bd57764d92c0b126", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -15,15 +15,27 @@ use super::{Field, SourceInfo};\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n+    /// Only permitted in regular `fn`s, prohibitted in `const fn`s.\n     General,\n     /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n-    BorrowPacked(hir::HirId),\n+    /// Borrow of packed field.\n+    /// Has to be handled as a lint for backwards compatibility.\n+    BorrowPacked,\n+    /// Unsafe operation in an `unsafe fn` but outside an `unsafe` block.\n+    /// Has to be handled as a lint for backwards compatibility.\n+    /// Should stay gated under `#![feature(unsafe_block_in_unsafe_fn)]`.\n+    UnsafeFn,\n+    /// Borrow of packed field in an `unsafe fn` but outside an `unsafe` block.\n+    /// Has to be handled as a lint for backwards compatibility.\n+    /// Should stay gated under `#![feature(unsafe_block_in_unsafe_fn)]`.\n+    UnsafeFnBorrowPacked,\n }\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n+    pub lint_root: hir::HirId,\n     pub description: Symbol,\n     pub details: Symbol,\n     pub kind: UnsafetyViolationKind,"}, {"sha": "efcd41e5c188dcfcb9e4fd3172b4860ff683758b", "filename": "src/librustc_middle/mir/tcx.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftcx.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -5,7 +5,6 @@\n \n use crate::mir::*;\n use crate::ty::subst::Subst;\n-use crate::ty::util::IntTypeExt;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n use rustc_target::abi::VariantIdx;\n@@ -56,8 +55,8 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// Convenience wrapper around `projection_ty_core` for\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n-    pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: &PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n-        self.projection_ty_core(tcx, ty::ParamEnv::empty(), elem, |_, _, ty| ty)\n+    pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n+        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, ty| ty)\n     }\n \n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n@@ -124,7 +123,7 @@ impl<'tcx> Place<'tcx> {\n     {\n         projection\n             .iter()\n-            .fold(PlaceTy::from_ty(local_decls.local_decls()[local].ty), |place_ty, elem| {\n+            .fold(PlaceTy::from_ty(local_decls.local_decls()[local].ty), |place_ty, &elem| {\n                 place_ty.projection_ty(tcx, elem)\n             })\n     }\n@@ -152,6 +151,13 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::Repeat(ref operand, count) => {\n                 tcx.mk_ty(ty::Array(operand.ty(local_decls, tcx), count))\n             }\n+            Rvalue::ThreadLocalRef(did) => {\n+                if tcx.is_mutable_static(did) {\n+                    tcx.mk_mut_ptr(tcx.type_of(did))\n+                } else {\n+                    tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.type_of(did))\n+                }\n+            }\n             Rvalue::Ref(reg, bk, ref place) => {\n                 let place_ty = place.ty(local_decls, tcx).ty;\n                 tcx.mk_ref(reg, ty::TypeAndMut { ty: place_ty, mutbl: bk.to_mutbl_lossy() })\n@@ -174,17 +180,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 tcx.intern_tup(&[ty, tcx.types.bool])\n             }\n             Rvalue::UnaryOp(UnOp::Not | UnOp::Neg, ref operand) => operand.ty(local_decls, tcx),\n-            Rvalue::Discriminant(ref place) => {\n-                let ty = place.ty(local_decls, tcx).ty;\n-                match ty.kind {\n-                    ty::Adt(adt_def, _) => adt_def.repr.discr_type().to_ty(tcx),\n-                    ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n-                    _ => {\n-                        // This can only be `0`, for now, so `u8` will suffice.\n-                        tcx.types.u8\n-                    }\n-                }\n-            }\n+            Rvalue::Discriminant(ref place) => place.ty(local_decls, tcx).ty.discriminant_ty(tcx),\n             Rvalue::NullaryOp(NullOp::Box, t) => tcx.mk_box(t),\n             Rvalue::NullaryOp(NullOp::SizeOf, _) => tcx.types.usize,\n             Rvalue::Aggregate(ref ak, ref ops) => match **ak {"}, {"sha": "97c6d6bf5f40b5f3c0845502c977790446bc49eb", "filename": "src/librustc_middle/mir/type_foldable.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -74,13 +74,17 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             Abort => Abort,\n             Return => Return,\n             Unreachable => Unreachable,\n-            FalseEdges { real_target, imaginary_target } => {\n-                FalseEdges { real_target, imaginary_target }\n+            FalseEdge { real_target, imaginary_target } => {\n+                FalseEdge { real_target, imaginary_target }\n             }\n             FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n-            InlineAsm { template, ref operands, options, destination } => {\n-                InlineAsm { template, operands: operands.fold_with(folder), options, destination }\n-            }\n+            InlineAsm { template, ref operands, options, line_spans, destination } => InlineAsm {\n+                template,\n+                operands: operands.fold_with(folder),\n+                options,\n+                line_spans,\n+                destination,\n+            },\n         };\n         Terminator { source_info: self.source_info, kind }\n     }\n@@ -130,7 +134,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             | Return\n             | GeneratorDrop\n             | Unreachable\n-            | FalseEdges { .. }\n+            | FalseEdge { .. }\n             | FalseUnwind { .. } => false,\n         }\n     }\n@@ -173,6 +177,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n         match *self {\n             Use(ref op) => Use(op.fold_with(folder)),\n             Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n+            ThreadLocalRef(did) => ThreadLocalRef(did.fold_with(folder)),\n             Ref(region, bk, ref place) => {\n                 Ref(region.fold_with(folder), bk, place.fold_with(folder))\n             }\n@@ -216,6 +221,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n         match *self {\n             Use(ref op) => op.visit_with(visitor),\n             Repeat(ref op, _) => op.visit_with(visitor),\n+            ThreadLocalRef(did) => did.visit_with(visitor),\n             Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n             AddressOf(_, ref place) => place.visit_with(visitor),\n             Len(ref place) => place.visit_with(visitor),"}, {"sha": "9f886cbc9fb5baf5b2e98d114a2cf1eb2261d9a4", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -429,7 +429,7 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Abort |\n                     TerminatorKind::GeneratorDrop |\n                     TerminatorKind::Unreachable |\n-                    TerminatorKind::FalseEdges { .. } |\n+                    TerminatorKind::FalseEdge { .. } |\n                     TerminatorKind::FalseUnwind { .. } => {\n                     }\n \n@@ -535,6 +535,7 @@ macro_rules! make_mir_visitor {\n                         template: _,\n                         operands,\n                         options: _,\n+                        line_spans: _,\n                         destination: _,\n                     } => {\n                         for op in operands {\n@@ -600,6 +601,8 @@ macro_rules! make_mir_visitor {\n                         self.visit_operand(value, location);\n                     }\n \n+                    Rvalue::ThreadLocalRef(_) => {}\n+\n                     Rvalue::Ref(r, bk, path) => {\n                         self.visit_region(r, location);\n                         let ctx = match bk {\n@@ -903,7 +906,7 @@ macro_rules! visit_place_fns {\n             let mut projection = Cow::Borrowed(projection);\n \n             for i in 0..projection.len() {\n-                if let Some(elem) = projection.get(i) {\n+                if let Some(&elem) = projection.get(i) {\n                     if let Some(elem) = self.process_projection_elem(elem, location) {\n                         // This converts the borrowed projection into `Cow::Owned(_)` and returns a\n                         // clone of the projection so we can mutate and reintern later.\n@@ -921,19 +924,19 @@ macro_rules! visit_place_fns {\n \n         fn process_projection_elem(\n             &mut self,\n-            elem: &PlaceElem<'tcx>,\n+            elem: PlaceElem<'tcx>,\n             location: Location,\n         ) -> Option<PlaceElem<'tcx>> {\n             match elem {\n                 PlaceElem::Index(local) => {\n-                    let mut new_local = *local;\n+                    let mut new_local = local;\n                     self.visit_local(\n                         &mut new_local,\n                         PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                         location,\n                     );\n \n-                    if new_local == *local { None } else { Some(PlaceElem::Index(new_local)) }\n+                    if new_local == local { None } else { Some(PlaceElem::Index(new_local)) }\n                 }\n                 PlaceElem::Deref\n                 | PlaceElem::Field(..)\n@@ -959,7 +962,7 @@ macro_rules! visit_place_fns {\n             &mut self,\n             local: Local,\n             proj_base: &[PlaceElem<'tcx>],\n-            elem: &PlaceElem<'tcx>,\n+            elem: PlaceElem<'tcx>,\n             context: PlaceContext,\n             location: Location,\n         ) {\n@@ -990,7 +993,7 @@ macro_rules! visit_place_fns {\n             location: Location,\n         ) {\n             let mut cursor = projection;\n-            while let [proj_base @ .., elem] = cursor {\n+            while let &[ref proj_base @ .., elem] = cursor {\n                 cursor = proj_base;\n                 self.visit_projection_elem(local, cursor, elem, context, location);\n             }\n@@ -1000,7 +1003,7 @@ macro_rules! visit_place_fns {\n             &mut self,\n             _local: Local,\n             _proj_base: &[PlaceElem<'tcx>],\n-            elem: &PlaceElem<'tcx>,\n+            elem: PlaceElem<'tcx>,\n             _context: PlaceContext,\n             location: Location,\n         ) {\n@@ -1010,7 +1013,7 @@ macro_rules! visit_place_fns {\n                 }\n                 ProjectionElem::Index(local) => {\n                     self.visit_local(\n-                        local,\n+                        &local,\n                         PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                         location,\n                     );"}, {"sha": "4d7e7882e426c48b48945bf4b2d0c11ddf3e4e17", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 180, "deletions": 78, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,5 +1,4 @@\n use crate::dep_graph::SerializedDepNodeIndex;\n-use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n use crate::traits;\n use crate::traits::query::{\n@@ -8,10 +7,10 @@ use crate::traits::query::{\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n };\n use crate::ty::query::queries;\n-use crate::ty::query::QueryDescription;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n+use rustc_query_system::query::QueryDescription;\n \n use rustc_span::symbol::Symbol;\n use std::borrow::Cow;\n@@ -92,6 +91,7 @@ rustc_queries! {\n \n         /// Records the type of every item.\n         query type_of(key: DefId) -> Ty<'tcx> {\n+            desc { |tcx| \"computing type of `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n \n@@ -103,6 +103,7 @@ rustc_queries! {\n         /// Maps from the `DefId` of an item (trait/struct/enum/fn) to its\n         /// associated generics.\n         query generics_of(key: DefId) -> ty::Generics {\n+            desc { |tcx| \"computing generics of `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n@@ -128,10 +129,11 @@ rustc_queries! {\n         /// to operate over only the actual where-clauses written by the\n         /// user.)\n         query predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n+            desc { |tcx| \"computing predicates of `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n \n-        query native_libraries(_: CrateNum) -> Lrc<Vec<NativeLibrary>> {\n+        query native_libraries(_: CrateNum) -> Lrc<Vec<NativeLib>> {\n             desc { \"looking up the native libraries of a linked crate\" }\n         }\n \n@@ -173,16 +175,17 @@ rustc_queries! {\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(_: LocalDefId) -> Steal<mir::Body<'tcx>> {\n+        query mir_built(key: LocalDefId) -> Steal<mir::Body<'tcx>> {\n             storage(ArenaCacheSelector<'tcx>)\n-            desc { \"building MIR for\" }\n+            desc { |tcx| \"building MIR for `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n         /// Fetch the MIR for a given `DefId` up till the point where it is\n-        /// ready for const evaluation.\n+        /// ready for const qualification.\n         ///\n         /// See the README for the `mir` module for details.\n-        query mir_const(_: DefId) -> Steal<mir::Body<'tcx>> {\n+        query mir_const(key: DefId) -> Steal<mir::Body<'tcx>> {\n+            desc { |tcx| \"processing MIR for `{}`\", tcx.def_path_str(key)  }\n             storage(ArenaCacheSelector<'tcx>)\n             no_hash\n         }\n@@ -200,11 +203,13 @@ rustc_queries! {\n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n         query optimized_mir(key: DefId) -> mir::Body<'tcx> {\n+            desc { |tcx| \"optimizing MIR for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n         }\n \n         query promoted_mir(key: DefId) -> IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+            desc { |tcx| \"optimizing promoted MIR for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n         }\n@@ -238,14 +243,20 @@ rustc_queries! {\n         /// predicates (where-clauses) directly defined on it. This is\n         /// equal to the `explicit_predicates_of` predicates plus the\n         /// `inferred_outlives_of` predicates.\n-        query predicates_defined_on(_: DefId) -> ty::GenericPredicates<'tcx> {}\n+        query predicates_defined_on(key: DefId) -> ty::GenericPredicates<'tcx> {\n+            desc { |tcx| \"computing predicates of `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Returns the predicates written explicitly by the user.\n-        query explicit_predicates_of(_: DefId) -> ty::GenericPredicates<'tcx> {}\n+        query explicit_predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n+            desc { |tcx| \"computing explicit predicates of `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Returns the inferred outlives predicates (e.g., for `struct\n         /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n-        query inferred_outlives_of(_: DefId) -> &'tcx [(ty::Predicate<'tcx>, Span)] {}\n+        query inferred_outlives_of(key: DefId) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+            desc { |tcx| \"computing inferred outlives predicates of `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Maps from the `DefId` of a trait to the list of\n         /// super-predicates. This is a subset of the full list of\n@@ -266,27 +277,34 @@ rustc_queries! {\n             }}\n         }\n \n-        query trait_def(_: DefId) -> ty::TraitDef {\n+        query trait_def(key: DefId) -> ty::TraitDef {\n+            desc { |tcx| \"computing trait definition for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n         }\n-        query adt_def(_: DefId) -> &'tcx ty::AdtDef {\n+        query adt_def(key: DefId) -> &'tcx ty::AdtDef {\n+            desc { |tcx| \"computing ADT definition for `{}`\", tcx.def_path_str(key) }\n+        }\n+        query adt_destructor(key: DefId) -> Option<ty::Destructor> {\n+            desc { |tcx| \"computing `Drop` impl for `{}`\", tcx.def_path_str(key) }\n         }\n-        query adt_destructor(_: DefId) -> Option<ty::Destructor> {}\n \n         // The cycle error here should be reported as an error by `check_representable`.\n         // We consider the type as Sized in the meanwhile to avoid\n         // further errors (done in impl Value for AdtSizedConstraint).\n         // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n         // in case we accidentally otherwise don't emit an error.\n         query adt_sized_constraint(\n-            _: DefId\n+            key: DefId\n         ) -> AdtSizedConstraint<'tcx> {\n+            desc { |tcx| \"computing `Sized` constraints for `{}`\", tcx.def_path_str(key) }\n             cycle_delay_bug\n         }\n \n         query adt_dtorck_constraint(\n-            _: DefId\n-        ) -> Result<DtorckConstraint<'tcx>, NoSolution> {}\n+            key: DefId\n+        ) -> Result<DtorckConstraint<'tcx>, NoSolution> {\n+            desc { |tcx| \"computing drop-check constraints for `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Returns `true` if this is a const fn, use the `is_const_fn` to know whether your crate\n         /// actually sees it as const fn (e.g., the const-fn-ness might be unstable and you might\n@@ -317,18 +335,28 @@ rustc_queries! {\n         /// be removed in the future in favour of some form of check which figures out whether the\n         /// function does not inspect the bits of any of its arguments (so is essentially just a\n         /// constructor function).\n-        query is_promotable_const_fn(_: DefId) -> bool {}\n+        query is_promotable_const_fn(key: DefId) -> bool {\n+            desc { |tcx| \"checking if item is promotable: `{}`\", tcx.def_path_str(key) }\n+        }\n \n-        query const_fn_is_allowed_fn_ptr(_: DefId) -> bool {}\n+        query const_fn_is_allowed_fn_ptr(key: DefId) -> bool {\n+            desc { |tcx| \"checking if const fn allows `fn()` types: `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Returns `true` if this is a foreign item (i.e., linked via `extern { ... }`).\n-        query is_foreign_item(_: DefId) -> bool {}\n+        query is_foreign_item(key: DefId) -> bool {\n+            desc { |tcx| \"checking if `{}` is a foreign item\", tcx.def_path_str(key) }\n+        }\n \n         /// Returns `Some(mutability)` if the node pointed to by `def_id` is a static item.\n-        query static_mutability(_: DefId) -> Option<hir::Mutability> {}\n+        query static_mutability(def_id: DefId) -> Option<hir::Mutability> {\n+            desc { |tcx| \"looking up static mutability of `{}`\", tcx.def_path_str(def_id) }\n+        }\n \n         /// Returns `Some(generator_kind)` if the node pointed to by `def_id` is a generator.\n-        query generator_kind(_: DefId) -> Option<hir::GeneratorKind> {}\n+        query generator_kind(def_id: DefId) -> Option<hir::GeneratorKind> {\n+            desc { |tcx| \"looking up generator kind of `{}`\", tcx.def_path_str(def_id) }\n+        }\n \n         /// Gets a map with the variance of every item; use `item_variance` instead.\n         query crate_variances(_: CrateNum) -> ty::CrateVariancesMap<'tcx> {\n@@ -337,7 +365,9 @@ rustc_queries! {\n         }\n \n         /// Maps from the `DefId` of a type or region parameter to its (inferred) variance.\n-        query variances_of(_: DefId) -> &'tcx [ty::Variance] {}\n+        query variances_of(def_id: DefId) -> &'tcx [ty::Variance] {\n+            desc { |tcx| \"computing the variances of `{}`\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     TypeChecking {\n@@ -351,10 +381,13 @@ rustc_queries! {\n \n     Other {\n         /// Maps from an impl/trait `DefId to a list of the `DefId`s of its items.\n-        query associated_item_def_ids(_: DefId) -> &'tcx [DefId] {}\n+        query associated_item_def_ids(key: DefId) -> &'tcx [DefId] {\n+            desc { |tcx| \"collecting associated items of `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Maps from a trait item to the trait item \"descriptor\".\n-        query associated_item(_: DefId) -> ty::AssocItem {\n+        query associated_item(key: DefId) -> ty::AssocItem {\n+            desc { |tcx| \"computing associated item data for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n         }\n \n@@ -364,17 +397,24 @@ rustc_queries! {\n             desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n         }\n \n-        query impl_trait_ref(_: DefId) -> Option<ty::TraitRef<'tcx>> {}\n-        query impl_polarity(_: DefId) -> ty::ImplPolarity {}\n+        query impl_trait_ref(key: DefId) -> Option<ty::TraitRef<'tcx>> {\n+            desc { |tcx| \"computing trait implemented by `{}`\", tcx.def_path_str(key) }\n+        }\n+        query impl_polarity(key: DefId) -> ty::ImplPolarity {\n+            desc { |tcx| \"computing implementation polarity of `{}`\", tcx.def_path_str(key) }\n+        }\n \n-        query issue33140_self_ty(_: DefId) -> Option<ty::Ty<'tcx>> {}\n+        query issue33140_self_ty(key: DefId) -> Option<ty::Ty<'tcx>> {\n+            desc { |tcx| \"computing Self type wrt issue #33140 `{}`\", tcx.def_path_str(key) }\n+        }\n     }\n \n     TypeChecking {\n         /// Maps a `DefId` of a type to a list of its inherent impls.\n         /// Contains implementations of methods that are inherent to a type.\n         /// Methods in these implementations don't need to be exported.\n-        query inherent_impls(_: DefId) -> &'tcx [DefId] {\n+        query inherent_impls(key: DefId) -> &'tcx [DefId] {\n+            desc { |tcx| \"collecting inherent impls for `{}`\", tcx.def_path_str(key) }\n             eval_always\n         }\n     }\n@@ -387,11 +427,19 @@ rustc_queries! {\n             storage(ArenaCacheSelector<'tcx>)\n         }\n \n-        /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n-        query unsafe_derive_on_repr_packed(_: DefId) -> () {}\n+        /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error.\n+        ///\n+        /// Unsafety checking is executed for each method separately, but we only want\n+        /// to emit this error once per derive. As there are some impls with multiple\n+        /// methods, we use a query for deduplication.\n+        query unsafe_derive_on_repr_packed(key: LocalDefId) -> () {\n+            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        }\n \n-        /// The signature of functions and closures.\n-        query fn_sig(_: DefId) -> ty::PolyFnSig<'tcx> {}\n+        /// The signature of functions.\n+        query fn_sig(key: DefId) -> ty::PolyFnSig<'tcx> {\n+            desc { |tcx| \"computing function signature of `{}`\", tcx.def_path_str(key) }\n+        }\n     }\n \n     Other {\n@@ -443,8 +491,10 @@ rustc_queries! {\n         }\n \n         /// Caches `CoerceUnsized` kinds for impls on custom types.\n-        query coerce_unsized_info(_: DefId)\n-            -> ty::adjustment::CoerceUnsizedInfo {}\n+        query coerce_unsized_info(key: DefId)\n+            -> ty::adjustment::CoerceUnsizedInfo {\n+                desc { |tcx| \"computing CoerceUnsized info for `{}`\", tcx.def_path_str(key) }\n+            }\n     }\n \n     TypeChecking {\n@@ -477,7 +527,9 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query has_typeck_tables(_: DefId) -> bool {}\n+        query has_typeck_tables(def_id: DefId) -> bool {\n+            desc { |tcx| \"checking whether `{}` has a body\", tcx.def_path_str(def_id) }\n+        }\n \n         query coherent_trait(def_id: DefId) -> () {\n             desc { |tcx| \"coherence checking all impls of trait `{}`\", tcx.def_path_str(def_id) }\n@@ -553,13 +605,6 @@ rustc_queries! {\n             }\n         }\n \n-        /// Extracts a field of a (variant of a) const.\n-        query const_field(\n-            key: ty::ParamEnvAnd<'tcx, (&'tcx ty::Const<'tcx>, mir::Field)>\n-        ) -> ConstValue<'tcx> {\n-            desc { \"extract field of const\" }\n-        }\n-\n         /// Destructure a constant ADT or array into its variant index and its\n         /// field values.\n         query destructure_const(\n@@ -581,6 +626,7 @@ rustc_queries! {\n \n     TypeChecking {\n         query check_match(key: DefId) {\n+            desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n \n@@ -602,7 +648,9 @@ rustc_queries! {\n \n         /// Per-body `region::ScopeTree`. The `DefId` should be the owner `DefId` for the body;\n         /// in the case of closures, this will be redirected to the enclosing function.\n-        query region_scope_tree(_: DefId) -> &'tcx region::ScopeTree {}\n+        query region_scope_tree(def_id: DefId) -> &'tcx region::ScopeTree {\n+            desc { |tcx| \"computing drop scopes for `{}`\", tcx.def_path_str(def_id) }\n+        }\n \n         query mir_shims(key: ty::InstanceDef<'tcx>) -> mir::Body<'tcx> {\n             storage(ArenaCacheSelector<'tcx>)\n@@ -617,38 +665,58 @@ rustc_queries! {\n             cache_on_disk_if { true }\n         }\n \n-        query def_kind(_: DefId) -> DefKind {}\n-        query def_span(_: DefId) -> Span {\n+        query def_kind(def_id: DefId) -> DefKind {\n+            desc { |tcx| \"looking up definition kind of `{}`\", tcx.def_path_str(def_id) }\n+        }\n+        query def_span(def_id: DefId) -> Span {\n+            desc { |tcx| \"looking up span for `{}`\", tcx.def_path_str(def_id) }\n             // FIXME(mw): DefSpans are not really inputs since they are derived from\n             // HIR. But at the moment HIR hashing still contains some hacks that allow\n             // to make type debuginfo to be source location independent. Declaring\n             // DefSpan an input makes sure that changes to these are always detected\n             // regardless of HIR hashing.\n             eval_always\n         }\n-        query lookup_stability(_: DefId) -> Option<&'tcx attr::Stability> {}\n-        query lookup_const_stability(_: DefId) -> Option<&'tcx attr::ConstStability> {}\n-        query lookup_deprecation_entry(_: DefId) -> Option<DeprecationEntry> {}\n-        query item_attrs(_: DefId) -> &'tcx [ast::Attribute] {}\n+        query lookup_stability(def_id: DefId) -> Option<&'tcx attr::Stability> {\n+            desc { |tcx| \"looking up stability of `{}`\", tcx.def_path_str(def_id) }\n+        }\n+        query lookup_const_stability(def_id: DefId) -> Option<&'tcx attr::ConstStability> {\n+            desc { |tcx| \"looking up const stability of `{}`\", tcx.def_path_str(def_id) }\n+        }\n+        query lookup_deprecation_entry(def_id: DefId) -> Option<DeprecationEntry> {\n+            desc { |tcx| \"checking whether `{}` is deprecated\", tcx.def_path_str(def_id) }\n+        }\n+        query item_attrs(def_id: DefId) -> &'tcx [ast::Attribute] {\n+            desc { |tcx| \"collecting attributes of `{}`\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     Codegen {\n-        query codegen_fn_attrs(_: DefId) -> CodegenFnAttrs {\n+        query codegen_fn_attrs(def_id: DefId) -> CodegenFnAttrs {\n+            desc { |tcx| \"computing codegen attributes of `{}`\", tcx.def_path_str(def_id) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { true }\n         }\n     }\n \n     Other {\n-        query fn_arg_names(_: DefId) -> &'tcx [Symbol] {}\n+        query fn_arg_names(def_id: DefId) -> &'tcx [Symbol] {\n+            desc { |tcx| \"looking up function parameter names for `{}`\", tcx.def_path_str(def_id) }\n+        }\n         /// Gets the rendered value of the specified constant or associated constant.\n         /// Used by rustdoc.\n-        query rendered_const(_: DefId) -> String {}\n-        query impl_parent(_: DefId) -> Option<DefId> {}\n+        query rendered_const(def_id: DefId) -> String {\n+            desc { |tcx| \"rendering constant intializer of `{}`\", tcx.def_path_str(def_id) }\n+        }\n+        query impl_parent(def_id: DefId) -> Option<DefId> {\n+            desc { |tcx| \"computing specialization parent impl of `{}`\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     TypeChecking {\n-        query trait_of_item(_: DefId) -> Option<DefId> {}\n+        query trait_of_item(def_id: DefId) -> Option<DefId> {\n+            desc { |tcx| \"finding trait defining `{}`\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     Codegen {\n@@ -667,7 +735,7 @@ rustc_queries! {\n     Codegen {\n         query codegen_fulfill_obligation(\n             key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n-        ) -> Result<Vtable<'tcx, ()>, ErrorReported> {\n+        ) -> Result<ImplSource<'tcx, ()>, ErrorReported> {\n             cache_on_disk_if { true }\n             desc { |tcx|\n                 \"checking if `{}` fulfills its obligations\",\n@@ -694,12 +762,14 @@ rustc_queries! {\n         }\n \n         /// Gets the ParameterEnvironment for a given item; this environment\n-        /// will be in \"user-facing\" mode, meaning that it is suitabe for\n+        /// will be in \"user-facing\" mode, meaning that it is suitable for\n         /// type-checking etc, and it does not normalize specializable\n         /// associated types. This is almost always what you want,\n         /// unless you are doing MIR optimizations, in which case you\n         /// might want to use `reveal_all()` method to change modes.\n-        query param_env(_: DefId) -> ty::ParamEnv<'tcx> {}\n+        query param_env(def_id: DefId) -> ty::ParamEnv<'tcx> {\n+            desc { |tcx| \"computing normalized predicates of `{}`\", tcx.def_path_str(def_id) }\n+        }\n \n         /// Trait selection queries. These are best used by invoking `ty.is_copy_modulo_regions()`,\n         /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n@@ -722,7 +792,8 @@ rustc_queries! {\n         /// A list of types where the ADT requires drop if and only if any of\n         /// those types require drop. If the ADT is known to always need drop\n         /// then `Err(AlwaysRequiresDrop)` is returned.\n-        query adt_drop_tys(_: DefId) -> Result<&'tcx ty::List<Ty<'tcx>>, AlwaysRequiresDrop> {\n+        query adt_drop_tys(def_id: DefId) -> Result<&'tcx ty::List<Ty<'tcx>>, AlwaysRequiresDrop> {\n+            desc { |tcx| \"computing when `{}` needs drop\", tcx.def_path_str(def_id) }\n             cache_on_disk_if { true }\n         }\n \n@@ -776,7 +847,7 @@ rustc_queries! {\n             desc { \"query a crate's symbol mangling version\" }\n         }\n \n-        query extern_crate(_: DefId) -> Option<&'tcx ExternCrate> {\n+        query extern_crate(def_id: DefId) -> Option<&'tcx ExternCrate> {\n             eval_always\n             desc { \"getting crate's ExternCrateData\" }\n         }\n@@ -794,25 +865,29 @@ rustc_queries! {\n     }\n \n     Other {\n-        query module_exports(_: DefId) -> Option<&'tcx [Export<hir::HirId>]> {\n+        query module_exports(def_id: LocalDefId) -> Option<&'tcx [Export<LocalDefId>]> {\n+            desc { |tcx| \"looking up items exported by `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n             eval_always\n         }\n     }\n \n     TypeChecking {\n-        query impl_defaultness(_: DefId) -> hir::Defaultness {}\n+        query impl_defaultness(def_id: DefId) -> hir::Defaultness {\n+            desc { |tcx| \"looking up whether `{}` is a default impl\", tcx.def_path_str(def_id) }\n+        }\n \n         query check_item_well_formed(key: LocalDefId) -> () {\n-            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            desc { |tcx| \"checking that `{}` is well-formed\", tcx.def_path_str(key.to_def_id()) }\n         }\n         query check_trait_item_well_formed(key: LocalDefId) -> () {\n-            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            desc { |tcx| \"checking that `{}` is well-formed\", tcx.def_path_str(key.to_def_id()) }\n         }\n         query check_impl_item_well_formed(key: LocalDefId) -> () {\n-            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            desc { |tcx| \"checking that `{}` is well-formed\", tcx.def_path_str(key.to_def_id()) }\n         }\n     }\n \n+\n     Linking {\n         // The `DefId`s of all non-generic functions and statics in the given crate\n         // that can be reached from outside the crate.\n@@ -831,8 +906,15 @@ rustc_queries! {\n             storage(ArenaCacheSelector<'tcx>)\n             desc { \"looking up the exported symbols of a crate\" }\n         }\n-        query is_reachable_non_generic(_: DefId) -> bool {}\n-        query is_unreachable_local_definition(_: DefId) -> bool {}\n+        query is_reachable_non_generic(def_id: DefId) -> bool {\n+            desc { |tcx| \"checking whether `{}` is an exported symbol\", tcx.def_path_str(def_id) }\n+        }\n+        query is_unreachable_local_definition(def_id: DefId) -> bool {\n+            desc { |tcx|\n+                \"checking whether `{}` is reachable from outside the crate\",\n+                tcx.def_path_str(def_id),\n+            }\n+        }\n     }\n \n     Codegen {\n@@ -856,8 +938,13 @@ rustc_queries! {\n         ///\n         /// You likely want to call `Instance::upstream_monomorphization()`\n         /// instead of invoking this query directly.\n-        query upstream_monomorphizations_for(_: DefId)\n-            -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {}\n+        query upstream_monomorphizations_for(def_id: DefId)\n+            -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n+                desc { |tcx|\n+                    \"collecting available upstream monomorphizations for `{}`\",\n+                    tcx.def_path_str(def_id),\n+                }\n+            }\n \n         /// Returns the upstream crate that exports drop-glue for the given\n         /// type (`substs` is expected to be a single-item list containing the\n@@ -934,10 +1021,16 @@ rustc_queries! {\n             storage(ArenaCacheSelector<'tcx>)\n             desc { \"dllimport_foreign_items\" }\n         }\n-        query is_dllimport_foreign_item(_: DefId) -> bool {}\n-        query is_statically_included_foreign_item(_: DefId) -> bool {}\n-        query native_library_kind(_: DefId)\n-            -> Option<NativeLibraryKind> {}\n+        query is_dllimport_foreign_item(def_id: DefId) -> bool {\n+            desc { |tcx| \"is_dllimport_foreign_item({})\", tcx.def_path_str(def_id) }\n+        }\n+        query is_statically_included_foreign_item(def_id: DefId) -> bool {\n+            desc { |tcx| \"is_statically_included_foreign_item({})\", tcx.def_path_str(def_id) }\n+        }\n+        query native_library_kind(def_id: DefId)\n+            -> Option<NativeLibKind> {\n+            desc { |tcx| \"native_library_kind({})\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     Linking {\n@@ -968,7 +1061,9 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query visibility(_: DefId) -> ty::Visibility {}\n+        query visibility(def_id: DefId) -> ty::Visibility {\n+            desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     Other {\n@@ -980,8 +1075,12 @@ rustc_queries! {\n             eval_always\n             desc { \"fetching what a crate is named\" }\n         }\n-        query item_children(_: DefId) -> &'tcx [Export<hir::HirId>] {}\n-        query extern_mod_stmt_cnum(_: DefId) -> Option<CrateNum> {}\n+        query item_children(def_id: DefId) -> &'tcx [Export<hir::HirId>] {\n+            desc { |tcx| \"collecting child items of `{}`\", tcx.def_path_str(def_id) }\n+        }\n+        query extern_mod_stmt_cnum(def_id: LocalDefId) -> Option<CrateNum> {\n+            desc { |tcx| \"computing crate imported by `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n+        }\n \n         query get_lib_features(_: CrateNum) -> LibFeatures {\n             storage(ArenaCacheSelector<'tcx>)\n@@ -1040,15 +1139,16 @@ rustc_queries! {\n             desc { \"generating a postorder list of CrateNums\" }\n         }\n \n-        query upvars(_: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n+        query upvars_mentioned(def_id: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n+            desc { |tcx| \"collecting upvars mentioned in `{}`\", tcx.def_path_str(def_id) }\n             eval_always\n         }\n         query maybe_unused_trait_import(def_id: LocalDefId) -> bool {\n             eval_always\n             desc { |tcx| \"maybe_unused_trait_import for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n         }\n         query maybe_unused_extern_crates(_: CrateNum)\n-            -> &'tcx [(DefId, Span)] {\n+            -> &'tcx [(LocalDefId, Span)] {\n             eval_always\n             desc { \"looking up all possibly unused extern crates\" }\n         }\n@@ -1094,7 +1194,9 @@ rustc_queries! {\n             eval_always\n             desc { \"collect_and_partition_mono_items\" }\n         }\n-        query is_codegened_item(_: DefId) -> bool {}\n+        query is_codegened_item(def_id: DefId) -> bool {\n+            desc { |tcx| \"determining whether `{}` needs codegen\", tcx.def_path_str(def_id) }\n+        }\n         query codegen_unit(_: Symbol) -> &'tcx CodegenUnit<'tcx> {\n             desc { \"codegen_unit\" }\n         }"}, {"sha": "56787304d4e7e1e10700610137e0ee75d2c76342", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 73, "deletions": 80, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -27,9 +27,9 @@ pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, Selecti\n \n pub type ChalkCanonicalGoal<'tcx> = Canonical<'tcx, ChalkEnvironmentAndGoal<'tcx>>;\n \n+pub use self::ImplSource::*;\n pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n-pub use self::Vtable::*;\n \n pub use self::chalk::{\n     ChalkEnvironmentAndGoal, ChalkEnvironmentClause, RustDefId as ChalkRustDefId,\n@@ -343,15 +343,10 @@ pub enum SelectionError<'tcx> {\n /// - `Err(e)`: error `e` occurred\n pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n \n-/// Given the successful resolution of an obligation, the `Vtable`\n-/// indicates where the vtable comes from. Note that while we call this\n-/// a \"vtable\", it does not necessarily indicate dynamic dispatch at\n-/// runtime. `Vtable` instances just tell the compiler where to find\n-/// methods, but in generic code those methods are typically statically\n-/// dispatched -- only when an object is constructed is a `Vtable`\n-/// instance reified into an actual vtable.\n+/// Given the successful resolution of an obligation, the `ImplSource`\n+/// indicates where the impl comes from.\n ///\n-/// For example, the vtable may be tied to a specific impl (case A),\n+/// For example, the obligation may be satisfied by a specific impl (case A),\n /// or it may be relative to some bound that is in scope (case B).\n ///\n /// ```\n@@ -363,136 +358,136 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n ///                 param: T,\n ///                 mixed: Option<T>) {\n ///\n-///    // Case A: Vtable points at a specific impl. Only possible when\n+///    // Case A: ImplSource points at a specific impl. Only possible when\n ///    // type is concretely known. If the impl itself has bounded\n-///    // type parameters, Vtable will carry resolutions for those as well:\n-///    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n+///    // type parameters, ImplSource will carry resolutions for those as well:\n+///    concrete.clone(); // ImplSource(Impl_1, [ImplSource(Impl_2, [ImplSource(Impl_3)])])\n ///\n-///    // Case B: Vtable must be provided by caller. This applies when\n+///    // Case B: ImplSource must be provided by caller. This applies when\n ///    // type is a type parameter.\n-///    param.clone();    // VtableParam\n+///    param.clone();    // ImplSourceParam\n ///\n ///    // Case C: A mix of cases A and B.\n-///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n+///    mixed.clone();    // ImplSource(Impl_1, [ImplSourceParam])\n /// }\n /// ```\n ///\n /// ### The type parameter `N`\n ///\n-/// See explanation on `VtableImplData`.\n+/// See explanation on `ImplSourceUserDefinedData`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub enum Vtable<'tcx, N> {\n-    /// Vtable identifying a particular impl.\n-    VtableImpl(VtableImplData<'tcx, N>),\n+pub enum ImplSource<'tcx, N> {\n+    /// ImplSource identifying a particular impl.\n+    ImplSourceUserDefined(ImplSourceUserDefinedData<'tcx, N>),\n \n-    /// Vtable for auto trait implementations.\n+    /// ImplSource for auto trait implementations.\n     /// This carries the information and nested obligations with regards\n     /// to an auto implementation for a trait `Trait`. The nested obligations\n     /// ensure the trait implementation holds for all the constituent types.\n-    VtableAutoImpl(VtableAutoImplData<N>),\n+    ImplSourceAutoImpl(ImplSourceAutoImplData<N>),\n \n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter. The `Vec<N>` represents the\n     /// obligations incurred from normalizing the where-clause (if\n     /// any).\n-    VtableParam(Vec<N>),\n+    ImplSourceParam(Vec<N>),\n \n     /// Virtual calls through an object.\n-    VtableObject(VtableObjectData<'tcx, N>),\n+    ImplSourceObject(ImplSourceObjectData<'tcx, N>),\n \n     /// Successful resolution for a builtin trait.\n-    VtableBuiltin(VtableBuiltinData<N>),\n+    ImplSourceBuiltin(ImplSourceBuiltinData<N>),\n \n-    /// Vtable automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is a `VtableImpl` in spirit, but the\n+    /// ImplSource automatically generated for a closure. The `DefId` is the ID\n+    /// of the closure expression. This is a `ImplSourceUserDefined` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n-    VtableClosure(VtableClosureData<'tcx, N>),\n+    ImplSourceClosure(ImplSourceClosureData<'tcx, N>),\n \n     /// Same as above, but for a function pointer type with the given signature.\n-    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n+    ImplSourceFnPointer(ImplSourceFnPointerData<'tcx, N>),\n \n-    /// Vtable for a builtin `DeterminantKind` trait implementation.\n-    VtableDiscriminantKind(VtableDiscriminantKindData),\n+    /// ImplSource for a builtin `DeterminantKind` trait implementation.\n+    ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData),\n \n-    /// Vtable automatically generated for a generator.\n-    VtableGenerator(VtableGeneratorData<'tcx, N>),\n+    /// ImplSource automatically generated for a generator.\n+    ImplSourceGenerator(ImplSourceGeneratorData<'tcx, N>),\n \n-    /// Vtable for a trait alias.\n-    VtableTraitAlias(VtableTraitAliasData<'tcx, N>),\n+    /// ImplSource for a trait alias.\n+    ImplSourceTraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n }\n \n-impl<'tcx, N> Vtable<'tcx, N> {\n+impl<'tcx, N> ImplSource<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {\n-            VtableImpl(i) => i.nested,\n-            VtableParam(n) => n,\n-            VtableBuiltin(i) => i.nested,\n-            VtableAutoImpl(d) => d.nested,\n-            VtableClosure(c) => c.nested,\n-            VtableGenerator(c) => c.nested,\n-            VtableObject(d) => d.nested,\n-            VtableFnPointer(d) => d.nested,\n-            VtableDiscriminantKind(VtableDiscriminantKindData) => Vec::new(),\n-            VtableTraitAlias(d) => d.nested,\n+            ImplSourceUserDefined(i) => i.nested,\n+            ImplSourceParam(n) => n,\n+            ImplSourceBuiltin(i) => i.nested,\n+            ImplSourceAutoImpl(d) => d.nested,\n+            ImplSourceClosure(c) => c.nested,\n+            ImplSourceGenerator(c) => c.nested,\n+            ImplSourceObject(d) => d.nested,\n+            ImplSourceFnPointer(d) => d.nested,\n+            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => Vec::new(),\n+            ImplSourceTraitAlias(d) => d.nested,\n         }\n     }\n \n     pub fn borrow_nested_obligations(&self) -> &[N] {\n         match &self {\n-            VtableImpl(i) => &i.nested[..],\n-            VtableParam(n) => &n[..],\n-            VtableBuiltin(i) => &i.nested[..],\n-            VtableAutoImpl(d) => &d.nested[..],\n-            VtableClosure(c) => &c.nested[..],\n-            VtableGenerator(c) => &c.nested[..],\n-            VtableObject(d) => &d.nested[..],\n-            VtableFnPointer(d) => &d.nested[..],\n-            VtableDiscriminantKind(VtableDiscriminantKindData) => &[],\n-            VtableTraitAlias(d) => &d.nested[..],\n+            ImplSourceUserDefined(i) => &i.nested[..],\n+            ImplSourceParam(n) => &n[..],\n+            ImplSourceBuiltin(i) => &i.nested[..],\n+            ImplSourceAutoImpl(d) => &d.nested[..],\n+            ImplSourceClosure(c) => &c.nested[..],\n+            ImplSourceGenerator(c) => &c.nested[..],\n+            ImplSourceObject(d) => &d.nested[..],\n+            ImplSourceFnPointer(d) => &d.nested[..],\n+            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => &[],\n+            ImplSourceTraitAlias(d) => &d.nested[..],\n         }\n     }\n \n-    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n+    pub fn map<M, F>(self, f: F) -> ImplSource<'tcx, M>\n     where\n         F: FnMut(N) -> M,\n     {\n         match self {\n-            VtableImpl(i) => VtableImpl(VtableImplData {\n+            ImplSourceUserDefined(i) => ImplSourceUserDefined(ImplSourceUserDefinedData {\n                 impl_def_id: i.impl_def_id,\n                 substs: i.substs,\n                 nested: i.nested.into_iter().map(f).collect(),\n             }),\n-            VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n-            VtableBuiltin(i) => {\n-                VtableBuiltin(VtableBuiltinData { nested: i.nested.into_iter().map(f).collect() })\n-            }\n-            VtableObject(o) => VtableObject(VtableObjectData {\n+            ImplSourceParam(n) => ImplSourceParam(n.into_iter().map(f).collect()),\n+            ImplSourceBuiltin(i) => ImplSourceBuiltin(ImplSourceBuiltinData {\n+                nested: i.nested.into_iter().map(f).collect(),\n+            }),\n+            ImplSourceObject(o) => ImplSourceObject(ImplSourceObjectData {\n                 upcast_trait_ref: o.upcast_trait_ref,\n                 vtable_base: o.vtable_base,\n                 nested: o.nested.into_iter().map(f).collect(),\n             }),\n-            VtableAutoImpl(d) => VtableAutoImpl(VtableAutoImplData {\n+            ImplSourceAutoImpl(d) => ImplSourceAutoImpl(ImplSourceAutoImplData {\n                 trait_def_id: d.trait_def_id,\n                 nested: d.nested.into_iter().map(f).collect(),\n             }),\n-            VtableClosure(c) => VtableClosure(VtableClosureData {\n+            ImplSourceClosure(c) => ImplSourceClosure(ImplSourceClosureData {\n                 closure_def_id: c.closure_def_id,\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),\n-            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n+            ImplSourceGenerator(c) => ImplSourceGenerator(ImplSourceGeneratorData {\n                 generator_def_id: c.generator_def_id,\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),\n-            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n+            ImplSourceFnPointer(p) => ImplSourceFnPointer(ImplSourceFnPointerData {\n                 fn_ty: p.fn_ty,\n                 nested: p.nested.into_iter().map(f).collect(),\n             }),\n-            VtableDiscriminantKind(VtableDiscriminantKindData) => {\n-                VtableDiscriminantKind(VtableDiscriminantKindData)\n+            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => {\n+                ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData)\n             }\n-            VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n+            ImplSourceTraitAlias(d) => ImplSourceTraitAlias(ImplSourceTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,\n                 nested: d.nested.into_iter().map(f).collect(),\n@@ -512,14 +507,14 @@ impl<'tcx, N> Vtable<'tcx, N> {\n /// is `()`, because codegen only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableImplData<'tcx, N> {\n+pub struct ImplSourceUserDefinedData<'tcx, N> {\n     pub impl_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableGeneratorData<'tcx, N> {\n+pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub generator_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     /// Nested obligations. This can be non-empty if the generator\n@@ -528,7 +523,7 @@ pub struct VtableGeneratorData<'tcx, N> {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableClosureData<'tcx, N> {\n+pub struct ImplSourceClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     /// Nested obligations. This can be non-empty if the closure\n@@ -537,20 +532,18 @@ pub struct VtableClosureData<'tcx, N> {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableAutoImplData<N> {\n+pub struct ImplSourceAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableBuiltinData<N> {\n+pub struct ImplSourceBuiltinData<N> {\n     pub nested: Vec<N>,\n }\n \n-/// A vtable for some object-safe trait `Foo` automatically derived\n-/// for the object type `Foo`.\n #[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableObjectData<'tcx, N> {\n+pub struct ImplSourceObjectData<'tcx, N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n \n@@ -563,17 +556,17 @@ pub struct VtableObjectData<'tcx, N> {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableFnPointerData<'tcx, N> {\n+pub struct ImplSourceFnPointerData<'tcx, N> {\n     pub fn_ty: Ty<'tcx>,\n     pub nested: Vec<N>,\n }\n \n // FIXME(@lcnr): This should be  refactored and merged with other builtin vtables.\n #[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableDiscriminantKindData;\n+pub struct ImplSourceDiscriminantKindData;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableTraitAliasData<'tcx, N> {\n+pub struct ImplSourceTraitAliasData<'tcx, N> {\n     pub alias_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>,"}, {"sha": "218bb144469b4b3848815aa50da15419a695bd1d", "filename": "src/librustc_middle/traits/structural_impls.rs", "status": "modified", "additions": 62, "deletions": 54, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -6,99 +6,99 @@ use std::rc::Rc;\n \n // Structural impls for the structs in `traits`.\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            super::VtableImpl(ref v) => write!(f, \"{:?}\", v),\n+            super::ImplSourceUserDefined(ref v) => write!(f, \"{:?}\", v),\n \n-            super::VtableAutoImpl(ref t) => write!(f, \"{:?}\", t),\n+            super::ImplSourceAutoImpl(ref t) => write!(f, \"{:?}\", t),\n \n-            super::VtableClosure(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceClosure(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableGenerator(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceGenerator(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableFnPointer(ref d) => write!(f, \"VtableFnPointer({:?})\", d),\n+            super::ImplSourceFnPointer(ref d) => write!(f, \"ImplSourceFnPointer({:?})\", d),\n \n-            super::VtableDiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceDiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableObject(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceObject(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n+            super::ImplSourceParam(ref n) => write!(f, \"ImplSourceParam({:?})\", n),\n \n-            super::VtableBuiltin(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceBuiltin(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableTraitAlias(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceTraitAlias(ref d) => write!(f, \"{:?}\", d),\n         }\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceUserDefinedData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableImplData(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"ImplSourceUserDefinedData(impl_def_id={:?}, substs={:?}, nested={:?})\",\n             self.impl_def_id, self.substs, self.nested\n         )\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceGeneratorData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"ImplSourceGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n             self.generator_def_id, self.substs, self.nested\n         )\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceClosureData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"ImplSourceClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n             self.closure_def_id, self.substs, self.nested\n         )\n     }\n }\n \n-impl<N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n+impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceBuiltinData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"VtableBuiltinData(nested={:?})\", self.nested)\n+        write!(f, \"ImplSourceBuiltinData(nested={:?})\", self.nested)\n     }\n }\n \n-impl<N: fmt::Debug> fmt::Debug for traits::VtableAutoImplData<N> {\n+impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceAutoImplData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n+            \"ImplSourceAutoImplData(trait_def_id={:?}, nested={:?})\",\n             self.trait_def_id, self.nested\n         )\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceObjectData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n+            \"ImplSourceObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n             self.upcast_trait_ref, self.vtable_base, self.nested\n         )\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceFnPointerData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"VtableFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n+        write!(f, \"ImplSourceFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableTraitAliasData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"ImplSourceTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n             self.alias_def_id, self.substs, self.nested\n         )\n     }\n@@ -241,63 +241,71 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n }\n \n // For codegen only.\n-impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n-    type Lifted = traits::Vtable<'tcx, ()>;\n+impl<'a, 'tcx> Lift<'tcx> for traits::ImplSource<'a, ()> {\n+    type Lifted = traits::ImplSource<'tcx, ()>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self.clone() {\n-            traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested })\n+            traits::ImplSourceUserDefined(traits::ImplSourceUserDefinedData {\n+                impl_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::ImplSourceUserDefined(traits::ImplSourceUserDefinedData {\n+                    impl_def_id,\n+                    substs,\n+                    nested,\n                 })\n-            }\n-            traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n-            traits::VtableGenerator(traits::VtableGeneratorData {\n+            }),\n+            traits::ImplSourceAutoImpl(t) => Some(traits::ImplSourceAutoImpl(t)),\n+            traits::ImplSourceGenerator(traits::ImplSourceGeneratorData {\n                 generator_def_id,\n                 substs,\n                 nested,\n             }) => tcx.lift(&substs).map(|substs| {\n-                traits::VtableGenerator(traits::VtableGeneratorData {\n+                traits::ImplSourceGenerator(traits::ImplSourceGeneratorData {\n                     generator_def_id,\n                     substs,\n                     nested,\n                 })\n             }),\n-            traits::VtableClosure(traits::VtableClosureData { closure_def_id, substs, nested }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableClosure(traits::VtableClosureData {\n-                        closure_def_id,\n-                        substs,\n-                        nested,\n-                    })\n+            traits::ImplSourceClosure(traits::ImplSourceClosureData {\n+                closure_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::ImplSourceClosure(traits::ImplSourceClosureData {\n+                    closure_def_id,\n+                    substs,\n+                    nested,\n                 })\n-            }\n-            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n+            }),\n+            traits::ImplSourceFnPointer(traits::ImplSourceFnPointerData { fn_ty, nested }) => {\n                 tcx.lift(&fn_ty).map(|fn_ty| {\n-                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n+                    traits::ImplSourceFnPointer(traits::ImplSourceFnPointerData { fn_ty, nested })\n                 })\n             }\n-            traits::VtableDiscriminantKind(traits::VtableDiscriminantKindData) => {\n-                Some(traits::VtableDiscriminantKind(traits::VtableDiscriminantKindData))\n+            traits::ImplSourceDiscriminantKind(traits::ImplSourceDiscriminantKindData) => {\n+                Some(traits::ImplSourceDiscriminantKind(traits::ImplSourceDiscriminantKindData))\n             }\n-            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n-            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n-            traits::VtableObject(traits::VtableObjectData {\n+            traits::ImplSourceParam(n) => Some(traits::ImplSourceParam(n)),\n+            traits::ImplSourceBuiltin(n) => Some(traits::ImplSourceBuiltin(n)),\n+            traits::ImplSourceObject(traits::ImplSourceObjectData {\n                 upcast_trait_ref,\n                 vtable_base,\n                 nested,\n             }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n-                traits::VtableObject(traits::VtableObjectData {\n+                traits::ImplSourceObject(traits::ImplSourceObjectData {\n                     upcast_trait_ref: trait_ref,\n                     vtable_base,\n                     nested,\n                 })\n             }),\n-            traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+            traits::ImplSourceTraitAlias(traits::ImplSourceTraitAliasData {\n                 alias_def_id,\n                 substs,\n                 nested,\n             }) => tcx.lift(&substs).map(|substs| {\n-                traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                traits::ImplSourceTraitAlias(traits::ImplSourceTraitAliasData {\n                     alias_def_id,\n                     substs,\n                     nested,"}, {"sha": "8bc69a9d1231288897f46ca1d100b0013c824013", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,7 +10,7 @@ use crate::arena::ArenaAllocatable;\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::mir::{self, interpret::Allocation};\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, List, Ty, TyCtxt};\n+use crate::ty::{self, List, ToPredicate, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n@@ -39,9 +39,9 @@ impl<'tcx> EncodableWithShorthand for Ty<'tcx> {\n }\n \n impl<'tcx> EncodableWithShorthand for ty::Predicate<'tcx> {\n-    type Variant = ty::Predicate<'tcx>;\n+    type Variant = ty::PredicateKind<'tcx>;\n     fn variant(&self) -> &Self::Variant {\n-        self\n+        self.kind()\n     }\n }\n \n@@ -200,15 +200,16 @@ where\n         (0..decoder.read_usize()?)\n             .map(|_| {\n                 // Handle shorthands first, if we have an usize > 0x80.\n-                let predicate = if decoder.positioned_at_shorthand() {\n+                let predicate_kind = if decoder.positioned_at_shorthand() {\n                     let pos = decoder.read_usize()?;\n                     assert!(pos >= SHORTHAND_OFFSET);\n                     let shorthand = pos - SHORTHAND_OFFSET;\n \n-                    decoder.with_position(shorthand, ty::Predicate::decode)\n+                    decoder.with_position(shorthand, ty::PredicateKind::decode)\n                 } else {\n-                    ty::Predicate::decode(decoder)\n+                    ty::PredicateKind::decode(decoder)\n                 }?;\n+                let predicate = predicate_kind.to_predicate(tcx);\n                 Ok((predicate, Decodable::decode(decoder)?))\n             })\n             .collect::<Result<Vec<_>, _>>()?,"}, {"sha": "d5be3508d2d803c14462d5a15cea751461117aee", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 109, "deletions": 124, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,40 +1,29 @@\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n-use crate::dep_graph::DepGraph;\n-use crate::dep_graph::{self, DepConstructor};\n-use crate::hir::exports::Export;\n+use crate::dep_graph::{self, DepConstructor, DepGraph};\n+use crate::hir::exports::ExportMap;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use crate::lint::LintDiagnosticBuilder;\n-use crate::lint::{struct_lint_level, LintSource};\n+use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintSource};\n use crate::middle;\n-use crate::middle::cstore::CrateStoreDyn;\n-use crate::middle::cstore::EncodedMetadata;\n+use crate::middle::cstore::{CrateStoreDyn, EncodedMetadata};\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::interpret::{Allocation, ConstValue, Scalar};\n-use crate::mir::{interpret, Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n+use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n+use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::traits;\n-use crate::ty::query;\n use crate::ty::steal::Steal;\n-use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n-use crate::ty::subst::{GenericArgKind, UserSubsts};\n-use crate::ty::CanonicalPolyFnSig;\n-use crate::ty::GenericParamDefKind;\n-use crate::ty::RegionKind;\n-use crate::ty::ReprOptions;\n+use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n use crate::ty::TyKind::*;\n-use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n-use crate::ty::{AdtDef, AdtKind, Const, Region};\n-use crate::ty::{BindingMode, BoundVar};\n-use crate::ty::{ConstVid, FloatVar, FloatVid, IntVar, IntVid, TyVar, TyVid};\n-use crate::ty::{ExistentialPredicate, InferTy, ParamTy, PolyFnSig, Predicate, ProjectionTy};\n-use crate::ty::{InferConst, ParamConst};\n-use crate::ty::{List, TyKind, TyS};\n+use crate::ty::{\n+    self, query, AdtDef, AdtKind, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid,\n+    DefIdTree, ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy,\n+    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateKind, ProjectionTy,\n+    Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut,\n+};\n use rustc_ast::ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n-use rustc_ast::node_id::NodeMap;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::SelfProfilerRef;\n@@ -48,10 +37,8 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefPathHash, Definitions};\n-use rustc_hir::lang_items;\n-use rustc_hir::lang_items::PanicLocationLangItem;\n-use rustc_hir::{HirId, Node, TraitCandidate};\n-use rustc_hir::{ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet};\n+use rustc_hir::lang_items::{self, PanicLocationLangItem};\n+use rustc_hir::{HirId, ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet, Node, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n@@ -89,6 +76,7 @@ pub struct CtxtInterners<'tcx> {\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo>>,\n     region: InternedSet<'tcx, RegionKind>,\n     existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n+    predicate_kind: InternedSet<'tcx, PredicateKind<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n@@ -107,6 +95,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             region: Default::default(),\n             existential_predicates: Default::default(),\n             canonical_var_infos: Default::default(),\n+            predicate_kind: Default::default(),\n             predicates: Default::default(),\n             projs: Default::default(),\n             place_elems: Default::default(),\n@@ -417,7 +406,7 @@ pub struct TypeckTables<'tcx> {\n     /// The upvarID contains the HIR node ID and it also contains the full path\n     /// leading to the member of the struct or tuple that is used instead of the\n     /// entire variable.\n-    pub upvar_list: ty::UpvarListMap,\n+    pub closure_captures: ty::UpvarListMap,\n \n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n@@ -445,7 +434,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             used_trait_imports: Lrc::new(Default::default()),\n             tainted_by_errors: None,\n             concrete_opaque_types: Default::default(),\n-            upvar_list: Default::default(),\n+            closure_captures: Default::default(),\n             generator_interior_types: Default::default(),\n         }\n     }\n@@ -686,7 +675,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             ref used_trait_imports,\n             tainted_by_errors,\n             ref concrete_opaque_types,\n-            ref upvar_list,\n+            ref closure_captures,\n             ref generator_interior_types,\n         } = *self;\n \n@@ -719,7 +708,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             used_trait_imports.hash_stable(hcx, hasher);\n             tainted_by_errors.hash_stable(hcx, hasher);\n             concrete_opaque_types.hash_stable(hcx, hasher);\n-            upvar_list.hash_stable(hcx, hasher);\n+            closure_captures.hash_stable(hcx, hasher);\n             generator_interior_types.hash_stable(hcx, hasher);\n         })\n     }\n@@ -923,14 +912,14 @@ pub struct GlobalCtxt<'tcx> {\n     pub consts: CommonConsts<'tcx>,\n \n     /// Resolutions of `extern crate` items produced by resolver.\n-    extern_crate_map: NodeMap<CrateNum>,\n+    extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n \n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     trait_map: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, StableVec<TraitCandidate>>>,\n \n     /// Export map produced by name resolution.\n-    export_map: FxHashMap<DefId, Vec<Export<hir::HirId>>>,\n+    export_map: ExportMap<LocalDefId>,\n \n     pub(crate) untracked_crate: &'tcx hir::Crate<'tcx>,\n     pub(crate) definitions: &'tcx Definitions,\n@@ -942,7 +931,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub queries: query::Queries<'tcx>,\n \n     maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n-    maybe_unused_extern_crates: Vec<(DefId, Span)>,\n+    maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n     /// A map of glob use to a set of names it actually imports. Currently only\n     /// used in save-analysis.\n     glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n@@ -1113,13 +1102,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n-        for (k, v) in resolutions.trait_map {\n-            let hir_id = definitions.node_id_to_hir_id(k);\n+        for (hir_id, v) in resolutions.trait_map.into_iter() {\n             let map = trait_map.entry(hir_id.owner).or_default();\n-            let v = v\n-                .into_iter()\n-                .map(|tc| tc.map_import_ids(|id| definitions.node_id_to_hir_id(id)))\n-                .collect();\n             map.insert(hir_id.local_id, StableVec::new(v));\n         }\n \n@@ -1136,32 +1120,10 @@ impl<'tcx> TyCtxt<'tcx> {\n             consts: common_consts,\n             extern_crate_map: resolutions.extern_crate_map,\n             trait_map,\n-            export_map: resolutions\n-                .export_map\n-                .into_iter()\n-                .map(|(k, v)| {\n-                    let exports: Vec<_> = v\n-                        .into_iter()\n-                        .map(|e| e.map_id(|id| definitions.node_id_to_hir_id(id)))\n-                        .collect();\n-                    (k, exports)\n-                })\n-                .collect(),\n-            maybe_unused_trait_imports: resolutions\n-                .maybe_unused_trait_imports\n-                .into_iter()\n-                .map(|id| definitions.local_def_id(id))\n-                .collect(),\n-            maybe_unused_extern_crates: resolutions\n-                .maybe_unused_extern_crates\n-                .into_iter()\n-                .map(|(id, sp)| (definitions.local_def_id(id).to_def_id(), sp))\n-                .collect(),\n-            glob_map: resolutions\n-                .glob_map\n-                .into_iter()\n-                .map(|(id, names)| (definitions.local_def_id(id), names))\n-                .collect(),\n+            export_map: resolutions.export_map,\n+            maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n+            maybe_unused_extern_crates: resolutions.maybe_unused_extern_crates,\n+            glob_map: resolutions.glob_map,\n             extern_prelude: resolutions.extern_prelude,\n             untracked_crate: krate,\n             definitions,\n@@ -1377,7 +1339,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn local_crate_exports_generics(self) -> bool {\n         debug_assert!(self.sess.opts.share_generics());\n \n-        self.sess.crate_types.borrow().iter().any(|crate_type| {\n+        self.sess.crate_types().iter().any(|crate_type| {\n             match crate_type {\n                 CrateType::Executable\n                 | CrateType::Staticlib\n@@ -1421,6 +1383,66 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n+    pub fn return_type_impl_or_dyn_trait(&self, scope_def_id: DefId) -> Option<(Span, bool)> {\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n+        let hir_output = match self.hir().get(hir_id) {\n+            Node::Item(hir::Item {\n+                kind:\n+                    ItemKind::Fn(\n+                        hir::FnSig {\n+                            decl: hir::FnDecl { output: hir::FnRetTy::Return(ty), .. },\n+                            ..\n+                        },\n+                        ..,\n+                    ),\n+                ..\n+            })\n+            | Node::ImplItem(hir::ImplItem {\n+                kind:\n+                    hir::ImplItemKind::Fn(\n+                        hir::FnSig {\n+                            decl: hir::FnDecl { output: hir::FnRetTy::Return(ty), .. },\n+                            ..\n+                        },\n+                        _,\n+                    ),\n+                ..\n+            })\n+            | Node::TraitItem(hir::TraitItem {\n+                kind:\n+                    hir::TraitItemKind::Fn(\n+                        hir::FnSig {\n+                            decl: hir::FnDecl { output: hir::FnRetTy::Return(ty), .. },\n+                            ..\n+                        },\n+                        _,\n+                    ),\n+                ..\n+            }) => ty,\n+            _ => return None,\n+        };\n+\n+        let ret_ty = self.type_of(scope_def_id);\n+        match ret_ty.kind {\n+            ty::FnDef(_, _) => {\n+                let sig = ret_ty.fn_sig(*self);\n+                let output = self.erase_late_bound_regions(&sig.output());\n+                if output.is_impl_trait() {\n+                    let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n+                    Some((fn_decl.output.span(), false))\n+                } else {\n+                    let mut v = TraitObjectVisitor(vec![]);\n+                    rustc_hir::intravisit::walk_ty(&mut v, hir_output);\n+                    if v.0.len() == 1 {\n+                        return Some((v.0[0], true));\n+                    }\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n         let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n@@ -1574,6 +1596,7 @@ macro_rules! nop_list_lift {\n nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n nop_lift! {region; Region<'a> => Region<'tcx>}\n nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n+nop_lift! {predicate_kind; &'a PredicateKind<'a> => &'tcx PredicateKind<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {existential_predicates; ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n@@ -1948,32 +1971,8 @@ impl<'tcx, T: Hash> Hash for Interned<'tcx, List<T>> {\n     }\n }\n \n-impl<'tcx> Borrow<[Ty<'tcx>]> for Interned<'tcx, List<Ty<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [Ty<'tcx>] {\n-        &self.0[..]\n-    }\n-}\n-\n-impl<'tcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, List<CanonicalVarInfo>> {\n-    fn borrow(&self) -> &[CanonicalVarInfo] {\n-        &self.0[..]\n-    }\n-}\n-\n-impl<'tcx> Borrow<[GenericArg<'tcx>]> for Interned<'tcx, InternalSubsts<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a [GenericArg<'tcx>] {\n-        &self.0[..]\n-    }\n-}\n-\n-impl<'tcx> Borrow<[ProjectionKind]> for Interned<'tcx, List<ProjectionKind>> {\n-    fn borrow(&self) -> &[ProjectionKind] {\n-        &self.0[..]\n-    }\n-}\n-\n-impl<'tcx> Borrow<[PlaceElem<'tcx>]> for Interned<'tcx, List<PlaceElem<'tcx>>> {\n-    fn borrow(&self) -> &[PlaceElem<'tcx>] {\n+impl<'tcx, T> Borrow<[T]> for Interned<'tcx, List<T>> {\n+    fn borrow<'a>(&'a self) -> &'a [T] {\n         &self.0[..]\n     }\n }\n@@ -1984,36 +1983,20 @@ impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n     }\n }\n \n-impl<'tcx> Borrow<[ExistentialPredicate<'tcx>]>\n-    for Interned<'tcx, List<ExistentialPredicate<'tcx>>>\n-{\n-    fn borrow<'a>(&'a self) -> &'a [ExistentialPredicate<'tcx>] {\n-        &self.0[..]\n-    }\n-}\n-\n-impl<'tcx> Borrow<[Predicate<'tcx>]> for Interned<'tcx, List<Predicate<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [Predicate<'tcx>] {\n-        &self.0[..]\n-    }\n-}\n-\n impl<'tcx> Borrow<Const<'tcx>> for Interned<'tcx, Const<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a Const<'tcx> {\n         &self.0\n     }\n }\n \n-impl<'tcx> Borrow<[traits::ChalkEnvironmentClause<'tcx>]>\n-    for Interned<'tcx, List<traits::ChalkEnvironmentClause<'tcx>>>\n-{\n-    fn borrow<'a>(&'a self) -> &'a [traits::ChalkEnvironmentClause<'tcx>] {\n-        &self.0[..]\n+impl<'tcx> Borrow<PredicateKind<'tcx>> for Interned<'tcx, PredicateKind<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a PredicateKind<'tcx> {\n+        &self.0\n     }\n }\n \n macro_rules! direct_interners {\n-    ($($name:ident: $method:ident($ty:ty)),+) => {\n+    ($($name:ident: $method:ident($ty:ty),)+) => {\n         $(impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n             fn eq(&self, other: &Self) -> bool {\n                 self.0 == other.0\n@@ -2038,7 +2021,11 @@ macro_rules! direct_interners {\n     }\n }\n \n-direct_interners!(region: mk_region(RegionKind), const_: mk_const(Const<'tcx>));\n+direct_interners!(\n+    region: mk_region(RegionKind),\n+    const_: mk_const(Const<'tcx>),\n+    predicate_kind: intern_predicate_kind(PredicateKind<'tcx>),\n+);\n \n macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ty)),+) => (\n@@ -2100,6 +2087,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.interners.intern_ty(st)\n     }\n \n+    #[inline]\n+    pub fn mk_predicate(&self, kind: PredicateKind<'tcx>) -> Predicate<'tcx> {\n+        let kind = self.intern_predicate_kind(kind);\n+        Predicate { kind }\n+    }\n+\n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {\n         match tm {\n             ast::IntTy::Isize => self.types.isize,\n@@ -2259,11 +2252,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         if self.features().never_type_fallback { self.types.never } else { self.types.unit }\n     }\n \n-    #[inline]\n-    pub fn mk_bool(self) -> Ty<'tcx> {\n-        self.mk_ty(Bool)\n-    }\n-\n     #[inline]\n     pub fn mk_fn_def(self, def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(FnDef(def_id, substs))\n@@ -2709,10 +2697,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n         tcx.stability().local_deprecation_entry(id)\n     };\n-    providers.extern_mod_stmt_cnum = |tcx, id| {\n-        let id = tcx.hir().as_local_node_id(id).unwrap();\n-        tcx.extern_crate_map.get(&id).cloned()\n-    };\n+    providers.extern_mod_stmt_cnum = |tcx, id| tcx.extern_crate_map.get(&id).cloned();\n     providers.all_crate_nums = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         tcx.arena.alloc_slice(&tcx.cstore.crates_untracked())"}, {"sha": "2e9aa724ac5af744fde06c944550ff3f760777fb", "filename": "src/librustc_middle/ty/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -7,7 +7,6 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n-use rustc_span::{BytePos, Span};\n \n impl<'tcx> TyS<'tcx> {\n     /// Similar to `TyS::is_primitive`, but also considers inferred numeric values to be primitive.\n@@ -221,24 +220,11 @@ pub fn suggest_constraining_type_param(\n             }\n         }\n \n-        let where_clause_span = generics.where_clause.span_for_predicates_or_empty_place();\n-        // Account for `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n-        let mut trailing_comma = false;\n-        if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(where_clause_span) {\n-            trailing_comma = snippet.ends_with(',');\n-        }\n-        let where_clause_span = if trailing_comma {\n-            let hi = where_clause_span.hi();\n-            Span::new(hi - BytePos(1), hi, where_clause_span.ctxt())\n-        } else {\n-            where_clause_span.shrink_to_hi()\n-        };\n-\n         match &param_spans[..] {\n             &[&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n             _ => {\n                 err.span_suggestion_verbose(\n-                    where_clause_span,\n+                    generics.where_clause.tail_span_for_suggestion(),\n                     &msg_restrict_type_further,\n                     format!(\", {}: {}\", param_name, constraint),\n                     Applicability::MachineApplicable,\n@@ -249,3 +235,22 @@ pub fn suggest_constraining_type_param(\n         true\n     }\n }\n+\n+pub struct TraitObjectVisitor(pub Vec<rustc_span::Span>);\n+impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor {\n+    type Map = rustc_hir::intravisit::ErasedMap<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+        if let hir::TyKind::TraitObject(\n+            _,\n+            hir::Lifetime { name: hir::LifetimeName::ImplicitObjectLifetimeDefault, .. },\n+        ) = ty.kind\n+        {\n+            self.0.push(ty.span);\n+        }\n+    }\n+}"}, {"sha": "480420dfdcf5e0a67df8dac6ecc4538b8a0b4e23", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -815,19 +815,18 @@ fn foo(&self) -> Self::T { String::new() }\n                 for item in &items[..] {\n                     match item.kind {\n                         hir::AssocItemKind::Type | hir::AssocItemKind::OpaqueTy => {\n-                            if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n-                                if let hir::Defaultness::Default { has_value: true } =\n-                                    item.defaultness\n-                                {\n+                            // FIXME: account for returning some type in a trait fn impl that has\n+                            // an assoc type as a return type (#72076).\n+                            if let hir::Defaultness::Default { has_value: true } = item.defaultness\n+                            {\n+                                if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n                                     db.span_label(\n                                         item.span,\n                                         \"associated type defaults can't be assumed inside the \\\n                                             trait defining them\",\n                                     );\n-                                } else {\n-                                    db.span_label(item.span, \"expected this associated type\");\n+                                    return true;\n                                 }\n-                                return true;\n                             }\n                         }\n                         _ => {}"}, {"sha": "edcb69c5e8cbdf3fc3b01cbdf3d0e4883fee1f08", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -129,7 +129,7 @@ impl FlagComputation {\n             &ty::Dynamic(ref obj, r) => {\n                 let mut computation = FlagComputation::new();\n                 for predicate in obj.skip_binder().iter() {\n-                    match *predicate {\n+                    match predicate {\n                         ty::ExistentialPredicate::Trait(tr) => computation.add_substs(tr.substs),\n                         ty::ExistentialPredicate::Projection(p) => {\n                             let mut proj_computation = FlagComputation::new();"}, {"sha": "e93abd3390a2db9518735af52e774a4f6f9e9a22", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -187,10 +187,9 @@ fn layout_raw<'tcx>(\n     query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Result<&'tcx Layout, LayoutError<'tcx>> {\n     ty::tls::with_related_context(tcx, move |icx| {\n-        let rec_limit = *tcx.sess.recursion_limit.get();\n         let (param_env, ty) = query.into_parts();\n \n-        if icx.layout_depth > rec_limit {\n+        if !tcx.sess.recursion_limit().value_within_limit(icx.layout_depth) {\n             tcx.sess.fatal(&format!(\"overflow representing the type `{}`\", ty));\n         }\n "}, {"sha": "161783bb370d44904b4a492ae05d2c55e1636f22", "filename": "src/librustc_middle/ty/list.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flist.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -5,6 +5,7 @@ use rustc_serialize::{Encodable, Encoder};\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n+use std::iter;\n use std::mem;\n use std::ops::Deref;\n use std::ptr;\n@@ -21,6 +22,10 @@ extern \"C\" {\n /// the same contents can exist in the same context.\n /// This means we can use pointer for both\n /// equality comparisons and hashing.\n+///\n+/// Unlike slices, The types contained in `List` are expected to be `Copy`\n+/// and iterating over a `List` returns `T` instead of a reference.\n+///\n /// Note: `Slice` was already taken by the `Ty`.\n #[repr(C)]\n pub struct List<T> {\n@@ -61,6 +66,15 @@ impl<T: Copy> List<T> {\n             result\n         }\n     }\n+\n+    // If this method didn't exist, we would use `slice.iter` due to\n+    // deref coercion.\n+    //\n+    // This would be weird, as `self.into_iter` iterates over `T` directly.\n+    #[inline(always)]\n+    pub fn iter(&self) -> <&'_ List<T> as IntoIterator>::IntoIter {\n+        self.into_iter()\n+    }\n }\n \n impl<T: fmt::Debug> fmt::Debug for List<T> {\n@@ -128,12 +142,12 @@ impl<T> AsRef<[T]> for List<T> {\n     }\n }\n \n-impl<'a, T> IntoIterator for &'a List<T> {\n-    type Item = &'a T;\n-    type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n+impl<'a, T: Copy> IntoIterator for &'a List<T> {\n+    type Item = T;\n+    type IntoIter = iter::Copied<<&'a [T] as IntoIterator>::IntoIter>;\n     #[inline(always)]\n     fn into_iter(self) -> Self::IntoIter {\n-        self[..].iter()\n+        self[..].iter().copied()\n     }\n }\n "}, {"sha": "ffbe3a40297c172a3d4ee9e8510d35f44e64bcb2", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 117, "deletions": 82, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -14,14 +14,14 @@ use crate::mir::Body;\n use crate::mir::GeneratorLayout;\n use crate::traits::{self, Reveal};\n use crate::ty;\n-use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n+use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::{Discr, IntTypeExt};\n use rustc_ast::ast;\n-use rustc_ast::node_id::{NodeId, NodeMap, NodeSet};\n use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -31,7 +31,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::lang_items::{FnMutTraitLangItem, FnOnceTraitLangItem, FnTraitLangItem};\n-use rustc_hir::{Constness, GlobMap, Node, TraitMap};\n+use rustc_hir::{Constness, Node};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_serialize::{self, Encodable, Encoder};\n@@ -120,12 +120,12 @@ mod sty;\n pub struct ResolverOutputs {\n     pub definitions: rustc_hir::definitions::Definitions,\n     pub cstore: Box<CrateStoreDyn>,\n-    pub extern_crate_map: NodeMap<CrateNum>,\n-    pub trait_map: TraitMap<NodeId>,\n-    pub maybe_unused_trait_imports: NodeSet,\n-    pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n-    pub export_map: ExportMap<NodeId>,\n-    pub glob_map: GlobMap,\n+    pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n+    pub trait_map: FxHashMap<hir::HirId, Vec<hir::TraitCandidate<hir::HirId>>>,\n+    pub maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n+    pub maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n+    pub export_map: ExportMap<LocalDefId>,\n+    pub glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n     /// Extern prelude entries. The value is `true` if the entry was introduced\n     /// via `extern crate` item and not `--extern` option or compiler built-in.\n     pub extern_prelude: FxHashMap<Symbol, bool>,\n@@ -1016,9 +1016,31 @@ impl<'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n+#[derive(Clone, Copy, Hash, RustcEncodable, RustcDecodable, Lift)]\n+#[derive(HashStable)]\n+pub struct Predicate<'tcx> {\n+    kind: &'tcx PredicateKind<'tcx>,\n+}\n+\n+impl<'tcx> PartialEq for Predicate<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        // `self.kind` is always interned.\n+        ptr::eq(self.kind, other.kind)\n+    }\n+}\n+\n+impl<'tcx> Eq for Predicate<'tcx> {}\n+\n+impl<'tcx> Predicate<'tcx> {\n+    #[inline(always)]\n+    pub fn kind(self) -> &'tcx PredicateKind<'tcx> {\n+        self.kind\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, TypeFoldable)]\n-pub enum Predicate<'tcx> {\n+pub enum PredicateKind<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n@@ -1039,7 +1061,7 @@ pub enum Predicate<'tcx> {\n     Projection(PolyProjectionPredicate<'tcx>),\n \n     /// No syntax: `T` well-formed.\n-    WellFormed(Ty<'tcx>),\n+    WellFormed(GenericArg<'tcx>),\n \n     /// Trait must be object-safe.\n     ObjectSafe(DefId),\n@@ -1073,20 +1095,14 @@ pub struct CratePredicatesMap<'tcx> {\n     pub predicates: FxHashMap<DefId, &'tcx [(ty::Predicate<'tcx>, Span)]>,\n }\n \n-impl<'tcx> AsRef<Predicate<'tcx>> for Predicate<'tcx> {\n-    fn as_ref(&self) -> &Predicate<'tcx> {\n-        self\n-    }\n-}\n-\n impl<'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n     /// poly-trait-ref holds. This is slightly different from a normal\n     /// substitution in terms of what happens with bound regions. See\n     /// lengthy comment below for details.\n     pub fn subst_supertrait(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n     ) -> ty::Predicate<'tcx> {\n@@ -1151,34 +1167,37 @@ impl<'tcx> Predicate<'tcx> {\n         // this trick achieves that).\n \n         let substs = &trait_ref.skip_binder().substs;\n-        match *self {\n-            Predicate::Trait(ref binder, constness) => {\n-                Predicate::Trait(binder.map_bound(|data| data.subst(tcx, substs)), constness)\n+        let kind = self.kind();\n+        let new = match kind {\n+            &PredicateKind::Trait(ref binder, constness) => {\n+                PredicateKind::Trait(binder.map_bound(|data| data.subst(tcx, substs)), constness)\n             }\n-            Predicate::Subtype(ref binder) => {\n-                Predicate::Subtype(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::Subtype(binder) => {\n+                PredicateKind::Subtype(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::RegionOutlives(ref binder) => {\n-                Predicate::RegionOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::RegionOutlives(binder) => {\n+                PredicateKind::RegionOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::TypeOutlives(ref binder) => {\n-                Predicate::TypeOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::TypeOutlives(binder) => {\n+                PredicateKind::TypeOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::Projection(ref binder) => {\n-                Predicate::Projection(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::Projection(binder) => {\n+                PredicateKind::Projection(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::WellFormed(data) => Predicate::WellFormed(data.subst(tcx, substs)),\n-            Predicate::ObjectSafe(trait_def_id) => Predicate::ObjectSafe(trait_def_id),\n-            Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                Predicate::ClosureKind(closure_def_id, closure_substs.subst(tcx, substs), kind)\n+            &PredicateKind::WellFormed(data) => PredicateKind::WellFormed(data.subst(tcx, substs)),\n+            &PredicateKind::ObjectSafe(trait_def_id) => PredicateKind::ObjectSafe(trait_def_id),\n+            &PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                PredicateKind::ClosureKind(closure_def_id, closure_substs.subst(tcx, substs), kind)\n             }\n-            Predicate::ConstEvaluatable(def_id, const_substs) => {\n-                Predicate::ConstEvaluatable(def_id, const_substs.subst(tcx, substs))\n+            &PredicateKind::ConstEvaluatable(def_id, const_substs) => {\n+                PredicateKind::ConstEvaluatable(def_id, const_substs.subst(tcx, substs))\n             }\n-            Predicate::ConstEquate(c1, c2) => {\n-                Predicate::ConstEquate(c1.subst(tcx, substs), c2.subst(tcx, substs))\n+            PredicateKind::ConstEquate(c1, c2) => {\n+                PredicateKind::ConstEquate(c1.subst(tcx, substs), c2.subst(tcx, substs))\n             }\n-        }\n+        };\n+\n+        if new != *kind { new.to_predicate(tcx) } else { self }\n     }\n }\n \n@@ -1191,17 +1210,17 @@ pub struct TraitPredicate<'tcx> {\n pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n \n impl<'tcx> TraitPredicate<'tcx> {\n-    pub fn def_id(&self) -> DefId {\n+    pub fn def_id(self) -> DefId {\n         self.trait_ref.def_id\n     }\n \n-    pub fn self_ty(&self) -> Ty<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n         self.trait_ref.self_ty()\n     }\n }\n \n impl<'tcx> PolyTraitPredicate<'tcx> {\n-    pub fn def_id(&self) -> DefId {\n+    pub fn def_id(self) -> DefId {\n         // Ok to skip binder since trait `DefId` does not care about regions.\n         self.skip_binder().def_id()\n     }\n@@ -1293,85 +1312,96 @@ impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n }\n \n pub trait ToPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx>;\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx>;\n+}\n+\n+impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n+    #[inline(always)]\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        tcx.mk_predicate(*self)\n+    }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::PredicateKind::Trait(\n             ty::Binder::dummy(ty::TraitPredicate { trait_ref: self.value }),\n             self.constness,\n         )\n+        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&TraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::PredicateKind::Trait(\n             ty::Binder::dummy(ty::TraitPredicate { trait_ref: *self.value }),\n             self.constness,\n         )\n+        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+            .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&PolyTraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+            .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::RegionOutlives(*self)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        PredicateKind::RegionOutlives(*self).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::TypeOutlives(*self)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        PredicateKind::TypeOutlives(*self).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::Projection(*self)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        PredicateKind::Projection(*self).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> Predicate<'tcx> {\n-    pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {\n-        match *self {\n-            Predicate::Trait(ref t, _) => Some(t.to_poly_trait_ref()),\n-            Predicate::Projection(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::RegionOutlives(..)\n-            | Predicate::WellFormed(..)\n-            | Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::TypeOutlives(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => None,\n+    pub fn to_opt_poly_trait_ref(self) -> Option<PolyTraitRef<'tcx>> {\n+        match self.kind() {\n+            &PredicateKind::Trait(ref t, _) => Some(t.to_poly_trait_ref()),\n+            PredicateKind::Projection(..)\n+            | PredicateKind::Subtype(..)\n+            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::WellFormed(..)\n+            | PredicateKind::ObjectSafe(..)\n+            | PredicateKind::ClosureKind(..)\n+            | PredicateKind::TypeOutlives(..)\n+            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::ConstEquate(..) => None,\n         }\n     }\n \n-    pub fn to_opt_type_outlives(&self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n-        match *self {\n-            Predicate::TypeOutlives(data) => Some(data),\n-            Predicate::Trait(..)\n-            | Predicate::Projection(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::RegionOutlives(..)\n-            | Predicate::WellFormed(..)\n-            | Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => None,\n+    pub fn to_opt_type_outlives(self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n+        match self.kind() {\n+            &PredicateKind::TypeOutlives(data) => Some(data),\n+            PredicateKind::Trait(..)\n+            | PredicateKind::Projection(..)\n+            | PredicateKind::Subtype(..)\n+            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::WellFormed(..)\n+            | PredicateKind::ObjectSafe(..)\n+            | PredicateKind::ClosureKind(..)\n+            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::ConstEquate(..) => None,\n         }\n     }\n }\n@@ -1617,7 +1647,7 @@ pub struct ConstnessAnd<T> {\n     pub value: T,\n }\n \n-// FIXME(ecstaticmorse): Audit all occurrences of `without_const().to_predicate()` to ensure that\n+// FIXME(ecstaticmorse): Audit all occurrences of `without_const().to_predicate(tcx)` to ensure that\n // the constness of trait bounds is being propagated correctly.\n pub trait WithConstness: Sized {\n     #[inline]\n@@ -1816,7 +1846,7 @@ pub struct FieldDef {\n \n /// The definition of a user-defined type, e.g., a `struct`, `enum`, or `union`.\n ///\n-/// These are all interned (by `intern_adt_def`) into the `adt_defs` table.\n+/// These are all interned (by `alloc_adt_def`) into the global arena.\n ///\n /// The initialism *ADT* stands for an [*algebraic data type (ADT)*][adt].\n /// This is slightly wrong because `union`s are not ADTs.\n@@ -2007,6 +2037,8 @@ impl ReprOptions {\n         self.flags.contains(ReprFlags::HIDE_NICHE)\n     }\n \n+    /// Returns the discriminant type, given these `repr` options.\n+    /// This must only be called on enums!\n     pub fn discr_type(&self) -> attr::IntType {\n         self.int.unwrap_or(attr::SignedInt(ast::IntTy::Isize))\n     }\n@@ -2239,6 +2271,7 @@ impl<'tcx> AdtDef {\n \n     #[inline]\n     pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n+        assert!(self.is_enum());\n         let param_env = tcx.param_env(expr_did);\n         let repr_type = self.repr.discr_type();\n         match tcx.const_eval_poly(expr_did) {\n@@ -2275,6 +2308,7 @@ impl<'tcx> AdtDef {\n         &'tcx self,\n         tcx: TyCtxt<'tcx>,\n     ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n+        assert!(self.is_enum());\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx);\n         let mut prev_discr = None::<Discr<'tcx>>;\n@@ -2307,6 +2341,7 @@ impl<'tcx> AdtDef {\n         tcx: TyCtxt<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Discr<'tcx> {\n+        assert!(self.is_enum());\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n         let explicit_value = val\n             .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))"}, {"sha": "1da042e161737ec6f7ebe730d06aa1bf0172bd76", "filename": "src/librustc_middle/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Foutlives.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -70,7 +70,7 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                 // consistent with previous (accidental) behavior.\n                 // See https://github.com/rust-lang/rust/issues/70917\n                 // for further background and discussion.\n-                for &child in substs {\n+                for child in substs {\n                     match child.unpack() {\n                         GenericArgKind::Type(ty) => {\n                             compute_components(tcx, ty, out);"}, {"sha": "7d9943ab07902986478494a6a2e58041d901a5e4", "filename": "src/librustc_middle/ty/print/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -47,7 +47,7 @@ impl DefPathBasedNames<'tcx> {\n             }\n             ty::Tuple(component_types) => {\n                 output.push('(');\n-                for &component_type in component_types {\n+                for component_type in component_types {\n                     self.push_type_name(component_type.expect_ty(), output, debug);\n                     output.push_str(\", \");\n                 }"}, {"sha": "90fb19816179368ae6843daf7f85e19a5ba545dd", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 39, "deletions": 50, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,6 +1,7 @@\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n-use crate::middle::region;\n-use crate::mir::interpret::{sign_extend, truncate, AllocId, ConstValue, Pointer, Scalar};\n+use crate::mir::interpret::{\n+    sign_extend, truncate, AllocId, ConstValue, GlobalAlloc, Pointer, Scalar,\n+};\n use crate::ty::layout::IntegerExt;\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n@@ -495,7 +496,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Never => p!(write(\"!\")),\n             ty::Tuple(ref tys) => {\n-                p!(write(\"(\"), comma_sep(tys.iter().copied()));\n+                p!(write(\"(\"), comma_sep(tys.iter()));\n                 if tys.len() == 1 {\n                     p!(write(\",\"));\n                 }\n@@ -560,7 +561,7 @@ pub trait PrettyPrinter<'tcx>:\n                         // FIXME(eddyb) print this with `print_def_path`.\n                         if !substs.is_empty() {\n                             p!(write(\"::\"));\n-                            p!(generic_delimiters(|cx| cx.comma_sep(substs.iter().copied())));\n+                            p!(generic_delimiters(|cx| cx.comma_sep(substs.iter())));\n                         }\n                         return Ok(self);\n                     }\n@@ -611,7 +612,7 @@ pub trait PrettyPrinter<'tcx>:\n                         let mut sep = \" \";\n                         for (&var_id, upvar_ty) in self\n                             .tcx()\n-                            .upvars(did)\n+                            .upvars_mentioned(did)\n                             .as_ref()\n                             .iter()\n                             .flat_map(|v| v.keys())\n@@ -660,7 +661,7 @@ pub trait PrettyPrinter<'tcx>:\n                         let mut sep = \" \";\n                         for (&var_id, upvar_ty) in self\n                             .tcx()\n-                            .upvars(did)\n+                            .upvars_mentioned(did)\n                             .as_ref()\n                             .iter()\n                             .flat_map(|v| v.keys())\n@@ -952,15 +953,20 @@ pub trait PrettyPrinter<'tcx>:\n                     },\n                     _,\n                 ),\n-            ) => {\n-                let byte_str = self\n-                    .tcx()\n-                    .global_alloc(ptr.alloc_id)\n-                    .unwrap_memory()\n-                    .get_bytes(&self.tcx(), ptr, Size::from_bytes(*data))\n-                    .unwrap();\n-                p!(pretty_print_byte_str(byte_str));\n-            }\n+            ) => match self.tcx().get_global_alloc(ptr.alloc_id) {\n+                Some(GlobalAlloc::Memory(alloc)) => {\n+                    if let Ok(byte_str) = alloc.get_bytes(&self.tcx(), ptr, Size::from_bytes(*data))\n+                    {\n+                        p!(pretty_print_byte_str(byte_str))\n+                    } else {\n+                        p!(write(\"<too short allocation>\"))\n+                    }\n+                }\n+                // FIXME: for statics and functions, we could in principle print more detail.\n+                Some(GlobalAlloc::Static(def_id)) => p!(write(\"<static({:?})>\", def_id)),\n+                Some(GlobalAlloc::Function(_)) => p!(write(\"<function>\")),\n+                None => p!(write(\"<dangling pointer>\")),\n+            },\n             // Bool\n             (Scalar::Raw { data: 0, .. }, ty::Bool) => p!(write(\"false\")),\n             (Scalar::Raw { data: 1, .. }, ty::Bool) => p!(write(\"true\")),\n@@ -1019,6 +1025,9 @@ pub trait PrettyPrinter<'tcx>:\n                 )?;\n             }\n             (Scalar::Ptr(ptr), ty::FnPtr(_)) => {\n+                // FIXME: this can ICE when the ptr is dangling or points to a non-function.\n+                // We should probably have a helper method to share code with the \"Byte strings\"\n+                // printing above (which also has to handle pointers to all sorts of things).\n                 let instance = self.tcx().global_alloc(ptr.alloc_id).unwrap_fn();\n                 self = self.typed_value(\n                     |this| this.print_value_path(instance.def_id(), instance.substs),\n@@ -1588,9 +1597,9 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n                 false\n             }\n \n-            ty::ReScope(_) | ty::ReVar(_) if identify_regions => true,\n+            ty::ReVar(_) if identify_regions => true,\n \n-            ty::ReVar(_) | ty::ReScope(_) | ty::ReErased => false,\n+            ty::ReVar(_) | ty::ReErased => false,\n \n             ty::ReStatic | ty::ReEmpty(_) => true,\n         }\n@@ -1666,32 +1675,12 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n                     }\n                 }\n             }\n-            ty::ReScope(scope) if identify_regions => {\n-                match scope.data {\n-                    region::ScopeData::Node => p!(write(\"'{}s\", scope.item_local_id().as_usize())),\n-                    region::ScopeData::CallSite => {\n-                        p!(write(\"'{}cs\", scope.item_local_id().as_usize()))\n-                    }\n-                    region::ScopeData::Arguments => {\n-                        p!(write(\"'{}as\", scope.item_local_id().as_usize()))\n-                    }\n-                    region::ScopeData::Destruction => {\n-                        p!(write(\"'{}ds\", scope.item_local_id().as_usize()))\n-                    }\n-                    region::ScopeData::Remainder(first_statement_index) => p!(write(\n-                        \"'{}_{}rs\",\n-                        scope.item_local_id().as_usize(),\n-                        first_statement_index.index()\n-                    )),\n-                }\n-                return Ok(self);\n-            }\n             ty::ReVar(region_vid) if identify_regions => {\n                 p!(write(\"{:?}\", region_vid));\n                 return Ok(self);\n             }\n             ty::ReVar(_) => {}\n-            ty::ReScope(_) | ty::ReErased => {}\n+            ty::ReErased => {}\n             ty::ReStatic => {\n                 p!(write(\"'static\"));\n                 return Ok(self);\n@@ -1935,7 +1924,7 @@ define_print_and_forward_display! {\n     (self, cx):\n \n     &'tcx ty::List<Ty<'tcx>> {\n-        p!(write(\"{{\"), comma_sep(self.iter().copied()), write(\"}}\"))\n+        p!(write(\"{{\"), comma_sep(self.iter()), write(\"}}\"))\n     }\n \n     ty::TypeAndMut<'tcx> {\n@@ -2031,34 +2020,34 @@ define_print_and_forward_display! {\n     }\n \n     ty::Predicate<'tcx> {\n-        match *self {\n-            ty::Predicate::Trait(ref data, constness) => {\n+        match self.kind() {\n+            &ty::PredicateKind::Trait(ref data, constness) => {\n                 if let hir::Constness::Const = constness {\n                     p!(write(\"const \"));\n                 }\n                 p!(print(data))\n             }\n-            ty::Predicate::Subtype(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::RegionOutlives(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::TypeOutlives(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::Projection(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n+            ty::PredicateKind::Subtype(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::RegionOutlives(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::TypeOutlives(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::Projection(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n+            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 p!(write(\"the trait `\"),\n                    print_def_path(trait_def_id, &[]),\n                    write(\"` is object-safe\"))\n             }\n-            ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n+            &ty::PredicateKind::ClosureKind(closure_def_id, _closure_substs, kind) => {\n                 p!(write(\"the closure `\"),\n                    print_value_path(closure_def_id, &[]),\n                    write(\"` implements the trait `{}`\", kind))\n             }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 p!(write(\"the constant `\"),\n                    print_value_path(def_id, substs),\n                    write(\"` can be evaluated\"))\n             }\n-            ty::Predicate::ConstEquate(c1, c2) => {\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n                 p!(write(\"the constant `\"),\n                    print(c1),\n                    write(\"` equals `\"),"}, {"sha": "35d19b7603fafa8483ab743fb26778e3eda24df0", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -4,8 +4,8 @@ use crate::hir::map;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintLevelMap;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use crate::middle::cstore::{CrateSource, DepKind, NativeLibraryKind};\n-use crate::middle::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLibrary};\n+use crate::middle::cstore::{CrateSource, DepKind};\n+use crate::middle::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use crate::middle::lib_features::LibFeatures;\n use crate::middle::privacy::AccessLevels;\n@@ -27,7 +27,7 @@ use crate::traits::query::{\n     OutlivesBound,\n };\n use crate::traits::specialization_graph;\n-use crate::traits::{self, Vtable};\n+use crate::traits::{self, ImplSource};\n use crate::ty::steal::Steal;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n@@ -46,6 +46,7 @@ use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, HirIdSet, ItemLocalId, TraitCandidate};\n use rustc_index::vec::IndexVec;\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n+use rustc_session::utils::NativeLibKind;\n use rustc_session::CrateDisambiguator;\n use rustc_target::spec::PanicStrategy;\n "}, {"sha": "4eae06742d9d35363363c7d9f0dc726f08d026d9", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -6,7 +6,7 @@ use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, Once};\n+use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n@@ -49,7 +49,7 @@ pub struct OnDiskCache<'sess> {\n     current_diagnostics: Lock<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n \n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n-    cnum_map: Once<IndexVec<CrateNum, Option<CrateNum>>>,\n+    cnum_map: OnceCell<IndexVec<CrateNum, Option<CrateNum>>>,\n \n     source_map: &'sess SourceMap,\n     file_index_to_stable_id: FxHashMap<SourceFileIndex, StableSourceFileId>,\n@@ -128,7 +128,7 @@ impl<'sess> OnDiskCache<'sess> {\n             file_index_to_stable_id: footer.file_index_to_stable_id,\n             file_index_to_file: Default::default(),\n             prev_cnums: footer.prev_cnums,\n-            cnum_map: Once::new(),\n+            cnum_map: OnceCell::new(),\n             source_map: sess.source_map(),\n             current_diagnostics: Default::default(),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n@@ -144,7 +144,7 @@ impl<'sess> OnDiskCache<'sess> {\n             file_index_to_stable_id: Default::default(),\n             file_index_to_file: Default::default(),\n             prev_cnums: vec![],\n-            cnum_map: Once::new(),\n+            cnum_map: OnceCell::new(),\n             source_map,\n             current_diagnostics: Default::default(),\n             query_result_index: Default::default(),\n@@ -370,14 +370,14 @@ impl<'sess> OnDiskCache<'sess> {\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n \n-        // Initialize `cnum_map` using the value from the thread that finishes the closure first.\n-        self.cnum_map.init_nonlocking_same(|| Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n+        let cnum_map =\n+            self.cnum_map.get_or_init(|| Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n \n         let mut decoder = CacheDecoder {\n             tcx,\n             opaque: opaque::Decoder::new(&self.serialized_data[..], pos.to_usize()),\n             source_map: self.source_map,\n-            cnum_map: self.cnum_map.get(),\n+            cnum_map,\n             synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,"}, {"sha": "d507fcbc19404ff69002dfc65e22ba50240bbce4", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -143,7 +143,7 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n \n     let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-        relation.relate_with_variance(variance, a, b)\n+        relation.relate_with_variance(variance, &a, &b)\n     });\n \n     Ok(tcx.mk_substs(params)?)\n@@ -319,7 +319,7 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n     ) -> RelateResult<'tcx, GeneratorWitness<'tcx>> {\n         assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n-        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(a, b)))?;\n+        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(&a, &b)))?;\n         Ok(GeneratorWitness(types))\n     }\n }\n@@ -633,7 +633,7 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n         let tcx = relation.tcx();\n         let v = a.iter().zip(b.iter()).map(|(ep_a, ep_b)| {\n             use crate::ty::ExistentialPredicate::*;\n-            match (*ep_a, *ep_b) {\n+            match (ep_a, ep_b) {\n                 (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),\n                 (Projection(ref a), Projection(ref b)) => Ok(Projection(relation.relate(a, b)?)),\n                 (AutoTrait(ref a), AutoTrait(ref b)) if a == b => Ok(AutoTrait(*a)),"}, {"sha": "f6f5dfd651612dbbc5e3376558218a2191f31bc9", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 57, "deletions": 34, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -87,8 +87,6 @@ impl fmt::Debug for ty::RegionKind {\n \n             ty::ReFree(ref fr) => fr.fmt(f),\n \n-            ty::ReScope(id) => write!(f, \"ReScope({:?})\", id),\n-\n             ty::ReStatic => write!(f, \"ReStatic\"),\n \n             ty::ReVar(ref vid) => vid.fmt(f),\n@@ -220,27 +218,35 @@ impl fmt::Debug for ty::ProjectionPredicate<'tcx> {\n }\n \n impl fmt::Debug for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self.kind())\n+    }\n+}\n+\n+impl fmt::Debug for ty::PredicateKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            ty::Predicate::Trait(ref a, constness) => {\n+            ty::PredicateKind::Trait(ref a, constness) => {\n                 if let hir::Constness::Const = constness {\n                     write!(f, \"const \")?;\n                 }\n                 a.fmt(f)\n             }\n-            ty::Predicate::Subtype(ref pair) => pair.fmt(f),\n-            ty::Predicate::RegionOutlives(ref pair) => pair.fmt(f),\n-            ty::Predicate::TypeOutlives(ref pair) => pair.fmt(f),\n-            ty::Predicate::Projection(ref pair) => pair.fmt(f),\n-            ty::Predicate::WellFormed(ty) => write!(f, \"WellFormed({:?})\", ty),\n-            ty::Predicate::ObjectSafe(trait_def_id) => write!(f, \"ObjectSafe({:?})\", trait_def_id),\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::Subtype(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::RegionOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::TypeOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::Projection(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::WellFormed(data) => write!(f, \"WellFormed({:?})\", data),\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+            }\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n             }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n             }\n-            ty::Predicate::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n+            ty::PredicateKind::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n         }\n     }\n }\n@@ -467,37 +473,39 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n-    type Lifted = ty::Predicate<'tcx>;\n+impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n+    type Lifted = ty::PredicateKind<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            ty::Predicate::Trait(ref binder, constness) => {\n-                tcx.lift(binder).map(|binder| ty::Predicate::Trait(binder, constness))\n+            ty::PredicateKind::Trait(ref binder, constness) => {\n+                tcx.lift(binder).map(|binder| ty::PredicateKind::Trait(binder, constness))\n             }\n-            ty::Predicate::Subtype(ref binder) => tcx.lift(binder).map(ty::Predicate::Subtype),\n-            ty::Predicate::RegionOutlives(ref binder) => {\n-                tcx.lift(binder).map(ty::Predicate::RegionOutlives)\n+            ty::PredicateKind::Subtype(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::Subtype)\n             }\n-            ty::Predicate::TypeOutlives(ref binder) => {\n-                tcx.lift(binder).map(ty::Predicate::TypeOutlives)\n+            ty::PredicateKind::RegionOutlives(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::RegionOutlives)\n             }\n-            ty::Predicate::Projection(ref binder) => {\n-                tcx.lift(binder).map(ty::Predicate::Projection)\n+            ty::PredicateKind::TypeOutlives(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::TypeOutlives)\n             }\n-            ty::Predicate::WellFormed(ty) => tcx.lift(&ty).map(ty::Predicate::WellFormed),\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::Projection(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::Projection)\n+            }\n+            ty::PredicateKind::WellFormed(ty) => tcx.lift(&ty).map(ty::PredicateKind::WellFormed),\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 tcx.lift(&closure_substs).map(|closure_substs| {\n-                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind)\n+                    ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n                 })\n             }\n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n-                Some(ty::Predicate::ObjectSafe(trait_def_id))\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                Some(ty::PredicateKind::ObjectSafe(trait_def_id))\n             }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                tcx.lift(&substs).map(|substs| ty::Predicate::ConstEvaluatable(def_id, substs))\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+                tcx.lift(&substs).map(|substs| ty::PredicateKind::ConstEvaluatable(def_id, substs))\n             }\n-            ty::Predicate::ConstEquate(c1, c2) => {\n-                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::Predicate::ConstEquate(c1, c2))\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n+                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateKind::ConstEquate(c1, c2))\n             }\n         }\n     }\n@@ -977,6 +985,17 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let new = ty::PredicateKind::super_fold_with(self.kind, folder);\n+        if new != *self.kind { folder.tcx().mk_predicate(new) } else { *self }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        ty::PredicateKind::super_visit_with(self.kind, visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         fold_list(*self, folder, |tcx, v| tcx.intern_predicates(v))\n@@ -1001,7 +1020,11 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let ty = self.ty.fold_with(folder);\n         let val = self.val.fold_with(folder);\n-        folder.tcx().mk_const(ty::Const { ty, val })\n+        if ty != self.ty || val != self.val {\n+            folder.tcx().mk_const(ty::Const { ty, val })\n+        } else {\n+            *self\n+        }\n     }\n \n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n@@ -1073,7 +1096,7 @@ where\n     // Look for the first element that changed\n     if let Some((i, new_t)) = iter.by_ref().enumerate().find_map(|(i, t)| {\n         let new_t = t.fold_with(folder);\n-        if new_t == *t { None } else { Some((i, new_t)) }\n+        if new_t == t { None } else { Some((i, new_t)) }\n     }) {\n         // An element changed, prepare to intern the resulting list\n         let mut new_list = SmallVec::<[_; 8]>::with_capacity(list.len());"}, {"sha": "5d4c2a54267c37d297ef0616330c2e23bc80c63e", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -6,7 +6,6 @@ use self::InferTy::*;\n use self::TyKind::*;\n \n use crate::infer::canonical::Canonical;\n-use crate::middle::region;\n use crate::mir::interpret::ConstValue;\n use crate::mir::interpret::{LitToConstInput, Scalar};\n use crate::mir::Promoted;\n@@ -30,6 +29,7 @@ use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::marker::PhantomData;\n use std::ops::Range;\n+use ty::util::IntTypeExt;\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n@@ -612,15 +612,16 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n         use crate::ty::ToPredicate;\n         match *self.skip_binder() {\n             ExistentialPredicate::Trait(tr) => {\n-                Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate()\n+                Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n             }\n             ExistentialPredicate::Projection(p) => {\n-                ty::Predicate::Projection(Binder(p.with_self_ty(tcx, self_ty)))\n+                ty::PredicateKind::Projection(Binder(p.with_self_ty(tcx, self_ty)))\n+                    .to_predicate(tcx)\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n                 let trait_ref =\n                     Binder(ty::TraitRef { def_id: did, substs: tcx.mk_substs_trait(self_ty, &[]) });\n-                trait_ref.without_const().to_predicate()\n+                trait_ref.without_const().to_predicate(tcx)\n             }\n         }\n     }\n@@ -669,15 +670,15 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     pub fn projection_bounds<'a>(\n         &'a self,\n     ) -> impl Iterator<Item = ExistentialProjection<'tcx>> + 'a {\n-        self.iter().filter_map(|predicate| match *predicate {\n+        self.iter().filter_map(|predicate| match predicate {\n             ExistentialPredicate::Projection(projection) => Some(projection),\n             _ => None,\n         })\n     }\n \n     #[inline]\n     pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item = DefId> + 'a {\n-        self.iter().filter_map(|predicate| match *predicate {\n+        self.iter().filter_map(|predicate| match predicate {\n             ExistentialPredicate::AutoTrait(did) => Some(did),\n             _ => None,\n         })\n@@ -708,7 +709,7 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n     pub fn iter<'a>(\n         &'a self,\n     ) -> impl DoubleEndedIterator<Item = Binder<ExistentialPredicate<'tcx>>> + 'tcx {\n-        self.skip_binder().iter().cloned().map(Binder::bind)\n+        self.skip_binder().iter().map(Binder::bind)\n     }\n }\n \n@@ -723,10 +724,6 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n ///\n /// Trait references also appear in object types like `Foo<U>`, but in\n /// that case the `Self` parameter is absent from the substitutions.\n-///\n-/// Note that a `TraitRef` introduces a level of region binding, to\n-/// account for higher-ranked trait bounds like `T: for<'a> Foo<&'a U>`\n-/// or higher-ranked object types.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct TraitRef<'tcx> {\n@@ -764,8 +761,8 @@ impl<'tcx> TraitRef<'tcx> {\n pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n \n impl<'tcx> PolyTraitRef<'tcx> {\n-    pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.skip_binder().self_ty()\n+    pub fn self_ty(&self) -> Binder<Ty<'tcx>> {\n+        self.map_bound_ref(|tr| tr.self_ty())\n     }\n \n     pub fn def_id(&self) -> DefId {\n@@ -1178,25 +1175,22 @@ rustc_index::newtype_index! {\n \n pub type Region<'tcx> = &'tcx RegionKind;\n \n-/// Representation of (lexical) regions. Note that the NLL checker\n-/// uses a distinct representation of regions. For this reason, it\n-/// internally replaces all the regions with inference variables --\n-/// the index of the variable is then used to index into internal NLL\n-/// data structures. See `rustc_mir::borrow_check` module for more\n-/// information.\n+/// Representation of regions. Note that the NLL checker uses a distinct\n+/// representation of regions. For this reason, it internally replaces all the\n+/// regions with inference variables -- the index of the variable is then used\n+/// to index into internal NLL data structures. See `rustc_mir::borrow_check`\n+/// module for more information.\n ///\n /// ## The Region lattice within a given function\n ///\n-/// In general, the (lexical, and hence deprecated) region lattice\n-/// looks like\n+/// In general, the region lattice looks like\n ///\n /// ```\n /// static ----------+-----...------+       (greatest)\n /// |                |              |\n /// early-bound and  |              |\n /// free regions     |              |\n /// |                |              |\n-/// scope regions    |              |\n /// |                |              |\n /// empty(root)   placeholder(U1)   |\n /// |            /                  |\n@@ -1211,13 +1205,7 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// Early-bound/free regions are the named lifetimes in scope from the\n /// function declaration. They have relationships to one another\n /// determined based on the declared relationships from the\n-/// function. They all collectively outlive the scope regions. (See\n-/// `RegionRelations` type, and particularly\n-/// `crate::infer::outlives::free_region_map::FreeRegionMap`.)\n-///\n-/// The scope regions are related to one another based on the AST\n-/// structure. (See `RegionRelations` type, and particularly the\n-/// `rustc_middle::middle::region::ScopeTree`.)\n+/// function.\n ///\n /// Note that inference variables and bound regions are not included\n /// in this diagram. In the case of inference variables, they should\n@@ -1306,11 +1294,6 @@ pub enum RegionKind {\n     /// region parameters.\n     ReFree(FreeRegion),\n \n-    /// A concrete region naming some statically determined scope\n-    /// (e.g., an expression or sequence of statements) within the\n-    /// current function.\n-    ReScope(region::Scope),\n-\n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     ReStatic,\n \n@@ -1534,7 +1517,6 @@ impl RegionKind {\n             RegionKind::ReEarlyBound(ebr) => ebr.has_name(),\n             RegionKind::ReLateBound(_, br) => br.is_named(),\n             RegionKind::ReFree(fr) => fr.bound_region.is_named(),\n-            RegionKind::ReScope(..) => false,\n             RegionKind::ReStatic => true,\n             RegionKind::ReVar(..) => false,\n             RegionKind::RePlaceholder(placeholder) => placeholder.name.is_named(),\n@@ -1615,7 +1597,7 @@ impl RegionKind {\n                 flags = flags | TypeFlags::HAS_RE_PARAM;\n                 flags = flags | TypeFlags::STILL_FURTHER_SPECIALIZABLE;\n             }\n-            ty::ReFree { .. } | ty::ReScope { .. } => {\n+            ty::ReFree { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n             }\n@@ -2111,14 +2093,28 @@ impl<'tcx> TyS<'tcx> {\n         variant_index: VariantIdx,\n     ) -> Option<Discr<'tcx>> {\n         match self.kind {\n-            TyKind::Adt(adt, _) => Some(adt.discriminant_for_variant(tcx, variant_index)),\n+            TyKind::Adt(adt, _) if adt.is_enum() => {\n+                Some(adt.discriminant_for_variant(tcx, variant_index))\n+            }\n             TyKind::Generator(def_id, substs, _) => {\n                 Some(substs.as_generator().discriminant_for_variant(def_id, tcx, variant_index))\n             }\n             _ => None,\n         }\n     }\n \n+    /// Returns the type of the discriminant of this type.\n+    pub fn discriminant_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        match self.kind {\n+            ty::Adt(adt, _) if adt.is_enum() => adt.repr.discr_type().to_ty(tcx),\n+            ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n+            _ => {\n+                // This can only be `0`, for now, so `u8` will suffice.\n+                tcx.types.u8\n+            }\n+        }\n+    }\n+\n     /// When we create a closure, we record its kind (i.e., what trait\n     /// it implements) into its `ClosureSubsts` using a type\n     /// parameter. This is kind of a phantom type, except that the"}, {"sha": "1529f1173b391caea5df017e76d86b1e957eb646", "filename": "src/librustc_middle/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsubst.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -340,11 +340,11 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n         target_substs: SubstsRef<'tcx>,\n     ) -> SubstsRef<'tcx> {\n         let defs = tcx.generics_of(source_ancestor);\n-        tcx.mk_substs(target_substs.iter().chain(&self[defs.params.len()..]).cloned())\n+        tcx.mk_substs(target_substs.iter().chain(self.iter().skip(defs.params.len())))\n     }\n \n     pub fn truncate_to(&self, tcx: TyCtxt<'tcx>, generics: &ty::Generics) -> SubstsRef<'tcx> {\n-        tcx.mk_substs(self.iter().take(generics.count()).cloned())\n+        tcx.mk_substs(self.iter().take(generics.count()))\n     }\n }\n "}, {"sha": "c2b794ca4bdd9e0ed5e3d6a2ca0a16ed795551f6", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -413,7 +413,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let result = item_substs\n             .iter()\n             .zip(impl_substs.iter())\n-            .filter(|&(_, &k)| {\n+            .filter(|&(_, k)| {\n                 match k.unpack() {\n                     GenericArgKind::Lifetime(&ty::RegionKind::ReEarlyBound(ref ebr)) => {\n                         !impl_generics.region_param(ebr, self).pure_wrt_drop\n@@ -433,7 +433,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n             })\n-            .map(|(&item_param, _)| item_param)\n+            .map(|(item_param, _)| item_param)\n             .collect();\n         debug!(\"destructor_constraint({:?}) = {:?}\", def.did, result);\n         result"}, {"sha": "bf988a430263303e9687dae8e9d2ef91d26c56b2", "filename": "src/librustc_middle/ty/walk.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fwalk.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -128,7 +128,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 stack.push(lt.into());\n             }\n             ty::Projection(data) => {\n-                stack.extend(data.substs.iter().copied().rev());\n+                stack.extend(data.substs.iter().rev());\n             }\n             ty::Dynamic(obj, lt) => {\n                 stack.push(lt.into());\n@@ -143,7 +143,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                         }\n                     };\n \n-                    substs.iter().copied().rev().chain(opt_ty.map(|ty| ty.into()))\n+                    substs.iter().rev().chain(opt_ty.map(|ty| ty.into()))\n                 }));\n             }\n             ty::Adt(_, substs)\n@@ -152,14 +152,14 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n             | ty::Generator(_, substs, _)\n             | ty::Tuple(substs)\n             | ty::FnDef(_, substs) => {\n-                stack.extend(substs.iter().copied().rev());\n+                stack.extend(substs.iter().rev());\n             }\n             ty::GeneratorWitness(ts) => {\n-                stack.extend(ts.skip_binder().iter().cloned().rev().map(|ty| ty.into()));\n+                stack.extend(ts.skip_binder().iter().rev().map(|ty| ty.into()));\n             }\n             ty::FnPtr(sig) => {\n                 stack.push(sig.skip_binder().output().into());\n-                stack.extend(sig.skip_binder().inputs().iter().cloned().rev().map(|ty| ty.into()));\n+                stack.extend(sig.skip_binder().inputs().iter().copied().rev().map(|ty| ty.into()));\n             }\n         },\n         GenericArgKind::Lifetime(_) => {}\n@@ -174,7 +174,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 | ty::ConstKind::Error => {}\n \n                 ty::ConstKind::Unevaluated(_, substs, _) => {\n-                    stack.extend(substs.iter().copied().rev());\n+                    stack.extend(substs.iter().rev());\n                 }\n             }\n         }"}, {"sha": "aebce78e4018b731d4e2c926e1c76f247a6ea4f0", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n either = \"1.5.0\"\n-dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n+rustc_graphviz = { path = \"../librustc_graphviz\" }\n itertools = \"0.8\"\n log = \"0.4\"\n log_settings = \"0.1.1\"\n@@ -25,7 +25,7 @@ rustc_index = { path = \"../librustc_index\" }\n rustc_infer = { path = \"../librustc_infer\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_macros = { path = \"../librustc_macros\" }\n-rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_trait_selection = { path = \"../librustc_trait_selection\" }"}, {"sha": "d0050f801fc6bbdd72ddbba27e8b018b255e247c", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -214,7 +214,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let generics = tcx.generics_of(self.mir_def_id);\n                     let param = generics.type_param(&param_ty, tcx);\n                     if let Some(generics) =\n-                        tcx.hir().get_generics(tcx.closure_base_def_id(self.mir_def_id))\n+                        tcx.hir().get_generics(tcx.closure_base_def_id(self.mir_def_id.to_def_id()))\n                     {\n                         suggest_constraining_type_param(\n                             tcx,\n@@ -865,49 +865,42 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n-            if let Some(def_id) = self.mir_def_id.as_local() {\n-                let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id);\n-                err.span_label(\n-                    drop_span,\n-                    format!(\n-                        \"...but `{}` will be dropped here, when the {} returns\",\n-                        name,\n-                        self.infcx\n-                            .tcx\n-                            .hir()\n-                            .opt_name(fn_hir_id)\n-                            .map(|name| format!(\"function `{}`\", name))\n-                            .unwrap_or_else(|| {\n-                                match &self\n-                                    .infcx\n-                                    .tcx\n-                                    .typeck_tables_of(def_id)\n-                                    .node_type(fn_hir_id)\n-                                    .kind\n-                                {\n-                                    ty::Closure(..) => \"enclosing closure\",\n-                                    ty::Generator(..) => \"enclosing generator\",\n-                                    kind => bug!(\"expected closure or generator, found {:?}\", kind),\n-                                }\n-                                .to_string()\n-                            })\n-                    ),\n-                );\n+            let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n+            err.span_label(\n+                drop_span,\n+                format!(\n+                    \"...but `{}` will be dropped here, when the {} returns\",\n+                    name,\n+                    self.infcx\n+                        .tcx\n+                        .hir()\n+                        .opt_name(fn_hir_id)\n+                        .map(|name| format!(\"function `{}`\", name))\n+                        .unwrap_or_else(|| {\n+                            match &self\n+                                .infcx\n+                                .tcx\n+                                .typeck_tables_of(self.mir_def_id)\n+                                .node_type(fn_hir_id)\n+                                .kind\n+                            {\n+                                ty::Closure(..) => \"enclosing closure\",\n+                                ty::Generator(..) => \"enclosing generator\",\n+                                kind => bug!(\"expected closure or generator, found {:?}\", kind),\n+                            }\n+                            .to_string()\n+                        })\n+                ),\n+            );\n \n-                err.note(\n-                    \"functions cannot return a borrow to data owned within the function's scope, \\\n-                     functions can only return borrows to data passed as arguments\",\n-                );\n-                err.note(\n-                    \"to learn more, visit <https://doc.rust-lang.org/book/ch04-02-\\\n-                     references-and-borrowing.html#dangling-references>\",\n-                );\n-            } else {\n-                err.span_label(\n-                    drop_span,\n-                    format!(\"...but `{}` dropped here while still borrowed\", name),\n-                );\n-            }\n+            err.note(\n+                \"functions cannot return a borrow to data owned within the function's scope, \\\n+                    functions can only return borrows to data passed as arguments\",\n+            );\n+            err.note(\n+                \"to learn more, visit <https://doc.rust-lang.org/book/ch04-02-\\\n+                    references-and-borrowing.html#dangling-references>\",\n+            );\n \n             if let BorrowExplanation::MustBeValidFor { .. } = explanation {\n             } else {\n@@ -1237,7 +1230,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> DiagnosticBuilder<'cx> {\n         let tcx = self.infcx.tcx;\n \n-        let (_, escapes_from) = tcx.article_and_description(self.mir_def_id);\n+        let (_, escapes_from) = tcx.article_and_description(self.mir_def_id.to_def_id());\n \n         let mut err =\n             borrowck_errors::borrowed_data_escapes_closure(tcx, escape_span, escapes_from);\n@@ -1572,14 +1565,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         // Define a fallback for when we can't match a closure.\n         let fallback = || {\n-            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n+            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id.to_def_id());\n             if is_closure {\n                 None\n             } else {\n                 let ty = self.infcx.tcx.type_of(self.mir_def_id);\n                 match ty.kind {\n-                    ty::FnDef(_, _) | ty::FnPtr(_) => self\n-                        .annotate_fn_sig(self.mir_def_id, self.infcx.tcx.fn_sig(self.mir_def_id)),\n+                    ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n+                        self.mir_def_id.to_def_id(),\n+                        self.infcx.tcx.fn_sig(self.mir_def_id),\n+                    ),\n                     _ => None,\n                 }\n             }"}, {"sha": "ca8e54ea286491d2112bd266a71ab21a1917db80", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -377,11 +377,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.describe_field_from_ty(&ty, field, variant_index)\n                 }\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                    // `tcx.upvars(def_id)` returns an `Option`, which is `None` in case\n+                    // `tcx.upvars_mentioned(def_id)` returns an `Option`, which is `None` in case\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n-                    let (&var_id, _) =\n-                        self.infcx.tcx.upvars(def_id).unwrap().get_index(field.index()).unwrap();\n+                    let (&var_id, _) = self\n+                        .infcx\n+                        .tcx\n+                        .upvars_mentioned(def_id)\n+                        .unwrap()\n+                        .get_index(field.index())\n+                        .unwrap();\n \n                     self.infcx.tcx.hir().name(var_id).to_string()\n                 }\n@@ -809,7 +814,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {\n-            for (upvar, place) in self.infcx.tcx.upvars(def_id)?.values().zip(places) {\n+            for (upvar, place) in self.infcx.tcx.upvars_mentioned(def_id)?.values().zip(places) {\n                 match place {\n                     Operand::Copy(place) | Operand::Move(place)\n                         if target_place == place.as_ref() =>"}, {"sha": "b49e4187fb81070124337a95064b142081274184", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 self.cannot_move_out_of_interior_noncopy(span, ty, None)\n             }\n             ty::Closure(def_id, closure_substs)\n-                if def_id == self.mir_def_id && upvar_field.is_some() =>\n+                if def_id.as_local() == Some(self.mir_def_id) && upvar_field.is_some() =>\n             {\n                 let closure_kind_ty = closure_substs.as_closure().kind_ty();\n                 let closure_kind = closure_kind_ty.to_opt_closure_kind();"}, {"sha": "e04ed8b83debd94509c692098c517f03abb96de4", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -492,7 +492,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err.span_label(sp, format!(\"cannot {}\", act));\n \n         let hir = self.infcx.tcx.hir();\n-        let closure_id = hir.as_local_hir_id(self.mir_def_id.expect_local());\n+        let closure_id = hir.as_local_hir_id(self.mir_def_id);\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n         let item_id = hir.get_parent_item(fn_call_id);"}, {"sha": "727c4d0605e124939a1a9c53886d713332f49549", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -162,10 +162,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     let type_test_span = type_test.locations.span(&self.body);\n \n                     if let Some(lower_bound_region) = lower_bound_region {\n-                        let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n                         self.infcx\n                             .construct_generic_bound_failure(\n-                                region_scope_tree,\n                                 type_test_span,\n                                 None,\n                                 type_test.generic_kind,\n@@ -194,12 +192,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n \n                 RegionErrorKind::UnexpectedHiddenRegion { span, hidden_ty, member_region } => {\n-                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n                     let named_ty = self.regioncx.name_regions(self.infcx.tcx, hidden_ty);\n                     let named_region = self.regioncx.name_regions(self.infcx.tcx, member_region);\n                     unexpected_hidden_region_diagnostic(\n                         self.infcx.tcx,\n-                        Some(region_scope_tree),\n                         span,\n                         named_ty,\n                         named_region,\n@@ -502,7 +498,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut diag =\n             self.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n \n-        let (_, mir_def_name) = self.infcx.tcx.article_and_description(self.mir_def_id);\n+        let (_, mir_def_name) = self.infcx.tcx.article_and_description(self.mir_def_id.to_def_id());\n \n         let fr_name = self.give_region_a_name(*fr).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n@@ -576,7 +572,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                     let mut found = false;\n                     for predicate in bounds.predicates {\n-                        if let ty::Predicate::TypeOutlives(binder) = predicate {\n+                        if let ty::PredicateKind::TypeOutlives(binder) = predicate.kind() {\n                             if let ty::OutlivesPredicate(_, ty::RegionKind::ReStatic) =\n                                 binder.skip_binder()\n                             {"}, {"sha": "2240eb81e1fa778aae5d63abc338b6582e11ec39", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -237,8 +237,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id =\n-                        self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n+                    let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(_, substs) = def_ty {\n@@ -284,7 +283,6 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             },\n \n             ty::ReLateBound(..)\n-            | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)\n@@ -324,7 +322,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n     ) -> Option<RegionName> {\n-        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.as_local()?);\n+        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n@@ -635,7 +633,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id);\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n@@ -687,7 +685,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id);\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {"}, {"sha": "77d16458383d1885539d72fe5e3303b5a9ee1481", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -183,7 +183,13 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                     }\n                 }\n             }\n-            TerminatorKind::InlineAsm { template: _, ref operands, options: _, destination: _ } => {\n+            TerminatorKind::InlineAsm {\n+                template: _,\n+                ref operands,\n+                options: _,\n+                line_spans: _,\n+                destination: _,\n+            } => {\n                 for op in operands {\n                     match *op {\n                         InlineAsmOperand::In { reg: _, ref value }\n@@ -209,7 +215,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             TerminatorKind::Goto { target: _ }\n             | TerminatorKind::Abort\n             | TerminatorKind::Unreachable\n-            | TerminatorKind::FalseEdges { real_target: _, imaginary_target: _ }\n+            | TerminatorKind::FalseEdge { real_target: _, imaginary_target: _ }\n             | TerminatorKind::FalseUnwind { real_target: _, unwind: _ } => {\n                 // no data used, thus irrelevant to borrowck\n             }\n@@ -295,6 +301,8 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 self.access_place(location, place, access_kind, LocalMutationIsAllowed::No);\n             }\n \n+            Rvalue::ThreadLocalRef(_) => {}\n+\n             Rvalue::Use(ref operand)\n             | Rvalue::Repeat(ref operand, _)\n             | Rvalue::UnaryOp(_ /*un_op*/, ref operand)"}, {"sha": "736cda83ca5121847da49c0a8520e42a065e7c7a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -4,10 +4,8 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n-use rustc_hir::{\n-    def_id::{DefId, LocalDefId},\n-    HirId, Node,\n-};\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::{HirId, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n@@ -142,7 +140,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         infcx.set_tainted_by_errors();\n     }\n     let upvars: Vec<_> = tables\n-        .upvar_list\n+        .closure_captures\n         .get(&def_id.to_def_id())\n         .into_iter()\n         .flat_map(|v| v.values())\n@@ -174,7 +172,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mut body = input_body.clone();\n     let mut promoted = input_promoted.clone();\n     let free_regions =\n-        nll::replace_regions_in_mir(infcx, def_id.to_def_id(), param_env, &mut body, &mut promoted);\n+        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n     let body = &body; // no further changes\n \n     let location_table = &LocationTable::new(&body);\n@@ -275,7 +273,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n             let mut promoted_mbcx = MirBorrowckCtxt {\n                 infcx,\n                 body: promoted_body,\n-                mir_def_id: def_id.to_def_id(),\n+                mir_def_id: def_id,\n                 move_data: &move_data,\n                 location_table: &LocationTable::new(promoted_body),\n                 movable_generator,\n@@ -307,7 +305,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n         body,\n-        mir_def_id: def_id.to_def_id(),\n+        mir_def_id: def_id,\n         move_data: &mdpe.move_data,\n         location_table,\n         movable_generator,\n@@ -459,7 +457,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n     body: &'cx Body<'tcx>,\n-    mir_def_id: DefId,\n+    mir_def_id: LocalDefId,\n     move_data: &'cx MoveData<'tcx>,\n \n     /// Map from MIR `Location` to `LocationIndex`; created\n@@ -724,7 +722,13 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 self.mutate_place(loc, (resume_arg, span), Deep, JustWrite, flow_state);\n             }\n \n-            TerminatorKind::InlineAsm { template: _, ref operands, options: _, destination: _ } => {\n+            TerminatorKind::InlineAsm {\n+                template: _,\n+                ref operands,\n+                options: _,\n+                line_spans: _,\n+                destination: _,\n+            } => {\n                 for op in operands {\n                     match *op {\n                         InlineAsmOperand::In { reg: _, ref value }\n@@ -766,7 +770,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n             | TerminatorKind::Resume\n             | TerminatorKind::Return\n             | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::FalseEdges { real_target: _, imaginary_target: _ }\n+            | TerminatorKind::FalseEdge { real_target: _, imaginary_target: _ }\n             | TerminatorKind::FalseUnwind { real_target: _, unwind: _ } => {\n                 // no data used, thus irrelevant to borrowck\n             }\n@@ -810,7 +814,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::Drop { .. }\n             | TerminatorKind::DropAndReplace { .. }\n-            | TerminatorKind::FalseEdges { real_target: _, imaginary_target: _ }\n+            | TerminatorKind::FalseEdge { real_target: _, imaginary_target: _ }\n             | TerminatorKind::FalseUnwind { real_target: _, unwind: _ }\n             | TerminatorKind::Goto { .. }\n             | TerminatorKind::SwitchInt { .. }\n@@ -1292,6 +1296,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n+            Rvalue::ThreadLocalRef(_) => {}\n+\n             Rvalue::Use(ref operand)\n             | Rvalue::Repeat(ref operand, _)\n             | Rvalue::UnaryOp(_ /*un_op*/, ref operand)"}, {"sha": "1d3733371473b109cfe1518d81af2f17f1282044", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -58,20 +58,20 @@ crate struct NllOutput<'tcx> {\n /// `compute_regions`.\n pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n-    let universal_regions = UniversalRegions::new(infcx, def_id.expect_local(), param_env);\n+    let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, body, promoted);\n \n-    let source = MirSource::item(def_id);\n+    let source = MirSource::item(def_id.to_def_id());\n     mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body, |_, _| Ok(()));\n \n     universal_regions"}, {"sha": "cadf1ebf1b774c30ef68ae59fbb8e4fd54a3a10b", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         for (i, elem) in self.projection.iter().enumerate() {\n             let proj_base = &self.projection[..i];\n \n-            if *elem == ProjectionElem::Deref {\n+            if elem == ProjectionElem::Deref {\n                 let ty = Place::ty_from(self.local, proj_base, body, tcx).ty;\n                 match ty.kind {\n                     ty::Ref(_, _, hir::Mutability::Not) if i == 0 => {"}, {"sha": "246e4826e0e767676d15355662894392fbe639c6", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -138,7 +138,7 @@ fn place_components_conflict<'tcx>(\n     }\n \n     // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-    for (i, (borrow_c, access_c)) in\n+    for (i, (borrow_c, &access_c)) in\n         borrow_place.projection.iter().zip(access_place.projection.iter()).enumerate()\n     {\n         debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n@@ -313,8 +313,8 @@ fn place_projection_conflict<'tcx>(\n     body: &Body<'tcx>,\n     pi1_local: Local,\n     pi1_proj_base: &[PlaceElem<'tcx>],\n-    pi1_elem: &PlaceElem<'tcx>,\n-    pi2_elem: &PlaceElem<'tcx>,\n+    pi1_elem: PlaceElem<'tcx>,\n+    pi2_elem: PlaceElem<'tcx>,\n     bias: PlaceConflictBias,\n ) -> Overlap {\n     match (pi1_elem, pi2_elem) {\n@@ -449,7 +449,7 @@ fn place_projection_conflict<'tcx>(\n             // element (like -1 in Python) and `min_length` the first.\n             // Therefore, `min_length - offset_from_end` gives the minimal possible\n             // offset from the beginning\n-            if *offset_from_begin >= *min_length - *offset_from_end {\n+            if offset_from_begin >= min_length - offset_from_end {\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-FE\");\n                 Overlap::EqualOrDisjoint\n             } else {"}, {"sha": "a272e922a504e16542ca81cf6fbb1cb04edee271", "filename": "src/librustc_mir/borrow_check/region_infer/graphviz.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fgraphviz.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,12 +1,13 @@\n //! This module provides linkage between RegionInferenceContext and\n-//! libgraphviz traits, specialized to attaching borrowck analysis\n+//! librustc_graphviz traits, specialized to attaching borrowck analysis\n //! data to rendered labels.\n \n use std::borrow::Cow;\n use std::io::{self, Write};\n \n use super::*;\n use crate::borrow_check::constraints::OutlivesConstraint;\n+use rustc_graphviz as dot;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Write out the region constraint graph."}, {"sha": "5df033b48c1f9f5153a1c12005be45a5b0f45c27", "filename": "src/librustc_mir/borrow_check/renumber.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -66,14 +66,14 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n \n     fn process_projection_elem(\n         &mut self,\n-        elem: &PlaceElem<'tcx>,\n+        elem: PlaceElem<'tcx>,\n         _: Location,\n     ) -> Option<PlaceElem<'tcx>> {\n         if let PlaceElem::Field(field, ty) = elem {\n-            let new_ty = self.renumber_regions(ty);\n+            let new_ty = self.renumber_regions(&ty);\n \n-            if new_ty != *ty {\n-                return Some(PlaceElem::Field(*field, new_ty));\n+            if new_ty != ty {\n+                return Some(PlaceElem::Field(field, new_ty));\n             }\n         }\n "}, {"sha": "e2255d170f9c96ac0d8137380713c0e1b18a1f2f", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -27,8 +27,8 @@ use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef, UserSubsts};\n use rustc_middle::ty::{\n-    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPolyTraitRef, Ty,\n-    TyCtxt, UserType, UserTypeAnnotationIndex,\n+    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPolyTraitRef,\n+    ToPredicate, Ty, TyCtxt, UserType, UserTypeAnnotationIndex,\n };\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n@@ -611,14 +611,14 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     fn sanitize_projection(\n         &mut self,\n         base: PlaceTy<'tcx>,\n-        pi: &PlaceElem<'tcx>,\n+        pi: PlaceElem<'tcx>,\n         place: &Place<'tcx>,\n         location: Location,\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, place);\n         let tcx = self.tcx();\n         let base_ty = base.ty;\n-        match *pi {\n+        match pi {\n             ProjectionElem::Deref => {\n                 let deref_ty = base_ty.builtin_deref(true);\n                 PlaceTy::from_ty(deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     self.prove_predicate(\n-                        ty::Predicate::WellFormed(inferred_ty),\n+                        ty::PredicateKind::WellFormed(inferred_ty.into()).to_predicate(self.tcx()),\n                         Locations::All(span),\n                         ConstraintCategory::TypeAnnotation,\n                     );\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     obligations.obligations.push(traits::Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        ty::Predicate::WellFormed(revealed_ty),\n+                        ty::PredicateKind::WellFormed(revealed_ty.into()).to_predicate(infcx.tcx),\n                     ));\n                     obligations.add(\n                         infcx\n@@ -1547,7 +1547,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Drop { .. }\n-            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n             | TerminatorKind::InlineAsm { .. } => {\n                 // no checks needed for these\n@@ -1612,7 +1612,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.check_call_dest(body, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n-                    sig.inputs_and_output.iter().map(|ty| ty::Predicate::WellFormed(ty)),\n+                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKind::WellFormed(ty.into())),\n                     term_location.to_locations(),\n                     ConstraintCategory::Boring,\n                 );\n@@ -1843,7 +1843,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     self.assert_iscleanup(body, block_data, cleanup, true);\n                 }\n             }\n-            TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n+            TerminatorKind::FalseEdge { real_target, imaginary_target } => {\n                 self.assert_iscleanup(body, block_data, real_target, is_cleanup);\n                 self.assert_iscleanup(body, block_data, imaginary_target, is_cleanup);\n             }\n@@ -2017,7 +2017,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                         traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                     ),\n                                     self.param_env,\n-                                    ty::Predicate::Trait(\n+                                    ty::PredicateKind::Trait(\n                                         ty::Binder::bind(ty::TraitPredicate {\n                                             trait_ref: ty::TraitRef::new(\n                                                 self.tcx().require_lang_item(\n@@ -2028,7 +2028,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                             ),\n                                         }),\n                                         hir::Constness::NotConst,\n-                                    ),\n+                                    )\n+                                    .to_predicate(self.tcx()),\n                                 ),\n                                 &traits::SelectionError::Unimplemented,\n                                 false,\n@@ -2352,6 +2353,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             Rvalue::AddressOf(..)\n+            | Rvalue::ThreadLocalRef(..)\n             | Rvalue::Use(..)\n             | Rvalue::Len(..)\n             | Rvalue::BinaryOp(..)\n@@ -2367,6 +2369,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn rvalue_user_ty(&self, rvalue: &Rvalue<'tcx>) -> Option<UserTypeAnnotationIndex> {\n         match rvalue {\n             Rvalue::Use(_)\n+            | Rvalue::ThreadLocalRef(_)\n             | Rvalue::Repeat(..)\n             | Rvalue::Ref(..)\n             | Rvalue::AddressOf(..)\n@@ -2686,7 +2689,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) {\n         self.prove_predicates(\n-            Some(ty::Predicate::Trait(\n+            Some(ty::PredicateKind::Trait(\n                 trait_ref.to_poly_trait_ref().to_poly_trait_predicate(),\n                 hir::Constness::NotConst,\n             )),\n@@ -2708,11 +2711,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n     fn prove_predicates(\n         &mut self,\n-        predicates: impl IntoIterator<Item = ty::Predicate<'tcx>>,\n+        predicates: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) {\n         for predicate in predicates {\n+            let predicate = predicate.to_predicate(self.tcx());\n             debug!(\"prove_predicates(predicate={:?}, locations={:?})\", predicate, locations,);\n \n             self.prove_predicate(predicate, locations, category);"}, {"sha": "695e0741e35989fa35269270871ea830891e7a80", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -89,7 +89,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n     InterpCx::new(\n         tcx.at(span),\n         param_env,\n-        CompileTimeInterpreter::new(*tcx.sess.const_eval_limit.get()),\n+        CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics },\n     )\n }\n@@ -122,7 +122,7 @@ pub(super) fn op_to_const<'tcx>(\n     } else {\n         // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n         // When we come back from raw const eval, we are always by-ref. The only way our op here is\n-        // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n+        // by-val is if we are in destructure_const, i.e., if this is (a field of) something that we\n         // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n         // structs containing such.\n         op.try_as_mplace(ecx)\n@@ -303,7 +303,7 @@ pub fn const_eval_raw_provider<'tcx>(\n     let mut ecx = InterpCx::new(\n         tcx.at(span),\n         key.param_env,\n-        CompileTimeInterpreter::new(*tcx.sess.const_eval_limit.get()),\n+        CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics: is_static },\n     );\n "}, {"sha": "dc13126df0e4cdd5b006c0601be2db3d5551eff0", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -10,6 +10,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_ast::ast::Mutability;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::AssertMessage;\n+use rustc_session::Limit;\n use rustc_span::symbol::Symbol;\n \n use crate::interpret::{\n@@ -109,8 +110,8 @@ pub struct MemoryExtra {\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n-    pub(super) fn new(const_eval_limit: usize) -> Self {\n-        CompileTimeInterpreter { steps_remaining: const_eval_limit, stack: Vec::new() }\n+    pub(super) fn new(const_eval_limit: Limit) -> Self {\n+        CompileTimeInterpreter { steps_remaining: const_eval_limit.0, stack: Vec::new() }\n     }\n }\n "}]}