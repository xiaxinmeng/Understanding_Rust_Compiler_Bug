{"sha": "b9a94c919b8cb09c186ff253360df91f223f6ef3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YTk0YzkxOWI4Y2IwOWMxODZmZjI1MzM2MGRmOTFmMjIzZjZlZjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-26T09:11:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-26T09:11:34Z"}, "message": "Auto merge of #78324 - RalfJung:uninhabited-statics, r=oli-obk\n\nensure that statics are inhabited\n\nFixes https://github.com/rust-lang/rust/issues/74840\n\nr? `@oli-obk`", "tree": {"sha": "58a3b681a12e633e9bcfce8c64badd1ddf4d5777", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58a3b681a12e633e9bcfce8c64badd1ddf4d5777"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9a94c919b8cb09c186ff253360df91f223f6ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9a94c919b8cb09c186ff253360df91f223f6ef3", "html_url": "https://github.com/rust-lang/rust/commit/b9a94c919b8cb09c186ff253360df91f223f6ef3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9a94c919b8cb09c186ff253360df91f223f6ef3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69e68cf550fb7ba6137b167c17d0fcbe7ea06ce2", "url": "https://api.github.com/repos/rust-lang/rust/commits/69e68cf550fb7ba6137b167c17d0fcbe7ea06ce2", "html_url": "https://github.com/rust-lang/rust/commit/69e68cf550fb7ba6137b167c17d0fcbe7ea06ce2"}, {"sha": "3bd5cc900c55722c38cf5aa51793cc133c8d741a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd5cc900c55722c38cf5aa51793cc133c8d741a", "html_url": "https://github.com/rust-lang/rust/commit/3bd5cc900c55722c38cf5aa51793cc133c8d741a"}], "stats": {"total": 145, "additions": 139, "deletions": 6}, "files": [{"sha": "d12eb0edd4d39371eda35bd7639e0ef9a5b186c2", "filename": "compiler/rustc_session/src/lint/builtin.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b9a94c919b8cb09c186ff253360df91f223f6ef3/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9a94c919b8cb09c186ff253360df91f223f6ef3/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs?ref=b9a94c919b8cb09c186ff253360df91f223f6ef3", "patch": "@@ -2647,6 +2647,35 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `uninhabited_static` lint detects uninhbaited statics.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// enum Void {}\n+    /// extern {\n+    ///     static EXTERN: Void;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Statics with an uninhabited type can never be initialized, so they are impossible to define.\n+    /// However, this can be side-stepped with an `extern static`, leading to problems later in the\n+    /// compiler which assumes that there are no initialized uninhabited places (such as locals or\n+    /// statics). This was accientally allowed, but is being phased out.\n+    pub UNINHABITED_STATIC,\n+    Warn,\n+    \"uninhabited static\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #74840 <https://github.com/rust-lang/rust/issues/74840>\",\n+        edition: None,\n+    };\n+}\n+\n declare_tool_lint! {\n     pub rustc::INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n     Deny,\n@@ -2732,6 +2761,7 @@ declare_lint_pass! {\n         CENUM_IMPL_DROP_CAST,\n         CONST_EVALUATABLE_UNCHECKED,\n         INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n+        UNINHABITED_STATIC,\n     ]\n }\n "}, {"sha": "8f2537404c5cc769bacde90824d2ef7a8816202c", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b9a94c919b8cb09c186ff253360df91f223f6ef3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9a94c919b8cb09c186ff253360df91f223f6ef3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=b9a94c919b8cb09c186ff253360df91f223f6ef3", "patch": "@@ -14,8 +14,9 @@ use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt, Representability};\n-use rustc_middle::ty::{self, RegionKind, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ParamEnv, RegionKind, ToPredicate, Ty, TyCtxt};\n use rustc_session::config::EntryFnType;\n+use rustc_session::lint::builtin::UNINHABITED_STATIC;\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n use rustc_target::spec::abi::Abi;\n@@ -338,7 +339,7 @@ pub(super) fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     check_packed(tcx, span, def);\n }\n \n-pub(super) fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n+fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -349,7 +350,7 @@ pub(super) fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n }\n \n /// Check that the fields of the `union` do not need dropping.\n-pub(super) fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> bool {\n+fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> bool {\n     let item_type = tcx.type_of(item_def_id);\n     if let ty::Adt(def, substs) = item_type.kind() {\n         assert!(def.is_union());\n@@ -377,6 +378,36 @@ pub(super) fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: Local\n     true\n }\n \n+/// Check that a `static` is inhabited.\n+fn check_static_inhabited<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n+    // Make sure statics are inhabited.\n+    // Other parts of the compiler assume that there are no uninhabited places. In principle it\n+    // would be enough to check this for `extern` statics, as statics with an initializer will\n+    // have UB during initialization if they are uninhabited, but there also seems to be no good\n+    // reason to allow any statics to be uninhabited.\n+    let ty = tcx.type_of(def_id);\n+    let layout = match tcx.layout_of(ParamEnv::reveal_all().and(ty)) {\n+        Ok(l) => l,\n+        Err(_) => {\n+            // Generic statics are rejected, but we still reach this case.\n+            tcx.sess.delay_span_bug(span, \"generic static must be rejected\");\n+            return;\n+        }\n+    };\n+    if layout.abi.is_uninhabited() {\n+        tcx.struct_span_lint_hir(\n+            UNINHABITED_STATIC,\n+            tcx.hir().local_def_id_to_hir_id(def_id),\n+            span,\n+            |lint| {\n+                lint.build(\"static of uninhabited type\")\n+                .note(\"uninhabited statics cannot be initialized, and any access would be an immediate error\")\n+                .emit();\n+            },\n+        );\n+    }\n+}\n+\n /// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n /// projections that would result in \"inheriting lifetimes\".\n pub(super) fn check_opaque<'tcx>(\n@@ -609,6 +640,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n             tcx.ensure().typeck(def_id);\n             maybe_check_static_with_link_section(tcx, def_id, it.span);\n+            check_static_inhabited(tcx, def_id, it.span);\n         }\n         hir::ItemKind::Const(..) => {\n             tcx.ensure().typeck(tcx.hir().local_def_id(it.hir_id));\n@@ -691,7 +723,8 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                 }\n             } else {\n                 for item in m.items {\n-                    let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n+                    let def_id = tcx.hir().local_def_id(item.hir_id);\n+                    let generics = tcx.generics_of(def_id);\n                     let own_counts = generics.own_counts();\n                     if generics.params.len() - own_counts.lifetimes != 0 {\n                         let (kinds, kinds_pl, egs) = match (own_counts.types, own_counts.consts) {\n@@ -722,8 +755,14 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                         .emit();\n                     }\n \n-                    if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.kind {\n-                        require_c_abi_if_c_variadic(tcx, fn_decl, m.abi, item.span);\n+                    match item.kind {\n+                        hir::ForeignItemKind::Fn(ref fn_decl, _, _) => {\n+                            require_c_abi_if_c_variadic(tcx, fn_decl, m.abi, item.span);\n+                        }\n+                        hir::ForeignItemKind::Static(..) => {\n+                            check_static_inhabited(tcx, def_id, item.span);\n+                        }\n+                        _ => {}\n                     }\n                 }\n             }"}, {"sha": "cc78f6cfa53f7127282038e0aaf1990424e8812f", "filename": "src/test/ui/statics/uninhabited-static.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b9a94c919b8cb09c186ff253360df91f223f6ef3/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9a94c919b8cb09c186ff253360df91f223f6ef3/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.rs?ref=b9a94c919b8cb09c186ff253360df91f223f6ef3", "patch": "@@ -0,0 +1,17 @@\n+#![feature(never_type)]\n+#![deny(uninhabited_static)]\n+\n+enum Void {}\n+extern {\n+    static VOID: Void; //~ ERROR static of uninhabited type\n+    //~| WARN: previously accepted\n+    static NEVER: !; //~ ERROR static of uninhabited type\n+    //~| WARN: previously accepted\n+}\n+\n+static VOID2: Void = unsafe { std::mem::transmute(()) }; //~ ERROR static of uninhabited type\n+//~| WARN: previously accepted\n+static NEVER2: Void = unsafe { std::mem::transmute(()) }; //~ ERROR static of uninhabited type\n+//~| WARN: previously accepted\n+\n+fn main() {}"}, {"sha": "5d95b29993827ff6b005f528373bafb9b35dc452", "filename": "src/test/ui/statics/uninhabited-static.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b9a94c919b8cb09c186ff253360df91f223f6ef3/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9a94c919b8cb09c186ff253360df91f223f6ef3/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr?ref=b9a94c919b8cb09c186ff253360df91f223f6ef3", "patch": "@@ -0,0 +1,47 @@\n+error: static of uninhabited type\n+  --> $DIR/uninhabited-static.rs:6:5\n+   |\n+LL |     static VOID: Void;\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/uninhabited-static.rs:2:9\n+   |\n+LL | #![deny(uninhabited_static)]\n+   |         ^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #74840 <https://github.com/rust-lang/rust/issues/74840>\n+   = note: uninhabited statics cannot be initialized, and any access would be an immediate error\n+\n+error: static of uninhabited type\n+  --> $DIR/uninhabited-static.rs:8:5\n+   |\n+LL |     static NEVER: !;\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #74840 <https://github.com/rust-lang/rust/issues/74840>\n+   = note: uninhabited statics cannot be initialized, and any access would be an immediate error\n+\n+error: static of uninhabited type\n+  --> $DIR/uninhabited-static.rs:12:1\n+   |\n+LL | static VOID2: Void = unsafe { std::mem::transmute(()) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #74840 <https://github.com/rust-lang/rust/issues/74840>\n+   = note: uninhabited statics cannot be initialized, and any access would be an immediate error\n+\n+error: static of uninhabited type\n+  --> $DIR/uninhabited-static.rs:14:1\n+   |\n+LL | static NEVER2: Void = unsafe { std::mem::transmute(()) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #74840 <https://github.com/rust-lang/rust/issues/74840>\n+   = note: uninhabited statics cannot be initialized, and any access would be an immediate error\n+\n+error: aborting due to 4 previous errors\n+"}]}