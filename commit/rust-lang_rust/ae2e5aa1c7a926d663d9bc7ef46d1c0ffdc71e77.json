{"sha": "ae2e5aa1c7a926d663d9bc7ef46d1c0ffdc71e77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMmU1YWExYzdhOTI2ZDY2M2Q5YmM3ZWY0NmQxYzBmZmRjNzFlNzc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-31T19:53:08Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-08T11:15:11Z"}, "message": "resolve: Further simplify legacy scopes, add comments", "tree": {"sha": "f58e51b3145371c7f665e4013e67bf3982f49149", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f58e51b3145371c7f665e4013e67bf3982f49149"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae2e5aa1c7a926d663d9bc7ef46d1c0ffdc71e77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae2e5aa1c7a926d663d9bc7ef46d1c0ffdc71e77", "html_url": "https://github.com/rust-lang/rust/commit/ae2e5aa1c7a926d663d9bc7ef46d1c0ffdc71e77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae2e5aa1c7a926d663d9bc7ef46d1c0ffdc71e77/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e00993a1abacc2bf211892af1e8012b55ad1ed9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e00993a1abacc2bf211892af1e8012b55ad1ed9b", "html_url": "https://github.com/rust-lang/rust/commit/e00993a1abacc2bf211892af1e8012b55ad1ed9b"}], "stats": {"total": 85, "additions": 45, "deletions": 40}, "files": [{"sha": "c5d1f63f70a845d6d4329626d78386ca46b2bf36", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae2e5aa1c7a926d663d9bc7ef46d1c0ffdc71e77/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2e5aa1c7a926d663d9bc7ef46d1c0ffdc71e77/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ae2e5aa1c7a926d663d9bc7ef46d1c0ffdc71e77", "patch": "@@ -961,6 +961,7 @@ impl<'a, 'b, 'cl> BuildReducedGraphVisitor<'a, 'b, 'cl> {\n         let invocation = self.resolver.invocations[&mark];\n         invocation.module.set(self.resolver.current_module);\n         invocation.parent_legacy_scope.set(self.current_legacy_scope);\n+        invocation.output_legacy_scope.set(self.current_legacy_scope);\n         invocation\n     }\n }\n@@ -990,7 +991,7 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n                 return\n             }\n             ItemKind::Mac(..) => {\n-                self.current_legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+                self.current_legacy_scope = LegacyScope::Invocation(self.visit_invoc(item.id));\n                 return\n             }\n             ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n@@ -1009,7 +1010,7 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n \n     fn visit_stmt(&mut self, stmt: &'a ast::Stmt) {\n         if let ast::StmtKind::Mac(..) = stmt.node {\n-            self.current_legacy_scope = LegacyScope::Expansion(self.visit_invoc(stmt.id));\n+            self.current_legacy_scope = LegacyScope::Invocation(self.visit_invoc(stmt.id));\n         } else {\n             visit::walk_stmt(self, stmt);\n         }"}, {"sha": "0359d62104c33390fcc443acf374fa3934ceb803", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ae2e5aa1c7a926d663d9bc7ef46d1c0ffdc71e77/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2e5aa1c7a926d663d9bc7ef46d1c0ffdc71e77/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ae2e5aa1c7a926d663d9bc7ef46d1c0ffdc71e77", "patch": "@@ -50,15 +50,16 @@ crate struct FromPrelude(bool);\n \n #[derive(Clone)]\n pub struct InvocationData<'a> {\n-    crate module: Cell<Module<'a>>,\n     def_index: DefIndex,\n-    // Legacy scope in which the macro was invoked.\n-    // The invocation path is resolved in this scope.\n+    /// Module in which the macro was invoked.\n+    crate module: Cell<Module<'a>>,\n+    /// Legacy scope in which the macro was invoked.\n+    /// The invocation path is resolved in this scope.\n     crate parent_legacy_scope: Cell<LegacyScope<'a>>,\n-    // Legacy scope *produced* by expanding this macro invocation,\n-    // includes all the macro_rules items, other invocations, etc generated by it.\n-    // `Empty` is used if for invocations that has not been expanded yet.\n-    output_legacy_scope: Cell<LegacyScope<'a>>,\n+    /// Legacy scope *produced* by expanding this macro invocation,\n+    /// includes all the macro_rules items, other invocations, etc generated by it.\n+    /// Set to the parent scope if the macro is not expanded yet (as if the macro produced nothing).\n+    crate output_legacy_scope: Cell<LegacyScope<'a>>,\n }\n \n impl<'a> InvocationData<'a> {\n@@ -72,21 +73,32 @@ impl<'a> InvocationData<'a> {\n     }\n }\n \n-// Binding produced by a `macro_rules` item.\n-// Not modularized, can shadow previous legacy bindings, etc.\n+/// Binding produced by a `macro_rules` item.\n+/// Not modularized, can shadow previous legacy bindings, etc.\n pub struct LegacyBinding<'a> {\n     binding: &'a NameBinding<'a>,\n-    // Legacy scope into which the `macro_rules` item was planted.\n-    parent_legacy_scope: Cell<LegacyScope<'a>>,\n+    /// Legacy scope into which the `macro_rules` item was planted.\n+    parent_legacy_scope: LegacyScope<'a>,\n     ident: Ident,\n }\n \n+/// Scope introduced by a `macro_rules!` macro.\n+/// Starts at the macro's definition and ends at the end of the macro's parent module\n+/// (named or unnamed), or even further if it escapes with `#[macro_use]`.\n+/// Some macro invocations need to introduce legacy scopes too because they\n+/// potentially can expand into macro definitions.\n #[derive(Copy, Clone)]\n pub enum LegacyScope<'a> {\n+    /// Created when invocation data is allocated in the arena,\n+    /// must be replaced with a proper scope later.\n+    Uninitialized,\n+    /// Empty \"root\" scope at the crate start containing no names.\n     Empty,\n-    Invocation(&'a InvocationData<'a>), // The scope of the invocation, not including its expansion\n-    Expansion(&'a InvocationData<'a>), // The scope of the invocation, including its expansion\n+    /// Scope introduced by a `macro_rules!` macro definition.\n     Binding(&'a LegacyBinding<'a>),\n+    /// Scope introduced by a macro invocation that can potentially\n+    /// create a `macro_rules!` macro definition.\n+    Invocation(&'a InvocationData<'a>),\n }\n \n pub struct ProcMacError {\n@@ -181,7 +193,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         }\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n-            current_legacy_scope: LegacyScope::Invocation(invocation),\n+            current_legacy_scope: invocation.parent_legacy_scope.get(),\n             expansion: mark,\n         };\n         fragment.visit_with(&mut visitor);\n@@ -483,8 +495,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         }\n \n-        let legacy_resolution =\n-            self.resolve_legacy_scope(path[0], invoc_id, &invocation.parent_legacy_scope, false);\n+        let legacy_resolution = self.resolve_legacy_scope(\n+            path[0], invoc_id, invocation.parent_legacy_scope.get(), false\n+        );\n         let result = if let Some(legacy_binding) = legacy_resolution {\n             Ok(legacy_binding.def())\n         } else {\n@@ -788,7 +801,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     fn resolve_legacy_scope(&mut self,\n                             ident: Ident,\n                             invoc_id: Mark,\n-                            invoc_parent_legacy_scope: &'a Cell<LegacyScope<'a>>,\n+                            invoc_parent_legacy_scope: LegacyScope<'a>,\n                             record_used: bool)\n                             -> Option<&'a NameBinding<'a>> {\n         let ident = ident.modern();\n@@ -809,28 +822,18 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // Go through all the scopes and try to resolve the name.\n         let mut where_to_resolve = invoc_parent_legacy_scope;\n         loop {\n-            let result = match where_to_resolve.get() {\n+            let result = match where_to_resolve {\n                 LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n                     Some(legacy_binding.binding),\n                 _ => None,\n             };\n \n             macro_rules! continue_search { () => {\n-                where_to_resolve = match where_to_resolve.get() {\n+                where_to_resolve = match where_to_resolve {\n                     LegacyScope::Empty => break, // nowhere else to search\n-                    LegacyScope::Binding(binding) => &binding.parent_legacy_scope,\n-                    LegacyScope::Invocation(invocation) => &invocation.parent_legacy_scope,\n-                    LegacyScope::Expansion(invocation) => {\n-                        match invocation.output_legacy_scope.get() {\n-                            LegacyScope::Empty => &invocation.parent_legacy_scope,\n-                            LegacyScope::Binding(..) |\n-                            LegacyScope::Expansion(..) => &invocation.output_legacy_scope,\n-                            LegacyScope::Invocation(..) => {\n-                                where_to_resolve.set(invocation.parent_legacy_scope.get());\n-                                where_to_resolve\n-                            }\n-                        }\n-                    }\n+                    LegacyScope::Binding(binding) => binding.parent_legacy_scope,\n+                    LegacyScope::Invocation(invocation) => invocation.output_legacy_scope.get(),\n+                    LegacyScope::Uninitialized => unreachable!(),\n                 };\n \n                 continue;\n@@ -885,9 +888,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         for &(invoc_id, ident, kind, def) in module.legacy_macro_resolutions.borrow().iter() {\n             let span = ident.span;\n-            let invoc_parent_legacy_scope = &self.invocations[&invoc_id].parent_legacy_scope;\n-            let legacy_resolution =\n-                self.resolve_legacy_scope(ident, invoc_id, invoc_parent_legacy_scope, true);\n+            let invocation = self.invocations[&invoc_id];\n+            let legacy_resolution = self.resolve_legacy_scope(\n+                ident, invoc_id, invocation.parent_legacy_scope.get(), true\n+            );\n             let resolution = self.resolve_lexical_macro_path_segment(\n                 ident, MacroNS, invoc_id, true, true, kind == MacroKind::Attr, span\n             );\n@@ -1013,8 +1017,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 arenas.alloc_invocation_data(InvocationData {\n                     def_index: invoc.def_index,\n                     module: Cell::new(graph_root),\n-                    parent_legacy_scope: Cell::new(LegacyScope::Empty),\n-                    output_legacy_scope: Cell::new(LegacyScope::Empty),\n+                    parent_legacy_scope: Cell::new(LegacyScope::Uninitialized),\n+                    output_legacy_scope: Cell::new(LegacyScope::Uninitialized),\n                 })\n             });\n         };\n@@ -1050,7 +1054,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let vis = ty::Visibility::Invisible; // Doesn't matter for legacy bindings\n             let binding = (def, vis, item.span, expansion).to_name_binding(self.arenas);\n             let legacy_binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n-                parent_legacy_scope: Cell::new(*current_legacy_scope), binding, ident\n+                parent_legacy_scope: *current_legacy_scope, binding, ident\n             });\n             *current_legacy_scope = LegacyScope::Binding(legacy_binding);\n             self.all_macros.insert(ident.name, def);"}]}