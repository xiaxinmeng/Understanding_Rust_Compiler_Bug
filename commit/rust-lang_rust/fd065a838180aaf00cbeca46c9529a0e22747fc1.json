{"sha": "fd065a838180aaf00cbeca46c9529a0e22747fc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMDY1YTgzODE4MGFhZjAwY2JlY2E0NmM5NTI5YTBlMjI3NDdmYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-04T23:30:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-04T23:30:30Z"}, "message": "Auto merge of #36814 - petrochenkov:def, r=eddyb\n\nRefactoring/bugfixing around definitions for struct/variant constructors\n\n https://github.com/rust-lang/rust/commit/d917c364ad0edfa441e5c219da1b00511b976789 separates definitions for struct/variant constructors living in value namespace from struct/variant type definitions.\n\nhttps://github.com/rust-lang/rust/commit/adfb37827b3a52a83dd11d5781e5b492714a5d4c fixes cross-crate resolution of reexports reexporting half-items, like struct constructors without struct type or types without constructor. Such reexports can appear due to glob shadowing.\nResolution now is not affected by the order in which items and reexports are decoded from metadata (cc https://github.com/rust-lang/rust/issues/31337#issuecomment-183996263). `try_define` is not used during building reduced graph anymore.\n500 lines of this PR are tests for this exotic situation, the remaining line diff count is actually negative! :)\n\nhttps://github.com/rust-lang/rust/commit/c695d0c8756a87c0708b97b7e277b6a3f4712b97 (and partially https://github.com/rust-lang/rust/commit/aabf132de04643602ec17b6abab9e276366d9c6d) moves most of pattern resolution checks from typeck to resolve (except those checking for associated items), uses the same wording for pattern resolution error messages from both typeck and resolve and makes the messages more precise.\n\nhttps://github.com/rust-lang/rust/commit/11e3524e5afa4ac1b04aece67fb683f078e63f37 fixes seemingly incorrectly set `NON_ZERO_SIZED` attributes for struct/variant ctors in const eval.\n\nhttps://github.com/rust-lang/rust/commit/4586fea2531054d9b25f8663f1ba4b32b07c11c2 eliminates `ty::VariantKind` in favor of `def::CtorKind`. The logic is that variant kinds are irrelevant for types, they make sense only when we deal with constructor functions/constants. Despite that `VariantDefData` still keeps a copy of `CtorKind`, but it's used only for various kinds of pretty-printing (and for storing in metadata).\n\nhttps://github.com/rust-lang/rust/commit/aabf132de04643602ec17b6abab9e276366d9c6d is mostly a cleanup of various impossible or improperly used definitions, and other small definition cleanups.\n\ncc @jseyfried\nr? @eddyb", "tree": {"sha": "6221d226708141338c7d8c46a59fa1b141371801", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6221d226708141338c7d8c46a59fa1b141371801"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd065a838180aaf00cbeca46c9529a0e22747fc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd065a838180aaf00cbeca46c9529a0e22747fc1", "html_url": "https://github.com/rust-lang/rust/commit/fd065a838180aaf00cbeca46c9529a0e22747fc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd065a838180aaf00cbeca46c9529a0e22747fc1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a4192804518199623fb88bf43bde69d6b0203cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a4192804518199623fb88bf43bde69d6b0203cb", "html_url": "https://github.com/rust-lang/rust/commit/1a4192804518199623fb88bf43bde69d6b0203cb"}, {"sha": "bc0eabd7a7585a3d1d8bfd314a72df923a85c623", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc0eabd7a7585a3d1d8bfd314a72df923a85c623", "html_url": "https://github.com/rust-lang/rust/commit/bc0eabd7a7585a3d1d8bfd314a72df923a85c623"}], "stats": {"total": 1644, "additions": 1031, "deletions": 613}, "files": [{"sha": "8b9cee1d2f6d6184bfbe61cbdd2011d161852ab7", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 60, "deletions": 25, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -13,34 +13,46 @@ use util::nodemap::NodeMap;\n use syntax::ast;\n use hir;\n \n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum CtorKind {\n+    // Constructor function automatically created by a tuple struct/variant.\n+    Fn,\n+    // Constructor constant automatically created by a unit struct/variant.\n+    Const,\n+    // Unusable name in value namespace created by a struct variant.\n+    Fictive,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n-    Fn(DefId),\n-    SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n+    // Type namespace\n     Mod(DefId),\n-    Static(DefId, bool /* is_mutbl */),\n-    Const(DefId),\n-    AssociatedConst(DefId),\n-    Local(DefId),\n-    Variant(DefId),\n+    Struct(DefId), // DefId refers to NodeId of the struct itself\n+    Union(DefId),\n     Enum(DefId),\n+    Variant(DefId),\n+    Trait(DefId),\n     TyAlias(DefId),\n     AssociatedTy(DefId),\n-    Trait(DefId),\n     PrimTy(hir::PrimTy),\n     TyParam(DefId),\n-    Upvar(DefId,        // def id of closed over local\n-             usize,        // index in the freevars list of the closure\n-             ast::NodeId), // expr node that creates the closure\n+    SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n \n-    // If Def::Struct lives in type namespace it denotes a struct item and its DefId refers\n-    // to NodeId of the struct itself.\n-    // If Def::Struct lives in value namespace (e.g. tuple struct, unit struct expressions)\n-    // it denotes a constructor and its DefId refers to NodeId of the struct's constructor.\n-    Struct(DefId),\n-    Union(DefId),\n-    Label(ast::NodeId),\n+    // Value namespace\n+    Fn(DefId),\n+    Const(DefId),\n+    Static(DefId, bool /* is_mutbl */),\n+    StructCtor(DefId, CtorKind), // DefId refers to NodeId of the struct's constructor\n+    VariantCtor(DefId, CtorKind),\n     Method(DefId),\n+    AssociatedConst(DefId),\n+    Local(DefId),\n+    Upvar(DefId,        // def id of closed over local\n+          usize,        // index in the freevars list of the closure\n+          ast::NodeId), // expr node that creates the closure\n+    Label(ast::NodeId),\n+\n+    // Both namespaces\n     Err,\n }\n \n@@ -93,18 +105,35 @@ pub type ExportMap = NodeMap<Vec<Export>>;\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct Export {\n-    pub name: ast::Name,    // The name of the target.\n-    pub def_id: DefId, // The definition of the target.\n+    pub name: ast::Name, // The name of the target.\n+    pub def: Def, // The definition of the target.\n+}\n+\n+impl CtorKind {\n+    pub fn from_ast(vdata: &ast::VariantData) -> CtorKind {\n+        match *vdata {\n+            ast::VariantData::Tuple(..) => CtorKind::Fn,\n+            ast::VariantData::Unit(..) => CtorKind::Const,\n+            ast::VariantData::Struct(..) => CtorKind::Fictive,\n+        }\n+    }\n+    pub fn from_hir(vdata: &hir::VariantData) -> CtorKind {\n+        match *vdata {\n+            hir::VariantData::Tuple(..) => CtorKind::Fn,\n+            hir::VariantData::Unit(..) => CtorKind::Const,\n+            hir::VariantData::Struct(..) => CtorKind::Fictive,\n+        }\n+    }\n }\n \n impl Def {\n     pub fn def_id(&self) -> DefId {\n         match *self {\n             Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n-            Def::Variant(id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(id) |\n-            Def::TyParam(id) | Def::Struct(id) | Def::Union(id) | Def::Trait(id) |\n-            Def::Method(id) | Def::Const(id) | Def::AssociatedConst(id) |\n-            Def::Local(id) | Def::Upvar(id, ..) => {\n+            Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) | Def::TyAlias(id) |\n+            Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n+            Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n+            Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) => {\n                 id\n             }\n \n@@ -123,10 +152,16 @@ impl Def {\n             Def::Mod(..) => \"module\",\n             Def::Static(..) => \"static\",\n             Def::Variant(..) => \"variant\",\n+            Def::VariantCtor(.., CtorKind::Fn) => \"tuple variant\",\n+            Def::VariantCtor(.., CtorKind::Const) => \"unit variant\",\n+            Def::VariantCtor(.., CtorKind::Fictive) => \"struct variant\",\n             Def::Enum(..) => \"enum\",\n-            Def::TyAlias(..) => \"type\",\n+            Def::TyAlias(..) => \"type alias\",\n             Def::AssociatedTy(..) => \"associated type\",\n             Def::Struct(..) => \"struct\",\n+            Def::StructCtor(.., CtorKind::Fn) => \"tuple struct\",\n+            Def::StructCtor(.., CtorKind::Const) => \"unit struct\",\n+            Def::StructCtor(.., CtorKind::Fictive) => bug!(\"impossible struct constructor\"),\n             Def::Union(..) => \"union\",\n             Def::Trait(..) => \"trait\",\n             Def::Method(..) => \"method\","}, {"sha": "f56a27b9ae04a1213463efe6f4f0c06dae80ce02", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -44,8 +44,9 @@ use hir;\n use hir::map::Definitions;\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n-use hir::def::{Def, PathResolution};\n+use hir::def::{Def, CtorKind, PathResolution};\n use session::Session;\n+use lint;\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -855,10 +856,23 @@ impl<'a> LoweringContext<'a> {\n                     })\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-                PatKind::TupleStruct(ref pth, ref pats, ddpos) => {\n-                    hir::PatKind::TupleStruct(self.lower_path(pth),\n-                                              pats.iter().map(|x| self.lower_pat(x)).collect(),\n-                                              ddpos)\n+                PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n+                    match self.resolver.get_resolution(p.id).map(|d| d.base_def) {\n+                        Some(def @ Def::StructCtor(_, CtorKind::Const)) |\n+                        Some(def @ Def::VariantCtor(_, CtorKind::Const)) => {\n+                            // Temporarily lower `UnitVariant(..)` into `UnitVariant`\n+                            // for backward compatibility.\n+                            let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n+                                            def.kind_name(), path);\n+                            self.sess.add_lint(\n+                                lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n+                                p.id, p.span, msg\n+                            );\n+                            hir::PatKind::Path(None, self.lower_path(path))\n+                        }\n+                        _ => hir::PatKind::TupleStruct(self.lower_path(path),\n+                                        pats.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n+                    }\n                 }\n                 PatKind::Path(ref opt_qself, ref path) => {\n                     let opt_qself = opt_qself.as_ref().map(|qself| {"}, {"sha": "0deea941463617f664141b7a86ff8b2e7bd932fc", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -58,7 +58,7 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n         PatKind::Path(..) |\n         PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Variant(..)) => true,\n+                Some(Def::Variant(..)) | Some(Def::VariantCtor(..)) => true,\n                 _ => false\n             }\n         }\n@@ -173,10 +173,9 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n             PatKind::TupleStruct(..) |\n             PatKind::Path(..) |\n             PatKind::Struct(..) => {\n-                match dm.get(&p.id) {\n-                    Some(&PathResolution { base_def: Def::Variant(id), .. }) => {\n-                        variants.push(id);\n-                    }\n+                match dm.get(&p.id).map(|d| d.full_def()) {\n+                    Some(Def::Variant(id)) |\n+                    Some(Def::VariantCtor(id, ..)) => variants.push(id),\n                     _ => ()\n                 }\n             }"}, {"sha": "dfd6256c35773ccc1227a5e2ab35ac443e488b04", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -201,8 +201,6 @@ pub trait CrateStore<'tcx> {\n                              -> Option<DefIndex>;\n     fn def_key(&self, def: DefId) -> hir_map::DefKey;\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n-    fn variant_kind(&self, def_id: DefId) -> Option<ty::VariantKind>;\n-    fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<def::Export>;\n \n@@ -378,9 +376,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n         bug!(\"relative_def_path\")\n     }\n-    fn variant_kind(&self, def_id: DefId) -> Option<ty::VariantKind> { bug!(\"variant_kind\") }\n-    fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n-        { bug!(\"struct_ctor_def_id\") }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n     fn item_children(&self, did: DefId) -> Vec<def::Export> { bug!(\"item_children\") }\n "}, {"sha": "dc634b08784a4a266031dab0a7befb94f716896b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -106,9 +106,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 self.check_def_id(def.def_id());\n             }\n             _ if self.ignore_non_const_paths => (),\n-            Def::PrimTy(_) => (),\n-            Def::SelfTy(..) => (),\n-            Def::Variant(variant_id) => {\n+            Def::PrimTy(..) | Def::SelfTy(..) => (),\n+            Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n                 if let Some(enum_id) = self.tcx.parent_def_id(variant_id) {\n                     self.check_def_id(enum_id);\n                 }"}, {"sha": "799c02b740310cad9bbd78e66af61b94ad3f6251", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -1003,7 +1003,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             match tcx.expect_def_or_none(pat.id) {\n-                Some(Def::Variant(variant_did)) => {\n+                Some(Def::Variant(variant_did)) |\n+                Some(Def::VariantCtor(variant_did, ..)) => {\n                     let enum_did = tcx.parent_def_id(variant_did).unwrap();\n                     let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n                         cmt_pat\n@@ -1015,12 +1016,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n-                Some(Def::Struct(..)) | Some(Def::Union(..)) |\n+                Some(Def::Struct(..)) | Some(Def::StructCtor(..)) | Some(Def::Union(..)) |\n                 Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }\n-                _ => {}\n+                None | Some(Def::Local(..)) |\n+                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {}\n+                def => bug!(\"unexpected definition: {:?}\", def)\n             }\n         }));\n     }"}, {"sha": "9214138d2107769abc9c5a72e20f4478b9746f01", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -74,7 +74,7 @@ use hir::def_id::DefId;\n use hir::map as ast_map;\n use infer::InferCtxt;\n use middle::const_qualif::ConstQualif;\n-use hir::def::Def;\n+use hir::def::{Def, CtorKind};\n use ty::adjustment;\n use ty::{self, Ty, TyCtxt};\n \n@@ -524,20 +524,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                id, expr_ty, def);\n \n         match def {\n-          Def::Struct(..) | Def::Union(..) | Def::Variant(..) | Def::Const(..) |\n+          Def::StructCtor(..) | Def::VariantCtor(..) | Def::Const(..) |\n           Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n \n-          Def::Mod(_) |\n-          Def::Trait(_) | Def::Enum(..) | Def::TyAlias(..) | Def::PrimTy(_) |\n-          Def::TyParam(..) |\n-          Def::Label(_) | Def::SelfTy(..) |\n-          Def::AssociatedTy(..) => {\n-              span_bug!(span, \"Unexpected definition in \\\n-                               memory categorization: {:?}\", def);\n-          }\n-\n           Def::Static(_, mutbl) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n@@ -598,7 +589,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }))\n           }\n \n-          Def::Err => bug!(\"Def::Err in memory categorization\")\n+          def => span_bug!(span, \"unexpected definition in memory categorization: {:?}\", def)\n         }\n     }\n \n@@ -1077,7 +1068,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // alone) because PatKind::Struct can also refer to variants.\n         let cmt = match self.tcx().expect_def_or_none(pat.id) {\n             Some(Def::Err) => return Err(()),\n-            Some(Def::Variant(variant_did)) => {\n+            Some(Def::Variant(variant_did)) |\n+            Some(Def::VariantCtor(variant_did, ..)) => {\n                 // univariant enums do not need downcasts\n                 let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n                 if !self.tcx().lookup_adt_def(enum_did).is_univariant() {\n@@ -1092,11 +1084,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         match pat.node {\n           PatKind::TupleStruct(_, ref subpats, ddpos) => {\n             let expected_len = match self.tcx().expect_def(pat.id) {\n-                Def::Variant(def_id) => {\n+                Def::VariantCtor(def_id, CtorKind::Fn) => {\n                     let enum_def = self.tcx().parent_def_id(def_id).unwrap();\n                     self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()\n                 }\n-                Def::Struct(..) => {\n+                Def::StructCtor(_, CtorKind::Fn) => {\n                     match self.pat_ty(&pat)?.sty {\n                         ty::TyAdt(adt_def, _) => {\n                             adt_def.struct_variant().fields.len()"}, {"sha": "5192575972b0200ade1b38ac3a9cedf15b16530c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -617,12 +617,8 @@ pub fn check_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            &Option<DeprecationEntry>)) {\n     // Paths in import prefixes may have no resolution.\n     match tcx.expect_def_or_none(id) {\n-        Some(Def::PrimTy(..)) => {}\n-        Some(Def::SelfTy(..)) => {}\n-        Some(def) => {\n-            maybe_do_stability_check(tcx, def.def_id(), path.span, cb);\n-        }\n-        None => {}\n+        None | Some(Def::PrimTy(..)) | Some(Def::SelfTy(..)) => {}\n+        Some(def) => maybe_do_stability_check(tcx, def.def_id(), path.span, cb)\n     }\n }\n \n@@ -631,12 +627,7 @@ pub fn check_path_list_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       cb: &mut FnMut(DefId, Span,\n                                                      &Option<&Stability>,\n                                                      &Option<DeprecationEntry>)) {\n-    match tcx.expect_def(item.node.id) {\n-        Def::PrimTy(..) => {}\n-        def => {\n-            maybe_do_stability_check(tcx, def.def_id(), item.span, cb);\n-        }\n-    }\n+    maybe_do_stability_check(tcx, tcx.expect_def(item.node.id).def_id(), item.span, cb);\n }\n \n pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,"}, {"sha": "fa899c4026955b6b7af7212f6f09d03615873dcf", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n+use hir::def::CtorKind;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n@@ -1140,10 +1141,10 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         ppaux::parameterized(fmt, substs, variant_def.did,\n                                              ppaux::Ns::Value, &[])?;\n \n-                        match variant_def.kind {\n-                            ty::VariantKind::Unit => Ok(()),\n-                            ty::VariantKind::Tuple => fmt_tuple(fmt, lvs),\n-                            ty::VariantKind::Struct => {\n+                        match variant_def.ctor_kind {\n+                            CtorKind::Const => Ok(()),\n+                            CtorKind::Fn => fmt_tuple(fmt, lvs),\n+                            CtorKind::Fictive => {\n                                 let mut struct_fmt = fmt.debug_struct(\"\");\n                                 for (field, lv) in variant_def.fields.iter().zip(lvs) {\n                                     struct_fmt.field(&field.name.as_str(), lv);"}, {"sha": "8e330ee8e824ce2cc6d89c4427b7eff7bddb6baf", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -20,7 +20,7 @@ pub use self::fold::TypeFoldable;\n use dep_graph::{self, DepNode};\n use hir::map as ast_map;\n use middle;\n-use hir::def::{Def, PathResolution, ExportMap};\n+use hir::def::{Def, CtorKind, PathResolution, ExportMap};\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n@@ -1420,7 +1420,7 @@ pub struct VariantDefData<'tcx, 'container: 'tcx> {\n     pub name: Name, // struct's name if this is a struct\n     pub disr_val: Disr,\n     pub fields: Vec<FieldDefData<'tcx, 'container>>,\n-    pub kind: VariantKind,\n+    pub ctor_kind: CtorKind,\n }\n \n pub struct FieldDefData<'tcx, 'container: 'tcx> {\n@@ -1485,19 +1485,6 @@ impl<'tcx> serialize::UseSpecializedDecodable for AdtDef<'tcx> {}\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub enum VariantKind { Struct, Tuple, Unit }\n-\n-impl VariantKind {\n-    pub fn from_variant_data(vdata: &hir::VariantData) -> Self {\n-        match *vdata {\n-            hir::VariantData::Struct(..) => VariantKind::Struct,\n-            hir::VariantData::Tuple(..) => VariantKind::Tuple,\n-            hir::VariantData::Unit(..) => VariantKind::Unit,\n-        }\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            did: DefId,\n@@ -1673,8 +1660,8 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n \n     pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n         match def {\n-            Def::Variant(vid) => self.variant_with_id(vid),\n-            Def::Struct(..) | Def::Union(..) |\n+            Def::Variant(vid) | Def::VariantCtor(vid, ..) => self.variant_with_id(vid),\n+            Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n             Def::TyAlias(..) | Def::AssociatedTy(..) => self.struct_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n         }\n@@ -2332,11 +2319,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // or variant or their constructors, panics otherwise.\n     pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {\n         match def {\n-            Def::Variant(did) => {\n+            Def::Variant(did) | Def::VariantCtor(did, ..) => {\n                 let enum_did = self.parent_def_id(did).unwrap();\n                 self.lookup_adt_def(enum_did).variant_with_id(did)\n             }\n-            Def::Struct(did) | Def::Union(did) => {\n+            Def::Struct(did) | Def::StructCtor(did, ..) | Def::Union(did) => {\n                 self.lookup_adt_def(did).struct_variant()\n             }\n             _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)"}, {"sha": "cf54f5908ca9e3ccbd2ab7b447125aeb3aa273b7", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -247,7 +247,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                 if edef.is_enum() {\n                     if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n                         if edef.variants.iter().any(|variant| {\n-                            variant.name == name.node && variant.kind == ty::VariantKind::Unit\n+                            variant.name == name.node && variant.ctor_kind == CtorKind::Const\n                         }) {\n                             let ty_path = cx.tcx.item_path_str(edef.did);\n                             let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n@@ -577,8 +577,8 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n \n         ty::TyAdt(adt, _) => {\n             let v = ctor.variant_for_adt(adt);\n-            match v.kind {\n-                ty::VariantKind::Struct => {\n+            match v.ctor_kind {\n+                CtorKind::Fictive => {\n                     let field_pats: hir::HirVec<_> = v.fields.iter()\n                         .zip(pats)\n                         .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n@@ -593,10 +593,10 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                     let has_more_fields = field_pats.len() < pats_len;\n                     PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n                 }\n-                ty::VariantKind::Tuple => {\n+                CtorKind::Fn => {\n                     PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n                 }\n-                ty::VariantKind::Unit => {\n+                CtorKind::Const => {\n                     PatKind::Path(None, def_to_path(cx.tcx, v.did))\n                 }\n             }\n@@ -801,8 +801,8 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n             match cx.tcx.expect_def(pat.id) {\n-                Def::Variant(id) => vec![Variant(id)],\n-                Def::Struct(..) | Def::Union(..) |\n+                Def::Variant(id) | Def::VariantCtor(id, ..) => vec![Variant(id)],\n+                Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n                 Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat.span, \"const pattern should've been rewritten\"),\n@@ -913,10 +913,10 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n-                Def::Variant(id) if *constructor != Variant(id) => None,\n-                Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n-                def => span_bug!(pat_span, \"specialize: unexpected \\\n-                                          definition {:?}\", def),\n+                Def::VariantCtor(id, CtorKind::Const) if *constructor != Variant(id) => None,\n+                Def::VariantCtor(_, CtorKind::Const) |\n+                Def::StructCtor(_, CtorKind::Const) => Some(Vec::new()),\n+                def => span_bug!(pat_span, \"specialize: unexpected definition: {:?}\", def),\n             }\n         }\n \n@@ -925,8 +925,9 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n-                Def::Variant(id) if *constructor != Variant(id) => None,\n-                Def::Variant(..) | Def::Struct(..) => {\n+                Def::VariantCtor(id, CtorKind::Fn) if *constructor != Variant(id) => None,\n+                Def::VariantCtor(_, CtorKind::Fn) |\n+                Def::StructCtor(_, CtorKind::Fn) => {\n                     match ddpos {\n                         Some(ddpos) => {\n                             let mut pats: Vec<_> = args[..ddpos].iter().map(|p| {\n@@ -939,7 +940,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n                         None => Some(args.iter().map(|p| wpat(p)).collect())\n                     }\n                 }\n-                _ => None\n+                def => span_bug!(pat_span, \"specialize: unexpected definition: {:?}\", def),\n             }\n         }\n "}, {"sha": "d876b4b6fec2eb1054ddd493ecafbaae614afc07", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::cstore::InlinedItem;\n use rustc::traits;\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::{Def, CtorKind, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -287,8 +287,8 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                entry.insert(PathResolution::new(def));\n             }\n             let path = match def {\n-                Def::Struct(def_id) => def_to_path(tcx, def_id),\n-                Def::Variant(variant_did) => def_to_path(tcx, variant_did),\n+                Def::StructCtor(def_id, CtorKind::Fn) |\n+                Def::VariantCtor(def_id, CtorKind::Fn) => def_to_path(tcx, def_id),\n                 Def::Fn(..) | Def::Method(..) => return Ok(P(hir::Pat {\n                     id: expr.id,\n                     node: PatKind::Lit(P(expr.clone())),\n@@ -326,7 +326,8 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         hir::ExprPath(_, ref path) => {\n             match tcx.expect_def(expr.id) {\n-                Def::Struct(..) | Def::Variant(..) => PatKind::Path(None, path.clone()),\n+                Def::StructCtor(_, CtorKind::Const) |\n+                Def::VariantCtor(_, CtorKind::Const) => PatKind::Path(None, path.clone()),\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n@@ -807,7 +808,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       signal!(e, NonConstPath);\n                   }\n               },\n-              Def::Variant(variant_def) => {\n+              Def::VariantCtor(variant_def, ..) => {\n                   if let Some(const_expr) = lookup_variant_by_id(tcx, variant_def) {\n                       match eval_const_expr_partial(tcx, const_expr, ty_hint, None) {\n                           Ok(val) => val,\n@@ -820,7 +821,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       signal!(e, UnimplementedConstVal(\"enum variants\"));\n                   }\n               }\n-              Def::Struct(..) => {\n+              Def::StructCtor(..) => {\n                   ConstVal::Struct(e.id)\n               }\n               Def::Local(def_id) => {"}, {"sha": "393f99b3eb832c57f6c6f05031c0175f776d1494", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -611,11 +611,13 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             Def::Mod(..) |\n             Def::Static(..) |\n             Def::Variant(..) |\n+            Def::VariantCtor(..) |\n             Def::Enum(..) |\n             Def::TyAlias(..) |\n             Def::AssociatedTy(..) |\n             Def::TyParam(..) |\n             Def::Struct(..) |\n+            Def::StructCtor(..) |\n             Def::Union(..) |\n             Def::Trait(..) |\n             Def::Method(..) |"}, {"sha": "54664b9c04046effbc4b1d197e9be680435598d6", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -149,7 +149,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n         self.get_crate_data(def_id.krate)\n-            .each_child_of_item(def_id.index, |child| result.push(child.def_id));\n+            .each_child_of_item(def_id.index, |child| result.push(child.def.def_id()));\n         result\n     }\n \n@@ -342,18 +342,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).def_path(def.index)\n     }\n \n-    fn variant_kind(&self, def_id: DefId) -> Option<ty::VariantKind>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        self.get_crate_data(def_id.krate).get_variant_kind(def_id.index)\n-    }\n-\n-    fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(struct_def_id));\n-        self.get_crate_data(struct_def_id.krate).get_struct_ctor_def_id(struct_def_id.index)\n-    }\n-\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n@@ -566,7 +554,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n             let mut bfs_queue = &mut VecDeque::new();\n             let mut add_child = |bfs_queue: &mut VecDeque<_>, child: def::Export, parent: DefId| {\n-                let child = child.def_id;\n+                let child = child.def.def_id();\n \n                 if self.visibility(child) != ty::Visibility::Public {\n                     return;"}, {"sha": "579a97138f250dc3c492b961f0c69038aaa66486", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -22,7 +22,7 @@ use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n use rustc::middle::cstore::{InlinedItem, LinkagePreference};\n-use rustc::hir::def::{self, Def};\n+use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -534,7 +534,7 @@ impl<'a, 'tcx> CrateMetadata {\n             name: self.item_name(item),\n             fields: fields,\n             disr_val: ConstInt::Infer(data.disr),\n-            kind: data.kind,\n+            ctor_kind: data.ctor_kind,\n         }, data.struct_ctor)\n     }\n \n@@ -670,10 +670,12 @@ impl<'a, 'tcx> CrateMetadata {\n                     // FIXME(eddyb) Don't encode these in children.\n                     EntryKind::ForeignMod => {\n                         for child_index in child.children.decode(self) {\n-                            callback(def::Export {\n-                                def_id: self.local_def_id(child_index),\n-                                name: self.item_name(&self.entry(child_index))\n-                            });\n+                            if let Some(def) = self.get_def(child_index) {\n+                                callback(def::Export {\n+                                    def: def,\n+                                    name: self.item_name(&self.entry(child_index))\n+                                });\n+                            }\n                         }\n                         continue;\n                     }\n@@ -683,11 +685,28 @@ impl<'a, 'tcx> CrateMetadata {\n                 }\n \n                 let def_key = child.def_key.decode(self);\n-                if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                    callback(def::Export {\n-                        def_id: self.local_def_id(child_index),\n-                        name: name\n-                    });\n+                if let (Some(def), Some(name)) = (self.get_def(child_index),\n+                                                  def_key.disambiguated_data.data.get_opt_name()) {\n+                    callback(def::Export { def: def, name: name });\n+                    // For non-reexport structs and variants add their constructors to children.\n+                    // Reexport lists automatically contain constructors when necessary.\n+                    match def {\n+                        Def::Struct(..) => {\n+                            if let Some(ctor_def_id) = self.get_struct_ctor_def_id(child_index) {\n+                                let ctor_kind = self.get_ctor_kind(child_index);\n+                                let ctor_def = Def::StructCtor(ctor_def_id, ctor_kind);\n+                                callback(def::Export { def: ctor_def, name: name });\n+                            }\n+                        }\n+                        Def::Variant(def_id) => {\n+                            // Braced variants, unlike structs, generate unusable names in\n+                            // value namespace, they are reserved for possible future use.\n+                            let ctor_kind = self.get_ctor_kind(child_index);\n+                            let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n+                            callback(def::Export { def: ctor_def, name: name });\n+                        }\n+                        _ => {}\n+                    }\n                 }\n             }\n         }\n@@ -787,12 +806,12 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id).variances.decode(self).collect()\n     }\n \n-    pub fn get_variant_kind(&self, node_id: DefIndex) -> Option<ty::VariantKind> {\n+    pub fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n         match self.entry(node_id).kind {\n             EntryKind::Struct(data) |\n             EntryKind::Union(data) |\n-            EntryKind::Variant(data) => Some(data.decode(self).kind),\n-            _ => None\n+            EntryKind::Variant(data) => data.decode(self).ctor_kind,\n+            _ => CtorKind::Fictive,\n         }\n     }\n "}, {"sha": "3b6c20040d09c71e5940192dde78b0aec331ccd2", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let def_id = variant.did;\n \n         let data = VariantData {\n-            kind: variant.kind,\n+            ctor_kind: variant.ctor_kind,\n             disr: variant.disr_val.to_u64_unchecked(),\n             struct_ctor: None\n         };\n@@ -406,17 +406,21 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId))\n                           -> Entry<'tcx> {\n-        let variant = self.tcx.lookup_adt_def(adt_def_id).struct_variant();\n+        let tcx = self.tcx;\n+        let variant = tcx.lookup_adt_def(adt_def_id).struct_variant();\n \n         let data = VariantData {\n-            kind: variant.kind,\n+            ctor_kind: variant.ctor_kind,\n             disr: variant.disr_val.to_u64_unchecked(),\n             struct_ctor: Some(def_id.index)\n         };\n \n+        let struct_id = tcx.map.as_local_node_id(adt_def_id).unwrap();\n+        let struct_vis = &tcx.map.expect_item(struct_id).vis;\n+\n         Entry {\n             kind: EntryKind::Struct(self.lazy(&data)),\n-            visibility: ty::Visibility::Public,\n+            visibility: struct_vis.simplify(),\n             def_key: self.encode_def_key(def_id),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n@@ -671,7 +675,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     None\n                 };\n                 EntryKind::Struct(self.lazy(&VariantData {\n-                    kind: variant.kind,\n+                    ctor_kind: variant.ctor_kind,\n                     disr: variant.disr_val.to_u64_unchecked(),\n                     struct_ctor: struct_ctor\n                 }))\n@@ -680,7 +684,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n                 EntryKind::Union(self.lazy(&VariantData {\n-                    kind: variant.kind,\n+                    ctor_kind: variant.ctor_kind,\n                     disr: variant.disr_val.to_u64_unchecked(),\n                     struct_ctor: None\n                 }))\n@@ -885,19 +889,12 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n             hir::ItemStruct(ref struct_def, _) => {\n                 self.encode_fields(def_id);\n \n-                // If this is a tuple-like struct, encode the type of the constructor.\n-                match self.tcx.lookup_adt_def(def_id).struct_variant().kind {\n-                    ty::VariantKind::Struct => {\n-                        // no value for structs like struct Foo { ... }\n-                    }\n-                    ty::VariantKind::Tuple | ty::VariantKind::Unit => {\n-                        // there is a value for structs like `struct\n-                        // Foo()` and `struct Foo`\n-                        let ctor_def_id = self.tcx.map.local_def_id(struct_def.id());\n-                        self.record(ctor_def_id,\n-                                    EncodeContext::encode_struct_ctor,\n-                                    (def_id, ctor_def_id));\n-                    }\n+                // If the struct has a constructor, encode it.\n+                if !struct_def.is_struct() {\n+                    let ctor_def_id = self.tcx.map.local_def_id(struct_def.id());\n+                    self.record(ctor_def_id,\n+                                EncodeContext::encode_struct_ctor,\n+                                (def_id, ctor_def_id));\n                 }\n             }\n             hir::ItemUnion(..) => {"}, {"sha": "0bb126ee0ffb640a359f54ecb9b62fa787baeab6", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -12,7 +12,7 @@ use astencode;\n use index;\n \n use rustc::hir;\n-use rustc::hir::def;\n+use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n use rustc::middle::cstore::{LinkagePreference, NativeLibraryKind};\n use rustc::middle::lang_items;\n@@ -261,7 +261,7 @@ pub struct FnData {\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct VariantData {\n-    pub kind: ty::VariantKind,\n+    pub ctor_kind: CtorKind,\n     pub disr: u64,\n \n     /// If this is a struct's only variant, this"}, {"sha": "a6c5cd1eeeaa7c2d0bc351cdde3caa51d69c14e7", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -15,7 +15,7 @@ use hair::cx::Cx;\n use hair::cx::block;\n use hair::cx::to_ref::ToRef;\n use rustc::hir::map;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval as const_eval;\n use rustc::middle::region::CodeExtent;\n@@ -271,10 +271,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def|{\n                         match cx.tcx.expect_def(fun.id) {\n-                            Def::Variant(variant_id) => {\n+                            Def::VariantCtor(variant_id, CtorKind::Fn) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n                             },\n-                            Def::Struct(..) => {\n+                            Def::StructCtor(_, CtorKind::Fn) => {\n                                 Some((adt_def, 0))\n                             },\n                             _ => None\n@@ -670,42 +670,25 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // Otherwise there may be def_map borrow conflicts\n     let def = cx.tcx.expect_def(expr.id);\n     let def_id = match def {\n-        // A regular function.\n-        Def::Fn(def_id) | Def::Method(def_id) => def_id,\n-        Def::Struct(def_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A tuple-struct constructor. Should only be reached if not called in the same\n-            // expression.\n-            ty::TyFnDef(..) => def_id,\n-            // A unit struct which is used as a value. We return a completely different ExprKind\n-            // here to account for this special case.\n+        // A regular function, constructor function or a constant.\n+        Def::Fn(def_id) | Def::Method(def_id) |\n+        Def::StructCtor(def_id, CtorKind::Fn) |\n+        Def::VariantCtor(def_id, CtorKind::Fn) |\n+        Def::Const(def_id) | Def::AssociatedConst(def_id) => def_id,\n+\n+        Def::StructCtor(def_id, CtorKind::Const) |\n+        Def::VariantCtor(def_id, CtorKind::Const) => match cx.tcx.node_id_to_type(expr.id).sty {\n+            // A unit struct/variant which is used as a value.\n+            // We return a completely different ExprKind here to account for this special case.\n             ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n                 adt_def: adt_def,\n-                variant_index: 0,\n+                variant_index: adt_def.variant_index_with_id(def_id),\n                 substs: substs,\n                 fields: vec![],\n-                base: None\n-            },\n-            ref sty => bug!(\"unexpected sty: {:?}\", sty)\n-        },\n-        Def::Variant(variant_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A variant constructor. Should only be reached if not called in the same\n-            // expression.\n-            ty::TyFnDef(..) => variant_id,\n-            // A unit variant, similar special case to the struct case above.\n-            ty::TyAdt(adt_def, substs) => {\n-                let index = adt_def.variant_index_with_id(variant_id);\n-                return ExprKind::Adt {\n-                    adt_def: adt_def,\n-                    substs: substs,\n-                    variant_index: index,\n-                    fields: vec![],\n-                    base: None\n-                };\n+                base: None,\n             },\n             ref sty => bug!(\"unexpected sty: {:?}\", sty)\n         },\n-        Def::Const(def_id) |\n-        Def::AssociatedConst(def_id) => def_id,\n \n         Def::Static(node_id, _) => return ExprKind::StaticRef {\n             id: node_id,"}, {"sha": "84f415463be05613e9d6bd36f3b2b0503975637b", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -301,7 +301,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                        subpatterns: Vec<FieldPattern<'tcx>>)\n                        -> PatternKind<'tcx> {\n         match self.cx.tcx.expect_def(pat.id) {\n-            Def::Variant(variant_id) => {\n+            Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n                 let enum_id = self.cx.tcx.parent_def_id(variant_id).unwrap();\n                 let adt_def = self.cx.tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n@@ -315,7 +315,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Def::Struct(..) | Def::Union(..) |\n+            Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }"}, {"sha": "198a6d256bcc325bdd914ab550fdd2fc04b671d2", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -12,7 +12,6 @@ use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::ty::VariantKind;\n \n pub struct Deaggregator;\n \n@@ -129,10 +128,7 @@ fn get_aggregate_statement_index<'a, 'tcx, 'b>(start: usize,\n         }\n         debug!(\"getting variant {:?}\", variant);\n         debug!(\"for adt_def {:?}\", adt_def);\n-        let variant_def = &adt_def.variants[variant];\n-        if variant_def.kind == VariantKind::Struct {\n-            return Some(i);\n-        }\n+        return Some(i);\n     };\n     None\n }"}, {"sha": "ee731dd042e4fe0c6d4f5ec027097f1e429e3729", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -33,7 +33,7 @@ use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonCo\n use rustc_const_eval::ErrKind::UnresolvedPath;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_math::{ConstMathErr, Op};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n@@ -489,20 +489,12 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         }\n         hir::ExprPath(..) => {\n             match v.tcx.expect_def(e.id) {\n-                Def::Variant(..) => {\n-                    // Count the discriminator or function pointer.\n-                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n-                }\n-                Def::Struct(..) => {\n-                    if let ty::TyFnDef(..) = node_ty.sty {\n-                        // Count the function pointer.\n-                        v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n-                    }\n-                }\n-                Def::Fn(..) | Def::Method(..) => {\n-                    // Count the function pointer.\n+                Def::VariantCtor(_, CtorKind::Const) => {\n+                    // Size is determined by the whole enum, may be non-zero.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n+                Def::VariantCtor(..) | Def::StructCtor(..) |\n+                Def::Fn(..) | Def::Method(..) => {}\n                 Def::Static(..) => {\n                     match v.mode {\n                         Mode::Static | Mode::StaticMut => {}\n@@ -539,9 +531,9 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n             let is_const = match v.tcx.expect_def_or_none(callee.id) {\n-                Some(Def::Struct(..)) => true,\n-                Some(Def::Variant(..)) => {\n-                    // Count the discriminator.\n+                Some(Def::StructCtor(_, CtorKind::Fn)) |\n+                Some(Def::VariantCtor(_, CtorKind::Fn)) => {\n+                    // `NON_ZERO_SIZED` is about the call result, not about the ctor itself.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     true\n                 }"}, {"sha": "0e0f8a8456731b7327981c89922356302b1cf8f8", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -14,7 +14,7 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as ast_map;\n use rustc::session::{CompileResult, Session};\n-use rustc::hir::def::{Def, DefMap};\n+use rustc::hir::def::{Def, CtorKind, DefMap};\n use rustc::util::nodemap::NodeMap;\n \n use syntax::ast;\n@@ -272,7 +272,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     // affect the specific variant used, but we need to check\n                     // the whole enum definition to see what expression that\n                     // might be (if any).\n-                    Some(Def::Variant(variant_id)) => {\n+                    Some(Def::VariantCtor(variant_id, CtorKind::Const)) => {\n                         if let Some(variant_id) = self.ast_map.as_local_node_id(variant_id) {\n                             let variant = self.ast_map.expect_variant(variant_id);\n                             let enum_id = self.ast_map.get_parent(variant_id);\n@@ -283,7 +283,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                             } else {\n                                 span_bug!(e.span,\n                                           \"`check_static_recursion` found \\\n-                                           non-enum in Def::Variant\");\n+                                           non-enum in Def::VariantCtor\");\n                             }\n                         }\n                     }"}, {"sha": "4ffe2fe38566ec5bb96c9e31b16a4255abe4c59a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -28,7 +28,7 @@ extern crate syntax_pos;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::{self, PatKind};\n-use rustc::hir::def::{self, Def};\n+use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -286,7 +286,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         if self.prev_level.is_some() {\n             if let Some(exports) = self.export_map.get(&id) {\n                 for export in exports {\n-                    if let Some(node_id) = self.tcx.map.as_local_node_id(export.def_id) {\n+                    if let Some(node_id) = self.tcx.map.as_local_node_id(export.def.def_id()) {\n                         self.update(node_id, Some(AccessLevel::Exported));\n                     }\n                 }\n@@ -454,36 +454,25 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprPath(..) => {\n-                if let Def::Struct(..) = self.tcx.expect_def(expr.id) {\n-                    let expr_ty = self.tcx.expr_ty(expr);\n-                    let def = match expr_ty.sty {\n-                        ty::TyFnDef(.., &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n-                            output: ty, ..\n-                        }), ..}) => ty,\n-                        _ => expr_ty\n-                    }.ty_adt_def().unwrap();\n-\n-                    let private_indexes : Vec<_> = def.struct_variant().fields.iter().enumerate()\n-                        .filter(|&(_,f)| {\n-                            !f.vis.is_accessible_from(self.curitem, &self.tcx.map)\n-                    }).map(|(n,&_)|n).collect();\n+                if let def @ Def::StructCtor(_, CtorKind::Fn) = self.tcx.expect_def(expr.id) {\n+                    let adt_def = self.tcx.expect_variant_def(def);\n+                    let private_indexes = adt_def.fields.iter().enumerate().filter(|&(_, field)| {\n+                        !field.vis.is_accessible_from(self.curitem, &self.tcx.map)\n+                    }).map(|(i, _)| i).collect::<Vec<_>>();\n \n                     if !private_indexes.is_empty() {\n-\n                         let mut error = struct_span_err!(self.tcx.sess, expr.span, E0450,\n                                                          \"cannot invoke tuple struct constructor \\\n-                                                         with private fields\");\n+                                                          with private fields\");\n                         error.span_label(expr.span,\n                                          &format!(\"cannot construct with a private field\"));\n \n-                        if let Some(def_id) = self.tcx.map.as_local_node_id(def.did) {\n-                            if let Some(hir::map::NodeItem(node)) = self.tcx.map.find(def_id) {\n-                                if let hir::Item_::ItemStruct(ref tuple_data, _) = node.node {\n-\n-                                    for i in private_indexes {\n-                                        error.span_label(tuple_data.fields()[i].span,\n-                                                         &format!(\"private field declared here\"));\n-                                    }\n+                        if let Some(node_id) = self.tcx.map.as_local_node_id(adt_def.did) {\n+                            let node = self.tcx.map.find(node_id);\n+                            if let Some(hir::map::NodeStructCtor(vdata)) = node {\n+                                for i in private_indexes {\n+                                    error.span_label(vdata.fields()[i].span,\n+                                                     &format!(\"private field declared here\"));\n                                 }\n                             }\n                         }"}, {"sha": "321b814238cfdb0c605ce86570ea2db9c51ac571", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 58, "deletions": 86, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -24,7 +24,6 @@ use {resolve_error, resolve_struct_error, ResolutionError};\n use rustc::middle::cstore::LoadedMacroKind;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::hir::map::DefPathData;\n use rustc::ty;\n \n use std::cell::Cell;\n@@ -78,6 +77,12 @@ impl<'b> Resolver<'b> {\n         })\n     }\n \n+    fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Name>) {\n+        if !field_names.is_empty() {\n+            self.field_names.insert(def_id, field_names);\n+        }\n+    }\n+\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n         let parent = self.current_module;\n@@ -297,32 +302,31 @@ impl<'b> Resolver<'b> {\n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if !struct_def.is_struct() {\n-                    let def = Def::Struct(self.definitions.local_def_id(struct_def.id()));\n-                    self.define(parent, name, ValueNS, (def, sp, vis));\n+                    let ctor_def = Def::StructCtor(self.definitions.local_def_id(struct_def.id()),\n+                                                   CtorKind::from_ast(struct_def));\n+                    self.define(parent, name, ValueNS, (ctor_def, sp, vis));\n                 }\n \n-                // Record the def ID and fields of this struct.\n-                let field_names = struct_def.fields().iter().enumerate().map(|(index, field)| {\n+                // Record field names for error reporting.\n+                let field_names = struct_def.fields().iter().filter_map(|field| {\n                     self.resolve_visibility(&field.vis);\n                     field.ident.map(|ident| ident.name)\n-                               .unwrap_or_else(|| token::intern(&index.to_string()))\n                 }).collect();\n                 let item_def_id = self.definitions.local_def_id(item.id);\n-                self.structs.insert(item_def_id, field_names);\n+                self.insert_field_names(item_def_id, field_names);\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n                 let def = Def::Union(self.definitions.local_def_id(item.id));\n                 self.define(parent, name, TypeNS, (def, sp, vis));\n \n-                // Record the def ID and fields of this union.\n-                let field_names = vdata.fields().iter().enumerate().map(|(index, field)| {\n+                // Record field names for error reporting.\n+                let field_names = vdata.fields().iter().filter_map(|field| {\n                     self.resolve_visibility(&field.vis);\n                     field.ident.map(|ident| ident.name)\n-                               .unwrap_or_else(|| token::intern(&index.to_string()))\n                 }).collect();\n                 let item_def_id = self.definitions.local_def_id(item.id);\n-                self.structs.insert(item_def_id, field_names);\n+                self.insert_field_names(item_def_id, field_names);\n             }\n \n             ItemKind::DefaultImpl(..) | ItemKind::Impl(..) => {}\n@@ -347,17 +351,18 @@ impl<'b> Resolver<'b> {\n                                        parent: Module<'b>,\n                                        vis: ty::Visibility) {\n         let name = variant.node.name.name;\n-        if variant.node.data.is_struct() {\n-            // Not adding fields for variants as they are not accessed with a self receiver\n-            let variant_def_id = self.definitions.local_def_id(variant.node.data.id());\n-            self.structs.insert(variant_def_id, Vec::new());\n-        }\n+        let def_id = self.definitions.local_def_id(variant.node.data.id());\n \n-        // Variants are always treated as importable to allow them to be glob used.\n-        // All variants are defined in both type and value namespaces as future-proofing.\n-        let def = Def::Variant(self.definitions.local_def_id(variant.node.data.id()));\n-        self.define(parent, name, ValueNS, (def, variant.span, vis));\n+        // Define a name in the type namespace.\n+        let def = Def::Variant(def_id);\n         self.define(parent, name, TypeNS, (def, variant.span, vis));\n+\n+        // Define a constructor name in the value namespace.\n+        // Braced variants, unlike structs, generate unusable names in\n+        // value namespace, they are reserved for possible future use.\n+        let ctor_kind = CtorKind::from_ast(&variant.node.data);\n+        let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n+        self.define(parent, name, ValueNS, (ctor_def, variant.span, vis));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n@@ -395,107 +400,74 @@ impl<'b> Resolver<'b> {\n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>,\n                                                   child: Export) {\n-        let def_id = child.def_id;\n         let name = child.name;\n-\n-        let def = if let Some(def) = self.session.cstore.describe_def(def_id) {\n-            def\n-        } else {\n-            return;\n-        };\n-\n+        let def = child.def;\n+        let def_id = def.def_id();\n         let vis = if parent.is_trait() {\n             ty::Visibility::Public\n         } else {\n             self.session.cstore.visibility(def_id)\n         };\n \n         match def {\n-            Def::Mod(_) | Def::Enum(..) => {\n-                debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n-                       name, vis);\n+            Def::Mod(..) | Def::Enum(..) => {\n                 let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n-            Def::Variant(variant_id) => {\n-                debug!(\"(building reduced graph for external crate) building variant {}\", name);\n-                // Variants are always treated as importable to allow them to be glob used.\n-                // All variants are defined in both type and value namespaces as future-proofing.\n-                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n-                let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n-                if self.session.cstore.variant_kind(variant_id) == Some(ty::VariantKind::Struct) {\n-                    // Not adding fields for variants as they are not accessed with a self receiver\n-                    self.structs.insert(variant_id, Vec::new());\n-                }\n+            Def::Variant(..) => {\n+                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+            }\n+            Def::VariantCtor(..) => {\n+                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n             }\n             Def::Fn(..) |\n             Def::Static(..) |\n             Def::Const(..) |\n             Def::AssociatedConst(..) |\n             Def::Method(..) => {\n-                debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n-                       name);\n-                let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n             }\n-            Def::Trait(_) => {\n-                debug!(\"(building reduced graph for external crate) building type {}\", name);\n-\n-                // If this is a trait, add all the trait item names to the trait\n-                // info.\n+            Def::Trait(..) => {\n+                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n+                self.define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n \n+                // If this is a trait, add all the trait item names to the trait info.\n                 let trait_item_def_ids = self.session.cstore.impl_or_trait_items(def_id);\n-                for &trait_item_def in &trait_item_def_ids {\n-                    let trait_item_name =\n-                        self.session.cstore.def_key(trait_item_def)\n-                            .disambiguated_data.data.get_opt_name()\n-                            .expect(\"opt_item_name returned None for trait\");\n-\n-                    debug!(\"(building reduced graph for external crate) ... adding trait item \\\n-                            '{}'\",\n-                           trait_item_name);\n-\n+                for trait_item_def_id in trait_item_def_ids {\n+                    let trait_item_name = self.session.cstore.def_key(trait_item_def_id)\n+                                              .disambiguated_data.data.get_opt_name()\n+                                              .expect(\"opt_item_name returned None for trait\");\n                     self.trait_item_map.insert((trait_item_name, def_id), false);\n                 }\n-\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n-                debug!(\"(building reduced graph for external crate) building type {}\", name);\n-                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n             }\n-            Def::Struct(_)\n-                if self.session.cstore.def_key(def_id).disambiguated_data.data !=\n-                   DefPathData::StructCtor\n-                => {\n-                debug!(\"(building reduced graph for external crate) building type and value for {}\",\n-                       name);\n-                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n-                if let Some(ctor_def_id) = self.session.cstore.struct_ctor_def_id(def_id) {\n-                    let def = Def::Struct(ctor_def_id);\n-                    let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n-                }\n+            Def::Struct(..) => {\n+                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n \n-                // Record the def ID and fields of this struct.\n-                let fields = self.session.cstore.struct_field_names(def_id);\n-                self.structs.insert(def_id, fields);\n+                // Record field names for error reporting.\n+                let field_names = self.session.cstore.struct_field_names(def_id);\n+                self.insert_field_names(def_id, field_names);\n+            }\n+            Def::StructCtor(..) => {\n+                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n             }\n-            Def::Union(_) => {\n-                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+            Def::Union(..) => {\n+                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n \n-                // Record the def ID and fields of this union.\n-                let fields = self.session.cstore.struct_field_names(def_id);\n-                self.structs.insert(def_id, fields);\n+                // Record field names for error reporting.\n+                let field_names = self.session.cstore.struct_field_names(def_id);\n+                self.insert_field_names(def_id, field_names);\n             }\n-            Def::Struct(..) => {}\n             Def::Local(..) |\n             Def::PrimTy(..) |\n             Def::TyParam(..) |\n             Def::Upvar(..) |\n             Def::Label(..) |\n             Def::SelfTy(..) |\n             Def::Err => {\n-                bug!(\"didn't expect `{:?}`\", def);\n+                bug!(\"unexpected definition: {:?}\", def);\n             }\n         }\n     }"}, {"sha": "4f41dfc8b645551e23dab1db11024aba5e27fdc0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -485,7 +485,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              E0531,\n                              \"unresolved {} `{}`\",\n                              expected_what,\n-                             path.segments.last().unwrap().identifier)\n+                             path)\n         }\n         ResolutionError::PatPathUnexpected(expected_what, found_what, path) => {\n             struct_span_err!(resolver.session,\n@@ -494,7 +494,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              \"expected {}, found {} `{}`\",\n                              expected_what,\n                              found_what,\n-                             path.segments.last().unwrap().identifier)\n+                             path)\n         }\n     }\n }\n@@ -924,7 +924,8 @@ impl<'a> NameBinding<'a> {\n \n     fn is_variant(&self) -> bool {\n         match self.kind {\n-            NameBindingKind::Def(Def::Variant(..)) => true,\n+            NameBindingKind::Def(Def::Variant(..)) |\n+            NameBindingKind::Def(Def::VariantCtor(..)) => true,\n             _ => false,\n         }\n     }\n@@ -1005,7 +1006,9 @@ pub struct Resolver<'a> {\n \n     trait_item_map: FnvHashMap<(Name, DefId), bool /* is static method? */>,\n \n-    structs: FnvHashMap<DefId, Vec<Name>>,\n+    // Names of fields of an item `DefId` accessible with dot syntax.\n+    // Used for hints during error reporting.\n+    field_names: FnvHashMap<DefId, Vec<Name>>,\n \n     // All imports known to succeed or fail.\n     determined_imports: Vec<&'a ImportDirective<'a>>,\n@@ -1217,7 +1220,7 @@ impl<'a> Resolver<'a> {\n             prelude: None,\n \n             trait_item_map: FnvHashMap(),\n-            structs: FnvHashMap(),\n+            field_names: FnvHashMap(),\n \n             determined_imports: Vec::new(),\n             indeterminate_imports: Vec::new(),\n@@ -2373,15 +2376,16 @@ impl<'a> Resolver<'a> {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n                                              bmode != BindingMode::ByValue(Mutability::Immutable);\n                         match def {\n-                            Def::Struct(..) | Def::Variant(..) |\n-                            Def::Const(..) | Def::AssociatedConst(..) if !always_binding => {\n-                                // A constant, unit variant, etc pattern.\n+                            Def::StructCtor(_, CtorKind::Const) |\n+                            Def::VariantCtor(_, CtorKind::Const) |\n+                            Def::Const(..) if !always_binding => {\n+                                // A unit struct/variant or constant pattern.\n                                 let name = ident.node.name;\n                                 self.record_use(name, ValueNS, binding.unwrap(), ident.span);\n                                 Some(PathResolution::new(def))\n                             }\n-                            Def::Struct(..) | Def::Variant(..) |\n-                            Def::Const(..) | Def::AssociatedConst(..) | Def::Static(..) => {\n+                            Def::StructCtor(..) | Def::VariantCtor(..) |\n+                            Def::Const(..) | Def::Static(..) => {\n                                 // A fresh binding that shadows something unacceptable.\n                                 resolve_error(\n                                     self,\n@@ -2398,7 +2402,7 @@ impl<'a> Resolver<'a> {\n                             }\n                             def => {\n                                 span_bug!(ident.span, \"unexpected definition for an \\\n-                                                       identifier in pattern {:?}\", def);\n+                                                       identifier in pattern: {:?}\", def);\n                             }\n                         }\n                     }).unwrap_or_else(|| {\n@@ -2408,23 +2412,29 @@ impl<'a> Resolver<'a> {\n                     self.record_def(pat.id, resolution);\n                 }\n \n-                PatKind::TupleStruct(ref path, ..) => {\n+                PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n                     self.resolve_pattern_path(pat.id, None, path, ValueNS, |def| {\n                         match def {\n-                            Def::Struct(..) | Def::Variant(..) => true,\n+                            Def::StructCtor(_, CtorKind::Fn) |\n+                            Def::VariantCtor(_, CtorKind::Fn) => true,\n+                            // `UnitVariant(..)` is accepted for backward compatibility.\n+                            Def::StructCtor(_, CtorKind::Const) |\n+                            Def::VariantCtor(_, CtorKind::Const)\n+                                if pats.is_empty() && ddpos.is_some() => true,\n                             _ => false,\n                         }\n-                    }, \"variant or struct\");\n+                    }, \"tuple struct/variant\");\n                 }\n \n                 PatKind::Path(ref qself, ref path) => {\n                     self.resolve_pattern_path(pat.id, qself.as_ref(), path, ValueNS, |def| {\n                         match def {\n-                            Def::Struct(..) | Def::Variant(..) |\n+                            Def::StructCtor(_, CtorKind::Const) |\n+                            Def::VariantCtor(_, CtorKind::Const) |\n                             Def::Const(..) | Def::AssociatedConst(..) => true,\n                             _ => false,\n                         }\n-                    }, \"variant, struct or constant\");\n+                    }, \"unit struct/variant or constant\");\n                 }\n \n                 PatKind::Struct(ref path, ..) => {\n@@ -2776,10 +2786,9 @@ impl<'a> Resolver<'a> {\n             // Look for a field with the same name in the current self_type.\n             if let Some(resolution) = self.def_map.get(&node_id) {\n                 match resolution.base_def {\n-                    Def::Enum(did) | Def::TyAlias(did) | Def::Union(did) |\n-                    Def::Struct(did) | Def::Variant(did) if resolution.depth == 0 => {\n-                        if let Some(fields) = self.structs.get(&did) {\n-                            if fields.iter().any(|&field_name| name == field_name) {\n+                    Def::Struct(did) | Def::Union(did) if resolution.depth == 0 => {\n+                        if let Some(field_names) = self.field_names.get(&did) {\n+                            if field_names.iter().any(|&field_name| name == field_name) {\n                                 return Field;\n                             }\n                         }\n@@ -2846,13 +2855,11 @@ impl<'a> Resolver<'a> {\n                 if let Some(path_res) = self.resolve_possibly_assoc_item(expr.id,\n                                                             maybe_qself.as_ref(), path, ValueNS) {\n                     // Check if struct variant\n-                    let is_struct_variant = if let Def::Variant(variant_id) = path_res.base_def {\n-                        self.structs.contains_key(&variant_id)\n-                    } else {\n-                        false\n+                    let is_struct_variant = match path_res.base_def {\n+                        Def::VariantCtor(_, CtorKind::Fictive) => true,\n+                        _ => false,\n                     };\n                     if is_struct_variant {\n-                        let _ = self.structs.contains_key(&path_res.base_def.def_id());\n                         let path_name = path_names_to_string(path, 0);\n \n                         let mut err = resolve_struct_error(self,\n@@ -2885,9 +2892,6 @@ impl<'a> Resolver<'a> {\n                     }\n                 } else {\n                     // Be helpful if the name refers to a struct\n-                    // (The pattern matching def_tys where the id is in self.structs\n-                    // matches on regular structs while excluding tuple- and enum-like\n-                    // structs, which wouldn't result in this error.)\n                     let path_name = path_names_to_string(path, 0);\n                     let type_res = self.with_no_errors(|this| {\n                         this.resolve_path(expr.id, path, 0, TypeNS)"}, {"sha": "4689c4ded5c0a4aaec56e47266575f531eb4d4ee", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -797,7 +797,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                (binding.is_import() || binding.is_extern_crate()) {\n                 let def = binding.def();\n                 if def != Def::Err {\n-                    reexports.push(Export { name: name, def_id: def.def_id() });\n+                    reexports.push(Export { name: name, def: def });\n                 }\n             }\n "}, {"sha": "6d9cd88afb17b0bb1784f259f6ccebec727d1c3c", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -271,12 +271,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n     }\n \n-    // looks up anything, not just a type\n-    fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n+    fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n         self.tcx.expect_def_or_none(ref_id).and_then(|def| {\n             match def {\n-                Def::PrimTy(..) => None,\n-                Def::SelfTy(..) => None,\n+                Def::PrimTy(..) | Def::SelfTy(..) => None,\n                 def => Some(def.def_id()),\n             }\n         })\n@@ -303,10 +301,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 }.lower(self.tcx));\n             }\n             Def::Struct(..) |\n+            Def::Variant(..) |\n             Def::Union(..) |\n             Def::Enum(..) |\n             Def::TyAlias(..) |\n-            Def::AssociatedTy(..) |\n             Def::Trait(_) => {\n                 self.dumper.type_ref(TypeRefData {\n                     span: sub_span.expect(\"No span found for type ref\"),\n@@ -316,11 +314,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 }.lower(self.tcx));\n             }\n             Def::Static(..) |\n-            Def::Const(_) |\n-            Def::AssociatedConst(..) |\n-            Def::Local(..) |\n-            Def::Variant(..) |\n-            Def::Upvar(..) => {\n+            Def::Const(..) |\n+            Def::StructCtor(..) |\n+            Def::VariantCtor(..) => {\n                 self.dumper.variable_ref(VariableRefData {\n                     span: sub_span.expect(\"No span found for var ref\"),\n                     ref_id: def_id,\n@@ -335,10 +331,14 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     scope: scope\n                 }.lower(self.tcx));\n             }\n+            Def::Local(..) |\n+            Def::Upvar(..) |\n             Def::SelfTy(..) |\n             Def::Label(_) |\n             Def::TyParam(..) |\n             Def::Method(..) |\n+            Def::AssociatedTy(..) |\n+            Def::AssociatedConst(..) |\n             Def::PrimTy(_) |\n             Def::Err => {\n                span_bug!(span,\n@@ -422,7 +422,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             None => {\n                                 if let Some(NodeItem(item)) = self.tcx.map.get_if_local(id) {\n                                     if let hir::ItemImpl(_, _, _, _, ref ty, _) = item.node {\n-                                        trait_id = self.lookup_type_ref(ty.id);\n+                                        trait_id = self.lookup_def_id(ty.id);\n                                     }\n                                 }\n                             }\n@@ -805,7 +805,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             };\n \n             let trait_ref = &trait_ref.trait_ref;\n-            if let Some(id) = self.lookup_type_ref(trait_ref.ref_id) {\n+            if let Some(id) = self.lookup_def_id(trait_ref.ref_id) {\n                 let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n                 if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n                     self.dumper.type_ref(TypeRefData {\n@@ -924,13 +924,19 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     }\n                 }\n             }\n-            Def::Local(..) |\n-            Def::Static(..) |\n+            Def::Fn(..) |\n             Def::Const(..) |\n+            Def::Static(..) |\n+            Def::StructCtor(..) |\n+            Def::VariantCtor(..) |\n             Def::AssociatedConst(..) |\n+            Def::Local(..) |\n+            Def::Upvar(..) |\n             Def::Struct(..) |\n+            Def::Union(..) |\n             Def::Variant(..) |\n-            Def::Fn(..) => self.write_sub_paths_truncated(path, false),\n+            Def::TyAlias(..) |\n+            Def::AssociatedTy(..) => self.write_sub_paths_truncated(path, false),\n             _ => {}\n         }\n     }\n@@ -1163,7 +1169,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                 match use_item.node {\n                     ast::ViewPathSimple(ident, ref path) => {\n                         let sub_span = self.span.span_for_last_ident(path.span);\n-                        let mod_id = match self.lookup_type_ref(item.id) {\n+                        let mod_id = match self.lookup_def_id(item.id) {\n                             Some(def_id) => {\n                                 let scope = self.cur_scope;\n                                 self.process_def_kind(item.id, path.span, sub_span, def_id, scope);\n@@ -1221,7 +1227,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                         for plid in list {\n                             let scope = self.cur_scope;\n                             let id = plid.node.id;\n-                            if let Some(def_id) = self.lookup_type_ref(id) {\n+                            if let Some(def_id) = self.lookup_def_id(id) {\n                                 let span = plid.span;\n                                 self.process_def_kind(id, span, Some(span), def_id, scope);\n                             }\n@@ -1316,7 +1322,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n         self.process_macro_use(t.span, t.id);\n         match t.node {\n             ast::TyKind::Path(_, ref path) => {\n-                if let Some(id) = self.lookup_type_ref(t.id) {\n+                if let Some(id) = self.lookup_def_id(t.id) {\n                     let sub_span = self.span.sub_span_for_type_name(t.span);\n                     if !self.span.filter_generated(sub_span, t.span) {\n                         self.dumper.type_ref(TypeRefData {\n@@ -1486,14 +1492,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                         }.lower(self.tcx));\n                     }\n                 }\n-                Def::Variant(..) | Def::Enum(..) |\n-                Def::TyAlias(..) | Def::Struct(..) => {\n+                Def::StructCtor(..) | Def::VariantCtor(..) |\n+                Def::Const(..) | Def::AssociatedConst(..) |\n+                Def::Struct(..) | Def::Variant(..) |\n+                Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n-                // FIXME(nrc) what are these doing here?\n-                Def::Static(..) |\n-                Def::Const(..) |\n-                Def::AssociatedConst(..) => {}\n                 def => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n                               def),\n             }"}, {"sha": "15c74f2ed6ab57411a7d5e49aebd4206d7123891", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -507,7 +507,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Def::Static(..) |\n             Def::Const(..) |\n             Def::AssociatedConst(..) |\n-            Def::Variant(..) => {\n+            Def::StructCtor(..) |\n+            Def::VariantCtor(..) => {\n                 Some(Data::VariableRefData(VariableRefData {\n                     name: self.span_utils.snippet(sub_span.unwrap()),\n                     span: sub_span.unwrap(),\n@@ -516,9 +517,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             Def::Struct(def_id) |\n+            Def::Variant(def_id, ..) |\n             Def::Union(def_id) |\n             Def::Enum(def_id) |\n             Def::TyAlias(def_id) |\n+            Def::AssociatedTy(def_id) |\n             Def::Trait(def_id) |\n             Def::TyParam(def_id) => {\n                 Some(Data::TypeRefData(TypeRefData {\n@@ -572,7 +575,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     qualname: String::new() // FIXME: generate the real qualname\n                 }))\n             }\n-            _ => None,\n+            Def::PrimTy(..) |\n+            Def::SelfTy(..) |\n+            Def::Label(..) |\n+            Def::Err => None,\n         }\n     }\n "}, {"sha": "765c128c30b63d8cf0039f561cad06d6050ce2e2", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -24,6 +24,7 @@ use session::Session;\n use llvm::{self, ValueRef};\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType, DILexicalBlock};\n \n+use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::hir;\n@@ -1076,10 +1077,6 @@ struct StructMemberDescriptionFactory<'tcx> {\n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n-        if self.variant.kind == ty::VariantKind::Unit {\n-            return Vec::new();\n-        }\n-\n         let field_size = if self.is_simd {\n             let fty = monomorphize::field_ty(cx.tcx(),\n                                              self.substs,\n@@ -1093,7 +1090,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n         };\n \n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n-            let name = if self.variant.kind == ty::VariantKind::Tuple {\n+            let name = if self.variant.ctor_kind == CtorKind::Fn {\n                 format!(\"__{}\", i)\n             } else {\n                 f.name.to_string()\n@@ -1387,12 +1384,12 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // For the metadata of the wrapper struct, we need to create a\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n-                    name: match non_null_variant.kind {\n-                        ty::VariantKind::Tuple => \"__0\".to_string(),\n-                        ty::VariantKind::Struct => {\n+                    name: match non_null_variant.ctor_kind {\n+                        CtorKind::Fn => \"__0\".to_string(),\n+                        CtorKind::Fictive => {\n                             non_null_variant.fields[0].name.to_string()\n                         }\n-                        ty::VariantKind::Unit => bug!()\n+                        CtorKind::Const => bug!()\n                     },\n                     llvm_type: non_null_llvm_type,\n                     type_metadata: non_null_type_metadata,\n@@ -1579,16 +1576,16 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                            containing_scope);\n \n     // Get the argument names from the enum variant info\n-    let mut arg_names: Vec<_> = match variant.kind {\n-        ty::VariantKind::Unit => vec![],\n-        ty::VariantKind::Tuple => {\n+    let mut arg_names: Vec<_> = match variant.ctor_kind {\n+        CtorKind::Const => vec![],\n+        CtorKind::Fn => {\n             variant.fields\n                    .iter()\n                    .enumerate()\n                    .map(|(i, _)| format!(\"__{}\", i))\n                    .collect()\n         }\n-        ty::VariantKind::Struct => {\n+        CtorKind::Fictive => {\n             variant.fields\n                    .iter()\n                    .map(|f| f.name.to_string())"}, {"sha": "87729da773f45fb9bb984db09985e6ad383cbbf4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 26, "deletions": 59, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def::Def;\n+use rustc::hir::{self, PatKind};\n+use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer::{self, InferOk, TypeOrigin};\n-use hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference, VariantKind};\n+use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation};\n-use lint;\n use util::nodemap::FnvHashMap;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -23,9 +23,6 @@ use syntax::codemap::Spanned;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n-use rustc::hir::{self, PatKind};\n-use rustc::hir::print as pprust;\n-\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_pat(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>) {\n         let tcx = self.tcx;\n@@ -516,10 +513,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         let tcx = self.tcx;\n-        let report_unexpected_def = || {\n+        let report_unexpected_def = |def: Def| {\n             span_err!(tcx.sess, pat.span, E0533,\n-                      \"`{}` does not name a unit variant, unit struct or a constant\",\n-                      pprust::path_to_string(path));\n+                      \"expected unit struct/variant or constant, found {} `{}`\",\n+                      def.kind_name(), path);\n         };\n \n         // Resolve the path and check the definition for errors.\n@@ -531,18 +528,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 return tcx.types.err;\n             }\n             Def::Method(..) => {\n-                report_unexpected_def();\n+                report_unexpected_def(def);\n                 return tcx.types.err;\n             }\n-            Def::Variant(..) | Def::Struct(..) => {\n-                let variant = tcx.expect_variant_def(def);\n-                if variant.kind != VariantKind::Unit {\n-                    report_unexpected_def();\n-                    return tcx.types.err;\n-                }\n-            }\n+            Def::VariantCtor(_, CtorKind::Const) |\n+            Def::StructCtor(_, CtorKind::Const) |\n             Def::Const(..) | Def::AssociatedConst(..) => {} // OK\n-            _ => bug!(\"unexpected pattern definition {:?}\", def)\n+            _ => bug!(\"unexpected pattern definition: {:?}\", def)\n         }\n \n         // Type check the path.\n@@ -564,17 +556,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.check_pat(&pat, tcx.types.err);\n             }\n         };\n-        let report_unexpected_def = |is_lint| {\n-            let msg = format!(\"`{}` does not name a tuple variant or a tuple struct\",\n-                              pprust::path_to_string(path));\n-            if is_lint {\n-                tcx.sess.add_lint(lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n-                                  pat.id, pat.span, msg);\n-            } else {\n-                struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n-                    .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n-                on_error();\n-            }\n+        let report_unexpected_def = |def: Def| {\n+            let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n+                              def.kind_name(), path);\n+            struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n+                .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n+            on_error();\n         };\n \n         // Resolve the path and check the definition for errors.\n@@ -585,33 +572,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 on_error();\n                 return tcx.types.err;\n             }\n-            Def::Const(..) | Def::AssociatedConst(..) | Def::Method(..) => {\n-                report_unexpected_def(false);\n+            Def::AssociatedConst(..) | Def::Method(..) => {\n+                report_unexpected_def(def);\n                 return tcx.types.err;\n             }\n-            Def::Variant(..) | Def::Struct(..) => {\n+            Def::VariantCtor(_, CtorKind::Fn) |\n+            Def::StructCtor(_, CtorKind::Fn) => {\n                 tcx.expect_variant_def(def)\n             }\n-            _ => bug!(\"unexpected pattern definition {:?}\", def)\n+            _ => bug!(\"unexpected pattern definition: {:?}\", def)\n         };\n-        if variant.kind == VariantKind::Unit && subpats.is_empty() && ddpos.is_some() {\n-            // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n-            // is allowed for backward compatibility.\n-            report_unexpected_def(true);\n-        } else if variant.kind != VariantKind::Tuple {\n-            report_unexpected_def(false);\n-            return tcx.types.err;\n-        }\n \n         // Type check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n-        let pat_ty = if pat_ty.is_fn() {\n-            // Replace constructor type with constructed type for tuple struct patterns.\n-            tcx.no_late_bound_regions(&pat_ty.fn_ret()).unwrap()\n-        } else {\n-            // Leave the type as is for unit structs (backward compatibility).\n-            pat_ty\n-        };\n+        // Replace constructor type with constructed type for tuple struct patterns.\n+        let pat_ty = tcx.no_late_bound_regions(&pat_ty.fn_ret()).expect(\"expected fn type\");\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns.\n@@ -626,16 +601,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.check_pat(&subpat, field_ty);\n             }\n         } else {\n-            let subpats_ending = if subpats.len() == 1 {\n-                \"\"\n-            } else {\n-                \"s\"\n-            };\n-            let fields_ending = if variant.fields.len() == 1 {\n-                \"\"\n-            } else {\n-                \"s\"\n-            };\n+            let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n+            let fields_ending = if variant.fields.len() == 1 { \"\" } else { \"s\" };\n             struct_span_err!(tcx.sess, pat.span, E0023,\n                              \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n                              subpats.len(), subpats_ending, def.kind_name(),"}, {"sha": "ac8a35f08b0d97646e8409ea7f75243aa743a299", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -451,27 +451,26 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n         fn handle_external_def(ccx: &CrateCtxt,\n                                traits: &mut AllTraitsVec,\n                                external_mods: &mut FnvHashSet<DefId>,\n-                               def_id: DefId) {\n-            match ccx.tcx.sess.cstore.describe_def(def_id) {\n-                Some(Def::Trait(_)) => {\n+                               def: Def) {\n+            let def_id = def.def_id();\n+            match def {\n+                Def::Trait(..) => {\n                     traits.push(TraitInfo::new(def_id));\n                 }\n-                Some(Def::Mod(_)) => {\n+                Def::Mod(..) => {\n                     if !external_mods.insert(def_id) {\n                         return;\n                     }\n                     for child in ccx.tcx.sess.cstore.item_children(def_id) {\n-                        handle_external_def(ccx, traits, external_mods, child.def_id)\n+                        handle_external_def(ccx, traits, external_mods, child.def)\n                     }\n                 }\n                 _ => {}\n             }\n         }\n         for cnum in ccx.tcx.sess.cstore.crates() {\n-            handle_external_def(ccx, &mut traits, &mut external_mods, DefId {\n-                krate: cnum,\n-                index: CRATE_DEF_INDEX\n-            });\n+            let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+            handle_external_def(ccx, &mut traits, &mut external_mods, Def::Mod(def_id));\n         }\n \n         *ccx.all_traits.borrow_mut() = Some(traits);"}, {"sha": "79c1c5fb5e2e11728aa1a3431de0ce8c81752b13", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 55, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -83,7 +83,7 @@ use self::TupleArgumentsFlag::*;\n use astconv::{AstConv, ast_region_to_region, PathParamMode};\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n-use hir::def::{Def, PathResolution};\n+use hir::def::{Def, CtorKind, PathResolution};\n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n@@ -3020,7 +3020,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         while let Some((base_t, autoderefs)) = autoderef.next() {\n             let field = match base_t.sty {\n                 ty::TyAdt(base_def, substs) if base_def.is_struct() => {\n-                    tuple_like = base_def.struct_variant().kind == ty::VariantKind::Tuple;\n+                    tuple_like = base_def.struct_variant().ctor_kind == CtorKind::Fn;\n                     if !tuple_like { continue }\n \n                     debug!(\"tuple struct named {:?}\",  base_t);\n@@ -3245,7 +3245,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Struct(type_did) | Def::Union(type_did) => {\n                 Some((type_did, self.tcx.expect_variant_def(def)))\n             }\n-            Def::TyAlias(did) => {\n+            Def::TyAlias(did) | Def::AssociatedTy(did) => {\n                 match self.tcx.opt_lookup_item_type(did).map(|scheme| &scheme.ty.sty) {\n                     Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => {\n                         Some((did, adt.struct_variant()))\n@@ -3257,7 +3257,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if let Some((def_id, variant)) = variant {\n-            if variant.kind == ty::VariantKind::Tuple &&\n+            if variant.ctor_kind == CtorKind::Fn &&\n                     !self.tcx.sess.features.borrow().relaxed_adts {\n                 emit_feature_err(&self.tcx.sess.parse_sess,\n                                  \"relaxed_adts\", span, GateIssue::Language,\n@@ -4064,34 +4064,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // There are basically four cases to consider:\n         //\n-        // 1. Reference to a *type*, such as a struct or enum:\n+        // 1. Reference to a constructor of enum variant or struct:\n         //\n-        //        mod a { struct Foo<T> { ... } }\n-        //\n-        //    Because we don't allow types to be declared within one\n-        //    another, a path that leads to a type will always look like\n-        //    `a::b::Foo<T>` where `a` and `b` are modules. This implies\n-        //    that only the final segment can have type parameters, and\n-        //    they are located in the TypeSpace.\n-        //\n-        //    *Note:* Generally speaking, references to types don't\n-        //    actually pass through this function, but rather the\n-        //    `ast_ty_to_ty` function in `astconv`. However, in the case\n-        //    of struct patterns (and maybe literals) we do invoke\n-        //    `instantiate_value_path` to get the general type of an instance of\n-        //    a struct. (In these cases, there are actually no type\n-        //    parameters permitted at present, but perhaps we will allow\n-        //    them in the future.)\n-        //\n-        // 1b. Reference to an enum variant or tuple-like struct:\n-        //\n-        //        struct foo<T>(...)\n-        //        enum E<T> { foo(...) }\n+        //        struct Foo<T>(...)\n+        //        enum E<T> { Foo(...) }\n         //\n         //    In these cases, the parameters are declared in the type\n         //    space.\n         //\n-        // 2. Reference to a *fn item*:\n+        // 2. Reference to a fn item or a free constant:\n         //\n         //        fn foo<T>() { }\n         //\n@@ -4100,7 +4081,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //    type parameters. However, in this case, those parameters are\n         //    declared on a value, and hence are in the `FnSpace`.\n         //\n-        // 3. Reference to a *method*:\n+        // 3. Reference to a method or an associated constant:\n         //\n         //        impl<A> SomeStruct<A> {\n         //            fn foo<B>(...)\n@@ -4112,15 +4093,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n         //    final segment, `foo::<B>` contains parameters in fn space.\n         //\n-        // 4. Reference to an *associated const*:\n-        //\n-        // impl<A> AnotherStruct<A> {\n-        // const FOO: B = BAR;\n-        // }\n+        // 4. Reference to a local variable\n         //\n-        // The path in this case will look like\n-        // `a::b::AnotherStruct::<A>::FOO`, so the penultimate segment\n-        // only will have parameters in TypeSpace.\n+        //    Local variables can't have any type parameters.\n         //\n         // The first step then is to categorize the segments appropriately.\n \n@@ -4130,14 +4105,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut type_segment = None;\n         let mut fn_segment = None;\n         match def {\n-            // Case 1 and 1b. Reference to a *type* or *enum variant*.\n-            Def::Struct(def_id) |\n-            Def::Union(def_id) |\n-            Def::Variant(def_id) |\n-            Def::Enum(def_id) |\n-            Def::TyAlias(def_id) |\n-            Def::AssociatedTy(def_id) |\n-            Def::Trait(def_id) => {\n+            // Case 1. Reference to a struct/variant constructor.\n+            Def::StructCtor(def_id, ..) |\n+            Def::VariantCtor(def_id, ..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n                 let mut generics = self.tcx.lookup_generics(def_id);\n@@ -4180,17 +4150,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 fn_segment = Some((segments.last().unwrap(), generics));\n             }\n \n-            // Other cases. Various nonsense that really shouldn't show up\n-            // here. If they do, an error will have been reported\n-            // elsewhere. (I hope)\n-            Def::Mod(..) |\n-            Def::PrimTy(..) |\n-            Def::SelfTy(..) |\n-            Def::TyParam(..) |\n-            Def::Local(..) |\n-            Def::Label(..) |\n-            Def::Upvar(..) |\n-            Def::Err => {}\n+            // Case 4. Local variable, no generics.\n+            Def::Local(..) | Def::Upvar(..) => {}\n+\n+            _ => bug!(\"unexpected definition: {:?}\", def),\n         }\n \n         // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory, but"}, {"sha": "128db6ef5848a8c525a680e83813cf3c4c417aca", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -68,7 +68,6 @@ use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n-use rustc::ty::{VariantKind};\n use rustc::ty::util::IntTypeExt;\n use rscope::*;\n use rustc::dep_graph::DepNode;\n@@ -87,7 +86,7 @@ use syntax::parse::token::keywords;\n use syntax_pos::Span;\n \n use rustc::hir::{self, intravisit, map as hir_map, print as pprust};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -987,9 +986,9 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let tcx = ccx.tcx;\n     let def_id = tcx.map.local_def_id(ctor_id);\n     generics_of_def_id(ccx, def_id);\n-    let ctor_ty = match variant.kind {\n-        VariantKind::Unit | VariantKind::Struct => scheme.ty,\n-        VariantKind::Tuple => {\n+    let ctor_ty = match variant.ctor_kind {\n+        CtorKind::Fictive | CtorKind::Const => scheme.ty,\n+        CtorKind::Fn => {\n             let inputs: Vec<_> =\n                 variant.fields\n                 .iter()\n@@ -1066,7 +1065,7 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         name: name,\n         disr_val: disr_val,\n         fields: fields,\n-        kind: VariantKind::from_variant_data(def),\n+        ctor_kind: CtorKind::from_hir(def),\n     }\n }\n "}, {"sha": "feca2d328fe3b2432414d955b8395a6ac60866bc", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -15,11 +15,10 @@ use std::iter::once;\n use syntax::ast;\n use rustc::hir;\n \n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::DefPathData;\n use rustc::hir::print as pprust;\n-use rustc::ty::{self, TyCtxt, VariantKind};\n+use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::FnvHashSet;\n \n use rustc_const_eval::lookup_const_by_id;\n@@ -81,9 +80,7 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             record_extern_fqn(cx, did, clean::TypeKind::Function);\n             clean::FunctionItem(build_external_function(cx, tcx, did))\n         }\n-        Def::Struct(did)\n-                // If this is a struct constructor, we skip it\n-                if tcx.def_key(did).disambiguated_data.data != DefPathData::StructCtor => {\n+        Def::Struct(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n             ret.extend(build_impls(cx, tcx, did));\n             clean::StructItem(build_struct(cx, tcx, did))\n@@ -105,7 +102,10 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n-        Def::Variant(..) => return Some(Vec::new()),\n+        // Similarly, consider that struct type is reexported next to its constructor.\n+        Def::Variant(..) |\n+        Def::VariantCtor(..) |\n+        Def::StructCtor(..) => return Some(Vec::new()),\n         Def::Mod(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Module);\n             clean::ModuleItem(build_module(cx, tcx, did))\n@@ -114,7 +114,7 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             record_extern_fqn(cx, did, clean::TypeKind::Static);\n             clean::StaticItem(build_static(cx, tcx, did, mtbl))\n         }\n-        Def::Const(did) | Def::AssociatedConst(did) => {\n+        Def::Const(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Const);\n             clean::ConstantItem(build_const(cx, tcx, did))\n         }\n@@ -219,10 +219,10 @@ fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let variant = tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Struct {\n-        struct_type: match variant.kind {\n-            VariantKind::Struct => doctree::Plain,\n-            VariantKind::Tuple => doctree::Tuple,\n-            VariantKind::Unit => doctree::Unit,\n+        struct_type: match variant.ctor_kind {\n+            CtorKind::Fictive => doctree::Plain,\n+            CtorKind::Fn => doctree::Tuple,\n+            CtorKind::Const => doctree::Unit,\n         },\n         generics: (t.generics, &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n@@ -498,12 +498,11 @@ fn build_module<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // visit each node at most once.\n         let mut visited = FnvHashSet();\n         for item in tcx.sess.cstore.item_children(did) {\n-            if tcx.sess.cstore.visibility(item.def_id) == ty::Visibility::Public {\n-                if !visited.insert(item.def_id) { continue }\n-                if let Some(def) = tcx.sess.cstore.describe_def(item.def_id) {\n-                    if let Some(i) = try_inline_def(cx, tcx, def) {\n-                        items.extend(i)\n-                    }\n+            let def_id = item.def.def_id();\n+            if tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {\n+                if !visited.insert(def_id) { continue }\n+                if let Some(i) = try_inline_def(cx, tcx, item.def) {\n+                    items.extend(i)\n                 }\n             }\n         }"}, {"sha": "eb6115e9373150a2f07581912115174c44fa8947", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -32,7 +32,7 @@ use syntax_pos::{self, DUMMY_SP, Pos};\n use rustc_trans::back::link;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime::DefRegion::*;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{self, DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n@@ -237,7 +237,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         let root = DefId { krate: self.0, index: CRATE_DEF_INDEX };\n         cx.tcx_opt().map(|tcx| {\n             for item in tcx.sess.cstore.item_children(root) {\n-                let attrs = inline::load_attrs(cx, tcx, item.def_id);\n+                let attrs = inline::load_attrs(cx, tcx, item.def.def_id());\n                 PrimitiveType::find(&attrs).map(|prim| primitives.push(prim));\n             }\n         });\n@@ -2032,14 +2032,14 @@ impl Clean<Item> for doctree::Variant {\n \n impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        let kind = match self.kind {\n-            ty::VariantKind::Unit => VariantKind::CLike,\n-            ty::VariantKind::Tuple => {\n+        let kind = match self.ctor_kind {\n+            CtorKind::Const => VariantKind::CLike,\n+            CtorKind::Fn => {\n                 VariantKind::Tuple(\n                     self.fields.iter().map(|f| f.unsubst_ty().clean(cx)).collect()\n                 )\n             }\n-            ty::VariantKind::Struct => {\n+            CtorKind::Fictive => {\n                 VariantKind::Struct(VariantStruct {\n                     struct_type: doctree::Plain,\n                     fields_stripped: false,"}, {"sha": "6d2830c56192bb434b73485384b6a9681d8d7d8b", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -66,11 +66,12 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n \n     pub fn visit_mod(&mut self, def_id: DefId) {\n         for item in self.cstore.item_children(def_id) {\n-            self.visit_item(item.def_id);\n+            self.visit_item(item.def);\n         }\n     }\n \n-    fn visit_item(&mut self, def_id: DefId) {\n+    fn visit_item(&mut self, def: Def) {\n+        let def_id = def.def_id();\n         let vis = self.cstore.visibility(def_id);\n         let inherited_item_level = if vis == Visibility::Public {\n             self.prev_level\n@@ -80,7 +81,7 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n \n         let item_level = self.update(def_id, inherited_item_level);\n \n-        if let Some(Def::Mod(_)) = self.cstore.describe_def(def_id) {\n+        if let Def::Mod(..) = def {\n             let orig_level = self.prev_level;\n \n             self.prev_level = item_level;"}, {"sha": "8d21cde84da1c06bd9a498b408225ec84887d9bf", "filename": "src/test/compile-fail/E0164.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2FE0164.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2FE0164.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0164.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -8,7 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Foo { B { i: u32 } }\n+#![feature(associated_consts)]\n+\n+enum Foo {}\n+\n+impl Foo {\n+    const B: u8 = 0;\n+}\n \n fn bar(foo: Foo) -> u32 {\n     match foo {"}, {"sha": "88e8b0d56fe3d4ab3e94bcdafe6b957794859851", "filename": "src/test/compile-fail/auxiliary/namespace-mix-new.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-new.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(item_like_imports, relaxed_adts)]\n+\n+pub mod c {\n+    pub struct S {}\n+    pub struct TS();\n+    pub struct US;\n+    pub enum E {\n+        V {},\n+        TV(),\n+        UV,\n+    }\n+\n+    pub struct Item;\n+}\n+\n+pub mod xm1 {\n+    pub use ::c::*;\n+    pub type S = ::c::Item;\n+}\n+pub mod xm2 {\n+    pub use ::c::*;\n+    pub const S: ::c::Item = ::c::Item;\n+}\n+\n+pub mod xm3 {\n+    pub use ::c::*;\n+    pub type TS = ::c::Item;\n+}\n+pub mod xm4 {\n+    pub use ::c::*;\n+    pub const TS: ::c::Item = ::c::Item;\n+}\n+\n+pub mod xm5 {\n+    pub use ::c::*;\n+    pub type US = ::c::Item;\n+}\n+pub mod xm6 {\n+    pub use ::c::*;\n+    pub const US: ::c::Item = ::c::Item;\n+}\n+\n+pub mod xm7 {\n+    pub use ::c::E::*;\n+    pub type V = ::c::Item;\n+}\n+pub mod xm8 {\n+    pub use ::c::E::*;\n+    pub const V: ::c::Item = ::c::Item;\n+}\n+\n+pub mod xm9 {\n+    pub use ::c::E::*;\n+    pub type TV = ::c::Item;\n+}\n+pub mod xmA {\n+    pub use ::c::E::*;\n+    pub const TV: ::c::Item = ::c::Item;\n+}\n+\n+pub mod xmB {\n+    pub use ::c::E::*;\n+    pub type UV = ::c::Item;\n+}\n+pub mod xmC {\n+    pub use ::c::E::*;\n+    pub const UV: ::c::Item = ::c::Item;\n+}"}, {"sha": "7bbba7163b5570c98ad5e56235f1b2fd0746cdcf", "filename": "src/test/compile-fail/auxiliary/namespace-mix-old.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-old.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME: Remove when `item_like_imports` is stabilized.\n+\n+#![feature(relaxed_adts)]\n+\n+pub mod c {\n+    pub struct S {}\n+    pub struct TS();\n+    pub struct US;\n+    pub enum E {\n+        V {},\n+        TV(),\n+        UV,\n+    }\n+\n+    pub struct Item;\n+}\n+\n+pub mod proxy {\n+    pub use c::*;\n+    pub use c::E::*;\n+}\n+\n+pub mod xm1 {\n+    pub use ::proxy::*;\n+    pub type S = ::c::Item;\n+}\n+pub mod xm2 {\n+    pub use ::proxy::*;\n+    pub const S: ::c::Item = ::c::Item;\n+}\n+\n+pub mod xm3 {\n+    pub use ::proxy::*;\n+    pub type TS = ::c::Item;\n+}\n+pub mod xm4 {\n+    pub use ::proxy::*;\n+    pub const TS: ::c::Item = ::c::Item;\n+}\n+\n+pub mod xm5 {\n+    pub use ::proxy::*;\n+    pub type US = ::c::Item;\n+}\n+pub mod xm6 {\n+    pub use ::proxy::*;\n+    pub const US: ::c::Item = ::c::Item;\n+}\n+\n+pub mod xm7 {\n+    pub use ::proxy::*;\n+    pub type V = ::c::Item;\n+}\n+pub mod xm8 {\n+    pub use ::proxy::*;\n+    pub const V: ::c::Item = ::c::Item;\n+}\n+\n+pub mod xm9 {\n+    pub use ::proxy::*;\n+    pub type TV = ::c::Item;\n+}\n+pub mod xmA {\n+    pub use ::proxy::*;\n+    pub const TV: ::c::Item = ::c::Item;\n+}\n+\n+pub mod xmB {\n+    pub use ::proxy::*;\n+    pub type UV = ::c::Item;\n+}\n+pub mod xmC {\n+    pub use ::proxy::*;\n+    pub const UV: ::c::Item = ::c::Item;\n+}"}, {"sha": "0db7eaf0ca7c3ea5e319cef0aa266481ab1256d5", "filename": "src/test/compile-fail/blind-item-block-middle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -12,6 +12,6 @@ mod foo { pub struct bar; }\n \n fn main() {\n     let bar = 5;\n-    //~^ ERROR let bindings cannot shadow structs\n+    //~^ ERROR let bindings cannot shadow unit structs\n     use foo::bar;\n }"}, {"sha": "e527170e9f9579d76282c0a44df60b373ba8b896", "filename": "src/test/compile-fail/empty-struct-braces-pat-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -32,13 +32,13 @@ fn main() {\n     }\n     match e3 {\n         E::Empty3 => ()\n-        //~^ ERROR `E::Empty3` does not name a unit variant, unit struct or a constant\n+        //~^ ERROR expected unit struct/variant or constant, found struct variant `E::Empty3`\n     }\n     match xe1 {\n         XEmpty1 => () // Not an error, `XEmpty1` is interpreted as a new binding\n     }\n     match xe3 {\n         XE::XEmpty3 => ()\n-        //~^ ERROR `XE::XEmpty3` does not name a unit variant, unit struct or a constant\n+        //~^ ERROR expected unit struct/variant or constant, found struct variant `XE::XEmpty3`\n     }\n }"}, {"sha": "58e3ca6b3ac5cb3c8cdd216f38c602efc800804b", "filename": "src/test/compile-fail/empty-struct-braces-pat-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -24,15 +24,15 @@ fn main() {\n     let xe1 = XEmpty1 {};\n \n     match e1 {\n-        Empty1() => () //~ ERROR unresolved variant or struct `Empty1`\n+        Empty1() => () //~ ERROR unresolved tuple struct/variant `Empty1`\n     }\n     match xe1 {\n-        XEmpty1() => () //~ ERROR unresolved variant or struct `XEmpty1`\n+        XEmpty1() => () //~ ERROR unresolved tuple struct/variant `XEmpty1`\n     }\n     match e1 {\n-        Empty1(..) => () //~ ERROR unresolved variant or struct `Empty1`\n+        Empty1(..) => () //~ ERROR unresolved tuple struct/variant `Empty1`\n     }\n     match xe1 {\n-        XEmpty1(..) => () //~ ERROR unresolved variant or struct `XEmpty1`\n+        XEmpty1(..) => () //~ ERROR unresolved tuple struct/variant `XEmpty1`\n     }\n }"}, {"sha": "1960eca9f80281a3c1f22a69c5b1d4035520b505", "filename": "src/test/compile-fail/empty-struct-braces-pat-3.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-3.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -26,15 +26,19 @@ fn main() {\n     let xe3 = XE::XEmpty3 {};\n \n     match e3 {\n-        E::Empty3() => () //~ ERROR `E::Empty3` does not name a tuple variant or a tuple struct\n+        E::Empty3() => ()\n+        //~^ ERROR expected tuple struct/variant, found struct variant `E::Empty3`\n     }\n     match xe3 {\n-        XE::XEmpty3() => () //~ ERROR `XE::XEmpty3` does not name a tuple variant or a tuple struct\n+        XE::XEmpty3() => ()\n+        //~^ ERROR expected tuple struct/variant, found struct variant `XE::XEmpty3`\n     }\n     match e3 {\n-        E::Empty3(..) => () //~ ERROR `E::Empty3` does not name a tuple variant or a tuple struct\n+        E::Empty3(..) => ()\n+        //~^ ERROR expected tuple struct/variant, found struct variant `E::Empty3`\n     }\n     match xe3 {\n-        XE::XEmpty3(..) => () //~ ERROR `XE::XEmpty3` does not name a tuple variant or a tuple\n+        XE::XEmpty3(..) => ()\n+        //~^ ERROR expected tuple struct/variant, found struct variant `XE::XEmpty3\n     }\n }"}, {"sha": "f15c126a1260837128a297fe03b4a3707300ce37", "filename": "src/test/compile-fail/empty-struct-tuple-pat.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-tuple-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-tuple-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-tuple-pat.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -31,17 +31,19 @@ fn main() {\n     let xe5 = XE::XEmpty5();\n \n     match e2 {\n-        Empty2 => () //~ ERROR `Empty2` does not name a unit variant, unit struct or a constant\n+        Empty2 => () //~ ERROR match bindings cannot shadow tuple structs\n     }\n     match xe6 {\n-        XEmpty6 => () //~ ERROR `XEmpty6` does not name a unit variant, unit struct or a constant\n+        XEmpty6 => () //~ ERROR match bindings cannot shadow tuple structs\n     }\n \n     match e4 {\n-        E::Empty4 => () //~ ERROR `E::Empty4` does not name a unit variant, unit struct or a\n+        E::Empty4 => ()\n+        //~^ ERROR expected unit struct/variant or constant, found tuple variant `E::Empty4`\n     }\n     match xe5 {\n-        XE::XEmpty5 => (), //~ ERROR `XE::XEmpty5` does not name a unit variant, unit struct or a\n+        XE::XEmpty5 => (),\n+        //~^ ERROR expected unit struct/variant or constant, found tuple variant `XE::XEmpty5`\n         _ => {},\n     }\n }"}, {"sha": "273cb48b2d2a5d8ff888e8c99cabb0c0c082751a", "filename": "src/test/compile-fail/empty-struct-unit-pat-1.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat-1.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -31,21 +31,22 @@ fn main() {\n     let xe4 = XE::XEmpty4;\n \n     match e2 {\n-        Empty2(..) => () //~ ERROR `Empty2` does not name a tuple variant or a tuple struct\n+        Empty2(..) => () //~ ERROR expected tuple struct/variant, found unit struct `Empty2`\n             //~^ WARNING hard error\n     }\n     match xe2 {\n-        XEmpty2(..) => () //~ ERROR `XEmpty2` does not name a tuple variant or a tuple struct\n+        XEmpty2(..) => () //~ ERROR expected tuple struct/variant, found unit struct `XEmpty2`\n             //~^ WARNING hard error\n     }\n \n     match e4 {\n-        E::Empty4(..) => () //~ ERROR `E::Empty4` does not name a tuple variant or a tuple struct\n+        E::Empty4(..) => () //~ ERROR expected tuple struct/variant, found unit variant `E::Empty4`\n             //~^ WARNING hard error\n     }\n     match xe4 {\n-        XE::XEmpty4(..) => (), //~ ERROR `XE::XEmpty4` does not name a tuple variant or a tuple\n-            //~^ WARNING hard error\n+        XE::XEmpty4(..) => (),\n+            //~^ ERROR expected tuple struct/variant, found unit variant `XE::XEmpty4`\n+            //~| WARNING hard error\n         _ => {},\n     }\n }"}, {"sha": "993f10e08067b2375582332a1359a9020a83faad", "filename": "src/test/compile-fail/empty-struct-unit-pat-2.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat-2.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -23,25 +23,28 @@ enum E {\n     Empty4\n }\n \n-// remove attribute after warning cycle and promoting warnings to errors\n fn main() {\n     let e2 = Empty2;\n     let e4 = E::Empty4;\n     let xe2 = XEmpty2;\n     let xe4 = XE::XEmpty4;\n \n     match e2 {\n-        Empty2() => () //~ ERROR `Empty2` does not name a tuple variant or a tuple struct\n+        Empty2() => ()\n+        //~^ ERROR expected tuple struct/variant, found unit struct `Empty2`\n     }\n     match xe2 {\n-        XEmpty2() => () //~ ERROR `XEmpty2` does not name a tuple variant or a tuple struct\n+        XEmpty2() => ()\n+        //~^ ERROR expected tuple struct/variant, found unit struct `XEmpty2`\n     }\n \n     match e4 {\n-        E::Empty4() => () //~ ERROR `E::Empty4` does not name a tuple variant or a tuple struct\n+        E::Empty4() => ()\n+        //~^ ERROR expected tuple struct/variant, found unit variant `E::Empty4`\n     }\n     match xe4 {\n-        XE::XEmpty4() => (), //~ ERROR `XE::XEmpty4` does not name a tuple variant or a tuple\n+        XE::XEmpty4() => (),\n+        //~^ ERROR expected tuple struct/variant, found unit variant `XE::XEmpty4`\n         _ => {},\n     }\n }"}, {"sha": "bc1bd03f2d65253e88a0aaee661690e4b14437c1", "filename": "src/test/compile-fail/enum-in-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -11,5 +11,5 @@\n struct hello(isize);\n \n fn main() {\n-    let hello = 0; //~ERROR let bindings cannot shadow structs\n+    let hello = 0; //~ERROR let bindings cannot shadow tuple structs\n }"}, {"sha": "03bdbe4e54b6815f3fdb798abb1a1f87075ebf8b", "filename": "src/test/compile-fail/enums-pats-not-idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let a(1) = 13; //~ ERROR unresolved variant or struct `a`\n+    let a(1) = 13; //~ ERROR unresolved tuple struct/variant `a`\n }"}, {"sha": "8c58ef6261e10485fa20e7265f475b7d72c4d1a0", "filename": "src/test/compile-fail/issue-10200.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-10200.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-10200.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10200.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -13,7 +13,7 @@ fn foo(_: usize) -> Foo { Foo(false) }\n \n fn main() {\n     match Foo(true) {\n-        foo(x) //~ ERROR expected variant or struct, found function `foo`\n+        foo(x) //~ ERROR expected tuple struct/variant, found function `foo`\n         => ()\n     }\n }"}, {"sha": "d3432410c5427b6a99feea3bc952cbb347b23ec9", "filename": "src/test/compile-fail/issue-12863.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -12,6 +12,6 @@ mod foo { pub fn bar() {} }\n \n fn main() {\n     match () {\n-        foo::bar => {} //~ ERROR expected variant, struct or constant, found function `bar`\n+        foo::bar => {} //~ ERROR expected unit struct/variant or constant, found function `foo::bar`\n     }\n }"}, {"sha": "049a0665c54589049c931376ba0bdddc21bfc52d", "filename": "src/test/compile-fail/issue-17933.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-17933.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-17933.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17933.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -13,7 +13,7 @@ pub static X: usize = 1;\n fn main() {\n     match 1 {\n         self::X => { },\n-        //~^ ERROR expected variant, struct or constant, found static `X`\n+        //~^ ERROR expected unit struct/variant or constant, found static `self::X`\n         _       => { },\n     }\n }"}, {"sha": "ba571ce17fd12eb58cd42a0bbe3f5e4be228c14f", "filename": "src/test/compile-fail/issue-19086.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-19086.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-19086.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19086.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -18,6 +18,6 @@ fn main() {\n     let f = FooB { x: 3, y: 4 };\n     match f {\n         FooB(a, b) => println!(\"{} {}\", a, b),\n-//~^ ERROR `FooB` does not name a tuple variant or a tuple struct\n+        //~^ ERROR expected tuple struct/variant, found struct variant `FooB`\n     }\n }"}, {"sha": "b8552aaee9005106d631dec1cabf3c7fd28db894", "filename": "src/test/compile-fail/issue-27033.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     match Some(1) {\n-        None @ _ => {} //~ ERROR match bindings cannot shadow variants\n+        None @ _ => {} //~ ERROR match bindings cannot shadow unit variants\n     };\n     const C: u8 = 1;\n     match 1 {"}, {"sha": "33930d1db1476dcaa1995027ef481dec3f5ed3de", "filename": "src/test/compile-fail/issue-27815.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -14,7 +14,9 @@ fn main() {\n     let u = A { x: 1 }; //~ ERROR `A` does not name a struct or a struct variant\n     let v = u32 { x: 1 }; //~ ERROR `u32` does not name a struct or a struct variant\n     match () {\n-        A { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found module `A`\n-        u32 { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found builtin type `u32\n+        A { x: 1 } => {}\n+        //~^ ERROR expected variant, struct or type alias, found module `A`\n+        u32 { x: 1 } => {}\n+        //~^ ERROR expected variant, struct or type alias, found builtin type `u32`\n     }\n }"}, {"sha": "d47fdda0203e8f0e38e92233d5d5816496935dee", "filename": "src/test/compile-fail/issue-28992-empty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -21,6 +21,7 @@ impl S {\n }\n \n fn main() {\n-    if let C1(..) = 0 {} //~ ERROR expected variant or struct, found constant `C1`\n-    if let S::C2(..) = 0 {} //~ ERROR `S::C2` does not name a tuple variant or a tuple struct\n+    if let C1(..) = 0 {} //~ ERROR expected tuple struct/variant, found constant `C1`\n+    if let S::C2(..) = 0 {}\n+    //~^ ERROR expected tuple struct/variant, found associated constant `S::C2`\n }"}, {"sha": "7e1f4c28d21e94bbc2dc65b23d6370f0c7f07471", "filename": "src/test/compile-fail/issue-32004.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -18,12 +18,12 @@ struct S;\n fn main() {\n     match Foo::Baz {\n         Foo::Bar => {}\n-        //~^ ERROR `Foo::Bar` does not name a unit variant, unit struct or a constant\n+        //~^ ERROR expected unit struct/variant or constant, found tuple variant `Foo::Bar`\n         _ => {}\n     }\n \n     match S {\n         S(()) => {}\n-        //~^ ERROR `S` does not name a tuple variant or a tuple struct\n+        //~^ ERROR expected tuple struct/variant, found unit struct `S`\n     }\n }"}, {"sha": "dd236b76a67396975acd32d03822ea897a3b9afc", "filename": "src/test/compile-fail/issue-32086.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-32086.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-32086.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32086.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -12,6 +12,6 @@ struct S(u8);\n const C: S = S(10);\n \n fn main() {\n-    let C(a) = S(11); //~ ERROR expected variant or struct, found constant `C`\n-    let C(..) = S(11); //~ ERROR expected variant or struct, found constant `C`\n+    let C(a) = S(11); //~ ERROR expected tuple struct/variant, found constant `C`\n+    let C(..) = S(11); //~ ERROR expected tuple struct/variant, found constant `C`\n }"}, {"sha": "7668a2117a26592b3b72edf183b76de5e8bccf8e", "filename": "src/test/compile-fail/issue-5927.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -11,7 +11,7 @@\n \n fn main() {\n     let z = match 3 {\n-        x(1) => x(1) //~ ERROR unresolved variant or struct `x`\n+        x(1) => x(1) //~ ERROR unresolved tuple struct/variant `x`\n         //~^ ERROR unresolved name `x`\n     };\n     assert!(z == 3);"}, {"sha": "aed9130d60e4b73b5a05d6c61abb27efbbf69637", "filename": "src/test/compile-fail/match-pattern-field-mismatch-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch-2.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -20,7 +20,7 @@ fn main() {\n           color::rgb(_, _, _) => { }\n           color::cmyk(_, _, _, _) => { }\n           color::no_color(_) => { }\n-          //~^ ERROR `color::no_color` does not name a tuple variant or a tuple struct\n+          //~^ ERROR expected tuple struct/variant, found unit variant `color::no_color`\n         }\n     }\n }"}, {"sha": "ddd5d63317011c4a82822791ed14506690f9615f", "filename": "src/test/compile-fail/match-pattern-field-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -18,7 +18,7 @@ fn main() {\n     fn foo(c: color) {\n         match c {\n           color::rgb(_, _) => { }\n-          //~^ ERROR this pattern has 2 fields, but the corresponding variant has 3 fields\n+          //~^ ERROR this pattern has 2 fields, but the corresponding tuple variant has 3 fields\n           color::cmyk(_, _, _, _) => { }\n           color::no_color => { }\n         }"}, {"sha": "aaa89b2282967318a630f10e7a6df2706c447bba", "filename": "src/test/compile-fail/method-path-in-pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -22,13 +22,13 @@ impl MyTrait for Foo {}\n \n fn main() {\n     match 0u32 {\n-        Foo::bar => {} //~ ERROR `Foo::bar` does not name a unit variant, unit struct or a constant\n+        Foo::bar => {} //~ ERROR expected unit struct/variant or constant, found method `Foo::bar`\n     }\n     match 0u32 {\n-        <Foo>::bar => {} //~ ERROR `bar` does not name a unit variant, unit struct or a constant\n+        <Foo>::bar => {} //~ ERROR expected unit struct/variant or constant, found method `bar`\n     }\n     match 0u32 {\n         <Foo>::trait_bar => {}\n-        //~^ ERROR `trait_bar` does not name a unit variant, unit struct or a constant\n+        //~^ ERROR expected unit struct/variant or constant, found method `trait_bar`\n     }\n }"}, {"sha": "4d8959466b948951366919105b833df35e95c03d", "filename": "src/test/compile-fail/method-resolvable-path-in-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -19,6 +19,6 @@ impl MyTrait for Foo {}\n fn main() {\n     match 0u32 {\n         <Foo as MyTrait>::trait_bar => {}\n-        //~^ ERROR expected variant, struct or constant, found method `trait_bar`\n+        //~^ ERROR expected unit struct/variant or constant, found method `MyTrait::trait_bar`\n     }\n }"}, {"sha": "4c76c4b8b0265662e236c3024bb58d395af6e117", "filename": "src/test/compile-fail/name-clash-nullary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -11,7 +11,7 @@\n use std::option::*;\n \n fn main() {\n-  let None: isize = 42; //~ ERROR let bindings cannot shadow variants\n+  let None: isize = 42; //~ ERROR let bindings cannot shadow unit variants\n   log(debug, None);\n   //~^ ERROR unresolved name `debug`\n   //~| ERROR unresolved name `log`"}, {"sha": "0abe8bd4390935dc64a9135cdd9edaecde373cc2", "filename": "src/test/compile-fail/namespace-mix-new.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-new.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:namespace-mix-new.rs\n+\n+#![feature(item_like_imports, relaxed_adts)]\n+\n+extern crate namespace_mix_new;\n+use namespace_mix_new::*;\n+\n+mod c {\n+    pub struct S {}\n+    pub struct TS();\n+    pub struct US;\n+    pub enum E {\n+        V {},\n+        TV(),\n+        UV,\n+    }\n+\n+    pub struct Item;\n+}\n+\n+// Use something emitting the type argument name, e.g. unsatisfied bound.\n+trait Impossible {}\n+fn check<T: Impossible>(_: T) {}\n+\n+mod m1 {\n+    pub use ::c::*;\n+    pub type S = ::c::Item;\n+}\n+mod m2 {\n+    pub use ::c::*;\n+    pub const S: ::c::Item = ::c::Item;\n+}\n+\n+fn f12() {\n+    check(m1::S{}); //~ ERROR c::Item\n+    check(m1::S); //~ ERROR unresolved name\n+    check(m2::S{}); //~ ERROR c::S\n+    check(m2::S); //~ ERROR c::Item\n+}\n+fn xf12() {\n+    check(xm1::S{}); //~ ERROR c::Item\n+    check(xm1::S); //~ ERROR unresolved name\n+    check(xm2::S{}); //~ ERROR c::S\n+    check(xm2::S); //~ ERROR c::Item\n+}\n+\n+mod m3 {\n+    pub use ::c::*;\n+    pub type TS = ::c::Item;\n+}\n+mod m4 {\n+    pub use ::c::*;\n+    pub const TS: ::c::Item = ::c::Item;\n+}\n+\n+fn f34() {\n+    check(m3::TS{}); //~ ERROR c::Item\n+    check(m3::TS); //~ ERROR c::TS\n+    check(m4::TS{}); //~ ERROR c::TS\n+    check(m4::TS); //~ ERROR c::Item\n+}\n+fn xf34() {\n+    check(xm3::TS{}); //~ ERROR c::Item\n+    check(xm3::TS); //~ ERROR c::TS\n+    check(xm4::TS{}); //~ ERROR c::TS\n+    check(xm4::TS); //~ ERROR c::Item\n+}\n+\n+mod m5 {\n+    pub use ::c::*;\n+    pub type US = ::c::Item;\n+}\n+mod m6 {\n+    pub use ::c::*;\n+    pub const US: ::c::Item = ::c::Item;\n+}\n+\n+fn f56() {\n+    check(m5::US{}); //~ ERROR c::Item\n+    check(m5::US); //~ ERROR c::US\n+    check(m6::US{}); //~ ERROR c::US\n+    check(m6::US); //~ ERROR c::Item\n+}\n+fn xf56() {\n+    check(xm5::US{}); //~ ERROR c::Item\n+    check(xm5::US); //~ ERROR c::US\n+    check(xm6::US{}); //~ ERROR c::US\n+    check(xm6::US); //~ ERROR c::Item\n+}\n+\n+mod m7 {\n+    pub use ::c::E::*;\n+    pub type V = ::c::Item;\n+}\n+mod m8 {\n+    pub use ::c::E::*;\n+    pub const V: ::c::Item = ::c::Item;\n+}\n+\n+fn f78() {\n+    check(m7::V{}); //~ ERROR c::Item\n+    check(m7::V); //~ ERROR name of a struct or struct variant\n+    check(m8::V{}); //~ ERROR c::E\n+    check(m8::V); //~ ERROR c::Item\n+}\n+fn xf78() {\n+    check(xm7::V{}); //~ ERROR c::Item\n+    check(xm7::V); //~ ERROR name of a struct or struct variant\n+    check(xm8::V{}); //~ ERROR c::E\n+    check(xm8::V); //~ ERROR c::Item\n+}\n+\n+mod m9 {\n+    pub use ::c::E::*;\n+    pub type TV = ::c::Item;\n+}\n+mod mA {\n+    pub use ::c::E::*;\n+    pub const TV: ::c::Item = ::c::Item;\n+}\n+\n+fn f9A() {\n+    check(m9::TV{}); //~ ERROR c::Item\n+    check(m9::TV); //~ ERROR c::E\n+    check(mA::TV{}); //~ ERROR c::E\n+    check(mA::TV); //~ ERROR c::Item\n+}\n+fn xf9A() {\n+    check(xm9::TV{}); //~ ERROR c::Item\n+    check(xm9::TV); //~ ERROR c::E\n+    check(xmA::TV{}); //~ ERROR c::E\n+    check(xmA::TV); //~ ERROR c::Item\n+}\n+\n+mod mB {\n+    pub use ::c::E::*;\n+    pub type UV = ::c::Item;\n+}\n+mod mC {\n+    pub use ::c::E::*;\n+    pub const UV: ::c::Item = ::c::Item;\n+}\n+\n+fn fBC() {\n+    check(mB::UV{}); //~ ERROR c::Item\n+    check(mB::UV); //~ ERROR c::E\n+    check(mC::UV{}); //~ ERROR c::E\n+    check(mC::UV); //~ ERROR c::Item\n+}\n+fn xfBC() {\n+    check(xmB::UV{}); //~ ERROR c::Item\n+    check(xmB::UV); //~ ERROR c::E\n+    check(xmC::UV{}); //~ ERROR c::E\n+    check(xmC::UV); //~ ERROR c::Item\n+}\n+\n+fn main() {}"}, {"sha": "ad6766441961b2375027922e42b22096e95a0927", "filename": "src/test/compile-fail/namespace-mix-old.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-old.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -0,0 +1,174 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME: Remove when `item_like_imports` is stabilized.\n+\n+// aux-build:namespace-mix-old.rs\n+\n+#![feature(relaxed_adts)]\n+\n+extern crate namespace_mix_old;\n+use namespace_mix_old::{xm1, xm2, xm3, xm4, xm5, xm6, xm7, xm8, xm9, xmA, xmB, xmC};\n+\n+mod c {\n+    pub struct S {}\n+    pub struct TS();\n+    pub struct US;\n+    pub enum E {\n+        V {},\n+        TV(),\n+        UV,\n+    }\n+\n+    pub struct Item;\n+}\n+\n+mod proxy {\n+    pub use c::*;\n+    pub use c::E::*;\n+}\n+\n+// Use something emitting the type argument name, e.g. unsatisfied bound.\n+trait Impossible {}\n+fn check<T: Impossible>(_: T) {}\n+\n+mod m1 {\n+    pub use ::proxy::*;\n+    pub type S = ::c::Item;\n+}\n+mod m2 {\n+    pub use ::proxy::*;\n+    pub const S: ::c::Item = ::c::Item;\n+}\n+\n+fn f12() {\n+    check(m1::S{}); //~ ERROR c::Item\n+    check(m1::S); //~ ERROR unresolved name\n+    check(m2::S{}); //~ ERROR c::S\n+    check(m2::S); //~ ERROR c::Item\n+}\n+fn xf12() {\n+    check(xm1::S{}); //~ ERROR c::Item\n+    check(xm1::S); //~ ERROR unresolved name\n+    check(xm2::S{}); //~ ERROR c::S\n+    check(xm2::S); //~ ERROR c::Item\n+}\n+\n+mod m3 {\n+    pub use ::proxy::*;\n+    pub type TS = ::c::Item;\n+}\n+mod m4 {\n+    pub use ::proxy::*;\n+    pub const TS: ::c::Item = ::c::Item;\n+}\n+\n+fn f34() {\n+    check(m3::TS{}); //~ ERROR c::Item\n+    check(m3::TS); //~ ERROR c::TS\n+    check(m4::TS{}); //~ ERROR c::TS\n+    check(m4::TS); //~ ERROR c::Item\n+}\n+fn xf34() {\n+    check(xm3::TS{}); //~ ERROR c::Item\n+    check(xm3::TS); //~ ERROR c::TS\n+    check(xm4::TS{}); //~ ERROR c::TS\n+    check(xm4::TS); //~ ERROR c::Item\n+}\n+\n+mod m5 {\n+    pub use ::proxy::*;\n+    pub type US = ::c::Item;\n+}\n+mod m6 {\n+    pub use ::proxy::*;\n+    pub const US: ::c::Item = ::c::Item;\n+}\n+\n+fn f56() {\n+    check(m5::US{}); //~ ERROR c::Item\n+    check(m5::US); //~ ERROR c::US\n+    check(m6::US{}); //~ ERROR c::US\n+    check(m6::US); //~ ERROR c::Item\n+}\n+fn xf56() {\n+    check(xm5::US{}); //~ ERROR c::Item\n+    check(xm5::US); //~ ERROR c::US\n+    check(xm6::US{}); //~ ERROR c::US\n+    check(xm6::US); //~ ERROR c::Item\n+}\n+\n+mod m7 {\n+    pub use ::proxy::*;\n+    pub type V = ::c::Item;\n+}\n+mod m8 {\n+    pub use ::proxy::*;\n+    pub const V: ::c::Item = ::c::Item;\n+}\n+\n+fn f78() {\n+    check(m7::V{}); //~ ERROR c::Item\n+    check(m7::V); //~ ERROR name of a struct or struct variant\n+    check(m8::V{}); //~ ERROR c::E\n+    check(m8::V); //~ ERROR c::Item\n+}\n+fn xf78() {\n+    check(xm7::V{}); //~ ERROR c::Item\n+    check(xm7::V); //~ ERROR name of a struct or struct variant\n+    check(xm8::V{}); //~ ERROR c::E\n+    check(xm8::V); //~ ERROR c::Item\n+}\n+\n+mod m9 {\n+    pub use ::proxy::*;\n+    pub type TV = ::c::Item;\n+}\n+mod mA {\n+    pub use ::proxy::*;\n+    pub const TV: ::c::Item = ::c::Item;\n+}\n+\n+fn f9A() {\n+    check(m9::TV{}); //~ ERROR c::Item\n+    check(m9::TV); //~ ERROR c::E\n+    check(mA::TV{}); //~ ERROR c::E\n+    check(mA::TV); //~ ERROR c::Item\n+}\n+fn xf9A() {\n+    check(xm9::TV{}); //~ ERROR c::Item\n+    check(xm9::TV); //~ ERROR c::E\n+    check(xmA::TV{}); //~ ERROR c::E\n+    check(xmA::TV); //~ ERROR c::Item\n+}\n+\n+mod mB {\n+    pub use ::proxy::*;\n+    pub type UV = ::c::Item;\n+}\n+mod mC {\n+    pub use ::proxy::*;\n+    pub const UV: ::c::Item = ::c::Item;\n+}\n+\n+fn fBC() {\n+    check(mB::UV{}); //~ ERROR c::Item\n+    check(mB::UV); //~ ERROR c::E\n+    check(mC::UV{}); //~ ERROR c::E\n+    check(mC::UV); //~ ERROR c::Item\n+}\n+fn xfBC() {\n+    check(xmB::UV{}); //~ ERROR c::Item\n+    check(xmB::UV); //~ ERROR c::E\n+    check(xmC::UV{}); //~ ERROR c::E\n+    check(xmC::UV); //~ ERROR c::Item\n+}\n+\n+fn main() {}"}, {"sha": "3dbe08f1908d7456e7fc91f9a71426f4e56caae4", "filename": "src/test/compile-fail/pat-shadow-in-nested-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -11,5 +11,5 @@\n struct foo(usize);\n \n fn main() {\n-    let (foo, _) = (2, 3); //~ ERROR let bindings cannot shadow structs\n+    let (foo, _) = (2, 3); //~ ERROR let bindings cannot shadow tuple structs\n }"}, {"sha": "069c1dc0aea1b89de4976ae5f523742a32216ffe", "filename": "src/test/compile-fail/pat-tuple-overfield.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fpat-tuple-overfield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fpat-tuple-overfield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-tuple-overfield.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -20,9 +20,9 @@ fn main() {\n     }\n     match S(1, 2, 3) {\n         S(1, 2, 3, 4) => {}\n-        //~^ ERROR this pattern has 4 fields, but the corresponding struct has 3 fields\n+        //~^ ERROR this pattern has 4 fields, but the corresponding tuple struct has 3 fields\n         S(1, 2, .., 3, 4) => {}\n-        //~^ ERROR this pattern has 4 fields, but the corresponding struct has 3 fields\n+        //~^ ERROR this pattern has 4 fields, but the corresponding tuple struct has 3 fields\n         _ => {}\n     }\n }"}, {"sha": "e63b84594aa944cc5b68779cc55a425ea3f293c1", "filename": "src/test/compile-fail/pattern-error-continue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -25,7 +25,7 @@ fn f(_c: char) {}\n fn main() {\n     match A::B(1, 2) {\n         A::B(_, _, _) => (), //~ ERROR this pattern has 3 fields, but\n-        A::D(_) => (),       //~ ERROR `A::D` does not name a tuple variant or a tuple struct\n+        A::D(_) => (),       //~ ERROR expected tuple struct/variant, found unit variant `A::D`\n         _ => ()\n     }\n     match 'c' {"}, {"sha": "82b0536a64ad4ab840fc5e4982fb7409e10fbc97", "filename": "src/test/compile-fail/qualified-path-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -28,7 +28,7 @@ impl S {\n fn main() {\n     match 10 {\n         <S as Tr>::A::f::<u8> => {}\n-        //~^ ERROR `Tr::A::f<u8>` does not name a unit variant, unit struct or a constant\n+        //~^ ERROR expected unit struct/variant or constant, found method `Tr::A::f<u8>`\n         0 ... <S as Tr>::A::f::<u8> => {} //~ ERROR only char and numeric types are allowed in range\n     }\n }"}, {"sha": "7dd4d970945e0302017b8e3c006edf40953e5491", "filename": "src/test/compile-fail/xcrate-private-by-default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd065a838180aaf00cbeca46c9529a0e22747fc1/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs?ref=fd065a838180aaf00cbeca46c9529a0e22747fc1", "patch": "@@ -39,7 +39,7 @@ fn main() {\n     foo::<static_priv_by_default::m>();\n     //~^ ERROR: enum `m` is private\n     foo::<static_priv_by_default::n>();\n-    //~^ ERROR: type `n` is private\n+    //~^ ERROR: type alias `n` is private\n \n     // public items in a private mod should be inaccessible\n     static_priv_by_default::foo::a;"}]}