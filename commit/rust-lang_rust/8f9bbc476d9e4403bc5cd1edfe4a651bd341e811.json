{"sha": "8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmOWJiYzQ3NmQ5ZTQ0MDNiYzVjZDFlZGZlNGE2NTFiZDM0MWU4MTE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-06T03:43:06Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-07T03:41:20Z"}, "message": "remove `extra::iter`\n\nThis module provided adaptors for the old internal iterator protocol,\nbut they proved to be quite unreadable and are not generic enough to\nhandle borrowed pointers well.\n\nSince Rust no longer defines an internal iteration protocol, I don't\nthink there's going to be any reuse via these adaptors.", "tree": {"sha": "d8203e9565a556e0998e4c1d0a10595627159345", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8203e9565a556e0998e4c1d0a10595627159345"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "html_url": "https://github.com/rust-lang/rust/commit/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40d11a546178ca32523e7424a0bf61fe25f7e3d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/40d11a546178ca32523e7424a0bf61fe25f7e3d1", "html_url": "https://github.com/rust-lang/rust/commit/40d11a546178ca32523e7424a0bf61fe25f7e3d1"}], "stats": {"total": 365, "additions": 17, "deletions": 348}, "files": [{"sha": "b5677a261c45bffd12d1d80907e3df7ed035f45f", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -544,7 +544,7 @@ an intermediate generation has already exited:\n ~~~\n # use std::task;\n # fn sleep_forever() { loop { task::yield() } }\n-# fn wait_for_a_while() { do 1000.times { task::yield() } }\n+# fn wait_for_a_while() { for _ in range(0, 1000u) { task::yield() } }\n # do task::try::<int> {\n do task::spawn_supervised {\n     do task::spawn_supervised {\n@@ -563,7 +563,7 @@ other at all, using `task::spawn_unlinked` for _isolated failure_.\n ~~~\n # use std::task;\n # fn random() -> uint { 100 }\n-# fn sleep_for(i: uint) { do i.times { task::yield() } }\n+# fn sleep_for(i: uint) { for _ in range(0, i) { task::yield() } }\n # do task::try::<()> {\n let (time1, time2) = (random(), random());\n do task::spawn_unlinked {"}, {"sha": "6e6b804aa9d3408123dffe40f2a70c5f2a85a702", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -1894,7 +1894,7 @@ struct TimeBomb {\n \n impl Drop for TimeBomb {\n     fn drop(&self) {\n-        do self.explosivity.times {\n+        for _ in range(0, self.explosivity) {\n             println(\"blam!\");\n         }\n     }"}, {"sha": "7fd47fdbd3999a7f336e837e0c67e008381b15d4", "filename": "src/libextra/iter.rs", "status": "removed", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/40d11a546178ca32523e7424a0bf61fe25f7e3d1/src%2Flibextra%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d11a546178ca32523e7424a0bf61fe25f7e3d1/src%2Flibextra%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fiter.rs?ref=40d11a546178ca32523e7424a0bf61fe25f7e3d1", "patch": "@@ -1,331 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! Composable internal iterators\n-\n-Internal iterators are functions implementing the protocol used by the `for` loop.\n-\n-An internal iterator takes `fn(...) -> bool` as a parameter, with returning `false` used to signal\n-breaking out of iteration. The adaptors in the module work with any such iterator, not just ones\n-tied to specific traits. For example:\n-\n-~~~ {.rust}\n-println(iter::to_vec(|f| uint::range(0, 20, f)).to_str());\n-~~~\n-\n-An external iterator object implementing the interface in the `iterator` module can be used as an\n-internal iterator by calling the `advance` method. For example:\n-\n-~~~ {.rust}\n-let xs = [0u, 1, 2, 3, 4, 5];\n-let ys = [30, 40, 50, 60];\n-let mut it = xs.iter().chain(ys.iter());\n-for &x: &uint in it {\n-    println(x.to_str());\n-}\n-~~~\n-\n-Internal iterators provide a subset of the functionality of an external iterator. It's not possible\n-to interleave them to implement algorithms like `zip`, `union` and `merge`. However, they're often\n-much easier to implement.\n-\n-*/\n-\n-use std::vec;\n-use std::cmp::Ord;\n-use std::option::{Option, Some, None};\n-use std::num::{One, Zero};\n-use std::ops::{Add, Mul};\n-\n-#[allow(missing_doc)]\n-pub trait FromIter<T> {\n-    /// Build a container with elements from an internal iterator.\n-    ///\n-    /// # Example:\n-    ///\n-    /// ~~~ {.rust}\n-    /// let xs = ~[1, 2, 3];\n-    /// let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-    /// assert_eq!(xs, ys);\n-    /// ~~~\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> Self;\n-}\n-\n-/**\n- * Return true if `predicate` is true for any values yielded by an internal iterator.\n- *\n- * Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5];\n- * assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n- * assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn any<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    do iter |x| {\n-        predicate(x)\n-    }\n-}\n-\n-/**\n- * Return true if `predicate` is true for all values yielded by an internal iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n- * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn all<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    // If we ever break, iter will return false, so this will only return true\n-    // if predicate returns true for everything.\n-    iter(|x| predicate(x))\n-}\n-\n-/**\n- * Return the first element where `predicate` returns `true`. Return `None` if no element is found.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5, 6];\n- * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n- * ~~~\n- */\n-#[inline]\n-pub fn find<T>(predicate: &fn(&T) -> bool,\n-               iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut ret = None;\n-    do iter |x| {\n-        if predicate(&x) {\n-            ret = Some(x);\n-            false\n-        } else { true }\n-    };\n-    ret\n-}\n-\n-/**\n- * Return the largest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n- * ~~~\n- */\n-#[inline]\n-pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    do iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x > *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Return the smallest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &-5);\n- * ~~~\n- */\n-#[inline]\n-pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    do iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x < *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n-    let mut result = start;\n-    do iter |x| {\n-        f(&mut result, x);\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * `fold_ref` is usable in some generic functions where `fold` is too lenient to type-check, but it\n- * forces the iterator to yield borrowed pointers.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n- *     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n- * }\n- * ~~~\n- */\n-#[inline]\n-pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n-    let mut result = start;\n-    do iter |x| {\n-        f(&mut result, x);\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Return the sum of the items yielding by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n-}\n-\n-/**\n- * Return the product of the items yielded by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n- * ~~~\n- */\n-#[inline]\n-pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n-}\n-\n-impl<T> FromIter<T> for ~[T]{\n-    #[inline]\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n-        let mut v = ~[];\n-        do iter |x| { v.push(x); true };\n-        v\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use prelude::*;\n-\n-    use int;\n-    use uint;\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = ~[1, 2, 3];\n-        let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-        assert_eq!(xs, ys);\n-    }\n-\n-    #[test]\n-    fn test_any() {\n-        let xs = ~[1u, 2, 3, 4, 5];\n-        assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n-        assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n-    }\n-\n-    #[test]\n-    fn test_all() {\n-        assert!(all(|x: uint| x < 6, |f| uint::range(1, 6, f)));\n-        assert!(!all(|x: uint| x < 5, |f| uint::range(1, 6, f)));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let xs = ~[1u, 2, 3, 4, 5, 6];\n-        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n-    }\n-\n-    #[test]\n-    fn test_max() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n-    }\n-\n-    #[test]\n-    fn test_min() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(min(|f| xs.iter().advance(f)).unwrap(), &-5);\n-    }\n-\n-    #[test]\n-    fn test_fold() {\n-        assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n-    }\n-\n-    #[test]\n-    fn test_sum() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n-    }\n-\n-    #[test]\n-    fn test_empty_sum() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 0);\n-    }\n-\n-    #[test]\n-    fn test_product() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n-    }\n-\n-    #[test]\n-    fn test_empty_product() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 1);\n-    }\n-}"}, {"sha": "f05c59083f40f49f5288e1348b6a2a126c4a366e", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -637,7 +637,7 @@ mod test {\n         let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n         write_markdown(doc, writer_factory);\n         // We expect two pages to have been written\n-        do 2.times {\n+        for _ in range(0, 2u) {\n             po.recv();\n         }\n     }\n@@ -649,7 +649,7 @@ mod test {\n             ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n         let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n         write_markdown(doc, writer_factory);\n-        do 2.times {\n+        for _ in range(0, 2u) {\n             let (page, markdown) = po.recv();\n             match page {\n                 doc::CratePage(_) => {"}, {"sha": "70fe6f706f79a763683fdc6556f09c765e2a86f0", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -59,7 +59,7 @@ impl Results {\n         {\n             let mut set = f();\n             do timed(&mut self.random_ints) {\n-                do num_keys.times {\n+                for _ in range(0, num_keys) {\n                     set.insert((rng.next() as uint) % rand_cap);\n                 }\n             }\n@@ -103,7 +103,7 @@ impl Results {\n         {\n             let mut set = f();\n             do timed(&mut self.random_strings) {\n-                do num_keys.times {\n+                for _ in range(0, num_keys) {\n                     let s = uint::to_str(rng.next() as uint);\n                     set.insert(s);\n                 }"}, {"sha": "8503b188b2f25a27dd7d21bc6d01e5d991373abd", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -105,7 +105,7 @@ fn main() {\n     let symbols = [\" \", \"\u2591\", \"\u2592\", \"\u2593\", \"\u2588\", \"\u2588\"];\n     let mut pixels = [0f32, ..256*256];\n     let n2d = ~Noise2DContext::new();\n-    do 100.times {\n+    for _ in range(0, 100u) {\n         for y in range(0, 256) {\n             for x in range(0, 256) {\n                 let v = n2d.get("}, {"sha": "2b177ccb98fcc194a0dbf743619ac82764b6a447", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -169,7 +169,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n     let mut creatures_met = 0;\n \n     // set up meetings...\n-    do nn.times {\n+    for _ in range(0, nn) {\n         let fst_creature: CreatureInfo = from_creatures.recv();\n         let snd_creature: CreatureInfo = from_creatures.recv();\n "}, {"sha": "44b1a28c12b30f6134729c413ad587797beb7ce0", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -164,7 +164,7 @@ impl RandomFasta {\n             let chars_left = n % LINE_LEN;\n             let mut buf = [0, ..LINE_LEN + 1];\n \n-            do lines.times {\n+            for _ in range(0, lines) {\n                 for i in range(0u, LINE_LEN) {\n                     buf[i] = self.nextc();\n                 }"}, {"sha": "2b5b4ded94774690913cd7136db00954f26a387d", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -54,7 +54,7 @@ impl Code {\n     fn unpack(&self, frame: i32) -> ~str {\n         let mut key = **self;\n         let mut result = ~[];\n-        do (frame as uint).times {\n+        for _ in range(0, frame) {\n             result.push(unpack_symbol((key as u8) & 3));\n             key >>= 2;\n         }\n@@ -251,7 +251,7 @@ fn generate_frequencies(frequencies: &mut Table,\n     let mut code = Code(0);\n \n     // Pull first frame.\n-    do (frame as uint).times {\n+    for _ in range(0, frame) {\n         code = code.push_char(input[0]);\n         input = next_char(input);\n     }"}, {"sha": "6a9c5ea89e4fc6a196fff097ae1ac76eef0edc84", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -79,7 +79,7 @@ struct Planet {\n \n fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n     let mut d = [ 0.0, ..3 ];\n-    do (steps as uint).times {\n+    for _ in range(0, steps) {\n         for i in range(0u, N_BODIES) {\n             for j in range(i + 1, N_BODIES) {\n                 d[0] = bodies[i].x[0] - bodies[j].x[0];"}, {"sha": "ecf54bf16473e8833ad074be023b8f3fc80c3d2f", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -56,7 +56,7 @@ fn main() {\n     let mut u = vec::from_elem(n, 1f64);\n     let mut v = u.clone();\n     let mut tmp = u.clone();\n-    do 8.times {\n+    for _ in range(0, 8u) {\n         mult_AtAv(u, v, tmp);\n         mult_AtAv(v, u, tmp);\n     }"}, {"sha": "114c7e997a24f67cd22b4195ae6d4221c126d776", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -32,7 +32,7 @@ fn main() {\n }\n \n fn run(repeat: int, depth: int) {\n-    do (repeat as uint).times {\n+    for _ in range(0, repeat) {\n         info!(\"starting %.4f\", precise_time_s());\n         do task::try {\n             recurse_or_fail(depth, None)"}, {"sha": "15808427f4a8b55c08d2c442c48ab8e4acc50cfb", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9bbc476d9e4403bc5cd1edfe4a651bd341e811/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=8f9bbc476d9e4403bc5cd1edfe4a651bd341e811", "patch": "@@ -32,7 +32,7 @@ fn grandchild_group(num_tasks: uint) {\n     let (po, ch) = stream();\n     let ch = SharedChan::new(ch);\n \n-    do num_tasks.times {\n+    for _ in range(0, num_tasks) {\n         let ch = ch.clone();\n         do task::spawn { // linked\n             ch.send(());\n@@ -41,7 +41,7 @@ fn grandchild_group(num_tasks: uint) {\n         }\n     }\n     error!(\"Grandchild group getting started\");\n-    do num_tasks.times {\n+    for _ in range(0, num_tasks) {\n         // Make sure all above children are fully spawned; i.e., enlisted in\n         // their ancestor groups.\n         po.recv();"}]}