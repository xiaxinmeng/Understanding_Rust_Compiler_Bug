{"sha": "8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMjg2ZGJmMjdiNjFhZmRkOTZmNjMyZDBiYzdmNGM0OWZiYjdkMGY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-12-13T21:21:14Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-02-06T19:32:07Z"}, "message": "rustc_errors: split macro backtrace rendering from <*macros> hacks.", "tree": {"sha": "b8f939ec9c615570d4376b22a215e36d9a114e02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8f939ec9c615570d4376b22a215e36d9a114e02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f", "html_url": "https://github.com/rust-lang/rust/commit/8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "442ae7f04026c215a03b155eaaf9cde8bb5cf02a", "url": "https://api.github.com/repos/rust-lang/rust/commits/442ae7f04026c215a03b155eaaf9cde8bb5cf02a", "html_url": "https://github.com/rust-lang/rust/commit/442ae7f04026c215a03b155eaaf9cde8bb5cf02a"}], "stats": {"total": 164, "additions": 97, "deletions": 67}, "files": [{"sha": "65d82f545e8f0735e0453ae0ab9b8110fcb8b270", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f", "patch": "@@ -32,7 +32,7 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n         let mut children = diag.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n \n-        self.fix_multispans_in_std_macros(\n+        self.render_multispans_macro_backtrace_and_fix_extern_macros(\n             &self.source_map,\n             &mut primary_span,\n             &mut children,"}, {"sha": "d32b8c689dc1d56cb633a0cf9d026df63d5c68c2", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 96, "deletions": 58, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f", "patch": "@@ -280,72 +280,72 @@ pub trait Emitter {\n         }\n     }\n \n-    // This does a small \"fix\" for multispans by looking to see if it can find any that\n-    // point directly at <*macros>. Since these are often difficult to read, this\n-    // will change the span to point at the use site.\n-    fn fix_multispans_in_std_macros(\n+    fn render_multispans_macro_backtrace_and_fix_extern_macros(\n         &self,\n         source_map: &Option<Lrc<SourceMap>>,\n         span: &mut MultiSpan,\n         children: &mut Vec<SubDiagnostic>,\n         level: &Level,\n         backtrace: bool,\n     ) {\n-        let mut spans_updated = self.fix_multispan_in_std_macros(source_map, span, backtrace);\n-        for child in children.iter_mut() {\n-            spans_updated |=\n-                self.fix_multispan_in_std_macros(source_map, &mut child.span, backtrace);\n+        self.render_multispans_macro_backtrace(source_map, span, children, backtrace);\n+\n+        if !backtrace {\n+            if self.fix_multispans_in_extern_macros(source_map, span, children) {\n+                let msg = if level == &Error {\n+                    \"this error originates in a macro outside of the current crate \\\n+                    (in Nightly builds, run with -Z external-macro-backtrace \\\n+                    for more info)\"\n+                        .to_string()\n+                } else {\n+                    \"this warning originates in a macro outside of the current crate \\\n+                    (in Nightly builds, run with -Z external-macro-backtrace \\\n+                    for more info)\"\n+                        .to_string()\n+                };\n+\n+                children.push(SubDiagnostic {\n+                    level: Level::Note,\n+                    message: vec![(msg, Style::NoStyle)],\n+                    span: MultiSpan::new(),\n+                    render_span: None,\n+                });\n+            }\n         }\n-        let msg = if level == &Error {\n-            \"this error originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\"\n-                .to_string()\n-        } else {\n-            \"this warning originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\"\n-                .to_string()\n-        };\n+    }\n \n-        if spans_updated {\n-            children.push(SubDiagnostic {\n-                level: Level::Note,\n-                message: vec![(msg, Style::NoStyle)],\n-                span: MultiSpan::new(),\n-                render_span: None,\n-            });\n+    fn render_multispans_macro_backtrace(\n+        &self,\n+        source_map: &Option<Lrc<SourceMap>>,\n+        span: &mut MultiSpan,\n+        children: &mut Vec<SubDiagnostic>,\n+        backtrace: bool,\n+    ) {\n+        self.render_multispan_macro_backtrace(source_map, span, backtrace);\n+        for child in children.iter_mut() {\n+            self.render_multispan_macro_backtrace(source_map, &mut child.span, backtrace);\n         }\n     }\n \n-    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n-    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n-    // <*macros> to their corresponding use site.\n-    fn fix_multispan_in_std_macros(\n+    fn render_multispan_macro_backtrace(\n         &self,\n         source_map: &Option<Lrc<SourceMap>>,\n         span: &mut MultiSpan,\n         always_backtrace: bool,\n-    ) -> bool {\n+    ) {\n         let sm = match source_map {\n             Some(ref sm) => sm,\n-            None => return false,\n+            None => return,\n         };\n \n-        let mut before_after: Vec<(Span, Span)> = vec![];\n         let mut new_labels: Vec<(Span, String)> = vec![];\n \n         // First, find all the spans in <*macros> and point instead at their use site\n-        for sp in span.primary_spans() {\n+        for &sp in span.primary_spans() {\n             if sp.is_dummy() {\n                 continue;\n             }\n-            let call_sp = sm.call_span_if_macro(*sp);\n-            if call_sp != *sp && !always_backtrace {\n-                before_after.push((*sp, call_sp));\n-            }\n             let macro_backtrace: Vec<_> = sp.macro_backtrace().collect();\n-            let backtrace_len = macro_backtrace.len();\n             for (i, trace) in macro_backtrace.iter().rev().enumerate() {\n                 // Only show macro locations that are local\n                 // and display them like a span_note\n@@ -358,13 +358,13 @@ pub trait Emitter {\n                         format!(\n                             \"in this expansion of `{}`{}\",\n                             trace.kind.descr(),\n-                            if backtrace_len > 2 {\n-                                // if backtrace_len == 1 it'll be pointed\n-                                // at by \"in this macro invocation\"\n+                            if macro_backtrace.len() > 2 {\n+                                // if macro_backtrace.len() == 1 it'll be\n+                                // pointed at by \"in this macro invocation\"\n                                 format!(\" (#{})\", i + 1)\n                             } else {\n                                 String::new()\n-                            }\n+                            },\n                         ),\n                     ));\n                 }\n@@ -377,13 +377,13 @@ pub trait Emitter {\n                         trace.call_site,\n                         format!(\n                             \"in this macro invocation{}\",\n-                            if backtrace_len > 2 && always_backtrace {\n+                            if macro_backtrace.len() > 2 && always_backtrace {\n                                 // only specify order when the macro\n                                 // backtrace is multiple levels deep\n                                 format!(\" (#{})\", i + 1)\n                             } else {\n                                 String::new()\n-                            }\n+                            },\n                         ),\n                     ));\n                     if !always_backtrace {\n@@ -395,20 +395,58 @@ pub trait Emitter {\n         for (label_span, label_text) in new_labels {\n             span.push_span_label(label_span, label_text);\n         }\n-        for sp_label in span.span_labels() {\n-            if sp_label.span.is_dummy() {\n-                continue;\n-            }\n-            if sm.span_to_filename(sp_label.span.clone()).is_macros() && !always_backtrace {\n-                if let Some(use_site) = sp_label.span.macro_backtrace().last() {\n-                    before_after.push((sp_label.span, use_site.call_site));\n-                }\n-            }\n+    }\n+\n+    // This does a small \"fix\" for multispans by looking to see if it can find any that\n+    // point directly at <*macros>. Since these are often difficult to read, this\n+    // will change the span to point at the use site.\n+    fn fix_multispans_in_extern_macros(\n+        &self,\n+        source_map: &Option<Lrc<SourceMap>>,\n+        span: &mut MultiSpan,\n+        children: &mut Vec<SubDiagnostic>,\n+    ) -> bool {\n+        let mut spans_updated = self.fix_multispan_in_extern_macros(source_map, span);\n+        for child in children.iter_mut() {\n+            spans_updated |= self.fix_multispan_in_extern_macros(source_map, &mut child.span);\n         }\n+        spans_updated\n+    }\n+\n+    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n+    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n+    // <*macros> to their corresponding use site.\n+    fn fix_multispan_in_extern_macros(\n+        &self,\n+        source_map: &Option<Lrc<SourceMap>>,\n+        span: &mut MultiSpan,\n+    ) -> bool {\n+        let sm = match source_map {\n+            Some(ref sm) => sm,\n+            None => return false,\n+        };\n+\n+        // First, find all the spans in <*macros> and point instead at their use site\n+        let replacements: Vec<(Span, Span)> = span\n+            .primary_spans()\n+            .iter()\n+            .copied()\n+            .chain(span.span_labels().iter().map(|sp_label| sp_label.span))\n+            .filter_map(|sp| {\n+                if !sp.is_dummy() && sm.span_to_filename(sp).is_macros() {\n+                    let maybe_callsite = sp.source_callsite();\n+                    if sp != maybe_callsite {\n+                        return Some((sp, maybe_callsite));\n+                    }\n+                }\n+                None\n+            })\n+            .collect();\n+\n         // After we have them, make sure we replace these 'bad' def sites with their use sites\n-        let spans_updated = !before_after.is_empty();\n-        for (before, after) in before_after {\n-            span.replace(before, after);\n+        let spans_updated = !replacements.is_empty();\n+        for (from, to) in replacements {\n+            span.replace(from, to);\n         }\n \n         spans_updated\n@@ -424,7 +462,7 @@ impl Emitter for EmitterWriter {\n         let mut children = diag.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n \n-        self.fix_multispans_in_std_macros(\n+        self.render_multispans_macro_backtrace_and_fix_extern_macros(\n             &self.sm,\n             &mut primary_span,\n             &mut children,"}, {"sha": "45c4d6dbc6cf4ecdf2867f58e794048b975abce1", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=8f286dbf27b61afdd96f632d0bc7f4c49fbb7d0f", "patch": "@@ -945,14 +945,6 @@ impl SourceMap {\n             _ => None,\n         })\n     }\n-    pub fn call_span_if_macro(&self, sp: Span) -> Span {\n-        if self.span_to_filename(sp.clone()).is_macros() {\n-            if let Some(use_site) = sp.macro_backtrace().last() {\n-                return use_site.call_site;\n-            }\n-        }\n-        sp\n-    }\n }\n \n #[derive(Clone)]"}]}