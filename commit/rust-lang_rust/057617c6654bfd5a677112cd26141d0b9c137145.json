{"sha": "057617c6654bfd5a677112cd26141d0b9c137145", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NzYxN2M2NjU0YmZkNWE2NzcxMTJjZDI2MTQxZDBiOWMxMzcxNDU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-20T15:33:55Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-23T17:09:25Z"}, "message": "Parse `iface` items and interface references in `impl` items.\n\nThe (temporary) syntax is\n\n    iface seq<T> {\n        fn len() -> uint;\n        fn iter(f: block(T));\n    }\n\n    // The 'blah<T>' can be left of to default the name of the\n    // impl to seq<T>. The 'of seq<T>' can be left off when\n    // not implementing a named interface.\n    impl blah<T> of seq<T> for [T] {\n        fn len() -> uint { vec::len(self) }\n        fn iter(f: block(T)) { for x in self { f(x); } }\n    }", "tree": {"sha": "316c1b2cbcb11aa3cd02f05107e76fa5cd624fef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/316c1b2cbcb11aa3cd02f05107e76fa5cd624fef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/057617c6654bfd5a677112cd26141d0b9c137145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/057617c6654bfd5a677112cd26141d0b9c137145", "html_url": "https://github.com/rust-lang/rust/commit/057617c6654bfd5a677112cd26141d0b9c137145", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/057617c6654bfd5a677112cd26141d0b9c137145/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92927449595782926c4db5a579ba7e4c6952287d", "url": "https://api.github.com/repos/rust-lang/rust/commits/92927449595782926c4db5a579ba7e4c6952287d", "html_url": "https://github.com/rust-lang/rust/commit/92927449595782926c4db5a579ba7e4c6952287d"}], "stats": {"total": 348, "additions": 209, "deletions": 139}, "files": [{"sha": "6bbca1335a155e265a3cfa413bf0f4d3dfd7dee0", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -64,6 +64,7 @@ fn encode_native_module_item_paths(ebml_w: ebml::writer, nmod: native_mod,\n \n fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n                             &index: [entry<str>]) {\n+    // FIXME factor out add_to_index/start/encode_name/encode_def_id/end ops\n     for it: @item in module.items {\n         if !ast_util::is_exported(it.ident, module) { cont; }\n         alt it.node {\n@@ -137,7 +138,14 @@ fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n-          item_impl(_, _, _) {}\n+          item_iface(_, _) {\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebml::start_tag(ebml_w, tag_paths_data_item);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(it.id));\n+            ebml::end_tag(ebml_w);\n+          }\n+          item_impl(_, _, _, _) {}\n         }\n     }\n }\n@@ -252,7 +260,7 @@ fn encode_info_for_mod(ebml_w: ebml::writer, md: _mod,\n     encode_name(ebml_w, name);\n     for i in md.items {\n         alt i.node {\n-          item_impl(_, _, _) {\n+          item_impl(_, _, _, _) {\n             if ast_util::is_exported(i.ident, md) {\n                 ebml::start_tag(ebml_w, tag_mod_impl);\n                 ebml_w.writer.write(str::bytes(def_to_str(local_def(i.id))));\n@@ -363,7 +371,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_symbol(ecx, ebml_w, ctor_id);\n         ebml::end_tag(ebml_w);\n       }\n-      item_impl(tps, _, methods) {\n+      item_impl(tps, _, _, methods) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i' as u8);\n@@ -390,6 +398,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             ebml::end_tag(ebml_w);\n         }\n       }\n+      item_iface(_, _) { /* FIXME[impl] */ }\n     }\n }\n "}, {"sha": "0b0d0337d2d002dfc77b36fee944126539307da8", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -71,7 +71,7 @@ fn map_item(cx: ctx, i: @item) {\n             cx.map.insert(m.id, node_obj_method(m));\n         }\n       }\n-      item_impl(_, _, ms) {\n+      item_impl(_, _, _, ms) {\n         for m in ms { cx.map.insert(m.id, node_method(m)); }\n       }\n       item_res(_, _, _, dtor_id, ctor_id) {"}, {"sha": "68d4d5aac30f9d71a42a71a604544a8b139fab4d", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -401,8 +401,9 @@ fn resolve_names(e: @env, c: @ast::crate) {\n fn visit_item_with_scope(i: @ast::item, sc: scopes, v: vt<scopes>) {\n     let sc = cons(scope_item(i), @sc);\n     alt i.node {\n-      ast::item_impl(tps, sty, methods) {\n-        visit::visit_ty(sty, sc, v);\n+      ast::item_impl(tps, ifce, sty, methods) {\n+        alt ifce { some(ty) { v.visit_ty(ty, sc, v); } _ {} }\n+        v.visit_ty(sty, sc, v);\n         for m in methods {\n             v.visit_fn_proto(m.decl, tps + m.tps, m.body, m.span,\n                              some(m.ident), m.id, sc, v);\n@@ -802,24 +803,22 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n               ast::item_obj(ob, ty_params, _) {\n                 ret lookup_in_obj(name, ob, ty_params, ns, it.id);\n               }\n-              ast::item_impl(ty_params, _, _) {\n+              ast::item_impl(ty_params, _, _, _) {\n                 if (name == \"self\" && ns == ns_value) {\n                     ret some(ast::def_self(local_def(it.id)));\n                 }\n                 if ns == ns_type { ret lookup_in_ty_params(name, ty_params); }\n               }\n-              ast::item_tag(_, ty_params) {\n-                if ns == ns_type { ret lookup_in_ty_params(name, ty_params); }\n+              ast::item_iface(tps, _) | ast::item_tag(_, tps) |\n+              ast::item_ty(_, tps) {\n+                if ns == ns_type { ret lookup_in_ty_params(name, tps); }\n               }\n               ast::item_mod(_) {\n                 ret lookup_in_local_mod(e, it.id, sp, name, ns, inside);\n               }\n               ast::item_native_mod(m) {\n                 ret lookup_in_local_native_mod(e, it.id, sp, name, ns);\n               }\n-              ast::item_ty(_, ty_params) {\n-                if ns == ns_type { ret lookup_in_ty_params(name, ty_params); }\n-              }\n               _ { }\n             }\n           }\n@@ -1064,7 +1063,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n       ast::item_native_mod(_) {\n         if ns == ns_module { ret some(ast::def_native_mod(local_def(i.id))); }\n       }\n-      ast::item_ty(_, _) {\n+      ast::item_ty(_, _) | item_iface(_, _) | item_tag(_, _) {\n         if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n       }\n       ast::item_res(_, _, _, _, ctor_id) {\n@@ -1076,9 +1075,6 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n           _ { }\n         }\n       }\n-      ast::item_tag(_, _) {\n-        if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n-      }\n       ast::item_obj(_, _, ctor_id) {\n         alt ns {\n           ns_value. {\n@@ -1322,7 +1318,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n           ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n           ast::item_native_mod(_) | ast::item_ty(_, _) |\n           ast::item_res(_, _, _, _, _) | ast::item_obj(_, _, _) |\n-          ast::item_impl(_, _, _) {\n+          ast::item_impl(_, _, _, _) | ast::item_iface(_, _) {\n             add_to_index(index, it.ident, mie_item(it));\n           }\n           ast::item_tag(variants, _) {\n@@ -1570,7 +1566,9 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n                   ast::item_const(_, _) | ast::item_fn(_, _, _) {\n                     add_name(values, it.span, it.ident);\n                   }\n-                  ast::item_ty(_, _) { add_name(types, it.span, it.ident); }\n+                  ast::item_ty(_, _) | ast::item_iface(_, _) {\n+                    add_name(types, it.span, it.ident);\n+                  }\n                   ast::item_res(_, _, _, _, _) | ast::item_obj(_, _, _) {\n                     add_name(types, it.span, it.ident);\n                     add_name(values, it.span, it.ident);\n@@ -1768,7 +1766,7 @@ fn find_impls_in_item(i: @ast::item, &impls: [@_impl],\n                       name: option::t<ident>,\n                       ck_exports: option::t<ast::_mod>) {\n     alt i.node {\n-      ast::item_impl(_, _, mthds) {\n+      ast::item_impl(_, _, _, mthds) {\n         if alt name { some(n) { n == i.ident } _ { true } } &&\n            alt ck_exports { some(m) { is_exported(i.ident, m) } _ { true } } {\n             impls += [@{did: local_def(i.id),"}, {"sha": "72c3858276087e3b3346e3d3767ac0578ac7b47a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -5013,7 +5013,7 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n                  with *extend_path(cx, item.ident)};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n-      ast::item_impl(tps, _, ms) {\n+      ast::item_impl(tps, _, _, ms) {\n         trans_impl(cx, item.ident, ms, item.id, tps);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n@@ -5340,7 +5340,7 @@ fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n             ccx.obj_methods.insert(m.id, ());\n         }\n       }\n-      ast::item_impl(tps, _, methods) {\n+      ast::item_impl(tps, _, _, methods) {\n         let name = ccx.names.next(i.ident);\n         for m in methods {\n             register_fn(ccx, i.span, pt + [name, m.ident],"}, {"sha": "8f960eea6c08144c429698a8d7aa4d509faf84c2", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -64,8 +64,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n       }\n       item_mod(m) { find_pre_post_mod(m); }\n       item_native_mod(nm) { find_pre_post_native_mod(nm); }\n-      item_ty(_, _) { ret; }\n-      item_tag(_, _) { ret; }\n+      item_ty(_, _) | item_tag(_, _) | item_iface(_, _) { ret; }\n       item_res(_, _, body, dtor_id, _) {\n         let fcx =\n             {enclosing: ccx.fm.get(dtor_id),\n@@ -75,7 +74,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n         find_pre_post_fn(fcx, body);\n       }\n       item_obj(o, _, _) {for m in o.methods { find_pre_post_method(ccx, m); }}\n-      item_impl(_, _, ms) { for m in ms { find_pre_post_method(ccx, m); } }\n+      item_impl(_, _, _, ms) { for m in ms { find_pre_post_method(ccx, m); } }\n     }\n }\n "}, {"sha": "f668184acb60a91bb61ff04273166d1147d845de", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -73,6 +73,7 @@ export mk_native;\n export mk_native_fn;\n export mk_nil;\n export mk_obj;\n+export mk_iface;\n export mk_res;\n export mk_param;\n export mk_ptr;\n@@ -123,6 +124,7 @@ export ty_vec;\n export ty_native;\n export ty_nil;\n export ty_obj;\n+export ty_iface;\n export ty_res;\n export ty_param;\n export ty_ptr;\n@@ -256,6 +258,7 @@ tag sty {\n     ty_fn(fn_ty);\n     ty_native_fn([arg], t);\n     ty_obj([method]);\n+    ty_iface(def_id, [t]);\n     ty_res(def_id, t, [t]);\n     ty_tup([t]);\n     ty_var(int); // type variable\n@@ -444,7 +447,7 @@ fn mk_raw_ty(cx: ctxt, st: sty) -> @raw_t {\n       }\n       ty_param(_, _) { has_params = true; }\n       ty_var(_) { has_vars = true; }\n-      ty_tag(_, tys) {\n+      ty_tag(_, tys) | ty_iface(_, tys) {\n         for tt: t in tys { derive_flags_t(cx, has_params, has_vars, tt); }\n       }\n       ty_box(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n@@ -584,6 +587,10 @@ fn mk_native_fn(cx: ctxt, args: [arg], ty: t) -> t {\n \n fn mk_obj(cx: ctxt, meths: [method]) -> t { ret gen_ty(cx, ty_obj(meths)); }\n \n+fn mk_iface(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n+    ret gen_ty(cx, ty_iface(did, tys));\n+}\n+\n fn mk_res(cx: ctxt, did: ast::def_id, inner: t, tps: [t]) -> t {\n     ret gen_ty(cx, ty_res(did, inner, tps));\n }\n@@ -634,7 +641,7 @@ fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n         /* no-op */\n       }\n       ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, walker, tm.ty); }\n-      ty_tag(tid, subtys) {\n+      ty_tag(_, subtys) | ty_iface(_, subtys) {\n         for subty: t in subtys { walk_ty(cx, walker, subty); }\n       }\n       ty_rec(fields) {\n@@ -703,9 +710,10 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n         ty = mk_vec(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n       ty_tag(tid, subtys) {\n-        let new_subtys: [t] = [];\n-        for subty: t in subtys { new_subtys += [fold_ty(cx, fld, subty)]; }\n-        ty = mk_tag(cx, tid, new_subtys);\n+        ty = mk_tag(cx, tid, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n+      }\n+      ty_iface(did, subtys) {\n+        ty = mk_iface(cx, did, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n       }\n       ty_rec(fields) {\n         let new_fields: [field] = [];\n@@ -785,14 +793,10 @@ fn type_is_bool(cx: ctxt, ty: t) -> bool {\n \n fn type_is_structural(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_rec(_) { ret true; }\n-      ty_tup(_) { ret true; }\n-      ty_tag(_, _) { ret true; }\n-      ty_fn(_) { ret true; }\n-      ty_native_fn(_, _) { ret true; }\n-      ty_obj(_) { ret true; }\n-      ty_res(_, _, _) { ret true; }\n-      _ { ret false; }\n+      ty_rec(_) | ty_tup(_) | ty_tag(_, _) | ty_fn(_) |\n+      ty_native_fn(_, _) | ty_obj(_) | ty_res(_, _, _) |\n+      ty_iface(_, _) { true }\n+      _ { false }\n     }\n }\n \n@@ -973,7 +977,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n       ty_opaque_closure. { kind_noncopyable }\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n-      ty_box(mt) { ast::kind_copyable }\n+      ty_box(_) | ty_iface(_, _) { ast::kind_copyable }\n       // Boxes and unique pointers raise pinned to shared.\n       ty_vec(tm) | ty_uniq(tm) { type_kind(cx, tm.ty) }\n       // Records lower to the lowest of their members.\n@@ -1142,9 +1146,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_send_type. | ty_type. | ty_native(_) | ty_ptr(_) { result = true; }\n       // Boxed types\n       ty_str. | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_) |\n-      ty_native_fn(_, _) | ty_obj(_) {\n-        result = false;\n-      }\n+      ty_native_fn(_, _) | ty_obj(_) | ty_iface(_, _) { result = false; }\n       // Structural types\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1332,6 +1334,11 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_send_type. { ret 38u; }\n       ty_opaque_closure. { ret 39u; }\n       ty_named(t, name) { (str::hash(*name) << 5u) + hash_subty(40u, t) }\n+      ty_iface(did, tys) {\n+        let h = hash_def(41u, did);\n+        for typ: t in tys { h += (h << 5u) + typ; }\n+        ret h;\n+      }\n     }\n }\n \n@@ -2024,6 +2031,20 @@ mod unify {\n         }\n     }\n \n+    fn unify_tps(cx: @ctxt, expected_tps: [t], actual_tps: [t],\n+                 variance: variance, finish: block([t]) -> result) -> result {\n+        let result_tps = [], i = 0u;\n+        for exp in expected_tps {\n+            let act = actual_tps[i];\n+            i += 1u;\n+            let result = unify_step(cx, exp, act, variance);\n+            alt result {\n+              ures_ok(rty) { result_tps += [rty]; }\n+              _ { ret result; }\n+            }\n+        }\n+        finish(result_tps)\n+    }\n     fn unify_step(cx: @ctxt, expected: t, actual: t,\n                   variance: variance) -> result {\n         // FIXME: rewrite this using tuple pattern matching when available, to\n@@ -2109,31 +2130,31 @@ mod unify {\n           ty::ty_tag(expected_id, expected_tps) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_tag(actual_id, actual_tps) {\n-                if expected_id.crate != actual_id.crate ||\n-                       expected_id.node != actual_id.node {\n+                if expected_id != actual_id {\n                     ret ures_err(terr_mismatch);\n                 }\n-                // TODO: factor this cruft out\n-                let result_tps: [t] = [];\n-                let i = 0u;\n-                let expected_len = vec::len::<t>(expected_tps);\n-                while i < expected_len {\n-                    let expected_tp = expected_tps[i];\n-                    let actual_tp = actual_tps[i];\n-                    let result = unify_step(\n-                        cx, expected_tp, actual_tp, variance);\n-                    alt result {\n-                      ures_ok(rty) { result_tps += [rty]; }\n-                      _ { ret result; }\n-                    }\n-                    i += 1u;\n-                }\n-                ret ures_ok(mk_tag(cx.tcx, expected_id, result_tps));\n+                ret unify_tps(cx, expected_tps, actual_tps, variance, {|tps|\n+                    ures_ok(mk_tag(cx.tcx, expected_id, tps))\n+                });\n               }\n               _ {/* fall through */ }\n             }\n             ret ures_err(terr_mismatch);\n           }\n+          ty_iface(expected_id, expected_tps) {\n+            alt struct(cx.tcx, actual) {\n+              ty::ty_iface(actual_id, actual_tps) {\n+                if expected_id != actual_id {\n+                    ret ures_err(terr_mismatch);\n+                }\n+                ret unify_tps(cx, expected_tps, actual_tps, variance, {|tps|\n+                    ures_ok(mk_iface(cx.tcx, expected_id, tps))\n+                });\n+              }\n+              _ {}\n+            }\n+            ret ures_err(terr_mismatch);\n+          }\n           ty::ty_box(expected_mt) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_box(actual_mt) {"}, {"sha": "21adb2af201ffff744adc07da3edd2cb435f3adf", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -422,7 +422,15 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_impl(_, _, _) | ast::item_mod(_) |\n+      ast::item_iface(tps, methods) {\n+        let t = ty::mk_named(tcx, ty::mk_iface(tcx, local_def(it.id),\n+                                               mk_ty_params(tcx, tps)),\n+                             @it.ident);\n+        let tpt = {kinds: ty_param_kinds(tps), ty: t};\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_impl(_, _, _, _) | ast::item_mod(_) |\n       ast::item_native_mod(_) { fail; }\n     }\n }\n@@ -647,7 +655,7 @@ mod collect {\n             write::ty_only(cx.tcx, it.id, tpt.ty);\n             get_tag_variant_types(cx, tpt.ty, variants, ty_params);\n           }\n-          ast::item_impl(_, selfty, ms) {\n+          ast::item_impl(_, _, selfty, ms) {\n             for m in ms {\n                 let ty = ty::mk_fn(cx.tcx, ty_of_fn_decl(cx.tcx, m_collect,\n                                                          m.decl));\n@@ -1429,9 +1437,9 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n               some(m) {\n                 let (n_tps, self_ty) = if did.crate == ast::local_crate {\n                     alt fcx.ccx.tcx.items.get(did.node) {\n-                      ast_map::node_item(@{node: ast::item_impl(tps, st, _),\n+                      ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n                                            _}) {\n-                        (vec::len(tps), ast_ty_to_ty_crate(fcx.ccx, st))\n+                        (vec::len(ts), ast_ty_to_ty_crate(fcx.ccx, st))\n                       }\n                     }\n                 } else {\n@@ -2637,7 +2645,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         // Now remove the info from the stack.\n         vec::pop(ccx.self_infos);\n       }\n-      ast::item_impl(_, ty, ms) {\n+      ast::item_impl(_, _, ty, ms) {\n         ccx.self_infos += [self_impl(ast_ty_to_ty(ccx.tcx, m_check, ty))];\n         for m in ms { check_method(ccx, m); }\n         vec::pop(ccx.self_infos);"}, {"sha": "9952dd55546c70efd7b3fed1d407b764229098c8", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -490,7 +490,9 @@ tag item_ {\n     item_obj(_obj, [ty_param], /* constructor id */node_id);\n     item_res(fn_decl /* dtor */, [ty_param], blk,\n              node_id /* dtor id */, node_id /* ctor id */);\n-    item_impl([ty_param], @ty /* self */, [@method]);\n+    item_iface([ty_param], [ty_method]);\n+    item_impl([ty_param], option::t<@ty> /* iface */,\n+              @ty /* self */, [@method]);\n }\n \n type native_item ="}, {"sha": "d06c98b0a3123d9bec6d7151a11ca2e3858c24bc", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -65,7 +65,7 @@ type a_f =\n      fold_native_mod: fn@(native_mod) -> native_mod,\n      fold_variant: fn@(variant) -> variant,\n      fold_ident: fn@(&&ident) -> ident,\n-     fold_path: fn@(@path) -> @path,\n+     fold_path: fn@(&&@path) -> @path,\n      fold_local: fn@(&&@local) -> @local,\n      map_exprs: fn@(fn@(&&@expr) -> @expr, [@expr]) -> [@expr],\n      new_id: fn@(node_id) -> node_id,\n@@ -94,7 +94,7 @@ fn nf_mod_dummy(_m: _mod) -> _mod { fail; }\n fn nf_native_mod_dummy(_n: native_mod) -> native_mod { fail; }\n fn nf_variant_dummy(_v: variant) -> variant { fail; }\n fn nf_ident_dummy(&&_i: ident) -> ident { fail; }\n-fn nf_path_dummy(_p: @path) -> @path { fail; }\n+fn nf_path_dummy(&&_p: @path) -> @path { fail; }\n fn nf_obj_field_dummy(_o: obj_field) -> obj_field { fail; }\n fn nf_local_dummy(&&_o: @local) -> @local { fail; }\n \n@@ -243,10 +243,13 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                       methods: vec::map(o.methods, fld.fold_method)},\n                      typms, d)\n           }\n-          item_impl(tps, ty, methods) {\n-            item_impl(tps, fld.fold_ty(ty),\n+          item_impl(tps, ifce, ty, methods) {\n+            item_impl(tps, option::map(ifce, fld.fold_ty), fld.fold_ty(ty),\n                       vec::map(methods, fld.fold_method))\n           }\n+          item_iface(tps, methods) {\n+            item_iface(tps, methods)\n+          }\n           item_res(decl, typms, body, did, cid) {\n             item_res(fold_fn_decl(decl, fld), typms, fld.fold_block(body),\n                      did, cid)\n@@ -471,7 +474,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n \n fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident { ret i; }\n \n-fn noop_fold_path(p: path_, fld: ast_fold) -> path_ {\n+fn noop_fold_path(&&p: path_, fld: ast_fold) -> path_ {\n     ret {global: p.global,\n          idents: vec::map(p.idents, fld.fold_ident),\n          types: vec::map(p.types, fld.fold_ty)};\n@@ -630,7 +633,7 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n     fn f_ident(afp: ast_fold_precursor, f: ast_fold, &&x: ident) -> ident {\n         ret afp.fold_ident(x, f);\n     }\n-    fn f_path(afp: ast_fold_precursor, f: ast_fold, x: @path) -> @path {\n+    fn f_path(afp: ast_fold_precursor, f: ast_fold, &&x: @path) -> @path {\n         ret @{node: afp.fold_path(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_local(afp: ast_fold_precursor, f: ast_fold, &&x: @local) -> @local {"}, {"sha": "8299f23ae2032c2067073ffcd03841781c3a1ec9", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -165,7 +165,7 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n                  \"cont\", \"ret\", \"be\", \"fail\", \"type\", \"resource\", \"check\",\n                  \"assert\", \"claim\", \"native\", \"fn\", \"lambda\", \"pure\",\n                  \"unsafe\", \"block\", \"import\", \"export\", \"let\", \"const\",\n-                 \"log\", \"tag\", \"obj\", \"copy\", \"sendfn\", \"impl\"] {\n+                 \"log\", \"tag\", \"obj\", \"copy\", \"sendfn\", \"impl\", \"iface\"] {\n         words.insert(word, ());\n     }\n     words\n@@ -285,7 +285,7 @@ fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n                     constraints: constrs});\n }\n \n-fn parse_ty_obj(p: parser) -> ast::ty_ {\n+fn parse_ty_methods(p: parser) -> [ast::ty_method] {\n     fn parse_method_sig(p: parser) -> ast::ty_method {\n         let flo = p.get_lo_pos();\n         let proto: ast::proto = parse_method_proto(p);\n@@ -298,10 +298,8 @@ fn parse_ty_obj(p: parser) -> ast::ty_ {\n           }\n         }\n     }\n-    let meths =\n-        parse_seq(token::LBRACE, token::RBRACE, seq_sep_none(),\n-                  parse_method_sig, p);\n-    ret ast::ty_obj(meths.node);\n+    parse_seq(token::LBRACE, token::RBRACE, seq_sep_none(),\n+              parse_method_sig, p).node\n }\n \n fn parse_mt(p: parser) -> ast::mt {\n@@ -519,7 +517,7 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     } else if eat_word(p, \"sendfn\") {\n         t = parse_ty_fn(ast::proto_send, p);\n     } else if eat_word(p, \"obj\") {\n-        t = parse_ty_obj(p);\n+        t = ast::ty_obj(parse_ty_methods(p));\n     } else if p.peek() == token::MOD_SEP || is_ident(p.peek()) {\n         let path = parse_path(p);\n         t = ast::ty_path(path, p.get_id());\n@@ -676,47 +674,22 @@ fn is_plain_ident(p: parser) -> bool {\n \n fn parse_path(p: parser) -> @ast::path {\n     let lo = p.get_lo_pos();\n-    let hi = lo;\n-\n-    let global;\n-    if p.peek() == token::MOD_SEP {\n-        global = true;\n-        p.bump();\n-    } else { global = false; }\n-\n-    let ids: [ast::ident] = [];\n-    while true {\n-        alt p.peek() {\n-          token::IDENT(i, _) {\n-            hi = p.get_hi_pos();\n-            ids += [p.get_str(i)];\n-            hi = p.get_hi_pos();\n-            p.bump();\n-            if p.peek() == token::MOD_SEP && p.look_ahead(1u) != token::LT {\n-                p.bump();\n-            } else { break; }\n-          }\n-          _ { break; }\n-        }\n+    let global = eat(p, token::MOD_SEP), ids = [parse_ident(p)];\n+    while p.look_ahead(1u) != token::LT && eat(p, token::MOD_SEP) {\n+        ids += [parse_ident(p)];\n     }\n-    ret @spanned(lo, hi, {global: global, idents: ids, types: []});\n+    ret @spanned(lo, p.get_last_hi_pos(),\n+                 {global: global, idents: ids, types: []});\n }\n \n-fn parse_path_and_ty_param_substs(p: parser) -> @ast::path {\n+fn parse_path_and_ty_param_substs(p: parser, colons: bool) -> @ast::path {\n     let lo = p.get_lo_pos();\n     let path = parse_path(p);\n-    if p.peek() == token::MOD_SEP {\n-        p.bump();\n-\n-        let seq =\n-            parse_seq_lt_gt(some(token::COMMA), {|p| parse_ty(p, false)}, p);\n-        let hi = seq.span.hi;\n-        path = @spanned(lo, hi,\n-                        {global: path.node.global,\n-                         idents: path.node.idents,\n-                         types: seq.node});\n-    }\n-    ret path;\n+    if colons ? eat(p, token::MOD_SEP) : p.peek() == token::LT {\n+        let seq = parse_seq_lt_gt(some(token::COMMA),\n+                                  {|p| parse_ty(p, false)}, p);\n+        @spanned(lo, seq.span.hi, {types: seq.node with path.node})\n+    } else { path }\n }\n \n fn parse_mutability(p: parser) -> ast::mutability {\n@@ -958,7 +931,7 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n                   is_ident(p.peek()) && !is_word(p, \"true\") &&\n                       !is_word(p, \"false\") {\n         check_bad_word(p);\n-        let pth = parse_path_and_ty_param_substs(p);\n+        let pth = parse_path_and_ty_param_substs(p, true);\n         hi = pth.span.hi;\n         ex = ast::expr_path(pth);\n     } else {\n@@ -984,10 +957,11 @@ fn parse_syntax_ext(p: parser) -> @ast::expr {\n }\n \n fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n-    let pth = parse_path(p);\n-    if vec::len(pth.node.idents) == 0u {\n-        p.fatal(\"expected a syntax expander name\");\n+    alt p.peek() {\n+      token::IDENT(_, _) {}\n+      _ { p.fatal(\"expected a syntax expander name\"); }\n     }\n+    let pth = parse_path(p);\n     //temporary for a backwards-compatible cycle:\n     let sep = seq_sep(token::COMMA);\n     let es =\n@@ -1518,7 +1492,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n             let sub = eat(p, token::AT) ? some(parse_pat(p)) : none;\n             pat = ast::pat_bind(name, sub);\n         } else {\n-            let tag_path = parse_path_and_ty_param_substs(p);\n+            let tag_path = parse_path_and_ty_param_substs(p, true);\n             hi = tag_path.span.hi;\n             let args: [@ast::pat];\n             alt p.peek() {\n@@ -1751,12 +1725,9 @@ fn parse_ty_param(p: parser) -> ast::ty_param {\n }\n \n fn parse_ty_params(p: parser) -> [ast::ty_param] {\n-    let ty_params: [ast::ty_param] = [];\n-    if p.peek() == token::LT {\n-        p.bump();\n-        ty_params = parse_seq_to_gt(some(token::COMMA), parse_ty_param, p);\n-    }\n-    ret ty_params;\n+    if eat(p, token::LT) {\n+        parse_seq_to_gt(some(token::COMMA), parse_ty_param, p)\n+    } else { [] }\n }\n \n fn parse_fn_decl(p: parser, proto: ast::proto, purity: ast::purity)\n@@ -1866,15 +1837,47 @@ fn parse_item_obj(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                 attrs);\n }\n \n-fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n+fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos(), ident = parse_ident(p),\n+        tps = parse_ty_params(p), meths = parse_ty_methods(p);\n+    ret mk_item(p, lo, p.get_last_hi_pos(), ident,\n+                ast::item_iface(tps, meths), attrs);\n+}\n+\n+fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n+    let lo = p.get_last_lo_pos(), ident, tps, ifce;\n+    fn wrap_path(p: parser, pt: @ast::path) -> @ast::ty {\n+        @{node: ast::ty_path(pt, p.get_id()), span: pt.span}\n+    }\n+    if eat_word(p, \"of\") {\n+        let path = parse_path_and_ty_param_substs(p, false);\n+        tps = vec::map(path.node.types, {|tp|\n+            alt tp.node {\n+              ast::ty_path(pt, _) {\n+                if vec::len(pt.node.idents) == 1u &&\n+                   vec::len(pt.node.types) == 0u {\n+                     ret {ident: pt.node.idents[0], kind: ast::kind_sendable};\n+                }\n+              }\n+              _ {}\n+            }\n+            p.fatal(\"only single-word, parameter-less types allowed here\");\n+        });\n+        ident = path.node.idents[vec::len(path.node.idents)-1u];\n+        ifce = some(wrap_path(p, path));\n+    } else {\n+        ident = parse_ident(p);\n         tps = parse_ty_params(p);\n+        ifce = if eat_word(p, \"of\") {\n+            some(wrap_path(p, parse_path_and_ty_param_substs(p, false)))\n+        } else { none };\n+    };\n     expect_word(p, \"for\");\n     let ty = parse_ty(p, false), meths = [];\n     expect(p, token::LBRACE);\n     while !eat(p, token::RBRACE) { meths += [parse_method(p, true)]; }\n     ret mk_item(p, lo, p.get_last_hi_pos(), ident,\n-                ast::item_impl(tps, ty, meths), attrs);\n+                ast::item_impl(tps, ifce, ty, meths), attrs);\n }\n \n fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n@@ -2145,6 +2148,8 @@ fn parse_item(p: parser, attrs: [ast::attribute]) -> option::t<@ast::item> {\n     } else if is_word(p, \"obj\") && p.look_ahead(1u) != token::LPAREN {\n         p.bump();\n         ret some(parse_item_obj(p, attrs));\n+    } else if eat_word(p, \"iface\") {\n+        ret some(parse_item_iface(p, attrs));\n     } else if eat_word(p, \"impl\") {\n         ret some(parse_item_impl(p, attrs));\n     } else if eat_word(p, \"resource\") {"}, {"sha": "99793d1b816a10ee2cc2952cee719ba5cab26bab", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -311,14 +311,7 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n       ast::ty_obj(methods) {\n         head(s, \"obj\");\n         bopen(s);\n-        for m: ast::ty_method in methods {\n-            hardbreak_if_not_bol(s);\n-            cbox(s, indent_unit);\n-            maybe_print_comment(s, m.span.lo);\n-            print_ty_fn(s, m.decl, some(m.ident));\n-            word(s.s, \";\");\n-            end(s);\n-        }\n+        for m in methods { print_ty_method(s, m); }\n         bclose(s, ty.span);\n       }\n       ast::ty_path(path, _) { print_path(s, path, false); }\n@@ -473,11 +466,19 @@ fn print_item(s: ps, &&item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_impl(tps, ty, methods) {\n+      ast::item_impl(tps, ifce, ty, methods) {\n         head(s, \"impl\");\n         word(s.s, item.ident);\n         print_type_params(s, tps);\n-        nbsp(s);\n+        space(s.s);\n+        alt ifce {\n+          some(ty) {\n+            word_nbsp(s, \"of\");\n+            print_type(s, ty);\n+            space(s.s);\n+          }\n+          _ {}\n+        }\n         word_nbsp(s, \"for\");\n         print_type(s, ty);\n         space(s.s);\n@@ -491,6 +492,14 @@ fn print_item(s: ps, &&item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n+      ast::item_iface(tps, methods) {\n+        head(s, \"iface\");\n+        word(s.s, item.ident);\n+        print_type_params(s, tps);\n+        bopen(s);\n+        for meth in methods { print_ty_method(s, meth); }\n+        bclose(s, item.span);\n+      }\n       ast::item_res(decl, tps, body, dt_id, ct_id) {\n         head(s, \"resource\");\n         word(s.s, item.ident);\n@@ -506,6 +515,15 @@ fn print_item(s: ps, &&item: @ast::item) {\n     s.ann.post(ann_node);\n }\n \n+fn print_ty_method(s: ps, m: ast::ty_method) {\n+    hardbreak_if_not_bol(s);\n+    cbox(s, indent_unit);\n+    maybe_print_comment(s, m.span.lo);\n+    print_ty_fn(s, m.decl, some(m.ident));\n+    word(s.s, \";\");\n+    end(s);\n+}\n+\n fn print_outer_attributes(s: ps, attrs: [ast::attribute]) {\n     let count = 0;\n     for attr: ast::attribute in attrs {"}, {"sha": "ecdf8c9a05dfb1a93195a3bfa383d8ed0c9561de", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057617c6654bfd5a677112cd26141d0b9c137145/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=057617c6654bfd5a677112cd26141d0b9c137145", "patch": "@@ -120,13 +120,20 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n                              some(m.ident), m.id, e, v);\n         }\n       }\n-      item_impl(_, ty, methods) {\n-        visit_ty(ty, e, v);\n+      item_impl(_, ifce, ty, methods) {\n+        alt ifce { some(ty) { v.visit_ty(ty, e, v); } _ {} }\n+        v.visit_ty(ty, e, v);\n         for m in methods {\n             v.visit_fn_proto(m.decl, m.tps, m.body, m.span,\n                              some(m.ident), m.id, e, v);\n         }\n       }\n+      item_iface(_, methods) {\n+        for m in methods {\n+            for a in m.decl.inputs { v.visit_ty(a.ty, e, v); }\n+            v.visit_ty(m.decl.output, e, v);\n+        }\n+      }\n     }\n }\n "}]}