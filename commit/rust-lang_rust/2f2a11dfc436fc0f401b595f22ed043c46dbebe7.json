{"sha": "2f2a11dfc436fc0f401b595f22ed043c46dbebe7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMmExMWRmYzQzNmZjMGY0MDFiNTk1ZjIyZWQwNDNjNDZkYmViZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-16T21:01:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-16T21:01:31Z"}, "message": "Auto merge of #50710 - Zoxc:value_to_constvalue, r=oli-obk\n\nFix conversion from Miri Value to ConstValue\n\nThis fixes an error compiling the `immeta` 0.3.6 crate. https://github.com/rust-lang/rust/issues/50707 may be fixed too.\n\nr? @oli-obk", "tree": {"sha": "d22171e4a637913a739fdfac01df1fe3f341d3b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d22171e4a637913a739fdfac01df1fe3f341d3b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f2a11dfc436fc0f401b595f22ed043c46dbebe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2a11dfc436fc0f401b595f22ed043c46dbebe7", "html_url": "https://github.com/rust-lang/rust/commit/2f2a11dfc436fc0f401b595f22ed043c46dbebe7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f2a11dfc436fc0f401b595f22ed043c46dbebe7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1151c9819cca90e511f60757297629177272d16", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1151c9819cca90e511f60757297629177272d16", "html_url": "https://github.com/rust-lang/rust/commit/e1151c9819cca90e511f60757297629177272d16"}, {"sha": "41a032db9050941e19fec7f3409de00ae175848d", "url": "https://api.github.com/repos/rust-lang/rust/commits/41a032db9050941e19fec7f3409de00ae175848d", "html_url": "https://github.com/rust-lang/rust/commit/41a032db9050941e19fec7f3409de00ae175848d"}], "stats": {"total": 144, "additions": 88, "deletions": 56}, "files": [{"sha": "7d0c16de0a440d74a66425fe8f857d7c16a55c87", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 67, "deletions": 56, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/2f2a11dfc436fc0f401b595f22ed043c46dbebe7/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2a11dfc436fc0f401b595f22ed043c46dbebe7/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=2f2a11dfc436fc0f401b595f22ed043c46dbebe7", "patch": "@@ -93,50 +93,69 @@ pub fn eval_body<'a, 'tcx>(\n     }\n }\n \n-pub fn value_to_const_value<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    val: Value,\n+pub fn value_to_const_value<'tcx>(\n+    ecx: &EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n+    mut val: Value,\n     ty: Ty<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n-    let layout = tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap();\n+    let result = (|| {\n+        // Convert to ByVal or ByValPair if possible\n+        if let Value::ByRef(ptr, align) = val {\n+            if let Some(read_val) = ecx.try_read_value(ptr, align, ty)? {\n+                val = read_val;\n+            }\n+        }\n \n-    if layout.is_zst() {\n-        return ty::Const::from_const_value(\n-            tcx,\n-            ConstValue::ByVal(PrimVal::Undef),\n-            ty);\n-    }\n+        let layout = ecx.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap();\n \n-    let val = match layout.abi {\n-        layout::Abi::Scalar(..) => {\n-            if let Value::ByVal(val) = val {\n-                ConstValue::ByVal(val)\n-            } else {\n-                bug!(\"expected ByVal value, got {:?}\", val);\n-            }\n+        if layout.is_zst() {\n+            return Ok(ty::Const::from_const_value(\n+                ecx.tcx.tcx,\n+                ConstValue::ByVal(PrimVal::Undef),\n+                ty));\n         }\n-        layout::Abi::ScalarPair(..) => {\n-            if let Value::ByValPair(a, b) = val {\n-                ConstValue::ByValPair(a, b)\n-            } else {\n-                bug!(\"expected ByValPair value, got {:?}\", val);\n+\n+        let val = match layout.abi {\n+            layout::Abi::Scalar(..) => {\n+                if let Value::ByVal(val) = val {\n+                    ConstValue::ByVal(val)\n+                } else {\n+                    bug!(\"expected ByVal value, got {:?}\", val);\n+                }\n             }\n-        }\n-        _ => {\n-            if let Value::ByRef(ptr, align) = val {\n-                let ptr = ptr.primval.to_ptr().unwrap();\n-                assert_eq!(ptr.offset, 0);\n-                let alloc = tcx.interpret_interner\n-                               .get_alloc(ptr.alloc_id)\n-                               .expect(\"miri allocation never successfully created\");\n-                assert_eq!(align, alloc.align);\n-                ConstValue::ByRef(alloc)\n-            } else {\n-                bug!(\"expected ByRef value, got {:?}\", val);\n+            layout::Abi::ScalarPair(..) => {\n+                if let Value::ByValPair(a, b) = val {\n+                    ConstValue::ByValPair(a, b)\n+                } else {\n+                    bug!(\"expected ByValPair value, got {:?}\", val);\n+                }\n             }\n-        },\n-    };\n-    ty::Const::from_const_value(tcx, val, ty)\n+            _ => {\n+                if let Value::ByRef(ptr, _) = val {\n+                    let ptr = ptr.primval.to_ptr().unwrap();\n+                    assert_eq!(ptr.offset, 0);\n+                    let alloc = ecx.memory.get(ptr.alloc_id)?;\n+                    assert!(alloc.align.abi() >= layout.align.abi());\n+                    assert!(alloc.bytes.len() as u64 == layout.size.bytes());\n+                    let mut alloc = alloc.clone();\n+                    // The align field is meaningless for values, so just use the layout's align\n+                    alloc.align = layout.align;\n+                    let alloc = ecx.tcx.intern_const_alloc(alloc);\n+                    ConstValue::ByRef(alloc)\n+                } else {\n+                    bug!(\"expected ByRef value, got {:?}\", val);\n+                }\n+            },\n+        };\n+        Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, ty))\n+    })();\n+    match result {\n+        Ok(v) => v,\n+        Err(mut err) => {\n+            ecx.report(&mut err, true, None);\n+            bug!(\"miri error occured when converting Value to ConstValue\")\n+        }\n+    }\n }\n \n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n@@ -423,7 +442,7 @@ pub fn const_val_field<'a, 'tcx>(\n     let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let result = (|| {\n         let value = ecx.const_value_to_value(value, ty)?;\n-        let (mut field, ty) = match value {\n+        let (field, ty) = match value {\n             Value::ByValPair(..) | Value::ByVal(_) => \n                 ecx.read_field(value, variant, field, ty)?.expect(\"const_val_field on non-field\"),\n             Value::ByRef(ptr, align) => {\n@@ -438,24 +457,16 @@ pub fn const_val_field<'a, 'tcx>(\n                 (Value::ByRef(ptr, align), layout.ty)\n             }\n         };\n-        if let Value::ByRef(ptr, align) = field {\n-            if let Some(val) = ecx.try_read_value(ptr, align, ty)? {\n-                field = val;\n-            }\n-        }\n-        Ok((field, ty))\n+        Ok(value_to_const_value(&ecx, field, ty))\n     })();\n-    match result {\n-        Ok((field, ty)) => Ok(value_to_const_value(tcx, field, ty)),\n-        Err(err) => {\n-            let (trace, span) = ecx.generate_stacktrace(None);\n-            let err = ErrKind::Miri(err, trace);\n-            Err(ConstEvalErr {\n-                kind: err.into(),\n-                span,\n-            })\n-        },\n-    }\n+    result.map_err(|err| {\n+        let (trace, span) = ecx.generate_stacktrace(None);\n+        let err = ErrKind::Miri(err, trace);\n+        ConstEvalErr {\n+            kind: err.into(),\n+            span,\n+        }\n+    })\n }\n \n pub fn const_variant_index<'a, 'tcx>(\n@@ -541,7 +552,7 @@ pub fn const_eval_provider<'a, 'tcx>(\n \n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n     res.map(|(val, _, miri_ty)| {\n-        value_to_const_value(tcx, val, miri_ty)\n+        value_to_const_value(&ecx, val, miri_ty)\n     }).map_err(|mut err| {\n         if tcx.is_static(def_id).is_some() {\n             ecx.report(&mut err, true, None);"}, {"sha": "8cb4d92c21cf0b4ccb14c6e9741e049cf71def73", "filename": "src/test/run-pass/match-larger-const.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2f2a11dfc436fc0f401b595f22ed043c46dbebe7/src%2Ftest%2Frun-pass%2Fmatch-larger-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2a11dfc436fc0f401b595f22ed043c46dbebe7/src%2Ftest%2Frun-pass%2Fmatch-larger-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-larger-const.rs?ref=2f2a11dfc436fc0f401b595f22ed043c46dbebe7", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[derive(Eq, PartialEq)]\n+pub struct Data([u8; 4]);\n+\n+const DATA: Data = Data([1, 2, 3, 4]);\n+\n+fn main() {\n+    match DATA {\n+        DATA => (),\n+        _ => (),\n+    }\n+}"}]}