{"sha": "cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZTMxYTQyMjljNTE5ZDdhZjdiNWQ4NmY5Mjk1ZmQyM2FkYjhjZDM=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-09-14T15:48:57Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:15:13Z"}, "message": "Generalized base::coerce_unsized_into", "tree": {"sha": "20fa448c1fceb703bac328fa69e7a84467e43006", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20fa448c1fceb703bac328fa69e7a84467e43006"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "html_url": "https://github.com/rust-lang/rust/commit/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78dd95f4c719797d64f988a35a6a25f2dfc7c124", "url": "https://api.github.com/repos/rust-lang/rust/commits/78dd95f4c719797d64f988a35a6a25f2dfc7c124", "html_url": "https://github.com/rust-lang/rust/commit/78dd95f4c719797d64f988a35a6a25f2dfc7c124"}], "stats": {"total": 329, "additions": 184, "deletions": 145}, "files": [{"sha": "38bdd9a79da207a614d81ecdd96a12ab5faa5664", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -35,13 +35,13 @@ pub fn codegen_inline_asm(\n \n     // Prepare the output operands\n     let mut indirect_outputs = vec![];\n-    for (i, (out, place)) in ia.outputs.iter().zip(&outputs).enumerate() {\n+    for (i, (out, &place)) in ia.outputs.iter().zip(&outputs).enumerate() {\n         if out.is_rw {\n-            inputs.push(place.load(bx).immediate());\n+            inputs.push(bx.load_operand(place).immediate());\n             ext_constraints.push(i.to_string());\n         }\n         if out.is_indirect {\n-            indirect_outputs.push(place.load(bx).immediate());\n+            indirect_outputs.push(bx.load_operand(place).immediate());\n         } else {\n             output_types.push(place.layout.llvm_type(bx.cx()));\n         }"}, {"sha": "4f726741ec1b4ed058400713f28a41acd34051b3", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -65,7 +65,7 @@ use monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n use rustc_codegen_utils::symbol_names_test;\n use time_graph;\n use mono_item::{MonoItem, MonoItemExt};\n-use type_of::LayoutLlvmExt;\n+\n use rustc::util::nodemap::FxHashMap;\n use CrateInfo;\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -208,7 +208,7 @@ pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n             let vtable_ptr = cx.layout_of(cx.tcx().mk_mut_ptr(target))\n                 .field(cx, abi::FAT_PTR_EXTRA);\n             cx.static_ptrcast(meth::get_vtable(cx, source, data.principal()),\n-                            cx.backend_type(&vtable_ptr))\n+                            cx.backend_type(vtable_ptr))\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n                   source,\n@@ -232,13 +232,13 @@ pub fn unsize_thin_ptr<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(bx.cx().type_is_sized(a));\n-            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(&bx.cx().layout_of(b)));\n+            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n             assert!(bx.cx().type_is_sized(a));\n-            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(&bx.cx().layout_of(b)));\n+            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n@@ -263,31 +263,31 @@ pub fn unsize_thin_ptr<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             }\n             let (lldata, llextra) = result.unwrap();\n             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-            (bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(&dst_layout, 0, true)),\n-             bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(&dst_layout, 1, true)))\n+            (bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true)),\n+             bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true)))\n         }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n }\n \n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    src: PlaceRef<'tcx, &'ll Value>,\n-    dst: PlaceRef<'tcx, &'ll Value>\n-) {\n+pub fn coerce_unsized_into<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    src: PlaceRef<'tcx, Bx::Value>,\n+    dst: PlaceRef<'tcx, Bx::Value>\n+)  {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n     let coerce_ptr = || {\n-        let (base, info) = match src.load(bx).val {\n+        let (base, info) = match bx.load_operand(src).val {\n             OperandValue::Pair(base, info) => {\n                 // fat-ptr to fat-ptr unsize preserves the vtable\n                 // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n                 // So we need to pointercast the base to ensure\n                 // the types match up.\n                 let thin_ptr = dst.layout.field(bx.cx(), abi::FAT_PTR_ADDR);\n-                (bx.pointercast(base, thin_ptr.llvm_type(bx.cx())), info)\n+                (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n             }\n             OperandValue::Immediate(base) => {\n                 unsize_thin_ptr(bx, base, src_ty, dst_ty)"}, {"sha": "07a3616a7f8b9ed8ae39842acde496e7a5e9eefe", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -13,15 +13,18 @@ use llvm::{self, False, OperandBundleDef, BasicBlock};\n use common::{self, *};\n use context::CodegenCx;\n use type_::Type;\n+use type_of::LayoutLlvmExt;\n use value::Value;\n use libc::{c_uint, c_char};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{Align, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, Size, TyLayout};\n use rustc::session::{config, Session};\n use rustc_data_structures::small_c_str::SmallCStr;\n use interfaces::*;\n use syntax;\n-\n+use base;\n+use mir::operand::{OperandValue, OperandRef};\n+use mir::place::PlaceRef;\n use std::borrow::Cow;\n use std::ops::Range;\n use std::ptr;\n@@ -538,6 +541,73 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n+    fn load_operand(\n+        &self,\n+        place: PlaceRef<'tcx, &'ll Value>\n+    ) -> OperandRef<'tcx, &'ll Value> {\n+        debug!(\"PlaceRef::load: {:?}\", place);\n+\n+        assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n+\n+        if place.layout.is_zst() {\n+            return OperandRef::new_zst(self.cx(), place.layout);\n+        }\n+\n+        let scalar_load_metadata = |load, scalar: &layout::Scalar| {\n+            let vr = scalar.valid_range.clone();\n+            match scalar.value {\n+                layout::Int(..) => {\n+                    let range = scalar.valid_range_exclusive(self.cx());\n+                    if range.start != range.end {\n+                        self.range_metadata(load, range);\n+                    }\n+                }\n+                layout::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n+                    self.nonnull_metadata(load);\n+                }\n+                _ => {}\n+            }\n+        };\n+\n+        let val = if let Some(llextra) = place.llextra {\n+            OperandValue::Ref(place.llval, Some(llextra), place.align)\n+        } else if place.layout.is_llvm_immediate() {\n+            let mut const_llval = None;\n+            unsafe {\n+                if let Some(global) = llvm::LLVMIsAGlobalVariable(place.llval) {\n+                    if llvm::LLVMIsGlobalConstant(global) == llvm::True {\n+                        const_llval = llvm::LLVMGetInitializer(global);\n+                    }\n+                }\n+            }\n+            let llval = const_llval.unwrap_or_else(|| {\n+                let load = self.load(place.llval, place.align);\n+                if let layout::Abi::Scalar(ref scalar) = place.layout.abi {\n+                    scalar_load_metadata(load, scalar);\n+                }\n+                load\n+            });\n+            OperandValue::Immediate(base::to_immediate(self, llval, place.layout))\n+        } else if let layout::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n+            let load = |i, scalar: &layout::Scalar| {\n+                let llptr = self.struct_gep(place.llval, i as u64);\n+                let load = self.load(llptr, place.align);\n+                scalar_load_metadata(load, scalar);\n+                if scalar.is_bool() {\n+                    self.trunc(load, self.cx().type_i1())\n+                } else {\n+                    load\n+                }\n+            };\n+            OperandValue::Pair(load(0, a), load(1, b))\n+        } else {\n+            OperandValue::Ref(place.llval, None, place.align)\n+        };\n+\n+        OperandRef { val, layout: place.layout }\n+    }\n+\n+\n \n     fn range_metadata(&self, load: &'ll Value, range: Range<u128>) {\n         if self.sess().target.target.arch == \"amdgpu\" {"}, {"sha": "7268c2c1aaccca53bb6ad2dd47c1393eec139247", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -14,23 +14,21 @@\n \n use std;\n \n-use builder::Builder;\n use common::*;\n use meth;\n-use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n+use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n-use value::Value;\n use interfaces::*;\n \n-pub fn size_and_align_of_dst(\n-    bx: &Builder<'_, 'll, 'tcx>,\n+pub fn size_and_align_of_dst<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n     t: Ty<'tcx>,\n-    info: Option<&'ll Value>\n-) -> (&'ll Value, &'ll Value) {\n+    info: Option<Bx::Value>\n+) -> (Bx::Value, Bx::Value) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, info);\n     if bx.cx().type_is_sized(t) {\n-        let (size, align) = bx.cx().size_and_align_of(t);\n+        let (size, align) = bx.cx().layout_of(t).size_and_align();\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n                t, info, size, align);\n         let size = bx.cx().const_usize(size.bytes());\n@@ -47,7 +45,7 @@ pub fn size_and_align_of_dst(\n             let unit = t.sequence_element_type(bx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            let (size, align) = bx.cx().size_and_align_of(unit);\n+            let (size, align) = bx.cx().layout_of(unit).size_and_align();\n             (bx.mul(info.unwrap(), bx.cx().const_usize(size.bytes())),\n              bx.cx().const_usize(align.abi()))\n         }"}, {"sha": "5799f5e84efd4ec9af6474c4679f1fbb7180d0de", "filename": "src/librustc_codegen_llvm/interfaces/backend.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -10,12 +10,13 @@\n \n use rustc::ty::layout::{HasTyCtxt, LayoutOf, TyLayout};\n use rustc::ty::Ty;\n-use std::fmt::Debug;\n+\n+use super::CodegenObject;\n \n pub trait BackendTypes {\n-    type Value: Debug + PartialEq + Copy;\n+    type Value: CodegenObject;\n     type BasicBlock;\n-    type Type: Debug + PartialEq + Copy;\n+    type Type: CodegenObject;\n     type Context;\n }\n "}, {"sha": "ebc8aa7a4cacee66dcaff7c8f1f0139e25b9f4c8", "filename": "src/librustc_codegen_llvm/interfaces/builder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -12,6 +12,8 @@ use super::HasCodegen;\n use builder::MemFlags;\n use common::*;\n use libc::c_char;\n+use mir::operand::OperandRef;\n+use mir::place::PlaceRef;\n use rustc::session::Session;\n use rustc::ty::layout::{Align, Size};\n \n@@ -88,6 +90,7 @@ pub trait BuilderMethods<'a, 'tcx: 'a>: HasCodegen<'tcx> {\n     fn load(&self, ptr: Self::Value, align: Align) -> Self::Value;\n     fn volatile_load(&self, ptr: Self::Value) -> Self::Value;\n     fn atomic_load(&self, ptr: Self::Value, order: AtomicOrdering, size: Size) -> Self::Value;\n+    fn load_operand(&self, place: PlaceRef<'tcx, Self::Value>) -> OperandRef<'tcx, Self::Value>;\n \n     fn range_metadata(&self, load: Self::Value, range: Range<u128>);\n     fn nonnull_metadata(&self, load: Self::Value);"}, {"sha": "4c5c9b164af23e971bb79b044c70f008936291e3", "filename": "src/librustc_codegen_llvm/interfaces/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -26,6 +26,8 @@ pub use self::misc::MiscMethods;\n pub use self::statics::StaticMethods;\n pub use self::type_::{BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods};\n \n+use std::fmt;\n+\n pub trait CodegenMethods<'tcx>:\n     Backend<'tcx>\n     + TypeMethods<'tcx>\n@@ -54,3 +56,6 @@ pub trait HasCodegen<'tcx>: Backend<'tcx> {\n             Context = Self::Context,\n         >;\n }\n+\n+pub trait CodegenObject: Copy + PartialEq + fmt::Debug {}\n+impl<T: Copy + PartialEq + fmt::Debug> CodegenObject for T {}"}, {"sha": "7a95f49def6321ac2dfcda86410e9992ddfeb71f", "filename": "src/librustc_codegen_llvm/interfaces/type_.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -69,12 +69,14 @@ pub trait DerivedTypeMethods<'tcx>: Backend<'tcx> {\n }\n \n pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n-    fn backend_type(&self, ty: &TyLayout<'tcx>) -> Self::Type;\n+    fn backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n+    fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n+    fn is_backend_immediate(&self, layout: TyLayout<'tcx>) -> bool;\n     fn scalar_pair_element_backend_type<'a>(\n         &self,\n-        ty: &TyLayout<'tcx>,\n+        layout: TyLayout<'tcx>,\n         index: usize,\n-        immediate: bool\n+        immediate: bool,\n     ) -> Self::Type;\n }\n "}, {"sha": "fe53ecd46e0ae5321199d0a2afbf1224dfb9b365", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -154,7 +154,7 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 let tp_ty = substs.type_at(0);\n                 if let OperandValue::Pair(_, meta) = args[0].val {\n                     let (llsize, _) =\n-                        glue::size_and_align_of_dst(&self, tp_ty, Some(meta));\n+                        glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n                     llsize\n                 } else {\n                     cx.const_usize(cx.size_of(tp_ty).bytes())\n@@ -168,7 +168,7 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 let tp_ty = substs.type_at(0);\n                 if let OperandValue::Pair(_, meta) = args[0].val {\n                     let (_, llalign) =\n-                        glue::size_and_align_of_dst(&self, tp_ty, Some(meta));\n+                        glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n                     llalign\n                 } else {\n                     cx.const_usize(cx.align_of(tp_ty).abi())\n@@ -353,9 +353,9 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                                     cx.type_bool()\n                                 );\n \n-                                let dest = result.project_field(&self, 0);\n+                                let dest = result.project_field(self, 0);\n                                 self.store(val, dest.llval, dest.align);\n-                                let dest = result.project_field(&self, 1);\n+                                let dest = result.project_field(self, 1);\n                                 self.store(overflow, dest.llval, dest.align);\n \n                                 return;\n@@ -520,9 +520,9 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                                 cx.type_bool()\n                             );\n \n-                            let dest = result.project_field(&self, 0);\n+                            let dest = result.project_field(self, 0);\n                             self.store(val, dest.llval, dest.align);\n-                            let dest = result.project_field(&self, 1);\n+                            let dest = result.project_field(self, 1);\n                             self.store(success, dest.llval, dest.align);\n                             return;\n                         } else {\n@@ -678,7 +678,7 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                             };\n                             let arg = PlaceRef::new_sized(ptr, arg.layout, align);\n                             (0..contents.len()).map(|i| {\n-                                arg.project_field(bx, i).load(bx).immediate()\n+                                bx.load_operand(arg.project_field(bx, i)).immediate()\n                             }).collect()\n                         }\n                         intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n@@ -729,7 +729,7 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                         assert!(!flatten);\n \n                         for i in 0..elems.len() {\n-                            let dest = result.project_field(&self, i);\n+                            let dest = result.project_field(self, i);\n                             let val = self.extract_value(val, i as u64);\n                             self.store(val, dest.llval, dest.align);\n                         }\n@@ -746,7 +746,7 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.store(llval, ptr, result.align);\n             } else {\n                 OperandRef::from_immediate_or_packed_pair(&self, llval, result.layout)\n-                    .val.store(&self, result);\n+                    .val.store(self, result);\n             }\n         }\n     }"}, {"sha": "77fce465f23bd7ff8d7ba4a85eaf8643e4532d9f", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -26,7 +26,7 @@ pub const DESTRUCTOR: VirtualIndex = VirtualIndex(0);\n pub const SIZE: VirtualIndex = VirtualIndex(1);\n pub const ALIGN: VirtualIndex = VirtualIndex(2);\n \n-impl<'a, 'tcx> VirtualIndex {\n+impl<'a, 'tcx: 'a> VirtualIndex {\n     pub fn from_index(index: usize) -> Self {\n         VirtualIndex(index as u64 + 3)\n     }\n@@ -52,11 +52,11 @@ impl<'a, 'tcx> VirtualIndex {\n         ptr\n     }\n \n-    pub fn get_usize(\n+    pub fn get_usize<Bx: BuilderMethods<'a, 'tcx>>(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n-        llvtable: &'ll Value\n-    ) -> &'ll Value {\n+        bx: &Bx,\n+        llvtable: Bx::Value\n+    ) -> Bx::Value {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", llvtable, self);\n "}, {"sha": "6307309109595e3d85c12534a0d27b57637ba315", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -165,8 +165,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     bx.cleanup_ret(cleanup_pad, None);\n                 } else {\n                     let slot = self.get_personality_slot(&bx);\n-                    let lp0 = slot.project_field(&bx, 0).load(&bx).immediate();\n-                    let lp1 = slot.project_field(&bx, 1).load(&bx).immediate();\n+                    let lp0 = bx.load_operand(slot.project_field(&bx, 0)).immediate();\n+                    let lp1 = bx.load_operand(slot.project_field(&bx, 1)).immediate();\n                     slot.storage_dead(&bx);\n \n                     if !bx.sess().target.target.options.custom_unwind_resume {\n@@ -835,7 +835,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             let tuple_ptr = PlaceRef::new_sized(llval, tuple.layout, align);\n             for i in 0..tuple.layout.fields.count() {\n                 let field_ptr = tuple_ptr.project_field(bx, i);\n-                self.codegen_argument(bx, field_ptr.load(bx), llargs, &args[i]);\n+                self.codegen_argument(bx, bx.load_operand(field_ptr), llargs, &args[i]);\n             }\n         } else if let Ref(_, Some(_), _) = tuple.val {\n             bug!(\"closure arguments must be sized\")\n@@ -994,7 +994,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let place = PlaceRef::alloca(bx, dst_layout, \"transmute_temp\");\n                     place.storage_live(bx);\n                     self.codegen_transmute_into(bx, src, place);\n-                    let op = place.load(bx);\n+                    let op = bx.load_operand(place);\n                     place.storage_dead(bx);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n                 }\n@@ -1032,7 +1032,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             Nothing => (),\n             Store(dst) => ret_ty.store(bx, llval, dst),\n             IndirectOperand(tmp, index) => {\n-                let op = tmp.load(bx);\n+                let op = bx.load_operand(tmp);\n                 tmp.storage_dead(bx);\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }\n@@ -1042,7 +1042,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let tmp = PlaceRef::alloca(bx, ret_ty.layout, \"tmp_ret\");\n                     tmp.storage_live(bx);\n                     ret_ty.store(bx, llval, tmp);\n-                    let op = tmp.load(bx);\n+                    let op = bx.load_operand(tmp);\n                     tmp.storage_dead(bx);\n                     op\n                 } else {"}, {"sha": "9939e0dcc45d331fb2f04fa7c223aa60ebd5ba01", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -567,7 +567,7 @@ fn arg_local_refs(\n             let indirect_operand = OperandValue::Pair(llarg, llextra);\n \n             let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout, &name);\n-            indirect_operand.store(&bx, tmp);\n+            indirect_operand.store(bx, tmp);\n             tmp\n         } else {\n             let tmp = PlaceRef::alloca(bx, arg.layout, &name);"}, {"sha": "d845d6ee34bf92bdd6ecd8ef88a5998e62988ad5", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -20,7 +20,7 @@ use value::Value;\n use type_of::LayoutLlvmExt;\n use glue;\n \n-use interfaces::{BuilderMethods, ConstMethods, BaseTypeMethods, IntrinsicDeclarationMethods};\n+use interfaces::*;\n \n use std::fmt;\n \n@@ -67,16 +67,20 @@ impl fmt::Debug for OperandRef<'tcx, &'ll Value> {\n     }\n }\n \n-impl OperandRef<'tcx, &'ll Value> {\n-    pub fn new_zst(cx: &CodegenCx<'ll, 'tcx>,\n-                   layout: TyLayout<'tcx>) -> OperandRef<'tcx, &'ll Value> {\n+impl<'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n+    pub fn new_zst<Cx: CodegenMethods<'tcx, Value = V>>(\n+        cx: &Cx,\n+        layout: TyLayout<'tcx>\n+    ) -> OperandRef<'tcx, V> {\n         assert!(layout.is_zst());\n         OperandRef {\n-            val: OperandValue::Immediate(cx.const_undef(layout.immediate_llvm_type(cx))),\n+            val: OperandValue::Immediate(cx.const_undef(cx.immediate_backend_type(layout))),\n             layout\n         }\n     }\n+}\n \n+impl OperandRef<'tcx, &'ll Value> {\n     pub fn from_const(bx: &Builder<'a, 'll, 'tcx>,\n                       val: &'tcx ty::Const<'tcx>)\n                       -> Result<OperandRef<'tcx, &'ll Value>, ErrorHandled> {\n@@ -122,7 +126,7 @@ impl OperandRef<'tcx, &'ll Value> {\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n             ConstValue::ByRef(_, alloc, offset) => {\n-                return Ok(PlaceRef::from_const_alloc(bx, layout, alloc, offset).load(bx));\n+                return Ok(bx.load_operand(PlaceRef::from_const_alloc(bx, layout, alloc, offset)));\n             },\n         };\n \n@@ -256,10 +260,17 @@ impl OperandRef<'tcx, &'ll Value> {\n     }\n }\n \n-impl OperandValue<&'ll Value> {\n-    pub fn store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx, &'ll Value>) {\n+impl<'a, 'tcx: 'a, V: CodegenObject> OperandValue<V> {\n+    pub fn store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        self,\n+        bx: &Bx,\n+        dest: PlaceRef<'tcx, Bx::Value>\n+    ) {\n         self.store_with_flags(bx, dest, MemFlags::empty());\n     }\n+}\n+\n+impl OperandValue<&'ll Value> {\n \n     pub fn volatile_store(\n         self,\n@@ -286,11 +297,13 @@ impl<'a, 'll: 'a, 'tcx: 'll> OperandValue<&'ll Value> {\n     ) {\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n     }\n+}\n \n-    fn store_with_flags(\n+impl<'a, 'tcx: 'a, V: CodegenObject> OperandValue<V> {\n+    fn store_with_flags<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n-        dest: PlaceRef<'tcx, &'ll Value>,\n+        bx: &Bx,\n+        dest: PlaceRef<'tcx, Bx::Value>,\n         flags: MemFlags,\n     ) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n@@ -427,7 +440,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n         // for most places, to consume them we just load them\n         // out from their home\n-        self.codegen_place(bx, place).load(bx)\n+        bx.load_operand(self.codegen_place(bx, place))\n     }\n \n     pub fn codegen_operand(&mut self,\n@@ -461,11 +474,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         bx.call(fnname, &[], None);\n                         // We've errored, so we don't have to produce working code.\n                         let layout = bx.cx().layout_of(ty);\n-                        PlaceRef::new_sized(\n+                        bx.load_operand(PlaceRef::new_sized(\n                             bx.cx().const_undef(bx.cx().type_ptr_to(layout.llvm_type(bx.cx()))),\n                             layout,\n                             layout.align,\n-                        ).load(bx)\n+                        ))\n                     })\n             }\n         }"}, {"sha": "981e5b3fe96c7ba79e9e2045b808648785b9919d", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 14, "deletions": 73, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, LLVMConstInBoundsGEP};\n+use llvm::LLVMConstInBoundsGEP;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, Size, VariantIdx, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n-use base;\n use builder::{Builder, MemFlags};\n use common::{CodegenCx, IntPredicate};\n use type_of::LayoutLlvmExt;\n@@ -24,7 +23,7 @@ use mir::constant::const_alloc_to_llvm;\n use interfaces::*;\n \n use super::{FunctionCx, LocalRef};\n-use super::operand::{OperandRef, OperandValue};\n+use super::operand::OperandValue;\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceRef<'tcx, V> {\n@@ -108,75 +107,14 @@ impl PlaceRef<'tcx, &'ll Value> {\n         }\n     }\n \n-    pub fn load(&self, bx: &Builder<'a, 'll, 'tcx>) -> OperandRef<'tcx, &'ll Value> {\n-        debug!(\"PlaceRef::load: {:?}\", self);\n-\n-        assert_eq!(self.llextra.is_some(), self.layout.is_unsized());\n-\n-        if self.layout.is_zst() {\n-            return OperandRef::new_zst(bx.cx(), self.layout);\n-        }\n-\n-        let scalar_load_metadata = |load, scalar: &layout::Scalar| {\n-            let vr = scalar.valid_range.clone();\n-            match scalar.value {\n-                layout::Int(..) => {\n-                    let range = scalar.valid_range_exclusive(bx.cx());\n-                    if range.start != range.end {\n-                        bx.range_metadata(load, range);\n-                    }\n-                }\n-                layout::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n-                    bx.nonnull_metadata(load);\n-                }\n-                _ => {}\n-            }\n-        };\n-\n-        let val = if let Some(llextra) = self.llextra {\n-            OperandValue::Ref(self.llval, Some(llextra), self.align)\n-        } else if self.layout.is_llvm_immediate() {\n-            let mut const_llval = None;\n-            unsafe {\n-                if let Some(global) = llvm::LLVMIsAGlobalVariable(self.llval) {\n-                    if llvm::LLVMIsGlobalConstant(global) == llvm::True {\n-                        const_llval = llvm::LLVMGetInitializer(global);\n-                    }\n-                }\n-            }\n-            let llval = const_llval.unwrap_or_else(|| {\n-                let load = bx.load(self.llval, self.align);\n-                if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n-                    scalar_load_metadata(load, scalar);\n-                }\n-                load\n-            });\n-            OperandValue::Immediate(base::to_immediate(bx, llval, self.layout))\n-        } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n-            let load = |i, scalar: &layout::Scalar| {\n-                let llptr = bx.struct_gep(self.llval, i as u64);\n-                let load = bx.load(llptr, self.align);\n-                scalar_load_metadata(load, scalar);\n-                if scalar.is_bool() {\n-                    bx.trunc(load, bx.cx().type_i1())\n-                } else {\n-                    load\n-                }\n-            };\n-            OperandValue::Pair(load(0, a), load(1, b))\n-        } else {\n-            OperandValue::Ref(self.llval, None, self.align)\n-        };\n-\n-        OperandRef { val, layout: self.layout }\n-    }\n+}\n \n+impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n     /// Access a field, at a point when the value's case is known.\n-    pub fn project_field(\n-        self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n+    pub fn project_field<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        self, bx: &Bx,\n         ix: usize,\n-    ) -> PlaceRef<'tcx, &'ll Value> {\n+    ) -> PlaceRef<'tcx, Bx::Value> {\n         let cx = bx.cx();\n         let field = self.layout.field(cx, ix);\n         let offset = self.layout.fields.offset(ix);\n@@ -195,7 +133,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n             };\n             PlaceRef {\n                 // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-                llval: bx.pointercast(llval, cx.type_ptr_to(field.llvm_type(cx))),\n+                llval: bx.pointercast(llval, cx.type_ptr_to(cx.backend_type(field))),\n                 llextra: if cx.type_has_metadata(field.ty) {\n                     self.llextra\n                 } else {\n@@ -268,7 +206,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n         let byte_ptr = bx.gep(byte_ptr, &[offset]);\n \n         // Finally, cast back to the type expected\n-        let ll_fty = field.llvm_type(cx);\n+        let ll_fty = cx.backend_type(field);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n \n         PlaceRef {\n@@ -278,6 +216,9 @@ impl PlaceRef<'tcx, &'ll Value> {\n             align: effective_field_align,\n         }\n     }\n+}\n+\n+impl PlaceRef<'tcx, &'ll Value> {\n \n     /// Obtain the actual discriminant of a value.\n     pub fn codegen_get_discr(\n@@ -301,7 +242,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n         }\n \n         let discr = self.project_field(bx, 0);\n-        let lldiscr = discr.load(bx).immediate();\n+        let lldiscr = bx.load_operand(discr).immediate();\n         match self.layout.variants {\n             layout::Variants::Single { .. } => bug!(),\n             layout::Variants::Tagged { ref tag, .. } => {\n@@ -449,7 +390,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     return place;\n                 }\n                 LocalRef::UnsizedPlace(place) => {\n-                    return place.load(bx).deref(&cx);\n+                    return bx.load_operand(place).deref(&cx);\n                 }\n                 LocalRef::Operand(..) => {\n                     bug!(\"using operand local {:?} as place\", place);"}, {"sha": "1285f588ea99a5cb17b3bacd6e0cd21ea03cf42b", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "patch": "@@ -394,15 +394,21 @@ impl DerivedTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n }\n \n impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn backend_type(&self, ty: &TyLayout<'tcx>) -> &'ll Type {\n-        ty.llvm_type(&self)\n+    fn backend_type(&self, layout: TyLayout<'tcx>) -> &'ll Type {\n+        layout.llvm_type(&self)\n+    }\n+    fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> &'ll Type {\n+        layout.immediate_llvm_type(self)\n+    }\n+    fn is_backend_immediate(&self, layout: TyLayout<'tcx>) -> bool {\n+        layout.is_llvm_immediate()\n     }\n     fn scalar_pair_element_backend_type<'a>(\n         &self,\n-        ty: &TyLayout<'tcx>,\n+        layout: TyLayout<'tcx>,\n         index: usize,\n         immediate: bool\n     ) -> &'ll Type {\n-        ty.scalar_pair_element_llvm_type(&self, index, immediate)\n+        layout.scalar_pair_element_llvm_type(self, index, immediate)\n     }\n }"}]}