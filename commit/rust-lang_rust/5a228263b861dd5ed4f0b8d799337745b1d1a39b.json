{"sha": "5a228263b861dd5ed4f0b8d799337745b1d1a39b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMjI4MjYzYjg2MWRkNWVkNGYwYjhkNzk5MzM3NzQ1YjFkMWEzOWI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-12-01T13:11:33Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-12-02T09:42:50Z"}, "message": "Clean up doc attributes check before adding more", "tree": {"sha": "1eff32630cbd546e6aae1c8bece70b0aad167156", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1eff32630cbd546e6aae1c8bece70b0aad167156"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a228263b861dd5ed4f0b8d799337745b1d1a39b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a228263b861dd5ed4f0b8d799337745b1d1a39b", "html_url": "https://github.com/rust-lang/rust/commit/5a228263b861dd5ed4f0b8d799337745b1d1a39b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a228263b861dd5ed4f0b8d799337745b1d1a39b/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92e4fb073245a42559e357a3002c596b8b38edf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/92e4fb073245a42559e357a3002c596b8b38edf6", "html_url": "https://github.com/rust-lang/rust/commit/92e4fb073245a42559e357a3002c596b8b38edf6"}], "stats": {"total": 172, "additions": 93, "deletions": 79}, "files": [{"sha": "54621dae1acfcccb3228bc4b3a84501223336668", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 93, "deletions": 79, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/5a228263b861dd5ed4f0b8d799337745b1d1a39b/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a228263b861dd5ed4f0b8d799337745b1d1a39b/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=5a228263b861dd5ed4f0b8d799337745b1d1a39b", "patch": "@@ -78,7 +78,7 @@ impl CheckAttrVisitor<'tcx> {\n             } else if self.tcx.sess.check_name(attr, sym::track_caller) {\n                 self.check_track_caller(&attr.span, attrs, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::doc) {\n-                self.check_doc_alias(attr, hir_id, target)\n+                self.check_doc_attrs(attr, hir_id, target)\n             } else if self.tcx.sess.check_name(attr, sym::no_link) {\n                 self.check_no_link(&attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::export_name) {\n@@ -297,89 +297,103 @@ impl CheckAttrVisitor<'tcx> {\n             .emit();\n     }\n \n-    fn check_doc_alias(&self, attr: &Attribute, hir_id: HirId, target: Target) -> bool {\n+    fn check_doc_alias(&self, meta: &NestedMetaItem, hir_id: HirId, target: Target) -> bool {\n+        if !meta.is_value_str() {\n+            self.doc_alias_str_error(meta);\n+            return false;\n+        }\n+        let doc_alias = meta.value_str().map(|s| s.to_string()).unwrap_or_else(String::new);\n+        if doc_alias.is_empty() {\n+            self.doc_alias_str_error(meta);\n+            return false;\n+        }\n+        if let Some(c) =\n+            doc_alias.chars().find(|&c| c == '\"' || c == '\\'' || (c.is_whitespace() && c != ' '))\n+        {\n+            self.tcx\n+                .sess\n+                .struct_span_err(\n+                    meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n+                    &format!(\"{:?} character isn't allowed in `#[doc(alias = \\\"...\\\")]`\", c,),\n+                )\n+                .emit();\n+            return false;\n+        }\n+        if doc_alias.starts_with(' ') || doc_alias.ends_with(' ') {\n+            self.tcx\n+                .sess\n+                .struct_span_err(\n+                    meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n+                    \"`#[doc(alias = \\\"...\\\")]` cannot start or end with ' '\",\n+                )\n+                .emit();\n+            return false;\n+        }\n+        if let Some(err) = match target {\n+            Target::Impl => Some(\"implementation block\"),\n+            Target::ForeignMod => Some(\"extern block\"),\n+            Target::AssocTy => {\n+                let parent_hir_id = self.tcx.hir().get_parent_item(hir_id);\n+                let containing_item = self.tcx.hir().expect_item(parent_hir_id);\n+                if Target::from_item(containing_item) == Target::Impl {\n+                    Some(\"type alias in implementation block\")\n+                } else {\n+                    None\n+                }\n+            }\n+            Target::AssocConst => {\n+                let parent_hir_id = self.tcx.hir().get_parent_item(hir_id);\n+                let containing_item = self.tcx.hir().expect_item(parent_hir_id);\n+                // We can't link to trait impl's consts.\n+                let err = \"associated constant in trait implementation block\";\n+                match containing_item.kind {\n+                    ItemKind::Impl { of_trait: Some(_), .. } => Some(err),\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        } {\n+            self.tcx\n+                .sess\n+                .struct_span_err(\n+                    meta.span(),\n+                    &format!(\"`#[doc(alias = \\\"...\\\")]` isn't allowed on {}\", err),\n+                )\n+                .emit();\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn check_attr_crate_level(\n+        &self,\n+        meta: &NestedMetaItem,\n+        hir_id: HirId,\n+        attr_name: &str,\n+    ) -> bool {\n+        if CRATE_HIR_ID == hir_id {\n+            self.tcx\n+                .sess\n+                .struct_span_err(\n+                    meta.span(),\n+                    &format!(\n+                        \"`#![doc({} = \\\"...\\\")]` isn't allowed as a crate level attribute\",\n+                        attr_name,\n+                    ),\n+                )\n+                .emit();\n+            return false;\n+        }\n+    }\n+\n+    fn check_doc_attrs(&self, attr: &Attribute, hir_id: HirId, target: Target) -> bool {\n         if let Some(mi) = attr.meta() {\n             if let Some(list) = mi.meta_item_list() {\n                 for meta in list {\n                     if meta.has_name(sym::alias) {\n-                        if !meta.is_value_str() {\n-                            self.doc_alias_str_error(meta);\n-                            return false;\n-                        }\n-                        let doc_alias =\n-                            meta.value_str().map(|s| s.to_string()).unwrap_or_else(String::new);\n-                        if doc_alias.is_empty() {\n-                            self.doc_alias_str_error(meta);\n-                            return false;\n-                        }\n-                        if let Some(c) = doc_alias\n-                            .chars()\n-                            .find(|&c| c == '\"' || c == '\\'' || (c.is_whitespace() && c != ' '))\n+                        if !self.check_attr_crate_level(meta, hir_id, \"alias\")\n+                            || !self.check_doc_alias(meta, hir_id, target)\n                         {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(\n-                                    meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                                    &format!(\n-                                        \"{:?} character isn't allowed in `#[doc(alias = \\\"...\\\")]`\",\n-                                        c,\n-                                    ),\n-                                )\n-                                .emit();\n-                            return false;\n-                        }\n-                        if doc_alias.starts_with(' ') || doc_alias.ends_with(' ') {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(\n-                                    meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                                    \"`#[doc(alias = \\\"...\\\")]` cannot start or end with ' '\",\n-                                )\n-                                .emit();\n-                            return false;\n-                        }\n-                        if let Some(err) = match target {\n-                            Target::Impl => Some(\"implementation block\"),\n-                            Target::ForeignMod => Some(\"extern block\"),\n-                            Target::AssocTy => {\n-                                let parent_hir_id = self.tcx.hir().get_parent_item(hir_id);\n-                                let containing_item = self.tcx.hir().expect_item(parent_hir_id);\n-                                if Target::from_item(containing_item) == Target::Impl {\n-                                    Some(\"type alias in implementation block\")\n-                                } else {\n-                                    None\n-                                }\n-                            }\n-                            Target::AssocConst => {\n-                                let parent_hir_id = self.tcx.hir().get_parent_item(hir_id);\n-                                let containing_item = self.tcx.hir().expect_item(parent_hir_id);\n-                                // We can't link to trait impl's consts.\n-                                let err = \"associated constant in trait implementation block\";\n-                                match containing_item.kind {\n-                                    ItemKind::Impl { of_trait: Some(_), .. } => Some(err),\n-                                    _ => None,\n-                                }\n-                            }\n-                            _ => None,\n-                        } {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(\n-                                    meta.span(),\n-                                    &format!(\"`#[doc(alias = \\\"...\\\")]` isn't allowed on {}\", err),\n-                                )\n-                                .emit();\n-                            return false;\n-                        }\n-                        if CRATE_HIR_ID == hir_id {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(\n-                                    meta.span(),\n-                                    \"`#![doc(alias = \\\"...\\\")]` isn't allowed as a crate \\\n-                                     level attribute\",\n-                                )\n-                                .emit();\n                             return false;\n                         }\n                     }"}]}