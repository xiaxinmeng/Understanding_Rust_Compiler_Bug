{"sha": "91ab8a3f529e8b6735e0c8a998dc78667cabe40e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYWI4YTNmNTI5ZThiNjczNWUwYzhhOTk4ZGM3ODY2N2NhYmU0MGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-11T23:46:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-11T23:46:00Z"}, "message": "auto merge of #9014 : dcrewi/rust/convert-between-bigints, r=anasazi", "tree": {"sha": "a1267914bbd611d45b873392c8dad6f5d72e4814", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1267914bbd611d45b873392c8dad6f5d72e4814"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91ab8a3f529e8b6735e0c8a998dc78667cabe40e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91ab8a3f529e8b6735e0c8a998dc78667cabe40e", "html_url": "https://github.com/rust-lang/rust/commit/91ab8a3f529e8b6735e0c8a998dc78667cabe40e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91ab8a3f529e8b6735e0c8a998dc78667cabe40e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f0d261ae2d931a8a3e06d784840d85e25166d89", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f0d261ae2d931a8a3e06d784840d85e25166d89", "html_url": "https://github.com/rust-lang/rust/commit/7f0d261ae2d931a8a3e06d784840d85e25166d89"}, {"sha": "9bee3d7e5b1ca7269d008c8df39c3683345bdb3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bee3d7e5b1ca7269d008c8df39c3683345bdb3d", "html_url": "https://github.com/rust-lang/rust/commit/9bee3d7e5b1ca7269d008c8df39c3683345bdb3d"}], "stats": {"total": 172, "additions": 130, "deletions": 42}, "files": [{"sha": "8975ed7fd9617050fa684e573f3d0249a2f054d4", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 130, "deletions": 42, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/91ab8a3f529e8b6735e0c8a998dc78667cabe40e/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ab8a3f529e8b6735e0c8a998dc78667cabe40e/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=91ab8a3f529e8b6735e0c8a998dc78667cabe40e", "patch": "@@ -503,7 +503,7 @@ impl Integer for BigUint {\n impl IntConvertible for BigUint {\n     #[inline]\n     fn to_int(&self) -> int {\n-        num::min(self.to_uint(), int::max_value as uint) as int\n+        self.to_int_opt().expect(\"BigUint conversion would overflow int\")\n     }\n \n     #[inline]\n@@ -615,18 +615,43 @@ impl BigUint {\n     }\n \n \n-    /// Converts this big integer into a uint, returning the uint::max_value if\n-    /// it's too large to fit in a uint.\n+    /// Converts this BigUint into a uint, failing if the conversion\n+    /// would overflow.\n     #[inline]\n     pub fn to_uint(&self) -> uint {\n+        self.to_uint_opt().expect(\"BigUint conversion would overflow uint\")\n+    }\n+\n+    /// Converts this BigUint into a uint, unless it would overflow.\n+    #[inline]\n+    pub fn to_uint_opt(&self) -> Option<uint> {\n         match self.data.len() {\n-            0 => 0,\n-            1 => self.data[0] as uint,\n-            2 => BigDigit::to_uint(self.data[1], self.data[0]),\n-            _ => uint::max_value\n+            0 => Some(0),\n+            1 => Some(self.data[0] as uint),\n+            2 => Some(BigDigit::to_uint(self.data[1], self.data[0])),\n+            _ => None\n         }\n     }\n \n+    // Converts this BigUint into an int, unless it would overflow.\n+    pub fn to_int_opt(&self) -> Option<int> {\n+        self.to_uint_opt().chain(|n| {\n+            // If top bit of uint is set, it's too large to convert to\n+            // int.\n+            if (n >> (2*BigDigit::bits - 1) != 0) {\n+                None\n+            } else {\n+                Some(n as int)\n+            }\n+        })\n+    }\n+\n+    /// Converts this BigUint into a BigInt.\n+    #[inline]\n+    pub fn to_bigint(&self) -> BigInt {\n+        BigInt::from_biguint(Plus, self.clone())\n+    }\n+\n     #[inline]\n     fn shl_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return (*self).clone(); }\n@@ -1048,12 +1073,7 @@ impl Integer for BigInt {\n impl IntConvertible for BigInt {\n     #[inline]\n     fn to_int(&self) -> int {\n-        match self.sign {\n-            Plus  => num::min(self.to_uint(), int::max_value as uint) as int,\n-            Zero  => 0,\n-            Minus => num::min((-self).to_uint(),\n-                               (int::max_value as uint) + 1) as int\n-        }\n+        self.to_int_opt().expect(\"BigInt conversion would overflow int\")\n     }\n \n     #[inline]\n@@ -1179,12 +1199,55 @@ impl BigInt {\n             .map_move(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n+    /// Converts this BigInt into a uint, failing if the conversion\n+    /// would overflow.\n     #[inline]\n     pub fn to_uint(&self) -> uint {\n+        self.to_uint_opt().expect(\"BigInt conversion would overflow uint\")\n+    }\n+\n+    /// Converts this BigInt into a uint, unless it would overflow.\n+    #[inline]\n+    pub fn to_uint_opt(&self) -> Option<uint> {\n+        match self.sign {\n+            Plus => self.data.to_uint_opt(),\n+            Zero => Some(0),\n+            Minus => None\n+        }\n+    }\n+\n+    /// Converts this BigInt into an int, unless it would overflow.\n+    pub fn to_int_opt(&self) -> Option<int> {\n+        match self.sign {\n+            Plus  => self.data.to_int_opt(),\n+            Zero  => Some(0),\n+            Minus => self.data.to_uint_opt().chain(|n| {\n+                let m: uint = 1 << (2*BigDigit::bits-1);\n+                if (n > m) {\n+                    None\n+                } else if (n == m) {\n+                    Some(int::min_value)\n+                } else {\n+                    Some(-(n as int))\n+                }\n+            })\n+        }\n+    }\n+\n+    /// Converts this BigInt into a BigUint, failing if BigInt is\n+    /// negative.\n+    #[inline]\n+    pub fn to_biguint(&self) -> BigUint {\n+        self.to_biguint_opt().expect(\"negative BigInt cannot convert to BigUint\")\n+    }\n+\n+    /// Converts this BigInt into a BigUint, if it's not negative.\n+    #[inline]\n+    pub fn to_biguint_opt(&self) -> Option<BigUint> {\n         match self.sign {\n-            Plus  => self.data.to_uint(),\n-            Zero  => 0,\n-            Minus => 0\n+            Plus => Some(self.data.clone()),\n+            Zero => Some(Zero::zero()),\n+            Minus => None\n         }\n     }\n }\n@@ -1385,9 +1448,9 @@ mod biguint_tests {\n         check(~[ 0,  1], ((uint::max_value >> BigDigit::bits) + 1) as int);\n         check(~[-1, -1 >> 1], int::max_value);\n \n-        assert_eq!(BigUint::new(~[0, -1]).to_int(), int::max_value);\n-        assert_eq!(BigUint::new(~[0, 0, 1]).to_int(), int::max_value);\n-        assert_eq!(BigUint::new(~[0, 0, -1]).to_int(), int::max_value);\n+        assert_eq!(BigUint::new(~[0, -1]).to_int_opt(), None);\n+        assert_eq!(BigUint::new(~[0, 0, 1]).to_int_opt(), None);\n+        assert_eq!(BigUint::new(~[0, 0, -1]).to_int_opt(), None);\n     }\n \n     #[test]\n@@ -1405,8 +1468,19 @@ mod biguint_tests {\n         check(~[ 0, -1], uint::max_value << BigDigit::bits);\n         check(~[-1, -1], uint::max_value);\n \n-        assert_eq!(BigUint::new(~[0, 0, 1]).to_uint(), uint::max_value);\n-        assert_eq!(BigUint::new(~[0, 0, -1]).to_uint(), uint::max_value);\n+        assert_eq!(BigUint::new(~[0, 0, 1]).to_uint_opt(), None);\n+        assert_eq!(BigUint::new(~[0, 0, -1]).to_uint_opt(), None);\n+    }\n+\n+    #[test]\n+    fn test_convert_to_bigint() {\n+        fn check(n: BigUint, ans: BigInt) {\n+            assert_eq!(n.to_bigint(), ans);\n+            assert_eq!(n.to_bigint().to_biguint(), n);\n+        }\n+        check(Zero::zero(), Zero::zero());\n+        check(BigUint::new(~[1,2,3]),\n+              BigInt::from_biguint(Plus, BigUint::new(~[1,2,3])));\n     }\n \n     static sum_triples: &'static [(&'static [BigDigit],\n@@ -1793,22 +1867,21 @@ mod bigint_tests {\n             Plus, BigUint::from_uint(int::max_value as uint)\n         ), int::max_value);\n \n-        assert!(BigInt::from_biguint(\n+        assert_eq!(BigInt::from_biguint(\n             Plus, BigUint::from_uint(int::max_value as uint + 1)\n-        ).to_int() == int::max_value);\n-        assert!(BigInt::from_biguint(\n+        ).to_int_opt(), None);\n+        assert_eq!(BigInt::from_biguint(\n             Plus, BigUint::new(~[1, 2, 3])\n-        ).to_int() == int::max_value);\n+        ).to_int_opt(), None);\n \n         check(BigInt::from_biguint(\n-            Minus, BigUint::from_uint(-int::min_value as uint)\n+            Minus, BigUint::new(~[0, 1<<(BigDigit::bits-1)])\n         ), int::min_value);\n-        assert!(BigInt::from_biguint(\n-            Minus, BigUint::from_uint(-int::min_value as uint + 1)\n-        ).to_int() == int::min_value);\n-        assert!(BigInt::from_biguint(\n-            Minus, BigUint::new(~[1, 2, 3])\n-        ).to_int() == int::min_value);\n+        assert_eq!(BigInt::from_biguint(\n+            Minus, BigUint::new(~[1, 1<<(BigDigit::bits-1)])\n+        ).to_int_opt(), None);\n+        assert_eq!(BigInt::from_biguint(\n+            Minus, BigUint::new(~[1, 2, 3])).to_int_opt(), None);\n     }\n \n     #[test]\n@@ -1824,16 +1897,31 @@ mod bigint_tests {\n         check(\n             BigInt::from_biguint(Plus, BigUint::from_uint(uint::max_value)),\n             uint::max_value);\n-        assert!(BigInt::from_biguint(\n-            Plus, BigUint::new(~[1, 2, 3])\n-        ).to_uint() == uint::max_value);\n-\n-        assert!(BigInt::from_biguint(\n-            Minus, BigUint::from_uint(uint::max_value)\n-        ).to_uint() == 0);\n-        assert!(BigInt::from_biguint(\n-            Minus, BigUint::new(~[1, 2, 3])\n-        ).to_uint() == 0);\n+        assert_eq!(BigInt::from_biguint(\n+            Plus, BigUint::new(~[1, 2, 3])).to_uint_opt(), None);\n+\n+        assert_eq!(BigInt::from_biguint(\n+            Minus, BigUint::from_uint(uint::max_value)).to_uint_opt(), None);\n+        assert_eq!(BigInt::from_biguint(\n+            Minus, BigUint::new(~[1, 2, 3])).to_uint_opt(), None);\n+    }\n+\n+    #[test]\n+    fn test_convert_to_biguint() {\n+        fn check(n: BigInt, ans_1: BigUint) {\n+            assert_eq!(n.to_biguint(), ans_1);\n+            assert_eq!(n.to_biguint().to_bigint(), n);\n+        }\n+        let zero: BigInt = Zero::zero();\n+        let unsigned_zero: BigUint = Zero::zero();\n+        let positive = BigInt::from_biguint(\n+            Plus, BigUint::new(~[1,2,3]));\n+        let negative = -positive;\n+\n+        check(zero, unsigned_zero);\n+        check(positive, BigUint::new(~[1,2,3]));\n+\n+        assert_eq!(negative.to_biguint_opt(), None);\n     }\n \n     static sum_triples: &'static [(&'static [BigDigit],"}]}