{"sha": "7889f961032fea47629f4dbdd40d92cea8dcc8de", "node_id": "C_kwDOAAsO6NoAKDc4ODlmOTYxMDMyZmVhNDc2MjlmNGRiZGQ0MGQ5MmNlYThkY2M4ZGU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-18T21:00:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-18T21:00:45Z"}, "message": "Rollup merge of #92425 - calebzulawski:simd-cast, r=workingjubilee\n\nImprove SIMD casts\n\n* Allows `simd_cast` intrinsic to take `usize` and `isize`\n* Adds `simd_as` intrinsic, which is the same as `simd_cast` except for saturating float-to-int conversions (matching the behavior of `as`).\n\ncc `@workingjubilee`", "tree": {"sha": "cc442cd6e4506f9af9f57a7359e36f1220190240", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc442cd6e4506f9af9f57a7359e36f1220190240"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7889f961032fea47629f4dbdd40d92cea8dcc8de", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh5yp+CRBK7hj4Ov3rIwAAE0oIAEbsVwKGNOhO6GncOrwupKGx\nvaN3MpSvOjvJf3JFHZs73wxMhndzhYo1BpJGe6Qj96S296HNOVB3cgceuR3fy11b\nC3XCvrSi4OfQzwe9Aj25gSrHJzyFYXfujjkWgxVhU3fxeW6P88PNbpOGE4JMQzit\nWYw3XgfKGMHnl1D9WOwm4uJc0rR2fwVkkB1rNBd1/05wZ9Y8snlpkOQwIkPneuCn\n3ot9VdrdDLQZI5EvNwo+CjV09Mi0qSAxawQ6QpKssj5BEhCwzyPsZO++JEDa2dqQ\nubu4lwzqPIFBCwWtKdOELCwBDbGfpPmt5gTOds2Erf8o2LCyVrV8M8VLp4Zk4YM=\n=GYNO\n-----END PGP SIGNATURE-----\n", "payload": "tree cc442cd6e4506f9af9f57a7359e36f1220190240\nparent f372476d2cd19fbd4baff24e767f5ee3d8264b49\nparent 49d36d733dc3906120cc0ecb268b839fb05e170d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642539645 +0100\ncommitter GitHub <noreply@github.com> 1642539645 +0100\n\nRollup merge of #92425 - calebzulawski:simd-cast, r=workingjubilee\n\nImprove SIMD casts\n\n* Allows `simd_cast` intrinsic to take `usize` and `isize`\n* Adds `simd_as` intrinsic, which is the same as `simd_cast` except for saturating float-to-int conversions (matching the behavior of `as`).\n\ncc `@workingjubilee`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7889f961032fea47629f4dbdd40d92cea8dcc8de", "html_url": "https://github.com/rust-lang/rust/commit/7889f961032fea47629f4dbdd40d92cea8dcc8de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7889f961032fea47629f4dbdd40d92cea8dcc8de/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f372476d2cd19fbd4baff24e767f5ee3d8264b49", "url": "https://api.github.com/repos/rust-lang/rust/commits/f372476d2cd19fbd4baff24e767f5ee3d8264b49", "html_url": "https://github.com/rust-lang/rust/commit/f372476d2cd19fbd4baff24e767f5ee3d8264b49"}, {"sha": "49d36d733dc3906120cc0ecb268b839fb05e170d", "url": "https://api.github.com/repos/rust-lang/rust/commits/49d36d733dc3906120cc0ecb268b839fb05e170d", "html_url": "https://github.com/rust-lang/rust/commit/49d36d733dc3906120cc0ecb268b839fb05e170d"}], "stats": {"total": 491, "additions": 314, "deletions": 177}, "files": [{"sha": "8a9450c20dda4c1727bfa1af201ff190d11344b6", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=7889f961032fea47629f4dbdd40d92cea8dcc8de", "patch": "@@ -731,27 +731,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n-        if !self.fptoint_sat_broken_in_llvm() {\n-            let src_ty = self.cx.val_ty(val);\n-            let float_width = self.cx.float_width(src_ty);\n-            let int_width = self.cx.int_width(dest_ty);\n-            let name = format!(\"llvm.fptoui.sat.i{}.f{}\", int_width, float_width);\n-            return Some(self.call_intrinsic(&name, &[val]));\n-        }\n-\n-        None\n+        self.fptoint_sat(false, val, dest_ty)\n     }\n \n     fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n-        if !self.fptoint_sat_broken_in_llvm() {\n-            let src_ty = self.cx.val_ty(val);\n-            let float_width = self.cx.float_width(src_ty);\n-            let int_width = self.cx.int_width(dest_ty);\n-            let name = format!(\"llvm.fptosi.sat.i{}.f{}\", int_width, float_width);\n-            return Some(self.call_intrinsic(&name, &[val]));\n-        }\n-\n-        None\n+        self.fptoint_sat(true, val, dest_ty)\n     }\n \n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n@@ -1455,4 +1439,43 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n             _ => false,\n         }\n     }\n+\n+    fn fptoint_sat(\n+        &mut self,\n+        signed: bool,\n+        val: &'ll Value,\n+        dest_ty: &'ll Type,\n+    ) -> Option<&'ll Value> {\n+        if !self.fptoint_sat_broken_in_llvm() {\n+            let src_ty = self.cx.val_ty(val);\n+            let (float_ty, int_ty, vector_length) = if self.cx.type_kind(src_ty) == TypeKind::Vector\n+            {\n+                assert_eq!(self.cx.vector_length(src_ty), self.cx.vector_length(dest_ty));\n+                (\n+                    self.cx.element_type(src_ty),\n+                    self.cx.element_type(dest_ty),\n+                    Some(self.cx.vector_length(src_ty)),\n+                )\n+            } else {\n+                (src_ty, dest_ty, None)\n+            };\n+            let float_width = self.cx.float_width(float_ty);\n+            let int_width = self.cx.int_width(int_ty);\n+\n+            let instr = if signed { \"fptosi\" } else { \"fptoui\" };\n+            let name = if let Some(vector_length) = vector_length {\n+                format!(\n+                    \"llvm.{}.sat.v{}i{}.v{}f{}\",\n+                    instr, vector_length, int_width, vector_length, float_width\n+                )\n+            } else {\n+                format!(\"llvm.{}.sat.i{}.f{}\", instr, int_width, float_width)\n+            };\n+            let f =\n+                self.declare_cfn(&name, llvm::UnnamedAddr::No, self.type_func(&[src_ty], dest_ty));\n+            Some(self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None))\n+        } else {\n+            None\n+        }\n+    }\n }"}, {"sha": "5adfa18035a0e2efbd53c159723c9fb52327a39d", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=7889f961032fea47629f4dbdd40d92cea8dcc8de", "patch": "@@ -1688,7 +1688,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     bitwise_red!(simd_reduce_all: vector_reduce_and, true);\n     bitwise_red!(simd_reduce_any: vector_reduce_or, true);\n \n-    if name == sym::simd_cast {\n+    if name == sym::simd_cast || name == sym::simd_as {\n         require_simd!(ret_ty, \"return\");\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n@@ -1714,14 +1714,26 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         let (in_style, in_width) = match in_elem.kind() {\n             // vectors of pointer-sized integers should've been\n             // disallowed before here, so this unwrap is safe.\n-            ty::Int(i) => (Style::Int(true), i.bit_width().unwrap()),\n-            ty::Uint(u) => (Style::Int(false), u.bit_width().unwrap()),\n+            ty::Int(i) => (\n+                Style::Int(true),\n+                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n+            ty::Uint(u) => (\n+                Style::Int(false),\n+                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n             ty::Float(f) => (Style::Float, f.bit_width()),\n             _ => (Style::Unsupported, 0),\n         };\n         let (out_style, out_width) = match out_elem.kind() {\n-            ty::Int(i) => (Style::Int(true), i.bit_width().unwrap()),\n-            ty::Uint(u) => (Style::Int(false), u.bit_width().unwrap()),\n+            ty::Int(i) => (\n+                Style::Int(true),\n+                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n+            ty::Uint(u) => (\n+                Style::Int(false),\n+                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n             ty::Float(f) => (Style::Float, f.bit_width()),\n             _ => (Style::Unsupported, 0),\n         };\n@@ -1748,10 +1760,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                 });\n             }\n             (Style::Float, Style::Int(out_is_signed)) => {\n-                return Ok(if out_is_signed {\n-                    bx.fptosi(args[0].immediate(), llret_ty)\n-                } else {\n-                    bx.fptoui(args[0].immediate(), llret_ty)\n+                return Ok(match (out_is_signed, name == sym::simd_as) {\n+                    (false, false) => bx.fptoui(args[0].immediate(), llret_ty),\n+                    (true, false) => bx.fptosi(args[0].immediate(), llret_ty),\n+                    (_, true) => bx.cast_float_to_int(out_is_signed, args[0].immediate(), llret_ty),\n                 });\n             }\n             (Style::Float, Style::Float) => {"}, {"sha": "68decce82ab52a44bdd6aa83235e4ce040c54ced", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 147, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=7889f961032fea47629f4dbdd40d92cea8dcc8de", "patch": "@@ -3,11 +3,10 @@ use super::place::PlaceRef;\n use super::{FunctionCx, LocalRef};\n \n use crate::base;\n-use crate::common::{self, IntPredicate, RealPredicate};\n+use crate::common::{self, IntPredicate};\n use crate::traits::*;\n use crate::MemFlags;\n \n-use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_middle::mir;\n use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n@@ -368,10 +367,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 bx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                cast_float_to_int(&mut bx, true, llval, ll_t_in, ll_t_out)\n+                                bx.cast_float_to_int(true, llval, ll_t_out)\n                             }\n                             (CastTy::Float, CastTy::Int(_)) => {\n-                                cast_float_to_int(&mut bx, false, llval, ll_t_in, ll_t_out)\n+                                bx.cast_float_to_int(false, llval, ll_t_out)\n                             }\n                             _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.layout.ty, cast.ty),\n                         };\n@@ -768,146 +767,3 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // (*) this is only true if the type is suitable\n     }\n }\n-\n-fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &mut Bx,\n-    signed: bool,\n-    x: Bx::Value,\n-    float_ty: Bx::Type,\n-    int_ty: Bx::Type,\n-) -> Bx::Value {\n-    if let Some(false) = bx.cx().sess().opts.debugging_opts.saturating_float_casts {\n-        return if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n-    }\n-\n-    let try_sat_result = if signed { bx.fptosi_sat(x, int_ty) } else { bx.fptoui_sat(x, int_ty) };\n-    if let Some(try_sat_result) = try_sat_result {\n-        return try_sat_result;\n-    }\n-\n-    let int_width = bx.cx().int_width(int_ty);\n-    let float_width = bx.cx().float_width(float_ty);\n-    // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n-    // destination integer type after rounding towards zero. This `undef` value can cause UB in\n-    // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n-    // Semantically, the mathematical value of the input is rounded towards zero to the next\n-    // mathematical integer, and then the result is clamped into the range of the destination\n-    // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n-    // the destination integer type. NaN is mapped to 0.\n-    //\n-    // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n-    // a value representable in int_ty.\n-    // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n-    // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n-    // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n-    // representable. Note that this only works if float_ty's exponent range is sufficiently large.\n-    // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n-    // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n-    // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n-    // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n-    // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n-    let int_max = |signed: bool, int_width: u64| -> u128 {\n-        let shift_amount = 128 - int_width;\n-        if signed { i128::MAX as u128 >> shift_amount } else { u128::MAX >> shift_amount }\n-    };\n-    let int_min = |signed: bool, int_width: u64| -> i128 {\n-        if signed { i128::MIN >> (128 - int_width) } else { 0 }\n-    };\n-\n-    let compute_clamp_bounds_single = |signed: bool, int_width: u64| -> (u128, u128) {\n-        let rounded_min = ieee::Single::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n-        assert_eq!(rounded_min.status, Status::OK);\n-        let rounded_max = ieee::Single::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n-        assert!(rounded_max.value.is_finite());\n-        (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n-    };\n-    let compute_clamp_bounds_double = |signed: bool, int_width: u64| -> (u128, u128) {\n-        let rounded_min = ieee::Double::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n-        assert_eq!(rounded_min.status, Status::OK);\n-        let rounded_max = ieee::Double::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n-        assert!(rounded_max.value.is_finite());\n-        (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n-    };\n-\n-    let mut float_bits_to_llval = |bits| {\n-        let bits_llval = match float_width {\n-            32 => bx.cx().const_u32(bits as u32),\n-            64 => bx.cx().const_u64(bits as u64),\n-            n => bug!(\"unsupported float width {}\", n),\n-        };\n-        bx.bitcast(bits_llval, float_ty)\n-    };\n-    let (f_min, f_max) = match float_width {\n-        32 => compute_clamp_bounds_single(signed, int_width),\n-        64 => compute_clamp_bounds_double(signed, int_width),\n-        n => bug!(\"unsupported float width {}\", n),\n-    };\n-    let f_min = float_bits_to_llval(f_min);\n-    let f_max = float_bits_to_llval(f_max);\n-    // To implement saturation, we perform the following steps:\n-    //\n-    // 1. Cast x to an integer with fpto[su]i. This may result in undef.\n-    // 2. Compare x to f_min and f_max, and use the comparison results to select:\n-    //  a) int_ty::MIN if x < f_min or x is NaN\n-    //  b) int_ty::MAX if x > f_max\n-    //  c) the result of fpto[su]i otherwise\n-    // 3. If x is NaN, return 0.0, otherwise return the result of step 2.\n-    //\n-    // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n-    // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n-    // undef does not introduce any non-determinism either.\n-    // More importantly, the above procedure correctly implements saturating conversion.\n-    // Proof (sketch):\n-    // If x is NaN, 0 is returned by definition.\n-    // Otherwise, x is finite or infinite and thus can be compared with f_min and f_max.\n-    // This yields three cases to consider:\n-    // (1) if x in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n-    //     saturating conversion for inputs in that range.\n-    // (2) if x > f_max, then x is larger than int_ty::MAX. This holds even if f_max is rounded\n-    //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n-    //     than int_ty::MAX. Because x is larger than int_ty::MAX, the return value of int_ty::MAX\n-    //     is correct.\n-    // (3) if x < f_min, then x is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n-    //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n-    // QED.\n-\n-    let int_max = bx.cx().const_uint_big(int_ty, int_max(signed, int_width));\n-    let int_min = bx.cx().const_uint_big(int_ty, int_min(signed, int_width) as u128);\n-    let zero = bx.cx().const_uint(int_ty, 0);\n-\n-    // Step 1 ...\n-    let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n-    let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n-    let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n-\n-    // Step 2: We use two comparisons and two selects, with %s1 being the\n-    // result:\n-    //     %less_or_nan = fcmp ult %x, %f_min\n-    //     %greater = fcmp olt %x, %f_max\n-    //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n-    //     %s1 = select %greater, int_ty::MAX, %s0\n-    // Note that %less_or_nan uses an *unordered* comparison. This\n-    // comparison is true if the operands are not comparable (i.e., if x is\n-    // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n-    // x is NaN.\n-    //\n-    // Performance note: Unordered comparison can be lowered to a \"flipped\"\n-    // comparison and a negation, and the negation can be merged into the\n-    // select. Therefore, it not necessarily any more expensive than an\n-    // ordered (\"normal\") comparison. Whether these optimizations will be\n-    // performed is ultimately up to the backend, but at least x86 does\n-    // perform them.\n-    let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n-    let s1 = bx.select(greater, int_max, s0);\n-\n-    // Step 3: NaN replacement.\n-    // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n-    // Therefore we only need to execute this step for signed integer types.\n-    if signed {\n-        // LLVM has no isNaN predicate, so we use (x == x) instead\n-        let cmp = bx.fcmp(RealPredicate::RealOEQ, x, x);\n-        bx.select(cmp, s1, zero)\n-    } else {\n-        s1\n-    }\n-}"}, {"sha": "5a06fb4610587963b923e46be227a4e85fc61499", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 178, "deletions": 2, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=7889f961032fea47629f4dbdd40d92cea8dcc8de", "patch": "@@ -1,18 +1,21 @@\n use super::abi::AbiBuilderMethods;\n use super::asm::AsmBuilderMethods;\n+use super::consts::ConstMethods;\n use super::coverageinfo::CoverageInfoBuilderMethods;\n use super::debuginfo::DebugInfoBuilderMethods;\n use super::intrinsic::IntrinsicCallMethods;\n-use super::type_::ArgAbiMethods;\n+use super::misc::MiscMethods;\n+use super::type_::{ArgAbiMethods, BaseTypeMethods};\n use super::{HasCodegen, StaticBuilderMethods};\n \n use crate::common::{\n-    AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope,\n+    AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope, TypeKind,\n };\n use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n \n+use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_middle::ty::layout::{HasParamEnv, TyAndLayout};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n@@ -202,6 +205,179 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn intcast(&mut self, val: Self::Value, dest_ty: Self::Type, is_signed: bool) -> Self::Value;\n     fn pointercast(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n \n+    fn cast_float_to_int(\n+        &mut self,\n+        signed: bool,\n+        x: Self::Value,\n+        dest_ty: Self::Type,\n+    ) -> Self::Value {\n+        let in_ty = self.cx().val_ty(x);\n+        let (float_ty, int_ty) = if self.cx().type_kind(dest_ty) == TypeKind::Vector\n+            && self.cx().type_kind(in_ty) == TypeKind::Vector\n+        {\n+            (self.cx().element_type(in_ty), self.cx().element_type(dest_ty))\n+        } else {\n+            (in_ty, dest_ty)\n+        };\n+        assert!(matches!(self.cx().type_kind(float_ty), TypeKind::Float | TypeKind::Double));\n+        assert_eq!(self.cx().type_kind(int_ty), TypeKind::Integer);\n+\n+        if let Some(false) = self.cx().sess().opts.debugging_opts.saturating_float_casts {\n+            return if signed { self.fptosi(x, dest_ty) } else { self.fptoui(x, dest_ty) };\n+        }\n+\n+        let try_sat_result =\n+            if signed { self.fptosi_sat(x, dest_ty) } else { self.fptoui_sat(x, dest_ty) };\n+        if let Some(try_sat_result) = try_sat_result {\n+            return try_sat_result;\n+        }\n+\n+        let int_width = self.cx().int_width(int_ty);\n+        let float_width = self.cx().float_width(float_ty);\n+        // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n+        // destination integer type after rounding towards zero. This `undef` value can cause UB in\n+        // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n+        // Semantically, the mathematical value of the input is rounded towards zero to the next\n+        // mathematical integer, and then the result is clamped into the range of the destination\n+        // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n+        // the destination integer type. NaN is mapped to 0.\n+        //\n+        // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n+        // a value representable in int_ty.\n+        // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n+        // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n+        // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n+        // representable. Note that this only works if float_ty's exponent range is sufficiently large.\n+        // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n+        // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n+        // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n+        // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n+        // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n+        let int_max = |signed: bool, int_width: u64| -> u128 {\n+            let shift_amount = 128 - int_width;\n+            if signed { i128::MAX as u128 >> shift_amount } else { u128::MAX >> shift_amount }\n+        };\n+        let int_min = |signed: bool, int_width: u64| -> i128 {\n+            if signed { i128::MIN >> (128 - int_width) } else { 0 }\n+        };\n+\n+        let compute_clamp_bounds_single = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Single::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Single::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        let compute_clamp_bounds_double = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Double::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Double::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        // To implement saturation, we perform the following steps:\n+        //\n+        // 1. Cast x to an integer with fpto[su]i. This may result in undef.\n+        // 2. Compare x to f_min and f_max, and use the comparison results to select:\n+        //  a) int_ty::MIN if x < f_min or x is NaN\n+        //  b) int_ty::MAX if x > f_max\n+        //  c) the result of fpto[su]i otherwise\n+        // 3. If x is NaN, return 0.0, otherwise return the result of step 2.\n+        //\n+        // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n+        // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n+        // undef does not introduce any non-determinism either.\n+        // More importantly, the above procedure correctly implements saturating conversion.\n+        // Proof (sketch):\n+        // If x is NaN, 0 is returned by definition.\n+        // Otherwise, x is finite or infinite and thus can be compared with f_min and f_max.\n+        // This yields three cases to consider:\n+        // (1) if x in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n+        //     saturating conversion for inputs in that range.\n+        // (2) if x > f_max, then x is larger than int_ty::MAX. This holds even if f_max is rounded\n+        //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n+        //     than int_ty::MAX. Because x is larger than int_ty::MAX, the return value of int_ty::MAX\n+        //     is correct.\n+        // (3) if x < f_min, then x is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n+        //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n+        // QED.\n+\n+        let float_bits_to_llval = |bx: &mut Self, bits| {\n+            let bits_llval = match float_width {\n+                32 => bx.cx().const_u32(bits as u32),\n+                64 => bx.cx().const_u64(bits as u64),\n+                n => bug!(\"unsupported float width {}\", n),\n+            };\n+            bx.bitcast(bits_llval, float_ty)\n+        };\n+        let (f_min, f_max) = match float_width {\n+            32 => compute_clamp_bounds_single(signed, int_width),\n+            64 => compute_clamp_bounds_double(signed, int_width),\n+            n => bug!(\"unsupported float width {}\", n),\n+        };\n+        let f_min = float_bits_to_llval(self, f_min);\n+        let f_max = float_bits_to_llval(self, f_max);\n+        let int_max = self.cx().const_uint_big(int_ty, int_max(signed, int_width));\n+        let int_min = self.cx().const_uint_big(int_ty, int_min(signed, int_width) as u128);\n+        let zero = self.cx().const_uint(int_ty, 0);\n+\n+        // If we're working with vectors, constants must be \"splatted\": the constant is duplicated\n+        // into each lane of the vector.  The algorithm stays the same, we are just using the\n+        // same constant across all lanes.\n+        let maybe_splat = |bx: &mut Self, val| {\n+            if bx.cx().type_kind(dest_ty) == TypeKind::Vector {\n+                bx.vector_splat(bx.vector_length(dest_ty), val)\n+            } else {\n+                val\n+            }\n+        };\n+        let f_min = maybe_splat(self, f_min);\n+        let f_max = maybe_splat(self, f_max);\n+        let int_max = maybe_splat(self, int_max);\n+        let int_min = maybe_splat(self, int_min);\n+        let zero = maybe_splat(self, zero);\n+\n+        // Step 1 ...\n+        let fptosui_result = if signed { self.fptosi(x, dest_ty) } else { self.fptoui(x, dest_ty) };\n+        let less_or_nan = self.fcmp(RealPredicate::RealULT, x, f_min);\n+        let greater = self.fcmp(RealPredicate::RealOGT, x, f_max);\n+\n+        // Step 2: We use two comparisons and two selects, with %s1 being the\n+        // result:\n+        //     %less_or_nan = fcmp ult %x, %f_min\n+        //     %greater = fcmp olt %x, %f_max\n+        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n+        //     %s1 = select %greater, int_ty::MAX, %s0\n+        // Note that %less_or_nan uses an *unordered* comparison. This\n+        // comparison is true if the operands are not comparable (i.e., if x is\n+        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n+        // x is NaN.\n+        //\n+        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n+        // comparison and a negation, and the negation can be merged into the\n+        // select. Therefore, it not necessarily any more expensive than an\n+        // ordered (\"normal\") comparison. Whether these optimizations will be\n+        // performed is ultimately up to the backend, but at least x86 does\n+        // perform them.\n+        let s0 = self.select(less_or_nan, int_min, fptosui_result);\n+        let s1 = self.select(greater, int_max, s0);\n+\n+        // Step 3: NaN replacement.\n+        // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n+        // Therefore we only need to execute this step for signed integer types.\n+        if signed {\n+            // LLVM has no isNaN predicate, so we use (x == x) instead\n+            let cmp = self.fcmp(RealPredicate::RealOEQ, x, x);\n+            self.select(cmp, s1, zero)\n+        } else {\n+            s1\n+        }\n+    }\n+\n     fn icmp(&mut self, op: IntPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n     fn fcmp(&mut self, op: RealPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n "}, {"sha": "702e35946607954b772a17f30cc3e98f2a7498e9", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=7889f961032fea47629f4dbdd40d92cea8dcc8de", "patch": "@@ -1223,6 +1223,7 @@ symbols! {\n         simd,\n         simd_add,\n         simd_and,\n+        simd_as,\n         simd_bitmask,\n         simd_cast,\n         simd_ceil,"}, {"sha": "4c612ed5be51a06db1c12823db92c6ddf8850a61", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7889f961032fea47629f4dbdd40d92cea8dcc8de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=7889f961032fea47629f4dbdd40d92cea8dcc8de", "patch": "@@ -453,7 +453,7 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n         sym::simd_scatter => (3, vec![param(0), param(1), param(2)], tcx.mk_unit()),\n         sym::simd_insert => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n         sym::simd_extract => (2, vec![param(0), tcx.types.u32], param(1)),\n-        sym::simd_cast => (2, vec![param(0)], param(1)),\n+        sym::simd_cast | sym::simd_as => (2, vec![param(0)], param(1)),\n         sym::simd_bitmask => (2, vec![param(0)], param(1)),\n         sym::simd_select | sym::simd_select_bitmask => {\n             (2, vec![param(0), param(1), param(1)], param(1))"}, {"sha": "a975190a2fafd43ae5d55f600c3285ef0eee55b6", "filename": "src/test/ui/simd/intrinsic/generic-as.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7889f961032fea47629f4dbdd40d92cea8dcc8de/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7889f961032fea47629f4dbdd40d92cea8dcc8de/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-as.rs?ref=7889f961032fea47629f4dbdd40d92cea8dcc8de", "patch": "@@ -0,0 +1,48 @@\n+// run-pass\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_as<T, U>(x: T) -> U;\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(simd)]\n+struct V<T>([T; 2]);\n+\n+fn main() {\n+    unsafe {\n+        let u = V::<u32>([u32::MIN, u32::MAX]);\n+        let i: V<i16> = simd_as(u);\n+        assert_eq!(i.0[0], u.0[0] as i16);\n+        assert_eq!(i.0[1], u.0[1] as i16);\n+    }\n+\n+    unsafe {\n+        let f = V::<f32>([f32::MIN, f32::MAX]);\n+        let i: V<i16> = simd_as(f);\n+        assert_eq!(i.0[0], f.0[0] as i16);\n+        assert_eq!(i.0[1], f.0[1] as i16);\n+    }\n+\n+    unsafe {\n+        let f = V::<f32>([f32::MIN, f32::MAX]);\n+        let u: V<u8> = simd_as(f);\n+        assert_eq!(u.0[0], f.0[0] as u8);\n+        assert_eq!(u.0[1], f.0[1] as u8);\n+    }\n+\n+    unsafe {\n+        let f = V::<f64>([f64::MIN, f64::MAX]);\n+        let i: V<isize> = simd_as(f);\n+        assert_eq!(i.0[0], f.0[0] as isize);\n+        assert_eq!(i.0[1], f.0[1] as isize);\n+    }\n+\n+    unsafe {\n+        let f = V::<f64>([f64::MIN, f64::MAX]);\n+        let u: V<usize> = simd_as(f);\n+        assert_eq!(u.0[0], f.0[0] as usize);\n+        assert_eq!(u.0[1], f.0[1] as usize);\n+    }\n+}"}, {"sha": "b9382310deb2c99d1e9a0b7057d60c83a3d9ef19", "filename": "src/test/ui/simd/intrinsic/generic-cast-pointer-width.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7889f961032fea47629f4dbdd40d92cea8dcc8de/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-cast-pointer-width.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7889f961032fea47629f4dbdd40d92cea8dcc8de/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-cast-pointer-width.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-cast-pointer-width.rs?ref=7889f961032fea47629f4dbdd40d92cea8dcc8de", "patch": "@@ -0,0 +1,21 @@\n+// run-pass\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_cast<T, U>(x: T) -> U;\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(simd)]\n+struct V<T>([T; 4]);\n+\n+fn main() {\n+    let u = V::<usize>([0, 1, 2, 3]);\n+    let uu32: V<u32> = unsafe { simd_cast(u) };\n+    let ui64: V<i64> = unsafe { simd_cast(u) };\n+\n+    for (u, (uu32, ui64)) in u.0.iter().zip(uu32.0.iter().zip(ui64.0.iter())) {\n+        assert_eq!(*u as u32, *uu32);\n+        assert_eq!(*u as i64, *ui64);\n+    }\n+}"}]}