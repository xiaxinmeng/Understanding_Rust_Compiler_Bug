{"sha": "2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhYjE4Y2U2ZjdlMTQ3YTcxZTk1M2I5YTAxZWQwOWFmZjZiOTU5NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-13T08:37:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-13T08:37:07Z"}, "message": "Auto merge of #34660 - jseyfried:fix_parse_stmt, r=nrc\n\nFix bugs in macro-expanded statement parsing\n\nFixes #34543.\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmacro_rules! m { () => {\n    println!(\"\") println!(\"\")\n    //^ Semicolons are now required on macro-expanded non-braced macro invocations\n    //| in statement positions.\n    let x = 0\n    //^ Semicolons are now required on macro-expanded `let` statements\n    //| that are followed by more statements, so this would break.\n    let y = 0 //< (this would still be allowed to reduce breakage in the wild)\n}\nfn main() { m!() }\n```\n\nr? @eddyb", "tree": {"sha": "376726d4299079f5a88cf6c54e6ed601921b11d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/376726d4299079f5a88cf6c54e6ed601921b11d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "html_url": "https://github.com/rust-lang/rust/commit/2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "617039bff0decea56b6698497b589671b0371507", "url": "https://api.github.com/repos/rust-lang/rust/commits/617039bff0decea56b6698497b589671b0371507", "html_url": "https://github.com/rust-lang/rust/commit/617039bff0decea56b6698497b589671b0371507"}, {"sha": "57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45", "url": "https://api.github.com/repos/rust-lang/rust/commits/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45", "html_url": "https://github.com/rust-lang/rust/commit/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45"}], "stats": {"total": 244, "additions": 125, "deletions": 119}, "files": [{"sha": "9f40829f4233f1e4d76f37f5f39fcc4850eaeb28", "filename": "src/doc/book/macros.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Fdoc%2Fbook%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Fdoc%2Fbook%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fmacros.md?ref=2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "patch": "@@ -328,7 +328,7 @@ invocation site. Code such as the following will not work:\n \n ```rust,ignore\n macro_rules! foo {\n-    () => (let x = 3);\n+    () => (let x = 3;);\n }\n \n fn main() {\n@@ -342,7 +342,7 @@ tagged with the right syntax context.\n \n ```rust\n macro_rules! foo {\n-    ($v:ident) => (let $v = 3);\n+    ($v:ident) => (let $v = 3;);\n }\n \n fn main() {"}, {"sha": "5e967f3250f710523440b186f468246a7d65b4e8", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "patch": "@@ -57,7 +57,7 @@ macro_rules! down_cast_data {\n             data\n         } else {\n             span_bug!($sp, \"unexpected data kind: {:?}\", $id);\n-        }\n+        };\n     };\n }\n "}, {"sha": "99e37ec80c0817802e2abeb08b4bfbef9583308b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "patch": "@@ -804,6 +804,19 @@ pub struct Stmt {\n     pub span: Span,\n }\n \n+impl Stmt {\n+    pub fn add_trailing_semicolon(mut self) -> Self {\n+        self.node = match self.node {\n+            StmtKind::Expr(expr) => StmtKind::Semi(expr),\n+            StmtKind::Mac(mac) => StmtKind::Mac(mac.map(|(mac, _style, attrs)| {\n+                (mac, MacStmtStyle::Semicolon, attrs)\n+            })),\n+            node @ _ => node,\n+        };\n+        self\n+    }\n+}\n+\n impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"stmt({}: {})\", self.id.to_string(), pprust::stmt_to_string(self))"}, {"sha": "220e0a753c30b5b1e7f2c53e1adbc775590274df", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "patch": "@@ -444,14 +444,7 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     // semicolon to the final statement produced by expansion.\n     if style == MacStmtStyle::Semicolon {\n         if let Some(stmt) = fully_expanded.pop() {\n-            fully_expanded.push(Stmt {\n-                id: stmt.id,\n-                node: match stmt.node {\n-                    StmtKind::Expr(expr) => StmtKind::Semi(expr),\n-                    _ => stmt.node /* might already have a semi */\n-                },\n-                span: stmt.span,\n-            });\n+            fully_expanded.push(stmt.add_trailing_semicolon());\n         }\n     }\n "}, {"sha": "db12ef24f7149fd95fd3ab362af7606ff517793b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "patch": "@@ -123,7 +123,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n             let mut parser = self.parser.borrow_mut();\n             match parser.token {\n                 token::Eof => break,\n-                _ => match parser.parse_stmt() {\n+                _ => match parser.parse_full_stmt(true) {\n                     Ok(maybe_stmt) => match maybe_stmt {\n                         Some(stmt) => ret.push(stmt),\n                         None => (),"}, {"sha": "c6374e59c1bc4b0e9a525e6b96b59ab99e799007", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 82, "deletions": 103, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "patch": "@@ -3789,7 +3789,13 @@ impl<'a> Parser<'a> {\n         self.span_err(self.last_span, message);\n     }\n \n-    /// Parse a statement. may include decl.\n+    /// Parse a statement. This stops just before trailing semicolons on everything but items.\n+    /// e.g. a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n+    ///\n+    /// Also, if a macro begins an expression statement, this only parses the macro. For example,\n+    /// ```rust\n+    /// vec![1].into_iter(); //< `parse_stmt` only parses the \"vec![1]\"\n+    /// ```\n     pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n         Ok(self.parse_stmt_())\n     }\n@@ -4038,36 +4044,14 @@ impl<'a> Parser<'a> {\n         let mut stmts = vec![];\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n-            let Stmt {node, span, ..} = if let Some(s) = self.parse_stmt_() {\n-                s\n+            if let Some(stmt) = self.parse_full_stmt(false)? {\n+                stmts.push(stmt);\n             } else if self.token == token::Eof {\n                 break;\n             } else {\n                 // Found only `;` or `}`.\n                 continue;\n             };\n-\n-            match node {\n-                StmtKind::Expr(e) => {\n-                    self.handle_expression_like_statement(e, span, &mut stmts)?;\n-                }\n-                StmtKind::Mac(mac) => {\n-                    self.handle_macro_in_block(mac.unwrap(), span, &mut stmts)?;\n-                }\n-                _ => { // all other kinds of statements:\n-                    let mut hi = span.hi;\n-                    if classify::stmt_ends_with_semi(&node) {\n-                        self.expect(&token::Semi)?;\n-                        hi = self.last_span.hi;\n-                    }\n-\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: node,\n-                        span: mk_sp(span.lo, hi)\n-                    });\n-                }\n-            }\n         }\n \n         Ok(P(ast::Block {\n@@ -4078,93 +4062,88 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    fn handle_macro_in_block(&mut self,\n-                             (mac, style, attrs): (ast::Mac, MacStmtStyle, ThinVec<Attribute>),\n-                             span: Span,\n-                             stmts: &mut Vec<Stmt>)\n-                             -> PResult<'a, ()> {\n-        if style == MacStmtStyle::NoBraces {\n-            // statement macro without braces; might be an\n-            // expr depending on whether a semicolon follows\n-            match self.token {\n-                token::Semi => {\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n-                        span: mk_sp(span.lo, self.span.hi),\n-                    });\n-                    self.bump();\n-                }\n-                _ => {\n-                    let e = self.mk_mac_expr(span.lo, span.hi, mac.node, ThinVec::new());\n-                    let lo = e.span.lo;\n-                    let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n-                    let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                    self.handle_expression_like_statement(e, span, stmts)?;\n-                }\n-            }\n-        } else {\n-            // statement macro; might be an expr\n-            match self.token {\n-                token::Semi => {\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n-                        span: mk_sp(span.lo, self.span.hi),\n-                    });\n-                    self.bump();\n-                }\n-                _ => {\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: StmtKind::Mac(P((mac, style, attrs))),\n-                        span: span\n-                    });\n+    /// Parse a statement, including the trailing semicolon.\n+    /// This parses expression statements that begin with macros correctly (c.f. `parse_stmt`).\n+    pub fn parse_full_stmt(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n+        let mut stmt = match self.parse_stmt_() {\n+            Some(stmt) => stmt,\n+            None => return Ok(None),\n+        };\n+\n+        if let StmtKind::Mac(mac) = stmt.node {\n+            if mac.1 != MacStmtStyle::NoBraces ||\n+               self.token == token::Semi || self.token == token::Eof {\n+                stmt.node = StmtKind::Mac(mac);\n+            } else {\n+                // We used to incorrectly stop parsing macro-expanded statements here.\n+                // If the next token will be an error anyway but could have parsed with the\n+                // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n+                if macro_expanded && self.token.can_begin_expr() && match self.token {\n+                    // These tokens can continue an expression, so we can't stop parsing and warn.\n+                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n+                    token::BinOp(token::Minus) | token::BinOp(token::Star) |\n+                    token::BinOp(token::And) | token::BinOp(token::Or) |\n+                    token::AndAnd | token::OrOr |\n+                    token::DotDot | token::DotDotDot => false,\n+                    _ => true,\n+                } {\n+                    self.warn_missing_semicolon();\n+                    stmt.node = StmtKind::Mac(mac);\n+                    return Ok(Some(stmt));\n                 }\n+\n+                let (mac, _style, attrs) = mac.unwrap();\n+                let e = self.mk_mac_expr(stmt.span.lo, stmt.span.hi, mac.node, ThinVec::new());\n+                let e = self.parse_dot_or_call_expr_with(e, stmt.span.lo, attrs)?;\n+                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                stmt.node = StmtKind::Expr(e);\n             }\n         }\n-        Ok(())\n+\n+        stmt = self.handle_trailing_semicolon(stmt, macro_expanded)?;\n+        Ok(Some(stmt))\n     }\n \n-    fn handle_expression_like_statement(&mut self,\n-                                        e: P<Expr>,\n-                                        span: Span,\n-                                        stmts: &mut Vec<Stmt>)\n-                                        -> PResult<'a, ()> {\n-        // expression without semicolon\n-        if classify::expr_requires_semi_to_be_stmt(&e) {\n-            // Just check for errors and recover; do not eat semicolon yet.\n-            if let Err(mut e) =\n-                self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n-            {\n-                e.emit();\n-                self.recover_stmt();\n+    fn handle_trailing_semicolon(&mut self, mut stmt: Stmt, macro_expanded: bool)\n+                                 -> PResult<'a, Stmt> {\n+        match stmt.node {\n+            StmtKind::Expr(ref expr) if self.token != token::Eof => {\n+                // expression without semicolon\n+                if classify::expr_requires_semi_to_be_stmt(expr) {\n+                    // Just check for errors and recover; do not eat semicolon yet.\n+                    if let Err(mut e) =\n+                        self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n+                    {\n+                        e.emit();\n+                        self.recover_stmt();\n+                    }\n+                }\n+            }\n+            StmtKind::Local(..) => {\n+                // We used to incorrectly allow a macro-expanded let statement to lack a semicolon.\n+                if macro_expanded && self.token != token::Semi {\n+                    self.warn_missing_semicolon();\n+                } else {\n+                    self.expect_one_of(&[token::Semi], &[])?;\n+                }\n             }\n+            _ => {}\n         }\n \n-        match self.token {\n-            token::Semi => {\n-                self.bump();\n-                let span_with_semi = Span {\n-                    lo: span.lo,\n-                    hi: self.last_span.hi,\n-                    expn_id: span.expn_id,\n-                };\n-                stmts.push(Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: StmtKind::Semi(e),\n-                    span: span_with_semi,\n-                });\n-            }\n-            _ => {\n-                stmts.push(Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: StmtKind::Expr(e),\n-                    span: span\n-                });\n-            }\n+        if self.eat(&token::Semi) {\n+            stmt = stmt.add_trailing_semicolon();\n         }\n-        Ok(())\n+\n+        stmt.span.hi = self.last_span.hi;\n+        Ok(stmt)\n+    }\n+\n+    fn warn_missing_semicolon(&self) {\n+        self.diagnostic().struct_span_warn(self.span, {\n+            &format!(\"expected `;`, found `{}`\", self.this_token_to_string())\n+        }).note({\n+            \"This was erroneously allowed and will become a hard error in a future release\"\n+        }).emit();\n     }\n \n     // Parses a sequence of bounds if a `:` is found,"}, {"sha": "8866ffc2575cca42176d10f1c77c1162d67d2446", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "patch": "@@ -1638,9 +1638,8 @@ impl<'a> State<'a> {\n                     _ => token::Paren\n                 };\n                 try!(self.print_mac(&mac, delim));\n-                match style {\n-                    ast::MacStmtStyle::Braces => {}\n-                    _ => try!(word(&mut self.s, \";\")),\n+                if style == ast::MacStmtStyle::Semicolon {\n+                    try!(word(&mut self.s, \";\"));\n                 }\n             }\n         }"}, {"sha": "c2ac99d1f6a2d2bdbfc9c4b0dfb8460b08dcab1d", "filename": "src/test/compile-fail/macro-incomplete-parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs?ref=2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "patch": "@@ -19,7 +19,7 @@ macro_rules! ignored_item {\n }\n \n macro_rules! ignored_expr {\n-    () => ( 1,  //~ ERROR expected expression, found `,`\n+    () => ( 1,  //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n             2 )\n }\n "}, {"sha": "bbc958b87a571724e93134e4d1599e3c116a0817", "filename": "src/test/compile-fail/missing-semicolon-warning.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Ftest%2Fcompile-fail%2Fmissing-semicolon-warning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ab18ce6f7e147a71e953b9a01ed09aff6b95972/src%2Ftest%2Fcompile-fail%2Fmissing-semicolon-warning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-semicolon-warning.rs?ref=2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+macro_rules! m {\n+    ($($e1:expr),*; $($e2:expr),*) => {\n+        $( let x = $e1 )*; //~ WARN expected `;`\n+        $( println!(\"{}\", $e2) )*; //~ WARN expected `;`\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { m!(0, 0; 0, 0); } //~ ERROR compilation successful"}]}