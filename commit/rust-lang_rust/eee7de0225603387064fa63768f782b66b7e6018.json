{"sha": "eee7de0225603387064fa63768f782b66b7e6018", "node_id": "C_kwDOAAsO6NoAKGVlZTdkZTAyMjU2MDMzODcwNjRmYTYzNzY4Zjc4MmI2NmI3ZTYwMTg", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-01T12:24:48Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-01T12:24:48Z"}, "message": "Diagnose private assoc item accesses", "tree": {"sha": "2fa81af64012f99668360fdee32f02499ca06d04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fa81af64012f99668360fdee32f02499ca06d04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eee7de0225603387064fa63768f782b66b7e6018", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eee7de0225603387064fa63768f782b66b7e6018", "html_url": "https://github.com/rust-lang/rust/commit/eee7de0225603387064fa63768f782b66b7e6018", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eee7de0225603387064fa63768f782b66b7e6018/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "html_url": "https://github.com/rust-lang/rust/commit/e3d144d17fa518d471ebc0c9b6262e62ba2a702c"}], "stats": {"total": 225, "additions": 199, "deletions": 26}, "files": [{"sha": "7b6569421195de23b50237078a377cca73bba554", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=eee7de0225603387064fa63768f782b66b7e6018", "patch": "@@ -36,6 +36,13 @@ pub(crate) fn dummy_expr_id() -> ExprId {\n \n pub type PatId = Idx<Pat>;\n \n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub enum ExprOrPatId {\n+    ExprId(ExprId),\n+    PatId(PatId),\n+}\n+stdx::impl_from!(ExprId, PatId for ExprOrPatId);\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Label {\n     pub name: Name,"}, {"sha": "7b54886d53f81793feaeafc1950542a9fc712039", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=eee7de0225603387064fa63768f782b66b7e6018", "patch": "@@ -21,7 +21,7 @@ use hir_def::{\n     body::Body,\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     data::{ConstData, StaticData},\n-    expr::{BindingAnnotation, ExprId, PatId},\n+    expr::{BindingAnnotation, ExprId, ExprOrPatId, PatId},\n     lang_item::LangItemTarget,\n     layout::Integer,\n     path::{path, Path},\n@@ -34,7 +34,7 @@ use hir_expand::name::{name, Name};\n use itertools::Either;\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n-use stdx::{always, impl_from};\n+use stdx::always;\n \n use crate::{\n     db::HirDatabase, fold_tys, fold_tys_and_consts, infer::coerce::CoerceMany,\n@@ -120,13 +120,6 @@ pub(crate) fn normalize(db: &dyn HirDatabase, owner: DefWithBodyId, ty: Ty) -> T\n     table.resolve_completely(ty_with_vars)\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-enum ExprOrPatId {\n-    ExprId(ExprId),\n-    PatId(PatId),\n-}\n-impl_from!(ExprId, PatId for ExprOrPatId);\n-\n /// Binding modes inferred for patterns.\n /// <https://doc.rust-lang.org/reference/patterns.html#binding-modes>\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -209,6 +202,7 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n     PrivateField { expr: ExprId, field: FieldId },\n+    PrivateAssocItem { id: ExprOrPatId, item: AssocItemId },\n     BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n }"}, {"sha": "a5dd020676421bee01f7d702abec6117553c9f2b", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=eee7de0225603387064fa63768f782b66b7e6018", "patch": "@@ -1142,20 +1142,26 @@ impl<'a> InferenceContext<'a> {\n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n         let resolved = method_resolution::lookup_method(\n-            &canonicalized_receiver.value,\n             self.db,\n+            &canonicalized_receiver.value,\n             self.trait_env.clone(),\n             &traits_in_scope,\n             VisibleFromModule::Filter(self.resolver.module()),\n             method_name,\n         );\n         let (receiver_ty, method_ty, substs) = match resolved {\n-            Some((adjust, func)) => {\n+            Some((adjust, func, visible)) => {\n                 let (ty, adjustments) = adjust.apply(&mut self.table, receiver_ty);\n                 let generics = generics(self.db.upcast(), func.into());\n                 let substs = self.substs_for_method_call(generics, generic_args);\n                 self.write_expr_adj(receiver, adjustments);\n                 self.write_method_resolution(tgt_expr, func, substs.clone());\n+                if !visible {\n+                    self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem {\n+                        id: tgt_expr.into(),\n+                        item: func.into(),\n+                    })\n+                }\n                 (ty, self.db.value_ty(func.into()), substs)\n             }\n             None => ("}, {"sha": "8bd17c0f39f4d71818c43da55598d226a681047d", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=eee7de0225603387064fa63768f782b66b7e6018", "patch": "@@ -14,7 +14,8 @@ use crate::{\n     consteval,\n     method_resolution::{self, VisibleFromModule},\n     utils::generics,\n-    Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind, ValueTyDefId,\n+    InferenceDiagnostic, Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n+    ValueTyDefId,\n };\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n@@ -279,20 +280,23 @@ impl<'a> InferenceContext<'a> {\n                 };\n \n                 if visible {\n-                    Some((def, item, Some(substs)))\n+                    Some((def, item, Some(substs), true))\n                 } else {\n                     if not_visible.is_none() {\n-                        not_visible = Some((def, item, Some(substs)));\n+                        not_visible = Some((def, item, Some(substs), false));\n                     }\n                     None\n                 }\n             },\n         );\n         let res = res.or(not_visible);\n-        if let Some((_, item, Some(ref substs))) = res {\n+        if let Some((_, item, Some(ref substs), visible)) = res {\n             self.write_assoc_resolution(id, item, substs.clone());\n+            if !visible {\n+                self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem { id, item })\n+            }\n         }\n-        res.map(|(def, _, substs)| (def, substs))\n+        res.map(|(def, _, substs, _)| (def, substs))\n     }\n \n     fn resolve_enum_variant_on_ty("}, {"sha": "2f5fa3083c7a196e9fa182ffdcc331e4ef5ad8c7", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=eee7de0225603387064fa63768f782b66b7e6018", "patch": "@@ -488,13 +488,13 @@ pub fn lang_names_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, Name)>\n \n /// Look up the method with the given name.\n pub(crate) fn lookup_method(\n-    ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n+    ty: &Canonical<Ty>,\n     env: Arc<TraitEnvironment>,\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: &Name,\n-) -> Option<(ReceiverAdjustments, FunctionId)> {\n+) -> Option<(ReceiverAdjustments, FunctionId, bool)> {\n     let mut not_visible = None;\n     let res = iterate_method_candidates(\n         ty,\n@@ -505,9 +505,9 @@ pub(crate) fn lookup_method(\n         Some(name),\n         LookupMode::MethodCall,\n         |adjustments, f, visible| match f {\n-            AssocItemId::FunctionId(f) if visible => Some((adjustments, f)),\n+            AssocItemId::FunctionId(f) if visible => Some((adjustments, f, true)),\n             AssocItemId::FunctionId(f) if not_visible.is_none() => {\n-                not_visible = Some((adjustments, f));\n+                not_visible = Some((adjustments, f, false));\n                 None\n             }\n             _ => None,"}, {"sha": "54d43fa8dc73b97e4f077324b79b850a98ac6a01", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=eee7de0225603387064fa63768f782b66b7e6018", "patch": "@@ -10,7 +10,7 @@ use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n-use crate::{Field, MacroKind, Type};\n+use crate::{AssocItem, Field, MacroKind, Type};\n \n macro_rules! diagnostics {\n     ($($diag:ident,)*) => {\n@@ -41,6 +41,7 @@ diagnostics![\n     MissingMatchArms,\n     MissingUnsafe,\n     NoSuchField,\n+    PrivateAssocItem,\n     PrivateField,\n     ReplaceFilterMapNextWithFindMap,\n     TypeMismatch,\n@@ -122,6 +123,13 @@ pub struct NoSuchField {\n     pub field: InFile<AstPtr<ast::RecordExprField>>,\n }\n \n+#[derive(Debug)]\n+pub struct PrivateAssocItem {\n+    pub expr_or_pat:\n+        InFile<Either<AstPtr<ast::Expr>, Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>>>,\n+    pub item: AssocItem,\n+}\n+\n #[derive(Debug)]\n pub struct PrivateField {\n     pub expr: InFile<AstPtr<ast::Expr>>,"}, {"sha": "86fd45e824697c5d5058f9c41cd128abaaf9ef1a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=eee7de0225603387064fa63768f782b66b7e6018", "patch": "@@ -41,7 +41,7 @@ use either::Either;\n use hir_def::{\n     adt::VariantData,\n     body::{BodyDiagnostic, SyntheticSyntax},\n-    expr::{BindingAnnotation, LabelId, Pat, PatId},\n+    expr::{BindingAnnotation, ExprOrPatId, LabelId, Pat, PatId},\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_tree::ItemTreeNode,\n     lang_item::LangItemTarget,\n@@ -85,9 +85,10 @@ pub use crate::{\n     diagnostics::{\n         AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n         MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n-        MissingUnsafe, NoSuchField, PrivateField, ReplaceFilterMapNextWithFindMap, TypeMismatch,\n-        UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n-        UnresolvedModule, UnresolvedProcMacro,\n+        MissingUnsafe, NoSuchField, PrivateAssocItem, PrivateField,\n+        ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n+        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n+        UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1358,6 +1359,20 @@ impl DefWithBody {\n                     let field = field.into();\n                     acc.push(PrivateField { expr, field }.into())\n                 }\n+                &hir_ty::InferenceDiagnostic::PrivateAssocItem { id, item } => {\n+                    let expr_or_pat = match id {\n+                        ExprOrPatId::ExprId(expr) => source_map\n+                            .expr_syntax(expr)\n+                            .expect(\"unexpected synthetic\")\n+                            .map(Either::Left),\n+                        ExprOrPatId::PatId(pat) => source_map\n+                            .pat_syntax(pat)\n+                            .expect(\"unexpected synthetic\")\n+                            .map(Either::Right),\n+                    };\n+                    let item = item.into();\n+                    acc.push(PrivateAssocItem { expr_or_pat, item }.into())\n+                }\n             }\n         }\n         for (expr, mismatch) in infer.expr_type_mismatches() {"}, {"sha": "b363a516dd1c0c59d9cfe668115de5cb359bf833", "filename": "crates/ide-diagnostics/src/handlers/private_assoc_item.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs?ref=eee7de0225603387064fa63768f782b66b7e6018", "patch": "@@ -0,0 +1,124 @@\n+use either::Either;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: private-assoc-item\n+//\n+// This diagnostic is triggered if the referenced associated item is not visible from the current\n+// module.\n+pub(crate) fn private_assoc_item(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::PrivateAssocItem,\n+) -> Diagnostic {\n+    // FIXME: add quickfix\n+    let name = match d.item.name(ctx.sema.db) {\n+        Some(name) => format!(\"`{}` \", name),\n+        None => String::new(),\n+    };\n+    Diagnostic::new(\n+        \"private-assoc-item\",\n+        format!(\n+            \"{} {}is private\",\n+            match d.item {\n+                hir::AssocItem::Function(_) => \"function\",\n+                hir::AssocItem::Const(_) => \"const\",\n+                hir::AssocItem::TypeAlias(_) => \"type alias\",\n+            },\n+            name,\n+        ),\n+        ctx.sema\n+            .diagnostics_display_range(d.expr_or_pat.clone().map(|it| match it {\n+                Either::Left(it) => it.into(),\n+                Either::Right(it) => match it {\n+                    Either::Left(it) => it.into(),\n+                    Either::Right(it) => it.into(),\n+                },\n+            }))\n+            .range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn private_method() {\n+        check_diagnostics(\n+            r#\"\n+mod module {\n+    pub struct Struct;\n+    impl Struct {\n+        fn method(&self) {}\n+    }\n+}\n+fn main(s: module::Struct) {\n+    s.method();\n+  //^^^^^^^^^^ error: function `method` is private\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn private_func() {\n+        check_diagnostics(\n+            r#\"\n+mod module {\n+    pub struct Struct;\n+    impl Struct {\n+        fn func() {}\n+    }\n+}\n+fn main() {\n+    module::Struct::func();\n+  //^^^^^^^^^^^^^^^^^^^^ error: function `func` is private\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn private_const() {\n+        check_diagnostics(\n+            r#\"\n+mod module {\n+    pub struct Struct;\n+    impl Struct {\n+        const CONST: u32 = 0;\n+    }\n+}\n+fn main() {\n+    module::Struct::CONST;\n+  //^^^^^^^^^^^^^^^^^^^^^ error: const `CONST` is private\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn private_but_shadowed_in_deref() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: deref\n+mod module {\n+    pub struct Struct { field: Inner }\n+    pub struct Inner;\n+    impl core::ops::Deref for Struct {\n+        type Target = Inner;\n+        fn deref(&self) -> &Inner { &self.field }\n+    }\n+    impl Struct {\n+        fn method(&self) {}\n+    }\n+    impl Inner {\n+        pub fn method(&self) {}\n+    }\n+}\n+fn main(s: module::Struct) {\n+    s.method();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "e630ae36866d3056238736d2fe822af1d1f962fc", "filename": "crates/ide-diagnostics/src/handlers/private_field.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs?ref=eee7de0225603387064fa63768f782b66b7e6018", "patch": "@@ -2,7 +2,7 @@ use crate::{Diagnostic, DiagnosticsContext};\n \n // Diagnostic: private-field\n //\n-// This diagnostic is triggered if created structure does not have field provided in record.\n+// This diagnostic is triggered if the accessed field is not visible from the current module.\n pub(crate) fn private_field(ctx: &DiagnosticsContext<'_>, d: &hir::PrivateField) -> Diagnostic {\n     // FIXME: add quickfix\n     Diagnostic::new(\n@@ -33,6 +33,19 @@ fn main(s: module::Struct) {\n         );\n     }\n \n+    #[test]\n+    fn private_tuple_field() {\n+        check_diagnostics(\n+            r#\"\n+mod module { pub struct Struct(u32); }\n+fn main(s: module::Struct) {\n+    s.0;\n+  //^^^ error: field `0` of `Struct` is private\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn private_but_shadowed_in_deref() {\n         check_diagnostics("}, {"sha": "b0231b875408a9d5183f7db533cf0a085f99e475", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7de0225603387064fa63768f782b66b7e6018/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=eee7de0225603387064fa63768f782b66b7e6018", "patch": "@@ -37,6 +37,7 @@ mod handlers {\n     pub(crate) mod missing_match_arms;\n     pub(crate) mod missing_unsafe;\n     pub(crate) mod no_such_field;\n+    pub(crate) mod private_assoc_item;\n     pub(crate) mod private_field;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n     pub(crate) mod type_mismatch;\n@@ -255,6 +256,7 @@ pub fn diagnostics(\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n+            AnyDiagnostic::PrivateAssocItem(d) => handlers::private_assoc_item::private_assoc_item(&ctx, &d),\n             AnyDiagnostic::PrivateField(d) => handlers::private_field::private_field(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n             AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),"}]}