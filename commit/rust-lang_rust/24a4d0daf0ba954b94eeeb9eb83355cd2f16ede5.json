{"sha": "24a4d0daf0ba954b94eeeb9eb83355cd2f16ede5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YTRkMGRhZjBiYTk1NGI5NGVlZWI5ZWI4MzM1NWNkMmYxNmVkZTU=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-28T02:15:40Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-28T03:25:18Z"}, "message": "std::vec: Sane implementations for connect_vec and concat_vec\n\nAvoid unnecessary copying of subvectors, and calculate the needed space\nbeforehand. These implementations are simple but better than the\nprevious.\n\nAlso only implement it once, for all `Vector<T>` using:\n\n    impl<'self, T: Clone, V: Vector<T>> VectorVector<T> for &'self [V]\n\nperformance improved according to the bench test:\n\n    before\n    test vec::bench::concat ... bench: 74818 ns/iter (+/- 408)\n    test vec::bench::connect ... bench: 87066 ns/iter (+/- 376)\n\n    after\n    test vec::bench::concat ... bench: 17724 ns/iter (+/- 126)\n    test vec::bench::connect ... bench: 18353 ns/iter (+/- 691)\n\nCloses #9581", "tree": {"sha": "ddff72104b11d337f2f89106067193c544e3ab7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddff72104b11d337f2f89106067193c544e3ab7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24a4d0daf0ba954b94eeeb9eb83355cd2f16ede5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24a4d0daf0ba954b94eeeb9eb83355cd2f16ede5", "html_url": "https://github.com/rust-lang/rust/commit/24a4d0daf0ba954b94eeeb9eb83355cd2f16ede5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24a4d0daf0ba954b94eeeb9eb83355cd2f16ede5/comments", "author": null, "committer": null, "parents": [{"sha": "5444f601dc02cd9f5fc886f438ea60310f664cc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5444f601dc02cd9f5fc886f438ea60310f664cc6", "html_url": "https://github.com/rust-lang/rust/commit/5444f601dc02cd9f5fc886f438ea60310f664cc6"}], "stats": {"total": 41, "additions": 15, "deletions": 26}, "files": [{"sha": "4d7d4bffdf148f0ba4df634cdff1bf0163ed8e6d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/24a4d0daf0ba954b94eeeb9eb83355cd2f16ede5/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a4d0daf0ba954b94eeeb9eb83355cd2f16ede5/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=24a4d0daf0ba954b94eeeb9eb83355cd2f16ede5", "patch": "@@ -356,43 +356,32 @@ pub fn connect_slices<T:Clone>(v: &[&[T]], sep: &T) -> ~[T] { v.connect_vec(sep)\n pub trait VectorVector<T> {\n     // FIXME #5898: calling these .concat and .connect conflicts with\n     // StrVector::con{cat,nect}, since they have generic contents.\n+    /// Flattens a vector of vectors of T into a single vector of T.\n     fn concat_vec(&self) -> ~[T];\n-    fn connect_vec(&self, sep: &T) -> ~[T];\n-}\n-\n-impl<'self, T:Clone> VectorVector<T> for &'self [~[T]] {\n-    /// Flattens a vector of slices of T into a single vector of T.\n-    fn concat_vec(&self) -> ~[T] {\n-        self.flat_map(|inner| (*inner).clone())\n-    }\n \n     /// Concatenate a vector of vectors, placing a given separator between each.\n-    fn connect_vec(&self, sep: &T) -> ~[T] {\n-        let mut r = ~[];\n-        let mut first = true;\n-        for inner in self.iter() {\n-            if first { first = false; } else { r.push((*sep).clone()); }\n-            r.push_all((*inner).clone());\n-        }\n-        r\n-    }\n+    fn connect_vec(&self, sep: &T) -> ~[T];\n }\n \n-impl<'self,T:Clone> VectorVector<T> for &'self [&'self [T]] {\n-    /// Flattens a vector of slices of T into a single vector of T.\n+impl<'self, T: Clone, V: Vector<T>> VectorVector<T> for &'self [V] {\n     fn concat_vec(&self) -> ~[T] {\n-        self.flat_map(|&inner| inner.to_owned())\n+        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let mut result = with_capacity(size);\n+        for v in self.iter() {\n+            result.push_all(v.as_slice())\n+        }\n+        result\n     }\n \n-    /// Concatenate a vector of slices, placing a given separator between each.\n     fn connect_vec(&self, sep: &T) -> ~[T] {\n-        let mut r = ~[];\n+        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let mut result = with_capacity(size + self.len());\n         let mut first = true;\n-        for &inner in self.iter() {\n-            if first { first = false; } else { r.push((*sep).clone()); }\n-            r.push_all(inner);\n+        for v in self.iter() {\n+            if first { first = false } else { result.push(sep.clone()) }\n+            result.push_all(v.as_slice())\n         }\n-        r\n+        result\n     }\n }\n "}]}