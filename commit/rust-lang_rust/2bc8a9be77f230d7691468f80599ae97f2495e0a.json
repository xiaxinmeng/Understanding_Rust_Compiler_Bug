{"sha": "2bc8a9be77f230d7691468f80599ae97f2495e0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYzhhOWJlNzdmMjMwZDc2OTE0NjhmODA1OTlhZTk3ZjI0OTVlMGE=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-07-29T22:08:54Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-08-12T13:39:31Z"}, "message": "doc: Update .pot files", "tree": {"sha": "aacbf9c4b458bc4af7e8d56c9db2806b5cbd3f50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aacbf9c4b458bc4af7e8d56c9db2806b5cbd3f50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bc8a9be77f230d7691468f80599ae97f2495e0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc8a9be77f230d7691468f80599ae97f2495e0a", "html_url": "https://github.com/rust-lang/rust/commit/2bc8a9be77f230d7691468f80599ae97f2495e0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bc8a9be77f230d7691468f80599ae97f2495e0a/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b1b7f32106b501c802a3b4e82bf77738f7502e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b1b7f32106b501c802a3b4e82bf77738f7502e8", "html_url": "https://github.com/rust-lang/rust/commit/7b1b7f32106b501c802a3b4e82bf77738f7502e8"}], "stats": {"total": 3615, "additions": 1840, "deletions": 1775}, "files": [{"sha": "9bc3fb1d16e2abd04888315bb56e21a2daa85f5f", "filename": "doc/po/rust.md.pot", "status": "modified", "additions": 914, "deletions": 970, "changes": 1884, "blob_url": "https://github.com/rust-lang/rust/blob/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Frust.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Frust.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Frust.md.pot?ref=2bc8a9be77f230d7691468f80599ae97f2495e0a"}, {"sha": "9c4fa4b6c2a9d7ed8c289b19ba3b51ac6295d0e5", "filename": "doc/po/rustpkg.md.pot", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Frustpkg.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Frustpkg.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Frustpkg.md.pot?ref=2bc8a9be77f230d7691468f80599ae97f2495e0a", "patch": "@@ -7,13 +7,13 @@\n msgid \"\"\n msgstr \"\"\n \"Project-Id-Version: Rust 0.8-pre\\n\"\n-\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n+\"POT-Creation-Date: 2013-07-30 07:07+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n \"Language: \\n\"\n \"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=CHARSET\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n \"Content-Transfer-Encoding: 8bit\\n\"\n \n #. type: Plain text\n@@ -160,7 +160,7 @@ msgid \"# Package identifiers\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:79\n+#: doc/rustpkg.md:87\n msgid \"\"\n \"A package identifier identifies a package uniquely.  A package can be stored \"\n \"in a workspace on the local file system, or on a remote Web server, in which \"\n@@ -169,51 +169,59 @@ msgid \"\"\n \"github.com/mozilla/rust`.  A package ID can also specify a version, like: \"\n \"`github.com/mozilla/rust#0.3`.  In this case, `rustpkg` will check that the \"\n \"repository `github.com/mozilla/rust` has a tag named `0.3`, and report an \"\n-\"error otherwise.\"\n+\"error otherwise.  A package ID can also specify a particular revision of a \"\n+\"repository, like: `github.com/mozilla/rust#release-0.7`.  When the refspec \"\n+\"(portion of the package ID after the `#`) can't be parsed as a decimal \"\n+\"number, rustpkg passes the refspec along to the version control system \"\n+\"without interpreting it.  rustpkg also interprets any dependencies on such a \"\n+\"package ID literally (as opposed to versions, where a newer version \"\n+\"satisfies a dependency on an older version).  Thus, `github.com/mozilla/\"\n+\"rust#5c4cd30f80` is also a valid package ID, since git can deduce that \"\n+\"5c4cd30f80 refers to a revision of the desired repository.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:81\n+#: doc/rustpkg.md:89\n msgid \"## Source files\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:83\n+#: doc/rustpkg.md:91\n msgid \"\"\n \"rustpkg searches for four different fixed filenames in order to determine \"\n \"the crates to build:\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/rustpkg.md:88\n+#: doc/rustpkg.md:96\n msgid \"`main.rs`: Assumed to be a main entry point for building an executable.\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/rustpkg.md:88\n+#: doc/rustpkg.md:96\n msgid \"`lib.rs`: Assumed to be a library crate.\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/rustpkg.md:88\n+#: doc/rustpkg.md:96\n msgid \"\"\n \"`test.rs`: Assumed to contain tests declared with the `#[test]` attribute.\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/rustpkg.md:88\n+#: doc/rustpkg.md:96\n msgid \"\"\n \"`bench.rs`: Assumed to contain benchmarks declared with the `#[bench]` \"\n \"attribute.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:90\n+#: doc/rustpkg.md:98\n msgid \"## Versions\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:97\n+#: doc/rustpkg.md:105\n msgid \"\"\n \"`rustpkg` packages do not need to declare their versions with an attribute \"\n \"inside one of the source files, because `rustpkg` infers it from the version \"\n@@ -224,12 +232,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:99\n+#: doc/rustpkg.md:107\n msgid \"# Dependencies\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:103\n+#: doc/rustpkg.md:111\n msgid \"\"\n \"rustpkg infers dependencies from `extern mod` directives.  Thus, there \"\n \"should be no need to pass a `-L` flag to rustpkg to tell it where to find a \"\n@@ -238,20 +246,20 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:105\n+#: doc/rustpkg.md:113\n msgid \"# Custom build scripts\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:109\n+#: doc/rustpkg.md:117\n msgid \"\"\n \"A file called `pkg.rs` at the root level in a workspace is called a *package \"\n \"script*.  If a package script exists, rustpkg executes it to build the \"\n \"package rather than inferring crates as described previously.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:113\n+#: doc/rustpkg.md:121\n msgid \"\"\n \"Inside `pkg.rs`, it's possible to call back into rustpkg to finish up the \"\n \"build.  `rustpkg::api` contains functions to build, install, or clean \"\n@@ -260,17 +268,17 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:115\n+#: doc/rustpkg.md:123\n msgid \"# Command reference\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:117\n+#: doc/rustpkg.md:125\n msgid \"## build\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:123\n+#: doc/rustpkg.md:131\n msgid \"\"\n \"`rustpkg build foo` searches for a package with ID `foo` and builds it in \"\n \"any workspace(s) where it finds one.  Supposing such packages are found in \"\n@@ -279,22 +287,22 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:125\n+#: doc/rustpkg.md:133\n msgid \"## clean\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:127\n+#: doc/rustpkg.md:135\n msgid \"`rustpkg clean foo` deletes the contents of `foo`'s `build` directory.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:129\n+#: doc/rustpkg.md:137\n msgid \"## install\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:133\n+#: doc/rustpkg.md:141\n msgid \"\"\n \"`rustpkg install foo` builds the libraries and/or executables that are \"\n \"targets for `foo`, and then installs them either into `foo`'s `lib` and \"\n@@ -303,12 +311,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:135\n+#: doc/rustpkg.md:143\n msgid \"## test\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:137\n+#: doc/rustpkg.md:145\n msgid \"\"\n \"`rustpkg test foo` builds `foo`'s `test.rs` file if necessary, then runs the \"\n \"resulting test executable.\""}, {"sha": "4678d3ae366023c9957b760a2e0af14ffcca6a6c", "filename": "doc/po/tutorial-borrowed-ptr.md.pot", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial-borrowed-ptr.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial-borrowed-ptr.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-borrowed-ptr.md.pot?ref=2bc8a9be77f230d7691468f80599ae97f2495e0a", "patch": "@@ -7,13 +7,13 @@\n msgid \"\"\n msgstr \"\"\n \"Project-Id-Version: Rust 0.8-pre\\n\"\n-\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n+\"POT-Creation-Date: 2013-07-22 23:37+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n \"Language: \\n\"\n \"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=CHARSET\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n \"Content-Transfer-Encoding: 8bit\\n\"\n \n #. type: Plain text\n@@ -24,7 +24,7 @@ msgid \"# Introduction\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1111 doc/tutorial-borrowed-ptr.md:72\n+#: doc/tutorial.md:1108 doc/tutorial-borrowed-ptr.md:72\n msgid \"Now we can call `compute_distance()` in various ways:\"\n msgstr \"\"\n \n@@ -60,8 +60,8 @@ msgstr \"\"\n msgid \"\"\n \"Although borrowed pointers have rather elaborate theoretical underpinnings \"\n \"(region pointers), the core concepts will be familiar to anyone who has \"\n-\"worked with C or C++. Therefore, the best way to explain how they are \"\n-\"usedand their limitationsis probably just to work through several examples.\"\n+\"worked with C or C++. Therefore, the best way to explain how they are used\u2014\"\n+\"and their limitations\u2014is probably just to work through several examples.\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -115,7 +115,7 @@ msgid \"\"\n \"any two points, no matter where they were stored. For example, we might like \"\n \"to compute the distance between `on_the_stack` and `managed_box`, or between \"\n \"`managed_box` and `owned_box`. One option is to define a function that takes \"\n-\"two arguments of type `Point`that is, it takes the points by value. But if \"\n+\"two arguments of type `Point`\u2014that is, it takes the points by value. But if \"\n \"we define it this way, calling the function will cause the points to be \"\n \"copied. For points, this is probably not so bad, but often copies are \"\n \"expensive. Worse, if the data type contains mutable fields, copying can \"\n@@ -313,8 +313,8 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial-borrowed-ptr.md:186\n msgid \"\"\n-\"Weve seen a few examples so far of borrowing heap boxes, both managed and \"\n-\"owned. Up till this point, weve glossed over issues of safety. As stated in \"\n+\"We\u2019ve seen a few examples so far of borrowing heap boxes, both managed and \"\n+\"owned. Up till this point, we\u2019ve glossed over issues of safety. As stated in \"\n \"the introduction, at runtime a borrowed pointer is simply a pointer, nothing \"\n \"more. Therefore, avoiding C's problems with dangling pointers requires a \"\n \"compile-time safety check.\"\n@@ -626,7 +626,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial-borrowed-ptr.md:376\n msgid \"\"\n-\"As an example, lets look at the following `shape` type that can represent \"\n+\"As an example, let\u2019s look at the following `shape` type that can represent \"\n \"both rectangles and circles:\"\n msgstr \"\"\n \n@@ -792,7 +792,7 @@ msgstr \"\"\n #: doc/tutorial-borrowed-ptr.md:483\n msgid \"\"\n \"So far, all of the examples we have looked at, use borrowed pointers in a \"\n-\"downward direction. That is, a method or code block creates a borrowed \"\n+\"\u201cdownward\u201d direction. That is, a method or code block creates a borrowed \"\n \"pointer, then uses it within the same scope. It is also possible to return \"\n \"borrowed pointers as the result of a function, but as we'll see, doing so \"\n \"requires some explicit annotation.\"\n@@ -844,7 +844,7 @@ msgstr \"\"\n msgid \"\"\n \"Named lifetimes that appear in function signatures are conceptually the same \"\n \"as the other lifetimes we have seen before, but they are a bit abstract: \"\n-\"they dont refer to a specific expression within `get_x()`, but rather to \"\n+\"they don\u2019t refer to a specific expression within `get_x()`, but rather to \"\n \"some expression within the *caller of `get_x()`*.  The lifetime `r` is \"\n \"actually a kind of *lifetime parameter*: it is defined by the caller to \"\n \"`get_x()`, just as the value for the parameter `p` is defined by that caller.\"\n@@ -862,7 +862,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial-borrowed-ptr.md:526\n msgid \"\"\n-\"To emphasize this point, lets look at a variation on the example, this time \"\n+\"To emphasize this point, let\u2019s look at a variation on the example, this time \"\n \"one that does not compile:\"\n msgstr \"\"\n "}, {"sha": "7f4f896076f3bb227fc583ac77a984bf368d9f6e", "filename": "doc/po/tutorial-container.md.pot", "status": "modified", "additions": 110, "deletions": 38, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial-container.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial-container.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-container.md.pot?ref=2bc8a9be77f230d7691468f80599ae97f2495e0a", "patch": "@@ -7,13 +7,13 @@\n msgid \"\"\n msgstr \"\"\n \"Project-Id-Version: Rust 0.8-pre\\n\"\n-\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n+\"POT-Creation-Date: 2013-08-05 19:40+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n \"Language: \\n\"\n \"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=CHARSET\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n \"Content-Transfer-Encoding: 8bit\\n\"\n \n #. type: Plain text\n@@ -242,48 +242,49 @@ msgstr \"\"\n #: doc/tutorial-container.md:112\n msgid \"\"\n \"Containers implement iteration over the contained elements by returning an \"\n-\"iterator object. For example, vector slices have four iterators available:\"\n+\"iterator object. For example, vector slices several iterators available:\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/tutorial-container.md:117\n-msgid \"`vector.iter()`, for immutable references to the elements\"\n+#: doc/tutorial-container.md:116\n+msgid \"`iter()` and `rev_iter()`, for immutable references to the elements\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/tutorial-container.md:117\n-msgid \"`vector.mut_iter()`, for mutable references to the elements\"\n+#: doc/tutorial-container.md:116\n+msgid \"\"\n+\"`mut_iter()` and `mut_rev_iter()`, for mutable references to the elements\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/tutorial-container.md:117\n+#: doc/tutorial-container.md:116\n msgid \"\"\n-\"`vector.rev_iter()`, for immutable references to the elements in reverse \"\n-\"order\"\n+\"`consume_iter()` and `consume_rev_iter`, to move the elements out by-value\"\n msgstr \"\"\n \n-#. type: Bullet: '* '\n-#: doc/tutorial-container.md:117\n+#. type: Plain text\n+#: doc/tutorial-container.md:119\n msgid \"\"\n-\"`vector.mut_rev_iter()`, for mutable references to the elements in reverse \"\n-\"order\"\n+\"A typical mutable container will implement at least `iter()`, `mut_iter()` \"\n+\"and `consume_iter()` along with the reverse variants if it maintains an \"\n+\"order.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:119\n+#: doc/tutorial-container.md:121\n msgid \"### Freezing\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:123\n+#: doc/tutorial-container.md:125\n msgid \"\"\n \"Unlike most other languages with external iterators, Rust has no *iterator \"\n \"invalidation*. As long an iterator is still in scope, the compiler will \"\n \"prevent modification of the container through another handle.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:128\n+#: doc/tutorial-container.md:130\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -293,7 +294,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:134\n+#: doc/tutorial-container.md:136\n #, no-wrap\n msgid \"\"\n \"    // the vector is frozen for this scope, the compiler will statically\\n\"\n@@ -304,66 +305,63 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:137\n+#: doc/tutorial-container.md:139\n msgid \"\"\n \"These semantics are due to most container iterators being implemented with \"\n \"`&` and `&mut`.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:139\n+#: doc/tutorial-container.md:141\n msgid \"## Iterator adaptors\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:143\n+#: doc/tutorial-container.md:145\n msgid \"\"\n \"The `IteratorUtil` trait implements common algorithms as methods extending \"\n \"every `Iterator` implementation. For example, the `fold` method will \"\n \"accumulate the items yielded by an `Iterator` into a single value:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:149\n+#: doc/tutorial-container.md:151\n msgid \"\"\n \"~~~ let xs = [1, 9, 2, 3, 14, 12]; let result = xs.iter().fold(0, |\"\n \"accumulator, item| accumulator - *item); assert_eq!(result, -41); ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:151\n+#: doc/tutorial-container.md:153\n msgid \"\"\n \"Some adaptors return an adaptor object implementing the `Iterator` trait \"\n \"itself:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:158\n+#: doc/tutorial-container.md:160\n msgid \"\"\n \"~~~ let xs = [1, 9, 2, 3, 14, 12]; let ys = [5, 2, 1, 8]; let sum = xs.\"\n \"iter().chain_(ys.iter()).fold(0, |a, b| a + *b); assert_eq!(sum, 57); ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:162\n+#: doc/tutorial-container.md:164\n msgid \"\"\n \"Note that some adaptors like the `chain_` method above use a trailing \"\n \"underscore to work around an issue with method resolve. The underscores will \"\n \"be dropped when they become unnecessary.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:164\n+#: doc/tutorial-container.md:166\n msgid \"## For loops\"\n msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial-container.md:168\n msgid \"\"\n-\"The `for` loop syntax is currently in transition, and will switch from the \"\n-\"old closure-based iteration protocol to iterator objects. For now, the \"\n-\"`advance` adaptor is required as a compatibility shim to use iterators with \"\n-\"for loops.\"\n+\"The `for` keyword can be used as sugar for iterating through any iterator:\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -419,7 +417,7 @@ msgstr \"\"\n msgid \"\"\n \"// print out the pairs of elements up to (&3, &\\\"baz\\\")\\n\"\n \"for (x, y) in it {\\n\"\n-\"    println(fmt!(\\\"%d %s\\\", *x, *y));\\n\"\n+\"    printfln!(\\\"%d %s\\\", *x, *y);\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -435,8 +433,8 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial-container.md:204\n msgid \"\"\n-\"// yield and print the last pair from the iterator println(fmt!(\\\"last: %?\"\n-\"\\\", it.next()));\"\n+\"// yield and print the last pair from the iterator printfln!(\\\"last: %?\\\", \"\n+\"it.next());\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -577,9 +575,9 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial-container.md:300\n msgid \"\"\n-\"~~~ let xs = [1, 2, 3, 4, 5, 6]; let mut it = xs.iter(); println(fmt!(\\\"%?\"\n-\"\\\", it.next())); // prints `Some(&1)` println(fmt!(\\\"%?\\\", it.next())); // \"\n-\"prints `Some(&2)` println(fmt!(\\\"%?\\\", it.next_back())); // prints `Some(&6)`\"\n+\"~~~ let xs = [1, 2, 3, 4, 5, 6]; let mut it = xs.iter(); printfln!(\\\"%?\\\", \"\n+\"it.next()); // prints `Some(&1)` printfln!(\\\"%?\\\", it.next()); // prints \"\n+\"`Some(&2)` printfln!(\\\"%?\\\", it.next_back()); // prints `Some(&6)`\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -588,14 +586,88 @@ msgstr \"\"\n msgid \"\"\n \"// prints `5`, `4` and `3`\\n\"\n \"for &x in it.invert() {\\n\"\n-\"    println(fmt!(\\\"%?\\\", x))\\n\"\n+\"    printfln!(\\\"%?\\\", x)\\n\"\n \"}\\n\"\n \"~~~\\n\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:308\n+#: doc/tutorial-container.md:309\n msgid \"\"\n \"The `rev_iter` and `mut_rev_iter` methods on vectors just return an inverted \"\n \"version of the standard immutable and mutable vector iterators.\"\n msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:312\n+msgid \"\"\n+\"The `chain_`, `transform`, `filter`, `filter_map` and `peek` adaptors are \"\n+\"`DoubleEndedIterator` implementations if the underlying iterators are.\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:317\n+msgid \"\"\n+\"~~~ let xs = [1, 2, 3, 4]; let ys = [5, 6, 7, 8]; let mut it = xs.iter().\"\n+\"chain_(ys.iter()).transform(|&x| x * 2);\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:319\n+msgid \"printfln!(\\\"%?\\\", it.next()); // prints `Some(2)`\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:325\n+#, no-wrap\n+msgid \"\"\n+\"// prints `16`, `14`, `12`, `10`, `8`, `6`, `4`\\n\"\n+\"for x in it.invert() {\\n\"\n+\"    printfln!(\\\"%?\\\", x);\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:327\n+msgid \"## Random-access iterators\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:331\n+msgid \"\"\n+\"The `RandomAccessIterator` trait represents an iterator offering random \"\n+\"access to the whole range. The `indexable` method retrieves the number of \"\n+\"elements accessible with the `idx` method.\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:334\n+msgid \"\"\n+\"The `chain_` adaptor is an implementation of `RandomAccessIterator` if the \"\n+\"underlying iterators are.\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:343\n+msgid \"\"\n+\"~~~ let xs = [1, 2, 3, 4, 5]; let ys = ~[7, 9, 11]; let mut it = xs.iter().\"\n+\"chain_(ys.iter()); printfln!(\\\"%?\\\", it.idx(0)); // prints `Some(&1)` \"\n+\"printfln!(\\\"%?\\\", it.idx(5)); // prints `Some(&7)` printfln!(\\\"%?\\\", it.\"\n+\"idx(7)); // prints `Some(&11)` printfln!(\\\"%?\\\", it.idx(8)); // prints `None`\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:348\n+msgid \"\"\n+\"// yield two elements from the beginning, and one from the end it.next(); it.\"\n+\"next(); it.next_back();\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:352\n+msgid \"\"\n+\"printfln!(\\\"%?\\\", it.idx(0)); // prints `Some(&3)` printfln!(\\\"%?\\\", it.\"\n+\"idx(4)); // prints `Some(&9)` printfln!(\\\"%?\\\", it.idx(6)); // prints `None` \"\n+\"~~~\"\n+msgstr \"\""}, {"sha": "97d3a44d7088437ff5d40a598d45db8a27c7fdd1", "filename": "doc/po/tutorial-ffi.md.pot", "status": "modified", "additions": 87, "deletions": 11, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial-ffi.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial-ffi.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-ffi.md.pot?ref=2bc8a9be77f230d7691468f80599ae97f2495e0a", "patch": "@@ -7,13 +7,13 @@\n msgid \"\"\n msgstr \"\"\n \"Project-Id-Version: Rust 0.8-pre\\n\"\n-\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n+\"POT-Creation-Date: 2013-08-10 07:44+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n \"Language: \\n\"\n \"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=CHARSET\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n \"Content-Transfer-Encoding: 8bit\\n\"\n \n #. type: Plain text\n@@ -24,7 +24,7 @@ msgid \"# Introduction\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:876 doc/tutorial-ffi.md:143\n+#: doc/tutorial.md:868 doc/tutorial-ffi.md:143\n msgid \"# Destructors\"\n msgstr \"\"\n \n@@ -446,11 +446,87 @@ msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial-ffi.md:232\n+msgid \"# Accessing foreign globals\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-ffi.md:236\n+msgid \"\"\n+\"Foreign APIs often export a global variable which could do something like \"\n+\"track global state. In order to access these variables, you declare them in \"\n+\"`extern` blocks with the `static` keyword:\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-ffi.md:239\n+msgid \"~~~{.xfail-test} use std::libc;\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-ffi.md:244\n+#, no-wrap\n+msgid \"\"\n+\"#[link_args = \\\"-lreadline\\\"]\\n\"\n+\"extern {\\n\"\n+\"    static rl_readline_version: libc::c_int;\\n\"\n+\"}\\n\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-ffi.md:250\n+#, no-wrap\n+msgid \"\"\n+\"fn main() {\\n\"\n+\"    println(fmt!(\\\"You have readline version %d installed.\\\",\\n\"\n+\"                 rl_readline_version as int));\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-ffi.md:254\n+msgid \"\"\n+\"Alternatively, you may need to alter global state provided by a foreign \"\n+\"interface. To do this, statics can be declared with `mut` so rust can mutate \"\n+\"them.\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-ffi.md:258\n+msgid \"~~~{.xfail-test} use std::libc; use std::ptr;\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-ffi.md:263\n+#, no-wrap\n+msgid \"\"\n+\"#[link_args = \\\"-lreadline\\\"]\\n\"\n+\"extern {\\n\"\n+\"    static mut rl_prompt: *libc::c_char;\\n\"\n+\"}\\n\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-ffi.md:272\n+#, no-wrap\n+msgid \"\"\n+\"fn main() {\\n\"\n+\"    do \\\"[my-awesome-shell] $\\\".as_c_str |buf| {\\n\"\n+\"        unsafe { rl_prompt = buf; }\\n\"\n+\"        // get a line, process it\\n\"\n+\"        unsafe { rl_prompt = ptr::null(); }\\n\"\n+\"    }\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-ffi.md:274\n msgid \"# Foreign calling conventions\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-ffi.md:237\n+#: doc/tutorial-ffi.md:279\n msgid \"\"\n \"Most foreign code exposes a C ABI, and Rust uses the platform's C calling \"\n \"convention by default when calling foreign functions. Some foreign \"\n@@ -460,7 +536,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-ffi.md:246\n+#: doc/tutorial-ffi.md:288\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -474,20 +550,20 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-ffi.md:250\n+#: doc/tutorial-ffi.md:292\n msgid \"\"\n \"The `abi` attribute applies to a foreign module (it cannot be applied to a \"\n \"single function within a module), and must be either `\\\"cdecl\\\"` or `\"\n \"\\\"stdcall\\\"`. The compiler may eventually support other calling conventions.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-ffi.md:252\n+#: doc/tutorial-ffi.md:294\n msgid \"# Interoperability with foreign code\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-ffi.md:256\n+#: doc/tutorial-ffi.md:298\n msgid \"\"\n \"Rust guarantees that the layout of a `struct` is compatible with the \"\n \"platform's representation in C.  A `#[packed]` attribute is available, which \"\n@@ -496,7 +572,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-ffi.md:263\n+#: doc/tutorial-ffi.md:305\n msgid \"\"\n \"Rust's owned and managed boxes use non-nullable pointers as handles which \"\n \"point to the contained object. However, they should not be manually created \"\n@@ -508,7 +584,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-ffi.md:268\n+#: doc/tutorial-ffi.md:310\n msgid \"\"\n \"Vectors and strings share the same basic memory layout, and utilities are \"\n \"available in the `vec` and `str` modules for working with C APIs. Strings \"\n@@ -518,7 +594,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-ffi.md:270\n+#: doc/tutorial-ffi.md:312\n msgid \"\"\n \"The standard library includes type aliases and function definitions for the \"\n \"C standard library in the `libc` module, and Rust links against `libc` and \""}, {"sha": "1b540ea8b1e85eb3ade8fb8df0a02261853f17d0", "filename": "doc/po/tutorial-macros.md.pot", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial-macros.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial-macros.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-macros.md.pot?ref=2bc8a9be77f230d7691468f80599ae97f2495e0a", "patch": "@@ -7,13 +7,13 @@\n msgid \"\"\n msgstr \"\"\n \"Project-Id-Version: Rust 0.8-pre\\n\"\n-\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n+\"POT-Creation-Date: 2013-07-22 23:37+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n \"Language: \\n\"\n \"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=CHARSET\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n \"Content-Transfer-Encoding: 8bit\\n\"\n \n #. type: Plain text\n@@ -24,7 +24,7 @@ msgid \"# Introduction\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rust.md:2033 doc/rust.md:2174 doc/tutorial-macros.md:323\n+#: doc/rust.md:2136 doc/rust.md:2223 doc/tutorial-macros.md:323\n msgid \"~~~~\"\n msgstr \"\"\n "}, {"sha": "893b3dc149193fd6f39eebada743b7fce959861a", "filename": "doc/po/tutorial-tasks.md.pot", "status": "modified", "additions": 124, "deletions": 124, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial-tasks.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial-tasks.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-tasks.md.pot?ref=2bc8a9be77f230d7691468f80599ae97f2495e0a", "patch": "@@ -7,13 +7,13 @@\n msgid \"\"\n msgstr \"\"\n \"Project-Id-Version: Rust 0.8-pre\\n\"\n-\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n+\"POT-Creation-Date: 2013-08-08 22:27+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n \"Language: \\n\"\n \"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=CHARSET\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n \"Content-Transfer-Encoding: 8bit\\n\"\n \n #. type: Plain text\n@@ -24,7 +24,7 @@ msgid \"# Introduction\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rust.md:1849 doc/tutorial-tasks.md:649\n+#: doc/rust.md:1952 doc/tutorial-tasks.md:648\n msgid \"# } ~~~~\"\n msgstr \"\"\n \n@@ -249,15 +249,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:124\n-msgid \"~~~ # use std::io::print; # use std::task::spawn; # use std::int;\"\n+#: doc/tutorial-tasks.md:123\n+msgid \"~~~ # use std::io::print; # use std::task::spawn;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:131\n+#: doc/tutorial-tasks.md:130\n #, no-wrap\n msgid \"\"\n-\"for int::range(0, 20) |child_task_number| {\\n\"\n+\"for child_task_number in range(0, 20) {\\n\"\n \"    do spawn {\\n\"\n \"       print(fmt!(\\\"I am child number %d\\\\n\\\", child_task_number));\\n\"\n \"    }\\n\"\n@@ -266,12 +266,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:133\n+#: doc/tutorial-tasks.md:132\n msgid \"## Communication\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:138\n+#: doc/tutorial-tasks.md:137\n msgid \"\"\n \"Now that we have spawned a new task, it would be nice if we could \"\n \"communicate with it. Recall that Rust does not have shared mutable state, so \"\n@@ -280,7 +280,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:143\n+#: doc/tutorial-tasks.md:142\n msgid \"\"\n \"A pipe is simply a pair of endpoints: one for sending messages and another \"\n \"for receiving messages. Pipes are low-level communication building-blocks \"\n@@ -289,7 +289,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:149\n+#: doc/tutorial-tasks.md:148\n msgid \"\"\n \"The simplest way to create a pipe is to use the `pipes::stream` function to \"\n \"create a `(Port, Chan)` pair. In Rust parlance, a *channel* is a sending \"\n@@ -298,17 +298,17 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:153\n+#: doc/tutorial-tasks.md:152\n msgid \"~~~~ # use std::task::spawn; # use std::comm::{stream, Port, Chan};\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:155\n+#: doc/tutorial-tasks.md:154\n msgid \"let (port, chan): (Port<int>, Chan<int>) = stream();\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:160\n+#: doc/tutorial-tasks.md:159\n #, no-wrap\n msgid \"\"\n \"do spawn || {\\n\"\n@@ -318,15 +318,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:166\n+#: doc/tutorial-tasks.md:165\n msgid \"\"\n \"some_other_expensive_computation(); let result = port.recv(); # fn \"\n \"some_expensive_computation() -> int { 42 } # fn \"\n \"some_other_expensive_computation() {} ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:171\n+#: doc/tutorial-tasks.md:170\n msgid \"\"\n \"Let's examine this example in detail. First, the `let` statement creates a \"\n \"stream for sending and receiving integers (the left-hand side of the `let`, \"\n@@ -335,22 +335,22 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:176\n+#: doc/tutorial-tasks.md:175\n msgid \"\"\n \"~~~~ # use std::comm::{stream, Chan, Port}; let (port, chan): (Port<int>, \"\n \"Chan<int>) = stream(); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:180\n+#: doc/tutorial-tasks.md:179\n msgid \"\"\n \"The child task will use the channel to send data to the parent task, which \"\n \"will wait to receive the data on the port. The next statement spawns the \"\n \"child task.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:191\n+#: doc/tutorial-tasks.md:190\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -366,7 +366,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:197\n+#: doc/tutorial-tasks.md:196\n msgid \"\"\n \"Notice that the creation of the task closure transfers `chan` to the child \"\n \"task implicitly: the closure captures `chan` in its environment. Both `Chan` \"\n@@ -376,22 +376,22 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:201\n+#: doc/tutorial-tasks.md:200\n msgid \"\"\n \"Finally, the parent continues with some other expensive computation, then \"\n \"waits for the child's result to arrive on the port:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:210\n+#: doc/tutorial-tasks.md:209\n msgid \"\"\n \"~~~~ # use std::comm::{stream}; # fn some_other_expensive_computation() {} # \"\n \"let (port, chan) = stream::<int>(); # chan.send(0); \"\n \"some_other_expensive_computation(); let result = port.recv(); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:216\n+#: doc/tutorial-tasks.md:215\n msgid \"\"\n \"The `Port` and `Chan` pair created by `stream` enables efficient \"\n \"communication between a single sender and a single receiver, but multiple \"\n@@ -401,15 +401,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:222\n+#: doc/tutorial-tasks.md:221\n msgid \"\"\n \"~~~ {.xfail-test} # use std::task::{spawn}; # use std::comm::{stream, Port, \"\n \"Chan}; # fn some_expensive_computation() -> int { 42 } let (port, chan) = \"\n \"stream();\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:226\n+#: doc/tutorial-tasks.md:225\n #, no-wrap\n msgid \"\"\n \"do spawn {\\n\"\n@@ -418,7 +418,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:233\n+#: doc/tutorial-tasks.md:232\n #, no-wrap\n msgid \"\"\n \"// ERROR! The previous spawn statement already owns the channel,\\n\"\n@@ -430,29 +430,27 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:236\n+#: doc/tutorial-tasks.md:235\n msgid \"\"\n \"Instead we can use a `SharedChan`, a type that allows a single `Chan` to be \"\n \"shared by multiple senders.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:241\n-msgid \"\"\n-\"~~~ # use std::task::spawn; # use std::comm::{stream, SharedChan}; # use \"\n-\"std::uint;\"\n+#: doc/tutorial-tasks.md:239\n+msgid \"~~~ # use std::task::spawn; # use std::comm::{stream, SharedChan};\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:244\n+#: doc/tutorial-tasks.md:242\n msgid \"let (port, chan) = stream(); let chan = SharedChan::new(chan);\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:252\n+#: doc/tutorial-tasks.md:250\n #, no-wrap\n msgid \"\"\n-\"for uint::range(0, 3) |init_val| {\\n\"\n+\"for init_val in range(0u, 3) {\\n\"\n \"    // Create a new channel handle to distribute to the child task\\n\"\n \"    let child_chan = chan.clone();\\n\"\n \"    do spawn {\\n\"\n@@ -462,14 +460,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:256\n+#: doc/tutorial-tasks.md:254\n msgid \"\"\n \"let result = port.recv() + port.recv() + port.recv(); # fn \"\n \"some_expensive_computation(_i: uint) -> int { 42 } ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:265\n+#: doc/tutorial-tasks.md:263\n msgid \"\"\n \"Here we transfer ownership of the channel into a new `SharedChan` value.  \"\n \"Like `Chan`, `SharedChan` is a non-copyable, owned type (sometimes also \"\n@@ -482,7 +480,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:270\n+#: doc/tutorial-tasks.md:268\n msgid \"\"\n \"Note that the above `SharedChan` example is somewhat contrived since you \"\n \"could also simply use three `stream` pairs, but it serves to illustrate the \"\n@@ -491,12 +489,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:275\n+#: doc/tutorial-tasks.md:273\n msgid \"~~~ # use std::task::spawn; # use std::comm::stream; # use std::vec;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:284\n+#: doc/tutorial-tasks.md:282\n #, no-wrap\n msgid \"\"\n \"// Create a vector of ports, one for each child task\\n\"\n@@ -510,22 +508,22 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:289\n+#: doc/tutorial-tasks.md:287\n msgid \"\"\n \"// Wait on each port, accumulating the results let result = ports.iter().\"\n \"fold(0, |accum, port| accum + port.recv() ); # fn \"\n \"some_expensive_computation(_i: uint) -> int { 42 } ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:293\n+#: doc/tutorial-tasks.md:291\n msgid \"\"\n \"## Backgrounding computations: Futures With `extra::future`, rust has a \"\n \"mechanism for requesting a computation and getting the result later.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:301\n+#: doc/tutorial-tasks.md:299\n #, no-wrap\n msgid \"\"\n \"The basic example below illustrates this.\\n\"\n@@ -538,14 +536,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:306\n+#: doc/tutorial-tasks.md:304\n msgid \"\"\n \"let mut delayed_fib = extra::future::spawn (|| fib(50) ); make_a_sandwich(); \"\n \"println(fmt!(\\\"fib(50) = %?\\\", delayed_fib.get()))  ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:312\n+#: doc/tutorial-tasks.md:310\n msgid \"\"\n \"The call to `future::spawn` returns immediately a `future` object regardless \"\n \"of how long it takes to run `fib(50)`. You can then make yourself a sandwich \"\n@@ -557,51 +555,50 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:325\n+#: doc/tutorial-tasks.md:322\n #, no-wrap\n msgid \"\"\n \"Here is another example showing how futures allow you to background computations. The workload will\\n\"\n \"be distributed on the available cores.\\n\"\n \"~~~\\n\"\n \"# use std::vec;\\n\"\n-\"# use std::uint;\\n\"\n \"fn partial_sum(start: uint) -> f64 {\\n\"\n \"    let mut local_sum = 0f64;\\n\"\n-\"    for uint::range(start*100000, (start+1)*100000) |num| {\\n\"\n+\"    for num in range(start*100000, (start+1)*100000) {\\n\"\n \"        local_sum += (num as f64 + 1.0).pow(&-2.0);\\n\"\n \"    }\\n\"\n \"    local_sum\\n\"\n \"}\\n\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:328\n+#: doc/tutorial-tasks.md:325\n #, no-wrap\n msgid \"\"\n \"fn main() {\\n\"\n \"    let mut futures = vec::from_fn(1000, |ind| do extra::future::spawn { partial_sum(ind) });\\n\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:336\n+#: doc/tutorial-tasks.md:333\n #, no-wrap\n msgid \"\"\n \"    let mut final_res = 0f64;\\n\"\n \"    for ft in futures.mut_iter()  {\\n\"\n \"        final_res += ft.get();\\n\"\n \"    }\\n\"\n-\"    println(fmt!(\\\"^2/6 is not far from : %?\\\", final_res));\\n\"\n+\"    println(fmt!(\\\"\u03c0^2/6 is not far from : %?\\\", final_res));\\n\"\n \"}\\n\"\n \"~~~\\n\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:338\n+#: doc/tutorial-tasks.md:335\n msgid \"## Sharing immutable data without copy: Arc\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:343\n+#: doc/tutorial-tasks.md:340\n msgid \"\"\n \"To share immutable data between tasks, a first approach would be to only use \"\n \"pipes as we have seen previously. A copy of the data to share would then be \"\n@@ -610,7 +607,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:347\n+#: doc/tutorial-tasks.md:344\n msgid \"\"\n \"To tackle this issue, one can use an Atomically Reference Counted wrapper \"\n \"(`Arc`) as implemented in the `extra` library of Rust. With an Arc, the data \"\n@@ -619,16 +616,16 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:355\n+#: doc/tutorial-tasks.md:351\n msgid \"\"\n \"Here is a small example showing how to use Arcs. We wish to run concurrently \"\n \"several computations on a single large vector of floats. Each task needs the \"\n-\"full vector to perform its duty.  ~~~ # use std::vec; # use std::uint; # use \"\n-\"std::rand; use extra::arc::Arc;\"\n+\"full vector to perform its duty.  ~~~ # use std::vec; # use std::rand; use \"\n+\"extra::arc::Arc;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:359\n+#: doc/tutorial-tasks.md:355\n #, no-wrap\n msgid \"\"\n \"fn pnorm(nums: &~[float], p: uint) -> float {\\n\"\n@@ -637,7 +634,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:363\n+#: doc/tutorial-tasks.md:359\n #, no-wrap\n msgid \"\"\n \"fn main() {\\n\"\n@@ -646,22 +643,22 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:365\n+#: doc/tutorial-tasks.md:361\n #, no-wrap\n msgid \"    let numbers_arc = Arc::new(numbers);\\n\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:369\n+#: doc/tutorial-tasks.md:365\n #, no-wrap\n msgid \"\"\n-\"    for uint::range(1,10) |num| {\\n\"\n+\"    for num in range(1u, 10) {\\n\"\n \"        let (port, chan)  = stream();\\n\"\n \"        chan.send(numbers_arc.clone());\\n\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:378\n+#: doc/tutorial-tasks.md:374\n #, no-wrap\n msgid \"\"\n \"        do spawn {\\n\"\n@@ -675,45 +672,45 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:400\n+#: doc/tutorial-tasks.md:396\n msgid \"\"\n \"The function `pnorm` performs a simple computation on the vector (it \"\n \"computes the sum of its items at the power given as argument and takes the \"\n \"inverse power of this value). The Arc on the vector is created by the line \"\n \"~~~ # use extra::arc::Arc; # use std::vec; # use std::rand; # let numbers = \"\n-\"vec::from_fn(1000000, |_| rand::random::<float>()); let \"\n-\"numbers_arc=Arc::new(numbers); ~~~ and a clone of it is sent to each task ~~~ # \"\n-\"use extra::arc::Arc; # use std::vec; # use std::rand; # let numbers=vec::\"\n-\"from_fn(1000000, |_| rand::random::<float>()); # let numbers_arc = \"\n-\"Arc::new(numbers); # let (port, chan)  = stream(); chan.send(numbers_arc.\"\n+\"vec::from_fn(1000000, |_| rand::random::<float>()); let numbers_arc=Arc::\"\n+\"new(numbers); ~~~ and a clone of it is sent to each task ~~~ # use extra::\"\n+\"arc::Arc; # use std::vec; # use std::rand; # let numbers=vec::\"\n+\"from_fn(1000000, |_| rand::random::<float>()); # let numbers_arc = Arc::\"\n+\"new(numbers); # let (port, chan)  = stream(); chan.send(numbers_arc.\"\n \"clone()); ~~~ copying only the wrapper and not its contents.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:414\n+#: doc/tutorial-tasks.md:410\n msgid \"\"\n \"Each task recovers the underlying data by ~~~ # use extra::arc::Arc; # use \"\n \"std::vec; # use std::rand; # let numbers=vec::from_fn(1000000, |_| rand::\"\n-\"random::<float>()); # let numbers_arc=Arc::new(numbers); # let (port, chan)  = \"\n-\"stream(); # chan.send(numbers_arc.clone()); # let local_arc : Arc<~[float]> \"\n-\"= port.recv(); let task_numbers = local_arc.get(); ~~~ and can use it as if \"\n-\"it were local.\"\n+\"random::<float>()); # let numbers_arc=Arc::new(numbers); # let (port, chan)  \"\n+\"= stream(); # chan.send(numbers_arc.clone()); # let local_arc : \"\n+\"Arc<~[float]> = port.recv(); let task_numbers = local_arc.get(); ~~~ and can \"\n+\"use it as if it were local.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:416\n+#: doc/tutorial-tasks.md:412\n msgid \"\"\n \"The `arc` module also implements Arcs around mutable data that are not \"\n \"covered here.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:418\n+#: doc/tutorial-tasks.md:414\n msgid \"# Handling task failure\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:427\n+#: doc/tutorial-tasks.md:423\n msgid \"\"\n \"Rust has a built-in mechanism for raising exceptions. The `fail!()` macro \"\n \"(which can also be written with an error string as an argument: `fail!\"\n@@ -726,29 +723,29 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:430\n+#: doc/tutorial-tasks.md:426\n msgid \"\"\n \"All tasks are, by default, _linked_ to each other. That means that the fates \"\n \"of all tasks are intertwined: if one fails, so do all the others.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:438\n+#: doc/tutorial-tasks.md:434\n msgid \"\"\n-\"~~~ # use std::task::spawn; # use std::task; # fn do_some_work() { loop \"\n-\"{ task::yield() } } # do task::try { // Create a child task that fails do \"\n-\"spawn { fail!() }\"\n+\"~~~{.xfail-test .linked-failure} # use std::task::spawn; # use std::task; # \"\n+\"fn do_some_work() { loop { task::yield() } } # do task::try { // Create a \"\n+\"child task that fails do spawn { fail!() }\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:443\n+#: doc/tutorial-tasks.md:439\n msgid \"\"\n \"// This will also fail because the task we spawned failed do_some_work(); \"\n \"# }; ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:453\n+#: doc/tutorial-tasks.md:449\n msgid \"\"\n \"While it isn't possible for a task to recover from failure, tasks may notify \"\n \"each other of failure. The simplest way of handling task failure is with the \"\n@@ -762,10 +759,10 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:467\n+#: doc/tutorial-tasks.md:463\n #, no-wrap\n msgid \"\"\n-\"~~~\\n\"\n+\"~~~{.xfail-test .linked-failure}\\n\"\n \"# use std::task;\\n\"\n \"# fn some_condition() -> bool { false }\\n\"\n \"# fn calculate_result() -> int { 0 }\\n\"\n@@ -781,7 +778,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:473\n+#: doc/tutorial-tasks.md:469\n msgid \"\"\n \"Unlike `spawn`, the function spawned using `try` may return a value, which \"\n \"`try` will dutifully propagate back to the caller in a [`Result`] enum. If \"\n@@ -790,27 +787,27 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:475\n+#: doc/tutorial-tasks.md:471\n msgid \"[`Result`]: std/result.html\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:480\n+#: doc/tutorial-tasks.md:476\n msgid \"\"\n \"> ***Note:*** A failed task does not currently produce a useful error > \"\n \"value (`try` always returns `Err(())`). In the > future, it may be possible \"\n \"for tasks to intercept the value passed to > `fail!()`.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:483\n+#: doc/tutorial-tasks.md:479\n msgid \"\"\n \"TODO: Need discussion of `future_result` in order to make failure modes \"\n \"useful.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:491\n+#: doc/tutorial-tasks.md:487\n msgid \"\"\n \"But not all failures are created equal. In some cases you might need to \"\n \"abort the entire program (perhaps you're writing an assert which, if it \"\n@@ -822,24 +819,25 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:493\n+#: doc/tutorial-tasks.md:489\n msgid \"## Failure modes\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:496\n+#: doc/tutorial-tasks.md:492\n msgid \"\"\n \"By default, task failure is _bidirectionally linked_, which means that if \"\n \"either task fails, it kills the other one.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:510\n+#: doc/tutorial-tasks.md:507\n #, no-wrap\n msgid \"\"\n-\"~~~\\n\"\n+\"~~~{.xfail-test .linked-failure}\\n\"\n \"# use std::task;\\n\"\n-\"# fn sleep_forever() { loop { task::yield() } }\\n\"\n+\"# use std::comm::oneshot;\\n\"\n+\"# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\\n\"\n \"# do task::try {\\n\"\n \"do spawn {\\n\"\n \"    do spawn {\\n\"\n@@ -853,7 +851,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:517\n+#: doc/tutorial-tasks.md:514\n msgid \"\"\n \"If you want parent tasks to be able to kill their children, but do not want \"\n \"a parent to fail automatically if one of its child task fails, you can call \"\n@@ -864,14 +862,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:538\n+#: doc/tutorial-tasks.md:536\n #, no-wrap\n msgid \"\"\n-\"~~~\\n\"\n+\"~~~{.xfail-test .linked-failure}\\n\"\n \"# use std::comm::{stream, Chan, Port};\\n\"\n+\"# use std::comm::oneshot;\\n\"\n \"# use std::task::{spawn, try};\\n\"\n \"# use std::task;\\n\"\n-\"# fn sleep_forever() { loop { task::yield() } }\\n\"\n+\"# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\\n\"\n \"# do task::try {\\n\"\n \"let (receiver, sender): (Port<int>, Chan<int>) = stream();\\n\"\n \"do spawn {  // Bidirectionally linked\\n\"\n@@ -890,7 +889,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:544\n+#: doc/tutorial-tasks.md:542\n msgid \"\"\n \"Supervised failure is useful in any situation where one task manages \"\n \"multiple fallible child tasks, and the parent task can recover if any child \"\n@@ -899,20 +898,21 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:547\n+#: doc/tutorial-tasks.md:545\n msgid \"\"\n \"Supervised task failure propagates across multiple generations even if an \"\n \"intermediate generation has already exited:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:563\n+#: doc/tutorial-tasks.md:562\n #, no-wrap\n msgid \"\"\n-\"~~~\\n\"\n+\"~~~{.xfail-test .linked-failure}\\n\"\n \"# use std::task;\\n\"\n-\"# fn sleep_forever() { loop { task::yield() } }\\n\"\n-\"# fn wait_for_a_while() { for 1000.times { task::yield() } }\\n\"\n+\"# use std::comm::oneshot;\\n\"\n+\"# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\\n\"\n+\"# fn wait_for_a_while() { for _ in range(0, 1000u) { task::yield() } }\\n\"\n \"# do task::try::<int> {\\n\"\n \"do task::spawn_supervised {\\n\"\n \"    do task::spawn_supervised {\\n\"\n@@ -927,20 +927,20 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:566\n+#: doc/tutorial-tasks.md:565\n msgid \"\"\n \"Finally, tasks can be configured to not propagate failure to each other at \"\n \"all, using `task::spawn_unlinked` for _isolated failure_.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:582\n+#: doc/tutorial-tasks.md:581\n #, no-wrap\n msgid \"\"\n-\"~~~\\n\"\n+\"~~~{.xfail-test .linked-failure}\\n\"\n \"# use std::task;\\n\"\n \"# fn random() -> uint { 100 }\\n\"\n-\"# fn sleep_for(i: uint) { for i.times { task::yield() } }\\n\"\n+\"# fn sleep_for(i: uint) { for _ in range(0, i) { task::yield() } }\\n\"\n \"# do task::try::<()> {\\n\"\n \"let (time1, time2) = (random(), random());\\n\"\n \"do task::spawn_unlinked {\\n\"\n@@ -955,12 +955,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:584\n+#: doc/tutorial-tasks.md:583\n msgid \"## Creating a task with a bi-directional communication path\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:589\n+#: doc/tutorial-tasks.md:588\n msgid \"\"\n \"A very common thing to do is to spawn a child task where the parent and \"\n \"child both need to exchange messages with each other. The function `extra::\"\n@@ -969,7 +969,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:594\n+#: doc/tutorial-tasks.md:593\n msgid \"\"\n \"To see how `DuplexStream()` works, we will create a child task that \"\n \"repeatedly receives a `uint` message, converts it to a string, and sends the \"\n@@ -978,10 +978,10 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:607\n+#: doc/tutorial-tasks.md:606\n #, no-wrap\n msgid \"\"\n-\"~~~~\\n\"\n+\"~~~{.xfail-test .linked-failure}\\n\"\n \"# use extra::comm::DuplexStream;\\n\"\n \"# use std::uint;\\n\"\n \"fn stringifier(channel: &DuplexStream<~str, uint>) {\\n\"\n@@ -996,7 +996,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:615\n+#: doc/tutorial-tasks.md:614\n msgid \"\"\n \"The implementation of `DuplexStream` supports both sending and receiving. \"\n \"The `stringifier` function takes a `DuplexStream` that can send strings (the \"\n@@ -1007,15 +1007,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:617\n+#: doc/tutorial-tasks.md:616\n msgid \"Here is the code for the parent task:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:631\n+#: doc/tutorial-tasks.md:630\n #, no-wrap\n msgid \"\"\n-\"~~~~\\n\"\n+\"~~~{.xfail-test .linked-failure}\\n\"\n \"# use std::task::spawn;\\n\"\n \"# use std::uint;\\n\"\n \"# use extra::comm::DuplexStream;\\n\"\n@@ -1031,12 +1031,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:633\n+#: doc/tutorial-tasks.md:632\n msgid \"let (from_child, to_child) = DuplexStream();\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:637\n+#: doc/tutorial-tasks.md:636\n #, no-wrap\n msgid \"\"\n \"do spawn {\\n\"\n@@ -1045,23 +1045,23 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:640\n+#: doc/tutorial-tasks.md:639\n msgid \"from_child.send(22); assert!(from_child.recv() == ~\\\"22\\\");\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:643\n+#: doc/tutorial-tasks.md:642\n msgid \"from_child.send(23); from_child.send(0);\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:646\n+#: doc/tutorial-tasks.md:645\n msgid \"\"\n \"assert!(from_child.recv() == ~\\\"23\\\"); assert!(from_child.recv() == ~\\\"0\\\");\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-tasks.md:653\n+#: doc/tutorial-tasks.md:652\n msgid \"\"\n \"The parent task first calls `DuplexStream` to create a pair of bidirectional \"\n \"endpoints. It then uses `task::spawn` to create the child task, which \""}, {"sha": "2aea69cc57332e98140d80ad3ab10fce558fd323", "filename": "doc/po/tutorial.md.pot", "status": "modified", "additions": 556, "deletions": 591, "changes": 1147, "blob_url": "https://github.com/rust-lang/rust/blob/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/2bc8a9be77f230d7691468f80599ae97f2495e0a/doc%2Fpo%2Ftutorial.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial.md.pot?ref=2bc8a9be77f230d7691468f80599ae97f2495e0a"}]}