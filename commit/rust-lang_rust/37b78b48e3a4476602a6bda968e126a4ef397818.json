{"sha": "37b78b48e3a4476602a6bda968e126a4ef397818", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3Yjc4YjQ4ZTNhNDQ3NjYwMmE2YmRhOTY4ZTEyNmE0ZWYzOTc4MTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-29T22:04:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-29T22:12:36Z"}, "message": "modify shape code to only emit monomorphized enums (#2444)\n\nthis is hacky, but shape code is going away anyway and I didn't\nwant to invest too much effort into it", "tree": {"sha": "08c9a7cc4f876b44c91f2f72c7e2f1079aa3ff05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08c9a7cc4f876b44c91f2f72c7e2f1079aa3ff05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37b78b48e3a4476602a6bda968e126a4ef397818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37b78b48e3a4476602a6bda968e126a4ef397818", "html_url": "https://github.com/rust-lang/rust/commit/37b78b48e3a4476602a6bda968e126a4ef397818", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37b78b48e3a4476602a6bda968e126a4ef397818/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccc7651b482167f61678c8630545a9f0e6b6ea91", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccc7651b482167f61678c8630545a9f0e6b6ea91", "html_url": "https://github.com/rust-lang/rust/commit/ccc7651b482167f61678c8630545a9f0e6b6ea91"}], "stats": {"total": 397, "additions": 210, "deletions": 187}, "files": [{"sha": "a6cb56ca264607941b6617932c0b9025fe34a08d", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37b78b48e3a4476602a6bda968e126a4ef397818/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b78b48e3a4476602a6bda968e126a4ef397818/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=37b78b48e3a4476602a6bda968e126a4ef397818", "patch": "@@ -560,7 +560,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n \n-        let shape = shape_of(ccx, key, []);\n+        let shape = shape_of(ccx, key);\n         let shape_tables =\n             llvm::LLVMConstPointerCast(ccx.shape_cx.llshapetables,\n                                        T_ptr(T_i8()));"}, {"sha": "707c8d0608e1d7609c915f8e0c94123b652ead51", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 197, "deletions": 186, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/37b78b48e3a4476602a6bda968e126a4ef397818/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b78b48e3a4476602a6bda968e126a4ef397818/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=37b78b48e3a4476602a6bda968e126a4ef397818", "patch": "@@ -22,14 +22,49 @@ import std::map::hashmap;\n \n import ty_ctxt = middle::ty::ctxt;\n \n-type res_info = {did: ast::def_id, tps: [ty::t]};\n+type nominal_id = @{did: ast::def_id, tps: [ty::t]};\n+\n+fn mk_nominal_id(tcx: ty::ctxt, did: ast::def_id,\n+                 tps: [ty::t]) -> nominal_id {\n+    let tps_norm = tps.map { |t| ty::normalize_ty(tcx, t) };\n+    @{did: did, tps: tps_norm}\n+}\n+\n+fn hash_nominal_id(&&ri: nominal_id) -> uint {\n+    let mut h = 5381u;\n+    h *= 33u;\n+    h += ri.did.crate as uint;\n+    h *= 33u;\n+    h += ri.did.node as uint;\n+    for vec::each(ri.tps) {|t|\n+        h *= 33u;\n+        h += ty::type_id(t);\n+    }\n+    ret h;\n+}\n+\n+fn eq_nominal_id(&&mi: nominal_id, &&ni: nominal_id) -> bool {\n+    if mi.did != ni.did {\n+        false\n+    } else {\n+        vec::all2(mi.tps, ni.tps) { |m_tp, n_tp|\n+            ty::type_id(m_tp) == ty::type_id(n_tp)\n+        }\n+    }\n+}\n+\n+fn new_nominal_id_hash<T: copy>() -> hashmap<nominal_id, T> {\n+    ret hashmap(hash_nominal_id, eq_nominal_id);\n+}\n+\n+type enum_data = {did: ast::def_id, substs: ty::substs};\n \n type ctxt =\n     {mut next_tag_id: u16,\n      pad: u16,\n-     tag_id_to_index: hashmap<ast::def_id, u16>,\n-     tag_order: dvec<ast::def_id>,\n-     resources: interner::interner<res_info>,\n+     tag_id_to_index: hashmap<nominal_id, u16>,\n+     tag_order: dvec<enum_data>,\n+     resources: interner::interner<nominal_id>,\n      llshapetablesty: TypeRef,\n      llshapetables: ValueRef};\n \n@@ -63,19 +98,6 @@ const shape_rptr: u8 = 31u8;\n const shape_fixedvec: u8 = 32u8;\n const shape_slice: u8 = 33u8;\n \n-fn hash_res_info(ri: res_info) -> uint {\n-    let mut h = 5381u;\n-    h *= 33u;\n-    h += ri.did.crate as uint;\n-    h *= 33u;\n-    h += ri.did.node as uint;\n-    for vec::each(ri.tps) {|t|\n-        h *= 33u;\n-        h += ty::type_id(t);\n-    }\n-    ret h;\n-}\n-\n fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n    ValueRef {\n     let llglobal =\n@@ -99,77 +121,6 @@ fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n // alignment at least as large as any other variant of the enum. This is an\n // important performance optimization.\n \n-fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n-    // Compute the minimum and maximum size and alignment for each variant.\n-    //\n-    // FIXME: We could do better here; e.g. we know that any variant that\n-    // contains (T,T) must be as least as large as any variant that contains\n-    // just T.\n-    let mut ranges = [];\n-    let variants = ty::enum_variants(ccx.tcx, tag_id);\n-    for vec::each(*variants) {|variant|\n-        let mut bounded = true;\n-        let mut min_size = 0u, min_align = 0u;\n-        for vec::each(variant.args) {|elem_t|\n-            if ty::type_has_params(elem_t) {\n-                // FIXME: We could do better here; this causes us to\n-                // conservatively assume that (int, T) has minimum size 0,\n-                // when in fact it has minimum size sizeof(int).\n-                bounded = false;\n-            } else {\n-                let llty = type_of::type_of(ccx, elem_t);\n-                min_size += llsize_of_real(ccx, llty);\n-                min_align += llalign_of_pref(ccx, llty);\n-            }\n-        }\n-\n-        ranges +=\n-            [{size: {min: min_size, bounded: bounded},\n-              align: {min: min_align, bounded: bounded}}];\n-    }\n-\n-    // Initialize the candidate set to contain all variants.\n-    let mut candidates = [mut];\n-    for vec::each(*variants) {|_v| candidates += [mut true]; }\n-\n-    // Do a pairwise comparison among all variants still in the candidate set.\n-    // Throw out any variant that we know has size and alignment at least as\n-    // small as some other variant.\n-    let mut i = 0u;\n-    while i < vec::len(ranges) - 1u {\n-        if candidates[i] {\n-            let mut j = i + 1u;\n-            while j < vec::len(ranges) {\n-                if candidates[j] {\n-                    if ranges[i].size.bounded && ranges[i].align.bounded &&\n-                           ranges[j].size.bounded && ranges[j].align.bounded {\n-                        if ranges[i].size >= ranges[j].size &&\n-                               ranges[i].align >= ranges[j].align {\n-                            // Throw out j.\n-                            candidates[j] = false;\n-                        } else if ranges[j].size >= ranges[i].size &&\n-                                      ranges[j].align >= ranges[j].align {\n-                            // Throw out i.\n-                            candidates[i] = false;\n-                        }\n-                    }\n-                }\n-                j += 1u;\n-            }\n-        }\n-        i += 1u;\n-    }\n-\n-    // Return the resulting set.\n-    let mut result = [];\n-    let mut i = 0u;\n-    while i < vec::len(candidates) {\n-        if candidates[i] { result += [i]; }\n-        i += 1u;\n-    }\n-    ret result;\n-}\n-\n fn round_up(size: u16, align: u8) -> u16 {\n     assert (align >= 1u8);\n     let alignment = align as u16;\n@@ -178,39 +129,6 @@ fn round_up(size: u16, align: u8) -> u16 {\n \n type size_align = {size: u16, align: u8};\n \n-fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n-                            did: ast::def_id) -> size_align {\n-    let mut max_size = 0u16;\n-    let mut max_align = 1u8;\n-    let variants = ty::enum_variants(ccx.tcx, did);\n-    for vec::each(largest_variants) {|vid|\n-        // We increment a \"virtual data pointer\" to compute the size.\n-        let mut lltys = [];\n-        for vec::each(variants[vid].args) {|typ|\n-            lltys += [type_of::type_of(ccx, typ)];\n-        }\n-\n-        let llty = trans::common::T_struct(lltys);\n-        let dp = llsize_of_real(ccx, llty) as u16;\n-        let variant_align = llalign_of_pref(ccx, llty) as u8;\n-\n-        if max_size < dp { max_size = dp; }\n-        if max_align < variant_align { max_align = variant_align; }\n-    }\n-\n-    // Add space for the enum if applicable.\n-    // FIXME (issue #792): This is wrong. If the enum starts with an 8 byte\n-    // aligned quantity, we don't align it.\n-    if vec::len(*variants) > 1u {\n-        let variant_t = T_enum_discrim(ccx);\n-        max_size += llsize_of_real(ccx, variant_t) as u16;\n-        let align = llalign_of_pref(ccx, variant_t) as u8;\n-        if max_align < align { max_align = align; }\n-    }\n-\n-    ret {size: max_size, align: max_align};\n-}\n-\n enum enum_kind {\n     tk_unit,    // 1 variant, no data\n     tk_enum,    // N variants, no data\n@@ -274,9 +192,9 @@ fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n \n     ret {mut next_tag_id: 0u16,\n          pad: 0u16,\n-         tag_id_to_index: new_def_hash(),\n+         tag_id_to_index: new_nominal_id_hash(),\n          tag_order: dvec(),\n-         resources: interner::mk(hash_res_info, {|a, b| a == b}),\n+         resources: interner::mk(hash_nominal_id, eq_nominal_id),\n          llshapetablesty: llshapetablesty,\n          llshapetables: llshapetables};\n }\n@@ -292,7 +210,7 @@ fn add_substr(&dest: [u8], src: [u8]) {\n     dest += src;\n }\n \n-fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n+fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n     alt ty::get(t).struct {\n       ty::ty_nil | ty::ty_bool | ty::ty_uint(ast::ty_u8) |\n       ty::ty_bot { [shape_u8] }\n@@ -314,35 +232,37 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         let mut s = [shape_vec];\n         add_bool(s, true); // type is POD\n         let unit_ty = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n-        add_substr(s, shape_of(ccx, unit_ty, ty_param_map));\n+        add_substr(s, shape_of(ccx, unit_ty));\n         s\n       }\n       ty::ty_enum(did, substs) {\n-        let tps = substs.tps;\n-\n         alt enum_kind(ccx, did) {\n-          // FIXME: For now we do this.\n           tk_unit { [s_variant_enum_t(ccx.tcx)] }\n           tk_enum { [s_variant_enum_t(ccx.tcx)] }\n           tk_newtype | tk_complex {\n             let mut s = [shape_enum], id;\n-            alt ccx.shape_cx.tag_id_to_index.find(did) {\n+            let nom_id = mk_nominal_id(ccx.tcx, did, substs.tps);\n+            alt ccx.shape_cx.tag_id_to_index.find(nom_id) {\n               none {\n                 id = ccx.shape_cx.next_tag_id;\n-                ccx.shape_cx.tag_id_to_index.insert(did, id);\n-                ccx.shape_cx.tag_order.push(did);\n+                ccx.shape_cx.tag_id_to_index.insert(nom_id, id);\n+                ccx.shape_cx.tag_order.push({did: did, substs: substs});\n                 ccx.shape_cx.next_tag_id += 1u16;\n               }\n               some(existing_id) { id = existing_id; }\n             }\n             add_u16(s, id as u16);\n \n-            add_u16(s, vec::len(tps) as u16);\n-            for vec::each(tps) {|tp|\n-                let subshape = shape_of(ccx, tp, ty_param_map);\n-                add_u16(s, vec::len(subshape) as u16);\n-                s += subshape;\n-            }\n+            // Hack: always encode 0 tps, since we will encode\n+            // a monomorpized version\n+            add_u16(s, 0_u16);\n+\n+            // add_u16(s, vec::len(tps) as u16);\n+            // for vec::each(tps) {|tp|\n+            //     let subshape = shape_of(ccx, tp, ty_param_map);\n+            //     add_u16(s, vec::len(subshape) as u16);\n+            //     s += subshape;\n+            // }\n             s\n           }\n         }\n@@ -352,14 +272,14 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       ty::ty_box(_) | ty::ty_opaque_box { [shape_box] }\n       ty::ty_uniq(mt) {\n         let mut s = [shape_uniq];\n-        add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n+        add_substr(s, shape_of(ccx, mt.ty));\n         s\n       }\n       ty::ty_evec(mt, ty::vstore_uniq) |\n       ty::ty_vec(mt) {\n         let mut s = [shape_vec];\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n-        add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n+        add_substr(s, shape_of(ccx, mt.ty));\n         s\n       }\n \n@@ -369,7 +289,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         assert (n + 1u) <= 0xffffu;\n         add_u16(s, (n + 1u) as u16);\n         add_bool(s, true);\n-        add_substr(s, shape_of(ccx, u8_t, ty_param_map));\n+        add_substr(s, shape_of(ccx, u8_t));\n         s\n       }\n \n@@ -378,7 +298,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         assert n <= 0xffffu;\n         add_u16(s, n as u16);\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n-        add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n+        add_substr(s, shape_of(ccx, mt.ty));\n         s\n       }\n \n@@ -387,30 +307,30 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         let u8_t = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n         add_bool(s, true); // is_pod\n         add_bool(s, true); // is_str\n-        add_substr(s, shape_of(ccx, u8_t, ty_param_map));\n+        add_substr(s, shape_of(ccx, u8_t));\n         s\n       }\n \n       ty::ty_evec(mt, ty::vstore_slice(r)) {\n         let mut s = [shape_slice];\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n         add_bool(s, false); // is_str\n-        add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n+        add_substr(s, shape_of(ccx, mt.ty));\n         s\n       }\n \n       ty::ty_rec(fields) {\n         let mut s = [shape_struct], sub = [];\n         for vec::each(fields) {|f|\n-            sub += shape_of(ccx, f.mt.ty, ty_param_map);\n+            sub += shape_of(ccx, f.mt.ty);\n         }\n         add_substr(s, sub);\n         s\n       }\n       ty::ty_tup(elts) {\n         let mut s = [shape_struct], sub = [];\n         for vec::each(elts) {|elt|\n-            sub += shape_of(ccx, elt, ty_param_map);\n+            sub += shape_of(ccx, elt);\n         }\n         add_substr(s, sub);\n         s\n@@ -426,23 +346,23 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n           else { [shape_struct] };\n         let mut sub = [];\n         option::iter(m_dtor_did) {|dtor_did|\n-          let ri = {did: dtor_did, tps: tps};\n+          let ri = @{did: dtor_did, tps: tps};\n           let id = interner::intern(ccx.shape_cx.resources, ri);\n           add_u16(s, id as u16);\n           add_u16(s, vec::len(tps) as u16);\n           for vec::each(tps) {|tp|\n-             add_substr(s, shape_of(ccx, tp, ty_param_map));\n+             add_substr(s, shape_of(ccx, tp));\n           }\n         };\n         for ty::class_items_as_fields(ccx.tcx, did, substs).each {|f|\n-            sub += shape_of(ccx, f.mt.ty, ty_param_map);\n+            sub += shape_of(ccx, f.mt.ty);\n         }\n         add_substr(s, sub);\n         s\n       }\n       ty::ty_rptr(_, mt) {\n         let mut s = [shape_rptr];\n-        add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n+        add_substr(s, shape_of(ccx, mt.ty));\n         s\n       }\n       ty::ty_res(did, raw_subt, substs) {\n@@ -453,73 +373,61 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         for substs.tps.each() {|t| assert !ty::type_has_params(t); }\n         let subt = ty::subst(ccx.tcx, substs, raw_subt);\n         let tps = substs.tps;\n-        let ri = {did: did, tps: tps};\n+        let ri = @{did: did, tps: tps};\n         let id = interner::intern(ccx.shape_cx.resources, ri);\n \n         let mut s = [shape_res];\n         add_u16(s, id as u16);\n         add_u16(s, vec::len(tps) as u16);\n         for vec::each(tps) {|tp|\n-            add_substr(s, shape_of(ccx, tp, ty_param_map));\n+            add_substr(s, shape_of(ccx, tp));\n         }\n-        add_substr(s, shape_of(ccx, subt, ty_param_map));\n+        add_substr(s, shape_of(ccx, subt));\n         s\n       }\n-      ty::ty_param(n, _) {\n-        // Find the type parameter in the parameter list.\n-        alt vec::position_elem(ty_param_map, n) {\n-          some(i) { [shape_var, i as u8] }\n-          none { fail \"ty param not found in ty_param_map\"; }\n-        }\n+      ty::ty_param(*) {\n+        ccx.tcx.sess.bug(\"non-monomorphized type parameter\");\n       }\n       ty::ty_fn({proto: ast::proto_box, _}) { [shape_box_fn] }\n       ty::ty_fn({proto: ast::proto_uniq, _}) { [shape_uniq_fn] }\n       ty::ty_fn({proto: ast::proto_block, _}) |\n       ty::ty_fn({proto: ast::proto_any, _}) { [shape_stack_fn] }\n       ty::ty_fn({proto: ast::proto_bare, _}) { [shape_bare_fn] }\n       ty::ty_opaque_closure_ptr(_) { [shape_opaque_closure_ptr] }\n-      ty::ty_constr(inner_t, _) { shape_of(ccx, inner_t, ty_param_map) }\n+      ty::ty_constr(inner_t, _) { shape_of(ccx, inner_t) }\n       ty::ty_var(_) | ty::ty_self {\n         ccx.sess.bug(\"shape_of: unexpected type struct found\");\n       }\n     }\n }\n \n-// FIXME: We might discover other variants as we traverse these. Handle this.\n-fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info,\n-                    ty_param_count: uint) -> [u8] {\n-    let mut ty_param_map = [];\n-    let mut i = 0u;\n-    while i < ty_param_count { ty_param_map += [i]; i += 1u; }\n-\n+fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info) -> [u8] {\n     let mut s = [];\n-    for vec::each(v.args) {|t| s += shape_of(ccx, t, ty_param_map); }\n+    for vec::each(v.args) {|t| s += shape_of(ccx, t); }\n     ret s;\n }\n \n fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     // Loop over all the enum variants and write their shapes into a\n     // data buffer. As we do this, it's possible for us to discover\n     // new enums, so we must do this first.\n-    let mut i = 0u;\n     let mut data = [];\n     let mut offsets = [];\n+    let mut i = 0u;\n+    let mut enum_variants = [];\n     while i < ccx.shape_cx.tag_order.len() {\n-        let did = ccx.shape_cx.tag_order[i];\n-        let variants = ty::enum_variants(ccx.tcx, did);\n-        let item_tyt = ty::lookup_item_type(ccx.tcx, did);\n-        let ty_param_count = vec::len(*item_tyt.bounds);\n-\n+        let {did, substs} = ccx.shape_cx.tag_order[i];\n+        let variants = @ty::substd_enum_variants(ccx.tcx, did, substs);\n         vec::iter(*variants) {|v|\n             offsets += [vec::len(data) as u16];\n \n-            let variant_shape = shape_of_variant(ccx, v, ty_param_count);\n+            let variant_shape = shape_of_variant(ccx, v);\n             add_substr(data, variant_shape);\n \n             let zname = str::bytes(v.name) + [0u8];\n             add_substr(data, zname);\n         }\n-\n+        enum_variants += [variants];\n         i += 1u;\n     }\n \n@@ -533,9 +441,8 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let data_sz = vec::len(data) as u16;\n \n     let mut inf_sz = 0u16;\n-    for ccx.shape_cx.tag_order.each {|did_|\n-        let did = did_; // Satisfy alias checker.\n-        let num_variants = vec::len(*ty::enum_variants(ccx.tcx, did)) as u16;\n+    for enum_variants.each { |variants|\n+        let num_variants = vec::len(*variants) as u16;\n         add_u16(header, header_sz + inf_sz);\n         inf_sz += 2u16 * (num_variants + 2u16) + 3u16;\n     }\n@@ -545,29 +452,27 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     // contains the variants that the size-of operation needs to look at.\n \n     let mut lv_table = [];\n-    i = 0u;\n-    for ccx.shape_cx.tag_order.each {|did_|\n-        let did = did_; // Satisfy alias checker.\n-        let variants = ty::enum_variants(ccx.tcx, did);\n+    let mut i = 0u;\n+    for enum_variants.each { |variants|\n         add_u16(inf, vec::len(*variants) as u16);\n \n         // Construct the largest-variants table.\n         add_u16(inf,\n                 header_sz + inf_sz + data_sz + (vec::len(lv_table) as u16));\n \n-        let lv = largest_variants(ccx, did);\n+        let lv = largest_variants(ccx, variants);\n         add_u16(lv_table, vec::len(lv) as u16);\n         for vec::each(lv) {|v| add_u16(lv_table, v as u16); }\n \n         // Determine whether the enum has dynamic size.\n-        let dynamic = vec::any(*variants, {|v|\n+        assert !vec::any(*variants, {|v|\n             vec::any(v.args, {|t| ty::type_has_params(t)})\n         });\n \n         // If we can, write in the static size and alignment of the enum.\n         // Otherwise, write a placeholder.\n-        let size_align = if dynamic { {size: 0u16, align: 0u8} }\n-                         else { compute_static_enum_size(ccx, lv, did) };\n+        let size_align = compute_static_enum_size(ccx, lv, variants);\n+\n         // Write in the static size and alignment of the enum.\n         add_u16(inf, size_align.size);\n         inf += [size_align.align];\n@@ -589,6 +494,112 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     header += lv_table;\n \n     ret mk_global(ccx, \"tag_shapes\", C_bytes(header), true);\n+\n+    fn largest_variants(ccx: @crate_ctxt,\n+                        variants: @[ty::variant_info]) -> [uint] {\n+        // Compute the minimum and maximum size and alignment for each\n+        // variant.\n+        //\n+        // FIXME: We could do better here; e.g. we know that any\n+        // variant that contains (T,T) must be as least as large as\n+        // any variant that contains just T.\n+        let mut ranges = [];\n+        for vec::each(*variants) {|variant|\n+            let mut bounded = true;\n+            let mut min_size = 0u, min_align = 0u;\n+            for vec::each(variant.args) {|elem_t|\n+                if ty::type_has_params(elem_t) {\n+                    // FIXME: We could do better here; this causes us to\n+                    // conservatively assume that (int, T) has minimum size 0,\n+                    // when in fact it has minimum size sizeof(int).\n+                    bounded = false;\n+                } else {\n+                    let llty = type_of::type_of(ccx, elem_t);\n+                    min_size += llsize_of_real(ccx, llty);\n+                    min_align += llalign_of_pref(ccx, llty);\n+                }\n+            }\n+\n+            ranges +=\n+                [{size: {min: min_size, bounded: bounded},\n+                  align: {min: min_align, bounded: bounded}}];\n+        }\n+\n+        // Initialize the candidate set to contain all variants.\n+        let mut candidates = [mut];\n+        for vec::each(*variants) {|_v| candidates += [mut true]; }\n+\n+        // Do a pairwise comparison among all variants still in the\n+        // candidate set.  Throw out any variant that we know has size\n+        // and alignment at least as small as some other variant.\n+        let mut i = 0u;\n+        while i < vec::len(ranges) - 1u {\n+            if candidates[i] {\n+                let mut j = i + 1u;\n+                while j < vec::len(ranges) {\n+                    if candidates[j] {\n+                        if ranges[i].size.bounded &&\n+                            ranges[i].align.bounded &&\n+                            ranges[j].size.bounded &&\n+                            ranges[j].align.bounded {\n+                            if ranges[i].size >= ranges[j].size &&\n+                                ranges[i].align >= ranges[j].align {\n+                                // Throw out j.\n+                                candidates[j] = false;\n+                            } else if ranges[j].size >= ranges[i].size &&\n+                                ranges[j].align >= ranges[j].align {\n+                                // Throw out i.\n+                                candidates[i] = false;\n+                            }\n+                        }\n+                    }\n+                    j += 1u;\n+                }\n+            }\n+            i += 1u;\n+        }\n+\n+        // Return the resulting set.\n+        let mut result = [];\n+        let mut i = 0u;\n+        while i < vec::len(candidates) {\n+            if candidates[i] { result += [i]; }\n+            i += 1u;\n+        }\n+        ret result;\n+    }\n+\n+    fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n+                                variants: @[ty::variant_info]) -> size_align {\n+        let mut max_size = 0u16;\n+        let mut max_align = 1u8;\n+        for vec::each(largest_variants) {|vid|\n+            // We increment a \"virtual data pointer\" to compute the size.\n+            let mut lltys = [];\n+            for vec::each(variants[vid].args) {|typ|\n+                lltys += [type_of::type_of(ccx, typ)];\n+            }\n+\n+            let llty = trans::common::T_struct(lltys);\n+            let dp = llsize_of_real(ccx, llty) as u16;\n+            let variant_align = llalign_of_pref(ccx, llty) as u8;\n+\n+            if max_size < dp { max_size = dp; }\n+            if max_align < variant_align { max_align = variant_align; }\n+        }\n+\n+        // Add space for the enum if applicable.\n+        // FIXME (issue #792): This is wrong. If the enum starts with an\n+        // 8 byte aligned quantity, we don't align it.\n+        if vec::len(*variants) > 1u {\n+            let variant_t = T_enum_discrim(ccx);\n+            max_size += llsize_of_real(ccx, variant_t) as u16;\n+            let align = llalign_of_pref(ccx, variant_t) as u8;\n+            if max_align < align { max_align = align; }\n+        }\n+\n+        ret {size: max_size, align: max_align};\n+    }\n }\n \n fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {"}, {"sha": "1dd1123e7e7df4164cde0dd1177cf6217f9724cc", "filename": "src/test/run-fail/issue-2444.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37b78b48e3a4476602a6bda968e126a4ef397818/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b78b48e3a4476602a6bda968e126a4ef397818/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2444.rs?ref=37b78b48e3a4476602a6bda968e126a4ef397818", "patch": "@@ -0,0 +1,12 @@\n+// error-pattern:explicit failure\n+\n+use std;\n+import std::arc;\n+\n+enum e<T: const> { e(arc::arc<T>) }\n+\n+fn foo() -> e<int> {fail;}\n+\n+fn main() {\n+   let f = foo();\n+}"}]}