{"sha": "cfcce8e684c5e1bb2f9a74e55debf801ef27706f", "node_id": "C_kwDOAAsO6NoAKGNmY2NlOGU2ODRjNWUxYmIyZjlhNzRlNTVkZWJmODAxZWYyNzcwNmY", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-10-23T17:19:37Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-11-07T20:44:25Z"}, "message": "specialize iter::ArrayChunks::fold for TrustedRandomAccess iters\n\nThis is fairly safe use of TRA since it consumes the iterator so\nno struct in an unsafe state will be left exposed to user code", "tree": {"sha": "e54523861d32ee7289d8d4cf1ffcdf14ea267e43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e54523861d32ee7289d8d4cf1ffcdf14ea267e43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfcce8e684c5e1bb2f9a74e55debf801ef27706f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfcce8e684c5e1bb2f9a74e55debf801ef27706f", "html_url": "https://github.com/rust-lang/rust/commit/cfcce8e684c5e1bb2f9a74e55debf801ef27706f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfcce8e684c5e1bb2f9a74e55debf801ef27706f/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb3f001d3739e5e9f35e1a4b4e600889cf9980c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb3f001d3739e5e9f35e1a4b4e600889cf9980c6", "html_url": "https://github.com/rust-lang/rust/commit/eb3f001d3739e5e9f35e1a4b4e600889cf9980c6"}], "stats": {"total": 89, "additions": 86, "deletions": 3}, "files": [{"sha": "3f0fad4ed336f0b599245923df64a7d4877aec3e", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "modified", "additions": 86, "deletions": 3, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/cfcce8e684c5e1bb2f9a74e55debf801ef27706f/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcce8e684c5e1bb2f9a74e55debf801ef27706f/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=cfcce8e684c5e1bb2f9a74e55debf801ef27706f", "patch": "@@ -1,6 +1,8 @@\n use crate::array;\n-use crate::iter::{ByRefSized, FusedIterator, Iterator};\n-use crate::ops::{ControlFlow, Try};\n+use crate::const_closure::ConstFnMutClosure;\n+use crate::iter::{ByRefSized, FusedIterator, Iterator, TrustedRandomAccessNoCoerce};\n+use crate::mem::{self, MaybeUninit};\n+use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n \n /// An iterator over `N` elements of the iterator at a time.\n ///\n@@ -82,7 +84,13 @@ where\n         }\n     }\n \n-    impl_fold_via_try_fold! { fold -> try_fold }\n+    fn fold<B, F>(self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        <Self as SpecFold>::fold(self, init, f)\n+    }\n }\n \n #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n@@ -168,3 +176,78 @@ where\n         self.iter.len() < N\n     }\n }\n+\n+trait SpecFold: Iterator {\n+    fn fold<B, F>(self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B;\n+}\n+\n+impl<I, const N: usize> SpecFold for ArrayChunks<I, N>\n+where\n+    I: Iterator,\n+{\n+    #[inline]\n+    default fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        let fold = ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp);\n+        self.try_fold(init, fold).0\n+    }\n+}\n+\n+impl<I, const N: usize> SpecFold for ArrayChunks<I, N>\n+where\n+    I: Iterator + TrustedRandomAccessNoCoerce,\n+{\n+    #[inline]\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        if self.remainder.is_some() {\n+            return init;\n+        }\n+\n+        let mut accum = init;\n+        let inner_len = self.iter.size();\n+        let mut i = 0;\n+        // Use a while loop because (0..len).step_by(N) doesn't optimize well.\n+        while inner_len - i >= N {\n+            let mut chunk = MaybeUninit::uninit_array();\n+            let mut guard = array::Guard { array_mut: &mut chunk, initialized: 0 };\n+            for j in 0..N {\n+                // SAFETY: The method consumes the iterator and the loop condition ensures that\n+                // all accesses are in bounds and only happen once.\n+                guard.array_mut[j].write(unsafe { self.iter.__iterator_get_unchecked(i + j) });\n+                guard.initialized = j + 1;\n+            }\n+            mem::forget(guard);\n+            // SAFETY: The loop above initialized all elements\n+            let chunk = unsafe { MaybeUninit::array_assume_init(chunk) };\n+            accum = f(accum, chunk);\n+            i += N;\n+        }\n+\n+        let remainder = inner_len % N;\n+\n+        let mut tail = MaybeUninit::uninit_array();\n+        let mut guard = array::Guard { array_mut: &mut tail, initialized: 0 };\n+        for i in 0..remainder {\n+            // SAFETY: the remainder was not visited by the previous loop, so we're still only\n+            // accessing each element once\n+            let val = unsafe { self.iter.__iterator_get_unchecked(inner_len - remainder + i) };\n+            guard.array_mut[i].write(val);\n+            guard.initialized = i + 1;\n+        }\n+        mem::forget(guard);\n+        // SAFETY: the loop above initialized elements up to the `remainder` index\n+        self.remainder = Some(unsafe { array::IntoIter::new_unchecked(tail, 0..remainder) });\n+\n+        accum\n+    }\n+}"}]}