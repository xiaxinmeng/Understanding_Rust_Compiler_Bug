{"sha": "194fe695e3af6f03953cbb4ca66f159993f6214d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NGZlNjk1ZTNhZjZmMDM5NTNjYmI0Y2E2NmYxNTk5OTNmNjIxNGQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-27T07:29:24Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-01T05:59:47Z"}, "message": "rustc: decompose Adjustment into a vector of adjustment steps.", "tree": {"sha": "de297f5593cbcc6ea01e0265c5e2b2e195aae442", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de297f5593cbcc6ea01e0265c5e2b2e195aae442"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/194fe695e3af6f03953cbb4ca66f159993f6214d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/194fe695e3af6f03953cbb4ca66f159993f6214d", "html_url": "https://github.com/rust-lang/rust/commit/194fe695e3af6f03953cbb4ca66f159993f6214d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/194fe695e3af6f03953cbb4ca66f159993f6214d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "html_url": "https://github.com/rust-lang/rust/commit/91d603a2a7ad6caed2275da0c7ae21d845ed72d1"}], "stats": {"total": 1526, "additions": 676, "deletions": 850}, "files": [{"sha": "899e994302f807b816128459fb2f5093a9e0f7bc", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -99,16 +99,20 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Ad\n             ty::adjustment::Adjust::ReifyFnPointer |\n             ty::adjustment::Adjust::UnsafeFnPointer |\n             ty::adjustment::Adjust::ClosureFnPointer |\n-            ty::adjustment::Adjust::MutToConstPointer => {}\n-            ty::adjustment::Adjust::Deref(ref autoderefs) => {\n-                autoderefs.hash_stable(hcx, hasher);\n+            ty::adjustment::Adjust::MutToConstPointer |\n+            ty::adjustment::Adjust::Unsize => {}\n+            ty::adjustment::Adjust::Deref(ref overloaded) => {\n+                overloaded.hash_stable(hcx, hasher);\n+            }\n+            ty::adjustment::Adjust::Borrow(ref autoref) => {\n+                autoref.hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n-impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, autoref, unsize, target });\n-impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl, target });\n+impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n+impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl });\n impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n "}, {"sha": "55c3049155f4d762db8845be09e06a4bd3a43d5e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 27, "deletions": 69, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -704,89 +704,55 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     // consumed or borrowed as part of the automatic adjustment\n     // process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr) {\n-        let infcx = self.mc.infcx;\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n-        let adj = infcx.tables.borrow().adjustments.get(&expr.id).cloned();\n+        let adjustments = self.mc.infcx.tables.borrow().expr_adjustments(expr).to_vec();\n         let mut cmt = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n-        if let Some(adjustment) = adj {\n+        for adjustment in adjustments {\n             debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n             match adjustment.kind {\n                 adjustment::Adjust::NeverToAny |\n                 adjustment::Adjust::ReifyFnPointer |\n                 adjustment::Adjust::UnsafeFnPointer |\n                 adjustment::Adjust::ClosureFnPointer |\n-                adjustment::Adjust::MutToConstPointer => {\n+                adjustment::Adjust::MutToConstPointer |\n+                adjustment::Adjust::Unsize => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    self.delegate_consume(expr.id, expr.span, cmt);\n-                    assert!(adjustment.autoref.is_none() && !adjustment.unsize);\n-                    return;\n-                }\n-                adjustment::Adjust::Deref(ref autoderefs) => {\n-                    cmt = return_if_err!(self.walk_autoderefs(expr, cmt, autoderefs));\n+                    self.delegate_consume(expr.id, expr.span, cmt.clone());\n                 }\n-            }\n \n-            cmt = self.walk_autoref(expr, cmt, adjustment.autoref);\n-\n-            if adjustment.unsize {\n-                // Unsizing consumes the thin pointer and produces a fat one.\n-                self.delegate_consume(expr.id, expr.span, cmt);\n-            }\n-        }\n-    }\n+                adjustment::Adjust::Deref(None) => {}\n+\n+                // Autoderefs for overloaded Deref calls in fact reference\n+                // their receiver. That is, if we have `(*x)` where `x`\n+                // is of type `Rc<T>`, then this in fact is equivalent to\n+                // `x.deref()`. Since `deref()` is declared with `&self`,\n+                // this is an autoref of `x`.\n+                adjustment::Adjust::Deref(Some(ref deref)) => {\n+                    let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n+                    self.delegate.borrow(expr.id, expr.span, cmt.clone(),\n+                                         deref.region, bk, AutoRef);\n+                }\n \n-    /// Autoderefs for overloaded Deref calls in fact reference their receiver. That is, if we have\n-    /// `(*x)` where `x` is of type `Rc<T>`, then this in fact is equivalent to `x.deref()`. Since\n-    /// `deref()` is declared with `&self`, this is an autoref of `x`.\n-    fn walk_autoderefs(&mut self,\n-                       expr: &hir::Expr,\n-                       mut cmt: mc::cmt<'tcx>,\n-                       autoderefs: &[Option<adjustment::OverloadedDeref<'tcx>>])\n-                       -> mc::McResult<mc::cmt<'tcx>> {\n-        debug!(\"walk_autoderefs expr={:?} autoderefs={:?}\", expr, autoderefs);\n-\n-        for &overloaded in autoderefs {\n-            if let Some(deref) = overloaded {\n-                let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n-                self.delegate.borrow(expr.id, expr.span, cmt.clone(),\n-                                     deref.region, bk, AutoRef);\n-                cmt = self.mc.cat_overloaded_autoderef(expr, deref)?;\n-            } else {\n-                cmt = self.mc.cat_deref(expr, cmt, false)?;\n+                adjustment::Adjust::Borrow(ref autoref) => {\n+                    self.walk_autoref(expr, cmt.clone(), autoref);\n+                }\n             }\n+            cmt = return_if_err!(self.mc.cat_expr_adjusted(expr, cmt, &adjustment));\n         }\n-        Ok(cmt)\n     }\n \n-    /// Walks the autoref `opt_autoref` applied to the autoderef'd\n-    /// `expr`. `cmt_derefd` is the mem-categorized form of `expr`\n-    /// after all relevant autoderefs have occurred. Because AutoRefs\n-    /// can be recursive, this function is recursive: it first walks\n-    /// deeply all the way down the autoref chain, and then processes\n-    /// the autorefs on the way out. At each point, it returns the\n-    /// `cmt` for the rvalue that will be produced by introduced an\n-    /// autoref.\n+    /// Walks the autoref `autoref` applied to the autoderef'd\n+    /// `expr`. `cmt_base` is the mem-categorized form of `expr`\n+    /// after all relevant autoderefs have occurred.\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n                     cmt_base: mc::cmt<'tcx>,\n-                    opt_autoref: Option<adjustment::AutoBorrow<'tcx>>)\n-                    -> mc::cmt<'tcx>\n-    {\n-        debug!(\"walk_autoref(expr.id={} cmt_derefd={:?} opt_autoref={:?})\",\n+                    autoref: &adjustment::AutoBorrow<'tcx>) {\n+        debug!(\"walk_autoref(expr.id={} cmt_base={:?} autoref={:?})\",\n                expr.id,\n                cmt_base,\n-               opt_autoref);\n-\n-        let cmt_base_ty = cmt_base.ty;\n-\n-        let autoref = match opt_autoref {\n-            Some(ref autoref) => autoref,\n-            None => {\n-                // No AutoRef.\n-                return cmt_base;\n-            }\n-        };\n+               autoref);\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n@@ -816,14 +782,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                      AutoUnsafe);\n             }\n         }\n-\n-        // Construct the categorization for the result of the autoref.\n-        // This is always an rvalue, since we are producing a new\n-        // (temporary) indirection.\n-\n-        let adj_ty = cmt_base_ty.adjust_for_autoref(self.tcx(), opt_autoref);\n-\n-        self.mc.cat_rvalue_node(expr.id, expr.span, adj_ty)\n     }\n \n "}, {"sha": "53d8eecde54223b28a845371b013301832b8b41d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -466,42 +466,62 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n-        match self.infcx.tables.borrow().adjustments.get(&expr.id) {\n-            None => {\n-                // No adjustments.\n-                self.cat_expr_unadjusted(expr)\n+        // This recursion helper avoids going through *too many*\n+        // adjustments, since *only* non-overloaded deref recurses.\n+        fn helper<'a, 'gcx, 'tcx>(mc: &MemCategorizationContext<'a, 'gcx, 'tcx>,\n+                                  expr: &hir::Expr,\n+                                  adjustments: &[adjustment::Adjustment<'tcx>])\n+                                   -> McResult<cmt<'tcx>> {\n+            match adjustments.split_last() {\n+                None => mc.cat_expr_unadjusted(expr),\n+                Some((adjustment, previous)) => {\n+                    mc.cat_expr_adjusted_with(expr, || helper(mc, expr, previous), adjustment)\n+                }\n             }\n+        }\n \n-            Some(adjustment) => {\n-                debug!(\"cat_expr({:?}): {:?}\", adjustment, expr);\n-                match adjustment.kind {\n-                    adjustment::Adjust::Deref(ref autoderefs)\n-                    if adjustment.autoref.is_none() && !adjustment.unsize => {\n-                        // Equivalent to *expr or something similar.\n-                        let mut cmt = self.cat_expr_unadjusted(expr)?;\n-                        debug!(\"cat_expr: autoderefs={:?}, cmt={:?}\",\n-                               autoderefs, cmt);\n-                        for &overloaded in autoderefs {\n-                            if let Some(deref) = overloaded {\n-                                cmt = self.cat_overloaded_autoderef(expr, deref)?;\n-                            } else {\n-                                cmt = self.cat_deref(expr, cmt, false)?;\n-                            }\n-                        }\n-                        return Ok(cmt);\n-                    }\n+        helper(self, expr, self.infcx.tables.borrow().expr_adjustments(expr))\n+    }\n \n-                    adjustment::Adjust::NeverToAny |\n-                    adjustment::Adjust::ReifyFnPointer |\n-                    adjustment::Adjust::UnsafeFnPointer |\n-                    adjustment::Adjust::ClosureFnPointer |\n-                    adjustment::Adjust::MutToConstPointer |\n-                    adjustment::Adjust::Deref(_) => {\n-                        // Result is an rvalue.\n-                        let expr_ty = self.expr_ty_adjusted(expr)?;\n-                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n-                    }\n-                }\n+    pub fn cat_expr_adjusted(&self, expr: &hir::Expr,\n+                             previous: cmt<'tcx>,\n+                             adjustment: &adjustment::Adjustment<'tcx>)\n+                             -> McResult<cmt<'tcx>> {\n+        self.cat_expr_adjusted_with(expr, || Ok(previous), adjustment)\n+    }\n+\n+    fn cat_expr_adjusted_with<F>(&self, expr: &hir::Expr,\n+                                 previous: F,\n+                                 adjustment: &adjustment::Adjustment<'tcx>)\n+                                 -> McResult<cmt<'tcx>>\n+        where F: FnOnce() -> McResult<cmt<'tcx>>\n+    {\n+        debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n+        let target = self.infcx.resolve_type_vars_if_possible(&adjustment.target);\n+        match adjustment.kind {\n+            adjustment::Adjust::Deref(overloaded) => {\n+                // Equivalent to *expr or something similar.\n+                let base = if let Some(deref) = overloaded {\n+                    let ref_ty = self.tcx().mk_ref(deref.region, ty::TypeAndMut {\n+                        ty: target,\n+                        mutbl: deref.mutbl,\n+                    });\n+                    self.cat_rvalue_node(expr.id, expr.span, ref_ty)\n+                } else {\n+                    previous()?\n+                };\n+                self.cat_deref(expr, base, false)\n+            }\n+\n+            adjustment::Adjust::NeverToAny |\n+            adjustment::Adjust::ReifyFnPointer |\n+            adjustment::Adjust::UnsafeFnPointer |\n+            adjustment::Adjust::ClosureFnPointer |\n+            adjustment::Adjust::MutToConstPointer |\n+            adjustment::Adjust::Borrow(_) |\n+            adjustment::Adjust::Unsize => {\n+                // Result is an rvalue.\n+                Ok(self.cat_rvalue_node(expr.id, expr.span, target))\n             }\n         }\n     }\n@@ -931,21 +951,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         self.cat_deref(expr, base_cmt, implicit)\n     }\n \n-    pub fn cat_overloaded_autoderef(&self,\n-                                    expr: &hir::Expr,\n-                                    deref: adjustment::OverloadedDeref<'tcx>)\n-                                    -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_overloaded_autoderef: deref={:?}\", deref);\n-\n-        let target = self.infcx.resolve_type_vars_if_possible(&deref.target);\n-        let ref_ty = self.tcx().mk_ref(deref.region, ty::TypeAndMut {\n-            ty: target,\n-            mutbl: deref.mutbl,\n-        });\n-        let base_cmt = self.cat_rvalue_node(expr.id, expr.span, ref_ty);\n-        self.cat_deref(expr, base_cmt, false)\n-    }\n-\n     pub fn cat_deref<N:ast_node>(&self,\n                                  node: &N,\n                                  base_cmt: cmt<'tcx>,"}, {"sha": "62d137475f90e9797b10bbc0e17611f84584d541", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 25, "deletions": 78, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -10,29 +10,18 @@\n \n use hir;\n use hir::def_id::DefId;\n-use ty::{self, Ty, TyCtxt, TypeAndMut};\n+use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n \n \n /// Represents coercing a value to a different type of value.\n ///\n-/// We transform values by following the following steps in order:\n-/// 1. Apply a step of `Adjust` (see its variants for details).\n-/// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n-///    `&` or `*` pointer.\n-/// 3. If `unsize` is `true`, then apply the unsize transformation,\n-///    which will do things like convert thin pointers to fat\n-///    pointers, or convert structs containing thin pointers to\n-///    structs containing fat pointers, or convert between fat\n-///    pointers.  We don't store the details of how the transform is\n-///    done (in fact, we don't know that, because it might depend on\n-///    the precise type parameters). We just store the target\n-///    type. Trans figures out what has to be done at monomorphization\n-///    time based on the precise source/target type at hand.\n+/// We transform values by following a number of `Adjust` steps in order.\n+/// See the documentation on variants of `Adjust` for more details.\n ///\n-/// To make that more concrete, here are some common scenarios:\n+/// Here are some common scenarios:\n ///\n-/// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n+/// 1. The simplest cases are where a pointer is not adjusted fat vs thin.\n /// Here the pointer will be dereferenced N times (where a dereference can\n /// happen to raw or borrowed pointers or any smart pointer which implements\n /// Deref, including Box<_>). The types of dereferences is given by\n@@ -48,12 +37,9 @@ use ty::subst::Substs;\n /// represented by:\n ///\n /// ```\n-/// Adjustment {\n-///     kind: Adjust::Deref(vec![None]),// &[i32; 4] -> [i32; 4]\n-///     autoref: Some(AutoBorrow::Ref), // [i32; 4] -> &[i32; 4]\n-///     unsize: true,                   // &[i32; 4] -> &[i32]\n-///     target: `[i32]`,\n-/// }\n+/// Deref(None) -> [i32; 4],\n+/// Borrow(AutoBorrow::Ref) -> &[i32; 4],\n+/// Unsize -> &[i32],\n /// ```\n ///\n /// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n@@ -67,28 +53,10 @@ use ty::subst::Substs;\n /// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n /// At some point, of course, `Box` should move out of the compiler, in which\n /// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n-/// Box<[i32]> is represented by:\n-///\n-/// ```\n-/// Adjustment {\n-///     kind: Adjust::Deref(vec![]),\n-///     autoref: None,\n-///     unsize: true,\n-///     target: `Box<[i32]>`,\n-/// }\n-/// ```\n+/// Box<[i32]> is an `Adjust::Unsize` with the target `Box<[i32]>`.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Adjustment<'tcx> {\n-    /// Step 1.\n     pub kind: Adjust<'tcx>,\n-\n-    /// Step 2. Optionally produce a pointer/reference from the value.\n-    pub autoref: Option<AutoBorrow<'tcx>>,\n-\n-    /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n-    /// `&[T]`. Note that the source could be a thin or fat pointer.\n-    pub unsize: bool,\n-\n     pub target: Ty<'tcx>,\n }\n \n@@ -109,27 +77,23 @@ pub enum Adjust<'tcx> {\n     /// Go from a mut raw pointer to a const raw pointer.\n     MutToConstPointer,\n \n-    /// Apply a number of dereferences, producing an lvalue,\n-    /// if there are more than 0 dereferences.\n-    Deref(Vec<Option<OverloadedDeref<'tcx>>>),\n-}\n+    /// Dereference once, producing an lvalue.\n+    Deref(Option<OverloadedDeref<'tcx>>),\n \n-impl<'tcx> Adjustment<'tcx> {\n-    pub fn is_identity(&self) -> bool {\n-        if self.autoref.is_some() || self.unsize {\n-            return false;\n-        }\n-        match self.kind {\n-            Adjust::NeverToAny => self.target.is_never(),\n-\n-            Adjust::Deref(ref autoderefs) => autoderefs.is_empty(),\n-\n-            Adjust::ReifyFnPointer |\n-            Adjust::UnsafeFnPointer |\n-            Adjust::ClosureFnPointer |\n-            Adjust::MutToConstPointer => false,\n-        }\n-    }\n+    /// Take the address and produce either a `&` or `*` pointer.\n+    Borrow(AutoBorrow<'tcx>),\n+\n+    /// Unsize a pointer/reference value, e.g. `&[T; n]` to\n+    /// `&[T]`. Note that the source could be a thin or fat pointer.\n+    /// This will do things like convert thin pointers to fat\n+    /// pointers, or convert structs containing thin pointers to\n+    /// structs containing fat pointers, or convert between fat\n+    /// pointers.  We don't store the details of how the transform is\n+    /// done (in fact, we don't know that, because it might depend on\n+    /// the precise type parameters). We just store the target\n+    /// type. Trans figures out what has to be done at monomorphization\n+    /// time based on the precise source/target type at hand.\n+    Unsize,\n }\n \n /// An overloaded autoderef step, representing a `Deref(Mut)::deref(_mut)`\n@@ -140,7 +104,6 @@ impl<'tcx> Adjustment<'tcx> {\n pub struct OverloadedDeref<'tcx> {\n     pub region: ty::Region<'tcx>,\n     pub mutbl: hir::Mutability,\n-    pub target: Ty<'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n@@ -185,19 +148,3 @@ pub enum CustomCoerceUnsized {\n     /// Records the index of the field being coerced.\n     Struct(usize)\n }\n-\n-impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n-    pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                              autoref: Option<AutoBorrow<'tcx>>)\n-                              -> Ty<'tcx> {\n-        match autoref {\n-            None => self,\n-            Some(AutoBorrow::Ref(r, m)) => {\n-                tcx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n-            }\n-            Some(AutoBorrow::RawPtr(m)) => {\n-                tcx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n-            }\n-        }\n-    }\n-}"}, {"sha": "c6fb2a5871b058f432923aa40fecaecab8eb1732", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -221,7 +221,7 @@ pub struct TypeckTables<'tcx> {\n     /// other items.\n     pub node_substs: NodeMap<&'tcx Substs<'tcx>>,\n \n-    pub adjustments: NodeMap<ty::adjustment::Adjustment<'tcx>>,\n+    pub adjustments: NodeMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n@@ -343,16 +343,24 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_id_to_type_opt(expr.id)\n     }\n \n+    pub fn expr_adjustments(&self, expr: &hir::Expr)\n+                            -> &[ty::adjustment::Adjustment<'tcx>] {\n+        self.adjustments.get(&expr.id).map_or(&[], |a| &a[..])\n+    }\n+\n     /// Returns the type of `expr`, considering any `Adjustment`\n     /// entry recorded for that expression.\n     pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n-        self.adjustments.get(&expr.id)\n+        self.expr_adjustments(expr)\n+            .last()\n             .map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n     }\n \n     pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n-        self.adjustments.get(&expr.id)\n-            .map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n+        self.expr_adjustments(expr)\n+            .last()\n+            .map(|adj| adj.target)\n+            .or_else(|| self.expr_ty_opt(expr))\n     }\n \n     pub fn is_method_call(&self, expr: &hir::Expr) -> bool {"}, {"sha": "31412ad1ab22292397b9300593dc6276e649e2e9", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -224,13 +224,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n     type Lifted = ty::adjustment::Adjustment<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.kind).and_then(|kind| {\n-            tcx.lift(&(self.autoref, self.target)).map(|(autoref, target)| {\n-                ty::adjustment::Adjustment {\n-                    kind,\n-                    autoref,\n-                    unsize: self.unsize,\n-                    target,\n-                }\n+            tcx.lift(&self.target).map(|target| {\n+                ty::adjustment::Adjustment { kind, target }\n             })\n         })\n     }\n@@ -250,8 +245,13 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n                 Some(ty::adjustment::Adjust::ClosureFnPointer),\n             ty::adjustment::Adjust::MutToConstPointer =>\n                 Some(ty::adjustment::Adjust::MutToConstPointer),\n-            ty::adjustment::Adjust::Deref(ref autoderefs) => {\n-                tcx.lift(autoderefs).map(ty::adjustment::Adjust::Deref)\n+            ty::adjustment::Adjust::Unsize =>\n+                Some(ty::adjustment::Adjust::Unsize),\n+            ty::adjustment::Adjust::Deref(ref overloaded) => {\n+                tcx.lift(overloaded).map(ty::adjustment::Adjust::Deref)\n+            }\n+            ty::adjustment::Adjust::Borrow(ref autoref) => {\n+                tcx.lift(autoref).map(ty::adjustment::Adjust::Borrow)\n             }\n         }\n     }\n@@ -260,11 +260,10 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n     type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&(self.region, self.target)).map(|(region, target)| {\n+        tcx.lift(&self.region).map(|region| {\n             ty::adjustment::OverloadedDeref {\n                 region,\n                 mutbl: self.mutbl,\n-                target,\n             }\n         })\n     }\n@@ -685,15 +684,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjustment<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::adjustment::Adjustment {\n             kind: self.kind.fold_with(folder),\n-            autoref: self.autoref.fold_with(folder),\n-            unsize: self.unsize,\n             target: self.target.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.kind.visit_with(visitor) ||\n-        self.autoref.visit_with(visitor) ||\n         self.target.visit_with(visitor)\n     }\n }\n@@ -705,9 +701,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjust<'tcx> {\n             ty::adjustment::Adjust::ReifyFnPointer |\n             ty::adjustment::Adjust::UnsafeFnPointer |\n             ty::adjustment::Adjust::ClosureFnPointer |\n-            ty::adjustment::Adjust::MutToConstPointer => self.clone(),\n-            ty::adjustment::Adjust::Deref(ref autoderefs) => {\n-                ty::adjustment::Adjust::Deref(autoderefs.fold_with(folder))\n+            ty::adjustment::Adjust::MutToConstPointer |\n+            ty::adjustment::Adjust::Unsize => self.clone(),\n+            ty::adjustment::Adjust::Deref(ref overloaded) => {\n+                ty::adjustment::Adjust::Deref(overloaded.fold_with(folder))\n+            }\n+            ty::adjustment::Adjust::Borrow(ref autoref) => {\n+                ty::adjustment::Adjust::Borrow(autoref.fold_with(folder))\n             }\n         }\n     }\n@@ -718,9 +718,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjust<'tcx> {\n             ty::adjustment::Adjust::ReifyFnPointer |\n             ty::adjustment::Adjust::UnsafeFnPointer |\n             ty::adjustment::Adjust::ClosureFnPointer |\n-            ty::adjustment::Adjust::MutToConstPointer => false,\n-            ty::adjustment::Adjust::Deref(ref autoderefs) => {\n-                autoderefs.visit_with(visitor)\n+            ty::adjustment::Adjust::MutToConstPointer |\n+            ty::adjustment::Adjust::Unsize => false,\n+            ty::adjustment::Adjust::Deref(ref overloaded) => {\n+                overloaded.visit_with(visitor)\n+            }\n+            ty::adjustment::Adjust::Borrow(ref autoref) => {\n+                autoref.visit_with(visitor)\n             }\n         }\n     }\n@@ -731,12 +735,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::OverloadedDeref<'tcx> {\n         ty::adjustment::OverloadedDeref {\n             region: self.region.fold_with(folder),\n             mutbl: self.mutbl,\n-            target: self.target.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.region.visit_with(visitor) || self.target.visit_with(visitor)\n+        self.region.visit_with(visitor)\n     }\n }\n "}, {"sha": "12bfb1e02cf6f48cfefa41a7291706a54fb9b6b2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -889,22 +889,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             };\n \n             // Check for overloaded autoderef method calls.\n-            if let Some(&Adjustment {\n-                kind: Adjust::Deref(ref autoderefs), ..\n-            }) = cx.tables.adjustments.get(&id) {\n-                let mut source = cx.tables.expr_ty(expr);\n-                for &overloaded in autoderefs {\n-                    if let Some(deref) = overloaded {\n-                        let (def_id, substs) = deref.method_call(cx.tcx, source);\n-                        if method_call_refers_to_method(cx.tcx, method, def_id, substs, id) {\n-                            return true;\n-                        }\n-                        source = deref.target;\n-                    } else {\n-                        source = source.builtin_deref(true,\n-                            ty::LvaluePreference::NoPreference).unwrap().ty;\n+            let mut source = cx.tables.expr_ty(expr);\n+            for adjustment in cx.tables.expr_adjustments(expr) {\n+                if let Adjust::Deref(Some(deref)) = adjustment.kind {\n+                    let (def_id, substs) = deref.method_call(cx.tcx, source);\n+                    if method_call_refers_to_method(cx.tcx, method, def_id, substs, id) {\n+                        return true;\n                     }\n                 }\n+                source = adjustment.target;\n             }\n \n             // Check for method calls and overloaded operators."}, {"sha": "0c82679c307d3ad0c2cdd665689cd53cd90388a1", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -468,19 +468,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n             _ => return,\n         }\n \n-        if let Some(adjustment) = cx.tables.adjustments.get(&e.id) {\n-            match adjustment.autoref {\n-                Some(adjustment::AutoBorrow::Ref(_, hir::MutImmutable)) => {\n-                    cx.span_lint(UNUSED_ALLOCATION,\n-                                 e.span,\n-                                 \"unnecessary allocation, use & instead\");\n-                }\n-                Some(adjustment::AutoBorrow::Ref(_, hir::MutMutable)) => {\n-                    cx.span_lint(UNUSED_ALLOCATION,\n-                                 e.span,\n-                                 \"unnecessary allocation, use &mut instead\");\n-                }\n-                _ => (),\n+        for adj in cx.tables.expr_adjustments(e) {\n+            if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n+                let msg = match m {\n+                    hir::MutImmutable => \"unnecessary allocation, use & instead\",\n+                    hir::MutMutable => \"unnecessary allocation, use &mut instead\"\n+                };\n+                cx.span_lint(UNUSED_ALLOCATION, e.span, msg);\n             }\n         }\n     }"}, {"sha": "6d1509e7e24c73ba19e0205ade07f43f01223c61", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 102, "deletions": 169, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -17,6 +17,7 @@ use hair::cx::to_ref::ToRef;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::ty::subst::Subst;\n use rustc::hir;\n@@ -32,177 +33,13 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let mut expr = make_mirror_unadjusted(cx, self);\n-        let adj = cx.tables().adjustments.get(&self.id);\n-\n-        debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n-               expr,\n-               adj);\n \n         // Now apply adjustments, if any.\n-        match adj.map(|adj| (&adj.kind, adj.target)) {\n-            None => {}\n-            Some((&ty::adjustment::Adjust::ReifyFnPointer, adjusted_ty)) => {\n-                expr = Expr {\n-                    temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n-                    ty: adjusted_ty,\n-                    span: self.span,\n-                    kind: ExprKind::ReifyFnPointer { source: expr.to_ref() },\n-                };\n-            }\n-            Some((&ty::adjustment::Adjust::UnsafeFnPointer, adjusted_ty)) => {\n-                expr = Expr {\n-                    temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n-                    ty: adjusted_ty,\n-                    span: self.span,\n-                    kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n-                };\n-            }\n-            Some((&ty::adjustment::Adjust::ClosureFnPointer, adjusted_ty)) => {\n-                expr = Expr {\n-                    temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n-                    ty: adjusted_ty,\n-                    span: self.span,\n-                    kind: ExprKind::ClosureFnPointer { source: expr.to_ref() },\n-                };\n-            }\n-            Some((&ty::adjustment::Adjust::NeverToAny, adjusted_ty)) => {\n-                expr = Expr {\n-                    temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n-                    ty: adjusted_ty,\n-                    span: self.span,\n-                    kind: ExprKind::NeverToAny { source: expr.to_ref() },\n-                };\n-            }\n-            Some((&ty::adjustment::Adjust::MutToConstPointer, adjusted_ty)) => {\n-                expr = Expr {\n-                    temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n-                    ty: adjusted_ty,\n-                    span: self.span,\n-                    kind: ExprKind::Cast { source: expr.to_ref() },\n-                };\n-            }\n-            Some((&ty::adjustment::Adjust::Deref(ref autoderefs), _)) => {\n-                for &overloaded in autoderefs {\n-                    let source = expr.ty;\n-                    let target;\n-                    let kind = if let Some(deref) = overloaded {\n-                        debug!(\"make_mirror: overloaded autoderef ({:?})\", deref);\n-\n-                        expr = Expr {\n-                            temp_lifetime: temp_lifetime,\n-                            temp_lifetime_was_shrunk: was_shrunk,\n-                            ty: cx.tcx.mk_ref(deref.region,\n-                                              ty::TypeAndMut {\n-                                                  ty: source,\n-                                                  mutbl: deref.mutbl,\n-                                              }),\n-                            span: expr.span,\n-                            kind: ExprKind::Borrow {\n-                                region: deref.region,\n-                                borrow_kind: to_borrow_kind(deref.mutbl),\n-                                arg: expr.to_ref(),\n-                            },\n-                        };\n-\n-                        target = deref.target;\n-\n-                        let call = deref.method_call(cx.tcx, source);\n-                        overloaded_lvalue(cx,\n-                                          self,\n-                                          deref.target,\n-                                          Some(call),\n-                                          PassArgs::ByRef,\n-                                          expr.to_ref(),\n-                                          vec![])\n-                    } else {\n-                        match source.builtin_deref(true,\n-                                                   ty::LvaluePreference::NoPreference) {\n-                            Some(mt) => {\n-                                target = mt.ty;\n-                            }\n-                            None => {\n-                                span_bug!(self.span, \"autoderef for {} failed: {}\",\n-                                          self.id, source);\n-                            }\n-                        };\n-                        debug!(\"make_mirror: built-in autoderef\");\n-                        ExprKind::Deref { arg: expr.to_ref() }\n-                    };\n-                    debug!(\"make_mirror: autoderef target={:?}\", target);\n-                    expr = Expr {\n-                        temp_lifetime: temp_lifetime,\n-                        temp_lifetime_was_shrunk: was_shrunk,\n-                        ty: target,\n-                        span: self.span,\n-                        kind: kind,\n-                    };\n-                }\n-            }\n-        }\n-\n-        if let Some(adj) = adj {\n-            if let Some(autoref) = adj.autoref {\n-                let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n-                match autoref {\n-                    ty::adjustment::AutoBorrow::Ref(r, m) => {\n-                        expr = Expr {\n-                            temp_lifetime: temp_lifetime,\n-                            temp_lifetime_was_shrunk: was_shrunk,\n-                            ty: adjusted_ty,\n-                            span: self.span,\n-                            kind: ExprKind::Borrow {\n-                                region: r,\n-                                borrow_kind: to_borrow_kind(m),\n-                                arg: expr.to_ref(),\n-                            },\n-                        };\n-                    }\n-                    ty::adjustment::AutoBorrow::RawPtr(m) => {\n-                        // Convert this to a suitable `&foo` and\n-                        // then an unsafe coercion. Limit the region to be just this\n-                        // expression.\n-                        let region = ty::ReScope(expr_extent);\n-                        let region = cx.tcx.mk_region(region);\n-                        expr = Expr {\n-                            temp_lifetime: temp_lifetime,\n-                            temp_lifetime_was_shrunk: was_shrunk,\n-                            ty: cx.tcx.mk_ref(region,\n-                                              ty::TypeAndMut {\n-                                                    ty: expr.ty,\n-                                                    mutbl: m,\n-                                              }),\n-                            span: self.span,\n-                            kind: ExprKind::Borrow {\n-                                region: region,\n-                                borrow_kind: to_borrow_kind(m),\n-                                arg: expr.to_ref(),\n-                            },\n-                        };\n-                        expr = Expr {\n-                            temp_lifetime: temp_lifetime,\n-                            temp_lifetime_was_shrunk: was_shrunk,\n-                            ty: adjusted_ty,\n-                            span: self.span,\n-                            kind: ExprKind::Cast { source: expr.to_ref() },\n-                        };\n-                    }\n-                }\n-            }\n-\n-            if adj.unsize {\n-                expr = Expr {\n-                    temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n-                    ty: adj.target,\n-                    span: self.span,\n-                    kind: ExprKind::Unsize { source: expr.to_ref() },\n-                };\n-            }\n+        for adjustment in cx.tables().expr_adjustments(self) {\n+            debug!(\"make_mirror: expr={:?} applying adjustment={:?}\",\n+                   expr,\n+                   adjustment);\n+            expr = apply_adjustment(cx, self, expr, adjustment);\n         }\n \n         // Next, wrap this up in the expr's scope.\n@@ -236,6 +73,102 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     }\n }\n \n+fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                    hir_expr: &'tcx hir::Expr,\n+                                    mut expr: Expr<'tcx>,\n+                                    adjustment: &Adjustment<'tcx>)\n+                                    -> Expr<'tcx> {\n+    let Expr { temp_lifetime, temp_lifetime_was_shrunk, span, .. } = expr;\n+    let kind = match adjustment.kind {\n+        Adjust::ReifyFnPointer => {\n+            ExprKind::ReifyFnPointer { source: expr.to_ref() }\n+        }\n+        Adjust::UnsafeFnPointer => {\n+            ExprKind::UnsafeFnPointer { source: expr.to_ref() }\n+        }\n+        Adjust::ClosureFnPointer => {\n+            ExprKind::ClosureFnPointer { source: expr.to_ref() }\n+        }\n+        Adjust::NeverToAny => {\n+            ExprKind::NeverToAny { source: expr.to_ref() }\n+        }\n+        Adjust::MutToConstPointer => {\n+            ExprKind::Cast { source: expr.to_ref() }\n+        }\n+        Adjust::Deref(None) => {\n+            ExprKind::Deref { arg: expr.to_ref() }\n+        }\n+        Adjust::Deref(Some(deref)) => {\n+            let call = deref.method_call(cx.tcx, expr.ty);\n+\n+            expr = Expr {\n+                temp_lifetime,\n+                temp_lifetime_was_shrunk,\n+                ty: cx.tcx.mk_ref(deref.region,\n+                                  ty::TypeAndMut {\n+                                    ty: expr.ty,\n+                                    mutbl: deref.mutbl,\n+                                  }),\n+                span,\n+                kind: ExprKind::Borrow {\n+                    region: deref.region,\n+                    borrow_kind: to_borrow_kind(deref.mutbl),\n+                    arg: expr.to_ref(),\n+                },\n+            };\n+\n+            overloaded_lvalue(cx,\n+                              hir_expr,\n+                              adjustment.target,\n+                              Some(call),\n+                              PassArgs::ByValue,\n+                              expr.to_ref(),\n+                              vec![])\n+        }\n+        Adjust::Borrow(AutoBorrow::Ref(r, m)) => {\n+            ExprKind::Borrow {\n+                region: r,\n+                borrow_kind: to_borrow_kind(m),\n+                arg: expr.to_ref(),\n+            }\n+        }\n+        Adjust::Borrow(AutoBorrow::RawPtr(m)) => {\n+            // Convert this to a suitable `&foo` and\n+            // then an unsafe coercion. Limit the region to be just this\n+            // expression.\n+            let region = ty::ReScope(CodeExtent::Misc(hir_expr.id));\n+            let region = cx.tcx.mk_region(region);\n+            expr = Expr {\n+                temp_lifetime,\n+                temp_lifetime_was_shrunk,\n+                ty: cx.tcx.mk_ref(region,\n+                                  ty::TypeAndMut {\n+                                    ty: expr.ty,\n+                                    mutbl: m,\n+                                  }),\n+                span,\n+                kind: ExprKind::Borrow {\n+                    region: region,\n+                    borrow_kind: to_borrow_kind(m),\n+                    arg: expr.to_ref(),\n+                },\n+            };\n+            ExprKind::Cast { source: expr.to_ref() }\n+        }\n+        Adjust::Unsize => {\n+            ExprKind::Unsize { source: expr.to_ref() }\n+        }\n+    };\n+\n+    Expr {\n+        temp_lifetime,\n+        temp_lifetime_was_shrunk,\n+        ty: adjustment.target,\n+        span,\n+        kind,\n+    }\n+}\n+\n fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {"}, {"sha": "fecde3a636cda0893fddd203e8b089286995bb9b", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -441,17 +441,21 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n     use rustc::ty::adjustment::*;\n \n-    match v.tables.adjustments.get(&e.id).map(|adj| &adj.kind) {\n-        None |\n-        Some(&Adjust::NeverToAny) |\n-        Some(&Adjust::ReifyFnPointer) |\n-        Some(&Adjust::UnsafeFnPointer) |\n-        Some(&Adjust::ClosureFnPointer) |\n-        Some(&Adjust::MutToConstPointer) => {}\n-\n-        Some(&Adjust::Deref(ref autoderefs)) => {\n-            if autoderefs.iter().any(|overloaded| overloaded.is_some()) {\n-                v.promotable = false;\n+    for adjustment in v.tables.expr_adjustments(e) {\n+        match adjustment.kind {\n+            Adjust::NeverToAny |\n+            Adjust::ReifyFnPointer |\n+            Adjust::UnsafeFnPointer |\n+            Adjust::ClosureFnPointer |\n+            Adjust::MutToConstPointer |\n+            Adjust::Borrow(_) |\n+            Adjust::Unsize => {}\n+\n+            Adjust::Deref(ref overloaded) => {\n+                if overloaded.is_some() {\n+                    v.promotable = false;\n+                    break;\n+                }\n             }\n         }\n     }"}, {"sha": "92044737df1cad683325f6cf2913bd2200cb987d", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -18,11 +18,13 @@ use rustc::traits;\n use rustc::ty::{self, Ty, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc::ty::{LvaluePreference, NoPreference};\n-use rustc::ty::adjustment::{AutoBorrow, OverloadedDeref};\n+use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n \n use syntax_pos::Span;\n use syntax::symbol::Symbol;\n \n+use std::iter;\n+\n #[derive(Copy, Clone, Debug)]\n enum AutoderefKind {\n     Builtin,\n@@ -152,25 +154,26 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         self.steps.len()\n     }\n \n-    /// Returns the steps required in adjustments (overloaded deref calls).\n+    /// Returns the adjustment steps.\n     pub fn adjust_steps(&self, pref: LvaluePreference)\n-                        -> Vec<Option<OverloadedDeref<'tcx>>> {\n+                        -> Vec<Adjustment<'tcx>> {\n         self.fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(pref))\n     }\n \n     pub fn adjust_steps_as_infer_ok(&self, pref: LvaluePreference)\n-                                    -> InferOk<'tcx, Vec<Option<OverloadedDeref<'tcx>>>> {\n+                                    -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n+        let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty)\n+            .chain(iter::once(self.cur_ty));\n         let steps: Vec<_> = self.steps.iter().map(|&(source, kind)| {\n             if let AutoderefKind::Overloaded = kind {\n                 self.fcx.try_overloaded_deref(self.span, source, pref)\n-                    .and_then(|InferOk { value: (_, method), obligations: o }| {\n+                    .and_then(|InferOk { value: method, obligations: o }| {\n                         obligations.extend(o);\n                         if let ty::TyRef(region, mt) = method.sig.output().sty {\n                             Some(OverloadedDeref {\n                                 region,\n                                 mutbl: mt.mutbl,\n-                                target: mt.ty\n                             })\n                         } else {\n                             None\n@@ -179,6 +182,11 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n             } else {\n                 None\n             }\n+        }).zip(targets).map(|(autoderef, target)| {\n+            Adjustment {\n+                kind: Adjust::Deref(autoderef),\n+                target\n+            }\n         }).collect();\n \n         InferOk {\n@@ -213,9 +221,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 span: Span,\n                                 base_ty: Ty<'tcx>,\n                                 pref: LvaluePreference)\n-                                -> Option<InferOk<'tcx,\n-                                    (Option<AutoBorrow<'tcx>>,\n-                                     MethodCallee<'tcx>)>> {\n+                                -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         self.try_overloaded_lvalue_op(span, base_ty, &[], pref, LvalueOp::Deref)\n     }\n }"}, {"sha": "d5ee66a2f0a07e0fa5ee8f0c80cb6769a6d9c9fc", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -17,7 +17,7 @@ use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, LvaluePreference, Ty};\n use rustc::ty::subst::Subst;\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, OverloadedDeref};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use syntax::abi;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -96,8 +96,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                let autoderefs = autoderef.adjust_steps(LvaluePreference::NoPreference);\n-                self.apply_autoderef_adjustment(callee_expr.id, autoderefs, adjusted_ty);\n+                let adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+                self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n \n@@ -113,13 +113,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                    infer::FnCall,\n                                                                    &closure_ty)\n                         .0;\n-                    let autoderefs = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+                    let adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n                     self.record_deferred_call_resolution(def_id, DeferredCallResolution {\n-                        call_expr: call_expr,\n-                        callee_expr: callee_expr,\n-                        adjusted_ty: adjusted_ty,\n-                        autoderefs: autoderefs,\n-                        fn_sig: fn_sig.clone(),\n+                        call_expr,\n+                        callee_expr,\n+                        adjusted_ty,\n+                        adjustments,\n+                        fn_sig,\n                         closure_def_id: def_id,\n                     });\n                     return Some(CallStep::DeferredClosure(fn_sig));\n@@ -142,39 +142,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         self.try_overloaded_call_traits(call_expr, adjusted_ty).map(|(autoref, method)| {\n-            let autoderefs = autoderef.adjust_steps(LvaluePreference::NoPreference);\n-            self.apply_adjustment(callee_expr.id, Adjustment {\n-                kind: Adjust::Deref(autoderefs),\n-                autoref,\n-                unsize: false,\n-                target: method.sig.inputs()[0]\n-            });\n+            let mut adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+            adjustments.extend(autoref);\n+            self.apply_adjustments(callee_expr, adjustments);\n             CallStep::Overloaded(method)\n         })\n     }\n \n     fn try_overloaded_call_traits(&self,\n                                   call_expr: &hir::Expr,\n                                   adjusted_ty: Ty<'tcx>)\n-                                  -> Option<(Option<AutoBorrow<'tcx>>,\n+                                  -> Option<(Option<Adjustment<'tcx>>,\n                                              MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n-        for &(opt_trait_def_id, method_name) in\n-            &[(self.tcx.lang_items.fn_trait(), Symbol::intern(\"call\")),\n-              (self.tcx.lang_items.fn_mut_trait(), Symbol::intern(\"call_mut\")),\n-              (self.tcx.lang_items.fn_once_trait(), Symbol::intern(\"call_once\"))] {\n+        for &(opt_trait_def_id, method_name, borrow) in\n+            &[(self.tcx.lang_items.fn_trait(), Symbol::intern(\"call\"), true),\n+              (self.tcx.lang_items.fn_mut_trait(), Symbol::intern(\"call_mut\"), true),\n+              (self.tcx.lang_items.fn_once_trait(), Symbol::intern(\"call_once\"), false)] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,\n             };\n \n-            match self.lookup_method_in_trait_adjusted(call_expr.span,\n-                                                       method_name,\n-                                                       trait_def_id,\n-                                                       adjusted_ty,\n-                                                       None) {\n+            match self.lookup_method_in_trait(call_expr.span,\n+                                              method_name,\n+                                              trait_def_id,\n+                                              adjusted_ty,\n+                                              None) {\n                 None => continue,\n-                Some(ok) => return Some(self.register_infer_ok_obligations(ok))\n+                Some(ok) => {\n+                    let method = self.register_infer_ok_obligations(ok);\n+                    let mut autoref = None;\n+                    if borrow {\n+                        if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                            autoref = Some(Adjustment {\n+                                kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                                target: method.sig.inputs()[0]\n+                            });\n+                        }\n+                    }\n+                    return Some((autoref, method));\n+                }\n             }\n         }\n \n@@ -317,7 +325,7 @@ pub struct DeferredCallResolution<'gcx: 'tcx, 'tcx> {\n     call_expr: &'gcx hir::Expr,\n     callee_expr: &'gcx hir::Expr,\n     adjusted_ty: Ty<'tcx>,\n-    autoderefs: Vec<Option<OverloadedDeref<'tcx>>>,\n+    adjustments: Vec<Adjustment<'tcx>>,\n     fn_sig: ty::FnSig<'tcx>,\n     closure_def_id: DefId,\n }\n@@ -353,12 +361,9 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n \n                 fcx.demand_eqtype(self.call_expr.span, method_sig.output(), self.fn_sig.output());\n \n-                fcx.apply_adjustment(self.callee_expr.id, Adjustment {\n-                    kind: Adjust::Deref(self.autoderefs),\n-                    autoref,\n-                    unsize: false,\n-                    target: method_sig.inputs()[0]\n-                });\n+                let mut adjustments = self.adjustments;\n+                adjustments.extend(autoref);\n+                fcx.apply_adjustments(self.callee_expr, adjustments);\n \n                 fcx.write_method_call(self.call_expr.id, method_callee);\n             }"}, {"sha": "a962cdb8f728fe6236ac61359145f16497d53464", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 87, "deletions": 78, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n     }\n }\n \n-type CoerceResult<'tcx> = InferResult<'tcx, Adjustment<'tcx>>;\n+type CoerceResult<'tcx> = InferResult<'tcx, (Vec<Adjustment<'tcx>>, Ty<'tcx>)>;\n \n fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n@@ -108,24 +108,18 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n     }\n }\n \n-fn identity<'tcx>(target: Ty<'tcx>) -> Adjustment<'tcx> {\n-    simple(Adjust::Deref(vec![]))(target)\n-}\n+fn identity(_: Ty) -> Vec<Adjustment> { vec![] }\n \n-fn simple<'tcx>(kind: Adjust<'tcx>) -> impl FnOnce(Ty<'tcx>) -> Adjustment<'tcx> {\n-    move |target| Adjustment {\n-        kind,\n-        autoref: None,\n-        unsize: false,\n-        target\n-    }\n+fn simple<'tcx>(kind: Adjust<'tcx>) -> impl FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>> {\n+    move |target| vec![Adjustment { kind, target }]\n }\n \n-fn success<'tcx>(adj: Adjustment<'tcx>,\n+fn success<'tcx>(adj: Vec<Adjustment<'tcx>>,\n+                 target: Ty<'tcx>,\n                  obligations: traits::PredicateObligations<'tcx>)\n                  -> CoerceResult<'tcx> {\n     Ok(InferOk {\n-        value: adj,\n+        value: (adj, target),\n         obligations\n     })\n }\n@@ -153,10 +147,10 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     /// Unify two types (using sub or lub) and produce a specific coercion.\n     fn unify_and<F>(&self, a: Ty<'tcx>, b: Ty<'tcx>, f: F)\n                     -> CoerceResult<'tcx>\n-        where F: FnOnce(Ty<'tcx>) -> Adjustment<'tcx>\n+        where F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>\n     {\n         self.unify(&a, &b).and_then(|InferOk { value: ty, obligations }| {\n-            success(f(ty), obligations)\n+            success(f(ty), ty, obligations)\n         })\n     }\n \n@@ -166,7 +160,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n-            return success(identity(b), vec![]);\n+            return success(vec![], b, vec![]);\n         }\n \n         if a.is_never() {\n@@ -185,7 +179,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                     TypeVariableOrigin::AdjustmentType(self.cause.span));\n                 self.unify_and(&b, &diverging_ty, simple(Adjust::NeverToAny))\n             } else {\n-                success(simple(Adjust::NeverToAny)(b), vec![])\n+                success(simple(Adjust::NeverToAny)(b), b, vec![])\n             };\n         }\n \n@@ -407,34 +401,31 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n             assert_eq!(mt_b.mutbl, hir::MutImmutable); // can only coerce &T -> &U\n-            return success(identity(ty), obligations);\n+            return success(vec![], ty, obligations);\n         }\n \n+        let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n+        let InferOk { value: mut adjustments, obligations: o }\n+            = autoderef.adjust_steps_as_infer_ok(pref);\n+        obligations.extend(o);\n+        obligations.extend(autoderef.into_obligations());\n+\n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n         let r_borrow = match ty.sty {\n             ty::TyRef(r_borrow, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n-        let autoref = Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl));\n-\n-        let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n-        let InferOk { value: autoderefs, obligations: o }\n-            = autoderef.adjust_steps_as_infer_ok(pref);\n-        obligations.extend(o);\n-        obligations.extend(autoderef.into_obligations());\n+        adjustments.push(Adjustment {\n+            kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mt_b.mutbl)),\n+            target: ty\n+        });\n \n-        debug!(\"coerce_borrowed_pointer: succeeded ty={:?} autoderefs={:?} autoref={:?}\",\n+        debug!(\"coerce_borrowed_pointer: succeeded ty={:?} adjustments={:?}\",\n                ty,\n-               autoderefs,\n-               autoref);\n+               adjustments);\n \n-        success(Adjustment {\n-            kind: Adjust::Deref(autoderefs),\n-            autoref,\n-            unsize: false,\n-            target: ty\n-        }, obligations)\n+        success(adjustments, ty, obligations)\n     }\n \n \n@@ -459,33 +450,58 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // that, at which point we will need extra checks on the target here.\n \n         // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n-        let (source, reborrow) = match (&source.sty, &target.sty) {\n+        let reborrow = match (&source.sty, &target.sty) {\n             (&ty::TyRef(_, mt_a), &ty::TyRef(_, mt_b)) => {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n \n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n-                (mt_a.ty, Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl)))\n+                Some((Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    target: mt_a.ty\n+                }, Adjustment {\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mt_b.mutbl)),\n+                    target:  self.tcx.mk_ref(r_borrow, ty::TypeAndMut {\n+                        mutbl: mt_b.mutbl,\n+                        ty: mt_a.ty\n+                    })\n+                }))\n             }\n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n-                (mt_a.ty, Some(AutoBorrow::RawPtr(mt_b.mutbl)))\n+\n+                Some((Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    target: mt_a.ty\n+                }, Adjustment {\n+                    kind: Adjust::Borrow(AutoBorrow::RawPtr(mt_b.mutbl)),\n+                    target:  self.tcx.mk_ptr(ty::TypeAndMut {\n+                        mutbl: mt_b.mutbl,\n+                        ty: mt_a.ty\n+                    })\n+                }))\n             }\n-            _ => (source, None),\n+            _ => None,\n         };\n-        let coerce_source = source.adjust_for_autoref(self.tcx, reborrow);\n+        let coerce_source = reborrow.as_ref().map_or(source, |&(_, ref r)| r.target);\n \n         // Setup either a subtyping or a LUB relationship between\n         // the `CoerceUnsized` target type and the expected type.\n         // We only have the latter, so we use an inference variable\n         // for the former and let type inference do the rest.\n         let origin = TypeVariableOrigin::MiscVariable(self.cause.span);\n         let coerce_target = self.next_ty_var(origin);\n-        let mut coercion = self.unify_and(coerce_target, target, |target| Adjustment {\n-            kind: Adjust::Deref(if reborrow.is_some() { vec![None] } else { vec![] }),\n-            autoref: reborrow,\n-            unsize: true,\n-            target\n+        let mut coercion = self.unify_and(coerce_target, target, |target| {\n+            let unsize = Adjustment {\n+                kind: Adjust::Unsize,\n+                target\n+            };\n+            match reborrow {\n+                None => vec![unsize],\n+                Some((ref deref, ref autoref)) => {\n+                    vec![deref.clone(), autoref.clone(), unsize]\n+                }\n+            }\n         })?;\n \n         let mut selcx = traits::SelectionContext::new(self);\n@@ -546,8 +562,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                  to_unsafe: F,\n                                  normal: G)\n                                  -> CoerceResult<'tcx>\n-        where F: FnOnce(Ty<'tcx>) -> Adjustment<'tcx>,\n-              G: FnOnce(Ty<'tcx>) -> Adjustment<'tcx>\n+        where F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n+              G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>\n     {\n         if let ty::TyFnPtr(fn_ty_b) = b.sty {\n             match (fn_ty_a.unsafety(), fn_ty_b.unsafety()) {\n@@ -668,11 +684,14 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // representation, we still register an Adjust::DerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n         if is_ref {\n-            self.unify_and(a_unsafe, b, |target| Adjustment {\n-                kind: Adjust::Deref(vec![None]),\n-                autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n-                unsize: false,\n-                target\n+            self.unify_and(a_unsafe, b, |target| {\n+                vec![Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    target: mt_a.ty\n+                }, Adjustment {\n+                    kind: Adjust::Borrow(AutoBorrow::RawPtr(mutbl_b)),\n+                    target\n+                }]\n             })\n         } else if mt_a.mutbl != mutbl_b {\n             self.unify_and(a_unsafe, b, simple(Adjust::MutToConstPointer))\n@@ -707,12 +726,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let coerce = Coerce::new(self, cause);\n         let ok = self.commit_if_ok(|_| coerce.coerce(source, target))?;\n \n-        let adjustment = self.register_infer_ok_obligations(ok);\n-        self.apply_adjustment(expr.id, adjustment);\n-\n-        // We should now have added sufficient adjustments etc to\n-        // ensure that the type of expression, post-adjustment, is\n-        // a subtype of target.\n+        let (adjustments, _) = self.register_infer_ok_obligations(ok);\n+        self.apply_adjustments(expr, adjustments);\n         Ok(target)\n     }\n \n@@ -781,12 +796,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n                     // The only adjustment that can produce an fn item is\n                     // `NeverToAny`, so this should always be valid.\n-                    self.apply_adjustment(expr.id, Adjustment {\n+                    self.apply_adjustments(expr, vec![Adjustment {\n                         kind: Adjust::ReifyFnPointer,\n-                        autoref: None,\n-                        unsize: false,\n                         target: fn_ptr\n-                    });\n+                    }]);\n                 }\n                 return Ok(fn_ptr);\n             }\n@@ -803,9 +816,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let result = self.commit_if_ok(|_| coerce.coerce(new_ty, prev_ty));\n             match result {\n                 Ok(ok) => {\n-                    let adjustment = self.register_infer_ok_obligations(ok);\n-                    let target = adjustment.target;\n-                    self.apply_adjustment(new.id, adjustment);\n+                    let (adjustments, target) = self.register_infer_ok_obligations(ok);\n+                    self.apply_adjustments(new, adjustments);\n                     return Ok(target);\n                 }\n                 Err(e) => first_error = Some(e),\n@@ -817,26 +829,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n         for expr in exprs {\n             let expr = expr.as_coercion_site();\n-            let noop = match self.tables.borrow().adjustments.get(&expr.id) {\n-                Some(&Adjustment {\n-                    kind: Adjust::Deref(ref autoderefs),\n-                    autoref: Some(AutoBorrow::Ref(_, mutbl_adj)),\n-                    unsize: false,\n-                    target: _\n-                }) if autoderefs.len() == 1 => {\n+            let noop = match self.tables.borrow().expr_adjustments(expr) {\n+                &[\n+                    Adjustment { kind: Adjust::Deref(_), .. },\n+                    Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }\n+                ] => {\n                     match self.node_ty(expr.id).sty {\n                         ty::TyRef(_, mt_orig) => {\n                             // Reborrow that we can safely ignore, because\n-                            // the next adjustment can only be a DerefRef\n+                            // the next adjustment can only be a Deref\n                             // which will be merged into it.\n                             mutbl_adj == mt_orig.mutbl\n                         }\n                         _ => false,\n                     }\n                 }\n-                Some(&Adjustment { kind: Adjust::NeverToAny, .. }) => true,\n-                Some(_) => false,\n-                None => true,\n+                &[Adjustment { kind: Adjust::NeverToAny, .. }] | &[] => true,\n+                _ => false,\n             };\n \n             if !noop {\n@@ -860,12 +869,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             Ok(ok) => {\n-                let adjustment = self.register_infer_ok_obligations(ok);\n+                let (adjustments, target) = self.register_infer_ok_obligations(ok);\n                 for expr in exprs {\n                     let expr = expr.as_coercion_site();\n-                    self.apply_adjustment(expr.id, adjustment.clone());\n+                    self.apply_adjustments(expr, adjustments.clone());\n                 }\n-                Ok(adjustment.target)\n+                Ok(target)\n             }\n         }\n     }"}, {"sha": "34e8d6b95a92679160faf150ba420f54d890080a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 81, "deletions": 52, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -15,7 +15,7 @@ use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, OverloadedDeref};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk};\n use syntax_pos::Span;\n@@ -118,40 +118,49 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                       unadjusted_self_ty: Ty<'tcx>,\n                       pick: &probe::Pick<'tcx>)\n                       -> Ty<'tcx> {\n-        let autoref = if let Some(mutbl) = pick.autoref {\n+        // Commit the autoderefs by calling `autoderef` again, but this\n+        // time writing the results into the various tables.\n+        let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n+        let (_, n) = autoderef.nth(pick.autoderefs).unwrap();\n+        assert_eq!(n, pick.autoderefs);\n+\n+        let mut adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+\n+        let mut target = autoderef.unambiguous_final_ty();\n+\n+        if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n-            Some(AutoBorrow::Ref(region, mutbl))\n+            target = self.tcx.mk_ref(region, ty::TypeAndMut {\n+                mutbl,\n+                ty: target\n+            });\n+            adjustments.push(Adjustment {\n+                kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                target\n+            });\n+\n+            if let Some(unsize_target) = pick.unsize {\n+                target = self.tcx.mk_ref(region, ty::TypeAndMut {\n+                    mutbl,\n+                    ty: unsize_target\n+                });\n+                adjustments.push(Adjustment {\n+                    kind: Adjust::Unsize,\n+                    target\n+                });\n+            }\n         } else {\n             // No unsizing should be performed without autoref (at\n             // least during method dispach). This is because we\n             // currently only unsize `[T;N]` to `[T]`, and naturally\n             // that must occur being a reference.\n             assert!(pick.unsize.is_none());\n-            None\n-        };\n-\n-\n-        // Commit the autoderefs by calling `autoderef` again, but this\n-        // time writing the results into the various tables.\n-        let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n-        let (autoderefd_ty, n) = autoderef.nth(pick.autoderefs).unwrap();\n-        assert_eq!(n, pick.autoderefs);\n-\n-        let autoderefs = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+        }\n \n-        autoderef.unambiguous_final_ty();\n         autoderef.finalize();\n \n-        let target = pick.unsize.unwrap_or(autoderefd_ty);\n-        let target = target.adjust_for_autoref(self.tcx, autoref);\n-\n-        // Write out the final adjustment.\n-        self.apply_adjustment(self.self_expr.id, Adjustment {\n-            kind: Adjust::Deref(autoderefs),\n-            autoref,\n-            unsize: pick.unsize.is_some(),\n-            target,\n-        });\n+        // Write out the final adjustments.\n+        self.apply_adjustments(self.self_expr, adjustments);\n \n         target\n     }\n@@ -436,17 +445,22 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             // Fix up the autoderefs. Autorefs can only occur immediately preceding\n             // overloaded lvalue ops, and will be fixed by them in order to get\n             // the correct region.\n-            let expr_ty = self.node_ty(expr.id);\n-            if let Some(adj) = self.tables.borrow_mut().adjustments.get_mut(&expr.id) {\n-                if let Adjust::Deref(ref mut autoderefs) = adj.kind {\n-                    let mut autoderef = self.autoderef(expr.span, expr_ty);\n-                    autoderef.nth(autoderefs.len()).unwrap_or_else(|| {\n-                        span_bug!(expr.span,\n-                                \"expr was deref-able as {:?} but now isn't?\",\n-                                autoderefs);\n-                    });\n-                    *autoderefs = autoderef.adjust_steps(LvaluePreference::PreferMutLvalue);\n-                    autoderef.finalize();\n+            let mut source = self.node_ty(expr.id);\n+            if let Some(adjustments) = self.tables.borrow_mut().adjustments.get_mut(&expr.id) {\n+                let pref = LvaluePreference::PreferMutLvalue;\n+                for adjustment in adjustments {\n+                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n+                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, pref) {\n+                            let method = self.register_infer_ok_obligations(ok);\n+                            if let ty::TyRef(region, mt) = method.sig.output().sty {\n+                                *deref = OverloadedDeref {\n+                                    region,\n+                                    mutbl: mt.mutbl\n+                                };\n+                            }\n+                        }\n+                    }\n+                    source = adjustment.target;\n                 }\n             }\n \n@@ -478,7 +492,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             return\n         }\n \n-        let base_ty = self.tables.borrow().adjustments.get(&base_expr.id)\n+        let base_ty = self.tables.borrow().expr_adjustments(base_expr).last()\n             .map_or_else(|| self.node_ty(expr.id), |adj| adj.target);\n         let base_ty = self.resolve_type_vars_if_possible(&base_ty);\n \n@@ -489,28 +503,43 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         let method = self.try_overloaded_lvalue_op(\n             expr.span, base_ty, arg_tys, PreferMutLvalue, op);\n-        let ok = match method {\n-            Some(method) => method,\n+        let method = match method {\n+            Some(ok) => self.register_infer_ok_obligations(ok),\n             None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\")\n         };\n-        let (_, method) = self.register_infer_ok_obligations(ok);\n         debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n         self.write_method_call(expr.id, method);\n \n+        let (region, mutbl) = if let ty::TyRef(r, mt) = method.sig.inputs()[0].sty {\n+            (r, mt.mutbl)\n+        } else {\n+            span_bug!(expr.span, \"input to lvalue op is not a ref?\");\n+        };\n+\n         // Convert the autoref in the base expr to mutable with the correct\n         // region and mutability.\n-        if let Some(&mut Adjustment {\n-            ref mut target,\n-            autoref: Some(AutoBorrow::Ref(ref mut r, ref mut mutbl)), ..\n-        }) = self.tables.borrow_mut().adjustments.get_mut(&base_expr.id) {\n-            debug!(\"convert_lvalue_op_to_mutable: converting autoref of {:?}\", target);\n-\n-            *target = method.sig.inputs()[0];\n-            if let ty::TyRef(r_, mt) = target.sty {\n-                *r = r_;\n-                *mutbl = mt.mutbl;\n-            } else {\n-                span_bug!(expr.span, \"input to lvalue op is not a ref?\");\n+        let base_expr_ty = self.node_ty(base_expr.id);\n+        if let Some(adjustments) = self.tables.borrow_mut().adjustments.get_mut(&base_expr.id) {\n+            let mut source = base_expr_ty;\n+            for adjustment in &mut adjustments[..] {\n+                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n+                    debug!(\"convert_lvalue_op_to_mutable: converting autoref {:?}\", adjustment);\n+                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n+                    adjustment.target = self.tcx.mk_ref(region, ty::TypeAndMut {\n+                        ty: source,\n+                        mutbl\n+                    });\n+                }\n+                source = adjustment.target;\n+            }\n+\n+            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n+            match adjustments[..] {\n+                [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. },\n+                 Adjustment { kind: Adjust::Unsize, ref mut target }] => {\n+                    *target = method.sig.inputs()[0];\n+                }\n+                _ => {}\n             }\n         }\n     }"}, {"sha": "b0ac61d2cc34af7aad8685a55787de77ded36db3", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 16, "deletions": 36, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -16,7 +16,6 @@ use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::ty::adjustment::AutoBorrow;\n use rustc::ty::subst::Subst;\n use rustc::infer::{self, InferOk};\n \n@@ -165,26 +164,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                supplied_method_types))\n     }\n \n-    /// `lookup_in_trait_adjusted` is used for overloaded operators.\n+    /// `lookup_method_in_trait` is used for overloaded operators.\n     /// It does a very narrow slice of what the normal probe/confirm path does.\n     /// In particular, it doesn't really do any probing: it simply constructs\n     /// an obligation for aparticular trait with the given self-type and checks\n     /// whether that trait is implemented.\n     ///\n     /// FIXME(#18741) -- It seems likely that we can consolidate some of this\n-    /// code with the other method-lookup code. In particular, autoderef on\n-    /// index is basically identical to autoderef with normal probes, except\n-    /// that the test also looks for built-in indexing. Also, the second half of\n-    /// this method is basically the same as confirmation.\n-    pub fn lookup_method_in_trait_adjusted(&self,\n-                                           span: Span,\n-                                           m_name: ast::Name,\n-                                           trait_def_id: DefId,\n-                                           self_ty: ty::Ty<'tcx>,\n-                                           opt_input_types: Option<&[ty::Ty<'tcx>]>)\n-                                           -> Option<InferOk<'tcx,\n-                                                (Option<AutoBorrow<'tcx>>,\n-                                                 MethodCallee<'tcx>)>> {\n+    /// code with the other method-lookup code. In particular, the second half\n+    /// of this method is basically the same as confirmation.\n+    pub fn lookup_method_in_trait(&self,\n+                                  span: Span,\n+                                  m_name: ast::Name,\n+                                  trait_def_id: DefId,\n+                                  self_ty: ty::Ty<'tcx>,\n+                                  opt_input_types: Option<&[ty::Ty<'tcx>]>)\n+                                  -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(\"lookup_in_trait_adjusted(self_ty={:?}, \\\n                 m_name={}, trait_def_id={:?})\",\n                self_ty,\n@@ -237,8 +232,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let original_method_ty = tcx.type_of(def_id);\n-        let fn_sig = original_method_ty.fn_sig();\n+        let fn_sig = tcx.type_of(def_id).fn_sig();\n         let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n                                                                     infer::FnCall,\n                                                                     &fn_sig).0;\n@@ -249,11 +243,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 value\n             }\n         };\n-        let method_ty = tcx.mk_fn_def(def_id, substs, ty::Binder(fn_sig));\n-\n-        debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n-               method_ty,\n-               obligation);\n \n         // Register obligations for the parameters.  This will include the\n         // `Self` parameter, which in turn has a bound of the main trait,\n@@ -276,21 +265,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         obligations.extend(traits::predicates_for_generics(cause.clone(), &bounds));\n \n         // Also add an obligation for the method type being well-formed.\n+        let method_ty = tcx.mk_fn_ptr(ty::Binder(fn_sig));\n+        debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n+               method_ty,\n+               obligation);\n         obligations.push(traits::Obligation::new(cause, ty::Predicate::WellFormed(method_ty)));\n \n-        let autoref = match (&original_method_ty.fn_sig().input(0).skip_binder().sty,\n-                             &fn_sig.inputs()[0].sty) {\n-            (&ty::TyRef(..), &ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ })) => {\n-                // Trait method is fn(&self) or fn(&mut self), need an\n-                // autoref. Pull the region etc out of the type of first argument.\n-                Some(AutoBorrow::Ref(region, mutbl))\n-            }\n-            _ => {\n-                // Trait method is fn(self), no transformation needed.\n-                None\n-            }\n-        };\n-\n         let callee = MethodCallee {\n             def_id: def_id,\n             substs: trait_ref.substs,\n@@ -301,7 +281,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         Some(InferOk {\n             obligations,\n-            value: (autoref, callee)\n+            value: callee\n         })\n     }\n "}, {"sha": "813e199f85a750798be6b2d5c940c5a72019bd76", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 59, "deletions": 77, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -96,7 +96,7 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility};\n-use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, OverloadedDeref};\n+use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n@@ -1774,48 +1774,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn apply_autoderef_adjustment(&self,\n-                                      node_id: ast::NodeId,\n-                                      autoderefs: Vec<Option<OverloadedDeref<'tcx>>>,\n-                                      adjusted_ty: Ty<'tcx>) {\n-        self.apply_adjustment(node_id, Adjustment {\n-            kind: Adjust::Deref(autoderefs),\n-            autoref: None,\n-            unsize: false,\n-            target: adjusted_ty\n-        });\n-    }\n-\n-    pub fn apply_adjustment(&self, node_id: ast::NodeId, adj: Adjustment<'tcx>) {\n-        debug!(\"apply_adjustment(node_id={}, adj={:?})\", node_id, adj);\n+    pub fn apply_adjustments(&self, expr: &hir::Expr, adj: Vec<Adjustment<'tcx>>) {\n+        debug!(\"apply_adjustments(expr={:?}, adj={:?})\", expr, adj);\n \n-        if adj.is_identity() {\n+        if adj.is_empty() {\n             return;\n         }\n \n-        match self.tables.borrow_mut().adjustments.entry(node_id) {\n+        match self.tables.borrow_mut().adjustments.entry(expr.id) {\n             Entry::Vacant(entry) => { entry.insert(adj); },\n             Entry::Occupied(mut entry) => {\n                 debug!(\" - composing on top of {:?}\", entry.get());\n-                match (entry.get(), &adj) {\n+                match (&entry.get()[..], &adj[..]) {\n                     // Applying any adjustment on top of a NeverToAny\n                     // is a valid NeverToAny adjustment, because it can't\n                     // be reached.\n-                    (&Adjustment { kind: Adjust::NeverToAny, .. }, _) => return,\n-                    (&Adjustment {\n-                        kind: Adjust::Deref(ref old),\n-                        autoref: Some(AutoBorrow::Ref(..)),\n-                        unsize: false, ..\n-                    }, &Adjustment {\n-                        kind: Adjust::Deref(ref new), ..\n-                    }) if old.len() == 1 && new.len() >= 1 => {\n+                    (&[Adjustment { kind: Adjust::NeverToAny, .. }], _) => return,\n+                    (&[\n+                        Adjustment { kind: Adjust::Deref(_), .. },\n+                        Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. },\n+                    ], &[\n+                        Adjustment { kind: Adjust::Deref(_), .. },\n+                        .. // Any following adjustments are allowed.\n+                    ]) => {\n                         // A reborrow has no effect before a dereference.\n                     }\n                     // FIXME: currently we never try to compose autoderefs\n                     // and ReifyFnPointer/UnsafeFnPointer, but we could.\n                     _ =>\n-                        bug!(\"while adjusting {}, can't compose {:?} and {:?}\",\n-                             node_id, entry.get(), adj)\n+                        bug!(\"while adjusting {:?}, can't compose {:?} and {:?}\",\n+                             expr, entry.get(), adj)\n                 };\n                 *entry.get_mut() = adj;\n             }\n@@ -2189,7 +2177,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       index_ty: Ty<'tcx>)\n                       -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n     {\n-        let mut adjusted_ty = autoderef.unambiguous_final_ty();\n+        let adjusted_ty = autoderef.unambiguous_final_ty();\n         debug!(\"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n                                index_ty={:?})\",\n                expr,\n@@ -2202,19 +2190,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match (adjusted_ty.builtin_index(), &index_ty.sty) {\n             (Some(ty), &ty::TyUint(ast::UintTy::Us)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n                 debug!(\"try_index_step: success, using built-in indexing\");\n-                let autoderefs = autoderef.adjust_steps(lvalue_pref);\n-                self.apply_autoderef_adjustment(\n-                    base_expr.id, autoderefs, adjusted_ty);\n+                let adjustments = autoderef.adjust_steps(lvalue_pref);\n+                self.apply_adjustments(base_expr, adjustments);\n                 return Some((self.tcx.types.usize, ty));\n             }\n             _ => {}\n         }\n \n         for &unsize in &[false, true] {\n+            let mut self_ty = adjusted_ty;\n             if unsize {\n                 // We only unsize arrays here.\n                 if let ty::TyArray(element_ty, _) = adjusted_ty.sty {\n-                    adjusted_ty = self.tcx.mk_slice(element_ty);\n+                    self_ty = self.tcx.mk_slice(element_ty);\n                 } else {\n                     continue;\n                 }\n@@ -2225,19 +2213,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // If some lookup succeeded, install method in table\n             let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n             let method = self.try_overloaded_lvalue_op(\n-                expr.span, adjusted_ty, &[input_ty], lvalue_pref, LvalueOp::Index);\n+                expr.span, self_ty, &[input_ty], lvalue_pref, LvalueOp::Index);\n \n             let result = method.map(|ok| {\n                 debug!(\"try_index_step: success, using overloaded indexing\");\n-                let (autoref, method) = self.register_infer_ok_obligations(ok);\n-\n-                let autoderefs = autoderef.adjust_steps(lvalue_pref);\n-                self.apply_adjustment(base_expr.id, Adjustment {\n-                    kind: Adjust::Deref(autoderefs),\n-                    autoref,\n-                    unsize,\n-                    target: method.sig.inputs()[0]\n-                });\n+                let method = self.register_infer_ok_obligations(ok);\n+\n+                let mut adjustments = autoderef.adjust_steps(lvalue_pref);\n+                if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                        target: self.tcx.mk_ref(region, ty::TypeAndMut {\n+                            mutbl: mt.mutbl,\n+                            ty: adjusted_ty\n+                        })\n+                    });\n+                }\n+                if unsize {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Unsize,\n+                        target: method.sig.inputs()[0]\n+                    });\n+                }\n+                self.apply_adjustments(base_expr, adjustments);\n \n                 self.write_method_call(expr.id, method);\n                 (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n@@ -2270,9 +2268,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 arg_tys: &[Ty<'tcx>],\n                                 lvalue_pref: LvaluePreference,\n                                 op: LvalueOp)\n-                                -> Option<InferOk<'tcx,\n-                                    (Option<AutoBorrow<'tcx>>,\n-                                     MethodCallee<'tcx>)>>\n+                                -> Option<InferOk<'tcx, MethodCallee<'tcx>>>\n     {\n         debug!(\"try_overloaded_lvalue_op({:?},{:?},{:?},{:?})\",\n                span,\n@@ -2284,11 +2280,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let (mut_tr, mut_op) = self.resolve_lvalue_op(op, true);\n         let method = match (lvalue_pref, mut_tr) {\n             (PreferMutLvalue, Some(trait_did)) => {\n-                self.lookup_method_in_trait_adjusted(span,\n-                                                     mut_op,\n-                                                     trait_did,\n-                                                     base_ty,\n-                                                     Some(arg_tys))\n+                self.lookup_method_in_trait(span, mut_op, trait_did, base_ty, Some(arg_tys))\n             }\n             _ => None,\n         };\n@@ -2297,11 +2289,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let (imm_tr, imm_op) = self.resolve_lvalue_op(op, false);\n         let method = match (method, imm_tr) {\n             (None, Some(trait_did)) => {\n-                self.lookup_method_in_trait_adjusted(span,\n-                                                     imm_op,\n-                                                     trait_did,\n-                                                     base_ty,\n-                                                     Some(arg_tys))\n+                self.lookup_method_in_trait(span, imm_op, trait_did, base_ty, Some(arg_tys))\n             }\n             (method, _) => method,\n         };\n@@ -2645,12 +2633,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n-            self.apply_adjustment(expr.id, Adjustment {\n+            self.apply_adjustments(expr, vec![Adjustment {\n                 kind: Adjust::NeverToAny,\n-                autoref: None,\n-                unsize: false,\n                 target: adj_ty\n-            });\n+            }]);\n             ty = adj_ty;\n         }\n \n@@ -2895,8 +2881,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let autoderefs = autoderef.adjust_steps(lvalue_pref);\n-                            self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n+                            let adjustments = autoderef.adjust_steps(lvalue_pref);\n+                            self.apply_adjustments(base, adjustments);\n                             autoderef.finalize();\n \n                             self.tcx.check_stability(field.did, expr.id, expr.span);\n@@ -3029,8 +3015,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if let Some(field_ty) = field {\n-                let autoderefs = autoderef.adjust_steps(lvalue_pref);\n-                self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n+                let adjustments = autoderef.adjust_steps(lvalue_pref);\n+                self.apply_adjustments(base, adjustments);\n                 autoderef.finalize();\n                 return field_ty;\n             }\n@@ -3446,13 +3432,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             oprnd_t = mt.ty;\n                         } else if let Some(ok) = self.try_overloaded_deref(\n                                 expr.span, oprnd_t, lvalue_pref) {\n-                            let (autoref, method) = self.register_infer_ok_obligations(ok);\n-                            self.apply_adjustment(oprnd.id, Adjustment {\n-                                kind: Adjust::Deref(vec![]),\n-                                autoref,\n-                                unsize: false,\n-                                target: method.sig.inputs()[0]\n-                            });\n+                            let method = self.register_infer_ok_obligations(ok);\n+                            if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                                self.apply_adjustments(oprnd, vec![Adjustment {\n+                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                                    target: method.sig.inputs()[0]\n+                                }]);\n+                            }\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n                             self.write_method_call(expr.id, method);\n                         } else {\n@@ -3466,9 +3452,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     hir::UnNot => {\n                         oprnd_t = self.structurally_resolved_type(oprnd.span,\n                                                                   oprnd_t);\n-                        let result = self.check_user_unop(\"!\", \"not\",\n-                                                          tcx.lang_items.not_trait(),\n-                                                          expr, &oprnd, oprnd_t, unop);\n+                        let result = self.check_user_unop(expr, &oprnd, oprnd_t, unop);\n                         // If it's builtin, we can reuse the type, this helps inference.\n                         if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n                             oprnd_t = result;\n@@ -3477,9 +3461,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     hir::UnNeg => {\n                         oprnd_t = self.structurally_resolved_type(oprnd.span,\n                                                                   oprnd_t);\n-                        let result = self.check_user_unop(\"-\", \"neg\",\n-                                                          tcx.lang_items.neg_trait(),\n-                                                          expr, &oprnd, oprnd_t, unop);\n+                        let result = self.check_user_unop(expr, &oprnd, oprnd_t, unop);\n                         // If it's builtin, we can reuse the type, this helps inference.\n                         if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n                             oprnd_t = result;"}, {"sha": "cbb89355bf952099ab168e23794f1281f703a2fe", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -11,13 +11,11 @@\n //! Code related to processing overloaded binary and unary operators.\n \n use super::FnCtxt;\n-use hir::def_id::DefId;\n-use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue, TypeVariants};\n+use rustc::ty::{self, Ty, TypeFoldable, PreferMutLvalue, TypeVariants};\n use rustc::ty::TypeVariants::{TyStr, TyRef};\n-use rustc::ty::adjustment::{Adjustment, Adjust};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n-use syntax::ast;\n use syntax::symbol::Symbol;\n use rustc::hir;\n \n@@ -175,8 +173,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                lhs_ty,\n                is_assign);\n \n-        let (name, trait_def_id) = self.name_and_trait_def_id(op, is_assign);\n-\n         // NB: As we have not yet type-checked the RHS, we don't have the\n         // type at hand. Make a variable to represent it. The whole reason\n         // for this indirection is so that, below, we can check the expr\n@@ -186,8 +182,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let rhs_ty_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(rhs_expr.span));\n \n         let return_ty = self.lookup_op_method(expr, lhs_ty, &[rhs_ty_var],\n-                                              Symbol::intern(name), trait_def_id,\n-                                              lhs_expr);\n+                                              Op::Binary(op, is_assign), lhs_expr);\n \n         // see `NB` above\n         let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n@@ -216,8 +211,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n                             if !self.infcx.type_moves_by_default(ty_mut.ty, lhs_expr.span) &&\n                                 self.lookup_op_method(expr, ty_mut.ty, &[rhs_ty],\n-                                    Symbol::intern(name), trait_def_id,\n-                                    lhs_expr).is_ok() {\n+                                                      Op::Binary(op, is_assign), lhs_expr).is_ok() {\n                                 err.note(\n                                     &format!(\n                                         \"this is a reference to a type that `{}` can be applied \\\n@@ -303,38 +297,38 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_user_unop(&self,\n-                           op_str: &str,\n-                           mname: &str,\n-                           trait_did: Option<DefId>,\n                            ex: &'gcx hir::Expr,\n                            operand_expr: &'gcx hir::Expr,\n                            operand_ty: Ty<'tcx>,\n                            op: hir::UnOp)\n                            -> Ty<'tcx>\n     {\n         assert!(op.is_by_value());\n-        let mname = Symbol::intern(mname);\n-        match self.lookup_op_method(ex, operand_ty, &[], mname, trait_did, operand_expr) {\n+        match self.lookup_op_method(ex, operand_ty, &[], Op::Unary(op), operand_expr) {\n             Ok(t) => t,\n             Err(()) => {\n                 let actual = self.resolve_type_vars_if_possible(&operand_ty);\n                 if !actual.references_error() {\n                     struct_span_err!(self.tcx.sess, ex.span, E0600,\n                                      \"cannot apply unary operator `{}` to type `{}`\",\n-                                     op_str, actual).emit();\n+                                     op.as_str(), actual).emit();\n                 }\n                 self.tcx.types.err\n             }\n         }\n     }\n \n-    fn name_and_trait_def_id(&self,\n-                             op: hir::BinOp,\n-                             is_assign: IsAssign)\n-                             -> (&'static str, Option<DefId>) {\n+    fn lookup_op_method(&self,\n+                        expr: &'gcx hir::Expr,\n+                        lhs_ty: Ty<'tcx>,\n+                        other_tys: &[Ty<'tcx>],\n+                        op: Op,\n+                        lhs_expr: &'a hir::Expr)\n+                        -> Result<Ty<'tcx>,()>\n+    {\n         let lang = &self.tcx.lang_items;\n \n-        if let IsAssign::Yes = is_assign {\n+        let (opname, trait_did) = if let Op::Binary(op, IsAssign::Yes) = op {\n             match op.node {\n                 hir::BiAdd => (\"add_assign\", lang.add_assign_trait()),\n                 hir::BiSub => (\"sub_assign\", lang.sub_assign_trait()),\n@@ -355,7 +349,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               op.node.as_str())\n                 }\n             }\n-        } else {\n+        } else if let Op::Binary(op, IsAssign::No) = op {\n             match op.node {\n                 hir::BiAdd => (\"add\", lang.add_trait()),\n                 hir::BiSub => (\"sub\", lang.sub_trait()),\n@@ -377,18 +371,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     span_bug!(op.span, \"&& and || are not overloadable\")\n                 }\n             }\n-        }\n-    }\n+        } else if let Op::Unary(hir::UnNot) = op {\n+            (\"not\", lang.not_trait())\n+        } else if let Op::Unary(hir::UnNeg) = op {\n+            (\"neg\", lang.neg_trait())\n+        } else {\n+            bug!(\"lookup_op_method: op not supported: {:?}\", op)\n+        };\n \n-    fn lookup_op_method(&self,\n-                        expr: &'gcx hir::Expr,\n-                        lhs_ty: Ty<'tcx>,\n-                        other_tys: &[Ty<'tcx>],\n-                        opname: ast::Name,\n-                        trait_did: Option<DefId>,\n-                        lhs_expr: &'a hir::Expr)\n-                        -> Result<Ty<'tcx>,()>\n-    {\n         debug!(\"lookup_op_method(expr={:?}, lhs_ty={:?}, opname={:?}, \\\n                                  trait_did={:?}, lhs_expr={:?})\",\n                expr,\n@@ -397,28 +387,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                trait_did,\n                lhs_expr);\n \n-        let method = match trait_did {\n-            Some(trait_did) => {\n-                self.lookup_method_in_trait_adjusted(expr.span,\n-                                                     opname,\n-                                                     trait_did,\n-                                                     lhs_ty,\n-                                                     Some(other_tys))\n-            }\n-            None => None\n-        };\n+        let method = trait_did.and_then(|trait_did| {\n+            let opname = Symbol::intern(opname);\n+            self.lookup_method_in_trait(expr.span, opname, trait_did, lhs_ty, Some(other_tys))\n+        });\n \n         match method {\n             Some(ok) => {\n-                let (autoref, method) = self.register_infer_ok_obligations(ok);\n+                let method = self.register_infer_ok_obligations(ok);\n                 self.select_obligations_where_possible();\n \n-                self.apply_adjustment(lhs_expr.id, Adjustment {\n-                    kind: Adjust::Deref(vec![]),\n-                    autoref,\n-                    unsize: false,\n-                    target: method.sig.inputs()[0]\n-                });\n+                let (lhs_by_ref, _rhs_by_ref) = match op {\n+                    Op::Binary(_, IsAssign::Yes) => (true, false),\n+                    Op::Binary(op, _) if !op.node.is_by_value() => (true, true),\n+                    Op::Binary(..) | Op::Unary(_) => (false, false),\n+                };\n+                if lhs_by_ref {\n+                    if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                        let autoref = Adjustment {\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                            target: method.sig.inputs()[0]\n+                        };\n+                        self.apply_adjustments(lhs_expr, vec![autoref]);\n+                    }\n+                }\n                 self.write_method_call(expr.id, method);\n \n                 Ok(method.sig.output())\n@@ -493,6 +485,12 @@ enum IsAssign {\n     Yes,\n }\n \n+#[derive(Clone, Copy, Debug)]\n+enum Op {\n+    Binary(hir::BinOp, IsAssign),\n+    Unary(hir::UnOp),\n+}\n+\n /// Returns true if this is a built-in arithmetic operation (e.g. u32\n /// + u32, i16x4 == i16x4) and false if these types would have to be\n /// overloaded to be legal. There are two reasons that we distinguish"}, {"sha": "e1905c9310649454d4fc17203172df80bd69b8b4", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 47, "deletions": 81, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -542,61 +542,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // Check any autoderefs or autorefs that appear.\n-        let adjustment = self.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n-        if let Some(adjustment) = adjustment {\n-            debug!(\"adjustment={:?}\", adjustment);\n-            match adjustment.kind {\n-                adjustment::Adjust::Deref(ref autoderefs) => {\n-                    let cmt = ignore_err!(self.constrain_autoderefs(expr, autoderefs));\n-                    if let Some(ref autoref) = adjustment.autoref {\n-                        self.link_autoref(expr, cmt, autoref);\n-\n-                        // Require that the resulting region encompasses\n-                        // the current node.\n-                        //\n-                        // FIXME(#6268) remove to support nested method calls\n-                        self.type_of_node_must_outlive(infer::AutoBorrow(expr.span),\n-                                                       expr.id, expr_region);\n-                    }\n-                }\n-                /*\n-                adjustment::AutoObject(_, ref bounds, ..) => {\n-                    // Determine if we are casting `expr` to a trait\n-                    // instance. If so, we have to be sure that the type\n-                    // of the source obeys the new region bound.\n-                    let source_ty = self.resolve_node_type(expr.id);\n-                    self.type_must_outlive(infer::RelateObjectBound(expr.span),\n-                                           source_ty, bounds.region_bound);\n-                }\n-                */\n-                _ => {\n-                    assert!(adjustment.autoref.is_none());\n-                }\n-            }\n-\n-            // If necessary, constrain destructors in the unadjusted form of this\n-            // expression.\n-            let cmt_result = {\n-                let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-                mc.cat_expr_unadjusted(expr)\n-            };\n-            match cmt_result {\n-                Ok(head_cmt) => {\n-                    self.check_safety_of_rvalue_destructor_if_necessary(head_cmt,\n-                                                                        expr.span);\n-                }\n-                Err(..) => {\n-                    self.tcx.sess.delay_span_bug(expr.span, \"cat_expr_unadjusted Errd\");\n-                }\n-            }\n-        }\n+        let cmt_result = self.constrain_adjustments(expr);\n \n         // If necessary, constrain destructors in this expression. This will be\n         // the adjusted form if there is an adjustment.\n-        let cmt_result = {\n-            let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-            mc.cat_expr(expr)\n-        };\n         match cmt_result {\n             Ok(head_cmt) => {\n                 self.check_safety_of_rvalue_destructor_if_necessary(head_cmt, expr.span);\n@@ -904,26 +853,35 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Invoked on any auto-dereference that occurs. Checks that if this is a region pointer being\n+    /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n-    fn constrain_autoderefs(&mut self,\n-                            deref_expr: &hir::Expr,\n-                            autoderefs: &[Option<adjustment::OverloadedDeref<'tcx>>])\n-                            -> mc::McResult<mc::cmt<'tcx>>\n-    {\n-        debug!(\"constrain_autoderefs(deref_expr={:?}, autoderefs={:?})\",\n-               deref_expr,\n-               autoderefs);\n+    fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::cmt<'tcx>> {\n+        debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n         let mut cmt = {\n             let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-            mc.cat_expr_unadjusted(deref_expr)?\n+            mc.cat_expr_unadjusted(expr)?\n         };\n \n-        let r_deref_expr = self.tcx.node_scope_region(deref_expr.id);\n-        for &overloaded in autoderefs {\n-            if let Some(deref) = overloaded {\n-                debug!(\"constrain_autoderefs: overloaded, {:?}\", deref);\n+        //NOTE(@jroesch): mixed RefCell borrow causes crash\n+        let adjustments = self.tables.borrow().expr_adjustments(&expr).to_vec();\n+        if adjustments.is_empty() {\n+            return Ok(cmt);\n+        }\n+\n+        debug!(\"constrain_adjustments: adjustments={:?}\", adjustments);\n+\n+        // If necessary, constrain destructors in the unadjusted form of this\n+        // expression.\n+        self.check_safety_of_rvalue_destructor_if_necessary(cmt.clone(), expr.span);\n+\n+        let expr_region = self.tcx.node_scope_region(expr.id);\n+        for adjustment in adjustments {\n+            debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n+                   adjustment, cmt);\n+\n+            if let adjustment::Adjust::Deref(Some(deref)) = adjustment.kind {\n+                debug!(\"constrain_adjustments: overloaded deref: {:?}\", deref);\n \n                 // Treat overloaded autoderefs as if an AutoBorrow adjustment\n                 // was applied on the base type, as that is always the case.\n@@ -932,33 +890,39 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     mutbl: deref.mutbl,\n                 });\n                 let output = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n-                    ty: deref.target,\n+                    ty: adjustment.target,\n                     mutbl: deref.mutbl,\n                 });\n \n-                debug!(\"constrain_autoderefs: self_cmt={:?}\", cmt);\n-                self.link_region(deref_expr.span, deref.region,\n+                self.link_region(expr.span, deref.region,\n                                  ty::BorrowKind::from_mutbl(deref.mutbl), cmt.clone());\n \n                 // Specialized version of constrain_call.\n-                self.type_must_outlive(infer::CallRcvr(deref_expr.span),\n-                                       input, r_deref_expr);\n-                self.type_must_outlive(infer::CallReturn(deref_expr.span),\n-                                       output, r_deref_expr);\n+                self.type_must_outlive(infer::CallRcvr(expr.span),\n+                                       input, expr_region);\n+                self.type_must_outlive(infer::CallReturn(expr.span),\n+                                       output, expr_region);\n+            }\n+\n+            if let adjustment::Adjust::Borrow(ref autoref) = adjustment.kind {\n+                self.link_autoref(expr, cmt.clone(), autoref);\n+\n+                // Require that the resulting region encompasses\n+                // the current node.\n+                //\n+                // FIXME(#6268) remove to support nested method calls\n+                self.type_of_node_must_outlive(infer::AutoBorrow(expr.span),\n+                                               expr.id, expr_region);\n             }\n \n             {\n                 let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-                if let Some(deref) = overloaded {\n-                    cmt = mc.cat_overloaded_autoderef(deref_expr, deref)?;\n-                } else {\n-                    cmt = mc.cat_deref(deref_expr, cmt, false)?;\n-                }\n+                cmt = mc.cat_expr_adjusted(expr, cmt, &adjustment)?;\n             }\n \n             if let Categorization::Deref(_, mc::BorrowedPtr(_, r_ptr)) = cmt.cat {\n-                self.mk_subregion_due_to_dereference(deref_expr.span,\n-                                                     r_deref_expr, r_ptr);\n+                self.mk_subregion_due_to_dereference(expr.span,\n+                                                     expr_region, r_ptr);\n             }\n         }\n \n@@ -1029,7 +993,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // is going to fail anyway, so just stop here and let typeck\n         // report errors later on in the writeback phase.\n         let ty0 = self.resolve_node_type(id);\n-        let ty = self.tables.borrow().adjustments.get(&id).map_or(ty0, |adj| adj.target);\n+        let ty = self.tables.borrow().adjustments.get(&id)\n+            .and_then(|adj| adj.last())\n+            .map_or(ty0, |adj| adj.target);\n         let ty = self.resolve_type(ty);\n         debug!(\"constrain_regions_in_type_of_node(\\\n                 ty={}, ty0={}, id={}, minimum_lifetime={:?})\","}, {"sha": "baef48fe7d2cde82b6f5ef8919af54712c1ec5e3", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194fe695e3af6f03953cbb4ca66f159993f6214d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=194fe695e3af6f03953cbb4ca66f159993f6214d", "patch": "@@ -73,12 +73,14 @@ This API is completely unstable and subject to change.\n \n #![allow(non_camel_case_types)]\n \n+#![feature(advanced_slice_patterns)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]\n #![feature(never_type)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(slice_patterns)]\n \n #![cfg_attr(stage0, unstable(feature = \"rustc_private\", issue = \"27812\"))]\n #![cfg_attr(stage0, feature(rustc_private))]"}]}