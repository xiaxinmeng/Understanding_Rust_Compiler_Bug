{"sha": "f9f90ede826e24a9b314ca7bf0bc04856e11aadb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZjkwZWRlODI2ZTI0YTliMzE0Y2E3YmYwYmMwNDg1NmUxMWFhZGI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-05-28T15:43:53Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-06-01T07:32:24Z"}, "message": "Add TinyList data structure.", "tree": {"sha": "94e2a425baae81705eb9282625bb392191ff011b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94e2a425baae81705eb9282625bb392191ff011b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9f90ede826e24a9b314ca7bf0bc04856e11aadb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f90ede826e24a9b314ca7bf0bc04856e11aadb", "html_url": "https://github.com/rust-lang/rust/commit/f9f90ede826e24a9b314ca7bf0bc04856e11aadb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9f90ede826e24a9b314ca7bf0bc04856e11aadb/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63cd4a39ead1bdcc6f4df5f11d187916bd8d3ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/63cd4a39ead1bdcc6f4df5f11d187916bd8d3ea7", "html_url": "https://github.com/rust-lang/rust/commit/63cd4a39ead1bdcc6f4df5f11d187916bd8d3ea7"}], "stats": {"total": 252, "additions": 252, "deletions": 0}, "files": [{"sha": "23a920739b964dcd28925cf6a78771205a589145", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9f90ede826e24a9b314ca7bf0bc04856e11aadb/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f90ede826e24a9b314ca7bf0bc04856e11aadb/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=f9f90ede826e24a9b314ca7bf0bc04856e11aadb", "patch": "@@ -74,6 +74,7 @@ pub mod control_flow_graph;\n pub mod flock;\n pub mod sync;\n pub mod owning_ref;\n+pub mod tiny_list;\n pub mod sorted_map;\n \n pub struct OnDrop<F: Fn()>(pub F);"}, {"sha": "3c54805502cf92da2c6ffeb50abdc05f0daaa9c5", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/f9f90ede826e24a9b314ca7bf0bc04856e11aadb/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f90ede826e24a9b314ca7bf0bc04856e11aadb/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=f9f90ede826e24a9b314ca7bf0bc04856e11aadb", "patch": "@@ -0,0 +1,251 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+//! A singly-linked list.\n+//!\n+//! Using this data structure only makes sense under very specific\n+//! circumstances:\n+//!\n+//! - If you have a list that rarely stores more than one element, then this\n+//!   data-structure can store the element without allocating and only uses as\n+//!   much space as a `Option<(T, usize)>`. If T can double as the `Option`\n+//!   discriminant, it will even only be as large as `T, usize`.\n+//!\n+//! If you expect to store more than 1 element in the common case, steer clear\n+//! and use a `Vec<T>`, `Box<[T]>`, or a `SmallVec<T>`.\n+\n+use std::mem;\n+\n+#[derive(Clone, Hash, Debug, PartialEq)]\n+pub struct TinyList<T: PartialEq> {\n+    head: Option<Element<T>>\n+}\n+\n+impl<T: PartialEq> TinyList<T> {\n+\n+    #[inline]\n+    pub fn new() -> TinyList<T> {\n+        TinyList {\n+            head: None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn new_single(data: T) -> TinyList<T> {\n+        TinyList {\n+            head: Some(Element {\n+                data,\n+                next: None,\n+            })\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn insert(&mut self, data: T) {\n+        let current_head = mem::replace(&mut self.head, None);\n+\n+        if let Some(current_head) = current_head {\n+            let current_head = Box::new(current_head);\n+            self.head = Some(Element {\n+                data,\n+                next: Some(current_head)\n+            });\n+        } else {\n+            self.head = Some(Element {\n+                data,\n+                next: None,\n+            })\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn remove(&mut self, data: &T) -> bool {\n+        let remove_head = if let Some(ref mut head) = self.head {\n+            if head.data == *data {\n+                Some(mem::replace(&mut head.next, None))\n+            } else {\n+                None\n+            }\n+        } else {\n+            return false\n+        };\n+\n+        if let Some(remove_head) = remove_head {\n+            if let Some(next) = remove_head {\n+                self.head = Some(*next);\n+            } else {\n+                self.head = None;\n+            }\n+            return true\n+        }\n+\n+        self.head.as_mut().unwrap().remove_next(data)\n+    }\n+\n+    #[inline]\n+    pub fn contains(&self, data: &T) -> bool {\n+        if let Some(ref head) = self.head {\n+            head.contains(data)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        if let Some(ref head) = self.head {\n+            head.len()\n+        } else {\n+            0\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Hash, Debug, PartialEq)]\n+struct Element<T: PartialEq> {\n+    data: T,\n+    next: Option<Box<Element<T>>>,\n+}\n+\n+impl<T: PartialEq> Element<T> {\n+\n+    fn remove_next(&mut self, data: &T) -> bool {\n+        let new_next = if let Some(ref mut next) = self.next {\n+            if next.data != *data {\n+                return next.remove_next(data)\n+            } else {\n+                mem::replace(&mut next.next, None)\n+            }\n+        } else {\n+            return false\n+        };\n+\n+        self.next = new_next;\n+        return true\n+    }\n+\n+    fn len(&self) -> usize {\n+        if let Some(ref next) = self.next {\n+            1 + next.len()\n+        } else {\n+            1\n+        }\n+    }\n+\n+    fn contains(&self, data: &T) -> bool {\n+        if self.data == *data {\n+            return true\n+        }\n+\n+        if let Some(ref next) = self.next {\n+            next.contains(data)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_contains_and_insert() {\n+        fn do_insert(i : u32) -> bool {\n+            i % 2 == 0\n+        }\n+\n+        let mut list = TinyList::new();\n+\n+        for i in 0 .. 10 {\n+            for j in 0 .. i {\n+                if do_insert(j) {\n+                    assert!(list.contains(&j));\n+                } else {\n+                    assert!(!list.contains(&j));\n+                }\n+            }\n+\n+            assert!(!list.contains(i));\n+\n+            if do_insert(i) {\n+                list.insert(i);\n+                assert!(list.contains(&i));\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_remove_first() {\n+        let mut list = TinyList::new();\n+        list.insert(1);\n+        list.insert(2);\n+        list.insert(3);\n+        list.insert(4);\n+        assert_eq!(list.len(), 4);\n+\n+        assert!(list.remove(&4));\n+        assert!(!list.contains(&4));\n+\n+        assert_eq!(list.len(), 3);\n+        assert!(list.contains(&1));\n+        assert!(list.contains(&2));\n+        assert!(list.contains(&3));\n+    }\n+\n+    #[test]\n+    fn test_remove_last() {\n+        let mut list = TinyList::new();\n+        list.insert(1);\n+        list.insert(2);\n+        list.insert(3);\n+        list.insert(4);\n+        assert_eq!(list.len(), 4);\n+\n+        assert!(list.remove(&1));\n+        assert!(!list.contains(&1));\n+\n+        assert_eq!(list.len(), 3);\n+        assert!(list.contains(&2));\n+        assert!(list.contains(&3));\n+        assert!(list.contains(&4));\n+    }\n+\n+    #[test]\n+    fn test_remove_middle() {\n+        let mut list = TinyList::new();\n+        list.insert(1);\n+        list.insert(2);\n+        list.insert(3);\n+        list.insert(4);\n+        assert_eq!(list.len(), 4);\n+\n+        assert!(list.remove(&2));\n+        assert!(!list.contains(&2));\n+\n+        assert_eq!(list.len(), 3);\n+        assert!(list.contains(&1));\n+        assert!(list.contains(&3));\n+        assert!(list.contains(&4));\n+    }\n+\n+    #[test]\n+    fn test_remove_single() {\n+        let mut list = TinyList::new();\n+        list.insert(1);\n+        assert_eq!(list.len(), 1);\n+\n+        assert!(list.remove(&1));\n+        assert!(!list.contains(&1));\n+\n+        assert_eq!(list.len(), 0);\n+    }\n+}"}]}