{"sha": "68a7f1b5e37f3b8a83def4e9cb4d02aef33b8dbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YTdmMWI1ZTM3ZjNiOGE4M2RlZjRlOWNiNGQwMmFlZjMzYjhkYmY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-20T19:57:47Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-27T21:55:14Z"}, "message": "syntax: turn the match-call generated by format_args inside-out.", "tree": {"sha": "2ea6fd7fd818b35e983b4a74807eed631b9853cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ea6fd7fd818b35e983b4a74807eed631b9853cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68a7f1b5e37f3b8a83def4e9cb4d02aef33b8dbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68a7f1b5e37f3b8a83def4e9cb4d02aef33b8dbf", "html_url": "https://github.com/rust-lang/rust/commit/68a7f1b5e37f3b8a83def4e9cb4d02aef33b8dbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68a7f1b5e37f3b8a83def4e9cb4d02aef33b8dbf/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17b3c1107a42048209a345924bf6045861c3c498", "url": "https://api.github.com/repos/rust-lang/rust/commits/17b3c1107a42048209a345924bf6045861c3c498", "html_url": "https://github.com/rust-lang/rust/commit/17b3c1107a42048209a345924bf6045861c3c498"}], "stats": {"total": 80, "additions": 41, "deletions": 39}, "files": [{"sha": "dc5a899aa6b90ce8d63a4236685e7f0d8be08d9f", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/68a7f1b5e37f3b8a83def4e9cb4d02aef33b8dbf/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a7f1b5e37f3b8a83def4e9cb4d02aef33b8dbf/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=68a7f1b5e37f3b8a83def4e9cb4d02aef33b8dbf", "patch": "@@ -559,9 +559,43 @@ impl<'a, 'b> Context<'a, 'b> {\n         // Now create a vector containing all the arguments\n         let args = locals.into_iter().chain(names.into_iter().map(|a| a.unwrap()));\n \n-        // Now create the fmt::Arguments struct with all our locals we created.\n-        let args_slice = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n+        let args_array = self.ecx.expr_vec(self.fmtsp, args.collect());\n+\n+        // Constructs an AST equivalent to:\n+        //\n+        //      match (&arg0, &arg1) {\n+        //          (tmp0, tmp1) => args_array\n+        //      }\n+        //\n+        // It was:\n+        //\n+        //      let tmp0 = &arg0;\n+        //      let tmp1 = &arg1;\n+        //      args_array\n+        //\n+        // Because of #11585 the new temporary lifetime rule, the enclosing\n+        // statements for these temporaries become the let's themselves.\n+        // If one or more of them are RefCell's, RefCell borrow() will also\n+        // end there; they don't last long enough for args_array to use them.\n+        // The match expression solves the scope problem.\n+        //\n+        // Note, it may also very well be transformed to:\n+        //\n+        //      match arg0 {\n+        //          ref tmp0 => {\n+        //              match arg1 => {\n+        //                  ref tmp1 => args_array } } }\n+        //\n+        // But the nested match expression is proved to perform not as well\n+        // as series of let's; the first approach does.\n+        let pat = self.ecx.pat_tuple(self.fmtsp, pats);\n+        let arm = self.ecx.arm(self.fmtsp, vec!(pat), args_array);\n+        let head = self.ecx.expr(self.fmtsp, ast::ExprTup(heads));\n+        let result = self.ecx.expr_match(self.fmtsp, head, vec!(arm));\n+\n+        let args_slice = self.ecx.expr_addr_of(self.fmtsp, result);\n \n+        // Now create the fmt::Arguments struct with all our locals we created.\n         let (fn_name, fn_args) = if self.all_pieces_simple {\n             (\"new\", vec![pieces, args_slice])\n         } else {\n@@ -582,58 +616,26 @@ impl<'a, 'b> Context<'a, 'b> {\n             (\"with_placeholders\", vec![pieces, fmt, args_slice])\n         };\n \n-        let result = self.ecx.expr_call_global(self.fmtsp, vec!(\n+        let body = self.ecx.expr_call_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n                 self.ecx.ident_of(\"Arguments\"),\n                 self.ecx.ident_of(fn_name)), fn_args);\n \n-        let body = match invocation {\n+        match invocation {\n             Call(e) => {\n                 let span = e.span;\n                 self.ecx.expr_call(span, e, vec![\n-                    self.ecx.expr_addr_of(span, result)\n+                    self.ecx.expr_addr_of(span, body)\n                 ])\n             }\n             MethodCall(e, m) => {\n                 let span = e.span;\n                 self.ecx.expr_method_call(span, e, m, vec![\n-                    self.ecx.expr_addr_of(span, result)\n+                    self.ecx.expr_addr_of(span, body)\n                 ])\n             }\n-        };\n-\n-        // Constructs an AST equivalent to:\n-        //\n-        //      match (&arg0, &arg1) {\n-        //          (tmp0, tmp1) => body\n-        //      }\n-        //\n-        // It was:\n-        //\n-        //      let tmp0 = &arg0;\n-        //      let tmp1 = &arg1;\n-        //      body\n-        //\n-        // Because of #11585 the new temporary lifetime rule, the enclosing\n-        // statements for these temporaries become the let's themselves.\n-        // If one or more of them are RefCell's, RefCell borrow() will also\n-        // end there; they don't last long enough for body to use them. The\n-        // match expression solves the scope problem.\n-        //\n-        // Note, it may also very well be transformed to:\n-        //\n-        //      match arg0 {\n-        //          ref tmp0 => {\n-        //              match arg1 => {\n-        //                  ref tmp1 => body } } }\n-        //\n-        // But the nested match expression is proved to perform not as well\n-        // as series of let's; the first approach does.\n-        let pat = self.ecx.pat_tuple(self.fmtsp, pats);\n-        let arm = self.ecx.arm(self.fmtsp, vec!(pat), body);\n-        let head = self.ecx.expr(self.fmtsp, ast::ExprTup(heads));\n-        self.ecx.expr_match(self.fmtsp, head, vec!(arm))\n+        }\n     }\n \n     fn format_arg(ecx: &ExtCtxt, sp: Span,"}]}