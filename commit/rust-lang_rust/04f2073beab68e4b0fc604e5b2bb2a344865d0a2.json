{"sha": "04f2073beab68e4b0fc604e5b2bb2a344865d0a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZjIwNzNiZWFiNjhlNGIwZmM2MDRlNWIyYmIyYTM0NDg2NWQwYTI=", "commit": {"author": {"name": "Damian Gryski", "email": "damian@gryski.com", "date": "2012-07-28T21:35:37Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-07-30T17:46:01Z"}, "message": "core::hash -- add a hash::streaming interface and associated siphash implementation.", "tree": {"sha": "581a51ba7cc92826f7141355603c20f0c66daa04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/581a51ba7cc92826f7141355603c20f0c66daa04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04f2073beab68e4b0fc604e5b2bb2a344865d0a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04f2073beab68e4b0fc604e5b2bb2a344865d0a2", "html_url": "https://github.com/rust-lang/rust/commit/04f2073beab68e4b0fc604e5b2bb2a344865d0a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04f2073beab68e4b0fc604e5b2bb2a344865d0a2/comments", "author": {"login": "dgryski", "id": 970862, "node_id": "MDQ6VXNlcjk3MDg2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/970862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dgryski", "html_url": "https://github.com/dgryski", "followers_url": "https://api.github.com/users/dgryski/followers", "following_url": "https://api.github.com/users/dgryski/following{/other_user}", "gists_url": "https://api.github.com/users/dgryski/gists{/gist_id}", "starred_url": "https://api.github.com/users/dgryski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dgryski/subscriptions", "organizations_url": "https://api.github.com/users/dgryski/orgs", "repos_url": "https://api.github.com/users/dgryski/repos", "events_url": "https://api.github.com/users/dgryski/events{/privacy}", "received_events_url": "https://api.github.com/users/dgryski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "082d8314da6b6b99854f0a70f5ea8e27f2602f79", "url": "https://api.github.com/repos/rust-lang/rust/commits/082d8314da6b6b99854f0a70f5ea8e27f2602f79", "html_url": "https://github.com/rust-lang/rust/commit/082d8314da6b6b99854f0a70f5ea8e27f2602f79"}], "stats": {"total": 205, "additions": 194, "deletions": 11}, "files": [{"sha": "9c85473e76111da1247654cc278183c9cf5585a1", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 194, "deletions": 11, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/04f2073beab68e4b0fc604e5b2bb2a344865d0a2/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f2073beab68e4b0fc604e5b2bb2a344865d0a2/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=04f2073beab68e4b0fc604e5b2bb2a344865d0a2", "patch": "@@ -32,7 +32,7 @@ pure fn hash_bytes_keyed(buf: &[const u8], k0: u64, k1: u64) -> u64 {\n \n     #macro([#rotl(x,b), (x << b) | (x >> (64 - b))]);\n \n-    #macro([#compress(), {\n+    #macro([#compress(v0,v1,v2,v3), {\n         v0 += v1; v1 = #rotl(v1, 13); v1 ^= v0; v0 = #rotl(v0, 32);\n         v2 += v3; v3 = #rotl(v3, 16); v3 ^= v2;\n         v0 += v3; v3 = #rotl(v3, 21); v3 ^= v0;\n@@ -47,8 +47,8 @@ pure fn hash_bytes_keyed(buf: &[const u8], k0: u64, k1: u64) -> u64 {\n     while i < end {\n         let m = #u8to64_le(buf, i);\n         v3 ^= m;\n-        #compress();\n-        #compress();\n+        #compress(v0,v1,v2,v3);\n+        #compress(v0,v1,v2,v3);\n         v0 ^= m;\n         i += 8;\n     }\n@@ -64,19 +64,182 @@ pure fn hash_bytes_keyed(buf: &[const u8], k0: u64, k1: u64) -> u64 {\n     if left > 6 { b |= buf[i + 6] as u64 << 48; }\n \n     v3 ^= b;\n-    #compress();\n-    #compress();\n+    #compress(v0,v1,v2,v3);\n+    #compress(v0,v1,v2,v3);\n     v0 ^= b;\n \n     v2 ^= 0xff;\n-    #compress();\n-    #compress();\n-    #compress();\n-    #compress();\n+\n+    #compress(v0,v1,v2,v3);\n+    #compress(v0,v1,v2,v3);\n+    #compress(v0,v1,v2,v3);\n+    #compress(v0,v1,v2,v3);\n \n     ret v0 ^ v1 ^ v2 ^ v3;\n }\n \n+\n+iface streaming {\n+    fn input(~[u8]);\n+    fn input_str(~str);\n+    fn result() -> ~[u8];\n+    fn result_str() -> ~str;\n+    fn reset();\n+}\n+\n+fn siphash(key0 : u64, key1 : u64) -> streaming {\n+    type sipstate = {\n+        k0 : u64,\n+        k1 : u64,\n+        mut length : uint, // how many bytes we've processed\n+        mut v0 : u64,      // hash state\n+        mut v1 : u64,\n+        mut v2 : u64,\n+        mut v3 : u64,\n+        tail : ~[mut u8]/8, // unprocessed bytes\n+        mut ntail : uint,   //  how many bytes in tail are valid\n+    };\n+\n+    fn add_input(st : sipstate, msg : ~[u8]) {\n+        let length = vec::len(msg);\n+        st.length += length;\n+\n+        let mut needed = 0u;\n+\n+        if st.ntail != 0 {\n+            needed = 8 - st.ntail;\n+\n+            if length < needed {\n+\n+                let mut t = 0;\n+                while t < length {\n+                    st.tail[st.ntail+t] = msg[t];\n+                    t += 1;\n+                }\n+                st.ntail += length;\n+\n+                ret;\n+            }\n+\n+            let mut t = 0;\n+            while t < needed {\n+                st.tail[st.ntail+t] = msg[t];\n+                t += 1;\n+            }\n+\n+            let m = #u8to64_le(st.tail, 0);\n+\n+            st.v3 ^= m;\n+            #compress(st.v0, st.v1, st.v2, st.v3);\n+            #compress(st.v0, st.v1, st.v2, st.v3);\n+            st.v0 ^= m;\n+\n+            st.ntail = 0;\n+        }\n+\n+        let len = length - needed;\n+        let end = len & (!0x7);\n+        let left = len & 0x7;\n+\n+        let mut i = needed;\n+        while i < end {\n+            let mi = #u8to64_le(msg, i);\n+\n+            st.v3 ^= mi;\n+            #compress(st.v0, st.v1, st.v2, st.v3);\n+            #compress(st.v0, st.v1, st.v2, st.v3);\n+            st.v0 ^= mi;\n+\n+            i += 8;\n+        }\n+\n+        let mut t = 0u;\n+        while t < left {\n+            st.tail[t] = msg[i+t];\n+            t += 1\n+        }\n+        st.ntail = left;\n+    }\n+\n+    fn mk_result(st : sipstate) -> ~[u8] {\n+\n+        let mut v0 = st.v0;\n+        let mut v1 = st.v1;\n+        let mut v2 = st.v2;\n+        let mut v3 = st.v3;\n+\n+        let mut b : u64 = (st.length as u64 & 0xff) << 56;\n+\n+        if st.ntail > 0 { b |= st.tail[0] as u64 <<  0; }\n+        if st.ntail > 1 { b |= st.tail[1] as u64 <<  8; }\n+        if st.ntail > 2 { b |= st.tail[2] as u64 << 16; }\n+        if st.ntail > 3 { b |= st.tail[3] as u64 << 24; }\n+        if st.ntail > 4 { b |= st.tail[4] as u64 << 32; }\n+        if st.ntail > 5 { b |= st.tail[5] as u64 << 40; }\n+        if st.ntail > 6 { b |= st.tail[6] as u64 << 48; }\n+\n+        v3 ^= b;\n+        #compress(v0, v1, v2, v3);\n+        #compress(v0, v1, v2, v3);\n+        v0 ^= b;\n+\n+        v2 ^= 0xff;\n+        #compress(v0, v1, v2, v3);\n+        #compress(v0, v1, v2, v3);\n+        #compress(v0, v1, v2, v3);\n+        #compress(v0, v1, v2, v3);\n+\n+        let h = v0 ^ v1 ^ v2 ^ v3;\n+\n+        ret ~[\n+            (h >> 0) as u8,\n+            (h >> 8) as u8,\n+            (h >> 16) as u8,\n+            (h >> 24) as u8,\n+            (h >> 32) as u8,\n+            (h >> 40) as u8,\n+            (h >> 48) as u8,\n+            (h >> 56) as u8,\n+        ];\n+    }\n+\n+   impl of streaming for sipstate {\n+        fn reset() {\n+            self.length = 0;\n+            self.v0 = self.k0 ^ 0x736f6d6570736575;\n+            self.v1 = self.k1 ^ 0x646f72616e646f6d;\n+            self.v2 = self.k0 ^ 0x6c7967656e657261;\n+            self.v3 = self.k1 ^ 0x7465646279746573;\n+            self.ntail = 0;\n+        }\n+        fn input(msg: ~[u8]) { add_input(self, msg); }\n+        fn input_str(msg: ~str) { add_input(self, str::bytes(msg)); }\n+        fn result() -> ~[u8] { ret mk_result(self); }\n+        fn result_str() -> ~str {\n+            let r = mk_result(self);\n+            let mut s = ~\"\";\n+            for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n+            ret s;\n+        }\n+    }\n+\n+    let st = {\n+        k0 : key0,\n+        k1 : key1,\n+        mut length : 0u,\n+        mut v0 : 0u64,\n+        mut v1 : 0u64,\n+        mut v2 : 0u64,\n+        mut v3 : 0u64,\n+        tail : ~[mut 0u8,0,0,0,0,0,0,0]/8,\n+        mut ntail : 0u,\n+    };\n+\n+    let sh = st as streaming;\n+    sh.reset();\n+    ret sh;\n+}\n+\n #[test]\n fn test_siphash() {\n     let vecs : [[u8]/8]/64 = [\n@@ -150,14 +313,34 @@ fn test_siphash() {\n     let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n     let mut buf : ~[u8] = ~[];\n     let mut t = 0;\n+    let stream_inc = siphash(k0,k1);\n+    let stream_full = siphash(k0,k1);\n+\n+    fn to_hex_str(r:[u8]/8) -> ~str {\n+        let mut s = ~\"\";\n+        for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n+        ret s;\n+    }\n+\n     while t < 64 {\n         #debug(\"siphash test %?\", t);\n         let vec = #u8to64_le(vecs[t], 0);\n         let out = hash_bytes_keyed(buf, k0, k1);\n         #debug(\"got %?, expected %?\", out, vec);\n         assert vec == out;\n+\n+        stream_full.reset();\n+        stream_full.input(buf);\n+        let f = stream_full.result_str();\n+        let i = stream_inc.result_str();\n+        let v = to_hex_str(vecs[t]);\n+        #debug[\"%d: (%s) => inc=%s full=%s\", t, v, i, f];\n+\n+        assert f == i && f == v;\n+\n         buf += ~[t as u8];\n+        stream_inc.input(~[t as u8]);\n+\n         t += 1;\n     }\n-\n-}\n\\ No newline at end of file\n+}"}]}