{"sha": "c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwOWYwZWIzZWI3Y2EwOTJmZGFlYWNhYjM3YmYwNWZlYTFlMjQxZjg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-29T18:21:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-29T18:21:18Z"}, "message": "Rollup merge of #72568 - golddranks:add_total_cmp_to_floats, r=sfackler\n\nImplement total_cmp for f32, f64\n\n# Overview\n* Implements method `total_cmp` on `f32` and `f64`. This method implements a float comparison that, unlike the standard `partial_cmp`, is total (defined on all values) in accordance to the IEEE 754 (rev 2008) \u00a75.10 `totalOrder` predicate.\n* The method has an API similar to `cmp`: `pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering { ... }`.\n* Implements tests.\n* Has documentation.\n\n# Justification for the API\n* Total ordering for `f32` and `f64` has been discussed many time before:\n  * https://internals.rust-lang.org/t/pre-pre-rfc-range-restricting-wrappers-for-floating-point-types/6701\n  * https://github.com/rust-lang/rfcs/issues/1249\n  * https://github.com/rust-lang/rust/pull/53938\n  * https://github.com/rust-lang/rust/issues/5585\n* The lack of total ordering leads to frequent complaints, especially from people new to Rust.\n  * This is an ergonomics issue that needs to be addressed.\n  * However, the default behaviour of implementing only `PartialOrd` is intentional, as relaxing it might lead to correctness issues.\n* Most earlier implementations and discussions have been focusing on a wrapper type that implements trait `Ord`. Such a wrapper type is, however not easy to add because of the large API surface added.\n* As a minimal step that hopefully proves uncontroversial, we can implement a stand-alone method `total_cmp` on floating point types.\n  * I expect adding such methods should be uncontroversial because...\n    * Similar methods on `f32` and `f64` would be warranted even in case stdlib would provide a wrapper type that implements `Ord` some day.\n    * It implements functionality that is standardised. (IEEE 754, 2008 rev. \u00a75.10 Note, that the 2019 revision relaxes the ordering. The way we do ordering in this method conforms to the stricter 2008 standard.)\n* With stdlib APIs such as `slice::sort_by` and `slice::binary_search_by` that allow users to provide a custom ordering criterion, providing additional helper methods is a minimal way of adding ordering functionality.\n  * Not also does it allow easily using aforementioned APIs, it also provides an easy and well-tested primitive for the users and library authors to implement an `Ord`-implementing wrapper, if needed.", "tree": {"sha": "3ca519557c5cbc3e0405a3f1beecc02681e6f5d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ca519557c5cbc3e0405a3f1beecc02681e6f5d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe0VKfCRBK7hj4Ov3rIwAAdHIIAFS+B/AZ8Gtp5OPqeouAIvKE\nmhh3zL+CSfEGDUl+dMU4nHsUnO48y5cXP/w+MTuFrVYjEiYAVJd/XI06gAqQU+NF\nZRhsbaLRInheRXQmFgIyGWYtoRWYnflnnqna9jwEFF/lxedjS5Ab7cQ+wav2zyTV\nYaH7tVcrjFCrXs+YeeZBvMQJ8H6z6vjiWfKaOqkTbgHnKe94B2C9Jpxw15i5teBM\nuBYM66gbp2lCcdaBgRaKomIX/56gvxfaITAdoCD6gJHc5kqo0DrdoAFhoG+TL5ON\nxsp7AkAjXGrZaRVivlfMsKEAmnwIkv3T9bLg4lTGLU2ILPGvyUkMvDwIPiBplxw=\n=xCt6\n-----END PGP SIGNATURE-----\n", "payload": "tree 3ca519557c5cbc3e0405a3f1beecc02681e6f5d4\nparent 9ef62271170cd15a8cbfa8d1d6192d1302e9cce2\nparent 66da7350963edf3d40461e6f5bafde95974908fc\nauthor Dylan DPC <dylan.dpc@gmail.com> 1590776478 +0200\ncommitter GitHub <noreply@github.com> 1590776478 +0200\n\nRollup merge of #72568 - golddranks:add_total_cmp_to_floats, r=sfackler\n\nImplement total_cmp for f32, f64\n\n# Overview\n* Implements method `total_cmp` on `f32` and `f64`. This method implements a float comparison that, unlike the standard `partial_cmp`, is total (defined on all values) in accordance to the IEEE 754 (rev 2008) \u00a75.10 `totalOrder` predicate.\n* The method has an API similar to `cmp`: `pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering { ... }`.\n* Implements tests.\n* Has documentation.\n\n# Justification for the API\n* Total ordering for `f32` and `f64` has been discussed many time before:\n  * https://internals.rust-lang.org/t/pre-pre-rfc-range-restricting-wrappers-for-floating-point-types/6701\n  * https://github.com/rust-lang/rfcs/issues/1249\n  * https://github.com/rust-lang/rust/pull/53938\n  * https://github.com/rust-lang/rust/issues/5585\n* The lack of total ordering leads to frequent complaints, especially from people new to Rust.\n  * This is an ergonomics issue that needs to be addressed.\n  * However, the default behaviour of implementing only `PartialOrd` is intentional, as relaxing it might lead to correctness issues.\n* Most earlier implementations and discussions have been focusing on a wrapper type that implements trait `Ord`. Such a wrapper type is, however not easy to add because of the large API surface added.\n* As a minimal step that hopefully proves uncontroversial, we can implement a stand-alone method `total_cmp` on floating point types.\n  * I expect adding such methods should be uncontroversial because...\n    * Similar methods on `f32` and `f64` would be warranted even in case stdlib would provide a wrapper type that implements `Ord` some day.\n    * It implements functionality that is standardised. (IEEE 754, 2008 rev. \u00a75.10 Note, that the 2019 revision relaxes the ordering. The way we do ordering in this method conforms to the stricter 2008 standard.)\n* With stdlib APIs such as `slice::sort_by` and `slice::binary_search_by` that allow users to provide a custom ordering criterion, providing additional helper methods is a minimal way of adding ordering functionality.\n  * Not also does it allow easily using aforementioned APIs, it also provides an easy and well-tested primitive for the users and library authors to implement an `Ord`-implementing wrapper, if needed.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8", "html_url": "https://github.com/rust-lang/rust/commit/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "html_url": "https://github.com/rust-lang/rust/commit/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2"}, {"sha": "66da7350963edf3d40461e6f5bafde95974908fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/66da7350963edf3d40461e6f5bafde95974908fc", "html_url": "https://github.com/rust-lang/rust/commit/66da7350963edf3d40461e6f5bafde95974908fc"}], "stats": {"total": 435, "additions": 435, "deletions": 0}, "files": [{"sha": "6313de31ce4d582dfc2f7b33e57216ed7d1f1070", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8", "patch": "@@ -810,4 +810,78 @@ impl f32 {\n     pub fn from_ne_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_ne_bytes(bytes))\n     }\n+\n+    /// Returns an ordering between self and other values.\n+    /// Unlike the standard partial comparison between floating point numbers,\n+    /// this comparison always produces an ordering in accordance to\n+    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n+    /// floating point standard. The values are ordered in following order:\n+    /// - Negative quiet NaN\n+    /// - Negative signaling NaN\n+    /// - Negative infinity\n+    /// - Negative numbers\n+    /// - Negative subnormal numbers\n+    /// - Negative zero\n+    /// - Positive zero\n+    /// - Positive subnormal numbers\n+    /// - Positive numbers\n+    /// - Positive infinity\n+    /// - Positive signaling NaN\n+    /// - Positive quiet NaN\n+    ///\n+    /// # Example\n+    /// ```\n+    /// #![feature(total_cmp)]\n+    /// struct GoodBoy {\n+    ///     name: String,\n+    ///     weight: f32,\n+    /// }\n+    ///\n+    /// let mut bois = vec![\n+    ///     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n+    ///     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n+    ///     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n+    ///     GoodBoy { name: \"Chonk\".to_owned(), weight: f32::INFINITY },\n+    ///     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f32::NAN },\n+    ///     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n+    /// ];\n+    ///\n+    /// bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n+    /// # assert!(bois.into_iter().map(|b| b.weight)\n+    /// #     .zip([-5.0, 0.1, 10.0, 99.0, f32::INFINITY, f32::NAN].iter())\n+    /// #     .all(|(a, b)| a.to_bits() == b.to_bits()))\n+    /// ```\n+    #[unstable(feature = \"total_cmp\", issue = \"72599\")]\n+    #[inline]\n+    pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering {\n+        let mut left = self.to_bits() as i32;\n+        let mut right = other.to_bits() as i32;\n+\n+        // In case of negatives, flip all the bits except the sign\n+        // to achieve a similar layout as two's complement integers\n+        //\n+        // Why does this work? IEEE 754 floats consist of three fields:\n+        // Sign bit, exponent and mantissa. The set of exponent and mantissa\n+        // fields as a whole have the property that their bitwise order is\n+        // equal to the numeric magnitude where the magnitude is defined.\n+        // The magnitude is not normally defined on NaN values, but\n+        // IEEE 754 totalOrder defines the NaN values also to follow the\n+        // bitwise order. This leads to order explained in the doc comment.\n+        // However, the representation of magnitude is the same for negative\n+        // and positive numbers \u2013 only the sign bit is different.\n+        // To easily compare the floats as signed integers, we need to\n+        // flip the exponent and mantissa bits in case of negative numbers.\n+        // We effectively convert the numbers to \"two's complement\" form.\n+        //\n+        // To do the flipping, we construct a mask and XOR against it.\n+        // We branchlessly calculate an \"all-ones except for the sign bit\"\n+        // mask from negative-signed values: right shifting sign-extends\n+        // the integer, so we \"fill\" the mask with sign bits, and then\n+        // convert to unsigned to push one more zero bit.\n+        // On positive values, the mask is all zeros, so it's a no-op.\n+        left ^= (((left >> 31) as u32) >> 1) as i32;\n+        right ^= (((right >> 31) as u32) >> 1) as i32;\n+\n+        left.cmp(&right)\n+    }\n }"}, {"sha": "d42e5392c586347af9dd092d4033342b46349e3c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8", "patch": "@@ -824,4 +824,78 @@ impl f64 {\n     pub fn from_ne_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_ne_bytes(bytes))\n     }\n+\n+    /// Returns an ordering between self and other values.\n+    /// Unlike the standard partial comparison between floating point numbers,\n+    /// this comparison always produces an ordering in accordance to\n+    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n+    /// floating point standard. The values are ordered in following order:\n+    /// - Negative quiet NaN\n+    /// - Negative signaling NaN\n+    /// - Negative infinity\n+    /// - Negative numbers\n+    /// - Negative subnormal numbers\n+    /// - Negative zero\n+    /// - Positive zero\n+    /// - Positive subnormal numbers\n+    /// - Positive numbers\n+    /// - Positive infinity\n+    /// - Positive signaling NaN\n+    /// - Positive quiet NaN\n+    ///\n+    /// # Example\n+    /// ```\n+    /// #![feature(total_cmp)]\n+    /// struct GoodBoy {\n+    ///     name: String,\n+    ///     weight: f64,\n+    /// }\n+    ///\n+    /// let mut bois = vec![\n+    ///     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n+    ///     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n+    ///     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n+    ///     GoodBoy { name: \"Chonk\".to_owned(), weight: f64::INFINITY },\n+    ///     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f64::NAN },\n+    ///     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n+    /// ];\n+    ///\n+    /// bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n+    /// # assert!(bois.into_iter().map(|b| b.weight)\n+    /// #     .zip([-5.0, 0.1, 10.0, 99.0, f64::INFINITY, f64::NAN].iter())\n+    /// #     .all(|(a, b)| a.to_bits() == b.to_bits()))\n+    /// ```\n+    #[unstable(feature = \"total_cmp\", issue = \"72599\")]\n+    #[inline]\n+    pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering {\n+        let mut left = self.to_bits() as i64;\n+        let mut right = other.to_bits() as i64;\n+\n+        // In case of negatives, flip all the bits except the sign\n+        // to achieve a similar layout as two's complement integers\n+        //\n+        // Why does this work? IEEE 754 floats consist of three fields:\n+        // Sign bit, exponent and mantissa. The set of exponent and mantissa\n+        // fields as a whole have the property that their bitwise order is\n+        // equal to the numeric magnitude where the magnitude is defined.\n+        // The magnitude is not normally defined on NaN values, but\n+        // IEEE 754 totalOrder defines the NaN values also to follow the\n+        // bitwise order. This leads to order explained in the doc comment.\n+        // However, the representation of magnitude is the same for negative\n+        // and positive numbers \u2013 only the sign bit is different.\n+        // To easily compare the floats as signed integers, we need to\n+        // flip the exponent and mantissa bits in case of negative numbers.\n+        // We effectively convert the numbers to \"two's complement\" form.\n+        //\n+        // To do the flipping, we construct a mask and XOR against it.\n+        // We branchlessly calculate an \"all-ones except for the sign bit\"\n+        // mask from negative-signed values: right shifting sign-extends\n+        // the integer, so we \"fill\" the mask with sign bits, and then\n+        // convert to unsigned to push one more zero bit.\n+        // On positive values, the mask is all zeros, so it's a no-op.\n+        left ^= (((left >> 63) as u64) >> 1) as i64;\n+        right ^= (((right >> 63) as u64) >> 1) as i64;\n+\n+        left.cmp(&right)\n+    }\n }"}, {"sha": "8ff19557a3063467ceeb0c5e663c31700d2390a9", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8", "patch": "@@ -1531,4 +1531,147 @@ mod tests {\n     fn test_clamp_max_is_nan() {\n         let _ = 1.0f32.clamp(3.0, NAN);\n     }\n+\n+    #[test]\n+    fn test_total_cmp() {\n+        use core::cmp::Ordering;\n+\n+        fn quiet_bit_mask() -> u32 {\n+            1 << (f32::MANTISSA_DIGITS - 2)\n+        }\n+\n+        fn min_subnorm() -> f32 {\n+            f32::MIN_POSITIVE / f32::powf(2.0, f32::MANTISSA_DIGITS as f32 - 1.0)\n+        }\n+\n+        fn max_subnorm() -> f32 {\n+            f32::MIN_POSITIVE - min_subnorm()\n+        }\n+\n+        fn q_nan() -> f32 {\n+            f32::from_bits(f32::NAN.to_bits() | quiet_bit_mask())\n+        }\n+\n+        fn s_nan() -> f32 {\n+            f32::from_bits((f32::NAN.to_bits() & !quiet_bit_mask()) + 42)\n+        }\n+\n+        assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Equal, (-f32::INFINITY).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Equal, (-f32::MAX).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Equal, (-2.5_f32).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Equal, (-1.0_f32).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Equal, (-1.5_f32).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Equal, (-0.5_f32).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Equal, (-f32::MIN_POSITIVE).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Equal, (-0.0_f32).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Equal, 0.0_f32.total_cmp(&0.0));\n+        assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Equal, f32::MIN_POSITIVE.total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, 0.5_f32.total_cmp(&0.5));\n+        assert_eq!(Ordering::Equal, 1.0_f32.total_cmp(&1.0));\n+        assert_eq!(Ordering::Equal, 1.5_f32.total_cmp(&1.5));\n+        assert_eq!(Ordering::Equal, 2.5_f32.total_cmp(&2.5));\n+        assert_eq!(Ordering::Equal, f32::MAX.total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Equal, f32::INFINITY.total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-f32::INFINITY).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Less, (-f32::MAX).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-2.5_f32).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-1.5_f32).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-1.0_f32).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-0.5_f32).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-f32::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-0.0_f32).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, 0.0_f32.total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, f32::MIN_POSITIVE.total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, 0.5_f32.total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, 1.0_f32.total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, 1.5_f32.total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, 2.5_f32.total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Less, f32::MAX.total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Less, f32::INFINITY.total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Greater, (-f32::INFINITY).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Greater, (-f32::MAX).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Greater, (-2.5_f32).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Greater, (-1.5_f32).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Greater, (-1.0_f32).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Greater, (-0.5_f32).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Greater, (-f32::MIN_POSITIVE).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Greater, (-0.0_f32).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.0_f32.total_cmp(&-0.0));\n+        assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n+        assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Greater, f32::MIN_POSITIVE.total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.5_f32.total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, 1.0_f32.total_cmp(&0.5));\n+        assert_eq!(Ordering::Greater, 1.5_f32.total_cmp(&1.0));\n+        assert_eq!(Ordering::Greater, 2.5_f32.total_cmp(&1.5));\n+        assert_eq!(Ordering::Greater, f32::MAX.total_cmp(&2.5));\n+        assert_eq!(Ordering::Greater, f32::INFINITY.total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Greater, s_nan().total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n+    }\n }"}, {"sha": "d7845fd2c4ddcc3efe86096faeaf71ecd36fd301", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8", "patch": "@@ -1554,4 +1554,147 @@ mod tests {\n     fn test_clamp_max_is_nan() {\n         let _ = 1.0f64.clamp(3.0, NAN);\n     }\n+\n+    #[test]\n+    fn test_total_cmp() {\n+        use core::cmp::Ordering;\n+\n+        fn quiet_bit_mask() -> u64 {\n+            1 << (f64::MANTISSA_DIGITS - 2)\n+        }\n+\n+        fn min_subnorm() -> f64 {\n+            f64::MIN_POSITIVE / f64::powf(2.0, f64::MANTISSA_DIGITS as f64 - 1.0)\n+        }\n+\n+        fn max_subnorm() -> f64 {\n+            f64::MIN_POSITIVE - min_subnorm()\n+        }\n+\n+        fn q_nan() -> f64 {\n+            f64::from_bits(f64::NAN.to_bits() | quiet_bit_mask())\n+        }\n+\n+        fn s_nan() -> f64 {\n+            f64::from_bits((f64::NAN.to_bits() & !quiet_bit_mask()) + 42)\n+        }\n+\n+        assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Equal, (-f64::INFINITY).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Equal, (-f64::MAX).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Equal, (-2.5_f64).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Equal, (-1.0_f64).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Equal, (-1.5_f64).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Equal, (-0.5_f64).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Equal, (-f64::MIN_POSITIVE).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Equal, (-0.0_f64).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Equal, 0.0_f64.total_cmp(&0.0));\n+        assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Equal, f64::MIN_POSITIVE.total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, 0.5_f64.total_cmp(&0.5));\n+        assert_eq!(Ordering::Equal, 1.0_f64.total_cmp(&1.0));\n+        assert_eq!(Ordering::Equal, 1.5_f64.total_cmp(&1.5));\n+        assert_eq!(Ordering::Equal, 2.5_f64.total_cmp(&2.5));\n+        assert_eq!(Ordering::Equal, f64::MAX.total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Equal, f64::INFINITY.total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-f64::INFINITY).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Less, (-f64::MAX).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-2.5_f64).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-1.5_f64).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-1.0_f64).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-0.5_f64).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-f64::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-0.0_f64).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, 0.0_f64.total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, f64::MIN_POSITIVE.total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, 0.5_f64.total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, 1.0_f64.total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, 1.5_f64.total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, 2.5_f64.total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Less, f64::MAX.total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Less, f64::INFINITY.total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Greater, (-f64::INFINITY).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Greater, (-f64::MAX).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Greater, (-2.5_f64).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Greater, (-1.5_f64).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Greater, (-1.0_f64).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Greater, (-0.5_f64).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Greater, (-f64::MIN_POSITIVE).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Greater, (-0.0_f64).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.0_f64.total_cmp(&-0.0));\n+        assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n+        assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Greater, f64::MIN_POSITIVE.total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.5_f64.total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, 1.0_f64.total_cmp(&0.5));\n+        assert_eq!(Ordering::Greater, 1.5_f64.total_cmp(&1.0));\n+        assert_eq!(Ordering::Greater, 2.5_f64.total_cmp(&1.5));\n+        assert_eq!(Ordering::Greater, f64::MAX.total_cmp(&2.5));\n+        assert_eq!(Ordering::Greater, f64::INFINITY.total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Greater, s_nan().total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n+    }\n }"}, {"sha": "72dfe2937f491082041f1c91c6565e1d5863ed1b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c09f0eb3eb7ca092fdaeacab37bf05fea1e241f8", "patch": "@@ -311,6 +311,7 @@\n #![feature(test)]\n #![feature(thread_local)]\n #![feature(toowned_clone_into)]\n+#![feature(total_cmp)]\n #![feature(trace_macros)]\n #![feature(track_caller)]\n #![feature(try_reserve)]"}]}