{"sha": "74d07699938b846703ab552f52cd5c32f751900f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZDA3Njk5OTM4Yjg0NjcwM2FiNTUyZjUyY2Q1YzMyZjc1MTkwMGY=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-25T00:21:39Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-19T07:31:34Z"}, "message": "Refactor std::os to use sys::os", "tree": {"sha": "692dd24ed1e8ee2091ec6728ac17c7f7d4063659", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/692dd24ed1e8ee2091ec6728ac17c7f7d4063659"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74d07699938b846703ab552f52cd5c32f751900f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74d07699938b846703ab552f52cd5c32f751900f", "html_url": "https://github.com/rust-lang/rust/commit/74d07699938b846703ab552f52cd5c32f751900f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74d07699938b846703ab552f52cd5c32f751900f/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b3477d373603527d23cc578f3737857b7b253d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3477d373603527d23cc578f3737857b7b253d7", "html_url": "https://github.com/rust-lang/rust/commit/2b3477d373603527d23cc578f3737857b7b253d7"}], "stats": {"total": 739, "additions": 352, "deletions": 387}, "files": [{"sha": "550e9e06aae014c3adc41fde080eb8097a3b9d25", "filename": "src/libstd/os.rs", "status": "modified", "additions": 25, "deletions": 381, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/74d07699938b846703ab552f52cd5c32f751900f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d07699938b846703ab552f52cd5c32f751900f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=74d07699938b846703ab552f52cd5c32f751900f", "patch": "@@ -46,7 +46,6 @@ use option::Option::{Some, None};\n use os;\n use path::{Path, GenericPath, BytesContainer};\n use sys;\n-use sys::os as os_imp;\n use ptr::RawPtr;\n use ptr;\n use result::Result;\n@@ -78,7 +77,6 @@ pub fn num_cpus() -> uint {\n }\n \n pub const TMPBUF_SZ : uint = 1000u;\n-const BUF_BYTES : uint = 2048u;\n \n /// Returns the current working directory as a `Path`.\n ///\n@@ -96,118 +94,12 @@ const BUF_BYTES : uint = 2048u;\n /// ```rust\n /// use std::os;\n ///\n-/// // We assume that we are in a valid directory like \"/home\".\n+/// // We assume that we are in a valid directory.\n /// let current_working_directory = os::getcwd().unwrap();\n /// println!(\"The current directory is {}\", current_working_directory.display());\n-/// // /home\n /// ```\n-#[cfg(unix)]\n-pub fn getcwd() -> IoResult<Path> {\n-    use c_str::CString;\n-\n-    let mut buf = [0 as c_char, ..BUF_BYTES];\n-    unsafe {\n-        if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n-            Err(IoError::last_error())\n-        } else {\n-            Ok(Path::new(CString::new(buf.as_ptr(), false)))\n-        }\n-    }\n-}\n-\n-/// Returns the current working directory as a `Path`.\n-///\n-/// # Errors\n-///\n-/// Returns an `Err` if the current working directory value is invalid.\n-/// Possible cases:\n-///\n-/// * Current directory does not exist.\n-/// * There are insufficient permissions to access the current directory.\n-/// * The internal buffer is not large enough to hold the path.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::os;\n-///\n-/// // We assume that we are in a valid directory like \"C:\\\\Windows\".\n-/// let current_working_directory = os::getcwd().unwrap();\n-/// println!(\"The current directory is {}\", current_working_directory.display());\n-/// // C:\\\\Windows\n-/// ```\n-#[cfg(windows)]\n pub fn getcwd() -> IoResult<Path> {\n-    use libc::DWORD;\n-    use libc::GetCurrentDirectoryW;\n-    use io::OtherIoError;\n-\n-    let mut buf = [0 as u16, ..BUF_BYTES];\n-    unsafe {\n-        if libc::GetCurrentDirectoryW(buf.len() as DWORD, buf.as_mut_ptr()) == 0 as DWORD {\n-            return Err(IoError::last_error());\n-        }\n-    }\n-\n-    match String::from_utf16(::str::truncate_utf16_at_nul(&buf)) {\n-        Some(ref cwd) => Ok(Path::new(cwd)),\n-        None => Err(IoError {\n-            kind: OtherIoError,\n-            desc: \"GetCurrentDirectoryW returned invalid UTF-16\",\n-            detail: None,\n-        }),\n-    }\n-}\n-\n-#[cfg(windows)]\n-pub mod windoze {\n-    use libc::types::os::arch::extra::DWORD;\n-    use libc;\n-    use ops::FnMut;\n-    use option::Option;\n-    use option::Option::None;\n-    use option;\n-    use os::TMPBUF_SZ;\n-    use slice::SliceExt;\n-    use string::String;\n-    use str::StrPrelude;\n-    use vec::Vec;\n-\n-    pub fn fill_utf16_buf_and_decode<F>(mut f: F) -> Option<String> where\n-        F: FnMut(*mut u16, DWORD) -> DWORD,\n-    {\n-\n-        unsafe {\n-            let mut n = TMPBUF_SZ as DWORD;\n-            let mut res = None;\n-            let mut done = false;\n-            while !done {\n-                let mut buf = Vec::from_elem(n as uint, 0u16);\n-                let k = f(buf.as_mut_ptr(), n);\n-                if k == (0 as DWORD) {\n-                    done = true;\n-                } else if k == n &&\n-                          libc::GetLastError() ==\n-                          libc::ERROR_INSUFFICIENT_BUFFER as DWORD {\n-                    n *= 2 as DWORD;\n-                } else if k >= n {\n-                    n = k;\n-                } else {\n-                    done = true;\n-                }\n-                if k != 0 && done {\n-                    let sub = buf.slice(0, k as uint);\n-                    // We want to explicitly catch the case when the\n-                    // closure returned invalid UTF-16, rather than\n-                    // set `res` to None and continue.\n-                    let s = String::from_utf16(sub)\n-                        .expect(\"fill_utf16_buf_and_decode: closure created invalid UTF-16\");\n-                    res = option::Option::Some(s)\n-                }\n-            }\n-            return res;\n-        }\n-    }\n+    sys::os::getcwd()\n }\n \n /*\n@@ -253,71 +145,6 @@ pub fn env() -> Vec<(String,String)> {\n /// environment variables of the current process.\n pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n     unsafe {\n-        #[cfg(windows)]\n-        unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n-            use slice;\n-\n-            use libc::funcs::extra::kernel32::{\n-                GetEnvironmentStringsW,\n-                FreeEnvironmentStringsW\n-            };\n-            let ch = GetEnvironmentStringsW();\n-            if ch as uint == 0 {\n-                panic!(\"os::env() failure getting env string from OS: {}\",\n-                       os::last_os_error());\n-            }\n-            // Here, we lossily decode the string as UTF16.\n-            //\n-            // The docs suggest that the result should be in Unicode, but\n-            // Windows doesn't guarantee it's actually UTF16 -- it doesn't\n-            // validate the environment string passed to CreateProcess nor\n-            // SetEnvironmentVariable.  Yet, it's unlikely that returning a\n-            // raw u16 buffer would be of practical use since the result would\n-            // be inherently platform-dependent and introduce additional\n-            // complexity to this code.\n-            //\n-            // Using the non-Unicode version of GetEnvironmentStrings is even\n-            // worse since the result is in an OEM code page.  Characters that\n-            // can't be encoded in the code page would be turned into question\n-            // marks.\n-            let mut result = Vec::new();\n-            let mut i = 0;\n-            while *ch.offset(i) != 0 {\n-                let p = &*ch.offset(i);\n-                let mut len = 0;\n-                while *(p as *const _).offset(len) != 0 {\n-                    len += 1;\n-                }\n-                let p = p as *const u16;\n-                let s = slice::from_raw_buf(&p, len as uint);\n-                result.push(String::from_utf16_lossy(s).into_bytes());\n-                i += len as int + 1;\n-            }\n-            FreeEnvironmentStringsW(ch);\n-            result\n-        }\n-        #[cfg(unix)]\n-        unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n-            use c_str::CString;\n-\n-            extern {\n-                fn rust_env_pairs() -> *const *const c_char;\n-            }\n-            let mut environ = rust_env_pairs();\n-            if environ as uint == 0 {\n-                panic!(\"os::env() failure getting env string from OS: {}\",\n-                       os::last_os_error());\n-            }\n-            let mut result = Vec::new();\n-            while *environ != 0 as *const _ {\n-                let env_pair =\n-                    CString::new(*environ, false).as_bytes_no_nul().to_vec();\n-                result.push(env_pair);\n-                environ = environ.offset(1);\n-            }\n-            result\n-        }\n-\n         fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> {\n             let mut pairs = Vec::new();\n             for p in input.iter() {\n@@ -330,7 +157,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             pairs\n         }\n         with_env_lock(|| {\n-            let unparsed_environ = get_env_pairs();\n+            let unparsed_environ = sys::os::get_env_pairs();\n             env_convert(unparsed_environ)\n         })\n     }\n@@ -390,7 +217,7 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n pub fn getenv(n: &str) -> Option<String> {\n     unsafe {\n         with_env_lock(|| {\n-            use os::windoze::{fill_utf16_buf_and_decode};\n+            use sys::os::fill_utf16_buf_and_decode;\n             let mut n: Vec<u16> = n.utf16_units().collect();\n             n.push(0);\n             fill_utf16_buf_and_decode(|buf, sz| {\n@@ -506,52 +333,7 @@ pub fn unsetenv(n: &str) {\n /// }\n /// ```\n pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-    #[cfg(unix)]\n-    fn _split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-        unparsed.container_as_bytes()\n-                .split(|b| *b == b':')\n-                .map(Path::new)\n-                .collect()\n-    }\n-\n-    #[cfg(windows)]\n-    fn _split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-        // On Windows, the PATH environment variable is semicolon separated.  Double\n-        // quotes are used as a way of introducing literal semicolons (since\n-        // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n-        // permitted in path names, so there is no way to escape a double quote.\n-        // Quoted regions can appear in arbitrary locations, so\n-        //\n-        //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n-        //\n-        // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n-        //\n-        // (The above is based on testing; there is no clear reference available\n-        // for the grammar.)\n-\n-        let mut parsed = Vec::new();\n-        let mut in_progress = Vec::new();\n-        let mut in_quote = false;\n-\n-        for b in unparsed.container_as_bytes().iter() {\n-            match *b {\n-                b';' if !in_quote => {\n-                    parsed.push(Path::new(in_progress.as_slice()));\n-                    in_progress.truncate(0)\n-                }\n-                b'\"' => {\n-                    in_quote = !in_quote;\n-                }\n-                _  => {\n-                    in_progress.push(*b);\n-                }\n-            }\n-        }\n-        parsed.push(Path::new(in_progress));\n-        parsed\n-    }\n-\n-    _split_paths(unparsed)\n+    sys::os::split_paths(unparsed.container_as_bytes())\n }\n \n /// Joins a collection of `Path`s appropriately for the `PATH`\n@@ -576,42 +358,7 @@ pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n /// os::setenv(key, os::join_paths(paths.as_slice()).unwrap());\n /// ```\n pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n-    #[cfg(windows)]\n-    fn _join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n-        let mut joined = Vec::new();\n-        let sep = b';';\n-\n-        for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n-            if i > 0 { joined.push(sep) }\n-            if path.contains(&b'\"') {\n-                return Err(\"path segment contains `\\\"`\");\n-            } else if path.contains(&sep) {\n-                joined.push(b'\"');\n-                joined.push_all(path);\n-                joined.push(b'\"');\n-            } else {\n-                joined.push_all(path);\n-            }\n-        }\n-\n-        Ok(joined)\n-    }\n-\n-    #[cfg(unix)]\n-    fn _join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n-        let mut joined = Vec::new();\n-        let sep = b':';\n-\n-        for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n-            if i > 0 { joined.push(sep) }\n-            if path.contains(&sep) { return Err(\"path segment contains separator `:`\") }\n-            joined.push_all(path);\n-        }\n-\n-        Ok(joined)\n-    }\n-\n-    _join_paths(paths)\n+    sys::os::join_paths(paths)\n }\n \n /// A low-level OS in-memory pipe.\n@@ -664,69 +411,7 @@ pub fn dll_filename(base: &str) -> String {\n /// };\n /// ```\n pub fn self_exe_name() -> Option<Path> {\n-\n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n-    fn load_self() -> Option<Vec<u8>> {\n-        unsafe {\n-            use libc::funcs::bsd44::*;\n-            use libc::consts::os::extra::*;\n-            let mut mib = vec![CTL_KERN as c_int,\n-                               KERN_PROC as c_int,\n-                               KERN_PROC_PATHNAME as c_int,\n-                               -1 as c_int];\n-            let mut sz: libc::size_t = 0;\n-            let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n-                             ptr::null_mut(), &mut sz, ptr::null_mut(),\n-                             0u as libc::size_t);\n-            if err != 0 { return None; }\n-            if sz == 0 { return None; }\n-            let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n-            let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n-                             v.as_mut_ptr() as *mut c_void, &mut sz,\n-                             ptr::null_mut(), 0u as libc::size_t);\n-            if err != 0 { return None; }\n-            if sz == 0 { return None; }\n-            v.set_len(sz as uint - 1); // chop off trailing NUL\n-            Some(v)\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn load_self() -> Option<Vec<u8>> {\n-        use std::io;\n-\n-        match io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n-            Ok(path) => Some(path.into_vec()),\n-            Err(..) => None\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn load_self() -> Option<Vec<u8>> {\n-        unsafe {\n-            use libc::funcs::extra::_NSGetExecutablePath;\n-            let mut sz: u32 = 0;\n-            _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n-            if sz == 0 { return None; }\n-            let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n-            let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n-            if err != 0 { return None; }\n-            v.set_len(sz as uint - 1); // chop off trailing NUL\n-            Some(v)\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn load_self() -> Option<Vec<u8>> {\n-        unsafe {\n-            use os::windoze::fill_utf16_buf_and_decode;\n-            fill_utf16_buf_and_decode(|buf, sz| {\n-                libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n-            }).map(|s| s.into_string().into_bytes())\n-        }\n-    }\n-\n-    load_self().and_then(Path::new_opt)\n+    sys::os::load_self().and_then(Path::new_opt)\n }\n \n /// Optionally returns the filesystem path to the current executable which is\n@@ -842,7 +527,6 @@ pub fn tmpdir() -> Path {\n     }\n }\n \n-///\n /// Convert a relative path to an absolute path\n ///\n /// If the given path is relative, return it prepended with the current working\n@@ -887,37 +571,12 @@ pub fn make_absolute(p: &Path) -> IoResult<Path> {\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n pub fn change_dir(p: &Path) -> IoResult<()> {\n-    return chdir(p);\n-\n-    #[cfg(windows)]\n-    fn chdir(p: &Path) -> IoResult<()> {\n-        let mut p = p.as_str().unwrap().utf16_units().collect::<Vec<u16>>();\n-        p.push(0);\n-\n-        unsafe {\n-            match libc::SetCurrentDirectoryW(p.as_ptr()) != (0 as libc::BOOL) {\n-                true => Ok(()),\n-                false => Err(IoError::last_error()),\n-            }\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn chdir(p: &Path) -> IoResult<()> {\n-        p.with_c_str(|buf| {\n-            unsafe {\n-                match libc::chdir(buf) == (0 as c_int) {\n-                    true => Ok(()),\n-                    false => Err(IoError::last_error()),\n-                }\n-            }\n-        })\n-    }\n+    return sys::os::chdir(p);\n }\n \n /// Returns the platform-specific value of errno\n pub fn errno() -> uint {\n-    os_imp::errno() as uint\n+    sys::os::errno() as uint\n }\n \n /// Return the string corresponding to an `errno()` value of `errnum`.\n@@ -930,7 +589,7 @@ pub fn errno() -> uint {\n /// println!(\"{}\", os::error_string(os::errno() as uint));\n /// ```\n pub fn error_string(errnum: uint) -> String {\n-    return os_imp::error_string(errnum as i32);\n+    return sys::os::error_string(errnum as i32);\n }\n \n /// Get a string representing the platform-dependent last error\n@@ -1144,38 +803,9 @@ extern {\n     pub fn _NSGetArgv() -> *mut *mut *mut c_char;\n }\n \n-// Round up `from` to be divisible by `to`\n-fn round_up(from: uint, to: uint) -> uint {\n-    let r = if from % to == 0 {\n-        from\n-    } else {\n-        from + to - (from % to)\n-    };\n-    if r == 0 {\n-        to\n-    } else {\n-        r\n-    }\n-}\n-\n /// Returns the page size of the current architecture in bytes.\n-#[cfg(unix)]\n pub fn page_size() -> uint {\n-    unsafe {\n-        libc::sysconf(libc::_SC_PAGESIZE) as uint\n-    }\n-}\n-\n-/// Returns the page size of the current architecture in bytes.\n-#[cfg(windows)]\n-pub fn page_size() -> uint {\n-    use mem;\n-    unsafe {\n-        let mut info = mem::zeroed();\n-        libc::GetSystemInfo(&mut info);\n-\n-        return info.dwPageSize as uint;\n-    }\n+    sys::os::page_size()\n }\n \n /// A memory mapped file or chunk of memory. This is a very system-specific\n@@ -1325,6 +955,20 @@ impl FromError<MapError> for Box<Error> {\n     }\n }\n \n+// Round up `from` to be divisible by `to`\n+fn round_up(from: uint, to: uint) -> uint {\n+    let r = if from % to == 0 {\n+        from\n+    } else {\n+        from + to - (from % to)\n+    };\n+    if r == 0 {\n+        to\n+    } else {\n+        r\n+    }\n+}\n+\n #[cfg(unix)]\n impl MemoryMap {\n     /// Create a new mapping with the given `options`, at least `min_len` bytes"}, {"sha": "0ed079df55b353f79e882346738db8ddc56dd350", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 132, "deletions": 3, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/74d07699938b846703ab552f52cd5c32f751900f/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d07699938b846703ab552f52cd5c32f751900f/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=74d07699938b846703ab552f52cd5c32f751900f", "patch": "@@ -8,14 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc;\n-use libc::{c_int, c_char};\n+//! Implementation of `std::os` functionality for unix systems\n+\n use prelude::*;\n-use io::IoResult;\n+\n+use error::{FromError, Error};\n+use fmt;\n+use io::{IoError, IoResult};\n+use libc::{mod, c_int, c_char, c_void};\n+use path::{Path, GenericPath, BytesContainer};\n+use ptr::{mod, RawPtr};\n+use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use sys::fs::FileDesc;\n+use os;\n \n use os::TMPBUF_SZ;\n \n+const BUF_BYTES : uint = 2048u;\n+\n /// Returns the platform-specific value of errno\n pub fn errno() -> int {\n     #[cfg(any(target_os = \"macos\",\n@@ -110,3 +120,122 @@ pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n         Err(super::last_error())\n     }\n }\n+\n+pub fn getcwd() -> IoResult<Path> {\n+    use c_str::CString;\n+\n+    let mut buf = [0 as c_char, ..BUF_BYTES];\n+    unsafe {\n+        if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n+            Err(IoError::last_error())\n+        } else {\n+            Ok(Path::new(CString::new(buf.as_ptr(), false)))\n+        }\n+    }\n+}\n+\n+pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n+    use c_str::CString;\n+\n+    extern {\n+        fn rust_env_pairs() -> *const *const c_char;\n+    }\n+    let mut environ = rust_env_pairs();\n+    if environ as uint == 0 {\n+        panic!(\"os::env() failure getting env string from OS: {}\",\n+               os::last_os_error());\n+    }\n+    let mut result = Vec::new();\n+    while *environ != 0 as *const _ {\n+        let env_pair =\n+            CString::new(*environ, false).as_bytes_no_nul().to_vec();\n+        result.push(env_pair);\n+        environ = environ.offset(1);\n+    }\n+    result\n+}\n+\n+pub fn split_paths(unparsed: &[u8]) -> Vec<Path> {\n+    unparsed.split(|b| *b == b':').map(Path::new).collect()\n+}\n+\n+pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+    let mut joined = Vec::new();\n+    let sep = b':';\n+\n+    for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+        if i > 0 { joined.push(sep) }\n+        if path.contains(&sep) { return Err(\"path segment contains separator `:`\") }\n+        joined.push_all(path);\n+    }\n+\n+    Ok(joined)\n+}\n+\n+#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+pub fn load_self() -> Option<Vec<u8>> {\n+    unsafe {\n+        use libc::funcs::bsd44::*;\n+        use libc::consts::os::extra::*;\n+        let mut mib = vec![CTL_KERN as c_int,\n+                           KERN_PROC as c_int,\n+                           KERN_PROC_PATHNAME as c_int,\n+                           -1 as c_int];\n+        let mut sz: libc::size_t = 0;\n+        let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n+                         ptr::null_mut(), &mut sz, ptr::null_mut(),\n+                         0u as libc::size_t);\n+        if err != 0 { return None; }\n+        if sz == 0 { return None; }\n+        let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n+        let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n+                         v.as_mut_ptr() as *mut c_void, &mut sz,\n+                         ptr::null_mut(), 0u as libc::size_t);\n+        if err != 0 { return None; }\n+        if sz == 0 { return None; }\n+        v.set_len(sz as uint - 1); // chop off trailing NUL\n+        Some(v)\n+    }\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub fn load_self() -> Option<Vec<u8>> {\n+    use std::io;\n+\n+    match io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n+        Ok(path) => Some(path.into_vec()),\n+        Err(..) => None\n+    }\n+}\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+pub fn load_self() -> Option<Vec<u8>> {\n+    unsafe {\n+        use libc::funcs::extra::_NSGetExecutablePath;\n+        let mut sz: u32 = 0;\n+        _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n+        if sz == 0 { return None; }\n+        let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n+        let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n+        if err != 0 { return None; }\n+        v.set_len(sz as uint - 1); // chop off trailing NUL\n+        Some(v)\n+    }\n+}\n+\n+pub fn chdir(p: &Path) -> IoResult<()> {\n+    p.with_c_str(|buf| {\n+        unsafe {\n+            match libc::chdir(buf) == (0 as c_int) {\n+                true => Ok(()),\n+                false => Err(IoError::last_error()),\n+            }\n+        }\n+    })\n+}\n+\n+pub fn page_size() -> uint {\n+    unsafe {\n+        libc::sysconf(libc::_SC_PAGESIZE) as uint\n+    }\n+}"}, {"sha": "5c690180c44d4ed5f6981cc3b87892235f2f6aab", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 195, "deletions": 3, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/74d07699938b846703ab552f52cd5c32f751900f/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d07699938b846703ab552f52cd5c32f751900f/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=74d07699938b846703ab552f52cd5c32f751900f", "patch": "@@ -8,17 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Implementation of `std::os` functionality for Windows\n+\n // FIXME: move various extern bindings from here into liblibc or\n // something similar\n \n-use libc;\n-use libc::{c_int, c_char, c_void};\n use prelude::*;\n+\n+use fmt;\n use io::{IoResult, IoError};\n+use libc::{c_int, c_char, c_void};\n+use libc;\n+use os;\n+use path::{Path, GenericPath, BytesContainer};\n+use ptr::{mod, RawPtr};\n+use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use sys::fs::FileDesc;\n-use ptr;\n \n use os::TMPBUF_SZ;\n+use libc::types::os::arch::extra::DWORD;\n+\n+const BUF_BYTES : uint = 2048u;\n \n pub fn errno() -> uint {\n     use libc::types::os::arch::extra::DWORD;\n@@ -101,3 +111,185 @@ pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n         _ => Err(IoError::last_error()),\n     }\n }\n+\n+pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD) -> Option<String> {\n+    unsafe {\n+        let mut n = TMPBUF_SZ as DWORD;\n+        let mut res = None;\n+        let mut done = false;\n+        while !done {\n+            let mut buf = Vec::from_elem(n as uint, 0u16);\n+            let k = f(buf.as_mut_ptr(), n);\n+            if k == (0 as DWORD) {\n+                done = true;\n+            } else if k == n &&\n+                      libc::GetLastError() ==\n+                      libc::ERROR_INSUFFICIENT_BUFFER as DWORD {\n+                n *= 2 as DWORD;\n+            } else if k >= n {\n+                n = k;\n+            } else {\n+                done = true;\n+            }\n+            if k != 0 && done {\n+                let sub = buf.slice(0, k as uint);\n+                // We want to explicitly catch the case when the\n+                // closure returned invalid UTF-16, rather than\n+                // set `res` to None and continue.\n+                let s = String::from_utf16(sub)\n+                    .expect(\"fill_utf16_buf_and_decode: closure created invalid UTF-16\");\n+                res = option::Some(s)\n+            }\n+        }\n+        return res;\n+    }\n+}\n+\n+pub fn getcwd() -> IoResult<Path> {\n+    use libc::DWORD;\n+    use libc::GetCurrentDirectoryW;\n+    use io::OtherIoError;\n+\n+    let mut buf = [0 as u16, ..BUF_BYTES];\n+    unsafe {\n+        if libc::GetCurrentDirectoryW(buf.len() as DWORD, buf.as_mut_ptr()) == 0 as DWORD {\n+            return Err(IoError::last_error());\n+        }\n+    }\n+\n+    match String::from_utf16(::str::truncate_utf16_at_nul(&buf)) {\n+        Some(ref cwd) => Ok(Path::new(cwd)),\n+        None => Err(IoError {\n+            kind: OtherIoError,\n+            desc: \"GetCurrentDirectoryW returned invalid UTF-16\",\n+            detail: None,\n+        }),\n+    }\n+}\n+\n+pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n+    use libc::funcs::extra::kernel32::{\n+        GetEnvironmentStringsW,\n+        FreeEnvironmentStringsW\n+    };\n+    let ch = GetEnvironmentStringsW();\n+    if ch as uint == 0 {\n+        panic!(\"os::env() failure getting env string from OS: {}\",\n+               os::last_os_error());\n+    }\n+    // Here, we lossily decode the string as UTF16.\n+    //\n+    // The docs suggest that the result should be in Unicode, but\n+    // Windows doesn't guarantee it's actually UTF16 -- it doesn't\n+    // validate the environment string passed to CreateProcess nor\n+    // SetEnvironmentVariable.  Yet, it's unlikely that returning a\n+    // raw u16 buffer would be of practical use since the result would\n+    // be inherently platform-dependent and introduce additional\n+    // complexity to this code.\n+    //\n+    // Using the non-Unicode version of GetEnvironmentStrings is even\n+    // worse since the result is in an OEM code page.  Characters that\n+    // can't be encoded in the code page would be turned into question\n+    // marks.\n+    let mut result = Vec::new();\n+    let mut i = 0;\n+    while *ch.offset(i) != 0 {\n+        let p = &*ch.offset(i);\n+        let mut len = 0;\n+        while *(p as *const _).offset(len) != 0 {\n+            len += 1;\n+        }\n+        let p = p as *const u16;\n+        let s = slice::from_raw_buf(&p, len as uint);\n+        result.push(String::from_utf16_lossy(s).into_bytes());\n+        i += len as int + 1;\n+    }\n+    FreeEnvironmentStringsW(ch);\n+    result\n+}\n+\n+pub fn split_paths(unparsed: &[u8]) -> Vec<Path> {\n+    // On Windows, the PATH environment variable is semicolon separated.  Double\n+    // quotes are used as a way of introducing literal semicolons (since\n+    // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n+    // permitted in path names, so there is no way to escape a double quote.\n+    // Quoted regions can appear in arbitrary locations, so\n+    //\n+    //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n+    //\n+    // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n+    //\n+    // (The above is based on testing; there is no clear reference available\n+    // for the grammar.)\n+\n+    let mut parsed = Vec::new();\n+    let mut in_progress = Vec::new();\n+    let mut in_quote = false;\n+\n+    for b in unparsed.iter() {\n+        match *b {\n+            b';' if !in_quote => {\n+                parsed.push(Path::new(in_progress.as_slice()));\n+                in_progress.truncate(0)\n+            }\n+            b'\"' => {\n+                in_quote = !in_quote;\n+            }\n+            _  => {\n+                in_progress.push(*b);\n+            }\n+        }\n+    }\n+    parsed.push(Path::new(in_progress));\n+    parsed\n+}\n+\n+pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+    let mut joined = Vec::new();\n+    let sep = b';';\n+\n+    for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+        if i > 0 { joined.push(sep) }\n+        if path.contains(&b'\"') {\n+            return Err(\"path segment contains `\\\"`\");\n+        } else if path.contains(&sep) {\n+            joined.push(b'\"');\n+            joined.push_all(path);\n+            joined.push(b'\"');\n+        } else {\n+            joined.push_all(path);\n+        }\n+    }\n+\n+    Ok(joined)\n+}\n+\n+pub fn load_self() -> Option<Vec<u8>> {\n+    unsafe {\n+        fill_utf16_buf_and_decode(|buf, sz| {\n+            libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n+        }).map(|s| s.into_string().into_bytes())\n+    }\n+}\n+\n+pub fn chdir(p: &Path) -> IoResult<()> {\n+    let mut p = p.as_str().unwrap().utf16_units().collect::<Vec<u16>>();\n+    p.push(0);\n+\n+    unsafe {\n+        match libc::SetCurrentDirectoryW(p.as_ptr()) != (0 as libc::BOOL) {\n+            true => Ok(()),\n+            false => Err(IoError::last_error()),\n+        }\n+    }\n+}\n+\n+pub fn page_size() -> uint {\n+    use mem;\n+    unsafe {\n+        let mut info = mem::zeroed();\n+        libc::GetSystemInfo(&mut info);\n+\n+        return info.dwPageSize as uint;\n+    }\n+}"}]}