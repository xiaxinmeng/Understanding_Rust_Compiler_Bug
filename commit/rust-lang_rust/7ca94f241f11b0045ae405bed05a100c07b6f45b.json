{"sha": "7ca94f241f11b0045ae405bed05a100c07b6f45b", "node_id": "C_kwDOAAsO6NoAKDdjYTk0ZjI0MWYxMWIwMDQ1YWU0MDViZWQwNWExMDBjMDdiNmY0NWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-22T03:37:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-22T03:37:20Z"}, "message": "Auto merge of #111781 - the8472:filter-map-chunk, r=thomcc\n\noptimize next_chunk impls for Filter and FilterMap\n\n```\nOLD:\n\nbenchmarks:\n    iter::bench_next_chunk_filter_even                 104.00ns/iter  +/- 1.00ns\n    iter::bench_next_chunk_filter_map_even             101.00ns/iter  +/- 1.00ns\n    iter::bench_next_chunk_filter_map_mostly_false       1.99\u00b5s/iter +/- 10.00ns\n    iter::bench_next_chunk_filter_map_predictably_true  56.00ns/iter  +/- 0.00ns\n    iter::bench_next_chunk_filter_mostly_false           1.15\u00b5s/iter  +/- 6.00ns\n    iter::bench_next_chunk_filter_predictably_true      65.00ns/iter  +/- 1.00ns\n\nNEW:\n\nbenchmarks:\n    iter::bench_next_chunk_filter_even                  42.00ns/iter  +/- 0.00ns\n    iter::bench_next_chunk_filter_map_even              49.00ns/iter  +/- 1.00ns\n    iter::bench_next_chunk_filter_map_mostly_false     501.00ns/iter  +/- 3.00ns\n    iter::bench_next_chunk_filter_map_predictably_true  31.00ns/iter  +/- 0.00ns\n    iter::bench_next_chunk_filter_mostly_false         534.00ns/iter +/- 13.00ns\n    iter::bench_next_chunk_filter_predictably_true      28.00ns/iter  +/- 1.00ns\n```", "tree": {"sha": "ca2d10bf40f9ab799772880f5d90751607b8900a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca2d10bf40f9ab799772880f5d90751607b8900a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ca94f241f11b0045ae405bed05a100c07b6f45b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ca94f241f11b0045ae405bed05a100c07b6f45b", "html_url": "https://github.com/rust-lang/rust/commit/7ca94f241f11b0045ae405bed05a100c07b6f45b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ca94f241f11b0045ae405bed05a100c07b6f45b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3869b7b12df0320d869479768c540db1a220f7a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3869b7b12df0320d869479768c540db1a220f7a4", "html_url": "https://github.com/rust-lang/rust/commit/3869b7b12df0320d869479768c540db1a220f7a4"}, {"sha": "b40896d17b312b8c5430a25fd7ffbf6770138b4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b40896d17b312b8c5430a25fd7ffbf6770138b4b", "html_url": "https://github.com/rust-lang/rust/commit/b40896d17b312b8c5430a25fd7ffbf6770138b4b"}], "stats": {"total": 163, "additions": 160, "deletions": 3}, "files": [{"sha": "60ef83223d104c296740418463011e29845b92e0", "filename": "library/core/benches/iter.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7ca94f241f11b0045ae405bed05a100c07b6f45b/library%2Fcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca94f241f11b0045ae405bed05a100c07b6f45b/library%2Fcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fiter.rs?ref=7ca94f241f11b0045ae405bed05a100c07b6f45b", "patch": "@@ -404,7 +404,7 @@ fn bench_trusted_random_access_adapters(b: &mut Bencher) {\n \n /// Exercises the iter::Copied specialization for slice::Iter\n #[bench]\n-fn bench_copied_chunks(b: &mut Bencher) {\n+fn bench_next_chunk_copied(b: &mut Bencher) {\n     let v = vec![1u8; 1024];\n \n     b.iter(|| {\n@@ -421,7 +421,7 @@ fn bench_copied_chunks(b: &mut Bencher) {\n \n /// Exercises the TrustedRandomAccess specialization in ArrayChunks\n #[bench]\n-fn bench_trusted_random_access_chunks(b: &mut Bencher) {\n+fn bench_next_chunk_trusted_random_access(b: &mut Bencher) {\n     let v = vec![1u8; 1024];\n \n     b.iter(|| {\n@@ -437,3 +437,45 @@ fn bench_trusted_random_access_chunks(b: &mut Bencher) {\n             .sum::<Wrapping<u64>>()\n     })\n }\n+\n+#[bench]\n+fn bench_next_chunk_filter_even(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter(|&&i| i % 2 == 0).next_chunk::<32>())\n+}\n+\n+#[bench]\n+fn bench_next_chunk_filter_predictably_true(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter(|&&i| i < 100).next_chunk::<32>())\n+}\n+\n+#[bench]\n+fn bench_next_chunk_filter_mostly_false(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter(|&&i| i > 900).next_chunk::<32>())\n+}\n+\n+#[bench]\n+fn bench_next_chunk_filter_map_even(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter_map(|&i| (i % 2 == 0).then(|| i)).next_chunk::<32>())\n+}\n+\n+#[bench]\n+fn bench_next_chunk_filter_map_predictably_true(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter_map(|&i| (i < 100).then(|| i)).next_chunk::<32>())\n+}\n+\n+#[bench]\n+fn bench_next_chunk_filter_map_mostly_false(b: &mut Bencher) {\n+    let a = (0..1024).next_chunk::<1024>().unwrap();\n+\n+    b.iter(|| black_box(&a).iter().filter_map(|&i| (i > 900).then(|| i)).next_chunk::<32>())\n+}"}, {"sha": "723657b9e43e438706e7801efacfe7891e0511f6", "filename": "library/core/src/iter/adapters/filter.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7ca94f241f11b0045ae405bed05a100c07b6f45b/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca94f241f11b0045ae405bed05a100c07b6f45b/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs?ref=7ca94f241f11b0045ae405bed05a100c07b6f45b", "patch": "@@ -1,6 +1,9 @@\n use crate::fmt;\n use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n use crate::ops::Try;\n+use core::array;\n+use core::mem::{ManuallyDrop, MaybeUninit};\n+use core::ops::ControlFlow;\n \n /// An iterator that filters the elements of `iter` with `predicate`.\n ///\n@@ -56,6 +59,58 @@ where\n         self.iter.find(&mut self.predicate)\n     }\n \n+    #[inline]\n+    fn next_chunk<const N: usize>(\n+        &mut self,\n+    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n+        let mut array: [MaybeUninit<Self::Item>; N] = MaybeUninit::uninit_array();\n+\n+        struct Guard<'a, T> {\n+            array: &'a mut [MaybeUninit<T>],\n+            initialized: usize,\n+        }\n+\n+        impl<T> Drop for Guard<'_, T> {\n+            #[inline]\n+            fn drop(&mut self) {\n+                if const { crate::mem::needs_drop::<T>() } {\n+                    // SAFETY: self.initialized is always <= N, which also is the length of the array.\n+                    unsafe {\n+                        core::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n+                            self.array.get_unchecked_mut(..self.initialized),\n+                        ));\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut guard = Guard { array: &mut array, initialized: 0 };\n+\n+        let result = self.iter.try_for_each(|element| {\n+            let idx = guard.initialized;\n+            guard.initialized = idx + (self.predicate)(&element) as usize;\n+\n+            // SAFETY: Loop conditions ensure the index is in bounds.\n+            unsafe { guard.array.get_unchecked_mut(idx) }.write(element);\n+\n+            if guard.initialized < N { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }\n+        });\n+\n+        let guard = ManuallyDrop::new(guard);\n+\n+        match result {\n+            ControlFlow::Break(()) => {\n+                // SAFETY: The loop above is only explicitly broken when the array has been fully initialized\n+                Ok(unsafe { MaybeUninit::array_assume_init(array) })\n+            }\n+            ControlFlow::Continue(()) => {\n+                let initialized = guard.initialized;\n+                // SAFETY: The range is in bounds since the loop breaks when reaching N elements.\n+                Err(unsafe { array::IntoIter::new_unchecked(array, 0..initialized) })\n+            }\n+        }\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();"}, {"sha": "693479977db51b4a36194d5bfe1aaa5f710612d9", "filename": "library/core/src/iter/adapters/filter_map.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7ca94f241f11b0045ae405bed05a100c07b6f45b/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca94f241f11b0045ae405bed05a100c07b6f45b/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs?ref=7ca94f241f11b0045ae405bed05a100c07b6f45b", "patch": "@@ -1,6 +1,7 @@\n-use crate::fmt;\n use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::mem::{ManuallyDrop, MaybeUninit};\n use crate::ops::{ControlFlow, Try};\n+use crate::{array, fmt};\n \n /// An iterator that uses `f` to both filter and map elements from `iter`.\n ///\n@@ -61,6 +62,65 @@ where\n         self.iter.find_map(&mut self.f)\n     }\n \n+    #[inline]\n+    fn next_chunk<const N: usize>(\n+        &mut self,\n+    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n+        let mut array: [MaybeUninit<Self::Item>; N] = MaybeUninit::uninit_array();\n+\n+        struct Guard<'a, T> {\n+            array: &'a mut [MaybeUninit<T>],\n+            initialized: usize,\n+        }\n+\n+        impl<T> Drop for Guard<'_, T> {\n+            #[inline]\n+            fn drop(&mut self) {\n+                if const { crate::mem::needs_drop::<T>() } {\n+                    // SAFETY: self.initialized is always <= N, which also is the length of the array.\n+                    unsafe {\n+                        core::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n+                            self.array.get_unchecked_mut(..self.initialized),\n+                        ));\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut guard = Guard { array: &mut array, initialized: 0 };\n+\n+        let result = self.iter.try_for_each(|element| {\n+            let idx = guard.initialized;\n+            let val = (self.f)(element);\n+            guard.initialized = idx + val.is_some() as usize;\n+\n+            // SAFETY: Loop conditions ensure the index is in bounds.\n+\n+            unsafe {\n+                let opt_payload_at = core::intrinsics::option_payload_ptr(&val);\n+                let dst = guard.array.as_mut_ptr().add(idx);\n+                crate::ptr::copy_nonoverlapping(opt_payload_at.cast(), dst, 1);\n+                crate::mem::forget(val);\n+            };\n+\n+            if guard.initialized < N { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }\n+        });\n+\n+        let guard = ManuallyDrop::new(guard);\n+\n+        match result {\n+            ControlFlow::Break(()) => {\n+                // SAFETY: The loop above is only explicitly broken when the array has been fully initialized\n+                Ok(unsafe { MaybeUninit::array_assume_init(array) })\n+            }\n+            ControlFlow::Continue(()) => {\n+                let initialized = guard.initialized;\n+                // SAFETY: The range is in bounds since the loop breaks when reaching N elements.\n+                Err(unsafe { array::IntoIter::new_unchecked(array, 0..initialized) })\n+            }\n+        }\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();"}]}