{"sha": "d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZGM0Mjc2ZmRiNWQ1YzRkOGQ3ZmY2OTA2MjEzZGI2YzZlZDRkN2U=", "commit": {"author": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-06-17T04:20:18Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-07-20T14:14:42Z"}, "message": "Refactor vtable format.", "tree": {"sha": "eaff15648d332d35a07e8892260d8a6f3b13240d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaff15648d332d35a07e8892260d8a6f3b13240d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e", "html_url": "https://github.com/rust-lang/rust/commit/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e/comments", "author": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da7d405357600a76f2b93b8aa41fe5ee5da7885d", "url": "https://api.github.com/repos/rust-lang/rust/commits/da7d405357600a76f2b93b8aa41fe5ee5da7885d", "html_url": "https://github.com/rust-lang/rust/commit/da7d405357600a76f2b93b8aa41fe5ee5da7885d"}], "stats": {"total": 375, "additions": 314, "deletions": 61}, "files": [{"sha": "ce1445f8a47466609116d60603fdce9b95c9e02e", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e", "patch": "@@ -14,17 +14,17 @@ pub fn anonymize_predicate<'tcx>(\n     tcx.reuse_or_mk_predicate(pred, new)\n }\n \n-struct PredicateSet<'tcx> {\n+pub struct PredicateSet<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     set: FxHashSet<ty::Predicate<'tcx>>,\n }\n \n impl PredicateSet<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n         Self { tcx, set: Default::default() }\n     }\n \n-    fn insert(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n+    pub fn insert(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n         // We have to be careful here because we want\n         //\n         //    for<'a> Foo<&'a i32>"}, {"sha": "c17757020135e3fb2f5cc22f5f1e4525e8909c3c", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e", "patch": "@@ -2,7 +2,7 @@ use std::convert::TryFrom;\n \n use crate::mir::interpret::{alloc_range, AllocId, Allocation, Pointer, Scalar, ScalarMaybeUninit};\n use crate::ty::fold::TypeFoldable;\n-use crate::ty::{self, DefId, SubstsRef, Ty, TyCtxt};\n+use crate::ty::{self, DefId, PolyExistentialTraitRef, SubstsRef, Ty, TyCtxt};\n use rustc_ast::Mutability;\n \n #[derive(Clone, Copy, Debug, PartialEq, HashStable)]\n@@ -12,6 +12,7 @@ pub enum VtblEntry<'tcx> {\n     MetadataAlign,\n     Vacant,\n     Method(DefId, SubstsRef<'tcx>),\n+    TraitVPtr(PolyExistentialTraitRef<'tcx>),\n }\n \n pub const COMMON_VTABLE_ENTRIES: &[VtblEntry<'_>] =\n@@ -92,6 +93,11 @@ impl<'tcx> TyCtxt<'tcx> {\n                     let fn_ptr = Pointer::from(fn_alloc_id);\n                     ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n                 }\n+                VtblEntry::TraitVPtr(trait_ref) => {\n+                    let supertrait_alloc_id = self.vtable_allocation(ty, Some(*trait_ref));\n+                    let vptr = Pointer::from(supertrait_alloc_id);\n+                    ScalarMaybeUninit::from_pointer(vptr, &tcx)\n+                }\n             };\n             vtable\n                 .write_scalar(&tcx, alloc_range(ptr_size * idx, ptr_size), scalar)"}, {"sha": "85c51bbff9dc3f970b8cc2bd89f63cbd4709a114", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e", "patch": "@@ -1116,6 +1116,10 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n                     | VtblEntry::MetadataSize\n                     | VtblEntry::MetadataAlign\n                     | VtblEntry::Vacant => None,\n+                    VtblEntry::TraitVPtr(_) => {\n+                        // all super trait items already covered, so skip them.\n+                        None\n+                    }\n                     VtblEntry::Method(def_id, substs) => ty::Instance::resolve_for_vtable(\n                         tcx,\n                         ty::ParamEnv::reveal_all(),"}, {"sha": "017a7c45bbf9d21fd8d6c49dad2264a9a6beac92", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e", "patch": "@@ -31,6 +31,8 @@ extern crate rustc_data_structures;\n extern crate tracing;\n #[macro_use]\n extern crate rustc_middle;\n+#[macro_use]\n+extern crate smallvec;\n \n pub mod autoderef;\n pub mod infer;"}, {"sha": "9537aa20e7aa56216c47ba823cde588617657cd2", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 298, "deletions": 57, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=d2dc4276fdb5d5c4d8d7ff6906213db6c6ed4d7e", "patch": "@@ -35,8 +35,10 @@ use rustc_middle::ty::{\n     COMMON_VTABLE_ENTRIES,\n };\n use rustc_span::Span;\n+use smallvec::SmallVec;\n \n use std::fmt::Debug;\n+use std::ops::ControlFlow;\n \n pub use self::FulfillmentErrorCode::*;\n pub use self::ImplSource::*;\n@@ -454,6 +456,164 @@ fn subst_and_check_impossible_predicates<'tcx>(\n     result\n }\n \n+#[derive(Clone, Debug)]\n+enum VtblSegment<'tcx> {\n+    MetadataDSA,\n+    TraitOwnEntries { trait_ref: ty::PolyTraitRef<'tcx>, emit_vptr: bool },\n+}\n+\n+/// Prepare the segments for a vtable\n+fn prepare_vtable_segments<'tcx, T>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    mut segment_visitor: impl FnMut(VtblSegment<'tcx>) -> ControlFlow<T>,\n+) -> Option<T> {\n+    // The following constraints holds for the final arrangement.\n+    // 1. The whole virtual table of the first direct super trait is included as the\n+    //    the prefix. If this trait doesn't have any super traits, then this step\n+    //    consists of the dsa metadata.\n+    // 2. Then comes the proper pointer metadata(vptr) and all own methods for all\n+    //    other super traits except those already included as part of the first\n+    //    direct super trait virtual table.\n+    // 3. finally, the own methods of this trait.\n+\n+    // This has the advantage that trait upcasting to the first direct super trait on each level\n+    // is zero cost, and to another trait includes only replacing the pointer with one level indirection,\n+    // while not using too much extra memory.\n+\n+    // For a single inheritance relationship like this,\n+    //   D --> C --> B --> A\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, C, D\n+\n+    // For a multiple inheritance relationship like this,\n+    //   D --> C --> A\n+    //           \\-> B\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, B-vptr, C, D\n+\n+    // For a diamond inheritance relationship like this,\n+    //   D --> B --> A\n+    //     \\-> C -/\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, C, C-vptr, D\n+\n+    // For a more complex inheritance relationship like this:\n+    //   O --> G --> C --> A\n+    //     \\     \\     \\-> B\n+    //     |     |-> F --> D\n+    //     |           \\-> E\n+    //     |-> N --> J --> H\n+    //           \\     \\-> I\n+    //           |-> M --> K\n+    //                 \\-> L\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, B-vptr, C, D, D-vptr, E, E-vptr, F, F-vptr, G,\n+    //  H, H-vptr, I, I-vptr, J, J-vptr, K, K-vptr, L, L-vptr, M, M-vptr,\n+    //  N, N-vptr, O\n+\n+    // emit dsa segment first.\n+    if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::MetadataDSA) {\n+        return Some(v);\n+    }\n+\n+    let mut emit_vptr_on_new_entry = false;\n+    let mut visited = util::PredicateSet::new(tcx);\n+    let predicate = trait_ref.without_const().to_predicate(tcx);\n+    let mut stack: SmallVec<[(ty::PolyTraitRef<'tcx>, _, _); 5]> =\n+        smallvec![(trait_ref, emit_vptr_on_new_entry, None)];\n+    visited.insert(predicate);\n+\n+    // the main traversal loop:\n+    // basically we want to cut the inheritance directed graph into a few non-overlapping slices of nodes\n+    // that each node is emited after all its descendents have been emitted.\n+    // so we convert the directed graph into a tree by skipping all previously visted nodes using a visited set.\n+    // this is done on the fly.\n+    // Each loop run emits a slice - it starts by find a \"childless\" unvisited node, backtracking upwards, and it\n+    // stops after it finds a node that has a next-sibling node.\n+    // This next-sibling node will used as the starting point of next slice.\n+\n+    // Example:\n+    // For a diamond inheritance relationship like this,\n+    //   D#1 --> B#0 --> A#0\n+    //     \\-> C#1 -/\n+\n+    // Starting point 0 stack [D]\n+    // Loop run #0: Stack after diving in is [D B A], A is \"childless\"\n+    // after this point, all newly visited nodes won't have a vtable that equals to a prefix of this one.\n+    // Loop run #0: Emiting the slice [B A] (in reverse order), B has a next-sibling node, so this slice stops here.\n+    // Loop run #0: Stack after exiting out is [D C], C is the next starting point.\n+    // Loop run #1: Stack after diving in is [D C], C is \"childless\", since its child A is skipped(already emitted).\n+    // Loop run #1: Emiting the slice [D C] (in reverse order). No one has a next-sibling node.\n+    // Loop run #1: Stack after exiting out is []. Now the function exits.\n+\n+    loop {\n+        // dive deeper into the stack, recording the path\n+        'diving_in: loop {\n+            if let Some((inner_most_trait_ref, _, _)) = stack.last() {\n+                let inner_most_trait_ref = *inner_most_trait_ref;\n+                let mut direct_super_traits_iter = tcx\n+                    .super_predicates_of(inner_most_trait_ref.def_id())\n+                    .predicates\n+                    .into_iter()\n+                    .filter_map(move |(pred, _)| {\n+                        pred.subst_supertrait(tcx, &inner_most_trait_ref).to_opt_poly_trait_ref()\n+                    });\n+\n+                'diving_in_skip_visited_traits: loop {\n+                    if let Some(next_super_trait) = direct_super_traits_iter.next() {\n+                        if visited.insert(next_super_trait.to_predicate(tcx)) {\n+                            stack.push((\n+                                next_super_trait.value,\n+                                emit_vptr_on_new_entry,\n+                                Some(direct_super_traits_iter),\n+                            ));\n+                            break 'diving_in_skip_visited_traits;\n+                        } else {\n+                            continue 'diving_in_skip_visited_traits;\n+                        }\n+                    } else {\n+                        break 'diving_in;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Other than the left-most path, vptr should be emitted for each trait.\n+        emit_vptr_on_new_entry = true;\n+\n+        // emit innermost item, move to next sibling and stop there if possible, otherwise jump to outer level.\n+        'exiting_out: loop {\n+            if let Some((inner_most_trait_ref, emit_vptr, siblings_opt)) = stack.last_mut() {\n+                if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::TraitOwnEntries {\n+                    trait_ref: *inner_most_trait_ref,\n+                    emit_vptr: *emit_vptr,\n+                }) {\n+                    return Some(v);\n+                }\n+\n+                'exiting_out_skip_visited_traits: loop {\n+                    if let Some(siblings) = siblings_opt {\n+                        if let Some(next_inner_most_trait_ref) = siblings.next() {\n+                            if visited.insert(next_inner_most_trait_ref.to_predicate(tcx)) {\n+                                *inner_most_trait_ref = next_inner_most_trait_ref.value;\n+                                *emit_vptr = emit_vptr_on_new_entry;\n+                                break 'exiting_out;\n+                            } else {\n+                                continue 'exiting_out_skip_visited_traits;\n+                            }\n+                        }\n+                    }\n+                    stack.pop();\n+                    continue 'exiting_out;\n+                }\n+            }\n+            // all done\n+            return None;\n+        }\n+    }\n+}\n+\n /// Given a trait `trait_ref`, iterates the vtable entries\n /// that come from `trait_ref`, including its supertraits.\n fn vtable_entries<'tcx>(\n@@ -462,57 +622,76 @@ fn vtable_entries<'tcx>(\n ) -> &'tcx [VtblEntry<'tcx>] {\n     debug!(\"vtable_entries({:?})\", trait_ref);\n \n-    let entries = COMMON_VTABLE_ENTRIES.iter().cloned().chain(\n-        supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-            let trait_methods = tcx\n-                .associated_items(trait_ref.def_id())\n-                .in_definition_order()\n-                .filter(|item| item.kind == ty::AssocKind::Fn);\n-\n-            // Now list each method's DefId and InternalSubsts (for within its trait).\n-            // If the method can never be called from this object, produce `Vacant`.\n-            trait_methods.map(move |trait_method| {\n-                debug!(\"vtable_entries: trait_method={:?}\", trait_method);\n-                let def_id = trait_method.def_id;\n-\n-                // Some methods cannot be called on an object; skip those.\n-                if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n-                    debug!(\"vtable_entries: not vtable safe\");\n-                    return VtblEntry::Vacant;\n-                }\n+    let mut entries = vec![];\n \n-                // The method may have some early-bound lifetimes; add regions for those.\n-                let substs = trait_ref.map_bound(|trait_ref| {\n-                    InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n-                        GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                        GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                            trait_ref.substs[param.index as usize]\n-                        }\n-                    })\n+    let vtable_segment_callback = |segment| -> ControlFlow<()> {\n+        match segment {\n+            VtblSegment::MetadataDSA => {\n+                entries.extend(COMMON_VTABLE_ENTRIES);\n+            }\n+            VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                let trait_methods = tcx\n+                    .associated_items(trait_ref.def_id())\n+                    .in_definition_order()\n+                    .filter(|item| item.kind == ty::AssocKind::Fn);\n+                // Now list each method's DefId and InternalSubsts (for within its trait).\n+                // If the method can never be called from this object, produce `Vacant`.\n+                let own_entries = trait_methods.map(move |trait_method| {\n+                    debug!(\"vtable_entries: trait_method={:?}\", trait_method);\n+                    let def_id = trait_method.def_id;\n+\n+                    // Some methods cannot be called on an object; skip those.\n+                    if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n+                        debug!(\"vtable_entries: not vtable safe\");\n+                        return VtblEntry::Vacant;\n+                    }\n+\n+                    // The method may have some early-bound lifetimes; add regions for those.\n+                    let substs = trait_ref.map_bound(|trait_ref| {\n+                        InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+                            GenericParamDefKind::Type { .. }\n+                            | GenericParamDefKind::Const { .. } => {\n+                                trait_ref.substs[param.index as usize]\n+                            }\n+                        })\n+                    });\n+\n+                    // The trait type may have higher-ranked lifetimes in it;\n+                    // erase them if they appear, so that we get the type\n+                    // at some particular call site.\n+                    let substs = tcx\n+                        .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n+\n+                    // It's possible that the method relies on where-clauses that\n+                    // do not hold for this particular set of type parameters.\n+                    // Note that this method could then never be called, so we\n+                    // do not want to try and codegen it, in that case (see #23435).\n+                    let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+                    if impossible_predicates(tcx, predicates.predicates) {\n+                        debug!(\"vtable_entries: predicates do not hold\");\n+                        return VtblEntry::Vacant;\n+                    }\n+\n+                    VtblEntry::Method(def_id, substs)\n                 });\n \n-                // The trait type may have higher-ranked lifetimes in it;\n-                // erase them if they appear, so that we get the type\n-                // at some particular call site.\n-                let substs =\n-                    tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n-\n-                // It's possible that the method relies on where-clauses that\n-                // do not hold for this particular set of type parameters.\n-                // Note that this method could then never be called, so we\n-                // do not want to try and codegen it, in that case (see #23435).\n-                let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-                if impossible_predicates(tcx, predicates.predicates) {\n-                    debug!(\"vtable_entries: predicates do not hold\");\n-                    return VtblEntry::Vacant;\n+                entries.extend(own_entries);\n+\n+                if emit_vptr {\n+                    let trait_ref = trait_ref.map_bound(|trait_ref| {\n+                        ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref)\n+                    });\n+                    entries.push(VtblEntry::TraitVPtr(trait_ref));\n                 }\n+            }\n+        }\n \n-                VtblEntry::Method(def_id, substs)\n-            })\n-        }),\n-    );\n+        ControlFlow::Continue(())\n+    };\n \n-    tcx.arena.alloc_from_iter(entries)\n+    let _ = prepare_vtable_segments(tcx, trait_ref, vtable_segment_callback);\n+    tcx.arena.alloc_from_iter(entries.into_iter())\n }\n \n /// Find slot base for trait methods within vtable entries of another trait\n@@ -525,20 +704,82 @@ fn vtable_trait_first_method_offset<'tcx>(\n ) -> usize {\n     let (trait_to_be_found, trait_owning_vtable) = key;\n \n-    let mut supertraits = util::supertraits(tcx, trait_owning_vtable);\n+    let vtable_segment_callback = {\n+        let mut vtable_base = 0;\n+\n+        move |segment| {\n+            match segment {\n+                VtblSegment::MetadataDSA => {\n+                    vtable_base += COMMON_VTABLE_ENTRIES.len();\n+                }\n+                VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                    if trait_ref == trait_to_be_found {\n+                        return ControlFlow::Break(vtable_base);\n+                    }\n+                    vtable_base += util::count_own_vtable_entries(tcx, trait_ref);\n+                    if emit_vptr {\n+                        vtable_base += 1;\n+                    }\n+                }\n+            }\n+            ControlFlow::Continue(())\n+        }\n+    };\n \n-    // For each of the non-matching predicates that\n-    // we pass over, we sum up the set of number of vtable\n-    // entries, so that we can compute the offset for the selected\n-    // trait.\n-    let vtable_base = ty::COMMON_VTABLE_ENTRIES.len()\n-        + supertraits\n-            .by_ref()\n-            .take_while(|t| *t != trait_to_be_found)\n-            .map(|t| util::count_own_vtable_entries(tcx, t))\n-            .sum::<usize>();\n+    if let Some(vtable_base) =\n+        prepare_vtable_segments(tcx, trait_owning_vtable, vtable_segment_callback)\n+    {\n+        vtable_base\n+    } else {\n+        bug!(\"Failed to find info for expected trait in vtable\");\n+    }\n+}\n \n-    vtable_base\n+/// Find slot offset for trait vptr within vtable entries of another trait\n+/// FIXME: This function is not yet used. Remove `#[allow(dead_code)]` when it's used in upcoming pr.\n+#[allow(dead_code)]\n+fn vtable_trait_vptr_slot_offset<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        ty::PolyTraitRef<'tcx>, // trait_to_be_found\n+        ty::PolyTraitRef<'tcx>, // trait_owning_vtable\n+    ),\n+) -> Option<usize> {\n+    let (trait_to_be_found, trait_owning_vtable) = key;\n+\n+    let vtable_segment_callback = {\n+        let mut vptr_offset = 0;\n+        move |segment| {\n+            match segment {\n+                VtblSegment::MetadataDSA => {\n+                    vptr_offset += COMMON_VTABLE_ENTRIES.len();\n+                }\n+                VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                    vptr_offset += util::count_own_vtable_entries(tcx, trait_ref);\n+                    if trait_ref == trait_to_be_found {\n+                        if emit_vptr {\n+                            return ControlFlow::Break(Some(vptr_offset));\n+                        } else {\n+                            return ControlFlow::Break(None);\n+                        }\n+                    }\n+\n+                    if emit_vptr {\n+                        vptr_offset += 1;\n+                    }\n+                }\n+            }\n+            ControlFlow::Continue(())\n+        }\n+    };\n+\n+    if let Some(vptr_offset) =\n+        prepare_vtable_segments(tcx, trait_owning_vtable, vtable_segment_callback)\n+    {\n+        vptr_offset\n+    } else {\n+        bug!(\"Failed to find info for expected trait in vtable\");\n+    }\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}]}