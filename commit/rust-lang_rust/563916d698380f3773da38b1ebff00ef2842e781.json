{"sha": "563916d698380f3773da38b1ebff00ef2842e781", "node_id": "C_kwDOAAsO6NoAKDU2MzkxNmQ2OTgzODBmMzc3M2RhMzhiMWViZmYwMGVmMjg0MmU3ODE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-10T19:15:30Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-20T10:26:37Z"}, "message": "Lint single-use-lifetimes on the AST.", "tree": {"sha": "b3349db03ea4fbadc6089ad026c8e2715da6b2ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3349db03ea4fbadc6089ad026c8e2715da6b2ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/563916d698380f3773da38b1ebff00ef2842e781", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/563916d698380f3773da38b1ebff00ef2842e781", "html_url": "https://github.com/rust-lang/rust/commit/563916d698380f3773da38b1ebff00ef2842e781", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/563916d698380f3773da38b1ebff00ef2842e781/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db8a9274a9e3feb90c3db5f7046f9b3566867f5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/db8a9274a9e3feb90c3db5f7046f9b3566867f5a", "html_url": "https://github.com/rust-lang/rust/commit/db8a9274a9e3feb90c3db5f7046f9b3566867f5a"}], "stats": {"total": 833, "additions": 364, "deletions": 469}, "files": [{"sha": "2c6bdef361aabc49b31e64dfe34eb9d15fcc669f", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -819,6 +819,43 @@ pub trait LintContext: Sized {\n                         \"see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\",\n                     );\n                 },\n+                BuiltinLintDiagnostics::SingleUseLifetime {\n+                    param_span,\n+                    use_span: Some((use_span, elide)),\n+                    deletion_span,\n+                } => {\n+                    debug!(?param_span, ?use_span, ?deletion_span);\n+                    db.span_label(param_span, \"this lifetime...\");\n+                    db.span_label(use_span, \"...is used only here\");\n+                    let msg = \"elide the single-use lifetime\";\n+                    let (use_span, replace_lt) = if elide {\n+                        let use_span = sess.source_map().span_extend_while(\n+                            use_span,\n+                            char::is_whitespace,\n+                        ).unwrap_or(use_span);\n+                        (use_span, String::new())\n+                    } else {\n+                        (use_span, \"'_\".to_owned())\n+                    };\n+                    db.multipart_suggestion(\n+                        msg,\n+                        vec![(deletion_span, String::new()), (use_span, replace_lt)],\n+                        Applicability::MachineApplicable,\n+                    );\n+                },\n+                BuiltinLintDiagnostics::SingleUseLifetime {\n+                    param_span: _,\n+                    use_span: None,\n+                    deletion_span,\n+                } => {\n+                    debug!(?deletion_span);\n+                    db.span_suggestion(\n+                        deletion_span,\n+                        \"elide the unused lifetime\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                },\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(LintDiagnosticBuilder::new(db));"}, {"sha": "8e505152fc4a0199c4295fd1ba9b1a132703ed68", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -239,6 +239,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n \n     fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n         run_early_pass!(self, check_generic_param, param);\n+        self.check_id(param.id);\n         ast_visit::walk_generic_param(self, param);\n     }\n "}, {"sha": "54f2c72527924dc550315c3db963ee5e0a521b1d", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::lint::{\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{RegisteredTools, TyCtxt};\n use rustc_session::lint::{\n-    builtin::{self, FORBIDDEN_LINT_GROUPS, UNFULFILLED_LINT_EXPECTATIONS},\n+    builtin::{self, FORBIDDEN_LINT_GROUPS, SINGLE_USE_LIFETIMES, UNFULFILLED_LINT_EXPECTATIONS},\n     Level, Lint, LintExpectationId, LintId,\n };\n use rustc_session::parse::{add_feature_diagnostics, feature_err};\n@@ -259,6 +259,14 @@ impl<'s> LintLevelsBuilder<'s> {\n         let sess = self.sess;\n         let bad_attr = |span| struct_span_err!(sess, span, E0452, \"malformed lint attribute input\");\n         for (attr_index, attr) in attrs.iter().enumerate() {\n+            if attr.has_name(sym::automatically_derived) {\n+                self.current_specs_mut().insert(\n+                    LintId::of(SINGLE_USE_LIFETIMES),\n+                    (Level::Allow, LintLevelSource::Default),\n+                );\n+                continue;\n+            }\n+\n             let level = match Level::from_attr(attr) {\n                 None => continue,\n                 Some(Level::Expect(unstable_id)) if let Some(hir_id) = source_hir_id => {"}, {"sha": "e50abf6cf25595f7bcec18ca7bcb5934d7e6ae59", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -423,7 +423,11 @@ pub enum BuiltinLintDiagnostics {\n     DeprecatedMacro(Option<Symbol>, Span),\n     MissingAbi(Span, Abi),\n     UnusedDocComment(Span),\n-    UnusedBuiltinAttribute { attr_name: Symbol, macro_name: String, invoc_span: Span },\n+    UnusedBuiltinAttribute {\n+        attr_name: Symbol,\n+        macro_name: String,\n+        invoc_span: Span,\n+    },\n     PatternsInFnsWithoutBody(Span, Ident),\n     LegacyDeriveHelpers(Span),\n     ProcMacroBackCompat(String),\n@@ -435,6 +439,16 @@ pub enum BuiltinLintDiagnostics {\n     UnicodeTextFlow(Span, String),\n     UnexpectedCfg((Symbol, Span), Option<(Symbol, Span)>),\n     DeprecatedWhereclauseLocation(Span, String),\n+    SingleUseLifetime {\n+        /// Span of the parameter which declares this lifetime.\n+        param_span: Span,\n+        /// Span of the code that should be removed when eliding this lifetime.\n+        /// This span should include leading or trailing comma.\n+        deletion_span: Span,\n+        /// Span of the single use, or None if the lifetime is never used.\n+        /// If true, the lifetime will be fully elided.\n+        use_span: Option<(Span, bool)>,\n+    },\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "f05090d046f397bc1f8cf283be189a73e08f4f69", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 126, "deletions": 52, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! \"Late resolution\" is the pass that resolves most of names in a crate beside imports and macros.\n //! It runs when the crate is fully expanded and its module structure is fully built.\n //! So it just walks through the crate and resolves all the expressions, types, etc.\n@@ -19,7 +20,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_errors::DiagnosticId;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, PartialRes, PerNS};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::{PrimTy, TraitCandidate};\n use rustc_index::vec::Idx;\n@@ -197,13 +198,19 @@ impl<'a, R> Rib<'a, R> {\n     }\n }\n \n+#[derive(Clone, Copy, Debug)]\n+enum LifetimeUseSet {\n+    One { use_span: Span, use_ctxt: visit::LifetimeCtxt },\n+    Many,\n+}\n+\n #[derive(Copy, Clone, Debug)]\n enum LifetimeRibKind {\n     /// This rib acts as a barrier to forbid reference to lifetimes of a parent item.\n     Item,\n \n     /// This rib declares generic parameters.\n-    Generics { parent: NodeId, span: Span, kind: LifetimeBinderKind },\n+    Generics { binder: NodeId, span: Span, kind: LifetimeBinderKind },\n \n     /// FIXME(const_generics): This patches over an ICE caused by non-'static lifetimes in const\n     /// generics. We are disallowing this until we can decide on how we want to handle non-'static\n@@ -230,7 +237,7 @@ enum LifetimeRibKind {\n     AnonymousReportError,\n \n     /// Pass responsibility to `resolve_lifetime` code for all cases.\n-    AnonymousPassThrough(NodeId),\n+    AnonymousPassThrough(NodeId, /* in_fn_return */ bool),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -519,6 +526,9 @@ struct LateResolutionVisitor<'a, 'b, 'ast> {\n     /// In most cases this will be `None`, in which case errors will always be reported.\n     /// If it is `true`, then it will be updated when entering a nested function or trait body.\n     in_func_body: bool,\n+\n+    /// Count the number of places a lifetime is used.\n+    lifetime_uses: FxHashMap<LocalDefId, LifetimeUseSet>,\n }\n \n /// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n@@ -599,17 +609,19 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     &bare_fn.generic_params,\n                     NormalRibKind,\n                     LifetimeRibKind::Generics {\n-                        parent: ty.id,\n+                        binder: ty.id,\n                         kind: LifetimeBinderKind::BareFnType,\n                         span,\n                     },\n                     |this| {\n+                        this.visit_generic_param_vec(&bare_fn.generic_params, false);\n                         this.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousPassThrough(ty.id),\n-                            |this| {\n-                                this.visit_generic_param_vec(&bare_fn.generic_params, false);\n-                                visit::walk_fn_decl(this, &bare_fn.decl);\n-                            },\n+                            LifetimeRibKind::AnonymousPassThrough(ty.id, false),\n+                            |this| walk_list!(this, visit_param, &bare_fn.decl.inputs),\n+                        );\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousPassThrough(ty.id, true),\n+                            |this| this.visit_fn_ret_ty(&bare_fn.decl.output),\n                         );\n                     },\n                 );\n@@ -628,7 +640,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             &tref.bound_generic_params,\n             NormalRibKind,\n             LifetimeRibKind::Generics {\n-                parent: tref.trait_ref.ref_id,\n+                binder: tref.trait_ref.ref_id,\n                 kind: LifetimeBinderKind::PolyTrait,\n                 span,\n             },\n@@ -652,7 +664,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         &generics.params,\n                         ItemRibKind(HasGenericParams::Yes),\n                         LifetimeRibKind::Generics {\n-                            parent: foreign_item.id,\n+                            binder: foreign_item.id,\n                             kind: LifetimeBinderKind::Item,\n                             span: generics.span,\n                         },\n@@ -666,7 +678,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         &generics.params,\n                         ItemRibKind(HasGenericParams::Yes),\n                         LifetimeRibKind::Generics {\n-                            parent: foreign_item.id,\n+                            binder: foreign_item.id,\n                             kind: LifetimeBinderKind::Function,\n                             span: generics.span,\n                         },\n@@ -690,13 +702,20 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             // a body, or if there's no body for some other reason.\n             FnKind::Fn(FnCtxt::Foreign, _, sig, _, generics, _)\n             | FnKind::Fn(_, _, sig, _, generics, None) => {\n-                self.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(fn_id), |this| {\n-                    // We don't need to deal with patterns in parameters, because\n-                    // they are not possible for foreign or bodiless functions.\n-                    this.visit_fn_header(&sig.header);\n-                    this.visit_generics(generics);\n-                    visit::walk_fn_decl(this, &sig.decl);\n-                });\n+                // We don't need to deal with patterns in parameters, because\n+                // they are not possible for foreign or bodiless functions.\n+                self.with_lifetime_rib(\n+                    LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n+                    |this| {\n+                        this.visit_fn_header(&sig.header);\n+                        this.visit_generics(generics);\n+                        walk_list!(this, visit_param, &sig.decl.inputs);\n+                    },\n+                );\n+                self.with_lifetime_rib(\n+                    LifetimeRibKind::AnonymousPassThrough(fn_id, true),\n+                    |this| this.visit_fn_ret_ty(&sig.decl.output),\n+                );\n                 return;\n             }\n             FnKind::Fn(FnCtxt::Free, ..) => FnItemRibKind,\n@@ -759,37 +778,41 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     this.r.extra_lifetime_params_map.insert(async_node_id, extra_lifetime_params);\n \n                     this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(async_node_id),\n+                        LifetimeRibKind::AnonymousPassThrough(async_node_id, true),\n                         |this| visit::walk_fn_ret_ty(this, &declaration.output),\n                     );\n                 } else {\n-                    this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(fn_id), |this| {\n-                        // Add each argument to the rib.\n-                        this.resolve_params(&declaration.inputs);\n-\n-                        visit::walk_fn_ret_ty(this, &declaration.output);\n-                    });\n+                    // Add each argument to the rib.\n+                    this.with_lifetime_rib(\n+                        LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n+                        |this| this.resolve_params(&declaration.inputs),\n+                    );\n+                    this.with_lifetime_rib(\n+                        LifetimeRibKind::AnonymousPassThrough(fn_id, true),\n+                        |this| visit::walk_fn_ret_ty(this, &declaration.output),\n+                    );\n                 };\n \n                 // Ignore errors in function bodies if this is rustdoc\n                 // Be sure not to set this until the function signature has been resolved.\n                 let previous_state = replace(&mut this.in_func_body, true);\n                 // Resolve the function body, potentially inside the body of an async closure\n-                this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(fn_id), |this| {\n-                    match fn_kind {\n+                this.with_lifetime_rib(\n+                    LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n+                    |this| match fn_kind {\n                         FnKind::Fn(.., body) => walk_list!(this, visit_block, body),\n                         FnKind::Closure(_, body) => this.visit_expr(body),\n-                    }\n-                });\n+                    },\n+                );\n \n                 debug!(\"(resolving function) leaving function\");\n                 this.in_func_body = previous_state;\n             })\n         });\n         self.diagnostic_metadata.current_function = previous_value;\n     }\n-    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime, _: visit::LifetimeCtxt) {\n-        self.resolve_lifetime(lifetime)\n+    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime, use_ctxt: visit::LifetimeCtxt) {\n+        self.resolve_lifetime(lifetime, use_ctxt)\n     }\n \n     fn visit_generics(&mut self, generics: &'ast Generics) {\n@@ -864,10 +887,16 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         if let Some(ref args) = path_segment.args {\n             match &**args {\n                 GenericArgs::AngleBracketed(..) => visit::walk_generic_args(self, path_span, args),\n-                GenericArgs::Parenthesized(..) => self.with_lifetime_rib(\n-                    LifetimeRibKind::AnonymousPassThrough(path_segment.id),\n-                    |this| visit::walk_generic_args(this, path_span, args),\n-                ),\n+                GenericArgs::Parenthesized(ref data) => {\n+                    self.with_lifetime_rib(\n+                        LifetimeRibKind::AnonymousPassThrough(path_segment.id, false),\n+                        |this| walk_list!(this, visit_ty, &data.inputs),\n+                    );\n+                    self.with_lifetime_rib(\n+                        LifetimeRibKind::AnonymousPassThrough(path_segment.id, true),\n+                        |this| visit::walk_fn_ret_ty(this, &data.output),\n+                    )\n+                }\n             }\n         }\n     }\n@@ -890,7 +919,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     &bound_generic_params,\n                     NormalRibKind,\n                     LifetimeRibKind::Generics {\n-                        parent: bounded_ty.id,\n+                        binder: bounded_ty.id,\n                         kind: LifetimeBinderKind::WhereBound,\n                         span,\n                     },\n@@ -971,6 +1000,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             diagnostic_metadata: DiagnosticMetadata::default(),\n             // errors at module scope should always be reported\n             in_func_body: false,\n+            lifetime_uses: Default::default(),\n         }\n     }\n \n@@ -1178,7 +1208,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    fn resolve_lifetime(&mut self, lifetime: &'ast Lifetime) {\n+    fn resolve_lifetime(&mut self, lifetime: &'ast Lifetime, use_ctxt: visit::LifetimeCtxt) {\n         let ident = lifetime.ident;\n \n         if ident.name == kw::StaticLifetime {\n@@ -1196,6 +1226,40 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             let normalized_ident = ident.normalize_to_macros_2_0();\n             if let Some(&(_, region)) = rib.bindings.get(&normalized_ident) {\n                 self.record_lifetime_res(lifetime.id, region);\n+\n+                if let LifetimeRes::Param { param, .. } = region {\n+                    match self.lifetime_uses.entry(param) {\n+                        Entry::Vacant(v) => {\n+                            debug!(\"First use of {:?} at {:?}\", region, ident.span);\n+                            let use_set = self\n+                                .lifetime_ribs\n+                                .iter()\n+                                .rev()\n+                                .find_map(|rib| match rib.kind {\n+                                    // Do not suggest eliding a lifetime where an anonymous\n+                                    // lifetime would be illegal.\n+                                    LifetimeRibKind::Item\n+                                    | LifetimeRibKind::AnonymousPassThrough(_, true)\n+                                    | LifetimeRibKind::AnonymousReportError => {\n+                                        Some(LifetimeUseSet::Many)\n+                                    }\n+                                    // An anonymous lifetime is legal here, go ahead.\n+                                    LifetimeRibKind::AnonymousPassThrough(_, false)\n+                                    | LifetimeRibKind::AnonymousCreateParameter(_) => {\n+                                        Some(LifetimeUseSet::One { use_span: ident.span, use_ctxt })\n+                                    }\n+                                    _ => None,\n+                                })\n+                                .unwrap_or(LifetimeUseSet::Many);\n+                            debug!(?use_ctxt, ?use_set);\n+                            v.insert(use_set);\n+                        }\n+                        Entry::Occupied(mut o) => {\n+                            debug!(\"Many uses of {:?} at {:?}\", region, ident.span);\n+                            *o.get_mut() = LifetimeUseSet::Many;\n+                        }\n+                    }\n+                }\n                 return;\n             }\n \n@@ -1262,7 +1326,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.record_lifetime_res(lifetime.id, LifetimeRes::Error);\n                     return;\n                 }\n-                LifetimeRibKind::AnonymousPassThrough(node_id) => {\n+                LifetimeRibKind::AnonymousPassThrough(node_id, _) => {\n                     self.record_lifetime_res(\n                         lifetime.id,\n                         LifetimeRes::Anonymous { binder: node_id, elided },\n@@ -1382,7 +1446,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     // `PathSegment`, for which there is no associated `'_` or `&T` with no explicit\n                     // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n                     // later, at which point a suitable error will be emitted.\n-                    LifetimeRibKind::AnonymousPassThrough(binder) => {\n+                    LifetimeRibKind::AnonymousPassThrough(binder, _) => {\n                         res = LifetimeRes::Anonymous { binder, elided: true };\n                         break;\n                     }\n@@ -1550,7 +1614,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 &generics.params,\n                 ItemRibKind(HasGenericParams::Yes),\n                 LifetimeRibKind::Generics {\n-                    parent: item.id,\n+                    binder: item.id,\n                     kind: LifetimeBinderKind::Item,\n                     span: generics.span,\n                 },\n@@ -1620,7 +1684,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     &generics.params,\n                     ItemRibKind(HasGenericParams::Yes),\n                     LifetimeRibKind::Generics {\n-                        parent: item.id,\n+                        binder: item.id,\n                         kind: LifetimeBinderKind::Item,\n                         span: generics.span,\n                     },\n@@ -1633,7 +1697,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     &generics.params,\n                     ItemRibKind(HasGenericParams::Yes),\n                     LifetimeRibKind::Generics {\n-                        parent: item.id,\n+                        binder: item.id,\n                         kind: LifetimeBinderKind::Function,\n                         span: generics.span,\n                     },\n@@ -1665,7 +1729,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     &generics.params,\n                     ItemRibKind(HasGenericParams::Yes),\n                     LifetimeRibKind::Generics {\n-                        parent: item.id,\n+                        binder: item.id,\n                         kind: LifetimeBinderKind::Item,\n                         span: generics.span,\n                     },\n@@ -1686,7 +1750,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                             &generics.params,\n                                             AssocItemRibKind,\n                                             LifetimeRibKind::Generics {\n-                                                parent: item.id,\n+                                                binder: item.id,\n                                                 span: generics.span,\n                                                 kind,\n                                             },\n@@ -1754,7 +1818,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     &generics.params,\n                     ItemRibKind(HasGenericParams::Yes),\n                     LifetimeRibKind::Generics {\n-                        parent: item.id,\n+                        binder: item.id,\n                         kind: LifetimeBinderKind::Item,\n                         span: generics.span,\n                     },\n@@ -1824,6 +1888,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         F: FnOnce(&mut Self),\n     {\n         debug!(\"with_generic_param_rib\");\n+        let LifetimeRibKind::Generics { binder, span: generics_span, kind: generics_kind, .. }\n+            = lifetime_kind else { panic!() };\n+\n         let mut function_type_rib = Rib::new(kind);\n         let mut function_value_rib = Rib::new(kind);\n         let mut function_lifetime_rib = LifetimeRib::new(lifetime_kind);\n@@ -1892,8 +1959,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 GenericParamKind::Type { .. } => (&mut function_type_rib, DefKind::TyParam),\n                 GenericParamKind::Const { .. } => (&mut function_value_rib, DefKind::ConstParam),\n                 GenericParamKind::Lifetime => {\n-                    let LifetimeRibKind::Generics { parent, .. } = lifetime_kind else { panic!() };\n-                    let res = LifetimeRes::Param { param: def_id, binder: parent };\n+                    let res = LifetimeRes::Param { param: def_id, binder };\n                     self.record_lifetime_res(param.id, res);\n                     function_lifetime_rib.bindings.insert(ident, (param.id, res));\n                     continue;\n@@ -1913,6 +1979,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         self.ribs[TypeNS].pop();\n         self.ribs[ValueNS].pop();\n         self.lifetime_ribs.pop();\n+\n+        if let LifetimeBinderKind::BareFnType\n+        | LifetimeBinderKind::WhereBound\n+        | LifetimeBinderKind::Function\n+        | LifetimeBinderKind::ImplBlock = generics_kind\n+        {\n+            self.maybe_report_lifetime_uses(generics_span, params)\n+        }\n     }\n \n     fn with_label_rib(&mut self, kind: RibKind<'a>, f: impl FnOnce(&mut Self)) {\n@@ -2039,7 +2113,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ) {\n         debug!(\"resolve_implementation\");\n         // If applicable, create a rib for the type parameters.\n-        self.with_generic_param_rib(&generics.params, ItemRibKind(HasGenericParams::Yes), LifetimeRibKind::Generics { span: generics.span, parent: item_id, kind: LifetimeBinderKind::ImplBlock }, |this| {\n+        self.with_generic_param_rib(&generics.params, ItemRibKind(HasGenericParams::Yes), LifetimeRibKind::Generics { span: generics.span, binder: item_id, kind: LifetimeBinderKind::ImplBlock }, |this| {\n             // Dummy self type for better errors if `Self` is used in the trait path.\n             this.with_self_rib(Res::SelfTy { trait_: None, alias_to: None }, |this| {\n                 this.with_lifetime_rib(LifetimeRibKind::AnonymousCreateParameter(item_id), |this| {\n@@ -2066,7 +2140,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             this.visit_generics(generics);\n \n                             // Resolve the items within the impl.\n-                            this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(item_id),\n+                            this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(item_id,false),\n                                 |this| {\n                                     this.with_current_self_type(self_type, |this| {\n                                         this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n@@ -2111,7 +2185,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                         this.with_generic_param_rib(\n                                                             &generics.params,\n                                                             AssocItemRibKind,\n-                                                            LifetimeRibKind::Generics { parent: item.id, span: generics.span, kind: LifetimeBinderKind::Function },\n+                                                            LifetimeRibKind::Generics { binder: item.id, span: generics.span, kind: LifetimeBinderKind::Function },\n                                                             |this| {\n                                                                 // If this is a trait impl, ensure the method\n                                                                 // exists in trait\n@@ -2140,7 +2214,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                         this.with_generic_param_rib(\n                                                             &generics.params,\n                                                             AssocItemRibKind,\n-                                                            LifetimeRibKind::Generics { parent: item.id, span: generics.span, kind: LifetimeBinderKind::Item },\n+                                                            LifetimeRibKind::Generics { binder: item.id, span: generics.span, kind: LifetimeBinderKind::Item },\n                                                             |this| {\n                                                                 // If this is a trait impl, ensure the type\n                                                                 // exists in trait"}, {"sha": "318bb8280ececb70b2a34d05ac04f9236623458f", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -1,16 +1,17 @@\n use crate::diagnostics::{ImportSuggestion, LabelSuggestion, TypoSuggestion};\n use crate::late::lifetimes::{ElisionFailureInfo, LifetimeContext};\n use crate::late::{AliasPossibility, LateResolutionVisitor, RibKind};\n-use crate::late::{LifetimeBinderKind, LifetimeRibKind};\n+use crate::late::{LifetimeBinderKind, LifetimeRibKind, LifetimeUseSet};\n use crate::path_names_to_string;\n use crate::{Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n-use rustc_ast::visit::{FnCtxt, FnKind};\n+use rustc_ast::visit::{FnCtxt, FnKind, LifetimeCtxt};\n use rustc_ast::{\n     self as ast, AssocItemKind, Expr, ExprKind, GenericParam, GenericParamKind, Item, ItemKind,\n     NodeId, Path, Ty, TyKind,\n };\n+use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust::path_segment_to_string;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{\n@@ -22,6 +23,7 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n+use rustc_session::lint;\n use rustc_session::parse::feature_err;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n@@ -1832,6 +1834,76 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         })\n     }\n \n+    crate fn maybe_report_lifetime_uses(\n+        &mut self,\n+        generics_span: Span,\n+        params: &[ast::GenericParam],\n+    ) {\n+        for (param_index, param) in params.iter().enumerate() {\n+            let GenericParamKind::Lifetime = param.kind else { continue };\n+\n+            let def_id = self.r.local_def_id(param.id);\n+\n+            let use_set = self.lifetime_uses.remove(&def_id);\n+            debug!(\n+                \"Use set for {:?}({:?} at {:?}) is {:?}\",\n+                def_id, param.ident, param.ident.span, use_set\n+            );\n+\n+            let deletion_span = || {\n+                if params.len() == 1 {\n+                    // if sole lifetime, remove the entire `<>` brackets\n+                    generics_span\n+                } else if param_index == 0 {\n+                    // if removing within `<>` brackets, we also want to\n+                    // delete a leading or trailing comma as appropriate\n+                    param.span().to(params[param_index + 1].span().shrink_to_lo())\n+                } else {\n+                    // if removing within `<>` brackets, we also want to\n+                    // delete a leading or trailing comma as appropriate\n+                    params[param_index - 1].span().shrink_to_hi().to(param.span())\n+                }\n+            };\n+            match use_set {\n+                Some(LifetimeUseSet::Many) => {}\n+                Some(LifetimeUseSet::One { use_span, use_ctxt }) => {\n+                    debug!(?param.ident, ?param.ident.span, ?use_span);\n+\n+                    let elidable = matches!(use_ctxt, LifetimeCtxt::Rptr);\n+\n+                    let deletion_span = deletion_span();\n+                    self.r.lint_buffer.buffer_lint_with_diagnostic(\n+                        lint::builtin::SINGLE_USE_LIFETIMES,\n+                        param.id,\n+                        param.ident.span,\n+                        &format!(\"lifetime parameter `{}` only used once\", param.ident),\n+                        lint::BuiltinLintDiagnostics::SingleUseLifetime {\n+                            param_span: param.ident.span,\n+                            use_span: Some((use_span, elidable)),\n+                            deletion_span,\n+                        },\n+                    );\n+                }\n+                None => {\n+                    debug!(?param.ident, ?param.ident.span);\n+\n+                    let deletion_span = deletion_span();\n+                    self.r.lint_buffer.buffer_lint_with_diagnostic(\n+                        lint::builtin::UNUSED_LIFETIMES,\n+                        param.id,\n+                        param.ident.span,\n+                        &format!(\"lifetime parameter `{}` never used\", param.ident),\n+                        lint::BuiltinLintDiagnostics::SingleUseLifetime {\n+                            param_span: param.ident.span,\n+                            use_span: None,\n+                            deletion_span,\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n     crate fn emit_undeclared_lifetime_error(\n         &self,\n         lifetime_ref: &ast::Lifetime,\n@@ -1863,7 +1935,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n         for rib in self.lifetime_ribs.iter().rev() {\n             match rib.kind {\n-                LifetimeRibKind::Generics { parent: _, span, kind } => {\n+                LifetimeRibKind::Generics { binder: _, span, kind } => {\n                     if !span.can_be_used_for_suggestions() && suggest_note {\n                         suggest_note = false; // Avoid displaying the same help multiple times.\n                         err.span_label("}, {"sha": "cacb851c4f04d1cebc09da69136d233e390708c0", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 376, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -9,20 +9,19 @@\n use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n use rustc_ast::walk_list;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic};\n+use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::hir_id::ItemLocalId;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node, ParamName, QPath};\n+use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node, ParamName};\n use rustc_hir::{GenericParamKind, HirIdMap, HirIdSet};\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n use rustc_middle::{bug, span_bug};\n-use rustc_session::lint;\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -33,13 +32,6 @@ use std::mem::take;\n \n use tracing::{debug, span, Level};\n \n-// This counts the no of times a lifetime is used\n-#[derive(Clone, Copy, Debug)]\n-pub enum LifetimeUseSet<'tcx> {\n-    One(&'tcx hir::Lifetime),\n-    Many,\n-}\n-\n trait RegionExt {\n     fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region);\n \n@@ -175,8 +167,6 @@ crate struct LifetimeContext<'a, 'tcx> {\n     /// Cache for cross-crate per-definition object lifetime defaults.\n     xcrate_object_lifetime_defaults: DefIdMap<Vec<ObjectLifetimeDefault>>,\n \n-    lifetime_uses: &'a mut DefIdMap<LifetimeUseSet<'tcx>>,\n-\n     /// When encountering an undefined named lifetime, we will suggest introducing it in these\n     /// places.\n     crate missing_named_lifetime_spots: Vec<MissingLifetimeSpot<'tcx>>,\n@@ -197,11 +187,6 @@ enum Scope<'a> {\n         /// we should use for an early-bound region?\n         next_early_index: u32,\n \n-        /// Flag is set to true if, in this binder, `'_` would be\n-        /// equivalent to a \"single-use region\". This is true on\n-        /// impls, but not other kinds of items.\n-        track_lifetime_uses: bool,\n-\n         /// Whether or not this binder would serve as the parent\n         /// binder for opaque types introduced within. For example:\n         ///\n@@ -297,7 +282,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n             Scope::Binder {\n                 lifetimes,\n                 next_early_index,\n-                track_lifetime_uses,\n                 opaque_type_parent,\n                 scope_type,\n                 hir_id,\n@@ -307,7 +291,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .debug_struct(\"Binder\")\n                 .field(\"lifetimes\", lifetimes)\n                 .field(\"next_early_index\", next_early_index)\n-                .field(\"track_lifetime_uses\", track_lifetime_uses)\n                 .field(\"opaque_type_parent\", opaque_type_parent)\n                 .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n@@ -453,7 +436,6 @@ fn do_resolve(\n         trait_definition_only,\n         labels_in_fn: vec![],\n         xcrate_object_lifetime_defaults: Default::default(),\n-        lifetime_uses: &mut Default::default(),\n         missing_named_lifetime_spots: vec![],\n     };\n     visitor.visit_item(item);\n@@ -697,7 +679,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     lifetimes: FxIndexMap::default(),\n                     next_early_index: self.next_early_index(),\n                     s: self.scope,\n-                    track_lifetime_uses: true,\n                     opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: true,\n@@ -796,9 +777,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n                 self.missing_named_lifetime_spots.push(generics.into());\n \n-                // Impls permit `'_` to be used and it is equivalent to \"some fresh lifetime name\".\n-                // This is not true for other kinds of items.\n-                let track_lifetime_uses = matches!(item.kind, hir::ItemKind::Impl { .. });\n                 // These kinds of items have only early-bound lifetime parameters.\n                 let mut index = if sub_items_have_self_param(&item.kind) {\n                     1 // Self comes before lifetimes\n@@ -825,7 +803,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n                     opaque_type_parent: true,\n-                    track_lifetime_uses,\n                     scope_type: BinderScopeType::Normal,\n                     s: ROOT_SCOPE,\n                     allow_late_bound: false,\n@@ -892,7 +869,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     lifetimes,\n                     s: self.scope,\n                     next_early_index,\n-                    track_lifetime_uses: true,\n                     opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: true,\n@@ -1053,11 +1029,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (name, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n-                            let Region::EarlyBound(_, def_id) = reg else {\n-                                bug!();\n-                            };\n-                            // We cannot predict what lifetimes are unused in opaque type.\n-                            self.lifetime_uses.insert(def_id, LifetimeUseSet::Many);\n                             if let hir::ParamName::Plain(Ident {\n                                 name: kw::UnderscoreLifetime,\n                                 ..\n@@ -1087,7 +1058,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             lifetimes,\n                             next_early_index,\n                             s: this.scope,\n-                            track_lifetime_uses: true,\n                             opaque_type_parent: false,\n                             scope_type: BinderScopeType::Normal,\n                             allow_late_bound: false,\n@@ -1108,7 +1078,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         lifetimes,\n                         next_early_index,\n                         s: self.scope,\n-                        track_lifetime_uses: true,\n                         opaque_type_parent: false,\n                         scope_type: BinderScopeType::Normal,\n                         allow_late_bound: false,\n@@ -1168,7 +1137,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n-                    track_lifetime_uses: true,\n                     opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: false,\n@@ -1238,7 +1206,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n-                    track_lifetime_uses: true,\n                     opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: true,\n@@ -1383,7 +1350,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             lifetimes,\n                             s: this.scope,\n                             next_early_index,\n-                            track_lifetime_uses: true,\n                             opaque_type_parent: false,\n                             scope_type: BinderScopeType::Normal,\n                             allow_late_bound: true,\n@@ -1457,7 +1423,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     lifetimes: FxIndexMap::default(),\n                     s: self.scope,\n                     next_early_index: self.next_early_index(),\n-                    track_lifetime_uses: true,\n                     opaque_type_parent: false,\n                     scope_type,\n                     allow_late_bound: true,\n@@ -1510,7 +1475,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             lifetimes,\n             s: self.scope,\n             next_early_index,\n-            track_lifetime_uses: true,\n             opaque_type_parent: false,\n             scope_type,\n             allow_late_bound: true,\n@@ -1812,7 +1776,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     where\n         F: for<'b> FnOnce(ScopeRef<'_>, &mut LifetimeContext<'b, 'tcx>),\n     {\n-        let LifetimeContext { tcx, map, lifetime_uses, .. } = self;\n+        let LifetimeContext { tcx, map, .. } = self;\n         let labels_in_fn = take(&mut self.labels_in_fn);\n         let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n         let missing_named_lifetime_spots = take(&mut self.missing_named_lifetime_spots);\n@@ -1823,298 +1787,18 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             trait_definition_only: self.trait_definition_only,\n             labels_in_fn,\n             xcrate_object_lifetime_defaults,\n-            lifetime_uses,\n             missing_named_lifetime_spots,\n         };\n         let span = tracing::debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n             f(self.scope, &mut this);\n-            if !self.trait_definition_only {\n-                this.check_uses_for_lifetimes_defined_by_scope();\n-            }\n         }\n         self.labels_in_fn = this.labels_in_fn;\n         self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n         self.missing_named_lifetime_spots = this.missing_named_lifetime_spots;\n     }\n \n-    /// helper method to determine the span to remove when suggesting the\n-    /// deletion of a lifetime\n-    fn lifetime_deletion_span(&self, name: Ident, generics: &hir::Generics<'_>) -> Option<Span> {\n-        generics.params.iter().enumerate().find_map(|(i, param)| {\n-            if param.name.ident() == name {\n-                if generics.params.len() == 1 {\n-                    // if sole lifetime, remove the entire `<>` brackets\n-                    Some(generics.span)\n-                } else {\n-                    // if removing within `<>` brackets, we also want to\n-                    // delete a leading or trailing comma as appropriate\n-                    if i >= generics.params.len() - 1 {\n-                        Some(generics.params[i - 1].span.shrink_to_hi().to(param.span))\n-                    } else {\n-                        Some(param.span.to(generics.params[i + 1].span.shrink_to_lo()))\n-                    }\n-                }\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    // helper method to issue suggestions from `fn rah<'a>(&'a T)` to `fn rah(&T)`\n-    // or from `fn rah<'a>(T<'a>)` to `fn rah(T<'_>)`\n-    fn suggest_eliding_single_use_lifetime(\n-        &self,\n-        err: &mut Diagnostic,\n-        def_id: DefId,\n-        lifetime: &hir::Lifetime,\n-    ) {\n-        let name = lifetime.name.ident();\n-        let remove_decl = self\n-            .tcx\n-            .parent(def_id)\n-            .as_local()\n-            .and_then(|parent_def_id| self.tcx.hir().get_generics(parent_def_id))\n-            .and_then(|generics| self.lifetime_deletion_span(name, generics));\n-\n-        let mut remove_use = None;\n-        let mut elide_use = None;\n-        let mut find_arg_use_span = |inputs: &[hir::Ty<'_>]| {\n-            for input in inputs {\n-                match input.kind {\n-                    hir::TyKind::Rptr(lt, _) => {\n-                        if lt.name.ident() == name {\n-                            // include the trailing whitespace between the lifetime and type names\n-                            let lt_through_ty_span = lifetime.span.to(input.span.shrink_to_hi());\n-                            remove_use = Some(\n-                                self.tcx\n-                                    .sess\n-                                    .source_map()\n-                                    .span_until_non_whitespace(lt_through_ty_span),\n-                            );\n-                            break;\n-                        }\n-                    }\n-                    hir::TyKind::Path(QPath::Resolved(_, path)) => {\n-                        let last_segment = &path.segments[path.segments.len() - 1];\n-                        let generics = last_segment.args();\n-                        for arg in generics.args.iter() {\n-                            if let GenericArg::Lifetime(lt) = arg {\n-                                if lt.name.ident() == name {\n-                                    elide_use = Some(lt.span);\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                        break;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        };\n-        if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get(lifetime.hir_id) {\n-            if let Some(parent) =\n-                self.tcx.hir().find_by_def_id(self.tcx.hir().get_parent_item(hir_lifetime.hir_id))\n-            {\n-                match parent {\n-                    Node::Item(item) => {\n-                        if let hir::ItemKind::Fn(sig, _, _) = &item.kind {\n-                            find_arg_use_span(sig.decl.inputs);\n-                        }\n-                    }\n-                    Node::ImplItem(impl_item) => {\n-                        if let hir::ImplItemKind::Fn(sig, _) = &impl_item.kind {\n-                            find_arg_use_span(sig.decl.inputs);\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-\n-        let msg = \"elide the single-use lifetime\";\n-        match (remove_decl, remove_use, elide_use) {\n-            (Some(decl_span), Some(use_span), None) => {\n-                // if both declaration and use deletion spans start at the same\n-                // place (\"start at\" because the latter includes trailing\n-                // whitespace), then this is an in-band lifetime\n-                if decl_span.shrink_to_lo() == use_span.shrink_to_lo() {\n-                    err.span_suggestion(\n-                        use_span,\n-                        msg,\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    err.multipart_suggestion(\n-                        msg,\n-                        vec![(decl_span, String::new()), (use_span, String::new())],\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            (Some(decl_span), None, Some(use_span)) => {\n-                err.multipart_suggestion(\n-                    msg,\n-                    vec![(decl_span, String::new()), (use_span, \"'_\".to_owned())],\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_uses_for_lifetimes_defined_by_scope(&mut self) {\n-        let Scope::Binder { lifetimes: defined_by, .. } = self.scope else {\n-            debug!(\"check_uses_for_lifetimes_defined_by_scope: not in a binder scope\");\n-            return;\n-        };\n-\n-        let def_ids: Vec<_> = defined_by\n-            .values()\n-            .flat_map(|region| match region {\n-                Region::EarlyBound(_, def_id)\n-                | Region::LateBound(_, _, def_id)\n-                | Region::Free(_, def_id) => Some(*def_id),\n-\n-                Region::LateBoundAnon(..) | Region::Static => None,\n-            })\n-            .collect();\n-\n-        'lifetimes: for def_id in def_ids {\n-            debug!(\"check_uses_for_lifetimes_defined_by_scope: def_id = {:?}\", def_id);\n-\n-            let lifetimeuseset = self.lifetime_uses.remove(&def_id);\n-\n-            debug!(\n-                \"check_uses_for_lifetimes_defined_by_scope: lifetimeuseset = {:?}\",\n-                lifetimeuseset\n-            );\n-\n-            match lifetimeuseset {\n-                Some(LifetimeUseSet::One(lifetime)) => {\n-                    debug!(?def_id);\n-                    if let Some((id, span, name)) =\n-                        match self.tcx.hir().get_by_def_id(def_id.expect_local()) {\n-                            Node::Lifetime(hir_lifetime) => Some((\n-                                hir_lifetime.hir_id,\n-                                hir_lifetime.span,\n-                                hir_lifetime.name.ident(),\n-                            )),\n-                            Node::GenericParam(param) => {\n-                                Some((param.hir_id, param.span, param.name.ident()))\n-                            }\n-                            _ => None,\n-                        }\n-                    {\n-                        debug!(\"id = {:?} span = {:?} name = {:?}\", id, span, name);\n-                        if name.name == kw::UnderscoreLifetime {\n-                            continue;\n-                        }\n-\n-                        let parent_def_id = self.tcx.parent(def_id);\n-                        if let Some(def_id) = parent_def_id.as_local() {\n-                            // lifetimes in `derive` expansions don't count (Issue #53738)\n-                            if self.tcx.has_attr(def_id.to_def_id(), sym::automatically_derived) {\n-                                continue;\n-                            }\n-\n-                            // opaque types generated when desugaring an async function can have a single\n-                            // use lifetime even if it is explicitly denied (Issue #77175)\n-                            if let hir::Node::Item(hir::Item {\n-                                kind: hir::ItemKind::OpaqueTy(ref opaque),\n-                                ..\n-                            }) = self.tcx.hir().get_by_def_id(def_id)\n-                            {\n-                                if !matches!(opaque.origin, hir::OpaqueTyOrigin::AsyncFn(..)) {\n-                                    continue 'lifetimes;\n-                                }\n-                                // We want to do this only if the lifetime identifier is already defined\n-                                // in the async function that generated this. Otherwise it could be\n-                                // an opaque type defined by the developer and we still want this\n-                                // lint to fail compilation\n-                                for p in opaque.generics.params {\n-                                    if defined_by.contains_key(&p.name) {\n-                                        continue 'lifetimes;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        self.tcx.struct_span_lint_hir(\n-                            lint::builtin::SINGLE_USE_LIFETIMES,\n-                            id,\n-                            span,\n-                            |lint| {\n-                                let mut err = lint.build(&format!(\n-                                    \"lifetime parameter `{}` only used once\",\n-                                    name\n-                                ));\n-                                if span == lifetime.span {\n-                                    // spans are the same for in-band lifetime declarations\n-                                    err.span_label(span, \"this lifetime is only used here\");\n-                                } else {\n-                                    err.span_label(span, \"this lifetime...\");\n-                                    err.span_label(lifetime.span, \"...is used only here\");\n-                                }\n-                                self.suggest_eliding_single_use_lifetime(\n-                                    &mut err, def_id, lifetime,\n-                                );\n-                                err.emit();\n-                            },\n-                        );\n-                    }\n-                }\n-                Some(LifetimeUseSet::Many) => {\n-                    debug!(\"not one use lifetime\");\n-                }\n-                None => {\n-                    if let Some((id, span, name)) =\n-                        match self.tcx.hir().get_by_def_id(def_id.expect_local()) {\n-                            Node::Lifetime(hir_lifetime) => Some((\n-                                hir_lifetime.hir_id,\n-                                hir_lifetime.span,\n-                                hir_lifetime.name.ident(),\n-                            )),\n-                            Node::GenericParam(param) => {\n-                                Some((param.hir_id, param.span, param.name.ident()))\n-                            }\n-                            _ => None,\n-                        }\n-                    {\n-                        debug!(\"id ={:?} span = {:?} name = {:?}\", id, span, name);\n-                        self.tcx.struct_span_lint_hir(\n-                            lint::builtin::UNUSED_LIFETIMES,\n-                            id,\n-                            span,\n-                            |lint| {\n-                                let mut err = lint\n-                                    .build(&format!(\"lifetime parameter `{}` never used\", name));\n-                                let parent_def_id = self.tcx.parent(def_id);\n-                                if let Some(generics) =\n-                                    self.tcx.hir().get_generics(parent_def_id.expect_local())\n-                                {\n-                                    let unused_lt_span =\n-                                        self.lifetime_deletion_span(name, generics);\n-                                    if let Some(span) = unused_lt_span {\n-                                        err.span_suggestion(\n-                                            span,\n-                                            \"elide the unused lifetime\",\n-                                            String::new(),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                    }\n-                                }\n-                                err.emit();\n-                            },\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n     ///\n     /// Handles visiting fns and methods. These are a bit complicated because we must distinguish\n@@ -2204,7 +1888,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             next_early_index,\n             s: self.scope,\n             opaque_type_parent: true,\n-            track_lifetime_uses: false,\n             scope_type: BinderScopeType::Normal,\n             allow_late_bound: true,\n         };\n@@ -3201,69 +2884,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    /// Returns `true` if, in the current scope, replacing `'_` would be\n-    /// equivalent to a single-use lifetime.\n-    fn track_lifetime_uses(&self) -> bool {\n-        let mut scope = self.scope;\n-        loop {\n-            match *scope {\n-                Scope::Root => break false,\n-\n-                // Inside of items, it depends on the kind of item.\n-                Scope::Binder { track_lifetime_uses, .. } => break track_lifetime_uses,\n-\n-                // Inside a body, `'_` will use an inference variable,\n-                // should be fine.\n-                Scope::Body { .. } => break true,\n-\n-                // A lifetime only used in a fn argument could as well\n-                // be replaced with `'_`, as that would generate a\n-                // fresh name, too.\n-                Scope::Elision { elide: Elide::FreshLateAnon(..), .. } => break true,\n-\n-                // In the return type or other such place, `'_` is not\n-                // going to make a fresh name, so we cannot\n-                // necessarily replace a single-use lifetime with\n-                // `'_`.\n-                Scope::Elision {\n-                    elide: Elide::Exact(_) | Elide::Error(_) | Elide::Forbid, ..\n-                } => break false,\n-\n-                Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => scope = s,\n-            }\n-        }\n-    }\n-\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: Region) {\n         debug!(\n             node = ?self.tcx.hir().node_to_string(lifetime_ref.hir_id),\n             span = ?self.tcx.sess.source_map().span_to_diagnostic_string(lifetime_ref.span)\n         );\n         self.map.defs.insert(lifetime_ref.hir_id, def);\n-\n-        match def {\n-            Region::LateBoundAnon(..) | Region::Static => {\n-                // These are anonymous lifetimes or lifetimes that are not declared.\n-            }\n-\n-            Region::Free(_, def_id)\n-            | Region::LateBound(_, _, def_id)\n-            | Region::EarlyBound(_, def_id) => {\n-                // A lifetime declared by the user.\n-                let track_lifetime_uses = self.track_lifetime_uses();\n-                debug!(?track_lifetime_uses);\n-                if track_lifetime_uses && !self.lifetime_uses.contains_key(&def_id) {\n-                    debug!(\"first use of {:?}\", def_id);\n-                    self.lifetime_uses.insert(def_id, LifetimeUseSet::One(lifetime_ref));\n-                } else {\n-                    debug!(\"many uses of {:?}\", def_id);\n-                    self.lifetime_uses.insert(def_id, LifetimeUseSet::Many);\n-                }\n-            }\n-        }\n     }\n \n     /// Sometimes we resolve a lifetime, but later find that it is an"}, {"sha": "6cfd36ba9e84312f723a6fe284ad3e9f0b4b4cf4", "filename": "src/test/ui/async-await/unused-lifetime.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -1,19 +1,15 @@\n // Check \"unused_lifetimes\" lint on both async and sync functions\n+// Both cases should be diagnosed the same way.\n \n // edition:2018\n \n #![deny(unused_lifetimes)]\n \n+async fn async_wrong_without_args<'a>() {} //~ ERROR lifetime parameter `'a` never used\n \n-// Async part with unused lifetimes\n-//\n-// Even wrong cases don't cause errors because async functions are desugared with all lifetimes\n-// involved in the signature. So, we cannot predict what lifetimes are unused in async function.\n-async fn async_wrong_without_args<'a>() {}\n+async fn async_wrong_1_lifetime<'a>(_: &i32) {} //~ ERROR lifetime parameter `'a` never used\n \n-async fn async_wrong_1_lifetime<'a>(_: &i32) {}\n-\n-async fn async_wrong_2_lifetimes<'a, 'b>(_: &'a i32, _: &i32) {}\n+async fn async_wrong_2_lifetimes<'a, 'b>(_: &'a i32, _: &i32) {} //~ ERROR lifetime parameter `'b` never used\n \n async fn async_right_1_lifetime<'a>(_: &'a i32) {}\n \n@@ -24,10 +20,6 @@ where\n     I: Iterator<Item = &'a i32>\n {}\n \n-\n-// Sync part with unused lifetimes\n-//\n-// These functions are compiled as supposed\n fn wrong_without_args<'a>() {} //~ ERROR lifetime parameter `'a` never used\n \n fn wrong_1_lifetime<'a>(_: &i32) {} //~ ERROR lifetime parameter `'a` never used"}, {"sha": "5c00501a62fe5f069ef4cc01a1953ef47cd28d0a", "filename": "src/test/ui/async-await/unused-lifetime.stderr", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.stderr?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -1,28 +1,48 @@\n error: lifetime parameter `'a` never used\n-  --> $DIR/unused-lifetime.rs:31:23\n+  --> $DIR/unused-lifetime.rs:8:35\n    |\n-LL | fn wrong_without_args<'a>() {}\n-   |                      -^^- help: elide the unused lifetime\n+LL | async fn async_wrong_without_args<'a>() {}\n+   |                                  -^^- help: elide the unused lifetime\n    |\n note: the lint level is defined here\n-  --> $DIR/unused-lifetime.rs:5:9\n+  --> $DIR/unused-lifetime.rs:6:9\n    |\n LL | #![deny(unused_lifetimes)]\n    |         ^^^^^^^^^^^^^^^^\n \n error: lifetime parameter `'a` never used\n-  --> $DIR/unused-lifetime.rs:33:21\n+  --> $DIR/unused-lifetime.rs:10:33\n+   |\n+LL | async fn async_wrong_1_lifetime<'a>(_: &i32) {}\n+   |                                -^^- help: elide the unused lifetime\n+\n+error: lifetime parameter `'b` never used\n+  --> $DIR/unused-lifetime.rs:12:38\n+   |\n+LL | async fn async_wrong_2_lifetimes<'a, 'b>(_: &'a i32, _: &i32) {}\n+   |                                    --^^\n+   |                                    |\n+   |                                    help: elide the unused lifetime\n+\n+error: lifetime parameter `'a` never used\n+  --> $DIR/unused-lifetime.rs:23:23\n+   |\n+LL | fn wrong_without_args<'a>() {}\n+   |                      -^^- help: elide the unused lifetime\n+\n+error: lifetime parameter `'a` never used\n+  --> $DIR/unused-lifetime.rs:25:21\n    |\n LL | fn wrong_1_lifetime<'a>(_: &i32) {}\n    |                    -^^- help: elide the unused lifetime\n \n error: lifetime parameter `'b` never used\n-  --> $DIR/unused-lifetime.rs:35:26\n+  --> $DIR/unused-lifetime.rs:27:26\n    |\n LL | fn wrong_2_lifetimes<'a, 'b>(_: &'a i32, _: &i32) {}\n    |                        --^^\n    |                        |\n    |                        help: elide the unused lifetime\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "9290c21620e90a5ae9e48e99c4100ed2617bd134", "filename": "src/test/ui/single-use-lifetime/fn-types.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Ffn-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Ffn-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Ffn-types.stderr?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -11,6 +11,11 @@ note: the lint level is defined here\n    |\n LL | #![deny(single_use_lifetimes)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n+help: elide the single-use lifetime\n+   |\n+LL -   a: for<'a> fn(&'a u32),\n+LL +   a: fn(&u32),\n+   | \n \n error[E0581]: return type references lifetime `'a`, which is not constrained by the fn input types\n   --> $DIR/fn-types.rs:12:22"}, {"sha": "7919ef820f6e1d8d487e4a77b5e5e39b48a808a6", "filename": "src/test/ui/single-use-lifetime/one-use-in-fn-argument.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-fn-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-fn-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-fn-argument.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -19,4 +19,15 @@ fn left<'x, 'y>(foo: Double<'x, 'y>) -> &'x u32 { foo.f } //~ ERROR `'y` only us\n fn right<'x, 'y>(foo: Double<'x, 'y>) -> &'y u32 { foo.f } //~ ERROR `'x` only used once\n //~^ HELP elide the single-use lifetime\n \n-fn main() { }\n+pub trait Tfv<'a> {}\n+\n+// Do NOT lint in an HRTB.\n+pub fn g<T: for<'a> Tfv<'a>>() {}\n+\n+// Do NOT lint for trait bounds.\n+pub fn h<'a, S>(_: S)\n+where\n+    S: Tfv<'a>,\n+{}\n+\n+fn main() {}"}, {"sha": "1ade01eed36e491156dd7b3319234d3dd809c729", "filename": "src/test/ui/single-use-lifetime/one-use-in-fn-return.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-fn-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-fn-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-fn-return.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -14,4 +14,10 @@ fn b<'a>() -> &'a u32 {\n     &22\n }\n \n+pub trait Tfv<'a> {}\n+impl Tfv<'_> for () {}\n+\n+// Do NOT lint if used in return type.\n+pub fn i<'a>() -> impl Tfv<'a> {}\n+\n fn main() {}"}, {"sha": "cf34a1ca299aca186fa23684c093a0132d3299a5", "filename": "src/test/ui/single-use-lifetime/one-use-in-inherent-impl-header.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-impl-header.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-impl-header.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-impl-header.stderr?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -11,6 +11,11 @@ note: the lint level is defined here\n    |\n LL | #![deny(single_use_lifetimes)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n+help: elide the single-use lifetime\n+   |\n+LL - impl<'f> Foo<'f> {\n+LL + impl Foo<'_> {\n+   | \n \n error: aborting due to previous error\n "}, {"sha": "eecd715efc1686a1ab0512a77c3d8ab3202656a4", "filename": "src/test/ui/single-use-lifetime/one-use-in-inherent-method-argument.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-method-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-method-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-method-argument.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -9,6 +9,7 @@ struct Foo<'f> {\n }\n \n impl<'f> Foo<'f> { //~ ERROR `'f` only used once\n+    //~^ HELP elide the single-use lifetime\n     fn inherent_a<'a>(&self, data: &'a u32) { //~ ERROR `'a` only used once\n         //~^ HELP elide the single-use lifetime\n     }"}, {"sha": "846c1bf41a29c5adc967198330215bc97190cca6", "filename": "src/test/ui/single-use-lifetime/one-use-in-inherent-method-argument.stderr", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-method-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-method-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-method-argument.stderr?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -1,10 +1,10 @@\n-error: lifetime parameter `'a` only used once\n-  --> $DIR/one-use-in-inherent-method-argument.rs:12:19\n+error: lifetime parameter `'f` only used once\n+  --> $DIR/one-use-in-inherent-method-argument.rs:11:6\n    |\n-LL |     fn inherent_a<'a>(&self, data: &'a u32) {\n-   |                   ^^                -- ...is used only here\n-   |                   |\n-   |                   this lifetime...\n+LL | impl<'f> Foo<'f> {\n+   |      ^^      -- ...is used only here\n+   |      |\n+   |      this lifetime...\n    |\n note: the lint level is defined here\n   --> $DIR/one-use-in-inherent-method-argument.rs:1:9\n@@ -13,17 +13,23 @@ LL | #![deny(single_use_lifetimes)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n help: elide the single-use lifetime\n    |\n-LL -     fn inherent_a<'a>(&self, data: &'a u32) {\n-LL +     fn inherent_a(&self, data: &u32) {\n+LL - impl<'f> Foo<'f> {\n+LL + impl Foo<'_> {\n    | \n \n-error: lifetime parameter `'f` only used once\n-  --> $DIR/one-use-in-inherent-method-argument.rs:11:6\n+error: lifetime parameter `'a` only used once\n+  --> $DIR/one-use-in-inherent-method-argument.rs:13:19\n    |\n-LL | impl<'f> Foo<'f> {\n-   |      ^^      -- ...is used only here\n-   |      |\n-   |      this lifetime...\n+LL |     fn inherent_a<'a>(&self, data: &'a u32) {\n+   |                   ^^                -- ...is used only here\n+   |                   |\n+   |                   this lifetime...\n+   |\n+help: elide the single-use lifetime\n+   |\n+LL -     fn inherent_a<'a>(&self, data: &'a u32) {\n+LL +     fn inherent_a(&self, data: &u32) {\n+   | \n \n error: aborting due to 2 previous errors\n "}, {"sha": "790fcaa409caf1013b2427a5c067ecd730d01425", "filename": "src/test/ui/single-use-lifetime/one-use-in-inherent-method-return.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-method-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-method-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-inherent-method-return.stderr?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -11,6 +11,11 @@ note: the lint level is defined here\n    |\n LL | #![deny(single_use_lifetimes)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n+help: elide the single-use lifetime\n+   |\n+LL - impl<'f> Foo<'f> {\n+LL + impl Foo<'_> {\n+   | \n \n error: aborting due to previous error\n "}, {"sha": "9cad942e7a2e721ea83b64bcbc1dc40bbca408f4", "filename": "src/test/ui/single-use-lifetime/one-use-in-struct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-struct.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -4,7 +4,8 @@\n //\n // check-pass\n \n-#![deny(single_use_lifetimes)]\n+// Use forbid to verify that `automatically_derived` is handled correctly.\n+#![forbid(single_use_lifetimes)]\n #![allow(dead_code)]\n #![allow(unused_variables)]\n "}, {"sha": "1848fc91c629bbc80f86477709d8a27ebc495329", "filename": "src/test/ui/single-use-lifetime/one-use-in-trait-method-argument.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-trait-method-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-trait-method-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-trait-method-argument.rs?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -18,4 +18,9 @@ impl<'f> Iterator for Foo<'f> {\n     }\n }\n \n-fn main() { }\n+trait Bar<'a> {\n+    // But we should not warn here.\n+    fn bar(x: Foo<'a>);\n+}\n+\n+fn main() {}"}, {"sha": "b50975a189e4f587618944c184b27a38fd1d18b8", "filename": "src/test/ui/single-use-lifetime/two-uses-in-inherent-method-argument-and-return.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Ftwo-uses-in-inherent-method-argument-and-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/563916d698380f3773da38b1ebff00ef2842e781/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Ftwo-uses-in-inherent-method-argument-and-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Ftwo-uses-in-inherent-method-argument-and-return.stderr?ref=563916d698380f3773da38b1ebff00ef2842e781", "patch": "@@ -11,6 +11,11 @@ note: the lint level is defined here\n    |\n LL | #![deny(single_use_lifetimes)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n+help: elide the single-use lifetime\n+   |\n+LL - impl<'f> Foo<'f> {\n+LL + impl Foo<'_> {\n+   | \n \n error: aborting due to previous error\n "}]}