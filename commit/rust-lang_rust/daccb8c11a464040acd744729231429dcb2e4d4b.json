{"sha": "daccb8c11a464040acd744729231429dcb2e4d4b", "node_id": "C_kwDOAAsO6NoAKGRhY2NiOGMxMWE0NjQwNDBhY2Q3NDQ3MjkyMzE0MjlkY2IyZTRkNGI", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-10-23T10:30:46Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-19T15:47:42Z"}, "message": "always use `align_offset` in `is_aligned_to` + add assembly test", "tree": {"sha": "9aaa472de2ef31af30601afbd7918d5b8b8c6d6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9aaa472de2ef31af30601afbd7918d5b8b8c6d6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daccb8c11a464040acd744729231429dcb2e4d4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daccb8c11a464040acd744729231429dcb2e4d4b", "html_url": "https://github.com/rust-lang/rust/commit/daccb8c11a464040acd744729231429dcb2e4d4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daccb8c11a464040acd744729231429dcb2e4d4b/comments", "author": null, "committer": null, "parents": [{"sha": "4696e8906d362c1e10ffe40a5935de0ada45fb48", "url": "https://api.github.com/repos/rust-lang/rust/commits/4696e8906d362c1e10ffe40a5935de0ada45fb48", "html_url": "https://github.com/rust-lang/rust/commit/4696e8906d362c1e10ffe40a5935de0ada45fb48"}], "stats": {"total": 96, "additions": 70, "deletions": 26}, "files": [{"sha": "82a01a70a4113e33acd0423eda4ba4e7f673914c", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/daccb8c11a464040acd744729231429dcb2e4d4b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daccb8c11a464040acd744729231429dcb2e4d4b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=daccb8c11a464040acd744729231429dcb2e4d4b", "patch": "@@ -1321,6 +1321,7 @@ impl<T: ?Sized> *const T {\n     /// # }\n     /// ```\n     #[must_use]\n+    #[inline]\n     #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n     #[rustc_const_unstable(feature = \"const_align_offset\", issue = \"90962\")]\n     pub const fn align_offset(self, align: usize) -> usize\n@@ -1562,19 +1563,11 @@ impl<T: ?Sized> *const T {\n             panic!(\"is_aligned_to: align is not a power-of-two\")\n         }\n \n-        #[inline]\n-        fn runtime(ptr: *const u8, align: usize) -> bool {\n-            ptr.addr() & (align - 1) == 0\n-        }\n-\n-        // This optimizes to `(ptr + align - 1) & -align == ptr`, which is slightly\n-        // slower than `ptr & (align - 1) == 0`\n-        const fn comptime(ptr: *const u8, align: usize) -> bool {\n-            ptr.align_offset(align) == 0\n-        }\n-\n-        // SAFETY: `ptr.align_offset(align)` returns 0 if and only if the pointer is already aligned.\n-        unsafe { intrinsics::const_eval_select((self.cast::<u8>(), align), comptime, runtime) }\n+        // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n+        // The cast to `()` is used to\n+        //   1. deal with fat pointers; and\n+        //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n+        self.cast::<()>().align_offset(align) == 0\n     }\n }\n "}, {"sha": "fdb99818ac7f95fb7aa8439fadd6b620836ab013", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/daccb8c11a464040acd744729231429dcb2e4d4b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daccb8c11a464040acd744729231429dcb2e4d4b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=daccb8c11a464040acd744729231429dcb2e4d4b", "patch": "@@ -1589,6 +1589,7 @@ impl<T: ?Sized> *mut T {\n     /// # }\n     /// ```\n     #[must_use]\n+    #[inline]\n     #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n     #[rustc_const_unstable(feature = \"const_align_offset\", issue = \"90962\")]\n     pub const fn align_offset(self, align: usize) -> usize\n@@ -1830,19 +1831,11 @@ impl<T: ?Sized> *mut T {\n             panic!(\"is_aligned_to: align is not a power-of-two\")\n         }\n \n-        #[inline]\n-        fn runtime(ptr: *mut u8, align: usize) -> bool {\n-            ptr.addr() & (align - 1) == 0\n-        }\n-\n-        // This optimizes to `(ptr + align - 1) & -align == ptr`, which is slightly\n-        // slower than `ptr & (align - 1) == 0`\n-        const fn comptime(ptr: *mut u8, align: usize) -> bool {\n-            ptr.align_offset(align) == 0\n-        }\n-\n-        // SAFETY: `ptr.align_offset(align)` returns 0 if and only if the pointer is already aligned.\n-        unsafe { intrinsics::const_eval_select((self.cast::<u8>(), align), comptime, runtime) }\n+        // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n+        // The cast to `()` is used to\n+        //   1. deal with fat pointers; and\n+        //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n+        self.cast::<()>().align_offset(align) == 0\n     }\n }\n "}, {"sha": "3949f5f6530b001d3bea07096307e723c3cae6dd", "filename": "src/test/assembly/is_aligned.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/daccb8c11a464040acd744729231429dcb2e4d4b/src%2Ftest%2Fassembly%2Fis_aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daccb8c11a464040acd744729231429dcb2e4d4b/src%2Ftest%2Fassembly%2Fis_aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fis_aligned.rs?ref=daccb8c11a464040acd744729231429dcb2e4d4b", "patch": "@@ -0,0 +1,58 @@\n+// assembly-output: emit-asm\n+// min-llvm-version: 14.0\n+// only-x86_64\n+// revisions: opt-speed opt-size\n+// [opt-speed] compile-flags: -Copt-level=1\n+// [opt-size] compile-flags: -Copt-level=s\n+#![crate_type=\"rlib\"]\n+\n+#![feature(core_intrinsics)]\n+#![feature(pointer_is_aligned)]\n+\n+// CHECK-LABEL: is_aligned_to_unchecked\n+// CHECK: decq %rsi\n+// CHECK-NEXT: testq %rdi, %rsi\n+// CHECK-NEXT: sete %al\n+// CHECK-NEXT: retq\n+#[no_mangle]\n+pub unsafe fn is_aligned_to_unchecked(ptr: *const u8, align: usize) -> bool {\n+    unsafe {\n+        std::intrinsics::assume(align.is_power_of_two())\n+    }\n+    ptr.is_aligned_to(align)\n+}\n+\n+// CHECK-LABEL: is_aligned_1\n+// CHECK: movb $1, %al\n+// CHECK-NEXT: retq\n+#[no_mangle]\n+pub fn is_aligned_1(ptr: *const u8) -> bool {\n+    ptr.is_aligned()\n+}\n+\n+// CHECK-LABEL: is_aligned_2\n+// CHECK: testb $1, %dil\n+// CHECK-NEXT: sete %al\n+// CHECK-NEXT: retq\n+#[no_mangle]\n+pub fn is_aligned_2(ptr: *const u16) -> bool {\n+    ptr.is_aligned()\n+}\n+\n+// CHECK-LABEL: is_aligned_4\n+// CHECK: testb $3, %dil\n+// CHECK-NEXT: sete %al\n+// CHECK-NEXT: retq\n+#[no_mangle]\n+pub fn is_aligned_4(ptr: *const u32) -> bool {\n+    ptr.is_aligned()\n+}\n+\n+// CHECK-LABEL: is_aligned_8\n+// CHECK: testb $7, %dil\n+// CHECK-NEXT: sete %al\n+// CHECK-NEXT: retq\n+#[no_mangle]\n+pub fn is_aligned_8(ptr: *const u64) -> bool {\n+    ptr.is_aligned()\n+}"}]}