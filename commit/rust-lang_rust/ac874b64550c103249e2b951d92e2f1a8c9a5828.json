{"sha": "ac874b64550c103249e2b951d92e2f1a8c9a5828", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjODc0YjY0NTUwYzEwMzI0OWUyYjk1MWQ5MmUyZjFhOGM5YTU4Mjg=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-21T15:35:51Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-21T15:35:51Z"}, "message": "Merge #237\n\n237: This moves parts of completion from ad-hockery to descriptors-based resolve r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "50fdd5d9681ff57a5cd15de3c401cd478e6f3ab5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50fdd5d9681ff57a5cd15de3c401cd478e6f3ab5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac874b64550c103249e2b951d92e2f1a8c9a5828", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac874b64550c103249e2b951d92e2f1a8c9a5828", "html_url": "https://github.com/rust-lang/rust/commit/ac874b64550c103249e2b951d92e2f1a8c9a5828", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac874b64550c103249e2b951d92e2f1a8c9a5828/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "031bc868293539714157e3d93cc338b011f5661d", "url": "https://api.github.com/repos/rust-lang/rust/commits/031bc868293539714157e3d93cc338b011f5661d", "html_url": "https://github.com/rust-lang/rust/commit/031bc868293539714157e3d93cc338b011f5661d"}, {"sha": "edeec6a41487e6458a9d96b328c9b784525d8f06", "url": "https://api.github.com/repos/rust-lang/rust/commits/edeec6a41487e6458a9d96b328c9b784525d8f06", "html_url": "https://github.com/rust-lang/rust/commit/edeec6a41487e6458a9d96b328c9b784525d8f06"}], "stats": {"total": 428, "additions": 262, "deletions": 166}, "files": [{"sha": "c7717ab615b980af64622280bdd40b2945bcafef", "filename": "crates/ra_analysis/src/completion/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs?ref=ac874b64550c103249e2b951d92e2f1a8c9a5828", "patch": "@@ -220,6 +220,20 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_completion_self_path() {\n+        check_scope_completion(\n+            r\"\n+            use self::m::<|>;\n+\n+            mod m {\n+                struct Bar;\n+            }\n+            \",\n+            r#\"[CompletionItem { label: \"Bar\", lookup: None, snippet: None }]\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_completion_mod_scope_nested() {\n         check_scope_completion("}, {"sha": "d301a3c02035a365d524445a4ec3e424138d6c47", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 18, "deletions": 47, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=ac874b64550c103249e2b951d92e2f1a8c9a5828", "patch": "@@ -10,8 +10,11 @@ use ra_syntax::{\n use crate::{\n     db::RootDatabase,\n     completion::CompletionItem,\n-    descriptors::module::{ModuleDescriptor},\n-    descriptors::function::FnScopes,\n+    descriptors::{\n+        module::{ModuleDescriptor},\n+        function::FnScopes,\n+        Path,\n+    },\n     Cancelable\n };\n \n@@ -55,7 +58,7 @@ pub(super) fn completions(\n                     }),\n             );\n         }\n-        NameRefKind::CratePath(path) => complete_path(acc, db, module, path)?,\n+        NameRefKind::Path(path) => complete_path(acc, db, module, path)?,\n         NameRefKind::BareIdentInMod => {\n             let name_range = name_ref.syntax().range();\n             let top_node = name_ref\n@@ -79,8 +82,8 @@ enum NameRefKind<'a> {\n     LocalRef {\n         enclosing_fn: Option<ast::FnDef<'a>>,\n     },\n-    /// NameRef is the last segment in crate:: path\n-    CratePath(Vec<ast::NameRef<'a>>),\n+    /// NameRef is the last segment in some path\n+    Path(Path),\n     /// NameRef is bare identifier at the module's root.\n     /// Used for keyword completion\n     BareIdentInMod,\n@@ -102,8 +105,10 @@ fn classify_name_ref(name_ref: ast::NameRef) -> Option<NameRefKind> {\n     let parent = name_ref.syntax().parent()?;\n     if let Some(segment) = ast::PathSegment::cast(parent) {\n         let path = segment.parent_path();\n-        if let Some(crate_path) = crate_path(path) {\n-            return Some(NameRefKind::CratePath(crate_path));\n+        if let Some(path) = Path::from_ast(path) {\n+            if !path.is_ident() {\n+                return Some(NameRefKind::Path(path));\n+            }\n         }\n         if path.qualifier().is_none() {\n             let enclosing_fn = name_ref\n@@ -117,32 +122,6 @@ fn classify_name_ref(name_ref: ast::NameRef) -> Option<NameRefKind> {\n     None\n }\n \n-fn crate_path(mut path: ast::Path) -> Option<Vec<ast::NameRef>> {\n-    let mut res = Vec::new();\n-    loop {\n-        let segment = path.segment()?;\n-        match segment.kind()? {\n-            ast::PathSegmentKind::Name(name) => res.push(name),\n-            ast::PathSegmentKind::CrateKw => break,\n-            ast::PathSegmentKind::SelfKw | ast::PathSegmentKind::SuperKw => return None,\n-        }\n-        path = qualifier(path)?;\n-    }\n-    res.reverse();\n-    return Some(res);\n-\n-    fn qualifier(path: ast::Path) -> Option<ast::Path> {\n-        if let Some(q) = path.qualifier() {\n-            return Some(q);\n-        }\n-        // TODO: this bottom up traversal is not too precise.\n-        // Should we handle do a top-down analysiss, recording results?\n-        let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n-        let use_tree = use_tree_list.parent_use_tree();\n-        use_tree.path()\n-    }\n-}\n-\n fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<CompletionItem>) {\n     let mut shadowed = FxHashSet::default();\n     acc.extend(\n@@ -169,9 +148,13 @@ fn complete_path(\n     acc: &mut Vec<CompletionItem>,\n     db: &RootDatabase,\n     module: &ModuleDescriptor,\n-    crate_path: Vec<ast::NameRef>,\n+    mut path: Path,\n ) -> Cancelable<()> {\n-    let target_module = match find_target_module(module, crate_path) {\n+    if path.segments.is_empty() {\n+        return Ok(());\n+    }\n+    path.segments.pop();\n+    let target_module = match module.resolve_path(path) {\n         None => return Ok(()),\n         Some(it) => it,\n     };\n@@ -188,18 +171,6 @@ fn complete_path(\n     Ok(())\n }\n \n-fn find_target_module(\n-    module: &ModuleDescriptor,\n-    mut crate_path: Vec<ast::NameRef>,\n-) -> Option<ModuleDescriptor> {\n-    crate_path.pop();\n-    let mut target_module = module.crate_root();\n-    for name in crate_path {\n-        target_module = target_module.child(name.text().as_str())?;\n-    }\n-    Some(target_module)\n-}\n-\n fn complete_mod_item_snippets(acc: &mut Vec<CompletionItem>) {\n     acc.push(CompletionItem {\n         label: \"tfn\".to_string(),"}, {"sha": "97750ea6462f8c2fed0b3c8965f52dc056710194", "filename": "crates/ra_analysis/src/descriptors/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs?ref=ac874b64550c103249e2b951d92e2f1a8c9a5828", "patch": "@@ -1,10 +1,11 @@\n pub(crate) mod function;\n pub(crate) mod module;\n+mod path;\n \n use std::sync::Arc;\n \n use ra_syntax::{\n-    ast::{self, AstNode, FnDefNode},\n+    ast::{self, FnDefNode, AstNode},\n     TextRange,\n };\n \n@@ -18,6 +19,8 @@ use crate::{\n     Cancelable,\n };\n \n+pub(crate) use self::path::{Path, PathKind};\n+\n salsa::query_group! {\n     pub(crate) trait DescriptorDatabase: SyntaxDatabase + IdDatabase {\n         fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {"}, {"sha": "acc6c1c5a1cce7f1bbeee124f8c09b4e449a5347", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=ac874b64550c103249e2b951d92e2f1a8c9a5828", "patch": "@@ -14,11 +14,11 @@ use relative_path::RelativePathBuf;\n \n use crate::{\n     db::SyntaxDatabase, syntax_ptr::SyntaxPtr, FileId, FilePosition, Cancelable,\n-    descriptors::DescriptorDatabase,\n+    descriptors::{Path, PathKind, DescriptorDatabase},\n     input::SourceRootId\n };\n \n-pub(crate) use self::{nameres::ModuleScope};\n+pub(crate) use self::nameres::ModuleScope;\n \n /// `ModuleDescriptor` is API entry point to get all the information\n /// about a particular module.\n@@ -110,6 +110,7 @@ impl ModuleDescriptor {\n     }\n \n     /// `name` is `None` for the crate's root module\n+    #[allow(unused)]\n     pub fn name(&self) -> Option<SmolStr> {\n         let link = self.module_id.parent_link(&self.tree)?;\n         Some(link.name(&self.tree))\n@@ -131,6 +132,19 @@ impl ModuleDescriptor {\n         Ok(res)\n     }\n \n+    pub(crate) fn resolve_path(&self, path: Path) -> Option<ModuleDescriptor> {\n+        let mut curr = match path.kind {\n+            PathKind::Crate => self.crate_root(),\n+            PathKind::Self_ | PathKind::Plain => self.clone(),\n+            PathKind::Super => self.parent()?,\n+        };\n+        let segments = path.segments;\n+        for name in segments {\n+            curr = curr.child(&name)?;\n+        }\n+        Some(curr)\n+    }\n+\n     pub fn problems(&self, db: &impl DescriptorDatabase) -> Vec<(SyntaxNode, Problem)> {\n         self.module_id.problems(&self.tree, db)\n     }"}, {"sha": "4c555421df69bfebcbebb51a2a1e2cdc753bf5f4", "filename": "crates/ra_analysis/src/descriptors/module/nameres.rs", "status": "modified", "additions": 54, "deletions": 108, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs?ref=ac874b64550c103249e2b951d92e2f1a8c9a5828", "patch": "@@ -1,4 +1,19 @@\n-//! Name resolution algorithm\n+//! Name resolution algorithm. The end result of the algorithm is `ItemMap`: a\n+//! map with maps each module to it's scope: the set of items, visible in the\n+//! module. That is, we only resolve imports here, name resolution of item\n+//! bodies will be done in a separate step.\n+//!\n+//! Like Rustc, we use an interative per-crate algorithm: we start with scopes\n+//! containing only directly defined items, and then iteratively resolve\n+//! imports.\n+//!\n+//! To make this work nicely in the IDE scenarios, we place `InputModuleItems`\n+//! in between raw syntax and name resolution. `InputModuleItems` are computed\n+//! using only the module's syntax, and it is all directly defined items plus\n+//! imports. The plain is to make `InputModuleItems` independent of local\n+//! modifications (that is, typing inside a function shold not change IMIs),\n+//! such that the results of name resolution can be preserved unless the module\n+//! structure itself is modified.\n use std::{\n     sync::Arc,\n     time::Instant,\n@@ -8,13 +23,14 @@ use rustc_hash::FxHashMap;\n \n use ra_syntax::{\n     SmolStr, SyntaxKind::{self, *},\n-    ast::{self, AstNode, ModuleItemOwner}\n+    ast::{self, ModuleItemOwner}\n };\n \n use crate::{\n     Cancelable,\n     loc2id::{DefId, DefLoc},\n     descriptors::{\n+        Path, PathKind,\n         DescriptorDatabase,\n         module::{ModuleId, ModuleTree, ModuleSourceNode},\n     },\n@@ -32,7 +48,6 @@ pub(crate) struct ItemMap {\n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub(crate) struct ModuleScope {\n     pub(crate) items: FxHashMap<SmolStr, Resolution>,\n-    pub(crate) import_resolutions: FxHashMap<LocalSyntaxPtr, DefId>,\n }\n \n /// A set of items and imports declared inside a module, without relation to\n@@ -44,22 +59,20 @@ pub(crate) struct ModuleScope {\n #[derive(Debug, Default, PartialEq, Eq)]\n pub(crate) struct InputModuleItems {\n     items: Vec<ModuleItem>,\n-    glob_imports: Vec<Path>,\n-    imports: Vec<Path>,\n+    imports: Vec<Import>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-struct Path {\n-    kind: PathKind,\n-    segments: Vec<(LocalSyntaxPtr, SmolStr)>,\n+struct Import {\n+    path: Path,\n+    kind: ImportKind,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum PathKind {\n-    Abs,\n-    Self_,\n-    Super,\n-    Crate,\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+enum ImportKind {\n+    Glob,\n+    // TODO: make offset independent\n+    Named(LocalSyntaxPtr),\n }\n \n pub(crate) fn input_module_items(\n@@ -182,86 +195,16 @@ impl InputModuleItems {\n     }\n \n     fn add_use_item(&mut self, item: ast::UseItem) {\n-        if let Some(tree) = item.use_tree() {\n-            self.add_use_tree(None, tree);\n-        }\n-    }\n-\n-    fn add_use_tree(&mut self, prefix: Option<Path>, tree: ast::UseTree) {\n-        if let Some(use_tree_list) = tree.use_tree_list() {\n-            let prefix = match tree.path() {\n-                None => prefix,\n-                Some(path) => match convert_path(prefix, path) {\n-                    Some(it) => Some(it),\n-                    None => return, // TODO: report errors somewhere\n-                },\n+        Path::expand_use_item(item, |path, ptr| {\n+            let kind = match ptr {\n+                None => ImportKind::Glob,\n+                Some(ptr) => ImportKind::Named(ptr),\n             };\n-            for tree in use_tree_list.use_trees() {\n-                self.add_use_tree(prefix.clone(), tree);\n-            }\n-        } else {\n-            if let Some(path) = tree.path() {\n-                if let Some(path) = convert_path(prefix, path) {\n-                    if tree.has_star() {\n-                        &mut self.glob_imports\n-                    } else {\n-                        &mut self.imports\n-                    }\n-                    .push(path);\n-                }\n-            }\n-        }\n+            self.imports.push(Import { kind, path })\n+        })\n     }\n }\n \n-fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n-    let prefix = if let Some(qual) = path.qualifier() {\n-        Some(convert_path(prefix, qual)?)\n-    } else {\n-        None\n-    };\n-    let segment = path.segment()?;\n-    let res = match segment.kind()? {\n-        ast::PathSegmentKind::Name(name) => {\n-            let mut res = prefix.unwrap_or_else(|| Path {\n-                kind: PathKind::Abs,\n-                segments: Vec::with_capacity(1),\n-            });\n-            let ptr = LocalSyntaxPtr::new(name.syntax());\n-            res.segments.push((ptr, name.text()));\n-            res\n-        }\n-        ast::PathSegmentKind::CrateKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path {\n-                kind: PathKind::Crate,\n-                segments: Vec::new(),\n-            }\n-        }\n-        ast::PathSegmentKind::SelfKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path {\n-                kind: PathKind::Self_,\n-                segments: Vec::new(),\n-            }\n-        }\n-        ast::PathSegmentKind::SuperKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path {\n-                kind: PathKind::Super,\n-                segments: Vec::new(),\n-            }\n-        }\n-    };\n-    Some(res)\n-}\n-\n impl ModuleItem {\n     fn new<'a>(item: impl ast::NameOwner<'a>) -> Option<ModuleItem> {\n         let name = item.name()?.text();\n@@ -308,14 +251,16 @@ where\n         let mut module_items = ModuleScope::default();\n \n         for import in input.imports.iter() {\n-            if let Some((ptr, name)) = import.segments.last() {\n-                module_items.items.insert(\n-                    name.clone(),\n-                    Resolution {\n-                        def_id: None,\n-                        import_name: Some(*ptr),\n-                    },\n-                );\n+            if let Some(name) = import.path.segments.iter().last() {\n+                if let ImportKind::Named(ptr) = import.kind {\n+                    module_items.items.insert(\n+                        name.clone(),\n+                        Resolution {\n+                            def_id: None,\n+                            import_name: Some(ptr),\n+                        },\n+                    );\n+                }\n             }\n         }\n \n@@ -356,10 +301,15 @@ where\n         }\n     }\n \n-    fn resolve_import(&mut self, module_id: ModuleId, import: &Path) {\n-        let mut curr = match import.kind {\n+    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) {\n+        let ptr = match import.kind {\n+            ImportKind::Glob => return,\n+            ImportKind::Named(ptr) => ptr,\n+        };\n+\n+        let mut curr = match import.path.kind {\n             // TODO: handle extern crates\n-            PathKind::Abs => return,\n+            PathKind::Plain => return,\n             PathKind::Self_ => module_id,\n             PathKind::Super => {\n                 match module_id.parent(&self.module_tree) {\n@@ -371,8 +321,8 @@ where\n             PathKind::Crate => module_id.crate_root(&self.module_tree),\n         };\n \n-        for (i, (ptr, name)) in import.segments.iter().enumerate() {\n-            let is_last = i == import.segments.len() - 1;\n+        for (i, name) in import.path.segments.iter().enumerate() {\n+            let is_last = i == import.path.segments.len() - 1;\n \n             let def_id = match self.result.per_module[&curr].items.get(name) {\n                 None => return,\n@@ -382,10 +332,6 @@ where\n                 },\n             };\n \n-            self.update(module_id, |items| {\n-                items.import_resolutions.insert(*ptr, def_id);\n-            });\n-\n             if !is_last {\n                 curr = match self.db.id_maps().def_loc(def_id) {\n                     DefLoc::Module { id, .. } => id,\n@@ -395,7 +341,7 @@ where\n                 self.update(module_id, |items| {\n                     let res = Resolution {\n                         def_id: Some(def_id),\n-                        import_name: Some(*ptr),\n+                        import_name: Some(ptr),\n                     };\n                     items.items.insert(name.clone(), res);\n                 })"}, {"sha": "99fca18b17bd92b05156b86b3e79efda57020962", "filename": "crates/ra_analysis/src/descriptors/path.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fpath.rs?ref=ac874b64550c103249e2b951d92e2f1a8c9a5828", "patch": "@@ -0,0 +1,153 @@\n+use ra_syntax::{SmolStr, ast, AstNode};\n+\n+use crate::syntax_ptr::LocalSyntaxPtr;\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(crate) struct Path {\n+    pub(crate) kind: PathKind,\n+    pub(crate) segments: Vec<SmolStr>,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(crate) enum PathKind {\n+    Plain,\n+    Self_,\n+    Super,\n+    Crate,\n+}\n+\n+impl Path {\n+    /// Calls `cb` with all paths, represented by this use item.\n+    pub(crate) fn expand_use_item(\n+        item: ast::UseItem,\n+        mut cb: impl FnMut(Path, Option<LocalSyntaxPtr>),\n+    ) {\n+        if let Some(tree) = item.use_tree() {\n+            expand_use_tree(None, tree, &mut cb);\n+        }\n+    }\n+\n+    /// Converts an `ast::Path` to `Path`. Works with use trees.\n+    pub(crate) fn from_ast(mut path: ast::Path) -> Option<Path> {\n+        let mut kind = PathKind::Plain;\n+        let mut segments = Vec::new();\n+        loop {\n+            let segment = path.segment()?;\n+            match segment.kind()? {\n+                ast::PathSegmentKind::Name(name) => segments.push(name.text()),\n+                ast::PathSegmentKind::CrateKw => {\n+                    kind = PathKind::Crate;\n+                    break;\n+                }\n+                ast::PathSegmentKind::SelfKw => {\n+                    kind = PathKind::Self_;\n+                    break;\n+                }\n+                ast::PathSegmentKind::SuperKw => {\n+                    kind = PathKind::Super;\n+                    break;\n+                }\n+            }\n+            path = match qualifier(path) {\n+                Some(it) => it,\n+                None => break,\n+            };\n+        }\n+        segments.reverse();\n+        return Some(Path { kind, segments });\n+\n+        fn qualifier(path: ast::Path) -> Option<ast::Path> {\n+            if let Some(q) = path.qualifier() {\n+                return Some(q);\n+            }\n+            // TODO: this bottom up traversal is not too precise.\n+            // Should we handle do a top-down analysiss, recording results?\n+            let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n+            let use_tree = use_tree_list.parent_use_tree();\n+            use_tree.path()\n+        }\n+    }\n+\n+    /// `true` is this path is a single identifier, like `foo`\n+    pub(crate) fn is_ident(&self) -> bool {\n+        self.kind == PathKind::Plain && self.segments.len() == 1\n+    }\n+}\n+\n+fn expand_use_tree(\n+    prefix: Option<Path>,\n+    tree: ast::UseTree,\n+    cb: &mut impl FnMut(Path, Option<LocalSyntaxPtr>),\n+) {\n+    if let Some(use_tree_list) = tree.use_tree_list() {\n+        let prefix = match tree.path() {\n+            None => prefix,\n+            Some(path) => match convert_path(prefix, path) {\n+                Some(it) => Some(it),\n+                None => return, // TODO: report errors somewhere\n+            },\n+        };\n+        for tree in use_tree_list.use_trees() {\n+            expand_use_tree(prefix.clone(), tree, cb);\n+        }\n+    } else {\n+        if let Some(ast_path) = tree.path() {\n+            if let Some(path) = convert_path(prefix, ast_path) {\n+                let ptr = if tree.has_star() {\n+                    None\n+                } else {\n+                    let ptr = LocalSyntaxPtr::new(ast_path.segment().unwrap().syntax());\n+                    Some(ptr)\n+                };\n+                cb(path, ptr)\n+            }\n+        }\n+    }\n+}\n+\n+fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n+    let prefix = if let Some(qual) = path.qualifier() {\n+        Some(convert_path(prefix, qual)?)\n+    } else {\n+        None\n+    };\n+    let segment = path.segment()?;\n+    let res = match segment.kind()? {\n+        ast::PathSegmentKind::Name(name) => {\n+            let mut res = prefix.unwrap_or_else(|| Path {\n+                kind: PathKind::Plain,\n+                segments: Vec::with_capacity(1),\n+            });\n+            res.segments.push(name.text());\n+            res\n+        }\n+        ast::PathSegmentKind::CrateKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path {\n+                kind: PathKind::Crate,\n+                segments: Vec::new(),\n+            }\n+        }\n+        ast::PathSegmentKind::SelfKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path {\n+                kind: PathKind::Self_,\n+                segments: Vec::new(),\n+            }\n+        }\n+        ast::PathSegmentKind::SuperKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path {\n+                kind: PathKind::Super,\n+                segments: Vec::new(),\n+            }\n+        }\n+    };\n+    Some(res)\n+}"}, {"sha": "c6b1161595e08159455113faf5e2045a0cdd2e4c", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=ac874b64550c103249e2b951d92e2f1a8c9a5828", "patch": "@@ -148,12 +148,7 @@ pub fn find_node_at_offset<'a, N: AstNode<'a>>(\n     syntax: SyntaxNodeRef<'a>,\n     offset: TextUnit,\n ) -> Option<N> {\n-    let leaves = find_leaf_at_offset(syntax, offset);\n-    let leaf = leaves\n-        .clone()\n-        .find(|leaf| !leaf.kind().is_trivia())\n-        .or_else(|| leaves.right_biased())?;\n-    leaf.ancestors().filter_map(N::cast).next()\n+    find_leaf_at_offset(syntax, offset).find_map(|leaf| leaf.ancestors().find_map(N::cast))\n }\n \n #[cfg(test)]"}, {"sha": "68226690809194695a97ca3430ffd28fee1bb605", "filename": "crates/ra_syntax/src/grammar/items/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Fmod.rs?ref=ac874b64550c103249e2b951d92e2f1a8c9a5828", "patch": "@@ -29,7 +29,7 @@ pub(super) enum ItemFlavor {\n     Trait,\n }\n \n-const ITEM_RECOVERY_SET: TokenSet = token_set![\n+pub(super) const ITEM_RECOVERY_SET: TokenSet = token_set![\n     FN_KW, STRUCT_KW, ENUM_KW, IMPL_KW, TRAIT_KW, CONST_KW, STATIC_KW, LET_KW, MOD_KW, PUB_KW,\n     CRATE_KW\n ];"}, {"sha": "33a11886cb3085c50c0f5fb7dffcc5052bdb37a5", "filename": "crates/ra_syntax/src/grammar/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac874b64550c103249e2b951d92e2f1a8c9a5828/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpaths.rs?ref=ac874b64550c103249e2b951d92e2f1a8c9a5828", "patch": "@@ -78,7 +78,7 @@ fn path_segment(p: &mut Parser, mode: Mode, first: bool) {\n             // use crate::foo;\n             SELF_KW | SUPER_KW | CRATE_KW => p.bump(),\n             _ => {\n-                p.err_and_bump(\"expected identifier\");\n+                p.err_recover(\"expected identifier\", items::ITEM_RECOVERY_SET);\n             }\n         };\n     }"}]}