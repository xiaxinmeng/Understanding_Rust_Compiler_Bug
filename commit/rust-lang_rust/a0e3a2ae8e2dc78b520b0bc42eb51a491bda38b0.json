{"sha": "a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZTNhMmFlOGUyZGM3OGI1MjBiMGJjNDJlYjUxYTQ5MWJkYTM4YjA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-09T02:41:50Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-09T02:59:30Z"}, "message": "Const field access (working) and vec indexing (almost). More for #2317.", "tree": {"sha": "bc971e23da42acc3c6a43853871aa9e50e8c1a68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc971e23da42acc3c6a43853871aa9e50e8c1a68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0", "html_url": "https://github.com/rust-lang/rust/commit/a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf", "html_url": "https://github.com/rust-lang/rust/commit/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf"}], "stats": {"total": 112, "additions": 110, "deletions": 2}, "files": [{"sha": "545cc049f4843f68b45dca0c550bcb50716c228f", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0", "patch": "@@ -102,6 +102,8 @@ fn check_expr(sess: session, def_map: resolve3::DefMap,\n           expr_vstore(_, vstore_fixed(_)) |\n           expr_vec(_, m_imm) |\n           expr_addr_of(m_imm, _) |\n+          expr_field(*) |\n+          expr_index(*) |\n           expr_tup(*) |\n           expr_struct(*) |\n           expr_rec(*) => { }"}, {"sha": "e7f281c461fabad19595d66168f7327f4ca6e801", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0", "patch": "@@ -43,6 +43,33 @@ fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n     return (v, sz, llunitty);\n }\n \n+fn const_deref(v: ValueRef) -> ValueRef {\n+    assert llvm::LLVMIsGlobalConstant(v) == True;\n+    llvm::LLVMGetInitializer(v)\n+}\n+\n+fn const_get_elt(v: ValueRef, u: uint) -> ValueRef {\n+    let u = u;\n+    llvm::LLVMConstExtractValue(v, ptr::addr_of(u), 1 as c_uint)\n+}\n+\n+fn const_autoderef(ty: ty::t, v: ValueRef)\n+    -> (ty::t, ValueRef) {\n+    let mut t1 = ty;\n+    let mut v1 = v;\n+    loop {\n+        // Only rptrs can be autoderef'ed in a const context.\n+        match ty::get(ty).struct {\n+            ty::ty_rptr(_, mt) => {\n+                t1 = mt.ty;\n+                v1 = const_deref(v1);\n+            }\n+            _ => return (t1,v1)\n+        }\n+    }\n+}\n+\n+\n fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     let _icx = cx.insn_ctxt(~\"const_expr\");\n     match e.node {\n@@ -106,15 +133,74 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         return match u {\n           ast::box(_)  |\n           ast::uniq(_) |\n-          ast::deref   => cx.sess.span_bug(e.span,\n-                                           ~\"bad unop type in const_expr\"),\n+          ast::deref  => const_deref(te),\n           ast::not    => llvm::LLVMConstNot(te),\n           ast::neg    => {\n             if is_float { llvm::LLVMConstFNeg(te) }\n             else        { llvm::LLVMConstNeg(te) }\n           }\n         }\n       }\n+      ast::expr_field(base, field, _) => {\n+          let bt = ty::expr_ty(cx.tcx, base);\n+          let bv = const_expr(cx, base);\n+          let (bt, bv) = const_autoderef(bt, bv);\n+          let fields = match ty::get(bt).struct {\n+              ty::ty_rec(fs) => fs,\n+              ty::ty_class(did, substs) =>\n+                  ty::class_items_as_mutable_fields(cx.tcx, did, substs),\n+              _ => cx.sess.span_bug(e.span,\n+                                    ~\"field access on unknown type in const\"),\n+          };\n+          let ix = field_idx_strict(cx.tcx, e.span, field, fields);\n+          const_get_elt(bv, ix)\n+      }\n+\n+      ast::expr_index(base, index) => {\n+          let bt = ty::expr_ty(cx.tcx, base);\n+          let bv = const_expr(cx, base);\n+          let (bt, bv) = const_autoderef(bt, bv);\n+          let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n+              const_eval::const_int(i) => i as u64,\n+              const_eval::const_uint(u) => u,\n+              _ => cx.sess.span_bug(index.span,\n+                                    ~\"index is not an integer-constant \\\n+                                      expression\")\n+          };\n+          let (arr,len) = match ty::get(bt).struct {\n+              ty::ty_evec(_, vstore) | ty::ty_estr(vstore) =>\n+                  match vstore {\n+                  ty::vstore_fixed(u) =>\n+                      (bv, C_uint(cx, u)),\n+\n+                  ty::vstore_slice(_) => {\n+                      let unit_ty = ty::sequence_element_type(cx.tcx, bt);\n+                      let llunitty = type_of::type_of(cx, unit_ty);\n+                      let unit_sz = shape::llsize_of(cx, llunitty);\n+                      (const_deref(const_get_elt(bv, 0)),\n+                       llvm::LLVMConstUDiv(const_get_elt(bv, 1),\n+                                            unit_sz))\n+                  },\n+                  _ => cx.sess.span_bug(base.span,\n+                                        ~\"index-expr base must be \\\n+                                          fixed-size or slice\")\n+              },\n+              _ =>  cx.sess.span_bug(base.span,\n+                                     ~\"index-expr base must be \\\n+                                       a vector or string type\")\n+          };\n+          let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n+          let len = match ty::get(bt).struct {\n+              ty::ty_estr(*) => {assert len > 0; len - 1},\n+              _ => len\n+          };\n+          if iv >= len {\n+              // Better late than never for reporting this?\n+              cx.sess.span_err(e.span,\n+                               ~\"const index-expr is out of bounds\");\n+          }\n+          const_get_elt(arr, iv as uint)\n+      }\n       ast::expr_cast(base, tp) => {\n         let ety = ty::expr_ty(cx.tcx, e), llty = type_of::type_of(cx, ety);\n         let basety = ty::expr_ty(cx.tcx, base);"}, {"sha": "6190053df7a0fc89d67b0e3a658810a855a59e31", "filename": "src/test/run-pass/const-fields-and-indexing.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs?ref=a0e3a2ae8e2dc78b520b0bc42eb51a491bda38b0", "patch": "@@ -0,0 +1,20 @@\n+// Not quite working on the indexing part yet.\n+/*\n+const x : [int]/4 = [1,2,3,4];\n+const y : &[int] = &[1,2,3,4];\n+const p : int = x[2];\n+const q : int = y[2];\n+*/\n+\n+const s : {a: int, b: int} = {a: 10, b: 20};\n+const t : int = s.b;\n+\n+fn main() {\n+\n+//    io::println(fmt!(\"%?\", p));\n+//    io::println(fmt!(\"%?\", q));\n+    io::println(fmt!(\"%?\", t));\n+//    assert p == 3;\n+//    assert q == 3;\n+    assert t == 20;\n+}\n\\ No newline at end of file"}]}