{"sha": "9ef4463b2a7d2c41fbc1072779951b445c80f95b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZjQ0NjNiMmE3ZDJjNDFmYmMxMDcyNzc5OTUxYjQ0NWM4MGY5NWI=", "commit": {"author": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2013-09-27T20:43:41Z"}, "committer": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2013-10-05T10:09:30Z"}, "message": "Use slice representation for module entries in CrateMap\n\nRelaxe lifetime of CrateMap as well.", "tree": {"sha": "ca783a7a10a7de1d7c1700641e1c183bd7acc9c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca783a7a10a7de1d7c1700641e1c183bd7acc9c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ef4463b2a7d2c41fbc1072779951b445c80f95b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef4463b2a7d2c41fbc1072779951b445c80f95b", "html_url": "https://github.com/rust-lang/rust/commit/9ef4463b2a7d2c41fbc1072779951b445c80f95b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ef4463b2a7d2c41fbc1072779951b445c80f95b/comments", "author": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "787f20a2550318a65bff6d69599afde562949a8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/787f20a2550318a65bff6d69599afde562949a8a", "html_url": "https://github.com/rust-lang/rust/commit/787f20a2550318a65bff6d69599afde562949a8a"}], "stats": {"total": 160, "additions": 60, "deletions": 100}, "files": [{"sha": "98de8293b60868855a19de1c771f6ae19b56ef2d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9ef4463b2a7d2c41fbc1072779951b445c80f95b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef4463b2a7d2c41fbc1072779951b445c80f95b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9ef4463b2a7d2c41fbc1072779951b445c80f95b", "patch": "@@ -2911,9 +2911,9 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     }\n }\n \n-pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n+pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint) {\n     let elttype = Type::struct_([ccx.int_type, ccx.int_type], false);\n-    let maptype = Type::array(&elttype, (ccx.module_data.len() + 1) as u64);\n+    let maptype = Type::array(&elttype, ccx.module_data.len() as u64);\n     let map = do \"_rust_mod_map\".with_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n@@ -2938,18 +2938,15 @@ pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n         let elt = C_struct([s_ptr, v_ptr]);\n         elts.push(elt);\n     }\n-    let term = C_struct([C_int(ccx, 0), C_int(ccx, 0)]);\n-    elts.push(term);\n     unsafe {\n         llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n     }\n-    return map;\n+    return (map, keys.len());\n }\n \n \n pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n                       llmod: ModuleRef) -> ValueRef {\n-    \n     let targ_cfg = sess.targ_cfg;\n     let int_type = Type::int(targ_cfg.arch);\n     let mut n_subcrates = 1;\n@@ -2962,8 +2959,8 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     };\n \n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n-    let vectype = Type::struct_([int_type, int_type], false);\n-    let maptype = Type::struct_([Type::i32(), int_type, vectype], false);\n+    let slicetype = Type::struct_([int_type, int_type], false);\n+    let maptype = Type::struct_([Type::i32(), slicetype, slicetype], false);\n     let map = do sym_name.with_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n@@ -3006,14 +3003,17 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n         lib::llvm::SetLinkage(vec_elements, lib::llvm::InternalLinkage);\n \n         llvm::LLVMSetInitializer(vec_elements, C_array(ccx.int_type, subcrates));\n-        let mod_map = create_module_map(ccx);\n+        let (mod_map, mod_count) = create_module_map(ccx);\n \n         llvm::LLVMSetInitializer(map, C_struct(\n             [C_i32(1),\n-             p2i(ccx, mod_map),\n-             C_struct(\n-                [p2i(ccx, vec_elements),\n-                 C_int(ccx, (subcrates.len() * 8) as int)\n+             C_struct([\n+                p2i(ccx, mod_map),\n+                C_int(ccx, (mod_count * 16) as int)\n+             ]),\n+             C_struct([\n+                p2i(ccx, vec_elements),\n+                C_int(ccx, (subcrates.len() * 8) as int)\n              ])\n         ]));\n     }"}, {"sha": "499516bb4fd379676b122cb2d0fd94ec9c7901eb", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 42, "deletions": 80, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/9ef4463b2a7d2c41fbc1072779951b445c80f95b/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef4463b2a7d2c41fbc1072779951b445c80f95b/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=9ef4463b2a7d2c41fbc1072779951b445c80f95b", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cast::transmute;\n+#[cfg(not(stage0))] use cast::transmute;\n use container::MutableSet;\n use hashmap::HashSet;\n use libc::c_char;\n+use option::{Some, None};\n+use vec::ImmutableVector;\n \n // Need to tell the linker on OS X to not barf on undefined symbols\n // and instead look them up at runtime, which we need to resolve\n@@ -24,36 +26,36 @@ extern {}\n extern {\n     #[weak_linkage]\n     #[link_name = \"_rust_crate_map_toplevel\"]\n-    static CRATE_MAP: CrateMap;\n+    static CRATE_MAP: CrateMap<'static>;\n }\n \n pub struct ModEntry {\n     name: *c_char,\n     log_level: *mut u32\n }\n \n-struct CrateMapV0 {\n-    entries: &static [ModEntry],\n-    children: &'static [&'static CrateMap]\n+pub struct CrateMapV0<'self> {\n+    entries: &'self [ModEntry],\n+    children: &'self [&'self CrateMap<'self>]\n }\n \n-struct CrateMap {\n+pub struct CrateMap<'self> {\n     version: i32,\n-    entries: &static [ModEntry],\n+    entries: &'self [ModEntry],\n     /// a dynamically sized struct, where all pointers to children are listed adjacent\n     /// to the struct, terminated with NULL\n-    children: [*CrateMap, ..1]\n+    children: &'self [&'self CrateMap<'self>]\n }\n \n #[cfg(not(windows))]\n-pub fn get_crate_map() -> *CrateMap {\n-    &'static CRATE_MAP as *CrateMap\n+pub fn get_crate_map() -> &'static CrateMap<'static> {\n+    &'static CRATE_MAP\n }\n \n #[cfg(windows)]\n #[fixed_stack_segment]\n #[inline(never)]\n-pub fn get_crate_map() -> *CrateMap {\n+pub fn get_crate_map() -> &'static CrateMap<'static> {\n     use c_str::ToCStr;\n     use unstable::dynamic_lib::dl;\n \n@@ -65,24 +67,24 @@ pub fn get_crate_map() -> *CrateMap {\n         dl::close(module);\n         sym\n     };\n-\n-    sym as *CrateMap\n+    sym\n }\n \n-fn version(crate_map: &'static CrateMap) -> i32 {\n+fn version(crate_map: &CrateMap) -> i32 {\n     match crate_map.version {\n         1 => return 1,\n         _ => return 0\n     }\n }\n \n #[cfg(not(stage0))]\n-fn entries(crate_map: &'static CrateMap) -> *ModEntry {\n+fn get_entries_and_children<'a>(crate_map: &'a CrateMap<'a>) ->\n+                    (&'a [ModEntry], &'a [&'a CrateMap<'a>]) {\n     match version(crate_map) {\n         0 => {\n             unsafe {\n-                let v0: &'static CrateMapV0 = transmute(crate_map);\n-                return v0.entries;\n+                let v0: &'a CrateMapV0<'a> = transmute(crate_map);\n+                return (v0.entries, v0.children);\n             }\n         }\n         1 => return (*crate_map).entries,\n@@ -91,100 +93,63 @@ fn entries(crate_map: &'static CrateMap) -> *ModEntry {\n }\n \n #[cfg(not(stage0))]\n-fn iterator(crate_map: &'static CrateMap) -> &'static [&'static CrateMap] {\n-    match version(crate_map) {\n-        0 => {\n-            unsafe {\n-                let v0: &'static CrateMapV0 = transmute(crate_map);\n-                return v0.children;\n-            }\n-        }\n-        1 => return vec::raw::to_ptr((*crate_map).children),\n-        _ => fail2!(\"Unknown crate map version!\")\n-    }\n-}\n-\n-fn iter_module_map(mod_entries: *ModEntry, f: &fn(&mut ModEntry)) {\n-    let mut curr = mod_entries;\n-\n-    unsafe {\n-        while !(*curr).name.is_null() {\n-            f(transmute(curr));\n-            curr = curr.offset(1);\n-        }\n+fn iter_module_map(mod_entries: &[ModEntry], f: &fn(&ModEntry)) {\n+    for entry in mod_entries.iter() {\n+        f(entry);\n     }\n }\n \n-\n-\n #[cfg(not(stage0))]\n-fn do_iter_crate_map(crate_map: &'static CrateMap, f: &fn(&mut ModEntry),\n-                            visited: &mut HashSet<*CrateMap>) {\n+fn do_iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry),\n+                            visited: &mut HashSet<*CrateMap<'a>>) {\n     if visited.insert(crate_map as *CrateMap) {\n-        iter_module_map(crate_map.entries, |x| f(x));\n-        let child_crates = iterator(crate_map);\n-        \n-        let mut i = 0;\n-        while i < child_crates.len() {\n-            do_iter_crate_map(child_crates[i], |x| f(x), visited);\n-            i = i + 1;\n+        let (entries, children) = get_entries_and_children(crate_map);\n+        iter_module_map(entries, |x| f(x));\n+        for child in children.iter() {\n+            do_iter_crate_map(*child, |x| f(x), visited);\n         }\n     }\n }\n \n #[cfg(stage0)]\n /// Iterates recursively over `crate_map` and all child crate maps\n-pub fn iter_crate_map(crate_map: *u8, f: &fn(&mut ModEntry)) {\n+pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry)) {\n }\n \n #[cfg(not(stage0))]\n /// Iterates recursively over `crate_map` and all child crate maps\n-pub fn iter_crate_map(crate_map: &'static CrateMap, f: &fn(&mut ModEntry)) {\n+pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry)) {\n     // XXX: use random numbers as keys from the OS-level RNG when there is a nice\n     //        way to do this\n-    let mut v: HashSet<*CrateMap> = HashSet::with_capacity_and_keys(0, 0, 32);\n-    unsafe {\n-        do_iter_crate_map(transmute(crate_map), f, &mut v);\n-    }\n+    let mut v: HashSet<*CrateMap<'a>> = HashSet::with_capacity_and_keys(0, 0, 32);\n+    do_iter_crate_map(crate_map, f, &mut v);\n }\n \n #[cfg(test)]\n mod tests {\n     use c_str::ToCStr;\n     use cast::transmute;\n-    use ptr;\n-    use vec;\n-\n-    use rt::crate_map::{ModEntry, iter_crate_map};\n-\n-    struct CrateMap<'self> { \n-        version: i32,\n-        entries: *ModEntry,\n-        /// a dynamically sized struct, where all pointers to children are listed adjacent\n-        /// to the struct, terminated with NULL\n-        children: &'self [&'self CrateMap<'self>] \n-    }\n+    use rt::crate_map::{CrateMap, ModEntry, iter_crate_map};\n \n     #[test]\n     fn iter_crate_map_duplicates() {\n         unsafe {\n             let mod_name1 = \"c::m1\".to_c_str();\n             let mut level3: u32 = 3;\n \n-            let entries: ~[ModEntry] = ~[\n+            let entries = [\n                 ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level3},\n-                ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n             ];\n \n             let child_crate = CrateMap {\n                 version: 1,\n-                entries: vec::raw::to_ptr(entries),\n+                entries: entries,\n                 children: []\n             };\n \n             let root_crate = CrateMap {\n                 version: 1,\n-                entries: vec::raw::to_ptr([ModEntry { name: ptr::null(), log_level: ptr::mut_null()}]),\n+                entries: [],\n                 children: [&child_crate, &child_crate]\n             };\n \n@@ -206,29 +171,26 @@ mod tests {\n             let mut level3: u32 = 3;\n             let child_crate2 = CrateMap {\n                 version: 1,\n-                entries: vec::raw::to_ptr([\n+                entries: [\n                     ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level2},\n                     ModEntry { name: mod_name2.with_ref(|buf| buf), log_level: &mut level3},\n-                    ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n-                ]),\n+                ],\n                 children: []\n             };\n \n             let child_crate1 = CrateMap {\n                 version: 1,\n-                entries: vec::raw::to_ptr([\n+                entries: [\n                     ModEntry { name: \"t::f1\".to_c_str().with_ref(|buf| buf), log_level: &mut 1},\n-                    ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n-                ]),\n+                ],\n                 children: [&child_crate2]\n             };\n \n             let root_crate = CrateMap {\n                 version: 1,\n-                entries: vec::raw::to_ptr([\n+                entries: [\n                     ModEntry { name: \"t::f1\".to_c_str().with_ref(|buf| buf), log_level: &mut 0},\n-                    ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n-                ]),\n+                ],\n                 children: [&child_crate1]\n             };\n "}, {"sha": "8d85f72056e466819e81559b01b4213e8dab4fda", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ef4463b2a7d2c41fbc1072779951b445c80f95b/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef4463b2a7d2c41fbc1072779951b445c80f95b/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=9ef4463b2a7d2c41fbc1072779951b445c80f95b", "patch": "@@ -14,14 +14,12 @@ use libc::{uintptr_t, exit};\n use option::{Some, None, Option};\n use rt;\n use rt::util::dumb_println;\n-use rt::crate_map::{ModEntry, iter_crate_map};\n-use rt::crate_map::get_crate_map;\n+use rt::crate_map::{ModEntry, CrateMap, iter_crate_map, get_crate_map};\n use str::StrSlice;\n use str::raw::from_c_str;\n use u32;\n use vec::ImmutableVector;\n-use send_str::{SendStr, SendStrOwned, SendStrStatic};\n-use cast::transmute;\n+#[cfg(test)] use cast::transmute;\n \n struct LogDirective {\n     name: Option<~str>,\n@@ -111,7 +109,7 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n \n /// Set the log level of an entry in the crate map depending on the vector\n /// of log directives\n-fn update_entry(dirs: &[LogDirective], entry: &mut ModEntry) -> u32 {\n+fn update_entry(dirs: &[LogDirective], entry: &ModEntry) -> u32 {\n     let mut new_lvl: u32 = DEFAULT_LOG_LEVEL;\n     let mut longest_match = -1i;\n     unsafe {\n@@ -142,7 +140,7 @@ fn update_entry(dirs: &[LogDirective], entry: &mut ModEntry) -> u32 {\n #[fixed_stack_segment] #[inline(never)]\n /// Set log level for every entry in crate_map according to the sepecification\n /// in settings\n-fn update_log_settings(crate_map: *u8, settings: ~str) {\n+fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n     let mut dirs = ~[];\n     if settings.len() > 0 {\n         if settings == ~\"::help\" || settings == ~\"?\" {\n@@ -206,7 +204,7 @@ impl rt::io::Writer for StdErrLogger {\n pub fn init() {\n     use os;\n \n-    let crate_map = get_crate_map() as *u8;\n+    let crate_map = get_crate_map();\n \n     let log_spec = os::getenv(\"RUST_LOG\");\n     match log_spec {"}]}