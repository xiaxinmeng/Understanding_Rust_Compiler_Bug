{"sha": "b1df9aa16fe0f801f2f56afdddd6faa0461a3b0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZGY5YWExNmZlMGY4MDFmMmY1NmFmZGRkZDZmYWEwNDYxYTNiMGU=", "commit": {"author": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2014-06-18T14:33:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-19T00:01:58Z"}, "message": "Fix #14865\n\nFixes a codegen bug which generates illegal non-terminated LLVM block\nwhen there are wildcard pattern with guard and enum patterns in a match\nexpression. Also refactors the code a little.\n\nCloses #14865", "tree": {"sha": "9b76ba2687615b143b57ced16c2a3cc15e00313f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b76ba2687615b143b57ced16c2a3cc15e00313f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1df9aa16fe0f801f2f56afdddd6faa0461a3b0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1df9aa16fe0f801f2f56afdddd6faa0461a3b0e", "html_url": "https://github.com/rust-lang/rust/commit/b1df9aa16fe0f801f2f56afdddd6faa0461a3b0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1df9aa16fe0f801f2f56afdddd6faa0461a3b0e/comments", "author": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bde851e969d327397ac1ab4bca05692069ff62a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/bde851e969d327397ac1ab4bca05692069ff62a5", "html_url": "https://github.com/rust-lang/rust/commit/bde851e969d327397ac1ab4bca05692069ff62a5"}], "stats": {"total": 84, "additions": 42, "deletions": 42}, "files": [{"sha": "ffd29ffeb8fb42797b013d5430aea9bc402d6226", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 12, "deletions": 42, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b1df9aa16fe0f801f2f56afdddd6faa0461a3b0e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1df9aa16fe0f801f2f56afdddd6faa0461a3b0e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=b1df9aa16fe0f801f2f56afdddd6faa0461a3b0e", "patch": "@@ -518,8 +518,7 @@ fn enter_default<'a, 'b>(\n                  dm: &DefMap,\n                  m: &'a [Match<'a, 'b>],\n                  col: uint,\n-                 val: ValueRef,\n-                 chk: &FailureHandler)\n+                 val: ValueRef)\n                  -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n@@ -529,35 +528,13 @@ fn enter_default<'a, 'b>(\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n-    let matches = enter_match(bcx, dm, m, col, val, |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n           ast::PatWild | ast::PatWildMulti => Some(Vec::new()),\n           ast::PatIdent(_, _, None) if pat_is_binding(dm, &*p) => Some(Vec::new()),\n           _ => None\n         }\n-    });\n-\n-    // Ok, now, this is pretty subtle. A \"default\" match is a match\n-    // that needs to be considered if none of the actual checks on the\n-    // value being considered succeed. The subtlety lies in that sometimes\n-    // identifier/wildcard matches are *not* default matches. Consider:\n-    // \"match x { _ if something => foo, true => bar, false => baz }\".\n-    // There is a wildcard match, but it is *not* a default case. The boolean\n-    // case on the value being considered is exhaustive. If the case is\n-    // exhaustive, then there are no defaults.\n-    //\n-    // We detect whether the case is exhaustive in the following\n-    // somewhat kludgy way: if the last wildcard/binding match has a\n-    // guard, then by non-redundancy, we know that there aren't any\n-    // non guarded matches, and thus by exhaustiveness, we know that\n-    // we don't need any default cases. If the check *isn't* nonexhaustive\n-    // (because chk is Some), then we need the defaults anyways.\n-    let is_exhaustive = match matches.last() {\n-        Some(m) if m.data.arm.guard.is_some() && chk.is_infallible() => true,\n-        _ => false\n-    };\n-\n-    if is_exhaustive { Vec::new() } else { matches }\n+    })\n }\n \n // <pcwalton> nmatsakis: what does enter_opt do?\n@@ -1448,15 +1425,12 @@ fn compile_submatch<'a, 'b>(\n            m.repr(bcx.tcx()),\n            vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n     let _indenter = indenter();\n-\n-    /*\n-      For an empty match, a fall-through case must exist\n-     */\n-    assert!((m.len() > 0u || chk.is_fallible()));\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     if m.len() == 0u {\n-        Br(bcx, chk.handle_fail());\n+        if chk.is_fallible() {\n+            Br(bcx, chk.handle_fail());\n+        }\n         return;\n     }\n     if m[0].pats.len() == 0u {\n@@ -1658,7 +1632,7 @@ fn compile_submatch_continue<'a, 'b>(\n         C_int(ccx, 0) // Placeholder for when not using a switch\n     };\n \n-    let defaults = enter_default(else_cx, dm, m, col, val, chk);\n+    let defaults = enter_default(else_cx, dm, m, col, val);\n     let exhaustive = chk.is_infallible() && defaults.len() == 0u;\n     let len = opts.len();\n \n@@ -1947,18 +1921,14 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n \n     // `compile_submatch` works one column of arm patterns a time and\n     // then peels that column off. So as we progress, it may become\n-    // impossible to know whether we have a genuine default arm, i.e.\n+    // impossible to tell whether we have a genuine default arm, i.e.\n     // `_ => foo` or not. Sometimes it is important to know that in order\n     // to decide whether moving on to the next condition or falling back\n     // to the default arm.\n-    let has_default = arms.len() > 0 && {\n-        let ref pats = arms.last().unwrap().pats;\n-\n-        pats.len() == 1\n-        && match pats.last().unwrap().node {\n-            ast::PatWild => true, _ => false\n-        }\n-    };\n+    let has_default = arms.last().map_or(false, |arm| {\n+        arm.pats.len() == 1\n+        && arm.pats.last().unwrap().node == ast::PatWild\n+    });\n \n     compile_submatch(bcx, matches.as_slice(), [discr_datum.val], &chk, has_default);\n "}, {"sha": "7fa88a7653ac4179f91c185a828e88af5279526c", "filename": "src/test/run-pass/issue-14865.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b1df9aa16fe0f801f2f56afdddd6faa0461a3b0e/src%2Ftest%2Frun-pass%2Fissue-14865.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1df9aa16fe0f801f2f56afdddd6faa0461a3b0e/src%2Ftest%2Frun-pass%2Fissue-14865.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14865.rs?ref=b1df9aa16fe0f801f2f56afdddd6faa0461a3b0e", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum X {\n+    Foo(uint),\n+    Bar(bool)\n+}\n+\n+fn main() {\n+    let x = match Foo(42) {\n+        Foo(..) => 1,\n+        _ if true => 0,\n+        Bar(..) => fail!(\"Oh dear\")\n+    };\n+    assert_eq!(x, 1);\n+\n+    let x = match Foo(42) {\n+        _ if true => 0,\n+        Foo(..) => 1,\n+        Bar(..) => fail!(\"Oh dear\")\n+    };\n+    assert_eq!(x, 0);\n+}"}]}