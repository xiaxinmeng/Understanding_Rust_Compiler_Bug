{"sha": "3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYTYyZGQwZjZkM2M2MDlhNWQ1YWM2MWYwZTFmYzdjNjg2MWY2NmM=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-16T13:06:59Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-17T12:40:46Z"}, "message": "mir/borrowck: simplify common patterns", "tree": {"sha": "bcaad75b83df8433d4976bf3abe2ddeedf4ac918", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcaad75b83df8433d4976bf3abe2ddeedf4ac918"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c", "html_url": "https://github.com/rust-lang/rust/commit/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "html_url": "https://github.com/rust-lang/rust/commit/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7"}], "stats": {"total": 422, "additions": 203, "deletions": 219}, "files": [{"sha": "18cc1430c2a8ff8975bfc32e5b4a1ca647ee2fc9", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 44, "deletions": 48, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c", "patch": "@@ -244,7 +244,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             K: Clone + Eq + Hash,\n             V: Eq + Hash,\n         {\n-            map.entry(k.clone()).or_insert(FxHashSet()).insert(v);\n+            map.entry(k.clone()).or_default().insert(v);\n         }\n     }\n \n@@ -261,57 +261,53 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             // ... check whether we (earlier) saw a 2-phase borrow like\n             //\n             //     TMP = &mut place\n-            match self.pending_activations.get(temp) {\n-                Some(&borrow_index) => {\n-                    let borrow_data = &mut self.idx_vec[borrow_index];\n-\n-                    // Watch out: the use of TMP in the borrow itself\n-                    // doesn't count as an activation. =)\n-                    if borrow_data.reserve_location == location && context == PlaceContext::Store {\n-                        return;\n-                    }\n+            if let Some(&borrow_index) = self.pending_activations.get(temp) {\n+                let borrow_data = &mut self.idx_vec[borrow_index];\n \n-                    if let TwoPhaseActivation::ActivatedAt(other_location) =\n-                            borrow_data.activation_location {\n-                        span_bug!(\n-                            self.mir.source_info(location).span,\n-                            \"found two uses for 2-phase borrow temporary {:?}: \\\n-                             {:?} and {:?}\",\n-                            temp,\n-                            location,\n-                            other_location,\n-                        );\n-                    }\n+                // Watch out: the use of TMP in the borrow itself\n+                // doesn't count as an activation. =)\n+                if borrow_data.reserve_location == location && context == PlaceContext::Store {\n+                    return;\n+                }\n \n-                    // Otherwise, this is the unique later use\n-                    // that we expect.\n-                    borrow_data.activation_location = match context {\n-                        // The use of TMP in a shared borrow does not\n-                        // count as an actual activation.\n-                        PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. }\n-                        | PlaceContext::Borrow { kind: mir::BorrowKind::Shallow, .. } => {\n-                            TwoPhaseActivation::NotActivated\n-                        }\n-                        _ => {\n-                            // Double check: This borrow is indeed a two-phase borrow (that is,\n-                            // we are 'transitioning' from `NotActivated` to `ActivatedAt`) and\n-                            // we've not found any other activations (checked above).\n-                            assert_eq!(\n-                                borrow_data.activation_location,\n-                                TwoPhaseActivation::NotActivated,\n-                                \"never found an activation for this borrow!\",\n-                            );\n-\n-                            self.activation_map\n-                                .entry(location)\n-                                .or_default()\n-                                .push(borrow_index);\n-                            TwoPhaseActivation::ActivatedAt(location)\n-                        }\n-                    };\n+                if let TwoPhaseActivation::ActivatedAt(other_location) =\n+                        borrow_data.activation_location {\n+                    span_bug!(\n+                        self.mir.source_info(location).span,\n+                        \"found two uses for 2-phase borrow temporary {:?}: \\\n+                         {:?} and {:?}\",\n+                        temp,\n+                        location,\n+                        other_location,\n+                    );\n                 }\n \n-                None => {}\n+                // Otherwise, this is the unique later use\n+                // that we expect.\n+                borrow_data.activation_location = match context {\n+                    // The use of TMP in a shared borrow does not\n+                    // count as an actual activation.\n+                    PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. }\n+                    | PlaceContext::Borrow { kind: mir::BorrowKind::Shallow, .. } => {\n+                        TwoPhaseActivation::NotActivated\n+                    }\n+                    _ => {\n+                        // Double check: This borrow is indeed a two-phase borrow (that is,\n+                        // we are 'transitioning' from `NotActivated` to `ActivatedAt`) and\n+                        // we've not found any other activations (checked above).\n+                        assert_eq!(\n+                            borrow_data.activation_location,\n+                            TwoPhaseActivation::NotActivated,\n+                            \"never found an activation for this borrow!\",\n+                        );\n+\n+                        self.activation_map\n+                            .entry(location)\n+                            .or_default()\n+                            .push(borrow_index);\n+                        TwoPhaseActivation::ActivatedAt(location)\n+                    }\n+                };\n             }\n         }\n     }"}, {"sha": "8d5629270feea5dbd933244008403b3428d34c0e", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 155, "deletions": 166, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c", "patch": "@@ -188,11 +188,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         let tables = self.infcx.tcx.typeck_tables_of(id);\n                         let node_id = self.infcx.tcx.hir.as_local_node_id(id).unwrap();\n                         let hir_id = self.infcx.tcx.hir.node_to_hir_id(node_id);\n-                        if tables.closure_kind_origins().get(hir_id).is_some() {\n-                            false\n-                        } else {\n-                            true\n-                        }\n+\n+                        tables.closure_kind_origins().get(hir_id).is_none()\n                     }\n                     _ => true,\n                 };\n@@ -1366,191 +1363,184 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"annotate_argument_and_return_for_borrow: location={:?}\",\n             location\n         );\n-        match &self.mir[location.block]\n-            .statements\n-            .get(location.statement_index)\n+        if let Some(&Statement { kind: StatementKind::Assign(ref reservation, _), ..})\n+             = &self.mir[location.block].statements.get(location.statement_index)\n         {\n-            Some(&Statement {\n-                kind: StatementKind::Assign(ref reservation, _),\n-                ..\n-            }) => {\n+            debug!(\n+                \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n+                reservation\n+            );\n+            // Check that the initial assignment of the reserve location is into a temporary.\n+            let mut target = *match reservation {\n+                Place::Local(local) if self.mir.local_kind(*local) == LocalKind::Temp => local,\n+                _ => return None,\n+            };\n+\n+            // Next, look through the rest of the block, checking if we are assigning the\n+            // `target` (that is, the place that contains our borrow) to anything.\n+            let mut annotated_closure = None;\n+            for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n                 debug!(\n-                    \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n-                    reservation\n+                    \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n+                    target, stmt\n                 );\n-                // Check that the initial assignment of the reserve location is into a temporary.\n-                let mut target = *match reservation {\n-                    Place::Local(local) if self.mir.local_kind(*local) == LocalKind::Temp => local,\n-                    _ => return None,\n-                };\n-\n-                // Next, look through the rest of the block, checking if we are assigning the\n-                // `target` (that is, the place that contains our borrow) to anything.\n-                let mut annotated_closure = None;\n-                for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+                if let StatementKind::Assign(Place::Local(assigned_to), box rvalue) = &stmt.kind\n+                {\n                     debug!(\n-                        \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n-                        target, stmt\n+                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n+                         rvalue={:?}\",\n+                        assigned_to, rvalue\n                     );\n-                    if let StatementKind::Assign(Place::Local(assigned_to), box rvalue) = &stmt.kind\n+                    // Check if our `target` was captured by a closure.\n+                    if let Rvalue::Aggregate(\n+                        box AggregateKind::Closure(def_id, substs),\n+                        operands,\n+                    ) = rvalue\n                     {\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n-                             rvalue={:?}\",\n-                            assigned_to, rvalue\n-                        );\n-                        // Check if our `target` was captured by a closure.\n-                        if let Rvalue::Aggregate(\n-                            box AggregateKind::Closure(def_id, substs),\n-                            operands,\n-                        ) = rvalue\n-                        {\n-                            for operand in operands {\n-                                let assigned_from = match operand {\n-                                    Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                        assigned_from\n-                                    }\n-                                    _ => continue,\n-                                };\n-                                debug!(\n-                                    \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                        for operand in operands {\n+                            let assigned_from = match operand {\n+                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n                                     assigned_from\n-                                );\n-\n-                                // Find the local from the operand.\n-                                let assigned_from_local = match assigned_from.local() {\n-                                    Some(local) => local,\n-                                    None => continue,\n-                                };\n-\n-                                if assigned_from_local != target {\n-                                    continue;\n                                 }\n+                                _ => continue,\n+                            };\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                                assigned_from\n+                            );\n \n-                                // If a closure captured our `target` and then assigned\n-                                // into a place then we should annotate the closure in\n-                                // case it ends up being assigned into the return place.\n-                                annotated_closure = self.annotate_fn_sig(\n-                                    *def_id,\n-                                    self.infcx.closure_sig(*def_id, *substs),\n-                                );\n-                                debug!(\n-                                    \"annotate_argument_and_return_for_borrow: \\\n-                                     annotated_closure={:?} assigned_from_local={:?} \\\n-                                     assigned_to={:?}\",\n-                                    annotated_closure, assigned_from_local, assigned_to\n-                                );\n-\n-                                if *assigned_to == mir::RETURN_PLACE {\n-                                    // If it was assigned directly into the return place, then\n-                                    // return now.\n-                                    return annotated_closure;\n-                                } else {\n-                                    // Otherwise, update the target.\n-                                    target = *assigned_to;\n-                                }\n+                            // Find the local from the operand.\n+                            let assigned_from_local = match assigned_from.local() {\n+                                Some(local) => local,\n+                                None => continue,\n+                            };\n+\n+                            if assigned_from_local != target {\n+                                continue;\n                             }\n \n-                            // If none of our closure's operands matched, then skip to the next\n-                            // statement.\n-                            continue;\n+                            // If a closure captured our `target` and then assigned\n+                            // into a place then we should annotate the closure in\n+                            // case it ends up being assigned into the return place.\n+                            annotated_closure = self.annotate_fn_sig(\n+                                *def_id,\n+                                self.infcx.closure_sig(*def_id, *substs),\n+                            );\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: \\\n+                                 annotated_closure={:?} assigned_from_local={:?} \\\n+                                 assigned_to={:?}\",\n+                                annotated_closure, assigned_from_local, assigned_to\n+                            );\n+\n+                            if *assigned_to == mir::RETURN_PLACE {\n+                                // If it was assigned directly into the return place, then\n+                                // return now.\n+                                return annotated_closure;\n+                            } else {\n+                                // Otherwise, update the target.\n+                                target = *assigned_to;\n+                            }\n                         }\n \n-                        // Otherwise, look at other types of assignment.\n-                        let assigned_from = match rvalue {\n-                            Rvalue::Ref(_, _, assigned_from) => assigned_from,\n-                            Rvalue::Use(operand) => match operand {\n-                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                    assigned_from\n-                                }\n-                                _ => continue,\n-                            },\n-                            _ => continue,\n-                        };\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from={:?}\",\n-                            assigned_from,\n-                        );\n+                        // If none of our closure's operands matched, then skip to the next\n+                        // statement.\n+                        continue;\n+                    }\n \n-                        // Find the local from the rvalue.\n-                        let assigned_from_local = match assigned_from.local() {\n-                            Some(local) => local,\n-                            None => continue,\n-                        };\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from_local={:?}\",\n-                            assigned_from_local,\n-                        );\n+                    // Otherwise, look at other types of assignment.\n+                    let assigned_from = match rvalue {\n+                        Rvalue::Ref(_, _, assigned_from) => assigned_from,\n+                        Rvalue::Use(operand) => match operand {\n+                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                assigned_from\n+                            }\n+                            _ => continue,\n+                        },\n+                        _ => continue,\n+                    };\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from={:?}\",\n+                        assigned_from,\n+                    );\n \n-                        // Check if our local matches the target - if so, we've assigned our\n-                        // borrow to a new place.\n-                        if assigned_from_local != target {\n-                            continue;\n-                        }\n+                    // Find the local from the rvalue.\n+                    let assigned_from_local = match assigned_from.local() {\n+                        Some(local) => local,\n+                        None => continue,\n+                    };\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from_local={:?}\",\n+                        assigned_from_local,\n+                    );\n \n-                        // If we assigned our `target` into a new place, then we should\n-                        // check if it was the return place.\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from_local={:?} assigned_to={:?}\",\n-                            assigned_from_local, assigned_to\n-                        );\n-                        if *assigned_to == mir::RETURN_PLACE {\n-                            // If it was then return the annotated closure if there was one,\n-                            // else, annotate this function.\n-                            return annotated_closure.or_else(fallback);\n-                        }\n+                    // Check if our local matches the target - if so, we've assigned our\n+                    // borrow to a new place.\n+                    if assigned_from_local != target {\n+                        continue;\n+                    }\n \n-                        // If we didn't assign into the return place, then we just update\n-                        // the target.\n-                        target = *assigned_to;\n+                    // If we assigned our `target` into a new place, then we should\n+                    // check if it was the return place.\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from_local={:?} assigned_to={:?}\",\n+                        assigned_from_local, assigned_to\n+                    );\n+                    if *assigned_to == mir::RETURN_PLACE {\n+                        // If it was then return the annotated closure if there was one,\n+                        // else, annotate this function.\n+                        return annotated_closure.or_else(fallback);\n                     }\n+\n+                    // If we didn't assign into the return place, then we just update\n+                    // the target.\n+                    target = *assigned_to;\n                 }\n+            }\n \n-                // Check the terminator if we didn't find anything in the statements.\n-                let terminator = &self.mir[location.block].terminator();\n+            // Check the terminator if we didn't find anything in the statements.\n+            let terminator = &self.mir[location.block].terminator();\n+            debug!(\n+                \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n+                target, terminator\n+            );\n+            if let TerminatorKind::Call {\n+                destination: Some((Place::Local(assigned_to), _)),\n+                args,\n+                ..\n+            } = &terminator.kind\n+            {\n                 debug!(\n-                    \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n-                    target, terminator\n+                    \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n+                    assigned_to, args\n                 );\n-                if let TerminatorKind::Call {\n-                    destination: Some((Place::Local(assigned_to), _)),\n-                    args,\n-                    ..\n-                } = &terminator.kind\n-                {\n+                for operand in args {\n+                    let assigned_from = match operand {\n+                        Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                            assigned_from\n+                        }\n+                        _ => continue,\n+                    };\n                     debug!(\n-                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n-                        assigned_to, args\n+                        \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                        assigned_from,\n                     );\n-                    for operand in args {\n-                        let assigned_from = match operand {\n-                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                assigned_from\n-                            }\n-                            _ => continue,\n-                        };\n+\n+                    if let Some(assigned_from_local) = assigned_from.local() {\n                         debug!(\n-                            \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n-                            assigned_from,\n+                            \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n+                            assigned_from_local,\n                         );\n \n-                        if let Some(assigned_from_local) = assigned_from.local() {\n-                            debug!(\n-                                \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n-                                assigned_from_local,\n-                            );\n-\n-                            if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n-                                return annotated_closure.or_else(fallback);\n-                            }\n+                        if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n+                            return annotated_closure.or_else(fallback);\n                         }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n \n         // If we haven't found an assignment into the return place, then we need not add\n@@ -1605,13 +1595,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // Need to use the `rustc::ty` types to compare against the\n                             // `return_region`. Then use the `rustc::hir` type to get only\n                             // the lifetime span.\n-                            match &fn_decl.inputs[index].node {\n-                                hir::TyKind::Rptr(lifetime, _) => {\n-                                    // With access to the lifetime, we can get\n-                                    // the span of it.\n-                                    arguments.push((*argument, lifetime.span));\n-                                }\n-                                _ => bug!(\"ty type is a ref but hir type is not\"),\n+                            if let hir::TyKind::Rptr(lifetime, _) = &fn_decl.inputs[index].node {\n+                                // With access to the lifetime, we can get\n+                                // the span of it.\n+                                arguments.push((*argument, lifetime.span));\n+                            } else {\n+                                bug!(\"ty type is a ref but hir type is not\");\n                             }\n                         }\n                     }"}, {"sha": "59bb534881e33a64c2356d86db5a62653ed83da7", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c", "patch": "@@ -284,7 +284,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let temporary_used_locals: FxHashSet<Local> = mbcx\n         .used_mut\n         .iter()\n-        .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable.is_some())\n+        .filter(|&local| mbcx.mir.local_decls[*local].is_user_variable.is_none())\n         .cloned()\n         .collect();\n     mbcx.gather_used_muts(temporary_used_locals);\n@@ -342,7 +342,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         diag.buffer(&mut mbcx.errors_buffer);\n     }\n \n-    if mbcx.errors_buffer.len() > 0 {\n+    if !mbcx.errors_buffer.is_empty() {\n         mbcx.errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n \n         if tcx.migrate_borrowck() {\n@@ -2171,7 +2171,7 @@ impl ContextKind {\n     fn new(self, loc: Location) -> Context {\n         Context {\n             kind: self,\n-            loc: loc,\n+            loc,\n         }\n     }\n }"}, {"sha": "f0b4a5ac7435b2256bc0991e3ea3fb49004524e7", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=3ba62dd0f6d3c609a5d5ac61f0e1fc7c6861f66c", "patch": "@@ -408,7 +408,6 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             .map(|replacement| (pattern_span, replacement))\n                     }\n \n-                    //\n                     ClearCrossCrate::Set(mir::BindingForm::RefForGuard) => unreachable!(),\n \n                     ClearCrossCrate::Clear => bug!(\"saw cleared local state\"),\n@@ -573,7 +572,7 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n     opt_ty_info: Option<Span>,\n ) -> (Span, String) {\n     let locations = mir.find_assignments(local);\n-    if locations.len() > 0 {\n+    if !locations.is_empty() {\n         let assignment_rhs_span = mir.source_info(locations[0]).span;\n         if let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span) {\n             if let (true, Some(ws_pos)) = ("}]}