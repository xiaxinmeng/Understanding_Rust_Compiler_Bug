{"sha": "d77655e5c3c6c09bc968715b2b7a3db6224f7883", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NzY1NWU1YzNjNmMwOWJjOTY4NzE1YjJiN2EzZGI2MjI0Zjc4ODM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-24T15:19:27Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-24T15:19:27Z"}, "message": "Refine tail exit point highlighting to highlight inner tails", "tree": {"sha": "5b10d01f24e7ed6bad25c04d85ef937d1a70a8a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b10d01f24e7ed6bad25c04d85ef937d1a70a8a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d77655e5c3c6c09bc968715b2b7a3db6224f7883", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d77655e5c3c6c09bc968715b2b7a3db6224f7883", "html_url": "https://github.com/rust-lang/rust/commit/d77655e5c3c6c09bc968715b2b7a3db6224f7883", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d77655e5c3c6c09bc968715b2b7a3db6224f7883/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d049783b5d854ceea1dbdd2bd6ce129a95202c80", "url": "https://api.github.com/repos/rust-lang/rust/commits/d049783b5d854ceea1dbdd2bd6ce129a95202c80", "html_url": "https://github.com/rust-lang/rust/commit/d049783b5d854ceea1dbdd2bd6ce129a95202c80"}], "stats": {"total": 229, "additions": 178, "deletions": 51}, "files": [{"sha": "1c17d35110924550e65f533ab280a1c0a3d06db7", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 178, "deletions": 51, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/d77655e5c3c6c09bc968715b2b7a3db6224f7883/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77655e5c3c6c09bc968715b2b7a3db6224f7883/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=d77655e5c3c6c09bc968715b2b7a3db6224f7883", "patch": "@@ -6,7 +6,10 @@ use ide_db::{\n     search::{FileReference, ReferenceAccess, SearchScope},\n     RootDatabase,\n };\n-use syntax::{ast, match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, WalkEvent, T};\n+use syntax::{\n+    ast::{self, LoopBodyOwner},\n+    match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, WalkEvent, T,\n+};\n \n use crate::{display::TryToNav, references, NavigationTarget};\n \n@@ -83,43 +86,35 @@ fn highlight_exit_points(\n     ) -> Option<Vec<HighlightedRange>> {\n         let mut highlights = Vec::new();\n         let body = body?;\n-        walk(&body, &mut |expr| {\n-            match expr {\n-                ast::Expr::ReturnExpr(expr) => {\n-                    if let Some(token) = expr.return_token() {\n-                        highlights\n-                            .push(HighlightedRange { access: None, range: token.text_range() });\n-                    }\n-                }\n-                ast::Expr::TryExpr(try_) => {\n-                    if let Some(token) = try_.question_mark_token() {\n-                        highlights\n-                            .push(HighlightedRange { access: None, range: token.text_range() });\n-                    }\n+        walk(&body, &mut |expr| match expr {\n+            ast::Expr::ReturnExpr(expr) => {\n+                if let Some(token) = expr.return_token() {\n+                    highlights.push(HighlightedRange { access: None, range: token.text_range() });\n                 }\n-                ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroCall(_) => {\n-                    if sema.type_of_expr(&expr).map_or(false, |ty| ty.is_never()) {\n-                        highlights.push(HighlightedRange {\n-                            access: None,\n-                            range: expr.syntax().text_range(),\n-                        });\n-                    }\n+            }\n+            ast::Expr::TryExpr(try_) => {\n+                if let Some(token) = try_.question_mark_token() {\n+                    highlights.push(HighlightedRange { access: None, range: token.text_range() });\n                 }\n-                ast::Expr::EffectExpr(effect) => {\n-                    return effect.async_token().is_some() || effect.try_token().is_some()\n+            }\n+            ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroCall(_) => {\n+                if sema.type_of_expr(&expr).map_or(false, |ty| ty.is_never()) {\n+                    highlights\n+                        .push(HighlightedRange { access: None, range: expr.syntax().text_range() });\n                 }\n-                ast::Expr::ClosureExpr(_) => return true,\n-                _ => (),\n             }\n-            false\n+            _ => (),\n         });\n         let tail = match body {\n             ast::Expr::BlockExpr(b) => b.tail_expr(),\n             e => Some(e),\n         };\n \n         if let Some(tail) = tail {\n-            highlights.push(HighlightedRange { access: None, range: tail.syntax().text_range() })\n+            for_each_inner_tail(&tail, &mut |tail| {\n+                highlights\n+                    .push(HighlightedRange { access: None, range: tail.syntax().text_range() })\n+            });\n         }\n         Some(highlights)\n     }\n@@ -149,24 +144,12 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n         highlights.push(HighlightedRange { access: None, range: async_token?.text_range() });\n         if let Some(body) = body {\n             walk(&body, &mut |expr| {\n-                match expr {\n-                    ast::Expr::AwaitExpr(expr) => {\n-                        if let Some(token) = expr.await_token() {\n-                            highlights\n-                                .push(HighlightedRange { access: None, range: token.text_range() });\n-                        }\n-                    }\n-                    // All the following are different contexts so skip them\n-                    ast::Expr::EffectExpr(effect) => {\n-                        return matches!(\n-                            effect.effect(),\n-                            ast::Effect::Async(_) | ast::Effect::Try(_) | ast::Effect::Const(_)\n-                        )\n+                if let ast::Expr::AwaitExpr(expr) = expr {\n+                    if let Some(token) = expr.await_token() {\n+                        highlights\n+                            .push(HighlightedRange { access: None, range: token.text_range() });\n                     }\n-                    ast::Expr::ClosureExpr(__) => return true,\n-                    _ => (),\n                 }\n-                false\n             });\n         }\n         Some(highlights)\n@@ -184,33 +167,139 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n     None\n }\n \n-/// Preorder walk the expression node skipping a node's subtrees if the callback returns `true` for the node.\n-fn walk(expr: &ast::Expr, cb: &mut dyn FnMut(ast::Expr) -> bool) {\n+/// Preorder walk all the expression's child expressions\n+fn walk(expr: &ast::Expr, cb: &mut dyn FnMut(ast::Expr)) {\n     let mut preorder = expr.syntax().preorder();\n     while let Some(event) = preorder.next() {\n         let node = match event {\n             WalkEvent::Enter(node) => node,\n             WalkEvent::Leave(_) => continue,\n         };\n         match ast::Stmt::cast(node.clone()) {\n+            // recursively walk the initializer, skipping potential const pat expressions\n+            // lets statements aren't usually nested too deeply so this is fine to recurse on\n             Some(ast::Stmt::LetStmt(l)) => {\n                 if let Some(expr) = l.initializer() {\n                     walk(&expr, cb);\n                 }\n+                preorder.skip_subtree();\n             }\n-            // Don't skip subtree since we want to process the expression behind this next\n-            Some(ast::Stmt::ExprStmt(_)) => continue,\n+            // Don't skip subtree since we want to process the expression child next\n+            Some(ast::Stmt::ExprStmt(_)) => (),\n             // skip inner items which might have their own expressions\n-            Some(ast::Stmt::Item(_)) => (),\n+            Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n             None => {\n                 if let Some(expr) = ast::Expr::cast(node) {\n-                    if !cb(expr) {\n-                        continue;\n+                    let is_different_context = match &expr {\n+                        ast::Expr::EffectExpr(effect) => {\n+                            matches!(\n+                                effect.effect(),\n+                                ast::Effect::Async(_) | ast::Effect::Try(_) | ast::Effect::Const(_)\n+                            )\n+                        }\n+                        ast::Expr::ClosureExpr(__) => true,\n+                        _ => false,\n+                    };\n+                    cb(expr);\n+                    if is_different_context {\n+                        preorder.skip_subtree();\n                     }\n+                } else {\n+                    preorder.skip_subtree();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// FIXME: doesn't account for labeled breaks in labeled blocks\n+fn for_each_inner_tail(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n+    match expr {\n+        ast::Expr::BlockExpr(b) => {\n+            if let Some(e) = b.tail_expr() {\n+                for_each_inner_tail(&e, cb);\n+            }\n+        }\n+        ast::Expr::EffectExpr(e) => match e.effect() {\n+            ast::Effect::Label(_) | ast::Effect::Unsafe(_) => {\n+                if let Some(e) = e.block_expr().and_then(|b| b.tail_expr()) {\n+                    for_each_inner_tail(&e, cb);\n                 }\n             }\n+            ast::Effect::Async(_) | ast::Effect::Try(_) | ast::Effect::Const(_) => cb(expr),\n+        },\n+        ast::Expr::IfExpr(if_) => {\n+            if_.blocks().for_each(|block| for_each_inner_tail(&ast::Expr::BlockExpr(block), cb))\n+        }\n+        ast::Expr::LoopExpr(l) => for_each_break(l, cb),\n+        ast::Expr::MatchExpr(m) => {\n+            if let Some(arms) = m.match_arm_list() {\n+                arms.arms().filter_map(|arm| arm.expr()).for_each(|e| for_each_inner_tail(&e, cb));\n+            }\n+        }\n+        ast::Expr::ArrayExpr(_)\n+        | ast::Expr::AwaitExpr(_)\n+        | ast::Expr::BinExpr(_)\n+        | ast::Expr::BoxExpr(_)\n+        | ast::Expr::BreakExpr(_)\n+        | ast::Expr::CallExpr(_)\n+        | ast::Expr::CastExpr(_)\n+        | ast::Expr::ClosureExpr(_)\n+        | ast::Expr::ContinueExpr(_)\n+        | ast::Expr::FieldExpr(_)\n+        | ast::Expr::ForExpr(_)\n+        | ast::Expr::IndexExpr(_)\n+        | ast::Expr::Literal(_)\n+        | ast::Expr::MacroCall(_)\n+        | ast::Expr::MacroStmts(_)\n+        | ast::Expr::MethodCallExpr(_)\n+        | ast::Expr::ParenExpr(_)\n+        | ast::Expr::PathExpr(_)\n+        | ast::Expr::PrefixExpr(_)\n+        | ast::Expr::RangeExpr(_)\n+        | ast::Expr::RecordExpr(_)\n+        | ast::Expr::RefExpr(_)\n+        | ast::Expr::ReturnExpr(_)\n+        | ast::Expr::TryExpr(_)\n+        | ast::Expr::TupleExpr(_)\n+        | ast::Expr::WhileExpr(_)\n+        | ast::Expr::YieldExpr(_) => cb(expr),\n+    }\n+}\n+\n+fn for_each_break(l: &ast::LoopExpr, cb: &mut dyn FnMut(&ast::Expr)) {\n+    let label = l.label().and_then(|lbl| lbl.lifetime());\n+    let mut depth = 0;\n+    if let Some(b) = l.loop_body() {\n+        let preorder = &mut b.syntax().preorder();\n+        let ev_as_expr = |ev| match ev {\n+            WalkEvent::Enter(it) => Some(WalkEvent::Enter(ast::Expr::cast(it)?)),\n+            WalkEvent::Leave(it) => Some(WalkEvent::Leave(ast::Expr::cast(it)?)),\n+        };\n+        let eq_label = |lt: Option<ast::Lifetime>| {\n+            lt.zip(label.as_ref()).map_or(false, |(lt, lbl)| lt.text() == lbl.text())\n+        };\n+        while let Some(node) = preorder.find_map(ev_as_expr) {\n+            match node {\n+                WalkEvent::Enter(expr) => match &expr {\n+                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n+                        depth += 1\n+                    }\n+                    ast::Expr::EffectExpr(e) if e.label().is_some() => depth += 1,\n+                    ast::Expr::BreakExpr(b) if depth == 0 || eq_label(b.lifetime()) => {\n+                        cb(&expr);\n+                    }\n+                    _ => (),\n+                },\n+                WalkEvent::Leave(expr) => match expr {\n+                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n+                        depth -= 1\n+                    }\n+                    ast::Expr::EffectExpr(e) if e.label().is_some() => depth -= 1,\n+                    _ => (),\n+                },\n+            }\n         }\n-        preorder.skip_subtree();\n     }\n }\n \n@@ -453,6 +542,44 @@ fn foo() ->$0 u32 {\n     0\n  // ^\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_inner_tail_exit_points() {\n+        check(\n+            r#\"\n+fn foo() ->$0 u32 {\n+    if true {\n+        unsafe {\n+            return 5;\n+         // ^^^^^^\n+            5\n+         // ^\n+        }\n+    } else {\n+        match 5 {\n+            6 => 100,\n+              // ^^^\n+            7 => loop {\n+                break 5;\n+             // ^^^^^^^\n+            }\n+            8 => 'a: loop {\n+                'b: loop {\n+                    break 'a 5;\n+                 // ^^^^^^^^^^\n+                    break 'b 5;\n+                    break 5;\n+                };\n+            }\n+            //\n+            _ => 500,\n+              // ^^^\n+        }\n+    }\n+}\n \"#,\n         );\n     }"}]}