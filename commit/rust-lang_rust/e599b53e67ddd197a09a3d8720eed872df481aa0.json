{"sha": "e599b53e67ddd197a09a3d8720eed872df481aa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1OTliNTNlNjdkZGQxOTdhMDlhM2Q4NzIwZWVkODcyZGY0ODFhYTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-24T17:22:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-24T17:22:56Z"}, "message": "Auto merge of #76918 - ishitatsuyuki:match-fastpath, r=oli-obk\n\nAdd fast path for match checking\n\nThis adds a fast path that would reduce the complexity to linear on matches consisting of only variant patterns (i.e. enum matches). (Also see: #7462) Unfortunately, I was too lazy to add a similar fast path for constants (mostly for integer matches), ideally that could be added another day.\n\nTBH, I'm not confident with the performance claims due to the fact that enums tends to be small and FxHashMap could add a lot of overhead.\n\nr? `@Mark-Simulacrum`\n\nneeds perf", "tree": {"sha": "a5deae8ca8ba28df94090e141d4175703153ca32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5deae8ca8ba28df94090e141d4175703153ca32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e599b53e67ddd197a09a3d8720eed872df481aa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e599b53e67ddd197a09a3d8720eed872df481aa0", "html_url": "https://github.com/rust-lang/rust/commit/e599b53e67ddd197a09a3d8720eed872df481aa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e599b53e67ddd197a09a3d8720eed872df481aa0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87d262acb50200d767baa7115f30c650a13672ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/87d262acb50200d767baa7115f30c650a13672ee", "html_url": "https://github.com/rust-lang/rust/commit/87d262acb50200d767baa7115f30c650a13672ee"}, {"sha": "01a771a7d8c16fc344152525e6fe16b3b72de57a", "url": "https://api.github.com/repos/rust-lang/rust/commits/01a771a7d8c16fc344152525e6fe16b3b72de57a", "html_url": "https://github.com/rust-lang/rust/commit/01a771a7d8c16fc344152525e6fe16b3b72de57a"}], "stats": {"total": 187, "additions": 165, "deletions": 22}, "files": [{"sha": "904524e13ae086c83a0305ec4435839a0add30f6", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 161, "deletions": 18, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/e599b53e67ddd197a09a3d8720eed872df481aa0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e599b53e67ddd197a09a3d8720eed872df481aa0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=e599b53e67ddd197a09a3d8720eed872df481aa0", "patch": "@@ -139,10 +139,10 @@\n //!\n //!    It is computed as follows. We look at the pattern `p_1` on top of the stack,\n //!    and we have three cases:\n-//!         1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-//!         1.2. `p_1 = _`. We return the rest of the stack:\n+//!         2.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+//!         2.2. `p_1 = _`. We return the rest of the stack:\n //!                 p_2, .., p_n\n-//!         1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!         2.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n //!           stack.\n //!                 D((r_1, p_2, .., p_n))\n //!                 D((r_2, p_2, .., p_n))\n@@ -276,7 +276,7 @@ use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::Idx;\n \n use super::{compare_const_vals, PatternFoldable, PatternFolder};\n@@ -416,7 +416,7 @@ impl<'tcx> Pat<'tcx> {\n \n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n /// works well.\n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, PartialEq)]\n crate struct PatStack<'p, 'tcx>(SmallVec<[&'p Pat<'tcx>; 2]>);\n \n impl<'p, 'tcx> PatStack<'p, 'tcx> {\n@@ -504,13 +504,36 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n     }\n }\n \n+/// Depending on the match patterns, the specialization process might be able to use a fast path.\n+/// Tracks whether we can use the fast path and the lookup table needed in those cases.\n+#[derive(Clone, Debug, PartialEq)]\n+enum SpecializationCache {\n+    /// Patterns consist of only enum variants.\n+    /// Variant patterns does not intersect with each other (in contrast to range patterns),\n+    /// so it is possible to precompute the result of `Matrix::specialize_constructor` at a\n+    /// lower computational complexity.\n+    /// `lookup` is responsible for holding the precomputed result of\n+    /// `Matrix::specialize_constructor`, while `wilds` is used for two purposes: the first one is\n+    /// the precomputed result of `Matrix::specialize_wildcard`, and the second is to be used as a\n+    /// fallback for `Matrix::specialize_constructor` when it tries to apply a constructor that\n+    /// has not been seen in the `Matrix`. See `update_cache` for further explanations.\n+    Variants { lookup: FxHashMap<DefId, SmallVec<[usize; 1]>>, wilds: SmallVec<[usize; 1]> },\n+    /// Does not belong to the cases above, use the slow path.\n+    Incompatible,\n+}\n+\n /// A 2D matrix.\n-#[derive(Clone)]\n-crate struct Matrix<'p, 'tcx>(Vec<PatStack<'p, 'tcx>>);\n+#[derive(Clone, PartialEq)]\n+crate struct Matrix<'p, 'tcx> {\n+    patterns: Vec<PatStack<'p, 'tcx>>,\n+    cache: SpecializationCache,\n+}\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     crate fn empty() -> Self {\n-        Matrix(vec![])\n+        // Use `SpecializationCache::Incompatible` as a placeholder; we will initialize it on the\n+        // first call to `push`. See the first half of `update_cache`.\n+        Matrix { patterns: vec![], cache: SpecializationCache::Incompatible }\n     }\n \n     /// Pushes a new row to the matrix. If the row starts with an or-pattern, this expands it.\n@@ -522,18 +545,101 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                 self.push(row)\n             }\n         } else {\n-            self.0.push(row);\n+            self.patterns.push(row);\n+            self.update_cache(self.patterns.len() - 1);\n+        }\n+    }\n+\n+    fn update_cache(&mut self, idx: usize) {\n+        let row = &self.patterns[idx];\n+        // We don't know which kind of cache could be used until we see the first row; therefore an\n+        // empty `Matrix` is initialized with `SpecializationCache::Empty`, then the cache is\n+        // assigned the appropriate variant below on the first call to `push`.\n+        if self.patterns.is_empty() {\n+            self.cache = if row.is_empty() {\n+                SpecializationCache::Incompatible\n+            } else {\n+                match *row.head().kind {\n+                    PatKind::Variant { .. } => SpecializationCache::Variants {\n+                        lookup: FxHashMap::default(),\n+                        wilds: SmallVec::new(),\n+                    },\n+                    // Note: If the first pattern is a wildcard, then all patterns after that is not\n+                    // useful. The check is simple enough so we treat it as the same as unsupported\n+                    // patterns.\n+                    _ => SpecializationCache::Incompatible,\n+                }\n+            };\n+        }\n+        // Update the cache.\n+        match &mut self.cache {\n+            SpecializationCache::Variants { ref mut lookup, ref mut wilds } => {\n+                let head = row.head();\n+                match *head.kind {\n+                    _ if head.is_wildcard() => {\n+                        // Per rule 1.3 in the top-level comments, a wildcard pattern is included in\n+                        // the result of `specialize_constructor` for *any* `Constructor`.\n+                        // We push the wildcard pattern to the precomputed result for constructors\n+                        // that we have seen before; results for constructors we have not yet seen\n+                        // defaults to `wilds`, which is updated right below.\n+                        for (_, v) in lookup.iter_mut() {\n+                            v.push(idx);\n+                        }\n+                        // Per rule 2.1 and 2.2 in the top-level comments, only wildcard patterns\n+                        // are included in the result of `specialize_wildcard`.\n+                        // What we do here is to track the wildcards we have seen; so in addition to\n+                        // acting as the precomputed result of `specialize_wildcard`, `wilds` also\n+                        // serves as the default value of `specialize_constructor` for constructors\n+                        // that are not in `lookup`.\n+                        wilds.push(idx);\n+                    }\n+                    PatKind::Variant { adt_def, variant_index, .. } => {\n+                        // Handle the cases of rule 1.1 and 1.2 in the top-level comments.\n+                        // A variant pattern can only be included in the results of\n+                        // `specialize_constructor` for a particular constructor, therefore we are\n+                        // using a HashMap to track that.\n+                        lookup\n+                            .entry(adt_def.variants[variant_index].def_id)\n+                            // Default to `wilds` for absent keys. See above for an explanation.\n+                            .or_insert_with(|| wilds.clone())\n+                            .push(idx);\n+                    }\n+                    _ => {\n+                        self.cache = SpecializationCache::Incompatible;\n+                    }\n+                }\n+            }\n+            SpecializationCache::Incompatible => {}\n         }\n     }\n \n     /// Iterate over the first component of each row\n     fn heads<'a>(&'a self) -> impl Iterator<Item = &'a Pat<'tcx>> + Captures<'p> {\n-        self.0.iter().map(|r| r.head())\n+        self.patterns.iter().map(|r| r.head())\n     }\n \n     /// This computes `D(self)`. See top of the file for explanations.\n     fn specialize_wildcard(&self) -> Self {\n-        self.0.iter().filter_map(|r| r.specialize_wildcard()).collect()\n+        match &self.cache {\n+            SpecializationCache::Variants { wilds, .. } => {\n+                let result =\n+                    wilds.iter().filter_map(|&i| self.patterns[i].specialize_wildcard()).collect();\n+                // When debug assertions are enabled, check the results against the \"slow path\"\n+                // result.\n+                debug_assert_eq!(\n+                    result,\n+                    Self {\n+                        patterns: self.patterns.clone(),\n+                        cache: SpecializationCache::Incompatible\n+                    }\n+                    .specialize_wildcard()\n+                );\n+                result\n+            }\n+            SpecializationCache::Incompatible => {\n+                self.patterns.iter().filter_map(|r| r.specialize_wildcard()).collect()\n+            }\n+        }\n     }\n \n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n@@ -543,10 +649,47 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         constructor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Matrix<'p, 'tcx> {\n-        self.0\n-            .iter()\n-            .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n-            .collect()\n+        match &self.cache {\n+            SpecializationCache::Variants { lookup, wilds } => {\n+                let result: Self = if let Constructor::Variant(id) = constructor {\n+                    lookup\n+                        .get(id)\n+                        // Default to `wilds` for absent keys. See `update_cache` for an explanation.\n+                        .unwrap_or(&wilds)\n+                        .iter()\n+                        .filter_map(|&i| {\n+                            self.patterns[i].specialize_constructor(\n+                                cx,\n+                                constructor,\n+                                ctor_wild_subpatterns,\n+                            )\n+                        })\n+                        .collect()\n+                } else {\n+                    unreachable!()\n+                };\n+                // When debug assertions are enabled, check the results against the \"slow path\"\n+                // result.\n+                debug_assert_eq!(\n+                    result,\n+                    Matrix {\n+                        patterns: self.patterns.clone(),\n+                        cache: SpecializationCache::Incompatible\n+                    }\n+                    .specialize_constructor(\n+                        cx,\n+                        constructor,\n+                        ctor_wild_subpatterns\n+                    )\n+                );\n+                result\n+            }\n+            SpecializationCache::Incompatible => self\n+                .patterns\n+                .iter()\n+                .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n+                .collect(),\n+        }\n     }\n }\n \n@@ -568,7 +711,7 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"\\n\")?;\n \n-        let &Matrix(ref m) = self;\n+        let Matrix { patterns: m, .. } = self;\n         let pretty_printed_matrix: Vec<Vec<String>> =\n             m.iter().map(|row| row.iter().map(|pat| format!(\"{:?}\", pat)).collect()).collect();\n \n@@ -1824,7 +1967,7 @@ crate fn is_useful<'p, 'tcx>(\n     is_under_guard: bool,\n     is_top_level: bool,\n ) -> Usefulness<'tcx> {\n-    let &Matrix(ref rows) = matrix;\n+    let Matrix { patterns: rows, .. } = matrix;\n     debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n \n     // The base case. We are pattern-matching on () and the return value is\n@@ -2266,7 +2409,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 // `borders` is the set of borders between equivalence classes: each equivalence\n                 // class lies between 2 borders.\n                 let row_borders = matrix\n-                    .0\n+                    .patterns\n                     .iter()\n                     .flat_map(|row| {\n                         IntRange::from_pat(tcx, param_env, row.head()).map(|r| (r, row.len()))"}, {"sha": "718ed78889f09b95677871029f0f60a8e0112ba8", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e599b53e67ddd197a09a3d8720eed872df481aa0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e599b53e67ddd197a09a3d8720eed872df481aa0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=e599b53e67ddd197a09a3d8720eed872df481aa0", "patch": "@@ -39,19 +39,19 @@ crate enum PatternError {\n     NonConstPath(Span),\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n crate enum BindingMode {\n     ByValue,\n     ByRef(BorrowKind),\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq)]\n crate struct FieldPat<'tcx> {\n     crate field: Field,\n     crate pattern: Pat<'tcx>,\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq)]\n crate struct Pat<'tcx> {\n     crate ty: Ty<'tcx>,\n     crate span: Span,\n@@ -116,7 +116,7 @@ crate struct Ascription<'tcx> {\n     crate user_ty_span: Span,\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq)]\n crate enum PatKind<'tcx> {\n     Wild,\n "}]}