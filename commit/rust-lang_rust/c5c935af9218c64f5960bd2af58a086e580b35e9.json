{"sha": "c5c935af9218c64f5960bd2af58a086e580b35e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YzkzNWFmOTIxOGM2NGY1OTYwYmQyYWY1OGEwODZlNTgwYjM1ZTk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-16T19:52:28Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-30T16:10:07Z"}, "message": "Simplify tracking the encoder state.", "tree": {"sha": "5be770d84d0bf1d68c927126eea3bc4e76718c39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5be770d84d0bf1d68c927126eea3bc4e76718c39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5c935af9218c64f5960bd2af58a086e580b35e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5c935af9218c64f5960bd2af58a086e580b35e9", "html_url": "https://github.com/rust-lang/rust/commit/c5c935af9218c64f5960bd2af58a086e580b35e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5c935af9218c64f5960bd2af58a086e580b35e9/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1c99e5fccdd97e7b78e364c3e408f535994e23c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1c99e5fccdd97e7b78e364c3e408f535994e23c", "html_url": "https://github.com/rust-lang/rust/commit/e1c99e5fccdd97e7b78e364c3e408f535994e23c"}], "stats": {"total": 152, "additions": 72, "deletions": 80}, "files": [{"sha": "ab97222e19abadc5d17eb8c0f990a1e4a06699df", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 72, "deletions": 80, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/c5c935af9218c64f5960bd2af58a086e580b35e9/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5c935af9218c64f5960bd2af58a086e580b35e9/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=c5c935af9218c64f5960bd2af58a086e580b35e9", "patch": "@@ -4,7 +4,7 @@ use super::query::DepGraphQuery;\n use super::{DepKind, DepNode, DepNodeIndex};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_data_structures::sync::Lock;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_serialize::opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize};\n use rustc_serialize::{Decodable, Decoder, Encodable};\n@@ -125,66 +125,80 @@ struct Stat<K: DepKind> {\n     edge_counter: u64,\n }\n \n-struct Stats<K: DepKind> {\n-    stats: FxHashMap<K, Stat<K>>,\n+struct EncodingStatus<K: DepKind> {\n+    encoder: FileEncoder,\n     total_node_count: usize,\n     total_edge_count: usize,\n+    result: FileEncodeResult,\n+    stats: Option<FxHashMap<K, Stat<K>>>,\n }\n \n-#[instrument(skip(encoder, _record_graph, record_stats))]\n-fn encode_node<K: DepKind>(\n-    encoder: &mut FileEncoder,\n-    _index: DepNodeIndex,\n-    node: &NodeInfo<K>,\n-    _record_graph: &Option<Lrc<Lock<DepGraphQuery<K>>>>,\n-    record_stats: &Option<Lrc<Lock<Stats<K>>>>,\n-) -> FileEncodeResult {\n-    #[cfg(debug_assertions)]\n-    if let Some(record_graph) = &_record_graph {\n-        // Do not ICE when a query is called from within `with_query`.\n-        if let Some(record_graph) = &mut record_graph.try_lock() {\n-            record_graph.push(_index, node.node, &node.edges);\n+impl<K: DepKind> EncodingStatus<K> {\n+    fn new(encoder: FileEncoder, record_stats: bool) -> Self {\n+        Self {\n+            encoder,\n+            total_edge_count: 0,\n+            total_node_count: 0,\n+            result: Ok(()),\n+            stats: if record_stats { Some(FxHashMap::default()) } else { None },\n         }\n     }\n \n-    if let Some(record_stats) = &record_stats {\n-        let mut stats = record_stats.lock();\n-        let kind = node.node.kind;\n+    #[instrument(skip(self, _record_graph))]\n+    fn encode_node(\n+        &mut self,\n+        node: &NodeInfo<K>,\n+        _record_graph: &Option<Lock<DepGraphQuery<K>>>,\n+    ) -> DepNodeIndex {\n+        let index = DepNodeIndex::new(self.total_node_count);\n+        self.total_node_count += 1;\n+\n         let edge_count = node.edges.len();\n+        self.total_edge_count += edge_count;\n+\n+        #[cfg(debug_assertions)]\n+        if let Some(record_graph) = &_record_graph {\n+            // Do not ICE when a query is called from within `with_query`.\n+            if let Some(record_graph) = &mut record_graph.try_lock() {\n+                record_graph.push(index, node.node, &node.edges);\n+            }\n+        }\n+\n+        if let Some(stats) = &mut self.stats {\n+            let kind = node.node.kind;\n \n-        let stat =\n-            stats.stats.entry(kind).or_insert(Stat { kind, node_counter: 0, edge_counter: 0 });\n-        stat.node_counter += 1;\n-        stat.edge_counter += edge_count as u64;\n-        stats.total_node_count += 1;\n-        stats.total_edge_count += edge_count;\n+            let stat = stats.entry(kind).or_insert(Stat { kind, node_counter: 0, edge_counter: 0 });\n+            stat.node_counter += 1;\n+            stat.edge_counter += edge_count as u64;\n+        }\n+\n+        debug!(?index, ?node);\n+        let encoder = &mut self.encoder;\n+        self.result =\n+            std::mem::replace(&mut self.result, Ok(())).and_then(|()| node.encode(encoder));\n+        index\n     }\n \n-    debug!(?_index, ?node);\n-    node.encode(encoder)\n-}\n+    fn finish(self) -> FileEncodeResult {\n+        let Self { mut encoder, total_node_count, total_edge_count, result, stats: _ } = self;\n+        let () = result?;\n \n-fn encode_counts(\n-    mut encoder: FileEncoder,\n-    node_count: usize,\n-    edge_count: usize,\n-) -> FileEncodeResult {\n-    let node_count = node_count.try_into().unwrap();\n-    let edge_count = edge_count.try_into().unwrap();\n-\n-    debug!(?node_count, ?edge_count);\n-    debug!(\"position: {:?}\", encoder.position());\n-    IntEncodedWithFixedSize(node_count).encode(&mut encoder)?;\n-    IntEncodedWithFixedSize(edge_count).encode(&mut encoder)?;\n-    debug!(\"position: {:?}\", encoder.position());\n-    // Drop the encoder so that nothing is written after the counts.\n-    encoder.flush()\n+        let node_count = total_node_count.try_into().unwrap();\n+        let edge_count = total_edge_count.try_into().unwrap();\n+\n+        debug!(?node_count, ?edge_count);\n+        debug!(\"position: {:?}\", encoder.position());\n+        IntEncodedWithFixedSize(node_count).encode(&mut encoder)?;\n+        IntEncodedWithFixedSize(edge_count).encode(&mut encoder)?;\n+        debug!(\"position: {:?}\", encoder.position());\n+        // Drop the encoder so that nothing is written after the counts.\n+        encoder.flush()\n+    }\n }\n \n pub struct GraphEncoder<K: DepKind> {\n-    status: Lock<(FileEncoder, DepNodeIndex, usize, FileEncodeResult)>,\n-    record_graph: Option<Lrc<Lock<DepGraphQuery<K>>>>,\n-    record_stats: Option<Lrc<Lock<Stats<K>>>>,\n+    status: Lock<EncodingStatus<K>>,\n+    record_graph: Option<Lock<DepGraphQuery<K>>>,\n }\n \n impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n@@ -195,21 +209,12 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n         record_stats: bool,\n     ) -> Self {\n         let record_graph = if cfg!(debug_assertions) && record_graph {\n-            Some(Lrc::new(Lock::new(DepGraphQuery::new(prev_node_count))))\n-        } else {\n-            None\n-        };\n-        let record_stats = if record_stats {\n-            Some(Lrc::new(Lock::new(Stats {\n-                stats: FxHashMap::default(),\n-                total_node_count: 0,\n-                total_edge_count: 0,\n-            })))\n+            Some(Lock::new(DepGraphQuery::new(prev_node_count)))\n         } else {\n             None\n         };\n-        let status = Lock::new((encoder, DepNodeIndex::new(0), 0, Ok(())));\n-        GraphEncoder { status, record_graph, record_stats }\n+        let status = Lock::new(EncodingStatus::new(encoder, record_stats));\n+        GraphEncoder { status, record_graph }\n     }\n \n     pub(crate) fn with_query(&self, f: impl Fn(&DepGraphQuery<K>)) {\n@@ -223,10 +228,9 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n         total_read_count: u64,\n         total_duplicate_read_count: u64,\n     ) {\n-        if let Some(record_stats) = &self.record_stats {\n-            let record_stats = record_stats.lock();\n-\n-            let mut stats: Vec<_> = record_stats.stats.values().collect();\n+        let status = self.status.lock();\n+        if let Some(record_stats) = &status.stats {\n+            let mut stats: Vec<_> = record_stats.values().collect();\n             stats.sort_by_key(|s| -(s.node_counter as i64));\n \n             const SEPARATOR: &str = \"[incremental] --------------------------------\\\n@@ -237,8 +241,8 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n             eprintln!(\"[incremental] DepGraph Statistics\");\n             eprintln!(\"{}\", SEPARATOR);\n             eprintln!(\"[incremental]\");\n-            eprintln!(\"[incremental] Total Node Count: {}\", record_stats.total_node_count);\n-            eprintln!(\"[incremental] Total Edge Count: {}\", record_stats.total_edge_count);\n+            eprintln!(\"[incremental] Total Node Count: {}\", status.total_node_count);\n+            eprintln!(\"[incremental] Total Edge Count: {}\", status.total_edge_count);\n \n             if cfg!(debug_assertions) {\n                 eprintln!(\"[incremental] Total Edge Reads: {}\", total_read_count);\n@@ -257,7 +261,7 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n \n             for stat in stats {\n                 let node_kind_ratio =\n-                    (100.0 * (stat.node_counter as f64)) / (record_stats.total_node_count as f64);\n+                    (100.0 * (stat.node_counter as f64)) / (status.total_node_count as f64);\n                 let node_kind_avg_edges = (stat.edge_counter as f64) / (stat.node_counter as f64);\n \n                 eprintln!(\n@@ -280,23 +284,11 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n         fingerprint: Fingerprint,\n         edges: SmallVec<[DepNodeIndex; 8]>,\n     ) -> DepNodeIndex {\n-        let &mut (ref mut encoder, ref mut next_index, ref mut edge_count, ref mut result) =\n-            &mut *self.status.lock();\n-        let index = next_index.clone();\n-        next_index.increment_by(1);\n-        *edge_count += edges.len();\n-        *result = std::mem::replace(result, Ok(())).and_then(|()| {\n-            let node = NodeInfo { node, fingerprint, edges };\n-            encode_node(encoder, index, &node, &self.record_graph, &self.record_stats)\n-        });\n-        index\n+        let node = NodeInfo { node, fingerprint, edges };\n+        self.status.lock().encode_node(&node, &self.record_graph)\n     }\n \n     pub fn finish(self) -> FileEncodeResult {\n-        let (encoder, node_count, edge_count, result) = self.status.into_inner();\n-        let () = result?;\n-        let node_count = node_count.index();\n-\n-        encode_counts(encoder, node_count, edge_count)\n+        self.status.into_inner().finish()\n     }\n }"}]}