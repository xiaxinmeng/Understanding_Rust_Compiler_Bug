{"sha": "7c3f0d6f30eeefa58170012df10008736ac89755", "node_id": "C_kwDOAAsO6NoAKDdjM2YwZDZmMzBlZWVmYTU4MTcwMDEyZGYxMDAwODczNmFjODk3NTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-06T02:09:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-06T02:09:00Z"}, "message": "Auto merge of #107141 - notriddle:notriddle/max-lev-distance-2023, r=GuillaumeGomez\n\nrustdoc: compute maximum Levenshtein distance based on the query\n\nPreview: https://notriddle.com/notriddle-rustdoc-demos/search-lev-distance-2023/std/index.html?search=regex\n\nThe heuristic is pretty close to the name resolver, maxLevDistance = `Math.floor(queryLen / 3)`.\n\nFixes #103357\nFixes #82131\n\nSimilar to https://github.com/rust-lang/rust/pull/103710, but following the suggestion in https://github.com/rust-lang/rust/pull/103710#issuecomment-1296360267 to use `floor` instead of `ceil`, and unblocked now that https://github.com/rust-lang/rust/pull/105796 made it so that setting the max lev distance to `0` doesn't cause substring matches to be removed.", "tree": {"sha": "b8ad1f69eac155e25cbd0376accb01a9371bc3d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8ad1f69eac155e25cbd0376accb01a9371bc3d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c3f0d6f30eeefa58170012df10008736ac89755", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3f0d6f30eeefa58170012df10008736ac89755", "html_url": "https://github.com/rust-lang/rust/commit/7c3f0d6f30eeefa58170012df10008736ac89755", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c3f0d6f30eeefa58170012df10008736ac89755/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14ea63a7e005f9ca48bc13df6cb4fc5afe32febe", "url": "https://api.github.com/repos/rust-lang/rust/commits/14ea63a7e005f9ca48bc13df6cb4fc5afe32febe", "html_url": "https://github.com/rust-lang/rust/commit/14ea63a7e005f9ca48bc13df6cb4fc5afe32febe"}, {"sha": "616a0db7d6c4f1c8dd202c06c6cbe919d171edb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/616a0db7d6c4f1c8dd202c06c6cbe919d171edb1", "html_url": "https://github.com/rust-lang/rust/commit/616a0db7d6c4f1c8dd202c06c6cbe919d171edb1"}], "stats": {"total": 182, "additions": 108, "deletions": 74}, "files": [{"sha": "251e806c2d90d086c5bec0a25ba4769ec3a7ba46", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 84, "deletions": 65, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/7c3f0d6f30eeefa58170012df10008736ac89755/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/7c3f0d6f30eeefa58170012df10008736ac89755/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=7c3f0d6f30eeefa58170012df10008736ac89755", "patch": "@@ -112,7 +112,6 @@ function levenshtein(s1, s2) {\n }\n \n function initSearch(rawSearchIndex) {\n-    const MAX_LEV_DISTANCE = 3;\n     const MAX_RESULTS = 200;\n     const NO_TYPE_FILTER = -1;\n     /**\n@@ -897,13 +896,13 @@ function initSearch(rawSearchIndex) {\n          * @param {QueryElement} elem  - The element from the parsed query.\n          * @param {integer} defaultLev - This is the value to return in case there are no generics.\n          *\n-         * @return {integer}           - Returns the best match (if any) or `MAX_LEV_DISTANCE + 1`.\n+         * @return {integer}           - Returns the best match (if any) or `maxLevDistance + 1`.\n          */\n-        function checkGenerics(row, elem, defaultLev) {\n+        function checkGenerics(row, elem, defaultLev, maxLevDistance) {\n             if (row.generics.length === 0) {\n-                return elem.generics.length === 0 ? defaultLev : MAX_LEV_DISTANCE + 1;\n+                return elem.generics.length === 0 ? defaultLev : maxLevDistance + 1;\n             } else if (row.generics.length > 0 && row.generics[0].name === null) {\n-                return checkGenerics(row.generics[0], elem, defaultLev);\n+                return checkGenerics(row.generics[0], elem, defaultLev, maxLevDistance);\n             }\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n@@ -914,8 +913,8 @@ function initSearch(rawSearchIndex) {\n                     elem_name = entry.name;\n                     if (elem_name === \"\") {\n                         // Pure generic, needs to check into it.\n-                        if (checkGenerics(entry, elem, MAX_LEV_DISTANCE + 1) !== 0) {\n-                            return MAX_LEV_DISTANCE + 1;\n+                        if (checkGenerics(entry, elem, maxLevDistance + 1, maxLevDistance) !== 0) {\n+                            return maxLevDistance + 1;\n                         }\n                         continue;\n                     }\n@@ -942,7 +941,7 @@ function initSearch(rawSearchIndex) {\n                         }\n                     }\n                     if (match === null) {\n-                        return MAX_LEV_DISTANCE + 1;\n+                        return maxLevDistance + 1;\n                     }\n                     elems[match] -= 1;\n                     if (elems[match] === 0) {\n@@ -951,7 +950,7 @@ function initSearch(rawSearchIndex) {\n                 }\n                 return 0;\n             }\n-            return MAX_LEV_DISTANCE + 1;\n+            return maxLevDistance + 1;\n         }\n \n         /**\n@@ -963,10 +962,10 @@ function initSearch(rawSearchIndex) {\n           *\n           * @return {integer} - Returns a Levenshtein distance to the best match.\n           */\n-        function checkIfInGenerics(row, elem) {\n-            let lev = MAX_LEV_DISTANCE + 1;\n+        function checkIfInGenerics(row, elem, maxLevDistance) {\n+            let lev = maxLevDistance + 1;\n             for (const entry of row.generics) {\n-                lev = Math.min(checkType(entry, elem, true), lev);\n+                lev = Math.min(checkType(entry, elem, true, maxLevDistance), lev);\n                 if (lev === 0) {\n                     break;\n                 }\n@@ -983,15 +982,15 @@ function initSearch(rawSearchIndex) {\n           * @param {boolean} literalSearch\n           *\n           * @return {integer} - Returns a Levenshtein distance to the best match. If there is\n-          *                     no match, returns `MAX_LEV_DISTANCE + 1`.\n+          *                     no match, returns `maxLevDistance + 1`.\n           */\n-        function checkType(row, elem, literalSearch) {\n+        function checkType(row, elem, literalSearch, maxLevDistance) {\n             if (row.name === null) {\n                 // This is a pure \"generic\" search, no need to run other checks.\n                 if (row.generics.length > 0) {\n-                    return checkIfInGenerics(row, elem);\n+                    return checkIfInGenerics(row, elem, maxLevDistance);\n                 }\n-                return MAX_LEV_DISTANCE + 1;\n+                return maxLevDistance + 1;\n             }\n \n             let lev = levenshtein(row.name, elem.name);\n@@ -1005,9 +1004,9 @@ function initSearch(rawSearchIndex) {\n                             return 0;\n                         }\n                     }\n-                    return MAX_LEV_DISTANCE + 1;\n+                    return maxLevDistance + 1;\n                 } else if (elem.generics.length > 0) {\n-                    return checkGenerics(row, elem, MAX_LEV_DISTANCE + 1);\n+                    return checkGenerics(row, elem, maxLevDistance + 1, maxLevDistance);\n                 }\n                 return 0;\n             } else if (row.generics.length > 0) {\n@@ -1017,30 +1016,28 @@ function initSearch(rawSearchIndex) {\n                     }\n                     // The name didn't match so we now check if the type we're looking for is inside\n                     // the generics!\n-                    lev = checkIfInGenerics(row, elem);\n-                    // Now whatever happens, the returned distance is \"less good\" so we should mark\n-                    // it as such, and so we add 0.5 to the distance to make it \"less good\".\n-                    return lev + 0.5;\n-                } else if (lev > MAX_LEV_DISTANCE) {\n+                    lev = Math.min(lev, checkIfInGenerics(row, elem, maxLevDistance));\n+                    return lev;\n+                } else if (lev > maxLevDistance) {\n                     // So our item's name doesn't match at all and has generics.\n                     //\n                     // Maybe it's present in a sub generic? For example \"f<A<B<C>>>()\", if we're\n                     // looking for \"B<C>\", we'll need to go down.\n-                    return checkIfInGenerics(row, elem);\n+                    return checkIfInGenerics(row, elem, maxLevDistance);\n                 } else {\n                     // At this point, the name kinda match and we have generics to check, so\n                     // let's go!\n-                    const tmp_lev = checkGenerics(row, elem, lev);\n-                    if (tmp_lev > MAX_LEV_DISTANCE) {\n-                        return MAX_LEV_DISTANCE + 1;\n+                    const tmp_lev = checkGenerics(row, elem, lev, maxLevDistance);\n+                    if (tmp_lev > maxLevDistance) {\n+                        return maxLevDistance + 1;\n                     }\n                     // We compute the median value of both checks and return it.\n                     return (tmp_lev + lev) / 2;\n                 }\n             } else if (elem.generics.length > 0) {\n                 // In this case, we were expecting generics but there isn't so we simply reject this\n                 // one.\n-                return MAX_LEV_DISTANCE + 1;\n+                return maxLevDistance + 1;\n             }\n             // No generics on our query or on the target type so we can return without doing\n             // anything else.\n@@ -1055,23 +1052,26 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} typeFilter\n          *\n          * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n-         *                      match, returns `MAX_LEV_DISTANCE + 1`.\n+         *                      match, returns `maxLevDistance + 1`.\n          */\n-        function findArg(row, elem, typeFilter) {\n-            let lev = MAX_LEV_DISTANCE + 1;\n+        function findArg(row, elem, typeFilter, maxLevDistance) {\n+            let lev = maxLevDistance + 1;\n \n             if (row && row.type && row.type.inputs && row.type.inputs.length > 0) {\n                 for (const input of row.type.inputs) {\n                     if (!typePassesFilter(typeFilter, input.ty)) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(input, elem, parsedQuery.literalSearch));\n+                    lev = Math.min(\n+                        lev,\n+                        checkType(input, elem, parsedQuery.literalSearch, maxLevDistance)\n+                    );\n                     if (lev === 0) {\n                         return 0;\n                     }\n                 }\n             }\n-            return parsedQuery.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n+            return parsedQuery.literalSearch ? maxLevDistance + 1 : lev;\n         }\n \n         /**\n@@ -1082,31 +1082,34 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} typeFilter\n          *\n          * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n-         *                      match, returns `MAX_LEV_DISTANCE + 1`.\n+         *                      match, returns `maxLevDistance + 1`.\n          */\n-        function checkReturned(row, elem, typeFilter) {\n-            let lev = MAX_LEV_DISTANCE + 1;\n+        function checkReturned(row, elem, typeFilter, maxLevDistance) {\n+            let lev = maxLevDistance + 1;\n \n             if (row && row.type && row.type.output.length > 0) {\n                 const ret = row.type.output;\n                 for (const ret_ty of ret) {\n                     if (!typePassesFilter(typeFilter, ret_ty.ty)) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(ret_ty, elem, parsedQuery.literalSearch));\n+                    lev = Math.min(\n+                        lev,\n+                        checkType(ret_ty, elem, parsedQuery.literalSearch, maxLevDistance)\n+                    );\n                     if (lev === 0) {\n                         return 0;\n                     }\n                 }\n             }\n-            return parsedQuery.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n+            return parsedQuery.literalSearch ? maxLevDistance + 1 : lev;\n         }\n \n-        function checkPath(contains, ty) {\n+        function checkPath(contains, ty, maxLevDistance) {\n             if (contains.length === 0) {\n                 return 0;\n             }\n-            let ret_lev = MAX_LEV_DISTANCE + 1;\n+            let ret_lev = maxLevDistance + 1;\n             const path = ty.path.split(\"::\");\n \n             if (ty.parent && ty.parent.name) {\n@@ -1116,7 +1119,7 @@ function initSearch(rawSearchIndex) {\n             const length = path.length;\n             const clength = contains.length;\n             if (clength > length) {\n-                return MAX_LEV_DISTANCE + 1;\n+                return maxLevDistance + 1;\n             }\n             for (let i = 0; i < length; ++i) {\n                 if (i + clength > length) {\n@@ -1126,7 +1129,7 @@ function initSearch(rawSearchIndex) {\n                 let aborted = false;\n                 for (let x = 0; x < clength; ++x) {\n                     const lev = levenshtein(path[i + x], contains[x]);\n-                    if (lev > MAX_LEV_DISTANCE) {\n+                    if (lev > maxLevDistance) {\n                         aborted = true;\n                         break;\n                     }\n@@ -1231,7 +1234,7 @@ function initSearch(rawSearchIndex) {\n          * following condition:\n          *\n          * * If it is a \"literal search\" (`parsedQuery.literalSearch`), then `lev` must be 0.\n-         * * If it is not a \"literal search\", `lev` must be <= `MAX_LEV_DISTANCE`.\n+         * * If it is not a \"literal search\", `lev` must be <= `maxLevDistance`.\n          *\n          * The `results` map contains information which will be used to sort the search results:\n          *\n@@ -1249,8 +1252,8 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} lev\n          * @param {integer} path_lev\n          */\n-        function addIntoResults(results, fullId, id, index, lev, path_lev) {\n-            const inBounds = lev <= MAX_LEV_DISTANCE || index !== -1;\n+        function addIntoResults(results, fullId, id, index, lev, path_lev, maxLevDistance) {\n+            const inBounds = lev <= maxLevDistance || index !== -1;\n             if (lev === 0 || (!parsedQuery.literalSearch && inBounds)) {\n                 if (results[fullId] !== undefined) {\n                     const result = results[fullId];\n@@ -1289,7 +1292,8 @@ function initSearch(rawSearchIndex) {\n             elem,\n             results_others,\n             results_in_args,\n-            results_returned\n+            results_returned,\n+            maxLevDistance\n         ) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n@@ -1298,13 +1302,13 @@ function initSearch(rawSearchIndex) {\n             const fullId = row.id;\n             const searchWord = searchWords[pos];\n \n-            const in_args = findArg(row, elem, parsedQuery.typeFilter);\n-            const returned = checkReturned(row, elem, parsedQuery.typeFilter);\n+            const in_args = findArg(row, elem, parsedQuery.typeFilter, maxLevDistance);\n+            const returned = checkReturned(row, elem, parsedQuery.typeFilter, maxLevDistance);\n \n             // path_lev is 0 because no parent path information is currently stored\n             // in the search index\n-            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0);\n-            addIntoResults(results_returned, fullId, pos, -1, returned, 0);\n+            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0, maxLevDistance);\n+            addIntoResults(results_returned, fullId, pos, -1, returned, 0, maxLevDistance);\n \n             if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n                 return;\n@@ -1328,16 +1332,16 @@ function initSearch(rawSearchIndex) {\n             // No need to check anything else if it's a \"pure\" generics search.\n             if (elem.name.length === 0) {\n                 if (row.type !== null) {\n-                    lev = checkGenerics(row.type, elem, MAX_LEV_DISTANCE + 1);\n+                    lev = checkGenerics(row.type, elem, maxLevDistance + 1, maxLevDistance);\n                     // path_lev is 0 because we know it's empty\n-                    addIntoResults(results_others, fullId, pos, index, lev, 0);\n+                    addIntoResults(results_others, fullId, pos, index, lev, 0, maxLevDistance);\n                 }\n                 return;\n             }\n \n             if (elem.fullPath.length > 1) {\n-                path_lev = checkPath(elem.pathWithoutLast, row);\n-                if (path_lev > MAX_LEV_DISTANCE) {\n+                path_lev = checkPath(elem.pathWithoutLast, row, maxLevDistance);\n+                if (path_lev > maxLevDistance) {\n                     return;\n                 }\n             }\n@@ -1351,11 +1355,11 @@ function initSearch(rawSearchIndex) {\n \n             lev = levenshtein(searchWord, elem.pathLast);\n \n-            if (index === -1 && lev + path_lev > MAX_LEV_DISTANCE) {\n+            if (index === -1 && lev + path_lev > maxLevDistance) {\n                 return;\n             }\n \n-            addIntoResults(results_others, fullId, pos, index, lev, path_lev);\n+            addIntoResults(results_others, fullId, pos, index, lev, path_lev, maxLevDistance);\n         }\n \n         /**\n@@ -1367,7 +1371,7 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} pos      - Position in the `searchIndex`.\n          * @param {Object} results\n          */\n-        function handleArgs(row, pos, results) {\n+        function handleArgs(row, pos, results, maxLevDistance) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n@@ -1379,7 +1383,7 @@ function initSearch(rawSearchIndex) {\n             function checkArgs(elems, callback) {\n                 for (const elem of elems) {\n                     // There is more than one parameter to the query so all checks should be \"exact\"\n-                    const lev = callback(row, elem, NO_TYPE_FILTER);\n+                    const lev = callback(row, elem, NO_TYPE_FILTER, maxLevDistance);\n                     if (lev <= 1) {\n                         nbLev += 1;\n                         totalLev += lev;\n@@ -1400,12 +1404,21 @@ function initSearch(rawSearchIndex) {\n                 return;\n             }\n             const lev = Math.round(totalLev / nbLev);\n-            addIntoResults(results, row.id, pos, 0, lev, 0);\n+            addIntoResults(results, row.id, pos, 0, lev, 0, maxLevDistance);\n         }\n \n         function innerRunQuery() {\n             let elem, i, nSearchWords, in_returned, row;\n \n+            let queryLen = 0;\n+            for (const elem of parsedQuery.elems) {\n+                queryLen += elem.name.length;\n+            }\n+            for (const elem of parsedQuery.returned) {\n+                queryLen += elem.name.length;\n+            }\n+            const maxLevDistance = Math.floor(queryLen / 3);\n+\n             if (parsedQuery.foundElems === 1) {\n                 if (parsedQuery.elems.length === 1) {\n                     elem = parsedQuery.elems[0];\n@@ -1418,21 +1431,27 @@ function initSearch(rawSearchIndex) {\n                             elem,\n                             results_others,\n                             results_in_args,\n-                            results_returned\n+                            results_returned,\n+                            maxLevDistance\n                         );\n                     }\n                 } else if (parsedQuery.returned.length === 1) {\n                     // We received one returned argument to check, so looking into returned values.\n                     elem = parsedQuery.returned[0];\n                     for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n                         row = searchIndex[i];\n-                        in_returned = checkReturned(row, elem, parsedQuery.typeFilter);\n-                        addIntoResults(results_others, row.id, i, -1, in_returned);\n+                        in_returned = checkReturned(\n+                            row,\n+                            elem,\n+                            parsedQuery.typeFilter,\n+                            maxLevDistance\n+                        );\n+                        addIntoResults(results_others, row.id, i, -1, in_returned, maxLevDistance);\n                     }\n                 }\n             } else if (parsedQuery.foundElems > 0) {\n                 for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n-                    handleArgs(searchIndex[i], i, results_others);\n+                    handleArgs(searchIndex[i], i, results_others, maxLevDistance);\n                 }\n             }\n         }\n@@ -1470,7 +1489,7 @@ function initSearch(rawSearchIndex) {\n      *\n      * @return {boolean}       - Whether the result is valid or not\n      */\n-    function validateResult(name, path, keys, parent) {\n+    function validateResult(name, path, keys, parent, maxLevDistance) {\n         if (!keys || !keys.length) {\n             return true;\n         }\n@@ -1485,7 +1504,7 @@ function initSearch(rawSearchIndex) {\n                 (parent !== undefined && parent.name !== undefined &&\n                     parent.name.toLowerCase().indexOf(key) > -1) ||\n                 // lastly check to see if the name was a levenshtein match\n-                levenshtein(name, key) <= MAX_LEV_DISTANCE)) {\n+                levenshtein(name, key) <= maxLevDistance)) {\n                 return false;\n             }\n         }"}, {"sha": "6ad1e8b4f673f5d46ba103735f902469e902bdc2", "filename": "tests/rustdoc-gui/src/test_docs/lib.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7c3f0d6f30eeefa58170012df10008736ac89755/tests%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3f0d6f30eeefa58170012df10008736ac89755/tests%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=7c3f0d6f30eeefa58170012df10008736ac89755", "patch": "@@ -340,7 +340,7 @@ pub mod details {\n pub mod doc_block_table {\n \n     pub trait DocBlockTableTrait {\n-        fn func();\n+        fn foo();\n     }\n \n     /// Struct doc.\n@@ -359,7 +359,7 @@ pub mod doc_block_table {\n         /// | header1                  | header2                  |\n         /// |--------------------------|--------------------------|\n         /// | Lorem Ipsum, Lorem Ipsum | Lorem Ipsum, Lorem Ipsum |\n-        fn func() {\n+        fn foo() {\n             println!();\n         }\n     }\n@@ -474,3 +474,15 @@ impl TypeWithImplDoc {\n ///\n /// </sub>\n pub mod codeblock_sub {}\n+pub mod search_results {\n+\n+    pub struct SearchResults {\n+        pub foo: i32,\n+    }\n+\n+    #[macro_export]\n+    macro_rules! foo {\n+        () => {};\n+    }\n+\n+}"}, {"sha": "a6843c595f7ad6d8e96f559f496ae97f533f2500", "filename": "tests/rustdoc-js-std/regex.js", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c3f0d6f30eeefa58170012df10008736ac89755/tests%2Frustdoc-js-std%2Fregex.js", "raw_url": "https://github.com/rust-lang/rust/raw/7c3f0d6f30eeefa58170012df10008736ac89755/tests%2Frustdoc-js-std%2Fregex.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fregex.js?ref=7c3f0d6f30eeefa58170012df10008736ac89755", "patch": "@@ -0,0 +1,10 @@\n+// exact-check\n+\n+// https://github.com/rust-lang/rust/issues/103357\n+const QUERY = 'regex';\n+\n+const EXPECTED = {\n+    'others': [],\n+    'in_args': [],\n+    'returned': [],\n+};"}, {"sha": "eeb3e1888695953d3746b68ac2d4616af2df8248", "filename": "tests/rustdoc-js-std/typed-query.js", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c3f0d6f30eeefa58170012df10008736ac89755/tests%2Frustdoc-js-std%2Ftyped-query.js", "raw_url": "https://github.com/rust-lang/rust/raw/7c3f0d6f30eeefa58170012df10008736ac89755/tests%2Frustdoc-js-std%2Ftyped-query.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Ftyped-query.js?ref=7c3f0d6f30eeefa58170012df10008736ac89755", "patch": "@@ -9,9 +9,5 @@ const EXPECTED = {\n         { 'path': 'std', 'name': 'println' },\n         { 'path': 'std', 'name': 'eprint' },\n         { 'path': 'std', 'name': 'eprintln' },\n-        { 'path': 'std::pin', 'name': 'pin' },\n-        { 'path': 'std::future', 'name': 'join' },\n-        { 'path': 'std', 'name': 'line' },\n-        { 'path': 'std', 'name': 'write' },\n     ],\n };"}, {"sha": "62c8e7a74b9405ed2a22075ec9464d189fce2228", "filename": "tests/rustdoc-js/doc-alias.js", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c3f0d6f30eeefa58170012df10008736ac89755/tests%2Frustdoc-js%2Fdoc-alias.js", "raw_url": "https://github.com/rust-lang/rust/raw/7c3f0d6f30eeefa58170012df10008736ac89755/tests%2Frustdoc-js%2Fdoc-alias.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fdoc-alias.js?ref=7c3f0d6f30eeefa58170012df10008736ac89755", "patch": "@@ -1,5 +1,3 @@\n-// exact-check\n-\n const QUERY = [\n     'StructItem',\n     'StructFieldItem',"}, {"sha": "f17a97f13dc7e9e3aaca47ab424284e28e29ad43", "filename": "tests/rustdoc-js/module-substring.js", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c3f0d6f30eeefa58170012df10008736ac89755/tests%2Frustdoc-js%2Fmodule-substring.js", "raw_url": "https://github.com/rust-lang/rust/raw/7c3f0d6f30eeefa58170012df10008736ac89755/tests%2Frustdoc-js%2Fmodule-substring.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fmodule-substring.js?ref=7c3f0d6f30eeefa58170012df10008736ac89755", "patch": "@@ -4,6 +4,5 @@ const EXPECTED = {\n     'others': [\n         { 'path': 'module_substring::Sig', 'name': 'pc' },\n         { 'path': 'module_substring::Si', 'name': 'pc' },\n-        { 'path': 'module_substring::Si', 'name': 'pa' },\n     ],\n };"}]}