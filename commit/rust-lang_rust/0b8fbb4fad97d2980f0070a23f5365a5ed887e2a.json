{"sha": "0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiOGZiYjRmYWQ5N2QyOTgwZjAwNzBhMjNmNTM2NWE1ZWQ4ODdlMmE=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-08T23:47:12Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-09T00:17:09Z"}, "message": "Fix typos in ARCHITECTURE.md and a number of crates\n\nspecifically: gen_lsp_server, ra_arena, ra_cli, ra_db, ra_hir", "tree": {"sha": "4e1cd7f26641c65d809e1a0a6943c77ccbe562d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e1cd7f26641c65d809e1a0a6943c77ccbe562d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "html_url": "https://github.com/rust-lang/rust/commit/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8261d611a60e99bc188022773f84912972208d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8261d611a60e99bc188022773f84912972208d2", "html_url": "https://github.com/rust-lang/rust/commit/f8261d611a60e99bc188022773f84912972208d2"}], "stats": {"total": 241, "additions": 150, "deletions": 91}, "files": [{"sha": "79adc932152cc18cb02f313b54670f2e09b9fb91", "filename": "ARCHITECTURE.md", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/ARCHITECTURE.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/ARCHITECTURE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ARCHITECTURE.md?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -1,6 +1,6 @@\n # Architecture\n \n-This document describes high-level architecture of rust-analyzer.\n+This document describes the high-level architecture of rust-analyzer.\n If you want to familiarize yourself with the code base, you are just\n in the right place!\n \n@@ -12,10 +12,10 @@ On the highest level, rust-analyzer is a thing which accepts input source code\n from the client and produces a structured semantic model of the code.\n \n More specifically, input data consists of a set of test files (`(PathBuf,\n-String)` pairs) and an information about project structure, the so called\n-`CrateGraph`. Crate graph specifies which files are crate roots, which cfg flags\n-are specified for each crate (TODO: actually implement this) and what are\n-dependencies between the crates. The analyzer keeps all these input data in\n+String)` pairs) and information about project structure, captured in the so called\n+`CrateGraph`. The crate graph specifies which files are crate roots, which cfg\n+flags are specified for each crate (TODO: actually implement this) and what\n+dependencies exist between the crates. The analyzer keeps all this input data in\n memory and never does any IO. Because the input data is source code, which\n typically measures in tens of megabytes at most, keeping all input data in\n memory is OK.\n@@ -28,16 +28,16 @@ declarations, etc.\n The client can submit a small delta of input data (typically, a change to a\n single file) and get a fresh code model which accounts for changes.\n \n-Underlying engine makes sure that model is computed lazily (on-demand) and can\n-be quickly updated for small modifications.\n+The underlying engine makes sure that model is computed lazily (on-demand) and\n+can be quickly updated for small modifications.\n \n \n ## Code generation\n \n Some of the components of this repository are generated through automatic\n processes. These are outlined below:\n \n-- `gen-syntax`: The kinds of tokens are reused in several places, so a generator\n+- `gen-syntax`: The kinds of tokens that are reused in several places, so a generator\n   is used. We use tera templates to generate the files listed below, based on\n   the grammar described in [grammar.ron]:\n   - [ast/generated.rs][ast generated] in `ra_syntax` based on\n@@ -58,17 +58,16 @@ processes. These are outlined below:\n ### `crates/ra_syntax`\n \n Rust syntax tree structure and parser. See\n-[RFC](https://github.com/rust-lang/rfcs/pull/2256) for some design\n-notes.\n+[RFC](https://github.com/rust-lang/rfcs/pull/2256) for some design notes.\n \n - [rowan](https://github.com/rust-analyzer/rowan) library is used for constructing syntax trees.\n-- `grammar` module is the actual parser. It is a hand-written recursive descent parsers, which\n-  produces a sequence of events like \"start node X\", \"finish not Y\". It works similarly to  [kotlin parser](https://github.com/JetBrains/kotlin/blob/4d951de616b20feca92f3e9cc9679b2de9e65195/compiler/frontend/src/org/jetbrains/kotlin/parsing/KotlinParsing.java),\n-  which is a good source for inspiration for dealing with syntax errors and incomplete input. Original [libsyntax parser](https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src/libsyntax/parse/parser.rs)\n+- `grammar` module is the actual parser. It is a hand-written recursive descent parser, which\n+  produces a sequence of events like \"start node X\", \"finish not Y\". It works similarly to [kotlin's parser](https://github.com/JetBrains/kotlin/blob/4d951de616b20feca92f3e9cc9679b2de9e65195/compiler/frontend/src/org/jetbrains/kotlin/parsing/KotlinParsing.java),\n+  which is a good source of inspiration for dealing with syntax errors and incomplete input. Original [libsyntax parser](https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src/libsyntax/parse/parser.rs)\n   is what we use for the definition of the Rust language.\n - `parser_api/parser_impl` bridges the tree-agnostic parser from `grammar` with `rowan` trees.\n   This is the thing that turns a flat list of events into a tree (see `EventProcessor`)\n-- `ast` a type safe API on top of the raw `rowan` tree.\n+- `ast` provides a type safe API on top of the raw `rowan` tree.\n - `grammar.ron` RON description of the grammar, which is used to\n   generate `syntax_kinds` and `ast` modules, using `cargo gen-syntax` command.\n - `algo`: generic tree algorithms, including `walk` for O(1) stack\n@@ -90,7 +89,7 @@ fixes a bug in the grammar.\n We use the [salsa](https://github.com/salsa-rs/salsa) crate for incremental and\n on-demand computation. Roughly, you can think of salsa as a key-value store, but\n it also can compute derived values using specified functions. The `ra_db` crate\n-provides a basic infrastructure for interacting with salsa. Crucially, it\n+provides basic infrastructure for interacting with salsa. Crucially, it\n defines most of the \"input\" queries: facts supplied by the client of the\n analyzer. Reading the docs of the `ra_db::input` module should be useful:\n everything else is strictly derived from those inputs.\n@@ -102,7 +101,7 @@ HIR provides high-level \"object oriented\" access to Rust code.\n The principal difference between HIR and syntax trees is that HIR is bound to a\n particular crate instance. That is, it has cfg flags and features applied (in\n theory, in practice this is to be implemented). So, the relation between\n-syntax and HIR is many-to-one. The `source_binder` modules is responsible for\n+syntax and HIR is many-to-one. The `source_binder` module is responsible for\n guessing a HIR for a particular source position.\n \n Underneath, HIR works on top of salsa, using a `HirDatabase` trait.\n@@ -111,12 +110,12 @@ Underneath, HIR works on top of salsa, using a `HirDatabase` trait.\n \n A stateful library for analyzing many Rust files as they change. `AnalysisHost`\n is a mutable entity (clojure's atom) which holds the current state, incorporates\n-changes and handles out `Analysis` --- an immutable and consistent snapshot of\n-world state at a point in time, which actually powers analysis.\n+changes and hands out `Analysis` --- an immutable and consistent snapshot of\n+the world state at a point in time, which actually powers analysis.\n \n One interesting aspect of analysis is its support for cancellation. When a\n change is applied to `AnalysisHost`, first all currently active snapshots are\n-cancelled. Only after all snapshots are dropped the change actually affects the\n+canceled. Only after all snapshots are dropped the change actually affects the\n database.\n \n APIs in this crate are IDE centric: they take text offsets as input and produce\n@@ -142,7 +141,7 @@ An LSP implementation which wraps `ra_ide_api` into a langauge server protocol.\n \n ### `crates/ra_vfs`\n \n-Although `hir` and `ra_ide_api` don't do any io, we need to be able to read\n+Although `hir` and `ra_ide_api` don't do any IO, we need to be able to read\n files from disk at the end of the day. This is what `ra_vfs` does. It also\n manages overlays: \"dirty\" files in the editor, whose \"true\" contents is\n different from data on disk.\n@@ -175,16 +174,16 @@ VS Code plugin\n ## Common workflows\n \n To try out VS Code extensions, run `cargo install-code`.  This installs both the\n-`ra_lsp_server` binary and VS Code extension. To install only the binary, use\n+`ra_lsp_server` binary and the VS Code extension. To install only the binary, use\n `cargo install --path crates/ra_lsp_server --force`\n \n To see logs from the language server, set `RUST_LOG=info` env variable. To see\n all communication between the server and the client, use\n-`RUST_LOG=gen_lsp_server=debug` (will print quite a bit of stuff).\n+`RUST_LOG=gen_lsp_server=debug` (this will print quite a bit of stuff).\n \n To run tests, just `cargo test`.\n \n-To work on VS Code extension, launch code inside `editors/code` and use `F5` to\n+To work on the VS Code extension, launch code inside `editors/code` and use `F5` to\n launch/debug. To automatically apply formatter and linter suggestions, use `npm\n run fix`.\n "}, {"sha": "16ac799ace1d3356f6df87f08d39320afc5e6f0c", "filename": "crates/gen_lsp_server/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -78,10 +78,10 @@ pub use crate::{\n };\n \n /// Main entry point: runs the server from initialization to shutdown.\n-/// To attach server to standard input/output streams, use `stdio_transport`\n+/// To attach server to standard input/output streams, use the `stdio_transport`\n /// function to create corresponding `sender` and `receiver` pair.\n ///\n-///`server` should use `handle_shutdown` function to handle the `Shutdown`\n+/// `server` should use the `handle_shutdown` function to handle the `Shutdown`\n /// request.\n pub fn run_server(\n     caps: ServerCapabilities,\n@@ -104,7 +104,7 @@ pub fn run_server(\n     Ok(())\n }\n \n-/// if `req` is `Shutdown`, respond to it and return `None`, otherwise return `Some(req)`\n+/// If `req` is `Shutdown`, respond to it and return `None`, otherwise return `Some(req)`\n pub fn handle_shutdown(req: RawRequest, sender: &Sender<RawMessage>) -> Option<RawRequest> {\n     match req.cast::<Shutdown>() {\n         Ok((id, ())) => {"}, {"sha": "94bef374ce0aba0dbe70dafcecb3cd50de59247e", "filename": "crates/gen_lsp_server/src/msg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -54,7 +54,7 @@ pub enum ErrorCode {\n     ServerErrorEnd = -32000,\n     ServerNotInitialized = -32002,\n     UnknownErrorCode = -32001,\n-    RequestCancelled = -32800,\n+    RequestCanceled = -32800,\n     ContentModified = -32801,\n }\n "}, {"sha": "8d38eebfb43ffc80d74bd050c6c3a77bf6f67077", "filename": "crates/ra_db/src/cancellation.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_db%2Fsrc%2Fcancellation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_db%2Fsrc%2Fcancellation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fcancellation.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -8,11 +8,11 @@\n //!   * user types next character, while syntax highlighting *is still in\n //!     progress*.\n //!\n-//! In this situation, we want to react to modification as quckly as possible.\n+//! In this situation, we want to react to modification as quickly as possible.\n //! At the same time, in-progress results are not very interesting, because they\n //! are invalidated by the edit anyway. So, we first cancel all in-flight\n-//! requests, and then apply modification knowing that it won't intrfere with\n-//! any background processing (this bit is handled by salsa, see\n+//! requests, and then apply modification knowing that it won't interfere with\n+//! any background processing (this bit is handled by salsa, see the\n //! `BaseDatabase::check_canceled` method).\n \n /// An \"error\" signifing that the operation was canceled.", "previous_filename": "crates/ra_db/src/cancelation.rs"}, {"sha": "023183e2902980c54c50038c50d493b5c97a63c8", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -1,9 +1,9 @@\n-/// This modules specifies the input to rust-analyzer. In some sense, this is\n+/// This module specifies the input to rust-analyzer. In some sense, this is\n /// **the** most important module, because all other fancy stuff is strictly\n /// derived from this input.\n ///\n /// Note that neither this module, nor any other part of the analyzer's core do\n-/// actual IO. See `vfs` and `project_model` in `ra_lsp_server` crate for how\n+/// actual IO. See `vfs` and `project_model` in the `ra_lsp_server` crate for how\n /// actual IO is done and lowered to input.\n use std::sync::Arc;\n \n@@ -17,17 +17,17 @@ use rustc_hash::FxHashSet;\n /// `FileId` is an integer which uniquely identifies a file. File paths are\n /// messy and system-dependent, so most of the code should work directly with\n /// `FileId`, without inspecting the path. The mapping between `FileId` and path\n-/// and `SourceRoot` is constant. File rename is represented as a pair of\n+/// and `SourceRoot` is constant. A file rename is represented as a pair of\n /// deletion/creation.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct FileId(pub u32);\n \n /// Files are grouped into source roots. A source root is a directory on the\n /// file systems which is watched for changes. Typically it corresponds to a\n-/// Cargo package. Source roots *might* be nested: in this case, file belongs to\n-/// the nearest enclosing source root. Path to files are always relative to a\n-/// source root, and analyzer does not know the root path of the source root at\n-/// all. So, a file from one source root can't refere a file in another source\n+/// Rust crate. Source roots *might* be nested: in this case, a file belongs to\n+/// the nearest enclosing source root. Paths to files are always relative to a\n+/// source root, and the analyzer does not know the root path of the source root at\n+/// all. So, a file from one source root can't refer to a file in another source\n /// root by path.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub struct SourceRootId(pub u32);\n@@ -38,15 +38,15 @@ pub struct SourceRoot {\n }\n \n /// `CrateGraph` is a bit of information which turns a set of text files into a\n-/// number of Rust crates. Each Crate is the `FileId` of it's root module, the\n-/// set of cfg flags (not yet implemented) and the set of dependencies. Note\n+/// number of Rust crates. Each crate is defined by the `FileId` of its root module,\n+/// the set of cfg flags (not yet implemented) and the set of dependencies. Note\n /// that, due to cfg's, there might be several crates for a single `FileId`! As\n /// in the rust-lang proper, a crate does not have a name. Instead, names are\n /// specified on dependency edges. That is, a crate might be known under\n-/// different names in different dependant crates.\n+/// different names in different dependent crates.\n ///\n /// Note that `CrateGraph` is build-system agnostic: it's a concept of the Rust\n-/// langauge proper, not a concept of the build system. In practice, we get\n+/// language proper, not a concept of the build system. In practice, we get\n /// `CrateGraph` by lowering `cargo metadata` output.\n #[derive(Debug, Clone, Default, PartialEq, Eq)]\n pub struct CrateGraph {"}, {"sha": "fb8ea249654166ba0023a83e520502209688a916", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -1,5 +1,5 @@\n-//! ra_db defines basic database traits. Concrete DB is defined by ra_ide_api.\n-mod cancelation;\n+//! ra_db defines basic database traits. The concrete DB is defined by ra_ide_api.\n+mod cancellation;\n mod syntax_ptr;\n mod input;\n mod loc2id;\n@@ -8,7 +8,7 @@ pub mod mock;\n use ra_syntax::{TextUnit, TextRange, SourceFile, TreePtr};\n \n pub use crate::{\n-    cancelation::{Canceled, Cancelable},\n+    cancellation::{Canceled, Cancelable},\n     syntax_ptr::LocalSyntaxPtr,\n     input::{\n         FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, Dependency,"}, {"sha": "254c52629846791200fa82e214d32d71c92f7438", "filename": "crates/ra_db/src/loc2id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_db%2Fsrc%2Floc2id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_db%2Fsrc%2Floc2id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Floc2id.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -5,15 +5,15 @@ use rustc_hash::FxHashMap;\n use ra_arena::{Arena, ArenaId};\n \n /// There are two principle ways to refer to things:\n-///   - by their locatinon (module in foo/bar/baz.rs at line 42)\n+///   - by their location (module in foo/bar/baz.rs at line 42)\n ///   - by their numeric id (module `ModuleId(42)`)\n ///\n /// The first one is more powerful (you can actually find the thing in question\n /// by id), but the second one is so much more compact.\n ///\n /// `Loc2IdMap` allows us to have a cake an eat it as well: by maintaining a\n /// bidirectional mapping between positional and numeric ids, we can use compact\n-/// representation wich still allows us to get the actual item\n+/// representation which still allows us to get the actual item.\n #[derive(Debug)]\n struct Loc2IdMap<LOC, ID>\n where"}, {"sha": "66c016180bbbac0ffbe4a88e9db64ee5ad4145bc", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -13,8 +13,8 @@ use crate::{\n     ty::InferenceResult,\n };\n \n-/// hir::Crate describes a single crate. It's the main inteface with which\n-/// crate's dependencies interact. Mostly, it should be just a proxy for the\n+/// hir::Crate describes a single crate. It's the main interface with which\n+/// a crate's dependencies interact. Mostly, it should be just a proxy for the\n /// root module.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Crate {\n@@ -78,6 +78,7 @@ impl Module {\n     pub fn definition_source(&self, db: &impl HirDatabase) -> Cancelable<(FileId, ModuleSource)> {\n         self.definition_source_impl(db)\n     }\n+\n     /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n     /// `None` for the crate root.\n     pub fn declaration_source(\n@@ -91,20 +92,24 @@ impl Module {\n     pub fn krate(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n         self.krate_impl(db)\n     }\n+\n     /// Topmost parent of this module. Every module has a `crate_root`, but some\n-    /// might miss `krate`. This can happen if a module's file is not included\n-    /// into any module tree of any target from Cargo.toml.\n+    /// might be missing `krate`. This can happen if a module's file is not included\n+    /// in the module tree of any target in Cargo.toml.\n     pub fn crate_root(&self, db: &impl HirDatabase) -> Cancelable<Module> {\n         self.crate_root_impl(db)\n     }\n+\n     /// Finds a child module with the specified name.\n     pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n         self.child_impl(db, name)\n     }\n+\n     /// Finds a parent module.\n     pub fn parent(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n         self.parent_impl(db)\n     }\n+\n     pub fn path_to_root(&self, db: &impl HirDatabase) -> Cancelable<Vec<Module>> {\n         let mut res = vec![self.clone()];\n         let mut curr = self.clone();\n@@ -114,13 +119,16 @@ impl Module {\n         }\n         Ok(res)\n     }\n+\n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n         self.scope_impl(db)\n     }\n+\n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> Cancelable<PerNs<DefId>> {\n         self.resolve_path_impl(db, path)\n     }\n+\n     pub fn problems(\n         &self,\n         db: &impl HirDatabase,\n@@ -140,6 +148,7 @@ impl StructField {\n     pub fn name(&self) -> &Name {\n         &self.name\n     }\n+\n     pub fn type_ref(&self) -> &TypeRef {\n         &self.type_ref\n     }\n@@ -160,18 +169,21 @@ impl VariantData {\n             _ => &[],\n         }\n     }\n+\n     pub fn is_struct(&self) -> bool {\n         match self {\n             VariantData::Struct(..) => true,\n             _ => false,\n         }\n     }\n+\n     pub fn is_tuple(&self) -> bool {\n         match self {\n             VariantData::Tuple(..) => true,\n             _ => false,\n         }\n     }\n+\n     pub fn is_unit(&self) -> bool {\n         match self {\n             VariantData::Unit => true,"}, {"sha": "7dbe93f2bd34eb9d9c34153668ec7473f408e83a", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -26,6 +26,7 @@ pub trait HirDatabase: SyntaxDatabase\n         type HirSourceFileQuery;\n         use fn HirFileId::hir_source_file;\n     }\n+\n     fn expand_macro_invocation(invoc: MacroCallId) -> Option<Arc<MacroExpansion>> {\n         type ExpandMacroCallQuery;\n         use fn crate::macros::expand_macro_invocation;\n@@ -80,10 +81,12 @@ pub trait HirDatabase: SyntaxDatabase\n         type InputModuleItemsQuery;\n         use fn query_definitions::input_module_items;\n     }\n+\n     fn item_map(source_root_id: SourceRootId) -> Cancelable<Arc<ItemMap>> {\n         type ItemMapQuery;\n         use fn query_definitions::item_map;\n     }\n+\n     fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n         type ModuleTreeQuery;\n         use fn crate::module_tree::ModuleTree::module_tree_query;"}, {"sha": "ebb83d084c735fa74240c20bfad2221fc147ae97", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -33,8 +33,7 @@ pub struct Body {\n /// IDs. This is needed to go from e.g. a position in a file to the HIR\n /// expression containing it; but for type inference etc., we want to operate on\n /// a structure that is agnostic to the actual positions of expressions in the\n-/// file, so that we don't recompute the type inference whenever some whitespace\n-/// is typed.\n+/// file, so that we don't recompute types whenever some whitespace is typed.\n #[derive(Debug, Eq, PartialEq)]\n pub struct BodySyntaxMapping {\n     body: Arc<Body>,\n@@ -74,20 +73,25 @@ impl BodySyntaxMapping {\n     pub fn expr_syntax(&self, expr: ExprId) -> Option<LocalSyntaxPtr> {\n         self.expr_syntax_mapping_back.get(expr).cloned()\n     }\n+\n     pub fn syntax_expr(&self, ptr: LocalSyntaxPtr) -> Option<ExprId> {\n         self.expr_syntax_mapping.get(&ptr).cloned()\n     }\n+\n     pub fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n         self.expr_syntax_mapping\n             .get(&LocalSyntaxPtr::new(node.syntax()))\n             .cloned()\n     }\n+\n     pub fn pat_syntax(&self, pat: PatId) -> Option<LocalSyntaxPtr> {\n         self.pat_syntax_mapping_back.get(pat).cloned()\n     }\n+\n     pub fn syntax_pat(&self, ptr: LocalSyntaxPtr) -> Option<PatId> {\n         self.pat_syntax_mapping.get(&ptr).cloned()\n     }\n+\n     pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n         self.pat_syntax_mapping\n             .get(&LocalSyntaxPtr::new(node.syntax()))"}, {"sha": "2e10e5516c78d04a2f3268d01bfd5ed940e84e35", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -9,25 +9,25 @@ use crate::{\n \n use crate::code_model_api::Module;\n \n-/// hir makes a heavy use of ids: integer (u32) handlers to various things. You\n+/// hir makes heavy use of ids: integer (u32) handlers to various things. You\n /// can think of id as a pointer (but without a lifetime) or a file descriptor\n /// (but for hir objects).\n ///\n /// This module defines a bunch of ids we are using. The most important ones are\n /// probably `HirFileId` and `DefId`.\n \n-/// Input to the analyzer is a set of file, where each file is indetified by\n+/// Input to the analyzer is a set of files, where each file is indentified by\n /// `FileId` and contains source code. However, another source of source code in\n /// Rust are macros: each macro can be thought of as producing a \"temporary\n-/// file\". To assign id to such file, we use the id of a macro call that\n+/// file\". To assign an id to such a file, we use the id of the macro call that\n /// produced the file. So, a `HirFileId` is either a `FileId` (source code\n /// written by user), or a `MacroCallId` (source code produced by macro).\n ///\n /// What is a `MacroCallId`? Simplifying, it's a `HirFileId` of a file containin\n /// the call plus the offset of the macro call in the file. Note that this is a\n-/// recursive definition! Nethetheless, size_of of `HirFileId` is finite\n+/// recursive definition! However, the size_of of `HirFileId` is finite\n /// (because everything bottoms out at the real `FileId`) and small\n-/// (`MacroCallId` uses location interner).\n+/// (`MacroCallId` uses the location interner).\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct HirFileId(HirFileIdRepr);\n \n@@ -235,7 +235,7 @@ pub struct SourceItemId {\n     pub(crate) item_id: Option<SourceFileItemId>,\n }\n \n-/// Maps item's `SyntaxNode`s to `SourceFileItemId` and back.\n+/// Maps items' `SyntaxNode`s to `SourceFileItemId`s and back.\n #[derive(Debug, PartialEq, Eq)]\n pub struct SourceFileItems {\n     file_id: HirFileId,"}, {"sha": "4acda9af301cb0a9a7b25afcee19a27549168e11", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -128,13 +128,13 @@ impl ImplItem {\n pub struct ImplId(pub RawId);\n impl_arena_id!(ImplId);\n \n-/// Collection of impl blocks is a two-step process: First we collect the blocks\n-/// per-module; then we build an index of all impl blocks in the crate. This\n-/// way, we avoid having to do this process for the whole crate whenever someone\n-/// types in any file; as long as the impl blocks in the file don't change, we\n-/// don't need to do the second step again.\n+/// The collection of impl blocks is a two-step process: first we collect the\n+/// blocks per-module; then we build an index of all impl blocks in the crate.\n+/// This way, we avoid having to do this process for the whole crate whenever\n+/// a file is changed; as long as the impl blocks in the file don't change,\n+/// we don't need to do the second step again.\n ///\n-/// (The second step does not yet exist currently.)\n+/// (The second step does not yet exist.)\n #[derive(Debug, PartialEq, Eq)]\n pub struct ModuleImplBlocks {\n     impls: Arena<ImplId, ImplData>,"}, {"sha": "ca7f395a8a8e89ff7922bf88c90b884e933e5eab", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -1,9 +1,9 @@\n-//! HIR (previsouly known as descriptors) provides a high-level OO acess to Rust\n-//! code.\n+//! HIR (previously known as descriptors) provides a high-level object oriented\n+//! access to Rust code.\n //!\n //! The principal difference between HIR and syntax trees is that HIR is bound\n //! to a particular crate instance. That is, it has cfg flags and features\n-//! applied. So, there relation between syntax and HIR is many-to-one.\n+//! applied. So, the relation between syntax and HIR is many-to-one.\n \n macro_rules! ctry {\n     ($expr:expr) => {"}, {"sha": "e455b2ad595ddb35c8a8b9590202b677e43415eb", "filename": "crates/ra_hir/src/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -4,9 +4,9 @@\n /// that is produced after expansion. See `HirFileId` and `MacroCallId` for how\n /// do we do that.\n ///\n-/// When file-management question is resolved, all that is left is a token tree\n-/// to token tree transformation plus hygent. We don't have either of thouse\n-/// yet, so all macros are string based at the moment!\n+/// When the file-management question is resolved, all that is left is a\n+/// token-tree-to-token-tree transformation plus hygiene. We don't have either of\n+/// those yet, so all macros are string based at the moment!\n use std::sync::Arc;\n \n use ra_db::LocalSyntaxPtr;"}, {"sha": "d2c92f150c0f2df5dac4f9923b1f78d6c537ec72", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -85,9 +85,9 @@ impl_arena_id!(LinkId);\n \n /// Physically, rust source is organized as a set of files, but logically it is\n /// organized as a tree of modules. Usually, a single file corresponds to a\n-/// single module, but it is not nessary the case.\n+/// single module, but it is not neccessarily always the case.\n ///\n-/// Module encapsulate the logic of transitioning from the fuzzy world of files\n+/// `ModuleTree` encapsulates the logic of transitioning from the fuzzy world of files\n /// (which can have multiple parents) to the precise world of modules (which\n /// always have one parent).\n #[derive(Default, Debug, PartialEq, Eq)]"}, {"sha": "d9683549c65d1e14cc04a7de9b97e435fd1eebd9", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -3,7 +3,7 @@ use std::fmt;\n use ra_syntax::{ast, SmolStr};\n \n /// `Name` is a wrapper around string, which is used in hir for both references\n-/// and declarations. In theory, names should also carry hygene info, but we are\n+/// and declarations. In theory, names should also carry hygiene info, but we are\n /// not there yet!\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Name {"}, {"sha": "6bf949654fd2ad3dae9a0afa4c4cb7ce1784b88e", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -1,18 +1,18 @@\n-//! Name resolution algorithm. The end result of the algorithm is `ItemMap`: a\n-//! map with maps each module to it's scope: the set of items, visible in the\n+//! Name resolution algorithm. The end result of the algorithm is an `ItemMap`:\n+//! a map which maps each module to its scope: the set of items visible in the\n //! module. That is, we only resolve imports here, name resolution of item\n //! bodies will be done in a separate step.\n //!\n-//! Like Rustc, we use an interative per-crate algorithm: we start with scopes\n+//! Like Rustc, we use an interactive per-crate algorithm: we start with scopes\n //! containing only directly defined items, and then iteratively resolve\n //! imports.\n //!\n-//! To make this work nicely in the IDE scenarios, we place `InputModuleItems`\n+//! To make this work nicely in the IDE scenario, we place `InputModuleItems`\n //! in between raw syntax and name resolution. `InputModuleItems` are computed\n //! using only the module's syntax, and it is all directly defined items plus\n-//! imports. The plain is to make `InputModuleItems` independent of local\n-//! modifications (that is, typing inside a function shold not change IMIs),\n-//! such that the results of name resolution can be preserved unless the module\n+//! imports. The plan is to make `InputModuleItems` independent of local\n+//! modifications (that is, typing inside a function should not change IMIs),\n+//! so that the results of name resolution can be preserved unless the module\n //! structure itself is modified.\n use std::sync::Arc;\n \n@@ -34,7 +34,7 @@ use crate::{\n     module_tree::{ModuleId, ModuleTree},\n };\n \n-/// Item map is the result of the name resolution. Item map contains, for each\n+/// `ItemMap` is the result of name resolution. It contains, for each\n /// module, the set of visible items.\n // FIXME: currenty we compute item map per source-root. We should do it per crate instead.\n #[derive(Default, Debug, PartialEq, Eq)]\n@@ -59,9 +59,9 @@ impl ModuleScope {\n /// A set of items and imports declared inside a module, without relation to\n /// other modules.\n ///\n-/// This stands in-between raw syntax and name resolution and alow us to avoid\n-/// recomputing name res: if `InputModuleItems` are the same, we can avoid\n-/// running name resolution.\n+/// This sits in-between raw syntax and name resolution and allows us to avoid\n+/// recomputing name res: if two instance of `InputModuleItems` are the same, we\n+/// can avoid redoing name resolution.\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct InputModuleItems {\n     pub(crate) items: Vec<ModuleItem>,\n@@ -114,7 +114,7 @@ enum ImportKind {\n     Named(NamedImport),\n }\n \n-/// Resolution is basically `DefId` atm, but it should account for stuff like\n+/// `Resolution` is basically `DefId` atm, but it should account for stuff like\n /// multiple namespaces, ambiguity and errors.\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Resolution {"}, {"sha": "1f149a366f4ae583685b1a9a8c9ef8f45fded6b2", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -1,4 +1,4 @@\n-/// Lookup hir elements using position in the source code. This is a lossy\n+/// Lookup hir elements using positions in the source code. This is a lossy\n /// transformation: in general, a single source might correspond to several\n /// modules, functions, etc, due to macros, cfgs and `#[path=]` attributes on\n /// modules."}, {"sha": "3b2bfd67ac5d69860384192688f66dc90a54c295", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -144,7 +144,7 @@ pub enum Ty {\n     Bool,\n \n     /// The primitive character type; holds a Unicode scalar value\n-    /// (a non-surrogate code point).  Written as `char`.\n+    /// (a non-surrogate code point). Written as `char`.\n     Char,\n \n     /// A primitive signed integer type. For example, `i32`.\n@@ -204,7 +204,7 @@ pub enum Ty {\n     // `|a| yield a`.\n     // Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n \n-    // A type representin the types stored inside a generator.\n+    // A type representing the types stored inside a generator.\n     // This should only appear in GeneratorInteriors.\n     // GeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n     /// The never type `!`."}, {"sha": "d95879e465aea6e88a7871aaede7a5bd362c7013", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -1,4 +1,4 @@\n-//! In certain situations, rust automatically inserts derefs as necessary: For\n+//! In certain situations, rust automatically inserts derefs as necessary: for\n //! example, field accesses `foo.bar` still work when `foo` is actually a\n //! reference to a type with the field `bar`. This is an approximation of the\n //! logic in rustc (which lives in librustc_typeck/check/autoderef.rs)."}, {"sha": "ba2a444743c54656b416cb1ad9bc21dc3595f2ed", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -15,7 +15,7 @@ use crate::{\n };\n \n // These tests compare the inference results for all expressions in a file\n-// against snapshots of the current results. If you change something and these\n+// against snapshots of the expected results. If you change something and these\n // tests fail expectedly, you can update the comparison files by deleting them\n // and running the tests again. Similarly, to add a new test, just write the\n // test here in the same pattern and it will automatically write the snapshot."}, {"sha": "fbe1421a4e4fa72f0cebab05da1aebf6e24014bb", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -121,9 +121,11 @@ impl AnalysisChange {\n     pub fn new() -> AnalysisChange {\n         AnalysisChange::default()\n     }\n+\n     pub fn add_root(&mut self, root_id: SourceRootId, is_local: bool) {\n         self.new_roots.push((root_id, is_local));\n     }\n+\n     pub fn add_file(\n         &mut self,\n         root_id: SourceRootId,\n@@ -142,9 +144,11 @@ impl AnalysisChange {\n             .added\n             .push(file);\n     }\n+\n     pub fn change_file(&mut self, file_id: FileId, new_text: Arc<String>) {\n         self.files_changed.push((file_id, new_text))\n     }\n+\n     pub fn remove_file(&mut self, root_id: SourceRootId, file_id: FileId, path: RelativePathBuf) {\n         let file = RemoveFile { file_id, path };\n         self.roots_changed\n@@ -153,9 +157,11 @@ impl AnalysisChange {\n             .removed\n             .push(file);\n     }\n+\n     pub fn add_library(&mut self, data: LibraryData) {\n         self.libraries_added.push(data)\n     }\n+\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         self.crate_graph = Some(graph);\n     }\n@@ -218,15 +224,19 @@ impl Query {\n             limit: usize::max_value(),\n         }\n     }\n+\n     pub fn only_types(&mut self) {\n         self.only_types = true;\n     }\n+\n     pub fn libs(&mut self) {\n         self.libs = true;\n     }\n+\n     pub fn exact(&mut self) {\n         self.exact = true;\n     }\n+\n     pub fn limit(&mut self, limit: usize) {\n         self.limit = limit\n     }\n@@ -257,15 +267,19 @@ impl NavigationTarget {\n             ptr: Some(symbol.ptr.clone()),\n         }\n     }\n+\n     pub fn name(&self) -> &SmolStr {\n         &self.name\n     }\n+\n     pub fn kind(&self) -> SyntaxKind {\n         self.kind\n     }\n+\n     pub fn file_id(&self) -> FileId {\n         self.file_id\n     }\n+\n     pub fn range(&self) -> TextRange {\n         self.range\n     }\n@@ -305,6 +319,7 @@ impl AnalysisHost {\n             db: self.db.snapshot(),\n         }\n     }\n+\n     /// Applies changes to the current state of the world. If there are\n     /// outstanding snapshots, they will be canceled.\n     pub fn apply_change(&mut self, change: AnalysisChange) {\n@@ -326,30 +341,36 @@ impl Analysis {\n     pub fn file_text(&self, file_id: FileId) -> Arc<String> {\n         self.db.file_text(file_id)\n     }\n+\n     /// Gets the syntax tree of the file.\n     pub fn file_syntax(&self, file_id: FileId) -> TreePtr<SourceFile> {\n         self.db.source_file(file_id).clone()\n     }\n+\n     /// Gets the file's `LineIndex`: data structure to convert between absolute\n     /// offsets and line/column representation.\n     pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n         self.db.line_index(file_id)\n     }\n+\n     /// Selects the next syntactic nodes encopasing the range.\n     pub fn extend_selection(&self, frange: FileRange) -> TextRange {\n         extend_selection::extend_selection(&self.db, frange)\n     }\n+\n     /// Returns position of the mathcing brace (all types of braces are\n     /// supported).\n     pub fn matching_brace(&self, file: &SourceFile, offset: TextUnit) -> Option<TextUnit> {\n         ra_ide_api_light::matching_brace(file, offset)\n     }\n+\n     /// Returns a syntax tree represented as `String`, for debug purposes.\n     // FIXME: use a better name here.\n     pub fn syntax_tree(&self, file_id: FileId) -> String {\n         let file = self.db.source_file(file_id);\n         ra_ide_api_light::syntax_tree(&file)\n     }\n+\n     /// Returns an edit to remove all newlines in the range, cleaning up minor\n     /// stuff like trailing commas.\n     pub fn join_lines(&self, frange: FileRange) -> SourceChange {\n@@ -359,13 +380,15 @@ impl Analysis {\n             ra_ide_api_light::join_lines(&file, frange.range),\n         )\n     }\n+\n     /// Returns an edit which should be applied when opening a new line, fixing\n     /// up minor stuff like continuing the comment.\n     pub fn on_enter(&self, position: FilePosition) -> Option<SourceChange> {\n         let file = self.db.source_file(position.file_id);\n         let edit = ra_ide_api_light::on_enter(&file, position.offset)?;\n         Some(SourceChange::from_local_edit(position.file_id, edit))\n     }\n+\n     /// Returns an edit which should be applied after `=` was typed. Primarily,\n     /// this works when adding `let =`.\n     // FIXME: use a snippet completion instead of this hack here.\n@@ -374,23 +397,27 @@ impl Analysis {\n         let edit = ra_ide_api_light::on_eq_typed(&file, position.offset)?;\n         Some(SourceChange::from_local_edit(position.file_id, edit))\n     }\n+\n     /// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n     pub fn on_dot_typed(&self, position: FilePosition) -> Option<SourceChange> {\n         let file = self.db.source_file(position.file_id);\n         let edit = ra_ide_api_light::on_dot_typed(&file, position.offset)?;\n         Some(SourceChange::from_local_edit(position.file_id, edit))\n     }\n+\n     /// Returns a tree representation of symbols in the file. Useful to draw a\n     /// file outline.\n     pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n         let file = self.db.source_file(file_id);\n         ra_ide_api_light::file_structure(&file)\n     }\n+\n     /// Returns the set of folding ranges.\n     pub fn folding_ranges(&self, file_id: FileId) -> Vec<Fold> {\n         let file = self.db.source_file(file_id);\n         ra_ide_api_light::folding_ranges(&file)\n     }\n+\n     /// Fuzzy searches for a symbol.\n     pub fn symbol_search(&self, query: Query) -> Cancelable<Vec<NavigationTarget>> {\n         let res = symbol_index::world_symbols(&*self.db, query)?\n@@ -399,62 +426,76 @@ impl Analysis {\n             .collect();\n         Ok(res)\n     }\n+\n     pub fn goto_definition(\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Option<Vec<NavigationTarget>>> {\n         goto_definition::goto_definition(&*self.db, position)\n     }\n+\n     /// Finds all usages of the reference at point.\n     pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n         self.db.find_all_refs(position)\n     }\n+\n     /// Returns a short text descrbing element at position.\n     pub fn hover(&self, position: FilePosition) -> Cancelable<Option<RangeInfo<String>>> {\n         hover::hover(&*self.db, position)\n     }\n+\n     /// Computes parameter information for the given call expression.\n     pub fn call_info(&self, position: FilePosition) -> Cancelable<Option<CallInfo>> {\n         call_info::call_info(&*self.db, position)\n     }\n+\n     /// Returns a `mod name;` declaration which created the current module.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n         self.db.parent_module(position)\n     }\n+\n     /// Returns crates this file belongs too.\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n         self.db.crate_for(file_id)\n     }\n+\n     /// Returns the root file of the given crate.\n     pub fn crate_root(&self, crate_id: CrateId) -> Cancelable<FileId> {\n         Ok(self.db.crate_graph().crate_root(crate_id))\n     }\n+\n     /// Returns the set of possible targets to run for the current file.\n     pub fn runnables(&self, file_id: FileId) -> Cancelable<Vec<Runnable>> {\n         runnables::runnables(&*self.db, file_id)\n     }\n+\n     /// Computes syntax highlighting for the given file.\n     pub fn highlight(&self, file_id: FileId) -> Cancelable<Vec<HighlightedRange>> {\n         syntax_highlighting::highlight(&*self.db, file_id)\n     }\n+\n     /// Computes completions at the given position.\n     pub fn completions(&self, position: FilePosition) -> Cancelable<Option<Vec<CompletionItem>>> {\n         let completions = completion::completions(&self.db, position)?;\n         Ok(completions.map(|it| it.into()))\n     }\n+\n     /// Computes assists (aks code actons aka intentions) for the given\n     /// position.\n     pub fn assists(&self, frange: FileRange) -> Cancelable<Vec<SourceChange>> {\n         Ok(self.db.assists(frange))\n     }\n+\n     /// Computes the set of diagnostics for the given file.\n     pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n         self.db.diagnostics(file_id)\n     }\n+\n     /// Computes the type of the expression at the given position.\n     pub fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n         hover::type_of(&*self.db, frange)\n     }\n+\n     /// Returns the edit required to rename reference at the position to the new\n     /// name.\n     pub fn rename("}, {"sha": "7fc0b8f50ad5f041426dcbd235c8497d26b2fe68", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8fbb4fad97d2980f0070a23f5365a5ed887e2a/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=0b8fbb4fad97d2980f0070a23f5365a5ed887e2a", "patch": "@@ -326,7 +326,7 @@ fn on_notification(\n             if pending_requests.remove(&id) {\n                 let response = RawResponse::err(\n                     id,\n-                    ErrorCode::RequestCancelled as i32,\n+                    ErrorCode::RequestCanceled as i32,\n                     \"canceled by client\".to_string(),\n                 );\n                 msg_sender.send(RawMessage::Response(response)).unwrap()"}]}