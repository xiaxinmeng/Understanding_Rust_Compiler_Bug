{"sha": "a8e3abd04cf85080d921c2d1875e0094b2db5155", "node_id": "C_kwDOAAsO6NoAKGE4ZTNhYmQwNGNmODUwODBkOTIxYzJkMTg3NWUwMDk0YjJkYjUxNTU", "commit": {"author": {"name": "mejrs", "email": "", "date": "2023-01-08T00:37:22Z"}, "committer": {"name": "mejrs", "email": "", "date": "2023-01-11T23:11:32Z"}, "message": "Address feedback", "tree": {"sha": "d02e0ba92d23c51baa2756343a225b7b2e74defe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d02e0ba92d23c51baa2756343a225b7b2e74defe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8e3abd04cf85080d921c2d1875e0094b2db5155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e3abd04cf85080d921c2d1875e0094b2db5155", "html_url": "https://github.com/rust-lang/rust/commit/a8e3abd04cf85080d921c2d1875e0094b2db5155", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8e3abd04cf85080d921c2d1875e0094b2db5155/comments", "author": {}, "committer": {}, "parents": [{"sha": "f92000816e0cf8bdfe6ad422464ce0fa6144b496", "url": "https://api.github.com/repos/rust-lang/rust/commits/f92000816e0cf8bdfe6ad422464ce0fa6144b496", "html_url": "https://github.com/rust-lang/rust/commit/f92000816e0cf8bdfe6ad422464ce0fa6144b496"}], "stats": {"total": 86, "additions": 63, "deletions": 23}, "files": [{"sha": "c2ce46d965cf35d4e6ff8f728b08dcd6e7bceab0", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a8e3abd04cf85080d921c2d1875e0094b2db5155/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e3abd04cf85080d921c2d1875e0094b2db5155/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=a8e3abd04cf85080d921c2d1875e0094b2db5155", "patch": "@@ -23,6 +23,7 @@ use rustc_hir::{\n use rustc_hir::{MethodKind, Target, Unsafety};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{ParamEnv, TyCtxt};\n use rustc_session::lint::builtin::{\n@@ -84,6 +85,8 @@ impl IntoDiagnosticArg for ProcMacroKind {\n \n struct CheckAttrVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n+\n+    // Whether or not this visitor should abort after finding errors\n     abort: Cell<bool>,\n }\n \n@@ -2084,6 +2087,9 @@ impl CheckAttrVisitor<'_> {\n         );\n     }\n \n+    /// A best effort attempt to create an error for a mismatching proc macro signature.\n+    ///\n+    /// If this best effort goes wrong, it will just emit a worse error later (see #102923)\n     fn check_proc_macro(&self, hir_id: HirId, target: Target, kind: ProcMacroKind) {\n         let expected_input_count = match kind {\n             ProcMacroKind::Attribute => 2,\n@@ -2103,23 +2109,30 @@ impl CheckAttrVisitor<'_> {\n             let id = hir_id.expect_owner();\n             let hir_sig = tcx.hir().fn_sig_by_hir_id(hir_id).unwrap();\n \n-            let sig = tcx.fn_sig(id);\n+            let sig = tcx.liberate_late_bound_regions(id.to_def_id(), tcx.fn_sig(id));\n+            let sig = tcx.normalize_erasing_regions(ParamEnv::empty(), sig);\n+\n+            // We don't currently require that the function signature is equal to\n+            // `fn(TokenStream) -> TokenStream`, but instead monomorphizes to\n+            // `fn(TokenStream) -> TokenStream` after some substitution of generic arguments.\n+            //\n+            // Properly checking this means pulling in additional `rustc` crates, so we don't.\n+            let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n \n-            if sig.abi() != Abi::Rust {\n-                tcx.sess\n-                    .emit_err(ProcMacroInvalidAbi { span: hir_sig.span, abi: sig.abi().name() });\n+            if sig.abi != Abi::Rust {\n+                tcx.sess.emit_err(ProcMacroInvalidAbi { span: hir_sig.span, abi: sig.abi.name() });\n                 self.abort.set(true);\n             }\n \n-            if sig.unsafety() == Unsafety::Unsafe {\n+            if sig.unsafety == Unsafety::Unsafe {\n                 tcx.sess.emit_err(ProcMacroUnsafe { span: hir_sig.span });\n                 self.abort.set(true);\n             }\n \n-            let output = sig.output().skip_binder();\n+            let output = sig.output();\n \n             // Typecheck the output\n-            if tcx.normalize_erasing_regions(ParamEnv::empty(), output) != tokenstream {\n+            if !drcx.types_may_unify(output, tokenstream) {\n                 tcx.sess.emit_err(ProcMacroTypeError {\n                     span: hir_sig.decl.output.span(),\n                     found: output,\n@@ -2129,11 +2142,22 @@ impl CheckAttrVisitor<'_> {\n                 self.abort.set(true);\n             }\n \n-            // Typecheck \"expected_input_count\" inputs, emitting\n-            // `ProcMacroMissingArguments` if there are not enough.\n-            if let Some(args) = sig.inputs().skip_binder().get(0..expected_input_count) {\n-                for (arg, input) in args.iter().zip(hir_sig.decl.inputs) {\n-                    if tcx.normalize_erasing_regions(ParamEnv::empty(), *arg) != tokenstream {\n+            if sig.inputs().len() < expected_input_count {\n+                tcx.sess.emit_err(ProcMacroMissingArguments {\n+                    expected_input_count,\n+                    span: hir_sig.span,\n+                    kind,\n+                    expected_signature,\n+                });\n+                self.abort.set(true);\n+            }\n+\n+            // Check that the inputs are correct, if there are enough.\n+            if sig.inputs().len() >= expected_input_count {\n+                for (arg, input) in\n+                    sig.inputs().iter().zip(hir_sig.decl.inputs).take(expected_input_count)\n+                {\n+                    if !drcx.types_may_unify(*arg, tokenstream) {\n                         tcx.sess.emit_err(ProcMacroTypeError {\n                             span: input.span,\n                             found: *arg,\n@@ -2143,14 +2167,6 @@ impl CheckAttrVisitor<'_> {\n                         self.abort.set(true);\n                     }\n                 }\n-            } else {\n-                tcx.sess.emit_err(ProcMacroMissingArguments {\n-                    expected_input_count,\n-                    span: hir_sig.span,\n-                    kind,\n-                    expected_signature,\n-                });\n-                self.abort.set(true);\n             }\n \n             // Check that there are not too many arguments"}, {"sha": "03c6ef86632df658b7c1372f0f946075f8849a00", "filename": "tests/ui/proc-macro/allowed-signatures.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a8e3abd04cf85080d921c2d1875e0094b2db5155/tests%2Fui%2Fproc-macro%2Fallowed-signatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e3abd04cf85080d921c2d1875e0094b2db5155/tests%2Fui%2Fproc-macro%2Fallowed-signatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fallowed-signatures.rs?ref=a8e3abd04cf85080d921c2d1875e0094b2db5155", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+\n+#![crate_type = \"proc-macro\"]\n+#![allow(private_in_public)]\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn foo<T>(t: T) -> TokenStream {\n+  TokenStream::new()\n+}\n+\n+trait Project {\n+    type Assoc;\n+}\n+\n+impl Project for () {\n+    type Assoc = TokenStream;\n+}\n+\n+#[proc_macro]\n+pub fn uwu(_input: <() as Project>::Assoc) -> <() as Project>::Assoc {\n+    TokenStream::new()\n+}"}, {"sha": "8e9d50d7832d5a49e53d4f0405b976d158e1b6e8", "filename": "tests/ui/proc-macro/proc-macro-abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8e3abd04cf85080d921c2d1875e0094b2db5155/tests%2Fui%2Fproc-macro%2Fproc-macro-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e3abd04cf85080d921c2d1875e0094b2db5155/tests%2Fui%2Fproc-macro%2Fproc-macro-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fproc-macro-abi.rs?ref=a8e3abd04cf85080d921c2d1875e0094b2db5155", "patch": "@@ -6,19 +6,19 @@ use proc_macro::TokenStream;\n \n #[proc_macro]\n pub extern \"C\" fn abi(a: TokenStream) -> TokenStream {\n-    //~^ ERROR proc macro functions may not be `extern\n+    //~^ ERROR proc macro functions may not be `extern \"C\"`\n     a\n }\n \n #[proc_macro]\n pub extern \"system\" fn abi2(a: TokenStream) -> TokenStream {\n-    //~^ ERROR proc macro functions may not be `extern\n+    //~^ ERROR proc macro functions may not be `extern \"system\"`\n     a\n }\n \n #[proc_macro]\n pub extern fn abi3(a: TokenStream) -> TokenStream {\n-    //~^ ERROR proc macro functions may not be `extern\n+    //~^ ERROR proc macro functions may not be `extern \"C\"`\n     a\n }\n "}]}