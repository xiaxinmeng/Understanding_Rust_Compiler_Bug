{"sha": "86eb262e8a2d270cc8195185b217710f815761b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZWIyNjJlOGEyZDI3MGNjODE5NTE4NWIyMTc3MTBmODE1NzYxYjM=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-30T22:37:27Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-24T22:02:54Z"}, "message": "Cleanup Condvar tests.", "tree": {"sha": "5c993bb2c948665dc95195a1014cfbae07e0ba3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c993bb2c948665dc95195a1014cfbae07e0ba3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86eb262e8a2d270cc8195185b217710f815761b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86eb262e8a2d270cc8195185b217710f815761b3", "html_url": "https://github.com/rust-lang/rust/commit/86eb262e8a2d270cc8195185b217710f815761b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86eb262e8a2d270cc8195185b217710f815761b3/comments", "author": null, "committer": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a303b13095122c2007bf8751bdbc0e89b8708d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a303b13095122c2007bf8751bdbc0e89b8708d3", "html_url": "https://github.com/rust-lang/rust/commit/4a303b13095122c2007bf8751bdbc0e89b8708d3"}], "stats": {"total": 280, "additions": 102, "deletions": 178}, "files": [{"sha": "a586be8139ba5303731b013c3442fff9a175fe1e", "filename": "src/shims/sync.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/86eb262e8a2d270cc8195185b217710f815761b3/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86eb262e8a2d270cc8195185b217710f815761b3/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=86eb262e8a2d270cc8195185b217710f815761b3", "patch": "@@ -1,4 +1,5 @@\n use std::time::{Duration, SystemTime};\n+use std::convert::TryInto;\n \n use rustc_middle::ty::{layout::TyAndLayout, TyKind, TypeAndMut};\n use rustc_target::abi::{LayoutOf, Size};\n@@ -719,12 +720,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let mut offset = Size::from_bytes(0);\n             let layout = this.libc_ty_layout(\"time_t\")?;\n             let seconds_place = tp.offset(offset, MemPlaceMeta::None, layout, this)?;\n-            let seconds = this.read_scalar(seconds_place.into())?.to_u64()?;\n+            let seconds = this.read_scalar(seconds_place.into())?;\n             offset += layout.size;\n             let layout = this.libc_ty_layout(\"c_long\")?;\n             let nanoseconds_place = tp.offset(offset, MemPlaceMeta::None, layout, this)?;\n-            let nanoseconds = this.read_scalar(nanoseconds_place.into())?.to_u64()?;\n-            Duration::new(seconds, nanoseconds as u32)\n+            let nanoseconds = this.read_scalar(nanoseconds_place.into())?;\n+            let (seconds, nanoseconds) = if this.pointer_size().bytes() == 8 {\n+                (seconds.to_u64()?, nanoseconds.to_u64()?.try_into().unwrap())\n+            } else {\n+                (seconds.to_u32()?.into(), nanoseconds.to_u32()?)\n+            };\n+            Duration::new(seconds, nanoseconds)\n         };\n \n         let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {"}, {"sha": "9b7a06b431c0469dece0e246e0b292752ae10b42", "filename": "tests/run-pass/concurrency/libc_pthread_cond.rs", "status": "modified", "additions": 44, "deletions": 168, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/86eb262e8a2d270cc8195185b217710f815761b3/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86eb262e8a2d270cc8195185b217710f815761b3/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs?ref=86eb262e8a2d270cc8195185b217710f815761b3", "patch": "@@ -1,199 +1,75 @@\n // ignore-windows: No libc on Windows\n+// ignore-macos: pthread_condattr_setclock is not supported on MacOS.\n // compile-flags: -Zmiri-disable-isolation\n \n #![feature(rustc_private)]\n \n+/// Test that conditional variable timeouts are working properly with both\n+/// monotonic and system clocks.\n extern crate libc;\n \n-use std::cell::UnsafeCell;\n-use std::mem::{self, MaybeUninit};\n-use std::sync::Arc;\n-use std::thread;\n+use std::mem;\n+use std::time::Instant;\n \n-struct Mutex {\n-    inner: UnsafeCell<libc::pthread_mutex_t>,\n-}\n-\n-unsafe impl Sync for Mutex {}\n-\n-impl std::fmt::Debug for Mutex {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"Mutex\")\n-    }\n-}\n-\n-struct Cond {\n-    inner: UnsafeCell<libc::pthread_cond_t>,\n-}\n-\n-unsafe impl Sync for Cond {}\n-\n-impl std::fmt::Debug for Cond {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"Cond\")\n-    }\n-}\n-\n-unsafe fn create_cond_attr_monotonic() -> libc::pthread_condattr_t {\n-    let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n-    assert_eq!(libc::pthread_condattr_init(attr.as_mut_ptr()), 0);\n-    assert_eq!(libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC), 0);\n-    attr.assume_init()\n-}\n-\n-unsafe fn create_cond(attr: Option<libc::pthread_condattr_t>) -> Cond {\n-    let cond: Cond = mem::zeroed();\n-    if let Some(mut attr) = attr {\n-        assert_eq!(libc::pthread_cond_init(cond.inner.get() as *mut _, &attr as *const _), 0);\n-        assert_eq!(libc::pthread_condattr_destroy(&mut attr as *mut _), 0);\n-    } else {\n-        assert_eq!(libc::pthread_cond_init(cond.inner.get() as *mut _, 0 as *const _), 0);\n-    }\n-    cond\n-}\n-\n-unsafe fn create_mutex() -> Mutex {\n-    mem::zeroed()\n-}\n-\n-unsafe fn create_timeout(seconds: i64) -> libc::timespec {\n-    let mut now: libc::timespec = mem::zeroed();\n-    assert_eq!(libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now), 0);\n-    libc::timespec { tv_sec: now.tv_sec + seconds, tv_nsec: now.tv_nsec }\n-}\n-\n-fn test_pthread_condattr_t() {\n+fn test_timed_wait_timeout_monotonic() {\n     unsafe {\n-        let mut attr = create_cond_attr_monotonic();\n-        let mut clock_id = MaybeUninit::<libc::clockid_t>::uninit();\n-        assert_eq!(libc::pthread_condattr_getclock(&attr as *const _, clock_id.as_mut_ptr()), 0);\n-        assert_eq!(clock_id.assume_init(), libc::CLOCK_MONOTONIC);\n-        assert_eq!(libc::pthread_condattr_destroy(&mut attr as *mut _), 0);\n-    }\n-}\n+        let mut attr: libc::pthread_condattr_t = mem::zeroed();\n+        assert_eq!(libc::pthread_condattr_init(&mut attr as *mut _), 0);\n+        assert_eq!(libc::pthread_condattr_setclock(&mut attr as *mut _, libc::CLOCK_MONOTONIC), 0);\n \n-fn test_signal() {\n-    unsafe {\n-        let cond = Arc::new(create_cond(None));\n-        let mutex = Arc::new(create_mutex());\n+        let mut cond: libc::pthread_cond_t = mem::zeroed();\n+        assert_eq!(libc::pthread_cond_init(&mut cond as *mut _, &attr as *const _), 0);\n+        assert_eq!(libc::pthread_condattr_destroy(&mut attr as *mut _), 0);\n \n-        assert_eq!(libc::pthread_mutex_lock(mutex.inner.get() as *mut _), 0);\n+        let mut mutex: libc::pthread_mutex_t = mem::zeroed();\n \n-        let spawn_mutex = Arc::clone(&mutex);\n-        let spawn_cond = Arc::clone(&cond);\n-        let handle = thread::spawn(move || {\n-            assert_eq!(libc::pthread_mutex_lock(spawn_mutex.inner.get() as *mut _), 0);\n-            assert_eq!(libc::pthread_cond_signal(spawn_cond.inner.get() as *mut _), 0);\n-            assert_eq!(libc::pthread_mutex_unlock(spawn_mutex.inner.get() as *mut _), 0);\n-        });\n+        let mut now: libc::timespec = mem::zeroed();\n+        assert_eq!(libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now), 0);\n+        let timeout = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: now.tv_nsec };\n \n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        let current_time = Instant::now();\n         assert_eq!(\n-            libc::pthread_cond_wait(cond.inner.get() as *mut _, mutex.inner.get() as *mut _),\n-            0\n+            libc::pthread_cond_timedwait(&mut cond as *mut _, &mut mutex as *mut _, &timeout),\n+            libc::ETIMEDOUT\n         );\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.inner.get() as *mut _), 0);\n-\n-        handle.join().unwrap();\n-\n-        let mutex = Arc::try_unwrap(mutex).unwrap();\n-        assert_eq!(libc::pthread_mutex_destroy(mutex.inner.get() as *mut _), 0);\n-        let cond = Arc::try_unwrap(cond).unwrap();\n-        assert_eq!(libc::pthread_cond_destroy(cond.inner.get() as *mut _), 0);\n+        assert!(current_time.elapsed().as_millis() >= 900);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_cond_destroy(&mut cond as *mut _), 0);\n     }\n }\n \n-fn test_broadcast() {\n+fn test_timed_wait_timeout_realtime() {\n     unsafe {\n-        let cond = Arc::new(create_cond(None));\n-        let mutex = Arc::new(create_mutex());\n-\n-        assert_eq!(libc::pthread_mutex_lock(mutex.inner.get() as *mut _), 0);\n-\n-        let spawn_mutex = Arc::clone(&mutex);\n-        let spawn_cond = Arc::clone(&cond);\n-        let handle = thread::spawn(move || {\n-            assert_eq!(libc::pthread_mutex_lock(spawn_mutex.inner.get() as *mut _), 0);\n-            assert_eq!(libc::pthread_cond_broadcast(spawn_cond.inner.get() as *mut _), 0);\n-            assert_eq!(libc::pthread_mutex_unlock(spawn_mutex.inner.get() as *mut _), 0);\n-        });\n+        let mut attr: libc::pthread_condattr_t = mem::zeroed();\n+        assert_eq!(libc::pthread_condattr_init(&mut attr as *mut _), 0);\n+        assert_eq!(libc::pthread_condattr_setclock(&mut attr as *mut _, libc::CLOCK_REALTIME), 0);\n \n-        assert_eq!(\n-            libc::pthread_cond_wait(cond.inner.get() as *mut _, mutex.inner.get() as *mut _),\n-            0\n-        );\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.inner.get() as *mut _), 0);\n+        let mut cond: libc::pthread_cond_t = mem::zeroed();\n+        assert_eq!(libc::pthread_cond_init(&mut cond as *mut _, &attr as *const _), 0);\n+        assert_eq!(libc::pthread_condattr_destroy(&mut attr as *mut _), 0);\n \n-        handle.join().unwrap();\n+        let mut mutex: libc::pthread_mutex_t = mem::zeroed();\n \n-        let mutex = Arc::try_unwrap(mutex).unwrap();\n-        assert_eq!(libc::pthread_mutex_destroy(mutex.inner.get() as *mut _), 0);\n-        let cond = Arc::try_unwrap(cond).unwrap();\n-        assert_eq!(libc::pthread_cond_destroy(cond.inner.get() as *mut _), 0);\n-    }\n-}\n+        let mut now: libc::timespec = mem::zeroed();\n+        assert_eq!(libc::clock_gettime(libc::CLOCK_REALTIME, &mut now), 0);\n+        let timeout = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: now.tv_nsec };\n \n-fn test_timed_wait_timeout() {\n-    unsafe {\n-        let attr = create_cond_attr_monotonic();\n-        let cond = create_cond(Some(attr));\n-        let mutex = create_mutex();\n-        let timeout = create_timeout(1);\n-\n-        assert_eq!(libc::pthread_mutex_lock(mutex.inner.get() as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        let current_time = Instant::now();\n         assert_eq!(\n-            libc::pthread_cond_timedwait(\n-                cond.inner.get() as *mut _,\n-                mutex.inner.get() as *mut _,\n-                &timeout\n-            ),\n+            libc::pthread_cond_timedwait(&mut cond as *mut _, &mut mutex as *mut _, &timeout),\n             libc::ETIMEDOUT\n         );\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.inner.get() as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_destroy(mutex.inner.get() as *mut _), 0);\n-        assert_eq!(libc::pthread_cond_destroy(cond.inner.get() as *mut _), 0);\n-    }\n-}\n-\n-fn test_timed_wait_notimeout() {\n-    unsafe {\n-        let attr = create_cond_attr_monotonic();\n-        let cond = Arc::new(create_cond(Some(attr)));\n-        let mutex = Arc::new(create_mutex());\n-        let timeout = create_timeout(100);\n-\n-        assert_eq!(libc::pthread_mutex_lock(mutex.inner.get() as *mut _), 0);\n-\n-        let spawn_mutex = Arc::clone(&mutex);\n-        let spawn_cond = Arc::clone(&cond);\n-        let handle = thread::spawn(move || {\n-            assert_eq!(libc::pthread_mutex_lock(spawn_mutex.inner.get() as *mut _), 0);\n-            assert_eq!(libc::pthread_cond_signal(spawn_cond.inner.get() as *mut _), 0);\n-            assert_eq!(libc::pthread_mutex_unlock(spawn_mutex.inner.get() as *mut _), 0);\n-        });\n-\n-        assert_eq!(\n-            libc::pthread_cond_timedwait(\n-                cond.inner.get() as *mut _,\n-                mutex.inner.get() as *mut _,\n-                &timeout\n-            ),\n-            0\n-        );\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.inner.get() as *mut _), 0);\n-\n-        handle.join().unwrap();\n-\n-        let mutex = Arc::try_unwrap(mutex).unwrap();\n-        assert_eq!(libc::pthread_mutex_destroy(mutex.inner.get() as *mut _), 0);\n-        let cond = Arc::try_unwrap(cond).unwrap();\n-        assert_eq!(libc::pthread_cond_destroy(cond.inner.get() as *mut _), 0);\n+        assert!(current_time.elapsed().as_millis() >= 900);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_cond_destroy(&mut cond as *mut _), 0);\n     }\n }\n \n fn main() {\n-    test_pthread_condattr_t();\n-    test_signal();\n-    test_broadcast();\n-    test_timed_wait_timeout();\n-    test_timed_wait_notimeout();\n+    test_timed_wait_timeout_monotonic();\n+    test_timed_wait_timeout_realtime();\n }"}, {"sha": "2dbfb7721d3683fb4d82c2ce771e3784be86fdc9", "filename": "tests/run-pass/concurrency/libc_pthread_cond.stderr", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a303b13095122c2007bf8751bdbc0e89b8708d3/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a303b13095122c2007bf8751bdbc0e89b8708d3/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.stderr?ref=4a303b13095122c2007bf8751bdbc0e89b8708d3", "patch": "@@ -1,2 +0,0 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n-"}, {"sha": "e3f3a03b11ae3fc6c5d25112373384efdc176ad2", "filename": "tests/run-pass/concurrency/sync.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/86eb262e8a2d270cc8195185b217710f815761b3/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86eb262e8a2d270cc8195185b217710f815761b3/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsync.rs?ref=86eb262e8a2d270cc8195185b217710f815761b3", "patch": "@@ -31,7 +31,7 @@ fn check_barriers() {\n // Check if Rust conditional variables are working.\n \n /// The test taken from the Rust documentation.\n-fn check_conditional_variables() {\n+fn check_conditional_variables_notify_one() {\n     let pair = Arc::new((Mutex::new(false), Condvar::new()));\n     let pair2 = pair.clone();\n \n@@ -52,17 +52,59 @@ fn check_conditional_variables() {\n     }\n }\n \n+/// The test taken from the Rust documentation.\n+fn check_conditional_variables_notify_all() {\n+    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    let pair2 = pair.clone();\n+\n+    thread::spawn(move || {\n+        let (lock, cvar) = &*pair2;\n+        let mut started = lock.lock().unwrap();\n+        *started = true;\n+        // We notify the condvar that the value has changed.\n+        cvar.notify_all();\n+    });\n+\n+    // Wait for the thread to start up.\n+    let (lock, cvar) = &*pair;\n+    let mut started = lock.lock().unwrap();\n+    // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n+    while !*started {\n+        started = cvar.wait(started).unwrap();\n+    }\n+}\n+\n /// Test that waiting on a conditional variable with a timeout does not\n /// deadlock.\n-fn check_conditional_variables_timeout() {\n+fn check_conditional_variables_timed_wait_timeout() {\n     let lock = Mutex::new(());\n     let cvar = Condvar::new();\n     let guard = lock.lock().unwrap();\n     let now = Instant::now();\n-    let _guard = cvar.wait_timeout(guard, Duration::from_millis(100)).unwrap().0;\n+    let (_guard, timeout) = cvar.wait_timeout(guard, Duration::from_millis(100)).unwrap();\n+    assert!(timeout.timed_out());\n     assert!(now.elapsed().as_millis() >= 100);\n }\n \n+/// Test that signaling a conditional variable when waiting with a timeout works\n+/// as expected.\n+fn check_conditional_variables_timed_wait_notimeout() {\n+    let pair = Arc::new((Mutex::new(()), Condvar::new()));\n+    let pair2 = pair.clone();\n+\n+    let (lock, cvar) = &*pair;\n+    let guard = lock.lock().unwrap();\n+\n+    let handle = thread::spawn(move || {\n+        let (_lock, cvar) = &*pair2;\n+        cvar.notify_one();\n+    });\n+\n+    let (_guard, timeout) = cvar.wait_timeout(guard, Duration::from_millis(100)).unwrap();\n+    assert!(!timeout.timed_out());\n+    handle.join().unwrap();\n+}\n+\n // Check if locks are working.\n \n fn check_mutex() {\n@@ -218,8 +260,10 @@ fn check_once() {\n \n fn main() {\n     check_barriers();\n-    check_conditional_variables();\n-    check_conditional_variables_timeout();\n+    check_conditional_variables_notify_one();\n+    check_conditional_variables_notify_all();\n+    check_conditional_variables_timed_wait_timeout();\n+    check_conditional_variables_timed_wait_notimeout();\n     check_mutex();\n     check_rwlock_write();\n     check_rwlock_read_no_deadlock();"}]}