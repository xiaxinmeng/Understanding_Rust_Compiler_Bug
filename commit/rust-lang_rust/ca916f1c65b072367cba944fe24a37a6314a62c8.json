{"sha": "ca916f1c65b072367cba944fe24a37a6314a62c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhOTE2ZjFjNjViMDcyMzY3Y2JhOTQ0ZmUyNGEzN2E2MzE0YTYyYzg=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-07-20T15:48:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-20T15:48:38Z"}, "message": "Merge pull request #1113 from oli-obk/assign_op\n\nlint `a += a + b` (possible mis-refactoring of `a = a + b`)", "tree": {"sha": "9ea327b9bf4ab5a9760f059b6a649743663f8434", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ea327b9bf4ab5a9760f059b6a649743663f8434"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca916f1c65b072367cba944fe24a37a6314a62c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca916f1c65b072367cba944fe24a37a6314a62c8", "html_url": "https://github.com/rust-lang/rust/commit/ca916f1c65b072367cba944fe24a37a6314a62c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca916f1c65b072367cba944fe24a37a6314a62c8/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3559ec4fc4daaf93951734d8d60a7541579e518", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3559ec4fc4daaf93951734d8d60a7541579e518", "html_url": "https://github.com/rust-lang/rust/commit/e3559ec4fc4daaf93951734d8d60a7541579e518"}, {"sha": "f7f9930b891da8cd8616bec8b3b63fb8c8406123", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f9930b891da8cd8616bec8b3b63fb8c8406123", "html_url": "https://github.com/rust-lang/rust/commit/f7f9930b891da8cd8616bec8b3b63fb8c8406123"}], "stats": {"total": 145, "additions": 128, "deletions": 17}, "files": [{"sha": "d15b08016658f8580bbdfb811434ff2b2503dcb6", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca916f1c65b072367cba944fe24a37a6314a62c8/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ca916f1c65b072367cba944fe24a37a6314a62c8/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=ca916f1c65b072367cba944fe24a37a6314a62c8", "patch": "@@ -207,6 +207,7 @@ All notable changes to this project will be documented in this file.\n [`match_same_arms`]: https://github.com/Manishearth/rust-clippy/wiki#match_same_arms\n [`mem_forget`]: https://github.com/Manishearth/rust-clippy/wiki#mem_forget\n [`min_max`]: https://github.com/Manishearth/rust-clippy/wiki#min_max\n+[`misrefactored_assign_op`]: https://github.com/Manishearth/rust-clippy/wiki#misrefactored_assign_op\n [`modulo_one`]: https://github.com/Manishearth/rust-clippy/wiki#modulo_one\n [`mut_mut`]: https://github.com/Manishearth/rust-clippy/wiki#mut_mut\n [`mutex_atomic`]: https://github.com/Manishearth/rust-clippy/wiki#mutex_atomic"}, {"sha": "ed315a0ca8fa46837bbfcb1d76e6ad36110f12fa", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca916f1c65b072367cba944fe24a37a6314a62c8/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ca916f1c65b072367cba944fe24a37a6314a62c8/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ca916f1c65b072367cba944fe24a37a6314a62c8", "patch": "@@ -17,7 +17,7 @@ Table of contents:\n \n ## Lints\n \n-There are 159 lints included in this crate:\n+There are 160 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -97,6 +97,7 @@ name\n [match_same_arms](https://github.com/Manishearth/rust-clippy/wiki#match_same_arms)                                   | warn    | `match` with identical arm bodies\n [mem_forget](https://github.com/Manishearth/rust-clippy/wiki#mem_forget)                                             | allow   | `mem::forget` usage on `Drop` types is likely to cause memory leaks\n [min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                                   | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n+[misrefactored_assign_op](https://github.com/Manishearth/rust-clippy/wiki#misrefactored_assign_op)                   | warn    | having a variable on both sides of an assign op\n [modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                                             | warn    | taking a number modulo 1, which always returns 0\n [mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                                   | allow   | usage of double-mut refs, e.g. `&mut &mut ...`\n [mutex_atomic](https://github.com/Manishearth/rust-clippy/wiki#mutex_atomic)                                         | warn    | using a mutex where an atomic value could be used instead"}, {"sha": "3327482f09d52e0f67c58bc6ca6b3f819a123ca6", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 88, "deletions": 16, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ca916f1c65b072367cba944fe24a37a6314a62c8/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca916f1c65b072367cba944fe24a37a6314a62c8/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=ca916f1c65b072367cba944fe24a37a6314a62c8", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::lint::*;\n-use utils::{span_lint_and_then, span_lint, snippet_opt, SpanlessEq, get_trait_def_id, implements_trait};\n+use utils::{span_lint_and_then, snippet_opt, SpanlessEq, get_trait_def_id, implements_trait};\n use utils::{higher, sugg};\n \n /// **What it does:** This lint checks for `+=` operations and similar.\n@@ -38,12 +38,31 @@ declare_lint! {\n     \"assigning the result of an operation on a variable to that same variable\"\n }\n \n+/// **What it does:** Check for `a op= a op b` or `a op= b op a` patterns.\n+///\n+/// **Why is this bad?** Most likely these are bugs where one meant to write `a op= b`\n+///\n+/// **Known problems:** Someone might actually mean `a op= a op b`, but that should rather be written as `a = (2 * a) op b` where applicable.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// let mut a = 5;\n+/// ...\n+/// a += a + b;\n+/// ```\n+declare_lint! {\n+    pub MISREFACTORED_ASSIGN_OP,\n+    Warn,\n+    \"having a variable on both sides of an assign op\"\n+}\n+\n #[derive(Copy, Clone, Default)]\n pub struct AssignOps;\n \n impl LintPass for AssignOps {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(ASSIGN_OPS, ASSIGN_OP_PATTERN)\n+        lint_array!(ASSIGN_OPS, ASSIGN_OP_PATTERN, MISREFACTORED_ASSIGN_OP)\n     }\n }\n \n@@ -59,6 +78,40 @@ impl LateLintPass for AssignOps {\n                                        \"replace it with\",\n                                        format!(\"{} = {}\", lhs, sugg::make_binop(higher::binop(op.node), lhs, rhs)));\n                 });\n+                if let hir::ExprBinary(binop, ref l, ref r) = rhs.node {\n+                    if op.node == binop.node {\n+                        let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n+                            let ty = cx.tcx.expr_ty(assignee);\n+                            if ty.walk_shallow().next().is_some() {\n+                                return; // implements_trait does not work with generics\n+                            }\n+                            let rty = cx.tcx.expr_ty(rhs);\n+                            if rty.walk_shallow().next().is_some() {\n+                                return; // implements_trait does not work with generics\n+                            }\n+                            span_lint_and_then(cx,\n+                                               MISREFACTORED_ASSIGN_OP,\n+                                               expr.span,\n+                                               \"variable appears on both sides of an assignment operation\",\n+                                               |db| {\n+                                                   if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span),\n+                                                                                          snippet_opt(cx, rhs.span)) {\n+                                                       db.span_suggestion(expr.span,\n+                                                                          \"replace it with\",\n+                                                                          format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n+                                                   }\n+                                               });\n+                        };\n+                        // lhs op= l op r\n+                        if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n+                            lint(lhs, r);\n+                        }\n+                        // lhs op= l commutative_op r\n+                        if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n+                            lint(lhs, l);\n+                        }\n+                    }\n+                }\n             }\n             hir::ExprAssign(ref assignee, ref e) => {\n                 if let hir::ExprBinary(op, ref l, ref r) = e.node {\n@@ -104,23 +157,18 @@ impl LateLintPass for AssignOps {\n                                 BitXor: BiBitXor,\n                                 Shr: BiShr,\n                                 Shl: BiShl) {\n-                            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span),\n-                                                                   snippet_opt(cx, rhs.span)) {\n-                                span_lint_and_then(cx,\n-                                                   ASSIGN_OP_PATTERN,\n-                                                   expr.span,\n-                                                   \"manual implementation of an assign operation\",\n-                                                   |db| {\n+                            span_lint_and_then(cx,\n+                                               ASSIGN_OP_PATTERN,\n+                                               expr.span,\n+                                               \"manual implementation of an assign operation\",\n+                                               |db| {\n+                                                   if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span),\n+                                                                                          snippet_opt(cx, rhs.span)) {\n                                                        db.span_suggestion(expr.span,\n                                                                           \"replace it with\",\n                                                                           format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n-                                                   });\n-                            } else {\n-                                span_lint(cx,\n-                                          ASSIGN_OP_PATTERN,\n-                                          expr.span,\n-                                          \"manual implementation of an assign operation\");\n-                            }\n+                                                   }\n+                                               });\n                         }\n                     };\n                     // a = a op b\n@@ -143,3 +191,27 @@ impl LateLintPass for AssignOps {\n         }\n     }\n }\n+\n+fn is_commutative(op: hir::BinOp_) -> bool {\n+    use rustc::hir::BinOp_::*;\n+    match op {\n+        BiAdd |\n+        BiMul |\n+        BiAnd |\n+        BiOr |\n+        BiBitXor |\n+        BiBitAnd |\n+        BiBitOr |\n+        BiEq |\n+        BiNe => true,\n+        BiSub |\n+        BiDiv |\n+        BiRem |\n+        BiShl |\n+        BiShr |\n+        BiLt |\n+        BiLe |\n+        BiGe |\n+        BiGt => false,\n+    }\n+}"}, {"sha": "d68a99a7b0941decf50e282d1d302de762436bc2", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca916f1c65b072367cba944fe24a37a6314a62c8/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca916f1c65b072367cba944fe24a37a6314a62c8/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ca916f1c65b072367cba944fe24a37a6314a62c8", "patch": "@@ -300,6 +300,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         approx_const::APPROX_CONSTANT,\n         array_indexing::OUT_OF_BOUNDS_INDEXING,\n         assign_ops::ASSIGN_OP_PATTERN,\n+        assign_ops::MISREFACTORED_ASSIGN_OP,\n         attrs::DEPRECATED_SEMVER,\n         attrs::INLINE_ALWAYS,\n         bit_mask::BAD_BIT_MASK,"}, {"sha": "1537232bf1828dd326feeba8fb40d988474e5b13", "filename": "tests/compile-fail/assign_ops2.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ca916f1c65b072367cba944fe24a37a6314a62c8/tests%2Fcompile-fail%2Fassign_ops2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca916f1c65b072367cba944fe24a37a6314a62c8/tests%2Fcompile-fail%2Fassign_ops2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fassign_ops2.rs?ref=ca916f1c65b072367cba944fe24a37a6314a62c8", "patch": "@@ -0,0 +1,36 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[allow(unused_assignments)]\n+#[deny(misrefactored_assign_op)]\n+fn main() {\n+    let mut a = 5;\n+    a += a + 1; //~ ERROR variable appears on both sides of an assignment operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a += 1\n+    a += 1 + a; //~ ERROR variable appears on both sides of an assignment operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a += 1\n+    a -= a - 1; //~ ERROR variable appears on both sides of an assignment operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a -= 1\n+    a *= a * 99; //~ ERROR variable appears on both sides of an assignment operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a *= 99\n+    a *= 42 * a; //~ ERROR variable appears on both sides of an assignment operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a *= 42\n+    a /= a / 2; //~ ERROR variable appears on both sides of an assignment operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a /= 2\n+    a %= a % 5; //~ ERROR variable appears on both sides of an assignment operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a %= 5\n+    a &= a & 1; //~ ERROR variable appears on both sides of an assignment operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a &= 1\n+    a -= 1 - a;\n+    a /= 5 / a;\n+    a %= 42 % a;\n+    a <<= 6 << a;\n+}"}]}