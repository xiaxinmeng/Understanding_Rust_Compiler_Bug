{"sha": "5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "node_id": "C_kwDOAAsO6NoAKDVmMmI4ZTY3YjNhYjVmNzAwZTkwNzZjM2EwYmJhOGJjMmVkNGE3ZjE", "commit": {"author": {"name": "kyoto7250", "email": "50972773+kyoto7250@users.noreply.github.com", "date": "2022-06-07T03:11:33Z"}, "committer": {"name": "kyoto7250", "email": "50972773+kyoto7250@users.noreply.github.com", "date": "2022-06-26T23:11:58Z"}, "message": "feat(new lint): new lint `use_retain`", "tree": {"sha": "16eaba2b6432d01fbaf529148127051f4a12e9b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16eaba2b6432d01fbaf529148127051f4a12e9b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "html_url": "https://github.com/rust-lang/rust/commit/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/comments", "author": {"login": "kyoto7250", "id": 50972773, "node_id": "MDQ6VXNlcjUwOTcyNzcz", "avatar_url": "https://avatars.githubusercontent.com/u/50972773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kyoto7250", "html_url": "https://github.com/kyoto7250", "followers_url": "https://api.github.com/users/kyoto7250/followers", "following_url": "https://api.github.com/users/kyoto7250/following{/other_user}", "gists_url": "https://api.github.com/users/kyoto7250/gists{/gist_id}", "starred_url": "https://api.github.com/users/kyoto7250/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kyoto7250/subscriptions", "organizations_url": "https://api.github.com/users/kyoto7250/orgs", "repos_url": "https://api.github.com/users/kyoto7250/repos", "events_url": "https://api.github.com/users/kyoto7250/events{/privacy}", "received_events_url": "https://api.github.com/users/kyoto7250/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kyoto7250", "id": 50972773, "node_id": "MDQ6VXNlcjUwOTcyNzcz", "avatar_url": "https://avatars.githubusercontent.com/u/50972773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kyoto7250", "html_url": "https://github.com/kyoto7250", "followers_url": "https://api.github.com/users/kyoto7250/followers", "following_url": "https://api.github.com/users/kyoto7250/following{/other_user}", "gists_url": "https://api.github.com/users/kyoto7250/gists{/gist_id}", "starred_url": "https://api.github.com/users/kyoto7250/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kyoto7250/subscriptions", "organizations_url": "https://api.github.com/users/kyoto7250/orgs", "repos_url": "https://api.github.com/users/kyoto7250/repos", "events_url": "https://api.github.com/users/kyoto7250/events{/privacy}", "received_events_url": "https://api.github.com/users/kyoto7250/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b150625a930cd7e0a72a071dd8c1127b5bec451", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b150625a930cd7e0a72a071dd8c1127b5bec451", "html_url": "https://github.com/rust-lang/rust/commit/9b150625a930cd7e0a72a071dd8c1127b5bec451"}], "stats": {"total": 722, "additions": 722, "deletions": 0}, "files": [{"sha": "56143e1cdb9f2f4fce00afb0850588718d75fa89", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "patch": "@@ -3840,6 +3840,7 @@ Released 2018-09-13\n [`unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_used\n [`upper_case_acronyms`]: https://rust-lang.github.io/rust-clippy/master/index.html#upper_case_acronyms\n [`use_debug`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_debug\n+[`use_retain`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_retain\n [`use_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_self\n [`used_underscore_binding`]: https://rust-lang.github.io/rust-clippy/master/index.html#used_underscore_binding\n [`useless_asref`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_asref"}, {"sha": "88e4c291b68f8e0b79892aeb73b98c48e2bccfdd", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "patch": "@@ -336,6 +336,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(unwrap::PANICKING_UNWRAP),\n     LintId::of(unwrap::UNNECESSARY_UNWRAP),\n     LintId::of(upper_case_acronyms::UPPER_CASE_ACRONYMS),\n+    LintId::of(use_retain::USE_RETAIN),\n     LintId::of(useless_conversion::USELESS_CONVERSION),\n     LintId::of(vec::USELESS_VEC),\n     LintId::of(vec_init_then_push::VEC_INIT_THEN_PUSH),"}, {"sha": "187786e80daefa1a0e243a580d87c13ce087cbda", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "patch": "@@ -563,6 +563,7 @@ store.register_lints(&[\n     unwrap::UNNECESSARY_UNWRAP,\n     unwrap_in_result::UNWRAP_IN_RESULT,\n     upper_case_acronyms::UPPER_CASE_ACRONYMS,\n+    use_retain::USE_RETAIN,\n     use_self::USE_SELF,\n     useless_conversion::USELESS_CONVERSION,\n     vec::USELESS_VEC,"}, {"sha": "3b3505f1e194957f94f8d64078af1eba74b526e8", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "patch": "@@ -117,6 +117,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n     LintId::of(unused_unit::UNUSED_UNIT),\n     LintId::of(upper_case_acronyms::UPPER_CASE_ACRONYMS),\n+    LintId::of(use_retain::USE_RETAIN),\n     LintId::of(write::PRINTLN_EMPTY_STRING),\n     LintId::of(write::PRINT_LITERAL),\n     LintId::of(write::PRINT_WITH_NEWLINE),"}, {"sha": "124f0d12b08ce51c3ab8f5abe9969c9bdbc8d63a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "patch": "@@ -410,6 +410,7 @@ mod unused_unit;\n mod unwrap;\n mod unwrap_in_result;\n mod upper_case_acronyms;\n+mod use_retain;\n mod use_self;\n mod useless_conversion;\n mod vec;\n@@ -914,6 +915,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(read_zero_byte_vec::ReadZeroByteVec));\n     store.register_late_pass(|| Box::new(default_instead_of_iter_empty::DefaultIterEmpty));\n     store.register_late_pass(move || Box::new(manual_rem_euclid::ManualRemEuclid::new(msrv)));\n+    store.register_late_pass(|| Box::new(use_retain::UseRetain));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "ffe2786ee091e051fdc683603f528f12168606bf", "filename": "clippy_lints/src/use_retain.rs", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_lints%2Fsrc%2Fuse_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_lints%2Fsrc%2Fuse_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_retain.rs?ref=5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "patch": "@@ -0,0 +1,233 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{get_parent_expr, match_def_path, paths, SpanlessEq};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::ExprKind::Assign;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n+\n+const ACCEPTABLE_METHODS: [&[&str]; 4] = [\n+    &paths::HASHSET_ITER,\n+    &paths::BTREESET_ITER,\n+    &paths::SLICE_INTO,\n+    &paths::VEC_DEQUE_ITER,\n+];\n+const ACCEPTABLE_TYPES: [rustc_span::Symbol; 6] = [\n+    sym::BTreeSet,\n+    sym::BTreeMap,\n+    sym::HashSet,\n+    sym::HashMap,\n+    sym::Vec,\n+    sym::VecDeque,\n+];\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for code to be replaced by `.retain()`.\n+    /// ### Why is this bad?\n+    /// `.retain()` is simpler.\n+    /// ### Example\n+    /// ```rust\n+    /// let mut vec = vec![0, 1, 2];\n+    /// vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    /// vec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut vec = vec![0, 1, 2];\n+    /// vec.retain(|x| x % 2 == 0);\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub USE_RETAIN,\n+    style,\n+    \"`retain()` is simpler and the same functionalitys\"\n+}\n+declare_lint_pass!(UseRetain => [USE_RETAIN]);\n+\n+impl<'tcx> LateLintPass<'tcx> for UseRetain {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if_chain! {\n+            if let Some(parent_expr) = get_parent_expr(cx, expr);\n+            if let Assign(left_expr, collect_expr, _) = &parent_expr.kind;\n+            if let hir::ExprKind::MethodCall(seg, _, _) = &collect_expr.kind;\n+            if seg.args.is_none();\n+\n+            if let hir::ExprKind::MethodCall(_, [target_expr], _) = &collect_expr.kind;\n+            if let Some(collect_def_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id);\n+            if match_def_path(cx, collect_def_id, &paths::CORE_ITER_COLLECT);\n+\n+            then {\n+                check_into_iter(cx, parent_expr, left_expr, target_expr);\n+                check_iter(cx, parent_expr, left_expr, target_expr);\n+                check_to_owned(cx, parent_expr, left_expr, target_expr);\n+            }\n+        }\n+    }\n+}\n+\n+fn check_into_iter(\n+    cx: &LateContext<'_>,\n+    parent_expr: &hir::Expr<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    target_expr: &hir::Expr<'_>,\n+) {\n+    if_chain! {\n+        if let hir::ExprKind::MethodCall(_, [into_iter_expr, _], _) = &target_expr.kind;\n+        if let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id);\n+        if match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER);\n+\n+        if let hir::ExprKind::MethodCall(_, [struct_expr], _) = &into_iter_expr.kind;\n+        if let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id);\n+        if match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER);\n+        if match_acceptable_type(cx, left_expr);\n+\n+        if SpanlessEq::new(cx).eq_expr(left_expr, struct_expr);\n+\n+        then {\n+            suggest(cx, parent_expr, left_expr, target_expr);\n+        }\n+    }\n+}\n+\n+fn check_iter(\n+    cx: &LateContext<'_>,\n+    parent_expr: &hir::Expr<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    target_expr: &hir::Expr<'_>,\n+) {\n+    if_chain! {\n+        if let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind;\n+        if let Some(copied_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id);\n+        if match_def_path(cx, copied_def_id, &paths::CORE_ITER_COPIED);\n+\n+        if let hir::ExprKind::MethodCall(_, [iter_expr, _], _) = &filter_expr.kind;\n+        if let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id);\n+        if match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER);\n+\n+        if let hir::ExprKind::MethodCall(_, [struct_expr], _) = &iter_expr.kind;\n+        if let Some(iter_expr_def_id) = cx.typeck_results().type_dependent_def_id(iter_expr.hir_id);\n+        if match_acceptable_def_path(cx, iter_expr_def_id);\n+        if match_acceptable_type(cx, left_expr);\n+        if SpanlessEq::new(cx).eq_expr(left_expr, struct_expr);\n+\n+        then {\n+            suggest(cx, parent_expr, left_expr, filter_expr);\n+        }\n+    }\n+}\n+\n+fn check_to_owned(\n+    cx: &LateContext<'_>,\n+    parent_expr: &hir::Expr<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    target_expr: &hir::Expr<'_>,\n+) {\n+    if_chain! {\n+        if let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind;\n+        if let Some(to_owned_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id);\n+        if match_def_path(cx, to_owned_def_id, &paths::TO_OWNED_METHOD);\n+\n+        if let hir::ExprKind::MethodCall(_, [chars_expr, _], _) = &filter_expr.kind;\n+        if let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id);\n+        if match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER);\n+\n+        if let hir::ExprKind::MethodCall(_, [str_expr], _) = &chars_expr.kind;\n+        if let Some(chars_expr_def_id) = cx.typeck_results().type_dependent_def_id(chars_expr.hir_id);\n+        if match_def_path(cx, chars_expr_def_id, &paths::STR_CHARS);\n+\n+        let ty = cx.typeck_results().expr_ty(str_expr).peel_refs();\n+        if is_type_diagnostic_item(cx, ty, sym::String);\n+        if SpanlessEq::new(cx).eq_expr(left_expr, str_expr);\n+\n+        then {\n+            suggest(cx, parent_expr, left_expr, filter_expr);\n+        }\n+    }\n+}\n+\n+fn suggest(cx: &LateContext<'_>, parent_expr: &hir::Expr<'_>, left_expr: &hir::Expr<'_>, filter_expr: &hir::Expr<'_>) {\n+    if_chain! {\n+        if let hir::ExprKind::MethodCall(_, [_, closure], _) = filter_expr.kind;\n+        if let hir::ExprKind::Closure(_, _, filter_body_id, ..) = closure.kind;\n+        let filter_body = cx.tcx.hir().body(filter_body_id);\n+        if let [filter_params] = filter_body.params;\n+        if let Some(sugg) = match filter_params.pat.kind {\n+            hir::PatKind::Binding(_, _, filter_param_ident, None) => {\n+                Some(format!(\"{}.retain(|{}| {})\", snippet(cx, left_expr.span, \"..\"), filter_param_ident, snippet(cx, filter_body.value.span, \"..\")))\n+            },\n+            hir::PatKind::Tuple([key_pat, value_pat], _) => {\n+                make_sugg(cx, key_pat, value_pat, left_expr, filter_body)\n+            },\n+            hir::PatKind::Ref(pat, _) => {\n+                match pat.kind {\n+                    hir::PatKind::Binding(_, _, filter_param_ident, None) => {\n+                        Some(format!(\"{}.retain(|{}| {})\", snippet(cx, left_expr.span, \"..\"), filter_param_ident, snippet(cx, filter_body.value.span, \"..\")))\n+                    },\n+                    _ => None\n+                }\n+            },\n+            _ => None\n+        };\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                USE_RETAIN,\n+                parent_expr.span,\n+                \"this expression can be written more simply using `.retain()`\",\n+                \"consider calling `.retain()` instead\",\n+                sugg,\n+                Applicability::MachineApplicable\n+            );\n+        }\n+    }\n+}\n+\n+fn make_sugg(\n+    cx: &LateContext<'_>,\n+    key_pat: &rustc_hir::Pat<'_>,\n+    value_pat: &rustc_hir::Pat<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    filter_body: &hir::Body<'_>,\n+) -> Option<String> {\n+    match (&key_pat.kind, &value_pat.kind) {\n+        (hir::PatKind::Binding(_, _, key_param_ident, None), hir::PatKind::Binding(_, _, value_param_ident, None)) => {\n+            Some(format!(\n+                \"{}.retain(|{}, &mut {}| {})\",\n+                snippet(cx, left_expr.span, \"..\"),\n+                key_param_ident,\n+                value_param_ident,\n+                snippet(cx, filter_body.value.span, \"..\")\n+            ))\n+        },\n+        (hir::PatKind::Binding(_, _, key_param_ident, None), hir::PatKind::Wild) => Some(format!(\n+            \"{}.retain(|{}, _| {})\",\n+            snippet(cx, left_expr.span, \"..\"),\n+            key_param_ident,\n+            snippet(cx, filter_body.value.span, \"..\")\n+        )),\n+        (hir::PatKind::Wild, hir::PatKind::Binding(_, _, value_param_ident, None)) => Some(format!(\n+            \"{}.retain(|_, &mut {}| {})\",\n+            snippet(cx, left_expr.span, \"..\"),\n+            value_param_ident,\n+            snippet(cx, filter_body.value.span, \"..\")\n+        )),\n+        _ => None,\n+    }\n+}\n+\n+fn match_acceptable_def_path(cx: &LateContext<'_>, collect_def_id: DefId) -> bool {\n+    return ACCEPTABLE_METHODS\n+        .iter()\n+        .any(|&method| match_def_path(cx, collect_def_id, method));\n+}\n+\n+fn match_acceptable_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n+    let expr_ty = cx.typeck_results().expr_ty(expr).peel_refs();\n+    return ACCEPTABLE_TYPES\n+        .iter()\n+        .any(|&ty| is_type_diagnostic_item(cx, expr_ty, ty));\n+}"}, {"sha": "17cccd43a9c353e2fbbfe486f1e598c0636ab17f", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "patch": "@@ -21,8 +21,13 @@ pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub const BTREEMAP_CONTAINS_KEY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"contains_key\"];\n pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n+pub const BTREESET_ITER: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\", \"iter\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n+pub const CORE_ITER_COLLECT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"collect\"];\n+pub const CORE_ITER_COPIED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"copied\"];\n+pub const CORE_ITER_FILTER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"filter\"];\n+pub const CORE_ITER_INTO_ITER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"IntoIterator\", \"into_iter\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"alloc\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n@@ -50,6 +55,7 @@ pub const FUTURES_IO_ASYNCWRITEEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncWri\n pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHMAP_INSERT: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"insert\"];\n+pub const HASHSET_ITER: [&str; 6] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\", \"iter\"];\n #[cfg(feature = \"internal\")]\n pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];\n #[cfg(feature = \"internal\")]\n@@ -145,6 +151,7 @@ pub const SLICE_FROM_RAW_PARTS: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_p\n pub const SLICE_FROM_RAW_PARTS_MUT: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_parts_mut\"];\n pub const SLICE_GET: [&str; 4] = [\"core\", \"slice\", \"<impl [T]>\", \"get\"];\n pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n+pub const SLICE_INTO: [&str; 4] = [\"core\", \"slice\", \"<impl [T]>\", \"iter\"];\n pub const SLICE_ITER: [&str; 4] = [\"core\", \"slice\", \"iter\", \"Iter\"];\n pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n@@ -154,6 +161,7 @@ pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_s\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];\n pub const STRING_NEW: [&str; 4] = [\"alloc\", \"string\", \"String\", \"new\"];\n pub const STR_BYTES: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"bytes\"];\n+pub const STR_CHARS: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"chars\"];\n pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];\n pub const STR_FROM_UTF8: [&str; 4] = [\"core\", \"str\", \"converts\", \"from_utf8\"];\n pub const STR_LEN: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"len\"];\n@@ -179,6 +187,7 @@ pub const TOKIO_IO_ASYNCWRITEEXT: [&str; 5] = [\"tokio\", \"io\", \"util\", \"async_wri\n pub const TRY_FROM: [&str; 4] = [\"core\", \"convert\", \"TryFrom\", \"try_from\"];\n pub const VEC_AS_MUT_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_mut_slice\"];\n pub const VEC_AS_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_slice\"];\n+pub const VEC_DEQUE_ITER: [&str; 5] = [\"alloc\", \"collections\", \"vec_deque\", \"VecDeque\", \"iter\"];\n pub const VEC_FROM_ELEM: [&str; 3] = [\"alloc\", \"vec\", \"from_elem\"];\n pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];"}, {"sha": "d24571b36f8745c22fddd248964c6b239126fdb9", "filename": "tests/ui/use_retain.fixed", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/tests%2Fui%2Fuse_retain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/tests%2Fui%2Fuse_retain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_retain.fixed?ref=5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "patch": "@@ -0,0 +1,184 @@\n+// run-rustfix\n+#![warn(clippy::use_retain)]\n+#![allow(unused)]\n+use std::collections::BTreeMap;\n+use std::collections::BTreeSet;\n+use std::collections::BinaryHeap;\n+use std::collections::HashMap;\n+use std::collections::HashSet;\n+use std::collections::VecDeque;\n+\n+fn main() {\n+    binary_heap_retain();\n+    btree_set_retain();\n+    btree_map_retain();\n+    hash_set_retain();\n+    hash_map_retain();\n+    string_retain();\n+    vec_queue_retain();\n+    vec_retain();\n+}\n+\n+fn binary_heap_retain() {\n+    // NOTE: Do not lint now, because binary_heap_retain is nighyly API.\n+    // https://github.com/rust-lang/rust/issues/71503\n+    let mut heap = BinaryHeap::from([1, 2, 3]);\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+\n+    // Do not lint, because type conversion is performed\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect::<BinaryHeap<i8>>();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect::<BinaryHeap<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: BinaryHeap<i8> = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: BinaryHeap<i8> = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn btree_map_retain() {\n+    let mut btree_map: BTreeMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    btree_map.retain(|k, _| k % 2 == 0);\n+    btree_map.retain(|_, &mut v| v % 2 == 0);\n+    btree_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0));\n+\n+    // Do not lint.\n+    btree_map = btree_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<BTreeMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeMap<i8, i8> = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    btree_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn btree_set_retain() {\n+    let mut btree_set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n+\n+    // Do lint.\n+    btree_set.retain(|x| x % 2 == 0);\n+    btree_set.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    btree_set = btree_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<BTreeSet<i8>>();\n+\n+    btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect::<BTreeSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeSet<i8> = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut bar: BTreeSet<i8> = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn hash_map_retain() {\n+    let mut hash_map: HashMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    hash_map.retain(|k, _| k % 2 == 0);\n+    hash_map.retain(|_, &mut v| v % 2 == 0);\n+    hash_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0));\n+\n+    // Do not lint.\n+    hash_map = hash_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<HashMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: HashMap<i8, i8> = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    hash_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn hash_set_retain() {\n+    let mut hash_set = HashSet::from([1, 2, 3, 4, 5, 6]);\n+    // Do lint.\n+    hash_set.retain(|x| x % 2 == 0);\n+    hash_set.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect::<HashSet<i8>>();\n+    hash_set = hash_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<HashSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: HashSet<i8> = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: HashSet<i8> = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|&x| x % 2 == 0).collect();\n+}\n+\n+fn string_retain() {\n+    let mut s = String::from(\"foobar\");\n+    // Do lint.\n+    s.retain(|c| c != 'o');\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: String = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    s = bar.chars().filter(|&c| c != 'o').to_owned().collect();\n+}\n+\n+fn vec_retain() {\n+    let mut vec = vec![0, 1, 2];\n+    // Do lint.\n+    vec.retain(|x| x % 2 == 0);\n+    vec.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    vec = vec.into_iter().filter(|x| x % 2 == 0).collect::<Vec<i8>>();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect::<Vec<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: Vec<i8> = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: Vec<i8> = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn vec_queue_retain() {\n+    let mut vec_deque = VecDeque::new();\n+    vec_deque.extend(1..5);\n+\n+    // Do lint.\n+    vec_deque.retain(|x| x % 2 == 0);\n+    vec_deque.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    vec_deque = vec_deque\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<VecDeque<i8>>();\n+    vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect::<VecDeque<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: VecDeque<i8> = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: VecDeque<i8> = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}"}, {"sha": "4a51825c95f7380673c274d04e50d0b191133543", "filename": "tests/ui/use_retain.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/tests%2Fui%2Fuse_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/tests%2Fui%2Fuse_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_retain.rs?ref=5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "patch": "@@ -0,0 +1,190 @@\n+// run-rustfix\n+#![warn(clippy::use_retain)]\n+#![allow(unused)]\n+use std::collections::BTreeMap;\n+use std::collections::BTreeSet;\n+use std::collections::BinaryHeap;\n+use std::collections::HashMap;\n+use std::collections::HashSet;\n+use std::collections::VecDeque;\n+\n+fn main() {\n+    binary_heap_retain();\n+    btree_set_retain();\n+    btree_map_retain();\n+    hash_set_retain();\n+    hash_map_retain();\n+    string_retain();\n+    vec_queue_retain();\n+    vec_retain();\n+}\n+\n+fn binary_heap_retain() {\n+    // NOTE: Do not lint now, because binary_heap_retain is nighyly API.\n+    // https://github.com/rust-lang/rust/issues/71503\n+    let mut heap = BinaryHeap::from([1, 2, 3]);\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+\n+    // Do not lint, because type conversion is performed\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect::<BinaryHeap<i8>>();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect::<BinaryHeap<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: BinaryHeap<i8> = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: BinaryHeap<i8> = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn btree_map_retain() {\n+    let mut btree_map: BTreeMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    btree_map = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+    btree_map = btree_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+    btree_map = btree_map\n+        .into_iter()\n+        .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+        .collect();\n+\n+    // Do not lint.\n+    btree_map = btree_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<BTreeMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeMap<i8, i8> = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    btree_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn btree_set_retain() {\n+    let mut btree_set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n+\n+    // Do lint.\n+    btree_set = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because type conversion is performed\n+    btree_set = btree_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<BTreeSet<i8>>();\n+\n+    btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect::<BTreeSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeSet<i8> = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut bar: BTreeSet<i8> = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn hash_map_retain() {\n+    let mut hash_map: HashMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    hash_map = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+    hash_map = hash_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+    hash_map = hash_map\n+        .into_iter()\n+        .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+        .collect();\n+\n+    // Do not lint.\n+    hash_map = hash_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<HashMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: HashMap<i8, i8> = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    hash_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn hash_set_retain() {\n+    let mut hash_set = HashSet::from([1, 2, 3, 4, 5, 6]);\n+    // Do lint.\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+    hash_set = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+\n+    // Do not lint, because type conversion is performed\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect::<HashSet<i8>>();\n+    hash_set = hash_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<HashSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: HashSet<i8> = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: HashSet<i8> = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|&x| x % 2 == 0).collect();\n+}\n+\n+fn string_retain() {\n+    let mut s = String::from(\"foobar\");\n+    // Do lint.\n+    s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: String = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    s = bar.chars().filter(|&c| c != 'o').to_owned().collect();\n+}\n+\n+fn vec_retain() {\n+    let mut vec = vec![0, 1, 2];\n+    // Do lint.\n+    vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    vec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because type conversion is performed\n+    vec = vec.into_iter().filter(|x| x % 2 == 0).collect::<Vec<i8>>();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect::<Vec<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: Vec<i8> = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: Vec<i8> = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn vec_queue_retain() {\n+    let mut vec_deque = VecDeque::new();\n+    vec_deque.extend(1..5);\n+\n+    // Do lint.\n+    vec_deque = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because type conversion is performed\n+    vec_deque = vec_deque\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<VecDeque<i8>>();\n+    vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect::<VecDeque<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: VecDeque<i8> = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: VecDeque<i8> = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}"}, {"sha": "331259c1626b4fe8187cc0586cae820c9de1217f", "filename": "tests/ui/use_retain.stderr", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/tests%2Fui%2Fuse_retain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1/tests%2Fui%2Fuse_retain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_retain.stderr?ref=5f2b8e67b3ab5f700e9076c3a0bba8bc2ed4a7f1", "patch": "@@ -0,0 +1,100 @@\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:45:5\n+   |\n+LL |     btree_map = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_map.retain(|k, _| k % 2 == 0)`\n+   |\n+   = note: `-D clippy::use-retain` implied by `-D warnings`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:46:5\n+   |\n+LL |     btree_map = btree_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_map.retain(|_, &mut v| v % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:47:5\n+   |\n+LL | /     btree_map = btree_map\n+LL | |         .into_iter()\n+LL | |         .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+LL | |         .collect();\n+   | |__________________^ help: consider calling `.retain()` instead: `btree_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0))`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:69:5\n+   |\n+LL |     btree_set = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:70:5\n+   |\n+LL |     btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:93:5\n+   |\n+LL |     hash_map = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_map.retain(|k, _| k % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:94:5\n+   |\n+LL |     hash_map = hash_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_map.retain(|_, &mut v| v % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:95:5\n+   |\n+LL | /     hash_map = hash_map\n+LL | |         .into_iter()\n+LL | |         .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+LL | |         .collect();\n+   | |__________________^ help: consider calling `.retain()` instead: `hash_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0))`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:116:5\n+   |\n+LL |     hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:117:5\n+   |\n+LL |     hash_set = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:139:5\n+   |\n+LL |     s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `s.retain(|c| c != 'o')`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:151:5\n+   |\n+LL |     vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:152:5\n+   |\n+LL |     vec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:172:5\n+   |\n+LL |     vec_deque = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec_deque.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/use_retain.rs:173:5\n+   |\n+LL |     vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec_deque.retain(|x| x % 2 == 0)`\n+\n+error: aborting due to 15 previous errors\n+"}]}