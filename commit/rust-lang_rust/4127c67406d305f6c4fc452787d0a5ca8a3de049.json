{"sha": "4127c67406d305f6c4fc452787d0a5ca8a3de049", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMjdjNjc0MDZkMzA1ZjZjNGZjNDUyNzg3ZDBhNWNhOGEzZGUwNDk=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-13T00:10:10Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-15T02:06:17Z"}, "message": "Ported check_const from oldvisit to <V:Visitor> trait API.", "tree": {"sha": "dbf4864b07eed49b632a09b74015bbe3849a7b59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbf4864b07eed49b632a09b74015bbe3849a7b59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4127c67406d305f6c4fc452787d0a5ca8a3de049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4127c67406d305f6c4fc452787d0a5ca8a3de049", "html_url": "https://github.com/rust-lang/rust/commit/4127c67406d305f6c4fc452787d0a5ca8a3de049", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4127c67406d305f6c4fc452787d0a5ca8a3de049/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef854c9b04cf916241587ea1764b86027e380e8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef854c9b04cf916241587ea1764b86027e380e8f", "html_url": "https://github.com/rust-lang/rust/commit/ef854c9b04cf916241587ea1764b86027e380e8f"}], "stats": {"total": 96, "additions": 60, "deletions": 36}, "files": [{"sha": "b772ca7e9bbf5709188174a4cad1e48b535f1bc4", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 60, "deletions": 36, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4127c67406d305f6c4fc452787d0a5ca8a3de049/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4127c67406d305f6c4fc452787d0a5ca8a3de049/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=4127c67406d305f6c4fc452787d0a5ca8a3de049", "patch": "@@ -17,47 +17,71 @@ use util::ppaux;\n \n use syntax::ast::*;\n use syntax::codemap;\n-use syntax::{oldvisit, ast_util, ast_map};\n+use syntax::{ast_util, ast_map};\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+\n+struct CheckCrateVisitor {\n+    sess: Session,\n+    ast_map: ast_map::map,\n+    def_map: resolve::DefMap,\n+    method_map: typeck::method_map,\n+    tcx: ty::ctxt,\n+}\n+\n+impl Visitor<bool> for CheckCrateVisitor {\n+    fn visit_item(&mut self, i:@item, env:bool) {\n+        check_item(self, self.sess, self.ast_map, self.def_map, i, env);\n+    }\n+    fn visit_pat(&mut self, p:@pat, env:bool) {\n+        check_pat(self, p, env);\n+    }\n+    fn visit_expr(&mut self, ex:@expr, env:bool) {\n+        check_expr(self, self.sess, self.def_map, self.method_map,\n+                   self.tcx, ex, env);\n+    }\n+}\n \n pub fn check_crate(sess: Session,\n                    crate: &Crate,\n                    ast_map: ast_map::map,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::method_map,\n                    tcx: ty::ctxt) {\n-    oldvisit::visit_crate(crate, (false, oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_item: |a,b| check_item(sess, ast_map, def_map, a, b),\n-        visit_pat: check_pat,\n-        visit_expr: |a,b|\n-            check_expr(sess, def_map, method_map, tcx, a, b),\n-        .. *oldvisit::default_visitor()\n-    })));\n+    let mut v = CheckCrateVisitor {\n+        sess: sess,\n+        ast_map: ast_map,\n+        def_map: def_map,\n+        method_map: method_map,\n+        tcx: tcx,\n+    };\n+    visit::walk_crate(&mut v, crate, false);\n     sess.abort_if_errors();\n }\n \n-pub fn check_item(sess: Session,\n+pub fn check_item(v: &mut CheckCrateVisitor,\n+                  sess: Session,\n                   ast_map: ast_map::map,\n                   def_map: resolve::DefMap,\n                   it: @item,\n-                  (_is_const, v): (bool,\n-                                   oldvisit::vt<bool>)) {\n+                  _is_const: bool) {\n     match it.node {\n       item_static(_, _, ex) => {\n-        (v.visit_expr)(ex, (true, v));\n+        v.visit_expr(ex, true);\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n       item_enum(ref enum_definition, _) => {\n         for var in (*enum_definition).variants.iter() {\n             for ex in var.node.disr_expr.iter() {\n-                (v.visit_expr)(*ex, (true, v));\n+                v.visit_expr(*ex, true);\n             }\n         }\n       }\n-      _ => oldvisit::visit_item(it, (false, v))\n+      _ => visit::walk_item(v, it, false)\n     }\n }\n \n-pub fn check_pat(p: @pat, (_is_const, v): (bool, oldvisit::vt<bool>)) {\n+pub fn check_pat(v: &mut CheckCrateVisitor, p: @pat, _is_const: bool) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n             expr_vstore(\n@@ -72,22 +96,22 @@ pub fn check_pat(p: @pat, (_is_const, v): (bool, oldvisit::vt<bool>)) {\n     }\n     match p.node {\n       // Let through plain ~-string literals here\n-      pat_lit(a) => if !is_str(a) { (v.visit_expr)(a, (true, v)); },\n+      pat_lit(a) => if !is_str(a) { v.visit_expr(a, true); },\n       pat_range(a, b) => {\n-        if !is_str(a) { (v.visit_expr)(a, (true, v)); }\n-        if !is_str(b) { (v.visit_expr)(b, (true, v)); }\n+        if !is_str(a) { v.visit_expr(a, true); }\n+        if !is_str(b) { v.visit_expr(b, true); }\n       }\n-      _ => oldvisit::visit_pat(p, (false, v))\n+      _ => visit::walk_pat(v, p, false)\n     }\n }\n \n-pub fn check_expr(sess: Session,\n+pub fn check_expr(v: &mut CheckCrateVisitor,\n+                  sess: Session,\n                   def_map: resolve::DefMap,\n                   method_map: typeck::method_map,\n                   tcx: ty::ctxt,\n                   e: @expr,\n-                  (is_const, v): (bool,\n-                                  oldvisit::vt<bool>)) {\n+                  is_const: bool) {\n     if is_const {\n         match e.node {\n           expr_unary(_, deref, _) => { }\n@@ -152,8 +176,8 @@ pub fn check_expr(sess: Session,\n                 }\n             }\n           }\n-          expr_paren(e) => { check_expr(sess, def_map, method_map,\n-                                         tcx, e, (is_const, v)); }\n+          expr_paren(e) => { check_expr(v, sess, def_map, method_map,\n+                                        tcx, e, is_const); }\n           expr_vstore(_, expr_vstore_slice) |\n           expr_vec(_, m_imm) |\n           expr_addr_of(m_imm, _) |\n@@ -191,7 +215,7 @@ pub fn check_expr(sess: Session,\n       }\n       _ => ()\n     }\n-    oldvisit::visit_expr(e, (is_const, v));\n+    visit::walk_expr(v, e, is_const);\n }\n \n #[deriving(Clone)]\n@@ -203,6 +227,8 @@ struct env {\n     idstack: @mut ~[NodeId]\n }\n \n+struct CheckItemRecursionVisitor;\n+\n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n pub fn check_item_recursion(sess: Session,\n@@ -217,36 +243,34 @@ pub fn check_item_recursion(sess: Session,\n         idstack: @mut ~[]\n     };\n \n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_item: visit_item,\n-        visit_expr: visit_expr,\n-        .. *oldvisit::default_visitor()\n-    });\n-    (visitor.visit_item)(it, (env, visitor));\n+    let mut visitor = CheckItemRecursionVisitor;\n+    visitor.visit_item(it, env);\n+}\n \n-    fn visit_item(it: @item, (env, v): (env, oldvisit::vt<env>)) {\n+impl Visitor<env> for CheckItemRecursionVisitor {\n+    fn visit_item(&mut self, it: @item, env: env) {\n         if env.idstack.iter().any(|x| x == &(it.id)) {\n             env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n         }\n         env.idstack.push(it.id);\n-        oldvisit::visit_item(it, (env, v));\n+        visit::walk_item(self, it, env);\n         env.idstack.pop();\n     }\n \n-    fn visit_expr(e: @expr, (env, v): (env, oldvisit::vt<env>)) {\n+    fn visit_expr(&mut self, e: @expr, env: env) {\n         match e.node {\n             expr_path(*) => match env.def_map.find(&e.id) {\n                 Some(&def_static(def_id, _)) if ast_util::is_local(def_id) =>\n                     match env.ast_map.get_copy(&def_id.node) {\n                         ast_map::node_item(it, _) => {\n-                            (v.visit_item)(it, (env, v));\n+                            self.visit_item(it, env);\n                         }\n                         _ => fail!(\"const not bound to an item\")\n                     },\n                 _ => ()\n             },\n             _ => ()\n         }\n-        oldvisit::visit_expr(e, (env, v));\n+        visit::walk_expr(self, e, env);\n     }\n }"}]}