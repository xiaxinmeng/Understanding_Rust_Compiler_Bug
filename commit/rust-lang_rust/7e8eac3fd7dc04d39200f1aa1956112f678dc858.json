{"sha": "7e8eac3fd7dc04d39200f1aa1956112f678dc858", "node_id": "C_kwDOAAsO6NoAKDdlOGVhYzNmZDdkYzA0ZDM5MjAwZjFhYTE5NTYxMTJmNjc4ZGM4NTg", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-20T12:33:18Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-20T12:33:18Z"}, "message": "Simplify", "tree": {"sha": "fa04269bb630772305b8a95552e325cc5585d4c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa04269bb630772305b8a95552e325cc5585d4c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e8eac3fd7dc04d39200f1aa1956112f678dc858", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e8eac3fd7dc04d39200f1aa1956112f678dc858", "html_url": "https://github.com/rust-lang/rust/commit/7e8eac3fd7dc04d39200f1aa1956112f678dc858", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e8eac3fd7dc04d39200f1aa1956112f678dc858/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6c067c06d9341e9d4c8a7ead2cc5f58a533ecfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6c067c06d9341e9d4c8a7ead2cc5f58a533ecfd", "html_url": "https://github.com/rust-lang/rust/commit/a6c067c06d9341e9d4c8a7ead2cc5f58a533ecfd"}], "stats": {"total": 67, "additions": 31, "deletions": 36}, "files": [{"sha": "87e22c2138b72abdfacacab338e9a49241b43b13", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e8eac3fd7dc04d39200f1aa1956112f678dc858/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e8eac3fd7dc04d39200f1aa1956112f678dc858/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=7e8eac3fd7dc04d39200f1aa1956112f678dc858", "patch": "@@ -115,7 +115,7 @@ pub(super) struct SourceToDefCtx<'a, 'b> {\n }\n \n impl SourceToDefCtx<'_, '_> {\n-    pub(super) fn file_to_def(&mut self, file: FileId) -> SmallVec<[ModuleId; 1]> {\n+    pub(super) fn file_to_def(&self, file: FileId) -> SmallVec<[ModuleId; 1]> {\n         let _p = profile::span(\"SourceBinder::to_module_def\");\n         let mut mods = SmallVec::new();\n         for &crate_id in self.db.relevant_crates(file).iter() {\n@@ -130,7 +130,7 @@ impl SourceToDefCtx<'_, '_> {\n         mods\n     }\n \n-    pub(super) fn module_to_def(&mut self, src: InFile<ast::Module>) -> Option<ModuleId> {\n+    pub(super) fn module_to_def(&self, src: InFile<ast::Module>) -> Option<ModuleId> {\n         let _p = profile::span(\"module_to_def\");\n         let parent_declaration = src\n             .syntax()\n@@ -151,7 +151,7 @@ impl SourceToDefCtx<'_, '_> {\n         Some(def_map.module_id(child_id))\n     }\n \n-    pub(super) fn source_file_to_def(&mut self, src: InFile<ast::SourceFile>) -> Option<ModuleId> {\n+    pub(super) fn source_file_to_def(&self, src: InFile<ast::SourceFile>) -> Option<ModuleId> {\n         let _p = profile::span(\"source_file_to_def\");\n         let file_id = src.file_id.original_file(self.db.upcast());\n         self.file_to_def(file_id).get(0).copied()"}, {"sha": "2c0af99940f971d132d5a3fc26824b0f341c12f0", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7e8eac3fd7dc04d39200f1aa1956112f678dc858/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e8eac3fd7dc04d39200f1aa1956112f678dc858/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=7e8eac3fd7dc04d39200f1aa1956112f678dc858", "patch": "@@ -21,8 +21,8 @@ use crate::{\n     cfg_flag::CfgFlag,\n     rustc_cfg,\n     sysroot::SysrootCrate,\n-    utf8_stdout, CargoConfig, CargoWorkspace, ManifestPath, ProjectJson, ProjectManifest, Sysroot,\n-    TargetKind, WorkspaceBuildScripts,\n+    utf8_stdout, CargoConfig, CargoWorkspace, ManifestPath, Package, ProjectJson, ProjectManifest,\n+    Sysroot, TargetKind, WorkspaceBuildScripts,\n };\n \n /// A set of cfg-overrides per crate.\n@@ -315,6 +315,13 @@ impl ProjectWorkspace {\n     /// The return type contains the path and whether or not\n     /// the root is a member of the current workspace\n     pub fn to_roots(&self) -> Vec<PackageRoot> {\n+        let mk_sysroot = |sysroot: Option<&Sysroot>| {\n+            sysroot.map(|sysroot| PackageRoot {\n+                is_local: false,\n+                include: vec![sysroot.src_root().to_path_buf()],\n+                exclude: Vec::new(),\n+            })\n+        };\n         match self {\n             ProjectWorkspace::Json { project, sysroot, rustc_cfg: _ } => project\n                 .crates()\n@@ -325,13 +332,7 @@ impl ProjectWorkspace {\n                 })\n                 .collect::<FxHashSet<_>>()\n                 .into_iter()\n-                .chain(sysroot.as_ref().into_iter().flat_map(|sysroot| {\n-                    sysroot.crates().map(move |krate| PackageRoot {\n-                        is_local: false,\n-                        include: vec![sysroot[krate].root.parent().to_path_buf()],\n-                        exclude: Vec::new(),\n-                    })\n-                }))\n+                .chain(mk_sysroot(sysroot.as_ref()))\n                 .collect::<Vec<_>>(),\n             ProjectWorkspace::Cargo {\n                 cargo,\n@@ -380,11 +381,7 @@ impl ProjectWorkspace {\n                         }\n                         PackageRoot { is_local, include, exclude }\n                     })\n-                    .chain(sysroot.iter().map(|sysroot| PackageRoot {\n-                        is_local: false,\n-                        include: vec![sysroot.src_root().to_path_buf()],\n-                        exclude: Vec::new(),\n-                    }))\n+                    .chain(mk_sysroot(sysroot.as_ref()))\n                     .chain(rustc.iter().flat_map(|rustc| {\n                         rustc.packages().map(move |krate| PackageRoot {\n                             is_local: false,\n@@ -401,11 +398,7 @@ impl ProjectWorkspace {\n                     include: vec![detached_file.clone()],\n                     exclude: Vec::new(),\n                 })\n-                .chain(sysroot.crates().map(|krate| PackageRoot {\n-                    is_local: false,\n-                    include: vec![sysroot[krate].root.parent().to_path_buf()],\n-                    exclude: Vec::new(),\n-                }))\n+                .chain(mk_sysroot(Some(sysroot)))\n                 .collect(),\n         }\n     }\n@@ -639,6 +632,8 @@ fn cargo_to_crate_graph(\n                     lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n                     pkg_to_lib_crate.insert(pkg, crate_id);\n                 }\n+                // Even crates that don't set proc-macro = true are allowed to depend on proc_macro\n+                // (just none of the APIs work when called outside of a proc macro).\n                 if let Some(proc_macro) = libproc_macro {\n                     add_dep_with_prelude(\n                         &mut crate_graph,\n@@ -654,19 +649,19 @@ fn cargo_to_crate_graph(\n         }\n \n         // Set deps to the core, std and to the lib target of the current package\n-        for (from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n+        for &(from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n             // Add sysroot deps first so that a lib target named `core` etc. can overwrite them.\n-            public_deps.add(*from, &mut crate_graph);\n+            public_deps.add(from, &mut crate_graph);\n \n             if let Some((to, name)) = lib_tgt.clone() {\n-                if to != *from && *kind != TargetKind::BuildScript {\n+                if to != from && kind != TargetKind::BuildScript {\n                     // (build script can not depend on its library target)\n \n                     // For root projects with dashes in their name,\n                     // cargo metadata does not do any normalization,\n                     // so we do it ourselves currently\n                     let name = CrateName::normalize_dashes(&name);\n-                    add_dep(&mut crate_graph, *from, name, to);\n+                    add_dep(&mut crate_graph, from, name, to);\n                 }\n             }\n         }\n@@ -678,17 +673,17 @@ fn cargo_to_crate_graph(\n         for dep in cargo[pkg].dependencies.iter() {\n             let name = CrateName::new(&dep.name).unwrap();\n             if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                for (from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n-                    if dep.kind == DepKind::Build && *kind != TargetKind::BuildScript {\n+                for &(from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n+                    if dep.kind == DepKind::Build && kind != TargetKind::BuildScript {\n                         // Only build scripts may depend on build dependencies.\n                         continue;\n                     }\n-                    if dep.kind != DepKind::Build && *kind == TargetKind::BuildScript {\n+                    if dep.kind != DepKind::Build && kind == TargetKind::BuildScript {\n                         // Build scripts may only depend on build dependencies.\n                         continue;\n                     }\n \n-                    add_dep(&mut crate_graph, *from, name.clone(), to)\n+                    add_dep(&mut crate_graph, from, name.clone(), to)\n                 }\n             }\n         }\n@@ -699,9 +694,9 @@ fn cargo_to_crate_graph(\n         // and create dependencies on them for the crates which opt-in to that\n         if let Some(rustc_workspace) = rustc {\n             handle_rustc_crates(\n+                &mut crate_graph,\n                 rustc_workspace,\n                 load,\n-                &mut crate_graph,\n                 &cfg_options,\n                 override_cfg,\n                 load_proc_macro,\n@@ -761,16 +756,16 @@ fn detached_files_to_crate_graph(\n }\n \n fn handle_rustc_crates(\n+    crate_graph: &mut CrateGraph,\n     rustc_workspace: &CargoWorkspace,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-    crate_graph: &mut CrateGraph,\n     cfg_options: &CfgOptions,\n     override_cfg: &CfgOverrides,\n     load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n-    pkg_to_lib_crate: &mut FxHashMap<la_arena::Idx<crate::PackageData>, CrateId>,\n+    pkg_to_lib_crate: &mut FxHashMap<Package, CrateId>,\n     public_deps: &SysrootPublicDeps,\n     cargo: &CargoWorkspace,\n-    pkg_crates: &FxHashMap<la_arena::Idx<crate::PackageData>, Vec<(CrateId, TargetKind)>>,\n+    pkg_crates: &FxHashMap<Package, Vec<(CrateId, TargetKind)>>,\n     build_scripts: &WorkspaceBuildScripts,\n ) {\n     let mut rustc_pkg_crates = FxHashMap::default();\n@@ -784,8 +779,8 @@ fn handle_rustc_crates(\n         let mut queue = VecDeque::new();\n         queue.push_back(root_pkg);\n         while let Some(pkg) = queue.pop_front() {\n-            // Don't duplicate packages if they are dependended on a diamond pattern\n-            // N.B. if this line is omitted, we try to analyse over 4_800_000 crates\n+            // Don't duplicate packages if they are dependent on a diamond pattern\n+            // N.B. if this line is omitted, we try to analyze over 4_800_000 crates\n             // which is not ideal\n             if rustc_pkg_crates.contains_key(&pkg) {\n                 continue;"}]}