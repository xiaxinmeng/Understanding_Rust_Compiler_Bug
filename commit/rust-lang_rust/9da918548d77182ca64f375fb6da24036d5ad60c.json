{"sha": "9da918548d77182ca64f375fb6da24036d5ad60c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkYTkxODU0OGQ3NzE4MmNhNjRmMzc1ZmI2ZGEyNDAzNmQ1YWQ2MGM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-11T21:38:58Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-11T21:39:16Z"}, "message": "syntax: move MethMac to MacImplItem and combine {Provided,Required}Method into MethodTraitItem.", "tree": {"sha": "f04e278a2ffe86f73f9499fa6d23e4dd14faa3c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f04e278a2ffe86f73f9499fa6d23e4dd14faa3c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9da918548d77182ca64f375fb6da24036d5ad60c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9da918548d77182ca64f375fb6da24036d5ad60c", "html_url": "https://github.com/rust-lang/rust/commit/9da918548d77182ca64f375fb6da24036d5ad60c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9da918548d77182ca64f375fb6da24036d5ad60c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "html_url": "https://github.com/rust-lang/rust/commit/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a"}], "stats": {"total": 1013, "additions": 464, "deletions": 549}, "files": [{"sha": "611d8bc27d19d5fa849827a7d0cd1b9e18714411", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -827,7 +827,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     let elem = ast_map::PathName(m.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     if let Some(impl_item) = impl_item_opt {\n-        if let ast::MethodImplItem(ref ast_method) = impl_item.node {\n+        if let ast::MethodImplItem(ref sig, _) = impl_item.node {\n             encode_attributes(rbml_w, &impl_item.attrs);\n             let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n@@ -838,7 +838,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             if !any_types {\n                 encode_symbol(ecx, rbml_w, m.def_id.node);\n             }\n-            encode_method_argument_names(rbml_w, &ast_method.pe_sig().decl);\n+            encode_method_argument_names(rbml_w, &sig.decl);\n         }\n     }\n \n@@ -1362,28 +1362,25 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_parent_sort(rbml_w, 't');\n \n             let trait_item = &*ms[i];\n-            let encode_trait_item = |rbml_w: &mut Encoder| {\n-                // If this is a static method, we've already\n-                // encoded this.\n-                if is_nonstatic_method {\n-                    // FIXME: I feel like there is something funny\n-                    // going on.\n-                    encode_bounds_and_type_for_item(rbml_w, ecx, item_def_id.def_id().local_id());\n-                }\n-            };\n             encode_attributes(rbml_w, &trait_item.attrs);\n             match trait_item.node {\n-                ast::RequiredMethod(ref m) => {\n-                    encode_trait_item(rbml_w);\n-                    encode_item_sort(rbml_w, 'r');\n-                    encode_method_argument_names(rbml_w, &*m.decl);\n-                }\n+                ast::MethodTraitItem(ref sig, ref body) => {\n+                    // If this is a static method, we've already\n+                    // encoded this.\n+                    if is_nonstatic_method {\n+                        // FIXME: I feel like there is something funny\n+                        // going on.\n+                        encode_bounds_and_type_for_item(rbml_w, ecx,\n+                            item_def_id.def_id().local_id());\n+                    }\n \n-                ast::ProvidedMethod(ref m) => {\n-                    encode_trait_item(rbml_w);\n-                    encode_item_sort(rbml_w, 'p');\n-                    encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n-                    encode_method_argument_names(rbml_w, &*m.pe_sig().decl);\n+                    if body.is_some() {\n+                        encode_item_sort(rbml_w, 'p');\n+                        encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n+                    } else {\n+                        encode_item_sort(rbml_w, 'r');\n+                    }\n+                    encode_method_argument_names(rbml_w, &sig.decl);\n                 }\n \n                 ast::TypeTraitItem(..) => {"}, {"sha": "5efea66ab0c6cc751cff9f1550057df4657780f7", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -18,7 +18,7 @@ use util::nodemap::NodeSet;\n \n use std::collections::HashSet;\n use syntax::{ast, ast_map, codemap};\n-use syntax::ast_util::{local_def, is_local, PostExpansionMethod};\n+use syntax::ast_util::{local_def, is_local};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::visit::{self, Visitor};\n \n@@ -353,7 +353,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             ast::ItemTrait(_, _, _, ref trait_items) => {\n                 for trait_item in trait_items {\n                     match trait_item.node {\n-                        ast::ProvidedMethod(_) => {\n+                        ast::MethodTraitItem(_, Some(_)) => {\n                             if has_allow_dead_code_or_lang_attr(&trait_item.attrs) {\n                                 self.worklist.push(trait_item.id);\n                             }\n@@ -365,13 +365,14 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             ast::ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n                 for impl_item in impl_items {\n                     match impl_item.node {\n-                        ast::MethodImplItem(_) => {\n+                        ast::MethodImplItem(..) => {\n                             if opt_trait.is_some() ||\n                                     has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n                                 self.worklist.push(impl_item.id);\n                             }\n                         }\n                         ast::TypeImplItem(_) => {}\n+                        ast::MacImplItem(_) => panic!(\"unexpanded macro\")\n                     }\n                 }\n             }\n@@ -578,10 +579,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     // Overwrite so that we don't warn the trait method itself.\n     fn visit_trait_item(&mut self, trait_method: &ast::TraitItem) {\n         match trait_method.node {\n-            ast::ProvidedMethod(ref method) => {\n-                visit::walk_block(self, method.pe_body())\n+            ast::MethodTraitItem(_, Some(ref body)) => {\n+                visit::walk_block(self, body)\n             }\n-            ast::RequiredMethod(_) |\n+            ast::MethodTraitItem(_, None) |\n             ast::TypeTraitItem(..) => {}\n         }\n     }"}, {"sha": "378f3db0823391064cc40409021c97497134dddd", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -18,7 +18,6 @@ use middle::ty::MethodCall;\n use util::ppaux;\n \n use syntax::ast;\n-use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -90,8 +89,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             visit::FkItemFn(_, _, fn_style, _) =>\n                 (true, fn_style == ast::Unsafety::Unsafe),\n-            visit::FkMethod(_, method) =>\n-                (true, method.pe_sig().unsafety == ast::Unsafety::Unsafe),\n+            visit::FkMethod(_, sig) =>\n+                (true, sig.unsafety == ast::Unsafety::Unsafe),\n             _ => (false, false),\n         };\n "}, {"sha": "1ca56596a014732f6840441a3987b3d5d7ab85d0", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -83,7 +83,7 @@ use std::rc::Rc;\n use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{name_to_dummy_lifetime, PostExpansionMethod};\n+use syntax::ast_util::name_to_dummy_lifetime;\n use syntax::owned_slice::OwnedSlice;\n use syntax::codemap;\n use syntax::parse::token;\n@@ -848,25 +848,26 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n                 ast_map::NodeImplItem(item) => {\n                     match item.node {\n-                        ast::MethodImplItem(ref m) => {\n-                            Some((&m.pe_sig().decl,\n-                                  &m.pe_sig().generics,\n-                                  m.pe_sig().unsafety,\n+                        ast::MethodImplItem(ref sig, _) => {\n+                            Some((&sig.decl,\n+                                  &sig.generics,\n+                                  sig.unsafety,\n                                   item.ident,\n-                                  Some(&m.pe_sig().explicit_self.node),\n+                                  Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n                         ast::TypeImplItem(_) => None,\n+                        ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\")\n                     }\n                 },\n                 ast_map::NodeTraitItem(item) => {\n                     match item.node {\n-                        ast::ProvidedMethod(ref m) => {\n-                            Some((&m.pe_sig().decl,\n-                                  &m.pe_sig().generics,\n-                                  m.pe_sig().unsafety,\n+                        ast::MethodTraitItem(ref sig, Some(_)) => {\n+                            Some((&sig.decl,\n+                                  &sig.generics,\n+                                  sig.unsafety,\n                                   item.ident,\n-                                  Some(&m.pe_sig().explicit_self.node),\n+                                  Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n                         _ => None\n@@ -1731,11 +1732,12 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match ii.node {\n-                    ast::MethodImplItem(ref m) => {\n-                        taken.push_all(&m.pe_sig().generics.lifetimes);\n+                    ast::MethodImplItem(ref sig, _) => {\n+                        taken.push_all(&sig.generics.lifetimes);\n                         Some(ii.id)\n                     }\n                     ast::TypeImplItem(_) => None,\n+                    ast::MacImplItem(_) => tcx.sess.bug(\"unexpanded macro\")\n                 }\n             }\n             _ => None"}, {"sha": "7ded344414ce698bf328818b6ea1ef645553bd0d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -25,7 +25,7 @@ use std::collections::HashSet;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{is_local, PostExpansionMethod};\n+use syntax::ast_util::is_local;\n use syntax::attr;\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -53,11 +53,11 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n     }\n }\n \n-fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n+fn method_might_be_inlined(tcx: &ty::ctxt, sig: &ast::MethodSig,\n                            impl_item: &ast::ImplItem,\n                            impl_src: ast::DefId) -> bool {\n     if attr::requests_inline(&impl_item.attrs) ||\n-        generics_require_inlining(&method.pe_sig().generics) {\n+        generics_require_inlining(&sig.generics) {\n         return true\n     }\n     if is_local(impl_src) {\n@@ -183,15 +183,14 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             Some(ast_map::NodeTraitItem(trait_method)) => {\n                 match trait_method.node {\n-                    ast::RequiredMethod(_) => false,\n-                    ast::ProvidedMethod(_) => true,\n+                    ast::MethodTraitItem(_, ref body) => body.is_some(),\n                     ast::TypeTraitItem(..) => false,\n                 }\n             }\n             Some(ast_map::NodeImplItem(impl_item)) => {\n                 match impl_item.node {\n-                    ast::MethodImplItem(ref method) => {\n-                        if generics_require_inlining(&method.pe_sig().generics) ||\n+                    ast::MethodImplItem(ref sig, _) => {\n+                        if generics_require_inlining(&sig.generics) ||\n                                 attr::requests_inline(&impl_item.attrs) {\n                             true\n                         } else {\n@@ -214,6 +213,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         }\n                     }\n                     ast::TypeImplItem(_) => false,\n+                    ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\")\n                 }\n             }\n             Some(_) => false,\n@@ -303,24 +303,25 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n                 match trait_method.node {\n-                    ast::RequiredMethod(..) => {\n+                    ast::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    ast::ProvidedMethod(ref method) => {\n-                        visit::walk_block(self, &*method.pe_body());\n+                    ast::MethodTraitItem(_, Some(ref body)) => {\n+                        visit::walk_block(self, body);\n                     }\n                     ast::TypeTraitItem(..) => {}\n                 }\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match impl_item.node {\n-                    ast::MethodImplItem(ref method) => {\n+                    ast::MethodImplItem(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n-                        if method_might_be_inlined(self.tcx, method, impl_item, did) {\n-                            visit::walk_block(self, method.pe_body())\n+                        if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n+                            visit::walk_block(self, body)\n                         }\n                     }\n                     ast::TypeImplItem(_) => {}\n+                    ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\")\n                 }\n             }\n             // Nothing to recurse on for these"}, {"sha": "e33a255343161b17769f70912d74badd77e7d394", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -25,7 +25,6 @@ use middle::subst;\n use middle::ty;\n use std::fmt;\n use syntax::ast;\n-use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n@@ -148,8 +147,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                     visit::walk_fn(this, fk, fd, b, s)\n                 })\n             }\n-            visit::FkMethod(_, m) => {\n-                self.visit_early_late(subst::FnSpace, &m.pe_sig().generics, |this| {\n+            visit::FkMethod(_, sig) => {\n+                self.visit_early_late(subst::FnSpace, &sig.generics, |this| {\n                     visit::walk_fn(this, fk, fd, b, s)\n                 })\n             }\n@@ -191,9 +190,9 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n-        if let ast::RequiredMethod(ref m) = trait_item.node {\n+        if let ast::MethodTraitItem(ref sig, None) = trait_item.node {\n             self.visit_early_late(\n-                subst::FnSpace, &m.generics,\n+                subst::FnSpace, &sig.generics,\n                 |this| visit::walk_trait_item(this, trait_item))\n         } else {\n             visit::walk_trait_item(self, trait_item);"}, {"sha": "14d61a37008795fcbb7dbf1b838fc044950e6eff", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -82,7 +82,7 @@ use syntax::abi;\n use syntax::ast::{CrateNum, DefId, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{StmtExpr, StmtSemi, StructField, UnnamedField, Visibility};\n-use syntax::ast_util::{self, is_local, lit_is_str, local_def, PostExpansionMethod};\n+use syntax::ast_util::{self, is_local, lit_is_str, local_def};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::parse::token::{self, InternedString, special_idents};\n@@ -2287,7 +2287,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n-                    ast::MethodImplItem(ref method) => {\n+                    ast::MethodImplItem(_, ref body) => {\n                         let method_def_id = ast_util::local_def(id);\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n@@ -2298,7 +2298,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     impl_item.span,\n                                     method_generics,\n                                     method_bounds,\n-                                    method.pe_body().id)\n+                                    body.id)\n                             }\n                             TypeTraitItem(_) => {\n                                 cx.sess\n@@ -2313,18 +2313,19 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                      can't create a parameter environment \\\n                                      for type impl items\")\n                     }\n+                    ast::MacImplItem(_) => cx.sess.bug(\"unexpanded macro\")\n                 }\n             }\n             Some(ast_map::NodeTraitItem(trait_item)) => {\n                 match trait_item.node {\n-                    ast::RequiredMethod(_) => {\n+                    ast::MethodTraitItem(_, None) => {\n                         cx.sess.span_bug(trait_item.span,\n                                          \"ParameterEnvironment::for_item():\n                                           can't create a parameter \\\n                                           environment for required trait \\\n                                           methods\")\n                     }\n-                    ast::ProvidedMethod(ref method) => {\n+                    ast::MethodTraitItem(_, Some(ref body)) => {\n                         let method_def_id = ast_util::local_def(id);\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n@@ -2335,7 +2336,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     trait_item.span,\n                                     method_generics,\n                                     method_bounds,\n-                                    method.pe_body().id)\n+                                    body.id)\n                             }\n                             TypeTraitItem(_) => {\n                                 cx.sess\n@@ -5082,7 +5083,7 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n     if is_local(id) {\n         if let ItemTrait(_, _, _, ref ms) = cx.map.expect_item(id.node).node {\n             ms.iter().filter_map(|ti| {\n-                if let ast::ProvidedMethod(_) = ti.node {\n+                if let ast::MethodTraitItem(_, Some(_)) = ti.node {\n                     match impl_or_trait_item(cx, ast_util::local_def(ti.id)) {\n                         MethodTraitItem(m) => Some(m),\n                         TypeTraitItem(_) => {"}, {"sha": "3a0b5832c9f5b626abfab415b74d7afcc9eda8cd", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -829,8 +829,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n impl<'tcx> Repr<'tcx> for ast::TraitItem {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         let kind = match self.node {\n-            ast::RequiredMethod(_) => \"RequiredMethod\",\n-            ast::ProvidedMethod(_) => \"ProvidedMethod\",\n+            ast::MethodTraitItem(..) => \"MethodTraitItem\",\n             ast::TypeTraitItem(..) => \"TypeTraitItem\",\n         };\n         format!(\"{}({}, id={})\", kind, self.ident, self.id)"}, {"sha": "074591fb927d2abb11714f4a5a30c40b12aa1424", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -46,7 +46,7 @@ use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n use syntax::{abi, ast, ast_map};\n-use syntax::ast_util::{self, is_shift_binop, local_def, PostExpansionMethod};\n+use syntax::ast_util::{self, is_shift_binop, local_def};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n@@ -1005,7 +1005,7 @@ impl LintPass for NonSnakeCase {\n     }\n \n     fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n-        if let ast::RequiredMethod(_) = trait_item.node {\n+        if let ast::MethodTraitItem(_, None) = trait_item.node {\n             self.check_snake_case(cx, \"trait method\", trait_item.ident, trait_item.span);\n         }\n     }\n@@ -1318,8 +1318,8 @@ impl LintPass for UnsafeCode {\n             visit::FkItemFn(_, _, ast::Unsafety::Unsafe, _) =>\n                 cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n \n-            visit::FkMethod(_, m) => {\n-                if m.pe_sig().unsafety == ast::Unsafety::Unsafe {\n+            visit::FkMethod(_, sig) => {\n+                if sig.unsafety == ast::Unsafety::Unsafe {\n                     cx.span_lint(UNSAFE_CODE, span, \"implementation of an `unsafe` method\")\n                 }\n             },\n@@ -1329,8 +1329,8 @@ impl LintPass for UnsafeCode {\n     }\n \n     fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n-        if let ast::RequiredMethod(ref m) = trait_item.node {\n-            if m.unsafety == ast::Unsafety::Unsafe {\n+        if let ast::MethodTraitItem(ref sig, None) = trait_item.node {\n+            if sig.unsafety == ast::Unsafety::Unsafe {\n                 cx.span_lint(UNSAFE_CODE, trait_item.span,\n                              \"declaration of an `unsafe` method\")\n             }\n@@ -1564,8 +1564,7 @@ impl LintPass for MissingDoc {\n \n     fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n         let desc = match trait_item.node {\n-            ast::ProvidedMethod(_) => \"a default method\",\n-            ast::RequiredMethod(_) => \"a trait method\",\n+            ast::MethodTraitItem(..) => \"a trait method\",\n             ast::TypeTraitItem(..) => \"an associated type\"\n         };\n         self.check_missing_docs_attrs(cx, Some(trait_item.id),\n@@ -1580,8 +1579,9 @@ impl LintPass for MissingDoc {\n         }\n \n         let desc = match impl_item.node {\n-            ast::MethodImplItem(_) => \"a method\",\n-            ast::TypeImplItem(_) => \"an associated type\"\n+            ast::MethodImplItem(..) => \"a method\",\n+            ast::TypeImplItem(_) => \"an associated type\",\n+            ast::MacImplItem(_) => \"an impl item macro\"\n         };\n         self.check_missing_docs_attrs(cx, Some(impl_item.id),\n                                       &impl_item.attrs,"}, {"sha": "27f807ebe429b53cb7f0f8b6ca7e650164134348", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -48,7 +48,7 @@ use rustc::middle::ty::{self, Ty};\n use rustc::util::nodemap::{NodeMap, NodeSet};\n \n use syntax::{ast, ast_map};\n-use syntax::ast_util::{is_local, local_def, PostExpansionMethod};\n+use syntax::ast_util::{is_local, local_def};\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit::{self, Visitor};\n@@ -273,17 +273,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 if public_ty || public_trait {\n                     for impl_item in impl_items {\n                         match impl_item.node {\n-                            ast::MethodImplItem(ref method) => {\n-                                let meth_public =\n-                                    match method.pe_sig().explicit_self.node {\n-                                        ast::SelfStatic => public_ty,\n-                                        _ => true,\n-                                    } && impl_item.vis == ast::Public;\n+                            ast::MethodImplItem(ref sig, _) => {\n+                                let meth_public = match sig.explicit_self.node {\n+                                    ast::SelfStatic => public_ty,\n+                                    _ => true,\n+                                } && impl_item.vis == ast::Public;\n                                 if meth_public || tr.is_some() {\n                                     self.exported_items.insert(impl_item.id);\n                                 }\n                             }\n-                            ast::TypeImplItem(_) => {}\n+                            ast::TypeImplItem(_) |\n+                            ast::MacImplItem(_) => {}\n                         }\n                     }\n                 }\n@@ -491,7 +491,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 //               where the method was defined?\n                 Some(ast_map::NodeImplItem(ii)) => {\n                     match ii.node {\n-                        ast::MethodImplItem(_) => {\n+                        ast::MethodImplItem(..) => {\n                             let imp = self.tcx.map\n                                           .get_parent_did(closest_private_id);\n                             match ty::impl_trait_ref(self.tcx, imp) {\n@@ -502,7 +502,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                 _ => ii.vis\n                             }\n                         }\n-                        ast::TypeImplItem(_) => return Allowable,\n+                        ast::TypeImplItem(_) |\n+                        ast::MacImplItem(_) => return Allowable,\n                     }\n                 }\n                 Some(ast_map::NodeTraitItem(_)) => {\n@@ -1125,10 +1126,11 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n             ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 for impl_item in impl_items {\n                     match impl_item.node {\n-                        ast::MethodImplItem(_) => {\n+                        ast::MethodImplItem(..) => {\n                             check_inherited(tcx, impl_item.span, impl_item.vis);\n                         }\n-                        ast::TypeImplItem(_) => {}\n+                        ast::TypeImplItem(_) |\n+                        ast::MacImplItem(_) => {}\n                     }\n                 }\n             }\n@@ -1302,10 +1304,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     impl_items.iter()\n                               .any(|impl_item| {\n                                   match impl_item.node {\n-                                      ast::MethodImplItem(_) => {\n+                                      ast::MethodImplItem(..) => {\n                                           self.exported_items.contains(&impl_item.id)\n                                       }\n-                                      ast::TypeImplItem(_) => false,\n+                                      ast::TypeImplItem(_) |\n+                                      ast::MacImplItem(_) => false,\n                                   }\n                               });\n \n@@ -1340,10 +1343,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                             // Those in 3. are warned with this call.\n                             for impl_item in impl_items {\n                                 match impl_item.node {\n-                                    ast::MethodImplItem(..) => {},\n                                     ast::TypeImplItem(ref ty) => {\n                                         self.visit_ty(ty);\n                                     }\n+                                    ast::MethodImplItem(..) |\n+                                    ast::MacImplItem(_) => {},\n                                 }\n                             }\n                         }\n@@ -1354,16 +1358,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     let mut found_pub_static = false;\n                     for impl_item in impl_items {\n                         match impl_item.node {\n-                            ast::MethodImplItem(ref method) => {\n-                                if method.pe_sig().explicit_self.node ==\n-                                        ast::SelfStatic &&\n-                                        self.exported_items\n-                                            .contains(&impl_item.id) {\n+                            ast::MethodImplItem(ref sig, _) => {\n+                                if sig.explicit_self.node == ast::SelfStatic &&\n+                                   self.exported_items.contains(&impl_item.id) {\n                                     found_pub_static = true;\n                                     visit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n-                            ast::TypeImplItem(_) => {}\n+                            ast::TypeImplItem(_) |\n+                            ast::MacImplItem(_) => {}\n                         }\n                     }\n                     if found_pub_static {"}, {"sha": "1cbbcad9550904de917aa6b95d5a72aa8cdef0ab", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -531,8 +531,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                         trait_item.span);\n \n                     match trait_item.node {\n-                        ast::RequiredMethod(_) |\n-                        ast::ProvidedMethod(_) => {\n+                        ast::MethodTraitItem(..) => {\n                             let def = DefMethod(local_def(trait_item.id),\n                                                 FromTrait(local_def(item.id)));\n                             // NB: not IMPORTABLE"}, {"sha": "e49fdc9c5d3564edc39a0b25356ca1e853866f19", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -82,7 +82,7 @@ use syntax::ast::{TyRptr, TyStr, TyUs, TyU8, TyU16, TyU32, TyU64, TyUint};\n use syntax::ast::{TypeImplItem};\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{PostExpansionMethod, local_def, walk_pat};\n+use syntax::ast_util::{local_def, walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::{self, special_names, special_idents};\n@@ -242,9 +242,9 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                 self.visit_generics(generics);\n                 ItemRibKind\n             }\n-            visit::FkMethod(_, method) => {\n-                self.visit_generics(&method.pe_sig().generics);\n-                self.visit_explicit_self(&method.pe_sig().explicit_self);\n+            visit::FkMethod(_, sig) => {\n+                self.visit_generics(&sig.generics);\n+                self.visit_explicit_self(&sig.explicit_self);\n                 MethodRibKind\n             }\n             visit::FkFnBlock(..) => ClosureRibKind(node_id)\n@@ -2814,16 +2814,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // FIXME #4951: Do we need a node ID here?\n \n                         let type_parameters = match trait_item.node {\n-                            ast::RequiredMethod(ref sig) => {\n+                            ast::MethodTraitItem(ref sig, _) => {\n                                 HasTypeParameters(&sig.generics,\n                                                   FnSpace,\n                                                   MethodRibKind)\n                             }\n-                            ast::ProvidedMethod(ref m) => {\n-                                HasTypeParameters(&m.pe_sig().generics,\n-                                                  FnSpace,\n-                                                  MethodRibKind)\n-                            }\n                             ast::TypeTraitItem(..) => {\n                                 this.check_if_primitive_type_name(trait_item.ident.name,\n                                                                   trait_item.span);\n@@ -3066,7 +3061,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 this.with_current_self_type(self_type, |this| {\n                     for impl_item in impl_items {\n                         match impl_item.node {\n-                            MethodImplItem(ref method) => {\n+                            MethodImplItem(ref sig, _) => {\n                                 // If this is a trait impl, ensure the method\n                                 // exists in trait\n                                 this.check_trait_item(impl_item.ident.name,\n@@ -3075,7 +3070,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 // We also need a new scope for the method-\n                                 // specific type parameters.\n                                 let type_parameters =\n-                                    HasTypeParameters(&method.pe_sig().generics,\n+                                    HasTypeParameters(&sig.generics,\n                                                       FnSpace,\n                                                       MethodRibKind);\n                                 this.with_type_parameter_rib(type_parameters, |this| {\n@@ -3090,6 +3085,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                                 this.visit_ty(ty);\n                             }\n+                            ast::MacImplItem(_) => {}\n                         }\n                     }\n                 });\n@@ -3953,19 +3949,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         fn is_static_method(this: &Resolver, did: DefId) -> bool {\n             if did.krate == ast::LOCAL_CRATE {\n-                let explicit_self = match this.ast_map.get(did.node) {\n+                let sig = match this.ast_map.get(did.node) {\n                     ast_map::NodeTraitItem(trait_item) => match trait_item.node {\n-                        ast::RequiredMethod(ref m) => &m.explicit_self,\n-                        ast::ProvidedMethod(ref m) => &m.pe_sig().explicit_self,\n+                        ast::MethodTraitItem(ref sig, _) => sig,\n                         _ => return false\n                     },\n                     ast_map::NodeImplItem(impl_item) => match impl_item.node {\n-                        ast::MethodImplItem(ref m) => &m.pe_sig().explicit_self,\n+                        ast::MethodImplItem(ref sig, _) => sig,\n                         _ => return false\n                     },\n                     _ => return false\n                 };\n-                explicit_self.node == ast::SelfStatic\n+                sig.explicit_self.node == ast::SelfStatic\n             } else {\n                 csearch::is_static_method(&this.session.cstore, did)\n             }"}, {"sha": "83bb5efb425d26564f746145dcba376b4086f67b", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 36, "deletions": 71, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -37,7 +37,7 @@ use std::env;\n use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n-use syntax::ast_util::{self, PostExpansionMethod};\n+use syntax::ast_util;\n use syntax::ast::{self, NodeId, DefId};\n use syntax::ast_map::NodeItem;\n use syntax::attr;\n@@ -284,7 +284,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_method(&mut self, method: &ast::Method,\n+    fn process_method(&mut self, sig: &ast::MethodSig,\n+                      body: Option<&ast::Block>,\n                       id: ast::NodeId, ident: ast::Ident,\n                       span: Span) {\n         if generated_code(span) {\n@@ -351,8 +352,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             },\n         };\n \n-        let qualname = format!(\"{}::{}\", qualname, &get_ident(ident));\n-        let qualname = &qualname[..];\n+        let qualname = &format!(\"{}::{}\", qualname, &get_ident(ident));\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n@@ -364,39 +364,44 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     }\n                     ty::TypeTraitItemId(_) => false,\n                 } {\n-                    Some(def_id)\n+                    Some(def_id.def_id())\n                 } else {\n                     None\n                 }\n             });\n-        let decl_id = match decl_id {\n-            None => None,\n-            Some(id) => Some(id.def_id()),\n-        };\n \n         let sub_span = self.span.sub_span_after_keyword(span, keywords::Fn);\n-        self.fmt.method_str(span,\n-                            sub_span,\n-                            id,\n-                            qualname,\n-                            decl_id,\n-                            scope_id);\n-\n-        self.process_formals(&method.pe_sig().decl.inputs, qualname);\n+        if body.is_some() {\n+            self.fmt.method_str(span,\n+                                sub_span,\n+                                id,\n+                                qualname,\n+                                decl_id,\n+                                scope_id);\n+            self.process_formals(&sig.decl.inputs, qualname);\n+        } else {\n+            self.fmt.method_decl_str(span,\n+                                     sub_span,\n+                                     id,\n+                                     qualname,\n+                                     scope_id);\n+        }\n \n         // walk arg and return types\n-        for arg in &method.pe_sig().decl.inputs {\n-            self.visit_ty(&*arg.ty);\n+        for arg in &sig.decl.inputs {\n+            self.visit_ty(&arg.ty);\n         }\n \n-        if let ast::Return(ref ret_ty) = method.pe_sig().decl.output {\n-            self.visit_ty(&**ret_ty);\n+        if let ast::Return(ref ret_ty) = sig.decl.output {\n+            self.visit_ty(ret_ty);\n         }\n \n         // walk the fn body\n-        self.nest(id, |v| v.visit_block(&*method.pe_body()));\n+        if let Some(body) = body {\n+            self.nest(id, |v| v.visit_block(body));\n+        }\n \n-        self.process_generic_params(&method.pe_sig().generics,\n+        self.process_generic_params(&sig.generics,\n                                     span,\n                                     qualname,\n                                     id);\n@@ -1226,62 +1231,22 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n         match trait_item.node {\n-            ast::RequiredMethod(ref method_type) => {\n-                if generated_code(trait_item.span) {\n-                    return;\n-                }\n-\n-                let mut scope_id;\n-                let mut qualname = match ty::trait_of_item(&self.analysis.ty_cx,\n-                                                           ast_util::local_def(trait_item.id)) {\n-                    Some(def_id) => {\n-                        scope_id = def_id.node;\n-                        format!(\"::{}::\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n-                    },\n-                    None => {\n-                        self.sess.span_bug(trait_item.span,\n-                                           &format!(\"Could not find trait for method {}\",\n-                                                   trait_item.id));\n-                    },\n-                };\n-\n-                qualname.push_str(&get_ident(trait_item.ident));\n-                let qualname = &qualname[..];\n-\n-                let sub_span = self.span.sub_span_after_keyword(trait_item.span, keywords::Fn);\n-                self.fmt.method_decl_str(trait_item.span,\n-                                         sub_span,\n-                                         trait_item.id,\n-                                         qualname,\n-                                         scope_id);\n-\n-                // walk arg and return types\n-                for arg in &method_type.decl.inputs {\n-                    self.visit_ty(&*arg.ty);\n-                }\n-\n-                if let ast::Return(ref ret_ty) = method_type.decl.output {\n-                    self.visit_ty(&**ret_ty);\n-                }\n-\n-                self.process_generic_params(&method_type.generics,\n-                                            trait_item.span,\n-                                            qualname,\n-                                            trait_item.id);\n-            }\n-            ast::ProvidedMethod(ref method) => {\n-                self.process_method(method, trait_item.id, trait_item.ident, trait_item.span);\n+            ast::MethodTraitItem(ref sig, ref body) => {\n+                self.process_method(sig, body.as_ref().map(|x| &**x),\n+                                    trait_item.id, trait_item.ident, trait_item.span);\n             }\n             ast::TypeTraitItem(..) => {}\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n         match impl_item.node {\n-            ast::MethodImplItem(ref method) => {\n-                self.process_method(method, impl_item.id, impl_item.ident, impl_item.span);\n+            ast::MethodImplItem(ref sig, ref body) => {\n+                self.process_method(sig, Some(body), impl_item.id,\n+                                    impl_item.ident, impl_item.span);\n             }\n-            ast::TypeImplItem(_) => {}\n+            ast::TypeImplItem(_) |\n+            ast::MacImplItem(_) => {}\n         }\n     }\n "}, {"sha": "74326d4ea919c0e41c821478059f81a7a03f6c00", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -94,7 +94,7 @@ use std::rc::Rc;\n use std::str;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{Rust, RustCall, RustIntrinsic, Abi};\n-use syntax::ast_util::{local_def, PostExpansionMethod};\n+use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -1263,15 +1263,15 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n         Some(ast_map::NodeItem(i)) => {\n             match i.node {\n                 ast::ItemFn(_, _, _, _, ref blk) => {\n-                    &**blk\n+                    blk\n                 }\n                 _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n             }\n         }\n         Some(ast_map::NodeTraitItem(trait_item)) => {\n             match trait_item.node {\n-                ast::ProvidedMethod(ref m) => m.pe_body(),\n-                ast::RequiredMethod(_) => {\n+                ast::MethodTraitItem(_, Some(ref body)) => body,\n+                ast::MethodTraitItem(_, None) => {\n                     tcx.sess.bug(\"unexpected variant: required trait method \\\n                                   in has_nested_returns\")\n                 }\n@@ -1283,16 +1283,20 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n         }\n         Some(ast_map::NodeImplItem(impl_item)) => {\n             match impl_item.node {\n-                ast::MethodImplItem(ref m) => m.pe_body(),\n+                ast::MethodImplItem(_, ref body) => body,\n                 ast::TypeImplItem(_) => {\n                     tcx.sess.bug(\"unexpected variant: associated type impl item in \\\n                                   has_nested_returns\")\n                 }\n+                ast::MacImplItem(_) => {\n+                    tcx.sess.bug(\"unexpected variant: unexpanded macro impl item in \\\n+                                  has_nested_returns\")\n+                }\n             }\n         }\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n-                ast::ExprClosure(_, _, ref blk) => &**blk,\n+                ast::ExprClosure(_, _, ref blk) => blk,\n                 _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")\n             }\n         }\n@@ -2805,25 +2809,29 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         ast_map::NodeTraitItem(trait_item) => {\n             debug!(\"get_item_val(): processing a NodeTraitItem\");\n             match trait_item.node {\n-                ast::RequiredMethod(_) | ast::TypeTraitItem(..) => {\n+                ast::MethodTraitItem(_, None) | ast::TypeTraitItem(..) => {\n                     ccx.sess().span_bug(trait_item.span,\n                         \"unexpected variant: required trait method in get_item_val()\");\n                 }\n-                ast::ProvidedMethod(_) => {\n+                ast::MethodTraitItem(_, Some(_)) => {\n                     register_method(ccx, id, &trait_item.attrs, trait_item.span)\n                 }\n             }\n         }\n \n         ast_map::NodeImplItem(impl_item) => {\n             match impl_item.node {\n-                ast::MethodImplItem(_) => {\n+                ast::MethodImplItem(..) => {\n                     register_method(ccx, id, &impl_item.attrs, impl_item.span)\n                 }\n                 ast::TypeImplItem(_) => {\n                     ccx.sess().span_bug(impl_item.span,\n                         \"unexpected variant: associated type in get_item_val()\")\n                 }\n+                ast::MacImplItem(_) => {\n+                    ccx.sess().span_bug(impl_item.span,\n+                        \"unexpected variant: unexpanded macro in get_item_val()\")\n+                }\n             }\n         }\n "}, {"sha": "b5ab2c28251274562108433cfd20abd0eaec862e", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -217,7 +217,6 @@ use std::rc::{Rc, Weak};\n use syntax::util::interner::Interner;\n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap, ast_util, ast_map, attr};\n-use syntax::ast_util::PostExpansionMethod;\n use syntax::parse::token::{self, special_idents};\n \n const DW_LANG_RUST: c_uint = 0x9000;\n@@ -1292,7 +1291,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             match item.node {\n                 ast::ItemFn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n-                    (item.ident, fn_decl, generics, &**top_level_block, item.span, true)\n+                    (item.ident, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n                     cx.sess().span_bug(item.span,\n@@ -1302,15 +1301,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeImplItem(impl_item) => {\n             match impl_item.node {\n-                ast::MethodImplItem(ref method) => {\n+                ast::MethodImplItem(ref sig, ref body) => {\n                     if contains_nodebug_attribute(&impl_item.attrs) {\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n                     (impl_item.ident,\n-                     &method.pe_sig().decl,\n-                     &method.pe_sig().generics,\n-                     method.pe_body(),\n+                     &sig.decl,\n+                     &sig.generics,\n+                     body,\n                      impl_item.span,\n                      true)\n                 }\n@@ -1319,6 +1318,11 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                        \"create_function_debug_context() \\\n                                         called on associated type?!\")\n                 }\n+                ast::MacImplItem(_) => {\n+                    cx.sess().span_bug(impl_item.span,\n+                                       \"create_function_debug_context() \\\n+                                        called on unexpanded macro?!\")\n+                }\n             }\n         }\n         ast_map::NodeExpr(ref expr) => {\n@@ -1330,7 +1334,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n                         &empty_generics,\n-                        &**top_level_block,\n+                        top_level_block,\n                         expr.span,\n                         // Don't try to lookup the item path:\n                         false)\n@@ -1341,15 +1345,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeTraitItem(trait_item) => {\n             match trait_item.node {\n-                ast::ProvidedMethod(ref method) => {\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n                     if contains_nodebug_attribute(&trait_item.attrs) {\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n                     (trait_item.ident,\n-                     &method.pe_sig().decl,\n-                     &method.pe_sig().generics,\n-                     method.pe_body(),\n+                     &sig.decl,\n+                     &sig.generics,\n+                     body,\n                      trait_item.span,\n                      true)\n                 }"}, {"sha": "2034c6223c13410d0d77b964d1043cda27309b86", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -17,7 +17,7 @@ use trans::common::*;\n use middle::ty;\n \n use syntax::ast;\n-use syntax::ast_util::{local_def, PostExpansionMethod};\n+use syntax::ast_util::local_def;\n \n fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n     -> Option<ast::DefId> {\n@@ -146,19 +146,19 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n \n             // Translate monomorphic impl methods immediately.\n-            if let ast::MethodImplItem(ref mth) = impl_item.node {\n+            if let ast::MethodImplItem(ref sig, ref body) = impl_item.node {\n                 let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n                 if impl_tpt.generics.types.is_empty() &&\n-                        mth.pe_sig().generics.ty_params.is_empty() {\n+                        sig.generics.ty_params.is_empty() {\n                     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n                     let llfn = get_item_val(ccx, impl_item.id);\n                     trans_fn(ccx,\n-                            &*mth.pe_sig().decl,\n-                            &*mth.pe_body(),\n-                            llfn,\n-                            empty_substs,\n-                            impl_item.id,\n-                            &[]);\n+                             &sig.decl,\n+                             body,\n+                             llfn,\n+                             empty_substs,\n+                             impl_item.id,\n+                             &[]);\n                     // Use InternalLinkage so LLVM can optimize more aggressively.\n                     SetLinkage(llfn, InternalLinkage);\n                 }"}, {"sha": "ba3798d7d8028e1ff79afce6e86a5aafbe77c33e", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -41,7 +41,6 @@ use std::rc::Rc;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n use syntax::{ast, ast_map, attr, visit};\n-use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::DUMMY_SP;\n use syntax::ptr::P;\n \n@@ -69,29 +68,25 @@ pub fn trans_impl(ccx: &CrateContext,\n     if !generics.ty_params.is_empty() {\n         for impl_item in impl_items {\n             match impl_item.node {\n-                ast::MethodImplItem(_) => {\n+                ast::MethodImplItem(..) => {\n                     visit::walk_impl_item(&mut v, impl_item);\n                 }\n-                ast::TypeImplItem(_) => {}\n+                ast::TypeImplItem(_) |\n+                ast::MacImplItem(_) => {}\n             }\n         }\n         return;\n     }\n     for impl_item in impl_items {\n         match impl_item.node {\n-            ast::MethodImplItem(ref method) => {\n-                if method.pe_sig().generics.ty_params.len() == 0 {\n+            ast::MethodImplItem(ref sig, ref body) => {\n+                if sig.generics.ty_params.len() == 0 {\n                     let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, impl_item.id);\n                         let empty_substs = tcx.mk_substs(Substs::trans_empty());\n-                        trans_fn(ccx,\n-                                 &method.pe_sig().decl,\n-                                 method.pe_body(),\n-                                 llfn,\n-                                 empty_substs,\n-                                 impl_item.id,\n-                                 &[]);\n+                        trans_fn(ccx, &sig.decl, body, llfn,\n+                                 empty_substs, impl_item.id, &[]);\n                         update_linkage(ccx,\n                                        llfn,\n                                        Some(impl_item.id),\n@@ -100,7 +95,8 @@ pub fn trans_impl(ccx: &CrateContext,\n                 }\n                 visit::walk_impl_item(&mut v, impl_item);\n             }\n-            ast::TypeImplItem(_) => {}\n+            ast::TypeImplItem(_) |\n+            ast::MacImplItem(_) => {}\n         }\n     }\n }"}, {"sha": "2083e737f89b117e0f984535712aec0fb866fba4", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -29,7 +29,7 @@ use util::ppaux::Repr;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{local_def, PostExpansionMethod};\n+use syntax::ast_util::local_def;\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n use std::hash::{Hasher, Hash, SipHasher};\n@@ -218,13 +218,13 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeImplItem(impl_item) => {\n             match impl_item.node {\n-                ast::MethodImplItem(ref mth) => {\n+                ast::MethodImplItem(ref sig, ref body) => {\n                     let d = mk_lldecl(abi::Rust);\n                     let needs_body = setup_lldecl(d, &impl_item.attrs);\n                     if needs_body {\n                         trans_fn(ccx,\n-                                 &mth.pe_sig().decl,\n-                                 mth.pe_body(),\n+                                 &sig.decl,\n+                                 body,\n                                  d,\n                                  psubsts,\n                                  impl_item.id,\n@@ -235,15 +235,18 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 ast::TypeImplItem(_) => {\n                     ccx.sess().bug(\"can't monomorphize an associated type\")\n                 }\n+                ast::MacImplItem(_) => {\n+                    ccx.sess().bug(\"can't monomorphize an unexpanded macro\")\n+                }\n             }\n         }\n         ast_map::NodeTraitItem(trait_item) => {\n             match trait_item.node {\n-                ast::ProvidedMethod(ref mth) => {\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n                     let d = mk_lldecl(abi::Rust);\n                     let needs_body = setup_lldecl(d, &trait_item.attrs);\n                     if needs_body {\n-                        trans_fn(ccx, &mth.pe_sig().decl, mth.pe_body(), d,\n+                        trans_fn(ccx, &sig.decl, body, d,\n                                  psubsts, trait_item.id, &[]);\n                     }\n                     d"}, {"sha": "41951ab2b620087368480fe58f69cf0dcf12517b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -119,8 +119,8 @@ use std::iter::repeat;\n use std::slice;\n use syntax::{self, abi, attr};\n use syntax::attr::AttrMetaMethods;\n-use syntax::ast::{self, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId, Visibility};\n-use syntax::ast_util::{self, local_def, PostExpansionMethod};\n+use syntax::ast::{self, DefId, Visibility};\n+use syntax::ast_util::{self, local_def};\n use syntax::codemap::{self, Span};\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n@@ -740,11 +740,12 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n \n         for impl_item in impl_items {\n             match impl_item.node {\n-                ast::MethodImplItem(ref m) => {\n-                    check_method_body(ccx, &impl_pty.generics, m,\n+                ast::MethodImplItem(ref sig, ref body) => {\n+                    check_method_body(ccx, &impl_pty.generics, sig, body,\n                                       impl_item.id, impl_item.span);\n                 }\n-                ast::TypeImplItem(_) => {\n+                ast::TypeImplItem(_) |\n+                ast::MacImplItem(_) => {\n                     // Nothing to do here.\n                 }\n             }\n@@ -756,15 +757,15 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n-                RequiredMethod(..) => {\n+                ast::MethodTraitItem(_, None) => {\n                     // Nothing to do, since required methods don't have\n                     // bodies to check.\n                 }\n-                ProvidedMethod(ref m) => {\n-                    check_method_body(ccx, &trait_def.generics, m,\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                    check_method_body(ccx, &trait_def.generics, sig, body,\n                                       trait_item.id, trait_item.span);\n                 }\n-                TypeTraitItem(..) => {\n+                ast::TypeTraitItem(..) => {\n                     // Nothing to do.\n                 }\n             }\n@@ -857,7 +858,8 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n /// * `method`: the method definition\n fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                item_generics: &ty::Generics<'tcx>,\n-                               method: &'tcx ast::Method,\n+                               sig: &'tcx ast::MethodSig,\n+                               body: &'tcx ast::Block,\n                                id: ast::NodeId, span: Span) {\n     debug!(\"check_method_body(item_generics={}, id={})\",\n             item_generics.repr(ccx.tcx), id);\n@@ -866,13 +868,7 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n     debug!(\"check_method_body: fty={}\", fty.repr(ccx.tcx));\n \n-    check_bare_fn(ccx,\n-                  &*method.pe_sig().decl,\n-                  &*method.pe_body(),\n-                  id,\n-                  span,\n-                  fty,\n-                  param_env);\n+    check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n }\n \n fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -887,7 +883,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // and compatible with trait signature\n     for impl_item in impl_items {\n         match impl_item.node {\n-            ast::MethodImplItem(ref impl_method) => {\n+            ast::MethodImplItem(_, ref body) => {\n                 let impl_method_def_id = local_def(impl_item.id);\n                 let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n                                                           impl_method_def_id);\n@@ -905,7 +901,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 compare_impl_method(ccx.tcx,\n                                                     &**impl_method_ty,\n                                                     impl_item.span,\n-                                                    impl_method.pe_body().id,\n+                                                    body.id,\n                                                     &**trait_method_ty,\n                                                     &*impl_trait_ref);\n                             }\n@@ -969,6 +965,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     }\n                 }\n             }\n+            ast::MacImplItem(_) => tcx.sess.span_bug(impl_item.span,\n+                                                     \"unexpanded macro\")\n         }\n     }\n \n@@ -981,10 +979,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let is_implemented =\n                     impl_items.iter().any(|ii| {\n                         match ii.node {\n-                            ast::MethodImplItem(_) => {\n+                            ast::MethodImplItem(..) => {\n                                 ii.ident.name == trait_method.name\n                             }\n-                            ast::TypeImplItem(_) => false,\n+                            ast::TypeImplItem(_) |\n+                            ast::MacImplItem(_) => false,\n                         }\n                     });\n                 let is_provided =\n@@ -999,7 +998,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         ast::TypeImplItem(_) => {\n                             ii.ident.name == associated_type.name\n                         }\n-                        ast::MethodImplItem(_) => false,\n+                        ast::MethodImplItem(..) |\n+                        ast::MacImplItem(_) => false,\n                     }\n                 });\n                 if !is_implemented {"}, {"sha": "adbf4c6b210e83a345146680bb601525da776f89", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -499,7 +499,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'v ast::TraitItem) {\n-        if let ast::RequiredMethod(_) = trait_item.node {\n+        if let ast::MethodTraitItem(_, None) = trait_item.node {\n             match ty::impl_or_trait_item(self.tcx(), local_def(trait_item.id)) {\n                 ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                     reject_non_type_param_bounds("}, {"sha": "6b0fb8ac71af0479f8b3ab85cc304448da19fac6", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -279,12 +279,16 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 let mut items: Vec<ImplOrTraitItemId> =\n                         impl_items.iter().map(|impl_item| {\n                     match impl_item.node {\n-                        ast::MethodImplItem(_) => {\n+                        ast::MethodImplItem(..) => {\n                             MethodTraitItemId(local_def(impl_item.id))\n                         }\n                         ast::TypeImplItem(_) => {\n                             TypeTraitItemId(local_def(impl_item.id))\n                         }\n+                        ast::MacImplItem(_) => {\n+                            self.crate_context.tcx.sess.span_bug(impl_item.span,\n+                                                                 \"unexpanded macro\");\n+                        }\n                     }\n                 }).collect();\n "}, {"sha": "23726805767978baca036df89d988257381450b2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -89,7 +89,7 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{local_def, PostExpansionMethod};\n+use syntax::ast_util::local_def;\n use syntax::codemap::Span;\n use syntax::parse::token::{special_idents};\n use syntax::parse::token;\n@@ -847,7 +847,6 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             // Convert all the associated types.\n             for impl_item in impl_items {\n                 match impl_item.node {\n-                    ast::MethodImplItem(_) => {}\n                     ast::TypeImplItem(ref ty) => {\n                         if opt_trait_ref.is_none() {\n                             span_err!(tcx.sess, impl_item.span, E0202,\n@@ -867,20 +866,23 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                                            ty::GenericPredicates::empty());\n                         write_ty_to_tcx(tcx, impl_item.id, typ);\n                     }\n+                    ast::MethodImplItem(..) |\n+                    ast::MacImplItem(_) => {}\n                 }\n             }\n \n             let methods = impl_items.iter().filter_map(|ii| {\n                 match ii.node {\n-                    ast::MethodImplItem(ref m) => {\n+                    ast::MethodImplItem(ref sig, _) => {\n                         // if the method specifies a visibility, use that, otherwise\n                         // inherit the visibility from the impl (so `foo` in `pub impl\n                         // { fn foo(); }` is public, but private in `priv impl { fn\n                         // foo(); }`).\n                         let method_vis = ii.vis.inherit_from(parent_visibility);\n-                        Some((m.pe_sig(), ii.id, ii.ident, method_vis, ii.span))\n+                        Some((sig, ii.id, ii.ident, method_vis, ii.span))\n                     }\n-                    ast::TypeImplItem(_) => None\n+                    ast::TypeImplItem(_) |\n+                    ast::MacImplItem(_) => None\n                 }\n             });\n             convert_methods(ccx,\n@@ -892,16 +894,17 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             for impl_item in impl_items {\n                 match impl_item.node {\n-                    ast::MethodImplItem(ref method) => {\n-                        let body_id = method.pe_body().id;\n+                    ast::MethodImplItem(ref sig, ref body) => {\n+                        let body_id = body.id;\n                         check_method_self_type(ccx,\n                                                &BindingRscope::new(),\n                                                ccx.method_ty(impl_item.id),\n                                                selfty,\n-                                               &method.pe_sig().explicit_self,\n+                                               &sig.explicit_self,\n                                                body_id);\n                     }\n-                    ast::TypeImplItem(_) => {}\n+                    ast::TypeImplItem(_) |\n+                    ast::MacImplItem(_) => {}\n                 }\n             }\n \n@@ -930,8 +933,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             // Convert all the associated types.\n             for trait_item in trait_items {\n                 match trait_item.node {\n-                    ast::RequiredMethod(_) |\n-                    ast::ProvidedMethod(_) => {}\n+                    ast::MethodTraitItem(..) => {}\n                     ast::TypeTraitItem(..) => {\n                         convert_associated_type(ccx, TraitContainer(local_def(it.id)),\n                                                 trait_item.ident, trait_item.id, ast::Public);\n@@ -941,8 +943,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             let methods = trait_items.iter().filter_map(|ti| {\n                 let sig = match ti.node {\n-                    ast::RequiredMethod(ref sig) => sig,\n-                    ast::ProvidedMethod(ref m) => m.pe_sig(),\n+                    ast::MethodTraitItem(ref sig, _) => sig,\n                     ast::TypeTraitItem(..) => return None,\n                 };\n                 Some((sig, ti.id, ti.ident, ast::Inherited, ti.span))\n@@ -960,8 +961,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n                 let def_id = local_def(trait_item.id);\n                 match trait_item.node {\n-                    ast::RequiredMethod(_) |\n-                    ast::ProvidedMethod(_) => {\n+                    ast::MethodTraitItem(..) => {\n                         ty::MethodTraitItemId(def_id)\n                     }\n                     ast::TypeTraitItem(..) => {\n@@ -975,8 +975,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             // we have a method type stored for every method.\n             for trait_item in trait_items {\n                 let sig = match trait_item.node {\n-                    ast::RequiredMethod(ref sig) => sig,\n-                    ast::ProvidedMethod(ref method) => method.pe_sig(),\n+                    ast::MethodTraitItem(ref sig, _) => sig,\n                     ast::TypeTraitItem(..) => continue\n                 };\n                 check_method_self_type(ccx,\n@@ -1196,7 +1195,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n         match trait_item.node {\n-            ast::RequiredMethod(_) | ast::ProvidedMethod(_) => None,\n+            ast::MethodTraitItem(..) => None,\n             ast::TypeTraitItem(..) => Some(trait_item.ident.name),\n         }\n     }).collect();\n@@ -1269,7 +1268,7 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n     trait_items.iter().any(|trait_item| {\n         match trait_item.node {\n             ast::TypeTraitItem(..) => trait_item.ident.name == assoc_name,\n-            ast::RequiredMethod(_) | ast::ProvidedMethod(_) => false,\n+            ast::MethodTraitItem(..) => false,\n         }\n     })\n }\n@@ -1329,7 +1328,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         trait_items.iter().flat_map(|trait_item| {\n             let bounds = match trait_item.node {\n                 ast::TypeTraitItem(ref bounds, _) => bounds,\n-                ast::RequiredMethod(..) | ast::ProvidedMethod(..) => {\n+                ast::MethodTraitItem(..) => {\n                     return vec!().into_iter();\n                 }\n             };"}, {"sha": "e91e95961c521157153c54280f455c3c7980c727", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -28,7 +28,6 @@ use syntax;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::ast_util::PostExpansionMethod;\n use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap;\n@@ -949,26 +948,26 @@ pub struct Method {\n     pub abi: abi::Abi\n }\n \n-impl Clean<Method> for ast::Method {\n+impl Clean<Method> for ast::MethodSig {\n     fn clean(&self, cx: &DocContext) -> Method {\n-        let all_inputs = &self.pe_sig().decl.inputs;\n-        let inputs = match self.pe_sig().explicit_self.node {\n+        let all_inputs = &self.decl.inputs;\n+        let inputs = match self.explicit_self.node {\n             ast::SelfStatic => &**all_inputs,\n             _ => &all_inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n                 values: inputs.clean(cx),\n             },\n-            output: self.pe_sig().decl.output.clean(cx),\n+            output: self.decl.output.clean(cx),\n             attrs: Vec::new()\n         };\n         Method {\n-            generics: self.pe_sig().generics.clean(cx),\n-            self_: self.pe_sig().explicit_self.node.clean(cx),\n-            unsafety: self.pe_sig().unsafety.clone(),\n+            generics: self.generics.clean(cx),\n+            self_: self.explicit_self.node.clean(cx),\n+            unsafety: self.unsafety.clone(),\n             decl: decl,\n-            abi: self.pe_sig().abi\n+            abi: self.abi\n         }\n     }\n }\n@@ -1190,8 +1189,12 @@ impl Clean<PolyTrait> for ast::PolyTraitRef {\n impl Clean<Item> for ast::TraitItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n-            ast::ProvidedMethod(ref m) => MethodItem(m.clean(cx)),\n-            ast::RequiredMethod(ref m) => TyMethodItem(m.clean(cx)),\n+            ast::MethodTraitItem(ref sig, Some(_)) => {\n+                MethodItem(sig.clean(cx))\n+            }\n+            ast::MethodTraitItem(ref sig, None) => {\n+                TyMethodItem(sig.clean(cx))\n+            }\n             ast::TypeTraitItem(ref bounds, ref default) => {\n                 AssociatedTypeItem(bounds.clean(cx), default.clean(cx))\n             }\n@@ -1211,7 +1214,9 @@ impl Clean<Item> for ast::TraitItem {\n impl Clean<Item> for ast::ImplItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n-            ast::MethodImplItem(ref m) => MethodItem(m.clean(cx)),\n+            ast::MethodImplItem(ref sig, _) => {\n+                MethodItem(sig.clean(cx))\n+            }\n             ast::TypeImplItem(ref ty) => TypedefItem(Typedef {\n                 type_: ty.clean(cx),\n                 generics: Generics {\n@@ -1220,6 +1225,11 @@ impl Clean<Item> for ast::ImplItem {\n                     where_predicates: Vec::new()\n                 },\n             }),\n+            ast::MacImplItem(_) => {\n+                MacroItem(Macro {\n+                    source: self.span.to_src(cx),\n+                })\n+            }\n         };\n         Item {\n             name: Some(self.ident.clean(cx)),"}, {"sha": "657ffcaece9f85f3fd7020f230703caad296e6e6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -33,7 +33,6 @@ pub use self::LocalSource::*;\n pub use self::Mac_::*;\n pub use self::MacStmtStyle::*;\n pub use self::MetaItem_::*;\n-pub use self::Method::*;\n pub use self::Mutability::*;\n pub use self::Pat_::*;\n pub use self::PathListItem_::*;\n@@ -1084,8 +1083,7 @@ pub struct TraitItem {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitItem_ {\n-    RequiredMethod(MethodSig),\n-    ProvidedMethod(Method),\n+    MethodTraitItem(MethodSig, Option<P<Block>>),\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n }\n \n@@ -1101,8 +1099,9 @@ pub struct ImplItem {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ImplItem_ {\n-    MethodImplItem(Method),\n+    MethodImplItem(MethodSig, P<Block>),\n     TypeImplItem(P<Ty>),\n+    MacImplItem(Mac),\n }\n \n #[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n@@ -1416,14 +1415,6 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Method {\n-    /// Represents a method declaration\n-    MethDecl(MethodSig, P<Block>),\n-    /// Represents a macro in method position\n-    MethMac(Mac),\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`."}, {"sha": "16a339cdcb530b22e99d455cc76ab740f06ae4f8", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -28,7 +28,6 @@ use ast::{Block, FnDecl, NodeId};\n use ast;\n use ast_map::{Node};\n use ast_map;\n-use ast_util::PostExpansionMethod;\n use codemap::Span;\n use visit;\n \n@@ -65,7 +64,7 @@ impl MaybeFnLike for ast::Item {\n \n impl MaybeFnLike for ast::TraitItem {\n     fn is_fn_like(&self) -> bool {\n-        match self.node { ast::ProvidedMethod(_) => true, _ => false, }\n+        match self.node { ast::MethodTraitItem(_, Some(_)) => true, _ => false, }\n     }\n }\n \n@@ -156,25 +155,25 @@ impl<'a> FnLikeNode<'a> {\n \n     pub fn body(self) -> &'a Block {\n         self.handle(|i: ItemFnParts<'a>|  &*i.body,\n-                    |_, _, m: &'a ast::Method, _|  m.pe_body(),\n+                    |_, _, _: &'a ast::MethodSig, body: &'a ast::Block, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n     pub fn decl(self) -> &'a FnDecl {\n         self.handle(|i: ItemFnParts<'a>|  &*i.decl,\n-                    |_, _, m: &'a ast::Method, _|  &m.pe_sig().decl,\n+                    |_, _, sig: &'a ast::MethodSig, _, _|  &sig.decl,\n                     |c: ClosureParts<'a>| c.decl)\n     }\n \n     pub fn span(self) -> Span {\n         self.handle(|i: ItemFnParts|     i.span,\n-                    |_, _, _: &'a ast::Method, span| span,\n+                    |_, _, _: &'a ast::MethodSig, _, span| span,\n                     |c: ClosureParts|    c.span)\n     }\n \n     pub fn id(self) -> NodeId {\n         self.handle(|i: ItemFnParts|     i.id,\n-                    |id, _, _: &'a ast::Method, _| id,\n+                    |id, _, _: &'a ast::MethodSig, _, _| id,\n                     |c: ClosureParts|    c.id)\n     }\n \n@@ -185,15 +184,15 @@ impl<'a> FnLikeNode<'a> {\n         let closure = |_: ClosureParts| {\n             visit::FkFnBlock\n         };\n-        let method = |_, ident, m: &'a ast::Method, _| {\n-            visit::FkMethod(ident, m)\n+        let method = |_, ident, sig: &'a ast::MethodSig, _, _| {\n+            visit::FkMethod(ident, sig)\n         };\n         self.handle(item, method, closure)\n     }\n \n     fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n-        M: FnOnce(NodeId, ast::Ident, &'a ast::Method, Span) -> A,\n+        M: FnOnce(NodeId, ast::Ident, &'a ast::MethodSig, &'a ast::Block, Span) -> A,\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n@@ -206,13 +205,18 @@ impl<'a> FnLikeNode<'a> {\n                 _ => panic!(\"item FnLikeNode that is not fn-like\"),\n             },\n             ast_map::NodeTraitItem(ti) => match ti.node {\n-                ast::ProvidedMethod(ref m) => method(ti.id, ti.ident, m, ti.span),\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                    method(ti.id, ti.ident, sig, body, ti.span)\n+                }\n                 _ => panic!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match ii.node {\n-                    ast::MethodImplItem(ref m) => method(ii.id, ii.ident, m, ii.span),\n-                    ast::TypeImplItem(_) => {\n+                    ast::MethodImplItem(ref sig, ref body) => {\n+                        method(ii.id, ii.ident, sig, body, ii.span)\n+                    }\n+                    ast::TypeImplItem(_) |\n+                    ast::MacImplItem(_) => {\n                         panic!(\"impl method FnLikeNode that is not fn-like\")\n                     }\n                 }"}, {"sha": "48bb044cb1854cafba113fd3a9b56ff1c3aa3ec9", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -929,30 +929,28 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n         Some(NodeImplItem(ii)) => {\n             match ii.node {\n-                MethodImplItem(ref m) => {\n-                    match *m {\n-                        MethDecl(..) =>\n-                            format!(\"method {} in {}{}\",\n-                                    token::get_ident(ii.ident),\n-                                    map.path_to_string(id), id_str),\n-                        MethMac(ref mac) =>\n-                            format!(\"method macro {}{}\",\n-                                    pprust::mac_to_string(mac), id_str)\n-                    }\n+                MethodImplItem(..) => {\n+                    format!(\"method {} in {}{}\",\n+                            token::get_ident(ii.ident),\n+                            map.path_to_string(id), id_str)\n                 }\n                 TypeImplItem(_) => {\n                     format!(\"assoc type {} in {}{}\",\n                             token::get_ident(ii.ident),\n                             map.path_to_string(id),\n                             id_str)\n                 }\n+                MacImplItem(ref mac) => {\n+                    format!(\"method macro {}{}\",\n+                            pprust::mac_to_string(mac), id_str)\n+                }\n             }\n         }\n         Some(NodeTraitItem(ti)) => {\n             let kind = match ti.node {\n-                RequiredMethod(_) => \"required method\",\n-                ProvidedMethod(_) => \"provided method\",\n+                MethodTraitItem(..) => \"trait method\",\n                 TypeTraitItem(..) => \"assoc type\",\n+//                 ConstTraitItem(..) => \"assoc constant\"\n             };\n \n             format!(\"{} {} in {}{}\","}, {"sha": "cec824e79ff5a5afc3d55f7a3ccb9674f6e99394", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -459,8 +459,8 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n             visit::FkItemFn(_, generics, _, _) => {\n                 self.visit_generics_helper(generics)\n             }\n-            visit::FkMethod(_, m) => {\n-                self.visit_generics_helper(&m.pe_sig().generics)\n+            visit::FkMethod(_, sig) => {\n+                self.visit_generics_helper(&sig.generics)\n             }\n             visit::FkFnBlock => {}\n         }\n@@ -647,34 +647,6 @@ pub fn lit_is_str(lit: &Lit) -> bool {\n     }\n }\n \n-/// Macro invocations are guaranteed not to occur after expansion is complete.\n-/// Extracting fields of a method requires a dynamic check to make sure that it's\n-/// not a macro invocation. This check is guaranteed to succeed, assuming\n-/// that the invocations are indeed gone.\n-pub trait PostExpansionMethod {\n-    fn pe_sig<'a>(&'a self) -> &'a ast::MethodSig;\n-    fn pe_body<'a>(&'a self) -> &'a ast::Block;\n-}\n-\n-macro_rules! mf_method{\n-    ($meth_name:ident, $field_ty:ty, $field_pat:pat, $result:expr) => {\n-        fn $meth_name<'a>(&'a self) -> $field_ty {\n-            match *self {\n-                $field_pat => $result,\n-                MethMac(_) => {\n-                    panic!(\"expected an AST without macro invocations\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-\n-impl PostExpansionMethod for Method {\n-    mf_method! { pe_sig, &'a ast::MethodSig,MethDecl(ref sig, _), sig }\n-    mf_method! { pe_body, &'a ast::Block,MethDecl(_, ref body), body }\n-}\n-\n #[cfg(test)]\n mod test {\n     use ast::*;"}, {"sha": "35449bde0b2e086e870198f5874dc882838a8e23", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -228,8 +228,8 @@ pub trait MacResult {\n         None\n     }\n \n-    /// Create zero or more methods.\n-    fn make_methods(self: Box<Self>) -> Option<SmallVector<P<ast::ImplItem>>> {\n+    /// Create zero or more impl items.\n+    fn make_impl_items(self: Box<Self>) -> Option<SmallVector<P<ast::ImplItem>>> {\n         None\n     }\n \n@@ -275,7 +275,7 @@ make_MacEager! {\n     expr: P<ast::Expr>,\n     pat: P<ast::Pat>,\n     items: SmallVector<P<ast::Item>>,\n-    methods: SmallVector<P<ast::ImplItem>>,\n+    impl_items: SmallVector<P<ast::ImplItem>>,\n     stmt: P<ast::Stmt>,\n }\n \n@@ -288,8 +288,8 @@ impl MacResult for MacEager {\n         self.items\n     }\n \n-    fn make_methods(self: Box<Self>) -> Option<SmallVector<P<ast::ImplItem>>> {\n-        self.methods\n+    fn make_impl_items(self: Box<Self>) -> Option<SmallVector<P<ast::ImplItem>>> {\n+        self.impl_items\n     }\n \n     fn make_stmt(self: Box<Self>) -> Option<P<ast::Stmt>> {\n@@ -377,7 +377,7 @@ impl MacResult for DummyResult {\n             Some(SmallVector::zero())\n         }\n     }\n-    fn make_methods(self: Box<DummyResult>) -> Option<SmallVector<P<ast::ImplItem>>> {\n+    fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVector<P<ast::ImplItem>>> {\n         if self.expr_only {\n             None\n         } else {"}, {"sha": "58b6d96607df777454cb9b841e60fddc4c77848e", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -724,13 +724,13 @@ impl<'a> MethodDef<'a> {\n             span: trait_.span,\n             vis: ast::Inherited,\n             ident: method_ident,\n-            node: ast::MethodImplItem(ast::MethDecl(ast::MethodSig {\n+            node: ast::MethodImplItem(ast::MethodSig {\n                 generics: fn_generics,\n                 abi: abi,\n                 explicit_self: explicit_self,\n                 unsafety: ast::Unsafety::Normal,\n                 decl: fn_decl\n-            }, body_block))\n+            }, body_block)\n         })\n     }\n "}, {"sha": "830248b5682f3d7209dc4d49dbaf13511e7b44a5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 61, "deletions": 69, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -25,7 +25,6 @@ use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use owned_slice::OwnedSlice;\n use parse;\n use parse::token::{fresh_mark, fresh_name, intern};\n use parse::token;\n@@ -1175,42 +1174,26 @@ fn expand_annotatable(a: Annotatable,\n                 noop_fold_item(it, fld).into_iter().map(|i| Annotatable::Item(i)).collect()\n             }\n         },\n+\n         Annotatable::TraitItem(it) => match it.node {\n-            ast::ProvidedMethod(ast::MethMac(_)) => {\n-                // HACK(eddyb): Expand method macros in a trait as if they were in an impl.\n-                let ii = it.and_then(|ti| match ti.node {\n-                    ast::ProvidedMethod(m) => P(ast::ImplItem {\n-                        id: ti.id,\n-                        ident: ti.ident,\n-                        attrs: ti.attrs,\n-                        vis: ast::Inherited,\n-                        node: ast::MethodImplItem(m),\n-                        span: ti.span\n-                    }),\n+            ast::MethodTraitItem(_, Some(_)) => SmallVector::one(it.map(|ti| ast::TraitItem {\n+                id: ti.id,\n+                ident: ti.ident,\n+                attrs: ti.attrs,\n+                node: match ti.node  {\n+                    ast::MethodTraitItem(sig, Some(body)) => {\n+                        let (sig, body) = expand_and_rename_method(sig, body, fld);\n+                        ast::MethodTraitItem(sig, Some(body))\n+                    }\n                     _ => unreachable!()\n-                });\n-                expand_method(ii, fld).into_iter().map(|ii| {\n-                    Annotatable::TraitItem(ii.and_then(|ii| P(ast::TraitItem {\n-                        id: ii.id,\n-                        ident: ii.ident,\n-                        attrs: ii.attrs,\n-                        node: match ii.node {\n-                            ast::MethodImplItem(m) => ast::ProvidedMethod(m),\n-                            ast::TypeImplItem(ty) => {\n-                                ast::TypeTraitItem(OwnedSlice::empty(), Some(ty))\n-                            }\n-                        },\n-                        span: ii.span\n-                    })))\n-                }).collect()\n-            }\n-            _ => {\n-                fold::noop_fold_trait_item(it, fld).into_iter()\n-                    .map(|ti| Annotatable::TraitItem(ti)).collect()\n-            }\n-        },\n+                },\n+                span: fld.new_span(ti.span)\n+            })),\n+            _ => fold::noop_fold_trait_item(it, fld)\n+        }.into_iter().map(Annotatable::TraitItem).collect(),\n+\n         Annotatable::ImplItem(ii) => {\n-            expand_method(ii, fld).into_iter().map(Annotatable::ImplItem).collect()\n+            expand_impl_item(ii, fld).into_iter().map(Annotatable::ImplItem).collect()\n         }\n     };\n \n@@ -1291,35 +1274,47 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     expand_item_multi_modifier(it, fld)\n }\n \n-// expand an impl item if it's a method macro\n-fn expand_method(ii: P<ast::ImplItem>, fld: &mut MacroExpander)\n+fn expand_impl_item(ii: P<ast::ImplItem>, fld: &mut MacroExpander)\n                  -> SmallVector<P<ast::ImplItem>> {\n-    let ii = fold::noop_fold_impl_item(ii, fld).expect_one(\"expected one impl item\");\n     match ii.node {\n-        ast::MethodImplItem(ast::MethMac(_)) => {\n+        ast::MethodImplItem(..) => SmallVector::one(ii.map(|ii| ast::ImplItem {\n+            id: ii.id,\n+            ident: ii.ident,\n+            attrs: ii.attrs,\n+            vis: ii.vis,\n+            node: match ii.node  {\n+                ast::MethodImplItem(sig, body) => {\n+                    let (sig, body) = expand_and_rename_method(sig, body, fld);\n+                    ast::MethodImplItem(sig, body)\n+                }\n+                _ => unreachable!()\n+            },\n+            span: fld.new_span(ii.span)\n+        })),\n+        ast::MacImplItem(_) => {\n             let (span, mac) = ii.and_then(|ii| match ii.node {\n-                ast::MethodImplItem(ast::MethMac(mac)) => (ii.span, mac),\n+                ast::MacImplItem(mac) => (ii.span, mac),\n                 _ => unreachable!()\n             });\n-            let maybe_new_methods =\n+            let maybe_new_items =\n                 expand_mac_invoc(mac, span,\n-                                 |r| r.make_methods(),\n-                                 |meths, mark| meths.move_map(|m| mark_method(m, mark)),\n+                                 |r| r.make_impl_items(),\n+                                 |meths, mark| meths.move_map(|m| mark_impl_item(m, mark)),\n                                  fld);\n \n-            match maybe_new_methods {\n-                Some(methods) => {\n+            match maybe_new_items {\n+                Some(impl_items) => {\n                     // expand again if necessary\n-                    let new_methods = methods.into_iter()\n-                                             .flat_map(|m| expand_method(m, fld).into_iter())\n-                                             .collect();\n+                    let new_items = impl_items.into_iter().flat_map(|ii| {\n+                        expand_impl_item(ii, fld).into_iter()\n+                    }).collect();\n                     fld.cx.bt_pop();\n-                    new_methods\n+                    new_items\n                 }\n                 None => SmallVector::zero()\n             }\n         }\n-        _ => SmallVector::one(ii)\n+        _ => fold::noop_fold_impl_item(ii, fld)\n     }\n }\n \n@@ -1328,7 +1323,7 @@ fn expand_method(ii: P<ast::ImplItem>, fld: &mut MacroExpander)\n /// the block, returning both the new FnDecl and the new Block.\n fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Block>,\n                                        fld: &mut MacroExpander)\n-    -> (P<ast::FnDecl>, P<ast::Block>) {\n+                                       -> (P<ast::FnDecl>, P<ast::Block>) {\n     let expanded_decl = fld.fold_fn_decl(fn_decl);\n     let idents = fn_decl_arg_bindings(&*expanded_decl);\n     let renames =\n@@ -1342,6 +1337,20 @@ fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Bl\n     (rewritten_fn_decl,rewritten_body)\n }\n \n+fn expand_and_rename_method(sig: ast::MethodSig, body: P<ast::Block>,\n+                            fld: &mut MacroExpander)\n+                            -> (ast::MethodSig, P<ast::Block>) {\n+    let (rewritten_fn_decl, rewritten_body)\n+        = expand_and_rename_fn_decl_and_block(sig.decl, body, fld);\n+    (ast::MethodSig {\n+        generics: fld.fold_generics(sig.generics),\n+        abi: sig.abi,\n+        explicit_self: fld.fold_explicit_self(sig.explicit_self),\n+        unsafety: sig.unsafety,\n+        decl: rewritten_fn_decl\n+    }, rewritten_body)\n+}\n+\n /// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n@@ -1391,23 +1400,6 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_arm(arm, self)\n     }\n \n-    fn fold_method(&mut self, m: ast::Method) -> ast::Method {\n-        match m {\n-            ast::MethDecl(sig, body) => {\n-                let (rewritten_fn_decl, rewritten_body)\n-                    = expand_and_rename_fn_decl_and_block(sig.decl, body, self);\n-                ast::MethDecl(ast::MethodSig {\n-                    generics: self.fold_generics(sig.generics),\n-                    abi: sig.abi,\n-                    explicit_self: self.fold_explicit_self(sig.explicit_self),\n-                    unsafety: sig.unsafety,\n-                    decl: rewritten_fn_decl\n-                }, rewritten_body)\n-            }\n-            ast::MethMac(mac) => ast::MethMac(mac)\n-        }\n-    }\n-\n     fn fold_trait_item(&mut self, i: P<ast::TraitItem>) -> SmallVector<P<ast::TraitItem>> {\n         expand_annotatable(Annotatable::TraitItem(i), self)\n             .into_iter().map(|i| i.expect_trait_item()).collect()\n@@ -1561,9 +1553,9 @@ fn mark_item(expr: P<ast::Item>, m: Mrk) -> P<ast::Item> {\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_method(ii: P<ast::ImplItem>, m: Mrk) -> P<ast::ImplItem> {\n+fn mark_impl_item(ii: P<ast::ImplItem>, m: Mrk) -> P<ast::ImplItem> {\n     Marker{mark:m}.fold_impl_item(ii)\n-        .expect_one(\"marking an impl item didn't return exactly one method\")\n+        .expect_one(\"marking an impl item didn't return exactly one impl item\")\n }\n \n /// Check that there are no macro invocations left in the AST:"}, {"sha": "7575d4b5ecdbe68d40fac8bc3920d8513dcf1faa", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -71,7 +71,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         loop {\n             let mut parser = self.parser.borrow_mut();\n             // so... do outer attributes attached to the macro invocation\n-            // just disappear? This question applies to make_methods, as\n+            // just disappear? This question applies to make_impl_items, as\n             // well.\n             match parser.parse_item_with_outer_attributes() {\n                 Some(item) => ret.push(item),\n@@ -82,16 +82,14 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         Some(ret)\n     }\n \n-    fn make_methods(self: Box<ParserAnyMacro<'a>>)\n-                    -> Option<SmallVector<P<ast::ImplItem>>> {\n+    fn make_impl_items(self: Box<ParserAnyMacro<'a>>)\n+                       -> Option<SmallVector<P<ast::ImplItem>>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n             match parser.token {\n                 token::Eof => break,\n-                _ => {\n-                    ret.push(parser.parse_method_with_outer_attributes());\n-                }\n+                _ => ret.push(parser.parse_impl_item_with_outer_attributes())\n             }\n         }\n         self.ensure_complete_parse(false);"}, {"sha": "105a61d085725e8c004f1f8200d3c5d50b877167", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -110,10 +110,6 @@ pub trait Folder : Sized {\n         noop_fold_fn_decl(d, self)\n     }\n \n-    fn fold_method(&mut self, m: Method) -> Method {\n-        noop_fold_method(m, self)\n-    }\n-\n     fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n         noop_fold_block(b, self)\n     }\n@@ -977,8 +973,10 @@ pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n         ident: folder.fold_ident(ident),\n         attrs: fold_attrs(attrs, folder),\n         node: match node {\n-            RequiredMethod(sig) => RequiredMethod(noop_fold_method_sig(sig, folder)),\n-            ProvidedMethod(m) => ProvidedMethod(folder.fold_method(m)),\n+            MethodTraitItem(sig, body) => {\n+                MethodTraitItem(noop_fold_method_sig(sig, folder),\n+                                body.map(|x| folder.fold_block(x)))\n+            }\n             TypeTraitItem(bounds, default) => {\n                 TypeTraitItem(folder.fold_bounds(bounds),\n                               default.map(|x| folder.fold_ty(x)))\n@@ -996,8 +994,12 @@ pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n         attrs: fold_attrs(attrs, folder),\n         vis: vis,\n         node: match node  {\n-            MethodImplItem(m) => MethodImplItem(folder.fold_method(m)),\n-            TypeImplItem(ty) => TypeImplItem(folder.fold_ty(ty))\n+            MethodImplItem(sig, body) => {\n+                MethodImplItem(noop_fold_method_sig(sig, folder),\n+                               folder.fold_block(body))\n+            }\n+            TypeImplItem(ty) => TypeImplItem(folder.fold_ty(ty)),\n+            MacImplItem(mac) => MacImplItem(folder.fold_mac(mac))\n         },\n         span: folder.new_span(span)\n     }))\n@@ -1099,17 +1101,6 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n     })\n }\n \n-// Default fold over a method.\n-pub fn noop_fold_method<T: Folder>(method: Method, folder: &mut T) -> Method {\n-    match method {\n-        MethDecl(sig, body) => {\n-            MethDecl(noop_fold_method_sig(sig, folder),\n-                     folder.fold_block(body))\n-        },\n-        MethMac(mac) => MethMac(folder.fold_mac(mac))\n-    }\n-}\n-\n pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n     MethodSig {\n         generics: folder.fold_generics(sig.generics),"}, {"sha": "9f851e5de194827098e92ac63e36465f912c793e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -13,7 +13,7 @@ pub use self::PathParsingMode::*;\n use abi;\n use ast::{BareFnTy};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n-use ast::{ProvidedMethod, Public, Unsafety};\n+use ast::{Public, Unsafety};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, BiLt, BiGt, Block};\n use ast::{BlockCheckMode, CaptureByRef, CaptureByValue, CaptureClause};\n@@ -42,8 +42,7 @@ use ast::{MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, NodeId, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n-use ast::{PolyTraitRef};\n-use ast::{QSelf, RequiredMethod};\n+use ast::{PolyTraitRef, QSelf};\n use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub, StrStyle};\n@@ -1349,18 +1348,18 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let hi = p.last_span.hi;\n-                let node = match p.token {\n+                let body = match p.token {\n                   token::Semi => {\n                     p.bump();\n                     debug!(\"parse_trait_methods(): parsing required method\");\n-                    RequiredMethod(sig)\n+                    None\n                   }\n                   token::OpenDelim(token::Brace) => {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n                     attrs.push_all(&inner_attrs[..]);\n-                    ProvidedMethod(ast::MethDecl(sig, body))\n+                    Some(body)\n                   }\n \n                   _ => {\n@@ -1374,7 +1373,7 @@ impl<'a> Parser<'a> {\n                     id: ast::DUMMY_NODE_ID,\n                     ident: ident,\n                     attrs: attrs,\n-                    node: node,\n+                    node: ast::MethodTraitItem(sig, body),\n                     span: mk_sp(lo, hi),\n                 })\n             }\n@@ -4682,11 +4681,15 @@ impl<'a> Parser<'a> {\n         (ident, ItemFn(decl, unsafety, abi, generics, body), Some(inner_attrs))\n     }\n \n-    /// Parse a method in a trait impl\n-    pub fn parse_method_with_outer_attributes(&mut self) -> P<ImplItem> {\n+    /// Parse an impl item.\n+    pub fn parse_impl_item_with_outer_attributes(&mut self) -> P<ImplItem> {\n         let attrs = self.parse_outer_attributes();\n-        let visa = self.parse_visibility();\n-        self.parse_method(attrs, visa)\n+        let vis = self.parse_visibility();\n+        if self.eat_keyword(keywords::Type) {\n+            self.parse_assoc_ty_in_impl(attrs, vis)\n+        } else {\n+            self.parse_method(attrs, vis)\n+        }\n     }\n \n     fn complain_if_pub_macro(&mut self, visa: Visibility, span: Span) {\n@@ -4733,7 +4736,7 @@ impl<'a> Parser<'a> {\n                 if delim != token::Brace {\n                     self.expect(&token::Semi)\n                 }\n-                (ast::MethMac(m), self.span.hi, attrs,\n+                (ast::MacImplItem(m), self.span.hi, attrs,\n                  token::special_idents::invalid)\n             } else {\n                 let unsafety = self.parse_unsafety();\n@@ -4753,7 +4756,7 @@ impl<'a> Parser<'a> {\n                 let body_span = body.span;\n                 let mut new_attrs = attrs;\n                 new_attrs.push_all(&inner_attrs[..]);\n-                (ast::MethDecl(ast::MethodSig {\n+                (MethodImplItem(ast::MethodSig {\n                     generics: generics,\n                     abi: abi,\n                     explicit_self: explicit_self,\n@@ -4767,7 +4770,7 @@ impl<'a> Parser<'a> {\n             attrs: new_attrs,\n             vis: vis,\n             ident: ident,\n-            node: MethodImplItem(method_),\n+            node: method_,\n             span: mk_sp(lo, hi),\n         })\n     }"}, {"sha": "07303ba51ff7075bfaf6c732fd5b82689f53bc63", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -1251,12 +1251,17 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ti.span.lo));\n         try!(self.print_outer_attributes(&ti.attrs));\n         match ti.node {\n-            ast::RequiredMethod(ref sig) => {\n+            ast::MethodTraitItem(ref sig, ref body) => {\n+                if body.is_some() {\n+                    try!(self.head(\"\"));\n+                }\n                 try!(self.print_method_sig(ti.ident, sig, ast::Inherited));\n-                word(&mut self.s, \";\")\n-            }\n-            ast::ProvidedMethod(ref m) => {\n-                self.print_method(ti.ident, &ti.attrs, ast::Inherited, m)\n+                if let Some(ref body) = *body {\n+                    try!(self.nbsp());\n+                    self.print_block_with_attrs(body, &ti.attrs)\n+                } else {\n+                    word(&mut self.s, \";\")\n+                }\n             }\n             ast::TypeTraitItem(ref bounds, ref default) => {\n                 self.print_associated_type(ti.ident, Some(bounds),\n@@ -1270,30 +1275,17 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ii.span.lo));\n         try!(self.print_outer_attributes(&ii.attrs));\n         match ii.node {\n-            ast::MethodImplItem(ref m) => {\n-                self.print_method(ii.ident, &ii.attrs, ii.vis, m)\n+            ast::MethodImplItem(ref sig, ref body) => {\n+                try!(self.head(\"\"));\n+                try!(self.print_method_sig(ii.ident, sig, ii.vis));\n+                try!(self.nbsp());\n+                self.print_block_with_attrs(body, &ii.attrs)\n             }\n             ast::TypeImplItem(ref ty) => {\n                 self.print_associated_type(ii.ident, None, Some(ty))\n             }\n-        }\n-    }\n-\n-    pub fn print_method(&mut self,\n-                        ident: ast::Ident,\n-                        attrs: &[ast::Attribute],\n-                        vis: ast::Visibility,\n-                        meth: &ast::Method)\n-                        -> io::Result<()> {\n-        match *meth {\n-            ast::MethDecl(ref sig, ref body) => {\n-                try!(self.head(\"\"));\n-                try!(self.print_method_sig(ident, sig, vis));\n-                try!(self.nbsp());\n-                self.print_block_with_attrs(&**body, attrs)\n-            },\n-            ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n-                                            ..}) => {\n+            ast::MacImplItem(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n+                                                ..}) => {\n                 // code copied from ItemMac:\n                 try!(self.print_path(pth, false, 0));\n                 try!(word(&mut self.s, \"! \"));"}, {"sha": "638ddd3ea2e5b5523d7160c9e29dc60f4dd46ce6", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 14, "deletions": 44, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -38,7 +38,7 @@ pub enum FnKind<'a> {\n     FkItemFn(Ident, &'a Generics, Unsafety, Abi),\n \n     /// fn foo(&self)\n-    FkMethod(Ident, &'a Method),\n+    FkMethod(Ident, &'a MethodSig),\n \n     /// |x, y| ...\n     /// proc(x, y) ...\n@@ -592,28 +592,6 @@ pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n \n-// Note: there is no visit_method() method in the visitor, instead override\n-// visit_fn() and check for FkMethod().  I named this visit_method_helper()\n-// because it is not a default impl of any method, though I doubt that really\n-// clarifies anything. - Niko\n-fn walk_method_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                          id: NodeId,\n-                                          ident: Ident,\n-                                          span: Span,\n-                                          method: &'v Method) {\n-    match *method {\n-        MethDecl(ref sig, ref body) => {\n-            visitor.visit_ident(span, ident);\n-            visitor.visit_fn(FkMethod(ident, method),\n-                             &sig.decl,\n-                             body,\n-                             span,\n-                             id);\n-        },\n-        MethMac(ref mac) => visitor.visit_mac(mac)\n-    }\n-}\n-\n pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_kind: FnKind<'v>,\n                                    function_declaration: &'v FnDecl,\n@@ -625,14 +603,9 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n         FkItemFn(_, generics, _, _) => {\n             visitor.visit_generics(generics);\n         }\n-        FkMethod(_, method) => {\n-            match *method {\n-                MethDecl(ref sig, _) => {\n-                    visitor.visit_generics(&sig.generics);\n-                    visitor.visit_explicit_self(&sig.explicit_self);\n-                }\n-                MethMac(ref mac) => visitor.visit_mac(mac)\n-            }\n+        FkMethod(_, sig) => {\n+            visitor.visit_generics(&sig.generics);\n+            visitor.visit_explicit_self(&sig.explicit_self);\n         }\n         FkFnBlock(..) => {}\n     }\n@@ -646,17 +619,14 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n         visitor.visit_attribute(attr);\n     }\n     match trait_item.node {\n-        RequiredMethod(ref sig) => {\n+        MethodTraitItem(ref sig, None) => {\n             visitor.visit_explicit_self(&sig.explicit_self);\n             visitor.visit_generics(&sig.generics);\n             walk_fn_decl(visitor, &sig.decl);\n         }\n-        ProvidedMethod(ref method) => {\n-            walk_method_helper(visitor,\n-                               trait_item.id,\n-                               trait_item.ident,\n-                               trait_item.span,\n-                               method);\n+        MethodTraitItem(ref sig, Some(ref body)) => {\n+            visitor.visit_fn(FkMethod(trait_item.ident, sig), &sig.decl,\n+                             body, trait_item.span, trait_item.id);\n         }\n         TypeTraitItem(ref bounds, ref default) => {\n             walk_ty_param_bounds_helper(visitor, bounds);\n@@ -671,16 +641,16 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         visitor.visit_attribute(attr);\n     }\n     match impl_item.node {\n-        MethodImplItem(ref method) => {\n-            walk_method_helper(visitor,\n-                               impl_item.id,\n-                               impl_item.ident,\n-                               impl_item.span,\n-                               method);\n+        MethodImplItem(ref sig, ref body) => {\n+            visitor.visit_fn(FkMethod(impl_item.ident, sig), &sig.decl,\n+                             body, impl_item.span, impl_item.id);\n         }\n         TypeImplItem(ref ty) => {\n             visitor.visit_ty(ty);\n         }\n+        MacImplItem(ref mac) => {\n+            visitor.visit_mac(mac);\n+        }\n     }\n }\n "}, {"sha": "36a34bc6c8b41a3e6189597d3de89e1681e29918", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -16,7 +16,7 @@\n extern crate syntax;\n extern crate rustc;\n \n-use syntax::ast::{TokenTree, Item, MetaItem, ImplItem, TraitItem, Method};\n+use syntax::ast::{self, TokenTree, Item, MetaItem};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::parse::token;\n@@ -81,7 +81,26 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n                 ..(*quote_item!(cx, enum Foo2 { Bar2, Baz2 }).unwrap()).clone()\n             }))\n         }\n-        it => it\n+        Annotatable::ImplItem(it) => {\n+            quote_item!(cx, impl X { fn foo(&self) -> i32 { 42 } }).unwrap().and_then(|i| {\n+                match i.node {\n+                    ast::ItemImpl(_, _, _, _, _, mut items) => {\n+                        Annotatable::ImplItem(items.pop().expect(\"impl method not found\"))\n+                    }\n+                    _ => unreachable!(\"impl parsed to something other than impl\")\n+                }\n+            })\n+        }\n+        Annotatable::TraitItem(it) => {\n+            quote_item!(cx, trait X { fn foo(&self) -> i32 { 0 } }).unwrap().and_then(|i| {\n+                match i.node {\n+                    ast::ItemTrait(_, _, _, mut items) => {\n+                        Annotatable::TraitItem(items.pop().expect(\"trait method not found\"))\n+                    }\n+                    _ => unreachable!(\"trait parsed to something other than trait\")\n+                }\n+            })\n+        }\n     }\n }\n "}, {"sha": "04db6c8c8f39c97798136e1af46f2f2136b79143", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da918548d77182ca64f375fb6da24036d5ad60c/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=9da918548d77182ca64f375fb6da24036d5ad60c", "patch": "@@ -60,7 +60,7 @@ trait B {\n \n pub trait C { //~ ERROR: missing documentation for a trait\n     fn foo(&self); //~ ERROR: missing documentation for a trait method\n-    fn foo_with_impl(&self) {} //~ ERROR: missing documentation for a default method\n+    fn foo_with_impl(&self) {} //~ ERROR: missing documentation for a trait method\n }\n \n #[allow(missing_docs)]"}]}