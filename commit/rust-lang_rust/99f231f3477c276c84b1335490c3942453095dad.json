{"sha": "99f231f3477c276c84b1335490c3942453095dad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZjIzMWYzNDc3YzI3NmM4NGIxMzM1NDkwYzM5NDI0NTMwOTVkYWQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-01T02:13:29Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-01T02:13:29Z"}, "message": "core: Change a number of arguments in vec to const vecs", "tree": {"sha": "d3fac547f044a9df17db8d0fa310e5946f24376f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3fac547f044a9df17db8d0fa310e5946f24376f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99f231f3477c276c84b1335490c3942453095dad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99f231f3477c276c84b1335490c3942453095dad", "html_url": "https://github.com/rust-lang/rust/commit/99f231f3477c276c84b1335490c3942453095dad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99f231f3477c276c84b1335490c3942453095dad/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4132cbd22a139f0dace8cb914b63faf816b77ea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4132cbd22a139f0dace8cb914b63faf816b77ea3", "html_url": "https://github.com/rust-lang/rust/commit/4132cbd22a139f0dace8cb914b63faf816b77ea3"}], "stats": {"total": 63, "additions": 32, "deletions": 31}, "files": [{"sha": "4b0c83d71685906a36d7141d402a1abd347c9f73", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/99f231f3477c276c84b1335490c3942453095dad/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f231f3477c276c84b1335490c3942453095dad/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=99f231f3477c276c84b1335490c3942453095dad", "patch": "@@ -52,7 +52,7 @@ Predicate: same_length\n \n Returns true if two vectors have the same length\n */\n-pure fn same_length<T, U>(xs: [T], ys: [U]) -> bool {\n+pure fn same_length<T, U>(xs: [const T], ys: [const U]) -> bool {\n     vec::len(xs) == vec::len(ys)\n }\n \n@@ -278,7 +278,7 @@ Function: split\n \n Split the vector `v` by applying each element against the predicate `f`.\n */\n-fn split<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n+fn split<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -303,7 +303,7 @@ Function: splitn\n Split the vector `v` by applying each element against the predicate `f` up\n to `n` times.\n */\n-fn splitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n+fn splitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -331,7 +331,7 @@ Function: rsplit\n Reverse split the vector `v` by applying each element against the predicate\n `f`.\n */\n-fn rsplit<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n+fn rsplit<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -356,7 +356,7 @@ Function: rsplitn\n Reverse split the vector `v` by applying each element against the predicate\n `f` up to `n times.\n */\n-fn rsplitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n+fn rsplitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -412,7 +412,7 @@ Function: push\n \n Append an element to a vector\n */\n-fn push<T: copy>(&v: [T], initval: T) {\n+fn push<T: copy>(&v: [const T], initval: T) {\n     v += [initval];\n }\n \n@@ -432,7 +432,7 @@ v - The vector to grow\n n - The number of elements to add\n initval - The value for the new elements\n */\n-fn grow<T: copy>(&v: [T], n: uint, initval: T) {\n+fn grow<T: copy>(&v: [const T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [initval]; i += 1u; }\n@@ -471,7 +471,7 @@ v - The vector to grow\n n - The number of elements to add\n init_op - A function to call to retreive each appended element's value\n */\n-fn grow_fn<T>(&v: [T], n: uint, op: init_op<T>) {\n+fn grow_fn<T>(&v: [const T], n: uint, op: init_op<T>) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [op(i)]; i += 1u; }\n@@ -527,7 +527,8 @@ Function: map2\n \n Apply a function to each pair of elements and return the results\n */\n-fn map2<T: copy, U: copy, V>(v0: [T], v1: [U], f: fn(T, U) -> V) -> [V] {\n+fn map2<T: copy, U: copy, V>(v0: [const T], v1: [const U],\n+                             f: fn(T, U) -> V) -> [V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail; }\n     let u: [V] = [];\n@@ -645,7 +646,7 @@ Return true if a predicate matches any elements in both vectors.\n \n If the vectors contains no elements then false is returned.\n */\n-fn any2<T, U>(v0: [T], v1: [U], f: fn(T, U) -> bool) -> bool {\n+fn any2<T, U>(v0: [const T], v1: [U], f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n     let i = 0u;\n@@ -675,7 +676,7 @@ Return true if a predicate matches all elements in both vectors.\n \n If the vectors are not the same size then false is returned.\n */\n-fn all2<T, U>(v0: [T], v1: [U], f: fn(T, U) -> bool) -> bool {\n+fn all2<T, U>(v0: [const T], v1: [const U], f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { ret false; }\n     let i = 0u;\n@@ -688,7 +689,7 @@ Function: contains\n \n Return true if a vector contains an element with the given value\n */\n-fn contains<T>(v: [T], x: T) -> bool {\n+fn contains<T>(v: [const T], x: T) -> bool {\n     for elt: T in v { if x == elt { ret true; } }\n     ret false;\n }\n@@ -713,7 +714,7 @@ Apply function `f` to each element of `v`, starting from the first.\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n */\n-fn find<T: copy>(v: [T], f: fn(T) -> bool) -> option<T> {\n+fn find<T: copy>(v: [const T], f: fn(T) -> bool) -> option<T> {\n     find_from(v, 0u, len(v), f)\n }\n \n@@ -726,8 +727,8 @@ Apply function `f` to each element of `v` within the range [`start`, `end`).\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n */\n-fn find_from<T: copy>(v: [T], start: uint, end: uint, f: fn(T) -> bool) ->\n-  option<T> {\n+fn find_from<T: copy>(v: [const T], start: uint, end: uint,\n+                      f: fn(T) -> bool) -> option<T> {\n     option::map(position_from(v, start, end, f)) { |i| v[i] }\n }\n \n@@ -740,7 +741,7 @@ Apply function `f` to each element of `v` in reverse order. When function `f`\n returns true then an option containing the element is returned. If `f`\n matches no elements then none is returned.\n */\n-fn rfind<T: copy>(v: [T], f: fn(T) -> bool) -> option<T> {\n+fn rfind<T: copy>(v: [const T], f: fn(T) -> bool) -> option<T> {\n     rfind_from(v, 0u, len(v), f)\n }\n \n@@ -753,8 +754,8 @@ Apply function `f` to each element of `v` in reverse order within the range\n [`start`, `end`). When function `f` returns true then an option containing\n the element is returned. If `f` matches no elements then none is returned.\n */\n-fn rfind_from<T: copy>(v: [T], start: uint, end: uint, f: fn(T) -> bool) ->\n-  option<T> {\n+fn rfind_from<T: copy>(v: [const T], start: uint, end: uint,\n+                       f: fn(T) -> bool) -> option<T> {\n     option::map(rposition_from(v, start, end, f)) { |i| v[i] }\n }\n \n@@ -768,7 +769,7 @@ Returns:\n option::some(uint) - The first index containing a matching value\n option::none - No elements matched\n */\n-fn position_elt<T>(v: [T], x: T) -> option<uint> {\n+fn position_elt<T>(v: [const T], x: T) -> option<uint> {\n     position(v) { |y| x == y }\n }\n \n@@ -781,7 +782,7 @@ Apply function `f` to each element of `v`.  When function `f` returns true\n then an option containing the index is returned. If `f` matches no elements\n then none is returned.\n */\n-fn position<T>(v: [T], f: fn(T) -> bool) -> option<uint> {\n+fn position<T>(v: [const T], f: fn(T) -> bool) -> option<uint> {\n     position_from(v, 0u, len(v), f)\n }\n \n@@ -794,8 +795,8 @@ Apply function `f` to each element of `v` between the range [`start`, `end`).\n When function `f` returns true then an option containing the index is\n returned. If `f` matches no elements then none is returned.\n */\n-fn position_from<T>(v: [T], start: uint, end: uint, f: fn(T) -> bool) ->\n-  option<uint> {\n+fn position_from<T>(v: [const T], start: uint, end: uint,\n+                    f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n     let i = start;\n@@ -813,7 +814,7 @@ Returns:\n option::some(uint) - The last index containing a matching value\n option::none - No elements matched\n */\n-fn rposition_elt<T>(v: [T], x: T) -> option<uint> {\n+fn rposition_elt<T>(v: [const T], x: T) -> option<uint> {\n     rposition(v) { |y| x == y }\n }\n \n@@ -826,7 +827,7 @@ Apply function `f` to each element of `v` in reverse order.  When function\n `f` returns true then an option containing the index is returned. If `f`\n matches no elements then none is returned.\n */\n-fn rposition<T>(v: [T], f: fn(T) -> bool) -> option<uint> {\n+fn rposition<T>(v: [const T], f: fn(T) -> bool) -> option<uint> {\n     rposition_from(v, 0u, len(v), f)\n }\n \n@@ -839,8 +840,8 @@ Apply function `f` to each element of `v` in reverse order between the range\n [`start`, `end`). When function `f` returns true then an option containing\n the index is returned. If `f` matches no elements then none is returned.\n */\n-fn rposition_from<T>(v: [T], start: uint, end: uint, f: fn(T) -> bool) ->\n-  option<uint> {\n+fn rposition_from<T>(v: [const T], start: uint, end: uint,\n+                     f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n     let i = end;\n@@ -865,7 +866,7 @@ vector contains the first element of the i-th tuple of the input vector,\n and the i-th element of the second vector contains the second element\n of the i-th tuple of the input vector.\n */\n-fn unzip<T: copy, U: copy>(v: [(T, U)]) -> ([T], [U]) {\n+fn unzip<T: copy, U: copy>(v: [const (T, U)]) -> ([T], [U]) {\n     let as = [], bs = [];\n     for (a, b) in v { as += [a]; bs += [b]; }\n     ret (as, bs);\n@@ -883,7 +884,7 @@ Preconditions:\n \n <same_length> (v, u)\n */\n-fn zip<T: copy, U: copy>(v: [T], u: [U]) -> [(T, U)] {\n+fn zip<T: copy, U: copy>(v: [const T], u: [const U]) -> [(T, U)] {\n     let zipped = [];\n     let sz = len(v), i = 0u;\n     assert sz == len(u);\n@@ -979,7 +980,7 @@ Function: iter2\n Iterates over two vectors in parallel\n \n */\n-fn iter2<U, T>(v: [U], v2: [T], f: fn(U, T)) {\n+fn iter2<U, T>(v: [ U], v2: [const T], f: fn(U, T)) {\n     let i = 0;\n     for elt in v { f(elt, v2[i]); i += 1; }\n }\n@@ -1036,7 +1037,7 @@ is sorted then the permutations are lexicographically sorted).\n The total number of permutations produced is `len(v)!`.  If `v` contains\n repeated elements, then some permutations are repeated.\n */\n-fn permute<T: copy>(v: [const T], put: fn([T])) {\n+fn permute<T: copy>(v: [T], put: fn([T])) {\n   let ln = len(v);\n   if ln == 0u {\n     put([]);\n@@ -1051,7 +1052,7 @@ fn permute<T: copy>(v: [const T], put: fn([T])) {\n   }\n }\n \n-fn windowed <TT: copy> (nn: uint, xx: [TT]) -> [[TT]] {\n+fn windowed <TT: copy> (nn: uint, xx: [const TT]) -> [[TT]] {\n    let ww = [];\n \n    assert 1u <= nn;"}]}