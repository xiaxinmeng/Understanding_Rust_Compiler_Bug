{"sha": "e7a8977358c108164d3ba39aede67119baa5aaf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YTg5NzczNThjMTA4MTY0ZDNiYTM5YWVkZTY3MTE5YmFhNWFhZjk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-19T13:09:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-19T13:09:18Z"}, "message": "Merge #8524 #8527\n\n8524: Fix extract function with partial block selection r=matklad a=brandondong\n\n**Reproduction:**\r\n```rust\r\nfn foo() {\r\n    let n = 1;\r\n    let mut v = $0n * n;$0\r\n    v += 1;\r\n}\r\n```\r\n1. Select the snippet ($0) and use the \"Extract into function\" assist.\r\n2. Extracted function is incorrect and does not compile:\r\n```rust\r\nfn foo() {\r\n    let n = 1;\r\n    let mut v = fun_name(n);\r\n    v += 1;\r\n}\r\n\r\nfn fun_name(n: i32) {}\r\n```\r\n3. Omitting the ending semicolon from the selection fixes the extracted function:\r\n```rust\r\nfn fun_name(n: i32) -> i32 {\r\n    n * n\r\n}\r\n```\r\n\r\n**Cause:**\r\n- When `extraction_target` uses a block extraction (semicolon case) instead of an expression extraction (no semicolon case), the user selection is directly used as the TextRange.\r\n- However, the existing function extraction logic for blocks requires that the TextRange spans from start to end of complete statements to work correctly.\r\n- For example:\r\n```rust\r\nfn foo() {\r\n    let m = 2;\r\n    let n = 1;\r\n    let mut v = m $0* n;\r\n    let mut w = 3;$0\r\n    v += 1;\r\n    w += 1;\r\n}\r\n```\r\nproduces\r\n```rust\r\nfn foo() {\r\n    let m = 2;\r\n    let n = 1;\r\n    let mut v = m let mut w = fun_name(n);\r\n    v += 1;\r\n    w += 1;\r\n}\r\n\r\nfn fun_name(n: i32) -> i32 {\r\n    let mut w = 3;\r\n    w\r\n}\r\n```\r\n- The user selected TextRange is directly replaced by the function call which is now in the middle of another statement. The extracted function body only contains statements that were fully covered by the TextRange and so the `* n` code is deleted. The logic for calculating variable usage and outlived variables for the function parameters and return type respectively search within the TextRange and so do not include `m` or `v`.\r\n\r\n**Fix:**\r\n- Only extract full statements when using block extraction. If a user selected part of a statement, extract that full statement.\n\n8527: Switch introduce_named_lifetime assist to use mutable syntax tree  r=matklad a=iDawer\n\nThis extends `GenericParamsOwnerEdit` trait with `get_or_create_generic_param_list` method\n\nCo-authored-by: Brandon <brandondong604@hotmail.com>\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>", "tree": {"sha": "501759b44e67d7d0b15455089c7c92db9477b4b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/501759b44e67d7d0b15455089c7c92db9477b4b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7a8977358c108164d3ba39aede67119baa5aaf9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgfYD+CRBK7hj4Ov3rIwAAaMAIAJcJOxIAzIJBzHHFR9BWRWj3\nEMlQ1EOhAs+WbQrGk0MIGY8fCoeJR1Z1unM1aTK0s1H5IKPzqj4Wtal0ZnWSqyPS\nirBfsPp0HcJcu8jP9qTDMFUaC6n03i/HlyJuk7xVwm90xcPqwB6CJZBYbxjyWCUU\nXvkZF55eg+0xlZZ+KwObemDq7LykOqnH3aLrnBVSLMn5Q/ujdM/uQeaUtI/v8dEf\nhW5bU8kvxCCeZzoCToEd6rr+WCaNcb3qEgAcE0pvFkO+hzreVaZ/QDh+/6TFSDv4\nCPNbjn025WPquuKCqoC912mQMvtYZ8aJVUD30Qj/bNWC0hNV9xeLXZ44/dGAxTI=\n=+auO\n-----END PGP SIGNATURE-----\n", "payload": "tree 501759b44e67d7d0b15455089c7c92db9477b4b4\nparent e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990\nparent ffefbf2ba4365c6d00775c63bb9da9d30d082e10\nparent cedbf2e1c5ead457caf7fe99486da1cc2f2d04f0\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1618837758 +0000\ncommitter GitHub <noreply@github.com> 1618837758 +0000\n\nMerge #8524 #8527\n\n8524: Fix extract function with partial block selection r=matklad a=brandondong\n\n**Reproduction:**\r\n```rust\r\nfn foo() {\r\n    let n = 1;\r\n    let mut v = $0n * n;$0\r\n    v += 1;\r\n}\r\n```\r\n1. Select the snippet ($0) and use the \"Extract into function\" assist.\r\n2. Extracted function is incorrect and does not compile:\r\n```rust\r\nfn foo() {\r\n    let n = 1;\r\n    let mut v = fun_name(n);\r\n    v += 1;\r\n}\r\n\r\nfn fun_name(n: i32) {}\r\n```\r\n3. Omitting the ending semicolon from the selection fixes the extracted function:\r\n```rust\r\nfn fun_name(n: i32) -> i32 {\r\n    n * n\r\n}\r\n```\r\n\r\n**Cause:**\r\n- When `extraction_target` uses a block extraction (semicolon case) instead of an expression extraction (no semicolon case), the user selection is directly used as the TextRange.\r\n- However, the existing function extraction logic for blocks requires that the TextRange spans from start to end of complete statements to work correctly.\r\n- For example:\r\n```rust\r\nfn foo() {\r\n    let m = 2;\r\n    let n = 1;\r\n    let mut v = m $0* n;\r\n    let mut w = 3;$0\r\n    v += 1;\r\n    w += 1;\r\n}\r\n```\r\nproduces\r\n```rust\r\nfn foo() {\r\n    let m = 2;\r\n    let n = 1;\r\n    let mut v = m let mut w = fun_name(n);\r\n    v += 1;\r\n    w += 1;\r\n}\r\n\r\nfn fun_name(n: i32) -> i32 {\r\n    let mut w = 3;\r\n    w\r\n}\r\n```\r\n- The user selected TextRange is directly replaced by the function call which is now in the middle of another statement. The extracted function body only contains statements that were fully covered by the TextRange and so the `* n` code is deleted. The logic for calculating variable usage and outlived variables for the function parameters and return type respectively search within the TextRange and so do not include `m` or `v`.\r\n\r\n**Fix:**\r\n- Only extract full statements when using block extraction. If a user selected part of a statement, extract that full statement.\n\n8527: Switch introduce_named_lifetime assist to use mutable syntax tree  r=matklad a=iDawer\n\nThis extends `GenericParamsOwnerEdit` trait with `get_or_create_generic_param_list` method\n\nCo-authored-by: Brandon <brandondong604@hotmail.com>\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a8977358c108164d3ba39aede67119baa5aaf9", "html_url": "https://github.com/rust-lang/rust/commit/e7a8977358c108164d3ba39aede67119baa5aaf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7a8977358c108164d3ba39aede67119baa5aaf9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "html_url": "https://github.com/rust-lang/rust/commit/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990"}, {"sha": "ffefbf2ba4365c6d00775c63bb9da9d30d082e10", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffefbf2ba4365c6d00775c63bb9da9d30d082e10", "html_url": "https://github.com/rust-lang/rust/commit/ffefbf2ba4365c6d00775c63bb9da9d30d082e10"}, {"sha": "cedbf2e1c5ead457caf7fe99486da1cc2f2d04f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/cedbf2e1c5ead457caf7fe99486da1cc2f2d04f0", "html_url": "https://github.com/rust-lang/rust/commit/cedbf2e1c5ead457caf7fe99486da1cc2f2d04f0"}], "stats": {"total": 336, "additions": 298, "deletions": 38}, "files": [{"sha": "78a57fbdce18bece21dad9ef97bce9d17ebeeef8", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e7a8977358c108164d3ba39aede67119baa5aaf9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a8977358c108164d3ba39aede67119baa5aaf9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=e7a8977358c108164d3ba39aede67119baa5aaf9", "patch": "@@ -599,7 +599,12 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n     // we have selected a few statements in a block\n     // so covering_element returns the whole block\n     if node.kind() == BLOCK_EXPR {\n-        let body = FunctionBody::from_range(node.clone(), selection_range);\n+        // Extract the full statements.\n+        let statements_range = node\n+            .children()\n+            .filter(|c| selection_range.intersect(c.text_range()).is_some())\n+            .fold(selection_range, |acc, c| acc.cover(c.text_range()));\n+        let body = FunctionBody::from_range(node.clone(), statements_range);\n         if body.is_some() {\n             return body;\n         }\n@@ -610,7 +615,8 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n     // so we try to expand covering_element to parent and repeat the previous\n     if let Some(parent) = node.parent() {\n         if parent.kind() == BLOCK_EXPR {\n-            let body = FunctionBody::from_range(parent, selection_range);\n+            // Extract the full statement.\n+            let body = FunctionBody::from_range(parent, node.text_range());\n             if body.is_some() {\n                 return body;\n             }\n@@ -1784,6 +1790,60 @@ fn $0fun_name() -> i32 {\n         );\n     }\n \n+    #[test]\n+    fn extract_partial_block_single_line() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    let n = 1;\n+    let mut v = $0n * n;$0\n+    v += 1;\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let n = 1;\n+    let mut v = fun_name(n);\n+    v += 1;\n+}\n+\n+fn $0fun_name(n: i32) -> i32 {\n+    let mut v = n * n;\n+    v\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_partial_block() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    let m = 2;\n+    let n = 1;\n+    let mut v = m $0* n;\n+    let mut w = 3;$0\n+    v += 1;\n+    w += 1;\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let m = 2;\n+    let n = 1;\n+    let (mut v, mut w) = fun_name(m, n);\n+    v += 1;\n+    w += 1;\n+}\n+\n+fn $0fun_name(m: i32, n: i32) -> (i32, i32) {\n+    let mut v = m * n;\n+    let mut w = 3;\n+    (v, w)\n+}\"#,\n+        );\n+    }\n+\n     #[test]\n     fn argument_form_expr() {\n         check_assist("}, {"sha": "9f4f71d6cc5521e44060c42ad134567c1b18c15e", "filename": "crates/ide_assists/src/handlers/introduce_named_lifetime.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e7a8977358c108164d3ba39aede67119baa5aaf9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a8977358c108164d3ba39aede67119baa5aaf9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=e7a8977358c108164d3ba39aede67119baa5aaf9", "patch": "@@ -1,7 +1,8 @@\n use rustc_hash::FxHashSet;\n use syntax::{\n-    ast::{self, GenericParamsOwner, NameOwner},\n-    AstNode, TextRange, TextSize,\n+    ast::{self, edit_in_place::GenericParamsOwnerEdit, make, GenericParamsOwner},\n+    ted::{self, Position},\n+    AstNode, TextRange,\n };\n \n use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n@@ -37,10 +38,12 @@ static ASSIST_LABEL: &str = \"Introduce named lifetime\";\n pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let lifetime =\n         ctx.find_node_at_offset::<ast::Lifetime>().filter(|lifetime| lifetime.text() == \"'_\")?;\n+    let lifetime_loc = lifetime.lifetime_ident_token()?.text_range();\n+\n     if let Some(fn_def) = lifetime.syntax().ancestors().find_map(ast::Fn::cast) {\n-        generate_fn_def_assist(acc, &fn_def, lifetime.lifetime_ident_token()?.text_range())\n+        generate_fn_def_assist(acc, fn_def, lifetime_loc, lifetime)\n     } else if let Some(impl_def) = lifetime.syntax().ancestors().find_map(ast::Impl::cast) {\n-        generate_impl_def_assist(acc, &impl_def, lifetime.lifetime_ident_token()?.text_range())\n+        generate_impl_def_assist(acc, impl_def, lifetime_loc, lifetime)\n     } else {\n         None\n     }\n@@ -49,26 +52,26 @@ pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext) -\n /// Generate the assist for the fn def case\n fn generate_fn_def_assist(\n     acc: &mut Assists,\n-    fn_def: &ast::Fn,\n+    fn_def: ast::Fn,\n     lifetime_loc: TextRange,\n+    lifetime: ast::Lifetime,\n ) -> Option<()> {\n     let param_list: ast::ParamList = fn_def.param_list()?;\n-    let new_lifetime_param = generate_unique_lifetime_param_name(&fn_def.generic_param_list())?;\n-    let end_of_fn_ident = fn_def.name()?.ident_token()?.text_range().end();\n+    let new_lifetime_param = generate_unique_lifetime_param_name(fn_def.generic_param_list())?;\n     let self_param =\n         // use the self if it's a reference and has no explicit lifetime\n         param_list.self_param().filter(|p| p.lifetime().is_none() && p.amp_token().is_some());\n     // compute the location which implicitly has the same lifetime as the anonymous lifetime\n     let loc_needing_lifetime = if let Some(self_param) = self_param {\n         // if we have a self reference, use that\n-        Some(self_param.name()?.syntax().text_range().start())\n+        Some(NeedsLifetime::SelfParam(self_param))\n     } else {\n         // otherwise, if there's a single reference parameter without a named liftime, use that\n         let fn_params_without_lifetime: Vec<_> = param_list\n             .params()\n             .filter_map(|param| match param.ty() {\n                 Some(ast::Type::RefType(ascribed_type)) if ascribed_type.lifetime().is_none() => {\n-                    Some(ascribed_type.amp_token()?.text_range().end())\n+                    Some(NeedsLifetime::RefType(ascribed_type))\n                 }\n                 _ => None,\n             })\n@@ -81,30 +84,46 @@ fn generate_fn_def_assist(\n         }\n     };\n     acc.add(AssistId(ASSIST_NAME, AssistKind::Refactor), ASSIST_LABEL, lifetime_loc, |builder| {\n-        add_lifetime_param(fn_def, builder, end_of_fn_ident, new_lifetime_param);\n-        builder.replace(lifetime_loc, format!(\"'{}\", new_lifetime_param));\n-        loc_needing_lifetime.map(|loc| builder.insert(loc, format!(\"'{} \", new_lifetime_param)));\n+        let fn_def = builder.make_ast_mut(fn_def);\n+        let lifetime = builder.make_ast_mut(lifetime);\n+        let loc_needing_lifetime =\n+            loc_needing_lifetime.and_then(|it| it.make_mut(builder).to_position());\n+\n+        add_lifetime_param(fn_def.get_or_create_generic_param_list(), new_lifetime_param);\n+        ted::replace(\n+            lifetime.syntax(),\n+            make_ast_lifetime(new_lifetime_param).clone_for_update().syntax(),\n+        );\n+        loc_needing_lifetime.map(|position| {\n+            ted::insert(position, make_ast_lifetime(new_lifetime_param).clone_for_update().syntax())\n+        });\n     })\n }\n \n /// Generate the assist for the impl def case\n fn generate_impl_def_assist(\n     acc: &mut Assists,\n-    impl_def: &ast::Impl,\n+    impl_def: ast::Impl,\n     lifetime_loc: TextRange,\n+    lifetime: ast::Lifetime,\n ) -> Option<()> {\n-    let new_lifetime_param = generate_unique_lifetime_param_name(&impl_def.generic_param_list())?;\n-    let end_of_impl_kw = impl_def.impl_token()?.text_range().end();\n+    let new_lifetime_param = generate_unique_lifetime_param_name(impl_def.generic_param_list())?;\n     acc.add(AssistId(ASSIST_NAME, AssistKind::Refactor), ASSIST_LABEL, lifetime_loc, |builder| {\n-        add_lifetime_param(impl_def, builder, end_of_impl_kw, new_lifetime_param);\n-        builder.replace(lifetime_loc, format!(\"'{}\", new_lifetime_param));\n+        let impl_def = builder.make_ast_mut(impl_def);\n+        let lifetime = builder.make_ast_mut(lifetime);\n+\n+        add_lifetime_param(impl_def.get_or_create_generic_param_list(), new_lifetime_param);\n+        ted::replace(\n+            lifetime.syntax(),\n+            make_ast_lifetime(new_lifetime_param).clone_for_update().syntax(),\n+        );\n     })\n }\n \n /// Given a type parameter list, generate a unique lifetime parameter name\n /// which is not in the list\n fn generate_unique_lifetime_param_name(\n-    existing_type_param_list: &Option<ast::GenericParamList>,\n+    existing_type_param_list: Option<ast::GenericParamList>,\n ) -> Option<char> {\n     match existing_type_param_list {\n         Some(type_params) => {\n@@ -118,25 +137,37 @@ fn generate_unique_lifetime_param_name(\n     }\n }\n \n-/// Add the lifetime param to `builder`. If there are type parameters in `type_params_owner`, add it to the end. Otherwise\n-/// add new type params brackets with the lifetime parameter at `new_type_params_loc`.\n-fn add_lifetime_param<TypeParamsOwner: ast::GenericParamsOwner>(\n-    type_params_owner: &TypeParamsOwner,\n-    builder: &mut AssistBuilder,\n-    new_type_params_loc: TextSize,\n-    new_lifetime_param: char,\n-) {\n-    match type_params_owner.generic_param_list() {\n-        // add the new lifetime parameter to an existing type param list\n-        Some(type_params) => {\n-            builder.insert(\n-                (u32::from(type_params.syntax().text_range().end()) - 1).into(),\n-                format!(\", '{}\", new_lifetime_param),\n-            );\n+fn add_lifetime_param(type_params: ast::GenericParamList, new_lifetime_param: char) {\n+    let generic_param =\n+        make::generic_param(format!(\"'{}\", new_lifetime_param), None).clone_for_update();\n+    type_params.add_generic_param(generic_param);\n+}\n+\n+fn make_ast_lifetime(new_lifetime_param: char) -> ast::Lifetime {\n+    make::generic_param(format!(\"'{}\", new_lifetime_param), None)\n+        .syntax()\n+        .descendants()\n+        .find_map(ast::Lifetime::cast)\n+        .unwrap()\n+}\n+\n+enum NeedsLifetime {\n+    SelfParam(ast::SelfParam),\n+    RefType(ast::RefType),\n+}\n+\n+impl NeedsLifetime {\n+    fn make_mut(self, builder: &mut AssistBuilder) -> Self {\n+        match self {\n+            Self::SelfParam(it) => Self::SelfParam(builder.make_ast_mut(it)),\n+            Self::RefType(it) => Self::RefType(builder.make_ast_mut(it)),\n         }\n-        // create a new type param list containing only the new lifetime parameter\n-        None => {\n-            builder.insert(new_type_params_loc, format!(\"<'{}>\", new_lifetime_param));\n+    }\n+\n+    fn to_position(self) -> Option<Position> {\n+        match self {\n+            Self::SelfParam(it) => Some(Position::after(it.amp_token()?)),\n+            Self::RefType(it) => Some(Position::after(it.amp_token()?)),\n         }\n     }\n }\n@@ -312,4 +343,13 @@ mod tests {\n             r#\"fn my_fun<'other, 'a>(self, f: &'a Foo, b: &'other Bar) -> X<'a>\"#,\n         );\n     }\n+\n+    #[test]\n+    fn test_function_add_lifetime_to_self_ref_mut() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"fn foo(&mut self) -> &'_$0 ()\"#,\n+            r#\"fn foo<'a>(&'a mut self) -> &'a ()\"#,\n+        );\n+    }\n }"}, {"sha": "04f97f3682f12e3e089daa518be7f2cd9d9485da", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e7a8977358c108164d3ba39aede67119baa5aaf9/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a8977358c108164d3ba39aede67119baa5aaf9/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=e7a8977358c108164d3ba39aede67119baa5aaf9", "patch": "@@ -14,10 +14,29 @@ use crate::{\n use super::NameOwner;\n \n pub trait GenericParamsOwnerEdit: ast::GenericParamsOwner + AstNodeEdit {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList;\n     fn get_or_create_where_clause(&self) -> ast::WhereClause;\n }\n \n impl GenericParamsOwnerEdit for ast::Fn {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList {\n+        match self.generic_param_list() {\n+            Some(it) => it,\n+            None => {\n+                let position = if let Some(name) = self.name() {\n+                    Position::after(name.syntax)\n+                } else if let Some(fn_token) = self.fn_token() {\n+                    Position::after(fn_token)\n+                } else if let Some(param_list) = self.param_list() {\n+                    Position::before(param_list.syntax)\n+                } else {\n+                    Position::last_child_of(self.syntax())\n+                };\n+                create_generic_param_list(position)\n+            }\n+        }\n+    }\n+\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(ty) = self.ret_type() {\n@@ -34,6 +53,20 @@ impl GenericParamsOwnerEdit for ast::Fn {\n }\n \n impl GenericParamsOwnerEdit for ast::Impl {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList {\n+        match self.generic_param_list() {\n+            Some(it) => it,\n+            None => {\n+                let position = if let Some(imp_token) = self.impl_token() {\n+                    Position::after(imp_token)\n+                } else {\n+                    Position::last_child_of(self.syntax())\n+                };\n+                create_generic_param_list(position)\n+            }\n+        }\n+    }\n+\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(items) = self.assoc_item_list() {\n@@ -48,6 +81,22 @@ impl GenericParamsOwnerEdit for ast::Impl {\n }\n \n impl GenericParamsOwnerEdit for ast::Trait {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList {\n+        match self.generic_param_list() {\n+            Some(it) => it,\n+            None => {\n+                let position = if let Some(name) = self.name() {\n+                    Position::after(name.syntax)\n+                } else if let Some(trait_token) = self.trait_token() {\n+                    Position::after(trait_token)\n+                } else {\n+                    Position::last_child_of(self.syntax())\n+                };\n+                create_generic_param_list(position)\n+            }\n+        }\n+    }\n+\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(items) = self.assoc_item_list() {\n@@ -62,6 +111,22 @@ impl GenericParamsOwnerEdit for ast::Trait {\n }\n \n impl GenericParamsOwnerEdit for ast::Struct {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList {\n+        match self.generic_param_list() {\n+            Some(it) => it,\n+            None => {\n+                let position = if let Some(name) = self.name() {\n+                    Position::after(name.syntax)\n+                } else if let Some(struct_token) = self.struct_token() {\n+                    Position::after(struct_token)\n+                } else {\n+                    Position::last_child_of(self.syntax())\n+                };\n+                create_generic_param_list(position)\n+            }\n+        }\n+    }\n+\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let tfl = self.field_list().and_then(|fl| match fl {\n@@ -84,6 +149,22 @@ impl GenericParamsOwnerEdit for ast::Struct {\n }\n \n impl GenericParamsOwnerEdit for ast::Enum {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList {\n+        match self.generic_param_list() {\n+            Some(it) => it,\n+            None => {\n+                let position = if let Some(name) = self.name() {\n+                    Position::after(name.syntax)\n+                } else if let Some(enum_token) = self.enum_token() {\n+                    Position::after(enum_token)\n+                } else {\n+                    Position::last_child_of(self.syntax())\n+                };\n+                create_generic_param_list(position)\n+            }\n+        }\n+    }\n+\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(gpl) = self.generic_param_list() {\n@@ -104,6 +185,37 @@ fn create_where_clause(position: Position) {\n     ted::insert(position, where_clause.syntax());\n }\n \n+fn create_generic_param_list(position: Position) -> ast::GenericParamList {\n+    let gpl = make::generic_param_list(empty()).clone_for_update();\n+    ted::insert_raw(position, gpl.syntax());\n+    gpl\n+}\n+\n+impl ast::GenericParamList {\n+    pub fn add_generic_param(&self, generic_param: ast::GenericParam) {\n+        match self.generic_params().last() {\n+            Some(last_param) => {\n+                let mut elems = Vec::new();\n+                if !last_param\n+                    .syntax()\n+                    .siblings_with_tokens(Direction::Next)\n+                    .any(|it| it.kind() == T![,])\n+                {\n+                    elems.push(make::token(T![,]).into());\n+                    elems.push(make::tokens::single_space().into());\n+                };\n+                elems.push(generic_param.syntax().clone().into());\n+                let after_last_param = Position::after(last_param.syntax());\n+                ted::insert_all(after_last_param, elems);\n+            }\n+            None => {\n+                let after_l_angle = Position::after(self.l_angle_token().unwrap());\n+                ted::insert(after_l_angle, generic_param.syntax())\n+            }\n+        }\n+    }\n+}\n+\n impl ast::WhereClause {\n     pub fn add_predicate(&self, predicate: ast::WherePred) {\n         if let Some(pred) = self.predicates().last() {\n@@ -164,3 +276,44 @@ impl ast::Use {\n         ted::remove(self.syntax())\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::fmt;\n+\n+    use crate::SourceFile;\n+\n+    use super::*;\n+\n+    fn ast_mut_from_text<N: AstNode>(text: &str) -> N {\n+        let parse = SourceFile::parse(text);\n+        parse.tree().syntax().descendants().find_map(N::cast).unwrap().clone_for_update()\n+    }\n+\n+    #[test]\n+    fn test_create_generic_param_list() {\n+        fn check_create_gpl<N: GenericParamsOwnerEdit + fmt::Display>(before: &str, after: &str) {\n+            let gpl_owner = ast_mut_from_text::<N>(before);\n+            gpl_owner.get_or_create_generic_param_list();\n+            assert_eq!(gpl_owner.to_string(), after);\n+        }\n+\n+        check_create_gpl::<ast::Fn>(\"fn foo\", \"fn foo<>\");\n+        check_create_gpl::<ast::Fn>(\"fn foo() {}\", \"fn foo<>() {}\");\n+\n+        check_create_gpl::<ast::Impl>(\"impl\", \"impl<>\");\n+        check_create_gpl::<ast::Impl>(\"impl Struct {}\", \"impl<> Struct {}\");\n+        check_create_gpl::<ast::Impl>(\"impl Trait for Struct {}\", \"impl<> Trait for Struct {}\");\n+\n+        check_create_gpl::<ast::Trait>(\"trait Trait<>\", \"trait Trait<>\");\n+        check_create_gpl::<ast::Trait>(\"trait Trait<> {}\", \"trait Trait<> {}\");\n+\n+        check_create_gpl::<ast::Struct>(\"struct A\", \"struct A<>\");\n+        check_create_gpl::<ast::Struct>(\"struct A;\", \"struct A<>;\");\n+        check_create_gpl::<ast::Struct>(\"struct A();\", \"struct A<>();\");\n+        check_create_gpl::<ast::Struct>(\"struct A {}\", \"struct A<> {}\");\n+\n+        check_create_gpl::<ast::Enum>(\"enum E\", \"enum E<>\");\n+        check_create_gpl::<ast::Enum>(\"enum E {\", \"enum E<> {\");\n+    }\n+}"}, {"sha": "450f2e447ab7ee5b86d8d296560c183bcae931ab", "filename": "crates/syntax/src/ted.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7a8977358c108164d3ba39aede67119baa5aaf9/crates%2Fsyntax%2Fsrc%2Fted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a8977358c108164d3ba39aede67119baa5aaf9/crates%2Fsyntax%2Fsrc%2Fted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fted.rs?ref=e7a8977358c108164d3ba39aede67119baa5aaf9", "patch": "@@ -165,6 +165,13 @@ fn ws_between(left: &SyntaxElement, right: &SyntaxElement) -> Option<SyntaxToken\n     if right.kind() == T![;] || right.kind() == T![,] {\n         return None;\n     }\n+    if left.kind() == T![<] || right.kind() == T![>] {\n+        return None;\n+    }\n+    if left.kind() == T![&] && right.kind() == SyntaxKind::LIFETIME {\n+        return None;\n+    }\n+\n     if right.kind() == SyntaxKind::USE {\n         let indent = IndentLevel::from_element(left);\n         return Some(make::tokens::whitespace(&format!(\"\\n{}\", indent)));"}]}