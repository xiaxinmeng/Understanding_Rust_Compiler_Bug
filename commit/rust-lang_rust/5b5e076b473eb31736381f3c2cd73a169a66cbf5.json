{"sha": "5b5e076b473eb31736381f3c2cd73a169a66cbf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNWUwNzZiNDczZWIzMTczNjM4MWYzYzJjZDczYTE2OWE2NmNiZjU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-31T15:46:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-05T08:15:46Z"}, "message": "generalize the traversal part of validation to a ValueVisitor", "tree": {"sha": "0182f611e7622db66678ef84b9c80f638a3e43dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0182f611e7622db66678ef84b9c80f638a3e43dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b5e076b473eb31736381f3c2cd73a169a66cbf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b5e076b473eb31736381f3c2cd73a169a66cbf5", "html_url": "https://github.com/rust-lang/rust/commit/5b5e076b473eb31736381f3c2cd73a169a66cbf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b5e076b473eb31736381f3c2cd73a169a66cbf5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0117b42f66632f1f0fc08f1cdd8ca264c10bba94", "url": "https://api.github.com/repos/rust-lang/rust/commits/0117b42f66632f1f0fc08f1cdd8ca264c10bba94", "html_url": "https://github.com/rust-lang/rust/commit/0117b42f66632f1f0fc08f1cdd8ca264c10bba94"}], "stats": {"total": 729, "additions": 424, "deletions": 305}, "files": [{"sha": "34684587db207afe594f9629120da97773c81f63", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=5b5e076b473eb31736381f3c2cd73a169a66cbf5", "patch": "@@ -535,14 +535,14 @@ fn validate_const<'a, 'tcx>(\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     let cid = key.value;\n-    let ecx = mk_eval_cx(tcx, cid.instance, key.param_env).unwrap();\n+    let mut ecx = mk_eval_cx(tcx, cid.instance, key.param_env).unwrap();\n     let val = (|| {\n         let op = ecx.const_to_op(constant)?;\n         let mut ref_tracking = RefTracking::new(op);\n-        while let Some((op, mut path)) = ref_tracking.todo.pop() {\n+        while let Some((op, path)) = ref_tracking.todo.pop() {\n             ecx.validate_operand(\n                 op,\n-                &mut path,\n+                path,\n                 Some(&mut ref_tracking),\n                 /* const_mode */ true,\n             )?;"}, {"sha": "e6267012dc27587848c9b42c105f429b2cb8ded8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=5b5e076b473eb31736381f3c2cd73a169a66cbf5", "patch": "@@ -521,7 +521,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 // return place is always a local and then this cannot happen.\n                 self.validate_operand(\n                     self.place_to_op(return_place)?,\n-                    &mut vec![],\n+                    vec![],\n                     None,\n                     /*const_mode*/false,\n                 )?;"}, {"sha": "82fe08fa038a4ad32c9deba323f34c4214aab597", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=5b5e076b473eb31736381f3c2cd73a169a66cbf5", "patch": "@@ -23,6 +23,7 @@ mod terminator;\n mod traits;\n mod validity;\n mod intrinsics;\n+mod visitor;\n \n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n@@ -38,4 +39,6 @@ pub use self::machine::{Machine, AllocMap, MayLeak};\n \n pub use self::operand::{ScalarMaybeUndef, Immediate, ImmTy, Operand, OpTy};\n \n+pub use self::visitor::ValueVisitor;\n+\n pub use self::validity::RefTracking;"}, {"sha": "35276fa6265d2af1f358998dfa05ff601ed8fc34", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=5b5e076b473eb31736381f3c2cd73a169a66cbf5", "patch": "@@ -489,6 +489,8 @@ where\n \n     /// Get the place of a field inside the place, and also the field's type.\n     /// Just a convenience function, but used quite a bit.\n+    /// This is the only projection that might have a side-effect: We cannot project\n+    /// into the field of a local `ScalarPair`, we have to first allocate it.\n     pub fn place_field(\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n@@ -501,7 +503,7 @@ where\n     }\n \n     pub fn place_downcast(\n-        &mut self,\n+        &self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n         variant: usize,\n     ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n@@ -643,7 +645,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, &mut vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(self.place_to_op(dest)?, vec![], None, /*const_mode*/false)?;\n         }\n \n         Ok(())\n@@ -765,7 +767,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, &mut vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(self.place_to_op(dest)?, vec![], None, /*const_mode*/false)?;\n         }\n \n         Ok(())\n@@ -843,7 +845,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), &mut vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(dest.into(), vec![], None, /*const_mode*/false)?;\n         }\n \n         Ok(())"}, {"sha": "8ac3f992cfd96ee85a596e14f4714377b428931b", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 286, "deletions": 297, "changes": 583, "blob_url": "https://github.com/rust-lang/rust/blob/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=5b5e076b473eb31736381f3c2cd73a169a66cbf5", "patch": "@@ -8,24 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt::Write;\n+use std::fmt::{self, Write};\n use std::hash::Hash;\n \n use syntax_pos::symbol::Symbol;\n use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf};\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n     Scalar, AllocType, EvalResult, EvalErrorKind\n };\n \n use super::{\n-    ImmTy, OpTy, MPlaceTy, Machine, EvalContext, ScalarMaybeUndef\n+    OpTy, MPlaceTy, Machine, EvalContext, ScalarMaybeUndef, ValueVisitor\n };\n \n macro_rules! validation_failure {\n     ($what:expr, $where:expr, $details:expr) => {{\n-        let where_ = path_format($where);\n+        let where_ = path_format(&$where);\n         let where_ = if where_.is_empty() {\n             String::new()\n         } else {\n@@ -37,7 +37,7 @@ macro_rules! validation_failure {\n         )))\n     }};\n     ($what:expr, $where:expr) => {{\n-        let where_ = path_format($where);\n+        let where_ = path_format(&$where);\n         let where_ = if where_.is_empty() {\n             String::new()\n         } else {\n@@ -129,6 +129,43 @@ fn path_format(path: &Vec<PathElem>) -> String {\n     out\n }\n \n+fn aggregate_field_path_elem<'a, 'tcx>(\n+    layout: TyLayout<'tcx>,\n+    field: usize,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+) -> PathElem {\n+    match layout.ty.sty {\n+        // generators and closures.\n+        ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n+            if let Some(upvar) = tcx.optimized_mir(def_id).upvar_decls.get(field) {\n+                PathElem::ClosureVar(upvar.debug_name)\n+            } else {\n+                // Sometimes the index is beyond the number of freevars (seen\n+                // for a generator).\n+                PathElem::ClosureVar(Symbol::intern(&field.to_string()))\n+            }\n+        }\n+\n+        // tuples\n+        ty::Tuple(_) => PathElem::TupleElem(field),\n+\n+        // enums\n+        ty::Adt(def, ..) if def.is_enum() => {\n+            let variant = match layout.variants {\n+                layout::Variants::Single { index } => &def.variants[index],\n+                _ => bug!(\"aggregate_field_path_elem: got enum but not in a specific variant\"),\n+            };\n+            PathElem::Field(variant.fields[field].ident.name)\n+        }\n+\n+        // other ADTs\n+        ty::Adt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n+\n+        // nothing else has an aggregate layout\n+        _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", layout.ty),\n+    }\n+}\n+\n fn scalar_format<Tag>(value: ScalarMaybeUndef<Tag>) -> String {\n     match value {\n         ScalarMaybeUndef::Undef =>\n@@ -140,37 +177,92 @@ fn scalar_format<Tag>(value: ScalarMaybeUndef<Tag>) -> String {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    /// Make sure that `value` is valid for `ty`, *assuming* `ty` is a primitive type.\n-    fn validate_primitive_type(\n-        &self,\n-        value: ImmTy<'tcx, M::PointerTag>,\n-        path: &Vec<PathElem>,\n-        ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,\n-        const_mode: bool,\n-    ) -> EvalResult<'tcx> {\n+struct ValidityVisitor<'rt, 'tcx, Tag> {\n+    op: OpTy<'tcx, Tag>,\n+    /// The `path` may be pushed to, but the part that is present when a function\n+    /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n+    /// this stack discipline.\n+    path: Vec<PathElem>,\n+    ref_tracking: Option<&'rt mut RefTracking<'tcx, Tag>>,\n+    const_mode: bool,\n+}\n+\n+impl<Tag: fmt::Debug> fmt::Debug for ValidityVisitor<'_, '_, Tag> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?} ({:?})\", *self.op, self.op.layout.ty)\n+    }\n+}\n+\n+impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n+    ValueVisitor<'a, 'mir, 'tcx, M> for ValidityVisitor<'rt, 'tcx, M::PointerTag>\n+{\n+    #[inline(always)]\n+    fn layout(&self) -> TyLayout<'tcx> {\n+        self.op.layout\n+    }\n+\n+    fn downcast_enum(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>\n+    {\n+        let variant = match ectx.read_discriminant(self.op) {\n+            Ok(res) => res.1,\n+            Err(err) => return match err.kind {\n+                EvalErrorKind::InvalidDiscriminant(val) =>\n+                    validation_failure!(\n+                        format!(\"invalid enum discriminant {}\", val), self.path\n+                    ),\n+                _ =>\n+                    validation_failure!(\n+                        format!(\"non-integer enum discriminant\"), self.path\n+                    ),\n+            }\n+        };\n+        // Put the variant projection onto the path, as a field\n+        self.path.push(PathElem::Field(self.op.layout.ty\n+                                    .ty_adt_def()\n+                                    .unwrap()\n+                                    .variants[variant].name));\n+        // Proceed with this variant\n+        self.op = ectx.operand_downcast(self.op, variant)?;\n+        Ok(())\n+    }\n+\n+    fn downcast_dyn_trait(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>\n+    {\n+        // FIXME: Should we reflect this in `self.path`?\n+        let dest = self.op.to_mem_place(); // immediate trait objects are not a thing\n+        self.op = ectx.unpack_dyn_trait(dest)?.1.into();\n+        Ok(())\n+    }\n+\n+    fn visit_primitive(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>\n+    {\n+        let value = try_validation!(ectx.read_immediate(self.op),\n+            \"uninitialized or unrepresentable data\", self.path);\n         // Go over all the primitive types\n         let ty = value.layout.ty;\n         match ty.sty {\n             ty::Bool => {\n                 let value = value.to_scalar_or_undef();\n                 try_validation!(value.to_bool(),\n-                    scalar_format(value), path, \"a boolean\");\n+                    scalar_format(value), self.path, \"a boolean\");\n             },\n             ty::Char => {\n                 let value = value.to_scalar_or_undef();\n                 try_validation!(value.to_char(),\n-                    scalar_format(value), path, \"a valid unicode codepoint\");\n+                    scalar_format(value), self.path, \"a valid unicode codepoint\");\n             },\n             ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n                 // NOTE: Keep this in sync with the array optimization for int/float\n                 // types below!\n                 let size = value.layout.size;\n                 let value = value.to_scalar_or_undef();\n-                if const_mode {\n+                if self.const_mode {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     try_validation!(value.to_bits(size),\n-                        scalar_format(value), path, \"initialized plain bits\");\n+                        scalar_format(value), self.path, \"initialized plain bits\");\n                 } else {\n                     // At run-time, for now, we accept *anything* for these types, including\n                     // undef. We should fix that, but let's start low.\n@@ -180,33 +272,33 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // No undef allowed here.  Eventually this should be consistent with\n                 // the integer types.\n                 let _ptr = try_validation!(value.to_scalar_ptr(),\n-                    \"undefined address in pointer\", path);\n+                    \"undefined address in pointer\", self.path);\n                 let _meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in fat pointer metadata\", path);\n+                    \"uninitialized data in fat pointer metadata\", self.path);\n             }\n             _ if ty.is_box() || ty.is_region_ptr() => {\n                 // Handle fat pointers.\n                 // Check metadata early, for better diagnostics\n                 let ptr = try_validation!(value.to_scalar_ptr(),\n-                    \"undefined address in pointer\", path);\n+                    \"undefined address in pointer\", self.path);\n                 let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in fat pointer metadata\", path);\n-                let layout = self.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n+                    \"uninitialized data in fat pointer metadata\", self.path);\n+                let layout = ectx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n                 if layout.is_unsized() {\n-                    let tail = self.tcx.struct_tail(layout.ty);\n+                    let tail = ectx.tcx.struct_tail(layout.ty);\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n                             let vtable = try_validation!(meta.unwrap().to_ptr(),\n-                                \"non-pointer vtable in fat pointer\", path);\n-                            try_validation!(self.read_drop_type_from_vtable(vtable),\n-                                \"invalid drop fn in vtable\", path);\n-                            try_validation!(self.read_size_and_align_from_vtable(vtable),\n-                                \"invalid size or align in vtable\", path);\n+                                \"non-pointer vtable in fat pointer\", self.path);\n+                            try_validation!(ectx.read_drop_type_from_vtable(vtable),\n+                                \"invalid drop fn in vtable\", self.path);\n+                            try_validation!(ectx.read_size_and_align_from_vtable(vtable),\n+                                \"invalid size or align in vtable\", self.path);\n                             // FIXME: More checks for the vtable.\n                         }\n                         ty::Slice(..) | ty::Str => {\n-                            try_validation!(meta.unwrap().to_usize(self),\n-                                \"non-integer slice length in fat pointer\", path);\n+                            try_validation!(meta.unwrap().to_usize(ectx),\n+                                \"non-integer slice length in fat pointer\", self.path);\n                         }\n                         ty::Foreign(..) => {\n                             // Unsized, but not fat.\n@@ -216,55 +308,55 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     }\n                 }\n                 // Make sure this is non-NULL and aligned\n-                let (size, align) = self.size_and_align_of(meta, layout)?\n+                let (size, align) = ectx.size_and_align_of(meta, layout)?\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n                     .unwrap_or_else(|| layout.size_and_align());\n-                match self.memory.check_align(ptr, align) {\n+                match ectx.memory.check_align(ptr, align) {\n                     Ok(_) => {},\n                     Err(err) => {\n                         error!(\"{:?} is not aligned to {:?}\", ptr, align);\n                         match err.kind {\n                             EvalErrorKind::InvalidNullPointerUsage =>\n-                                return validation_failure!(\"NULL reference\", path),\n+                                return validation_failure!(\"NULL reference\", self.path),\n                             EvalErrorKind::AlignmentCheckFailed { .. } =>\n-                                return validation_failure!(\"unaligned reference\", path),\n+                                return validation_failure!(\"unaligned reference\", self.path),\n                             _ =>\n                                 return validation_failure!(\n                                     \"dangling (out-of-bounds) reference (might be NULL at \\\n                                         run-time)\",\n-                                    path\n+                                    self.path\n                                 ),\n                         }\n                     }\n                 }\n                 // Turn ptr into place.\n                 // `ref_to_mplace` also calls the machine hook for (re)activating the tag,\n                 // which in turn will (in full miri) check if the pointer is dereferencable.\n-                let place = self.ref_to_mplace(value)?;\n+                let place = ectx.ref_to_mplace(value)?;\n                 // Recursive checking\n-                if let Some(ref_tracking) = ref_tracking {\n-                    assert!(const_mode, \"We should only do recursie checking in const mode\");\n+                if let Some(ref mut ref_tracking) = self.ref_tracking {\n+                    assert!(self.const_mode, \"We should only do recursie checking in const mode\");\n                     if size != Size::ZERO {\n                         // Non-ZST also have to be dereferencable\n                         let ptr = try_validation!(place.ptr.to_ptr(),\n-                            \"integer pointer in non-ZST reference\", path);\n+                            \"integer pointer in non-ZST reference\", self.path);\n                         // Skip validation entirely for some external statics\n-                        let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                        let alloc_kind = ectx.tcx.alloc_map.lock().get(ptr.alloc_id);\n                         if let Some(AllocType::Static(did)) = alloc_kind {\n                             // `extern static` cannot be validated as they have no body.\n                             // FIXME: Statics from other crates are also skipped.\n                             // They might be checked at a different type, but for now we\n                             // want to avoid recursing too deeply.  This is not sound!\n-                            if !did.is_local() || self.tcx.is_foreign_item(did) {\n+                            if !did.is_local() || ectx.tcx.is_foreign_item(did) {\n                                 return Ok(());\n                             }\n                         }\n                         // Maintain the invariant that the place we are checking is\n                         // already verified to be in-bounds.\n-                        try_validation!(self.memory.check_bounds(ptr, size, false),\n-                            \"dangling (not entirely in bounds) reference\", path);\n+                        try_validation!(ectx.memory.check_bounds(ptr, size, false),\n+                            \"dangling (not entirely in bounds) reference\", self.path);\n                     }\n                     // Check if we have encountered this pointer+layout combination\n                     // before.  Proceed recursively even for integer pointers, no\n@@ -273,16 +365,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     let op = place.into();\n                     if ref_tracking.seen.insert(op) {\n                         trace!(\"Recursing below ptr {:#?}\", *op);\n-                        ref_tracking.todo.push((op, path_clone_and_deref(path)));\n+                        ref_tracking.todo.push((op, path_clone_and_deref(&self.path)));\n                     }\n                 }\n             }\n             ty::FnPtr(_sig) => {\n                 let value = value.to_scalar_or_undef();\n                 let ptr = try_validation!(value.to_ptr(),\n-                    scalar_format(value), path, \"a pointer\");\n-                let _fn = try_validation!(self.memory.get_fn(ptr),\n-                    scalar_format(value), path, \"a function pointer\");\n+                    scalar_format(value), self.path, \"a pointer\");\n+                let _fn = try_validation!(ectx.memory.get_fn(ptr),\n+                    scalar_format(value), self.path, \"a function pointer\");\n                 // FIXME: Check if the signature matches\n             }\n             // This should be all the primitive types\n@@ -292,16 +384,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok(())\n     }\n \n-    /// Make sure that `value` matches the\n-    fn validate_scalar_layout(\n-        &self,\n-        value: ScalarMaybeUndef<M::PointerTag>,\n-        size: Size,\n-        path: &Vec<PathElem>,\n-        layout: &layout::Scalar,\n-    ) -> EvalResult<'tcx> {\n+    fn visit_scalar(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>, layout: &layout::Scalar)\n+        -> EvalResult<'tcx>\n+    {\n+        let value = try_validation!(ectx.read_scalar(self.op),\n+            \"uninitialized or unrepresentable data\", self.path);\n+        // Determine the allowed range\n         let (lo, hi) = layout.valid_range.clone().into_inner();\n-        let max_hi = u128::max_value() >> (128 - size.bits()); // as big as the size fits\n+        // `max_hi` is as big as the size fits\n+        let max_hi = u128::max_value() >> (128 - self.op.layout.size.bits());\n         assert!(hi <= max_hi);\n         // We could also write `(hi + 1) % (max_hi + 1) == lo` but `max_hi + 1` overflows for `u128`\n         if (lo == 0 && hi == max_hi) || (hi + 1 == lo) {\n@@ -310,38 +401,39 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         }\n         // At least one value is excluded. Get the bits.\n         let value = try_validation!(value.not_undef(),\n-            scalar_format(value), path, format!(\"something in the range {:?}\", layout.valid_range));\n+            scalar_format(value), self.path,\n+            format!(\"something in the range {:?}\", layout.valid_range));\n         let bits = match value {\n             Scalar::Ptr(ptr) => {\n                 if lo == 1 && hi == max_hi {\n                     // only NULL is not allowed.\n                     // We can call `check_align` to check non-NULL-ness, but have to also look\n                     // for function pointers.\n                     let non_null =\n-                        self.memory.check_align(\n+                        ectx.memory.check_align(\n                             Scalar::Ptr(ptr), Align::from_bytes(1, 1).unwrap()\n                         ).is_ok() ||\n-                        self.memory.get_fn(ptr).is_ok();\n+                        ectx.memory.get_fn(ptr).is_ok();\n                     if !non_null {\n                         // could be NULL\n-                        return validation_failure!(\"a potentially NULL pointer\", path);\n+                        return validation_failure!(\"a potentially NULL pointer\", self.path);\n                     }\n                     return Ok(());\n                 } else {\n                     // Conservatively, we reject, because the pointer *could* have this\n                     // value.\n                     return validation_failure!(\n                         \"a pointer\",\n-                        path,\n+                        self.path,\n                         format!(\n                             \"something that cannot possibly be outside the (wrapping) range {:?}\",\n                             layout.valid_range\n                         )\n                     );\n                 }\n             }\n-            Scalar::Bits { bits, size: value_size } => {\n-                assert_eq!(value_size as u64, size.bytes());\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, self.op.layout.size.bytes());\n                 bits\n             }\n         };\n@@ -355,7 +447,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             } else {\n                 validation_failure!(\n                     bits,\n-                    path,\n+                    self.path,\n                     format!(\"something in the range {:?} or {:?}\", 0..=hi, lo..=max_hi)\n                 )\n             }\n@@ -365,7 +457,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             } else {\n                 validation_failure!(\n                     bits,\n-                    path,\n+                    self.path,\n                     if hi == max_hi {\n                         format!(\"something greater or equal to {}\", lo)\n                     } else {\n@@ -376,250 +468,147 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         }\n     }\n \n-    /// This function checks the data at `op`.  `op` is assumed to cover valid memory if it\n-    /// is an indirect operand.\n-    /// It will error if the bits at the destination do not match the ones described by the layout.\n-    /// The `path` may be pushed to, but the part that is present when the function\n-    /// starts must not be changed!\n-    ///\n-    /// `ref_tracking` can be None to avoid recursive checking below references.\n-    /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n-    /// validation (e.g., pointer values are fine in integers at runtime).\n-    pub fn validate_operand(\n-        &self,\n-        dest: OpTy<'tcx, M::PointerTag>,\n-        path: &mut Vec<PathElem>,\n-        mut ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,\n-        const_mode: bool,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"validate_operand: {:?}, {:?}\", *dest, dest.layout.ty);\n-\n-        // If this is a multi-variant layout, we have find the right one and proceed with that.\n-        // (No good reasoning to make this recursion, but it is equivalent to that.)\n-        let dest = match dest.layout.variants {\n-            layout::Variants::NicheFilling { .. } |\n-            layout::Variants::Tagged { .. } => {\n-                let variant = match self.read_discriminant(dest) {\n-                    Ok(res) => res.1,\n-                    Err(err) => match err.kind {\n-                        EvalErrorKind::InvalidDiscriminant(val) =>\n-                            return validation_failure!(\n-                                format!(\"invalid enum discriminant {}\", val), path\n-                            ),\n-                        _ =>\n-                            return validation_failure!(\n-                                String::from(\"non-integer enum discriminant\"), path\n-                            ),\n-                    }\n-                };\n-                // Put the variant projection onto the path, as a field\n-                path.push(PathElem::Field(dest.layout.ty\n-                                          .ty_adt_def()\n-                                          .unwrap()\n-                                          .variants[variant].name));\n-                // Proceed with this variant\n-                let dest = self.operand_downcast(dest, variant)?;\n-                trace!(\"variant layout: {:#?}\", dest.layout);\n-                dest\n-            },\n-            layout::Variants::Single { .. } => dest,\n-        };\n-\n-        // First thing, find the real type:\n-        // If it is a trait object, switch to the actual type that was used to create it.\n-        let dest = match dest.layout.ty.sty {\n-            ty::Dynamic(..) => {\n-                let dest = dest.to_mem_place(); // immediate trait objects are not a thing\n-                self.unpack_dyn_trait(dest)?.1.into()\n-            },\n-            _ => dest\n-        };\n-\n-        // If this is a scalar, validate the scalar layout.\n-        // Things can be aggregates and have scalar layout at the same time, and that\n-        // is very relevant for `NonNull` and similar structs: We need to validate them\n-        // at their scalar layout *before* descending into their fields.\n-        // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n-        // scalars, we do the same check on every \"level\" (e.g. first we check\n-        // MyNewtype and then the scalar in there).\n-        match dest.layout.abi {\n-            layout::Abi::Uninhabited =>\n-                return validation_failure!(\"a value of an uninhabited type\", path),\n-            layout::Abi::Scalar(ref layout) => {\n-                let value = try_validation!(self.read_scalar(dest),\n-                            \"uninitialized or unrepresentable data\", path);\n-                self.validate_scalar_layout(value, dest.layout.size, &path, layout)?;\n-            }\n-            // FIXME: Should we do something for ScalarPair? Vector?\n-            _ => {}\n+    fn visit_fields(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>, num_fields: usize)\n+        -> EvalResult<'tcx>\n+    {\n+        // Remember some stuff that will change for the recursive calls\n+        let op = self.op;\n+        let path_len = self.path.len();\n+        // Go look at all the fields\n+        for i in 0..num_fields {\n+            // Adapt our state\n+            self.op = ectx.operand_field(op, i as u64)?;\n+            self.path.push(aggregate_field_path_elem(op.layout, i, *ectx.tcx));\n+            // Recursive visit\n+            ectx.visit_value(self)?;\n+            // Restore original state\n+            self.op = op;\n+            self.path.truncate(path_len);\n         }\n+        Ok(())\n+    }\n \n-        // Check primitive types.  We do this after checking the scalar layout,\n-        // just to have that done as well.  Primitives can have varying layout,\n-        // so we check them separately and before aggregate handling.\n-        // It is CRITICAL that we get this check right, or we might be\n-        // validating the wrong thing!\n-        let primitive = match dest.layout.fields {\n-            // Primitives appear as Union with 0 fields -- except for fat pointers.\n-            layout::FieldPlacement::Union(0) => true,\n-            _ => dest.layout.ty.builtin_deref(true).is_some(),\n-        };\n-        if primitive {\n-            let value = try_validation!(self.read_immediate(dest),\n-                \"uninitialized or unrepresentable data\", path);\n-            return self.validate_primitive_type(\n-                value,\n-                &path,\n-                ref_tracking,\n-                const_mode,\n-            );\n-        }\n+    fn visit_str(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>\n+    {\n+        let mplace = self.op.to_mem_place(); // strings are never immediate\n+        try_validation!(ectx.read_str(mplace),\n+            \"uninitialized or non-UTF-8 data in str\", self.path);\n+        Ok(())\n+    }\n \n-        // Validate all fields of compound data structures\n-        let path_len = path.len(); // Remember the length, in case we need to truncate\n-        match dest.layout.fields {\n-            layout::FieldPlacement::Union(fields) => {\n-                // Empty unions are not accepted by rustc. That's great, it means we can\n-                // use that as an unambiguous signal for detecting primitives.  Make sure\n-                // we did not miss any primitive.\n-                debug_assert!(fields > 0);\n-                // We can't check unions, their bits are allowed to be anything.\n-                // The fields don't need to correspond to any bit pattern of the union's fields.\n-                // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n-            },\n-            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                // Go look at all the fields\n-                for i in 0..offsets.len() {\n-                    let field = self.operand_field(dest, i as u64)?;\n-                    path.push(self.aggregate_field_path_elem(dest.layout, i));\n-                    self.validate_operand(\n-                        field,\n-                        path,\n-                        ref_tracking.as_mut().map(|r| &mut **r),\n-                        const_mode,\n-                    )?;\n-                    path.truncate(path_len);\n+    fn visit_array(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>) -> EvalResult<'tcx>\n+    {\n+        let mplace = if self.op.layout.is_zst() {\n+            // it's a ZST, the memory content cannot matter\n+            MPlaceTy::dangling(self.op.layout, ectx)\n+        } else {\n+            // non-ZST array/slice/str cannot be immediate\n+            self.op.to_mem_place()\n+        };\n+        match self.op.layout.ty.sty {\n+            ty::Str => bug!(\"Strings should be handled separately\"),\n+            // Special handling for arrays/slices of builtin integer types\n+            ty::Array(tys, ..) | ty::Slice(tys) if {\n+                // This optimization applies only for integer and floating point types\n+                // (i.e., types that can hold arbitrary bytes).\n+                match tys.sty {\n+                    ty::Int(..) | ty::Uint(..) | ty::Float(..) => true,\n+                    _ => false,\n                 }\n-            }\n-            layout::FieldPlacement::Array { stride, .. } => {\n-                let dest = if dest.layout.is_zst() {\n-                    // it's a ZST, the memory content cannot matter\n-                    MPlaceTy::dangling(dest.layout, self)\n-                } else {\n-                    // non-ZST array/slice/str cannot be immediate\n-                    dest.to_mem_place()\n-                };\n-                match dest.layout.ty.sty {\n-                    // Special handling for strings to verify UTF-8\n-                    ty::Str => {\n-                        try_validation!(self.read_str(dest),\n-                            \"uninitialized or non-UTF-8 data in str\", path);\n-                    }\n-                    // Special handling for arrays/slices of builtin integer types\n-                    ty::Array(tys, ..) | ty::Slice(tys) if {\n-                        // This optimization applies only for integer and floating point types\n-                        // (i.e., types that can hold arbitrary bytes).\n-                        match tys.sty {\n-                            ty::Int(..) | ty::Uint(..) | ty::Float(..) => true,\n-                            _ => false,\n-                        }\n-                    } => {\n-                        // This is the length of the array/slice.\n-                        let len = dest.len(self)?;\n-                        // Since primitive types are naturally aligned and tightly packed in arrays,\n-                        // we can use the stride to get the size of the integral type.\n-                        let ty_size = stride.bytes();\n-                        // This is the size in bytes of the whole array.\n-                        let size = Size::from_bytes(ty_size * len);\n-\n-                        // NOTE: Keep this in sync with the handling of integer and float\n-                        // types above, in `validate_primitive_type`.\n-                        // In run-time mode, we accept pointers in here.  This is actually more\n-                        // permissive than a per-element check would be, e.g. we accept\n-                        // an &[u8] that contains a pointer even though bytewise checking would\n-                        // reject it.  However, that's good: We don't inherently want\n-                        // to reject those pointers, we just do not have the machinery to\n-                        // talk about parts of a pointer.\n-                        // We also accept undef, for consistency with the type-based checks.\n-                        match self.memory.check_bytes(\n-                            dest.ptr,\n-                            size,\n-                            /*allow_ptr_and_undef*/!const_mode,\n-                        ) {\n-                            // In the happy case, we needn't check anything else.\n-                            Ok(()) => {},\n-                            // Some error happened, try to provide a more detailed description.\n-                            Err(err) => {\n-                                // For some errors we might be able to provide extra information\n-                                match err.kind {\n-                                    EvalErrorKind::ReadUndefBytes(offset) => {\n-                                        // Some byte was undefined, determine which\n-                                        // element that byte belongs to so we can\n-                                        // provide an index.\n-                                        let i = (offset.bytes() / ty_size) as usize;\n-                                        path.push(PathElem::ArrayElem(i));\n-\n-                                        return validation_failure!(\n-                                            \"undefined bytes\", path\n-                                        )\n-                                    },\n-                                    // Other errors shouldn't be possible\n-                                    _ => return Err(err),\n-                                }\n-                            }\n-                        }\n-                    },\n-                    _ => {\n-                        // This handles the unsized case correctly as well, as well as\n-                        // SIMD an all sorts of other array-like types.\n-                        for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n-                            let field = field?;\n-                            path.push(PathElem::ArrayElem(i));\n-                            self.validate_operand(\n-                                field.into(),\n-                                path,\n-                                ref_tracking.as_mut().map(|r| &mut **r),\n-                                const_mode,\n-                            )?;\n-                            path.truncate(path_len);\n+            } => {\n+                // This is the length of the array/slice.\n+                let len = mplace.len(ectx)?;\n+                // This is the element type size.\n+                let ty_size = ectx.layout_of(tys)?.size;\n+                // This is the size in bytes of the whole array.\n+                let size = ty_size * len;\n+\n+                // NOTE: Keep this in sync with the handling of integer and float\n+                // types above, in `visit_primitive`.\n+                // In run-time mode, we accept pointers in here.  This is actually more\n+                // permissive than a per-element check would be, e.g. we accept\n+                // an &[u8] that contains a pointer even though bytewise checking would\n+                // reject it.  However, that's good: We don't inherently want\n+                // to reject those pointers, we just do not have the machinery to\n+                // talk about parts of a pointer.\n+                // We also accept undef, for consistency with the type-based checks.\n+                match ectx.memory.check_bytes(\n+                    mplace.ptr,\n+                    size,\n+                    /*allow_ptr_and_undef*/!self.const_mode,\n+                ) {\n+                    // In the happy case, we needn't check anything else.\n+                    Ok(()) => {},\n+                    // Some error happened, try to provide a more detailed description.\n+                    Err(err) => {\n+                        // For some errors we might be able to provide extra information\n+                        match err.kind {\n+                            EvalErrorKind::ReadUndefBytes(offset) => {\n+                                // Some byte was undefined, determine which\n+                                // element that byte belongs to so we can\n+                                // provide an index.\n+                                let i = (offset.bytes() / ty_size.bytes()) as usize;\n+                                self.path.push(PathElem::ArrayElem(i));\n+\n+                                return validation_failure!(\n+                                    \"undefined bytes\", self.path\n+                                )\n+                            },\n+                            // Other errors shouldn't be possible\n+                            _ => return Err(err),\n                         }\n                     }\n                 }\n             },\n+            _ => {\n+                // Remember some stuff that will change for the recursive calls\n+                let op = self.op;\n+                let path_len = self.path.len();\n+                // This handles the unsized case correctly as well, as well as\n+                // SIMD and all sorts of other array-like types.\n+                for (i, field) in ectx.mplace_array_fields(mplace)?.enumerate() {\n+                    // Adapt our state\n+                    self.op = field?.into();\n+                    self.path.push(PathElem::ArrayElem(i));\n+                    // Recursive visit\n+                    ectx.visit_value(self)?;\n+                    // Restore original state\n+                    self.op = op;\n+                    self.path.truncate(path_len);\n+                }\n+            }\n         }\n         Ok(())\n     }\n+}\n \n-    fn aggregate_field_path_elem(&self, layout: TyLayout<'tcx>, field: usize) -> PathElem {\n-        match layout.ty.sty {\n-            // generators and closures.\n-            ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                if let Some(upvar) = self.tcx.optimized_mir(def_id).upvar_decls.get(field) {\n-                    PathElem::ClosureVar(upvar.debug_name)\n-                } else {\n-                    // Sometimes the index is beyond the number of freevars (seen\n-                    // for a generator).\n-                    PathElem::ClosureVar(Symbol::intern(&field.to_string()))\n-                }\n-            }\n-\n-            // tuples\n-            ty::Tuple(_) => PathElem::TupleElem(field),\n-\n-            // enums\n-            ty::Adt(def, ..) if def.is_enum() => {\n-                let variant = match layout.variants {\n-                    layout::Variants::Single { index } => &def.variants[index],\n-                    _ => bug!(\"aggregate_field_path_elem: got enum but not in a specific variant\"),\n-                };\n-                PathElem::Field(variant.fields[field].ident.name)\n-            }\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    /// This function checks the data at `op`.  `op` is assumed to cover valid memory if it\n+    /// is an indirect operand.\n+    /// It will error if the bits at the destination do not match the ones described by the layout.\n+    ///\n+    /// `ref_tracking` can be None to avoid recursive checking below references.\n+    /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n+    /// validation (e.g., pointer values are fine in integers at runtime).\n+    pub fn validate_operand(\n+        &mut self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+        path: Vec<PathElem>,\n+        ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,\n+        const_mode: bool,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"validate_operand: {:?}, {:?}\", *op, op.layout.ty);\n \n-            // other ADTs\n-            ty::Adt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n+        // Construct a visitor\n+        let mut visitor = ValidityVisitor {\n+            op,\n+            path,\n+            ref_tracking,\n+            const_mode\n+        };\n \n-            // nothing else has an aggregate layout\n-            _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", layout.ty),\n-        }\n+        // Run it\n+        self.visit_value(&mut visitor)\n     }\n }"}, {"sha": "892eaceff1bc6f6265ba5e2abaabc4c7c8efdbd0", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b5e076b473eb31736381f3c2cd73a169a66cbf5/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=5b5e076b473eb31736381f3c2cd73a169a66cbf5", "patch": "@@ -0,0 +1,125 @@\n+//! Visitor for a run-time value with a given layout: Traverse enums, structs and other compound\n+//! types until we arrive at the leaves, with custom handling for primitive types.\n+\n+use std::fmt;\n+\n+use rustc::ty::layout::{self, TyLayout};\n+use rustc::ty;\n+use rustc::mir::interpret::{\n+    EvalResult,\n+};\n+\n+use super::{\n+    Machine, EvalContext,\n+};\n+\n+// How to traverse a value and what to do when we are at the leaves.\n+// In the future, we might want to turn this into two traits, but so far the\n+// only implementations we have couldn't share any code anyway.\n+pub trait ValueVisitor<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: fmt::Debug {\n+    // Get this value's layout.\n+    fn layout(&self) -> TyLayout<'tcx>;\n+\n+    // Downcast functions.  These change the value as a side-effect.\n+    fn downcast_enum(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>;\n+    fn downcast_dyn_trait(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>;\n+\n+    // Visit all fields of a compound.\n+    // Just call `visit_value` if you want to go on recursively.\n+    fn visit_fields(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>, num_fields: usize)\n+        -> EvalResult<'tcx>;\n+    // Optimized handling for arrays -- avoid computing the layout for every field.\n+    // Also it is the value's responsibility to figure out the length.\n+    fn visit_array(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>) -> EvalResult<'tcx>;\n+    // Special handling for strings.\n+    fn visit_str(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>;\n+\n+    // Actions on the leaves.\n+    fn visit_scalar(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>, layout: &layout::Scalar)\n+        -> EvalResult<'tcx>;\n+    fn visit_primitive(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>;\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    pub fn visit_value<V: ValueVisitor<'a, 'mir, 'tcx, M>>(&mut self, v: &mut V) -> EvalResult<'tcx> {\n+        trace!(\"visit_value: {:?}\", v);\n+\n+        // If this is a multi-variant layout, we have find the right one and proceed with that.\n+        // (No benefit from making this recursion, but it is equivalent to that.)\n+        match v.layout().variants {\n+            layout::Variants::NicheFilling { .. } |\n+            layout::Variants::Tagged { .. } => {\n+                v.downcast_enum(self)?;\n+                trace!(\"variant layout: {:#?}\", v.layout());\n+            }\n+            layout::Variants::Single { .. } => {}\n+        }\n+\n+        // Even for single variants, we might be able to get a more refined type:\n+        // If it is a trait object, switch to the actual type that was used to create it.\n+        match v.layout().ty.sty {\n+            ty::Dynamic(..) => {\n+                v.downcast_dyn_trait(self)?;\n+            },\n+            _ => {},\n+        };\n+\n+        // If this is a scalar, visit it as such.\n+        // Things can be aggregates and have scalar layout at the same time, and that\n+        // is very relevant for `NonNull` and similar structs: We need to visit them\n+        // at their scalar layout *before* descending into their fields.\n+        // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n+        // scalars, we do the same check on every \"level\" (e.g. first we check\n+        // MyNewtype and then the scalar in there).\n+        match v.layout().abi {\n+            layout::Abi::Scalar(ref layout) => {\n+                v.visit_scalar(self, layout)?;\n+            }\n+            // FIXME: Should we do something for ScalarPair? Vector?\n+            _ => {}\n+        }\n+\n+        // Check primitive types.  We do this after checking the scalar layout,\n+        // just to have that done as well.  Primitives can have varying layout,\n+        // so we check them separately and before aggregate handling.\n+        // It is CRITICAL that we get this check right, or we might be\n+        // validating the wrong thing!\n+        let primitive = match v.layout().fields {\n+            // Primitives appear as Union with 0 fields -- except for Boxes and fat pointers.\n+            layout::FieldPlacement::Union(0) => true,\n+            _ => v.layout().ty.builtin_deref(true).is_some(),\n+        };\n+        if primitive {\n+            return v.visit_primitive(self);\n+        }\n+\n+        // Proceed into the fields.\n+        match v.layout().fields {\n+            layout::FieldPlacement::Union(fields) => {\n+                // Empty unions are not accepted by rustc. That's great, it means we can\n+                // use that as an unambiguous signal for detecting primitives.  Make sure\n+                // we did not miss any primitive.\n+                debug_assert!(fields > 0);\n+                // We can't traverse unions, their bits are allowed to be anything.\n+                // The fields don't need to correspond to any bit pattern of the union's fields.\n+                // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n+                Ok(())\n+            },\n+            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n+                v.visit_fields(self, offsets.len())\n+            },\n+            layout::FieldPlacement::Array { .. } => {\n+                match v.layout().ty.sty {\n+                    // Strings have properties that cannot be expressed pointwise.\n+                    ty::Str => v.visit_str(self),\n+                    // General case -- might also be SIMD vector or so\n+                    _ => v.visit_array(self),\n+                }\n+            }\n+        }\n+    }\n+}"}]}