{"sha": "1239e34261f3bfff1a42bf3a20485dbd35c61d30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMzllMzQyNjFmM2JmZmYxYTQyYmYzYTIwNDg1ZGJkMzVjNjFkMzA=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-08T22:31:08Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-10T14:24:11Z"}, "message": "Add more std::io documentation.\n\nThis round: io::Result and the free functions.", "tree": {"sha": "43f103ba38aa53436a79f12ac301b370347b2e09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43f103ba38aa53436a79f12ac301b370347b2e09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1239e34261f3bfff1a42bf3a20485dbd35c61d30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1239e34261f3bfff1a42bf3a20485dbd35c61d30", "html_url": "https://github.com/rust-lang/rust/commit/1239e34261f3bfff1a42bf3a20485dbd35c61d30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1239e34261f3bfff1a42bf3a20485dbd35c61d30/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdcce3ba4491436e6603833cee19533003993117", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdcce3ba4491436e6603833cee19533003993117", "html_url": "https://github.com/rust-lang/rust/commit/cdcce3ba4491436e6603833cee19533003993117"}], "stats": {"total": 177, "additions": 158, "deletions": 19}, "files": [{"sha": "3b48ff3096043d4dfb58443ba79c760d0571ad4a", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1239e34261f3bfff1a42bf3a20485dbd35c61d30/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1239e34261f3bfff1a42bf3a20485dbd35c61d30/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=1239e34261f3bfff1a42bf3a20485dbd35c61d30", "patch": "@@ -17,11 +17,37 @@ use option::Option::{self, Some, None};\n use result;\n use sys;\n \n-/// A type for results generated by I/O related functions where the `Err` type\n-/// is hard-wired to `io::Error`.\n+/// A specialized [`Result`][result] type for I/O operations.\n+///\n+/// [result]: ../result/enum.Result.html\n+///\n+/// This type is broadly used across `std::io` for any operation which may\n+/// produce an error.\n ///\n /// This typedef is generally used to avoid writing out `io::Error` directly and\n-/// is otherwise a direct mapping to `std::result::Result`.\n+/// is otherwise a direct mapping to `Result`.\n+///\n+/// While usual Rust style is to import types directly, aliases of `Result`\n+/// often are not, to make it easier to distinguish between them. `Result` is\n+/// generally assumed to be `std::result::Result`, and so users of this alias\n+/// will generally use `io::Result` instead of shadowing the prelude's import\n+/// of `std::result::Result`.\n+///\n+/// # Examples\n+///\n+/// A convenience function that bubbles an `io::Result` to its caller:\n+///\n+/// ```\n+/// use std::io;\n+///\n+/// fn get_string() -> io::Result<String> {\n+///     let mut buffer = String::new();\n+///\n+///     try!(io::stdin().read_line(&mut buffer));\n+///\n+///     Ok(buffer)\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type Result<T> = result::Result<T, Error>;\n "}, {"sha": "62bbb939a71f5dcd8aeddb44772e94c444bf1868", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 97, "deletions": 15, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1239e34261f3bfff1a42bf3a20485dbd35c61d30/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1239e34261f3bfff1a42bf3a20485dbd35c61d30/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=1239e34261f3bfff1a42bf3a20485dbd35c61d30", "patch": "@@ -154,15 +154,42 @@ pub struct StdinLock<'a> {\n     inner: MutexGuard<'a, BufReader<Maybe<StdinRaw>>>,\n }\n \n-/// Creates a new handle to the global standard input stream of this process.\n+/// Constructs a new handle to the standard input of the current process.\n ///\n-/// The handle returned refers to a globally shared buffer between all threads.\n-/// Access is synchronized and can be explicitly controlled with the `lock()`\n-/// method.\n+/// Each handle returned is a reference to a shared global buffer whose access\n+/// is synchronized via a mutex. If you need more explicit control over\n+/// locking, see the [lock() method][lock].\n+///\n+/// [lock]: struct.Stdin.html#method.lock\n+///\n+/// # Examples\n+///\n+/// Using implicit synchronization:\n+///\n+/// ```\n+/// use std::io::{self, Read};\n+///\n+/// # fn foo() -> io::Result<String> {\n+/// let mut buffer = String::new();\n+/// try!(io::stdin().read_to_string(&mut buffer));\n+/// # Ok(buffer)\n+/// # }\n+/// ```\n+///\n+/// Using explicit synchronization:\n ///\n-/// The `Read` trait is implemented for the returned value but the `BufRead`\n-/// trait is not due to the global nature of the standard input stream. The\n-/// locked version, `StdinLock`, implements both `Read` and `BufRead`, however.\n+/// ```\n+/// use std::io::{self, Read};\n+///\n+/// # fn foo() -> io::Result<String> {\n+/// let mut buffer = String::new();\n+/// let stdin = io::stdin();\n+/// let mut handle = stdin.lock();\n+///\n+/// try!(handle.read_to_string(&mut buffer));\n+/// # Ok(buffer)\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdin() -> Stdin {\n     static INSTANCE: Lazy<Mutex<BufReader<Maybe<StdinRaw>>>> = Lazy::new(stdin_init);\n@@ -298,13 +325,42 @@ pub struct StdoutLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<LineWriter<Maybe<StdoutRaw>>>>,\n }\n \n-/// Constructs a new reference to the standard output of the current process.\n+/// Constructs a new handle to the standard output of the current process.\n ///\n /// Each handle returned is a reference to a shared global buffer whose access\n-/// is synchronized via a mutex. Explicit control over synchronization is\n-/// provided via the `lock` method.\n+/// is synchronized via a mutex. If you need more explicit control over\n+/// locking, see the [lock() method][lock].\n+///\n+/// [lock]: struct.Stdout.html#method.lock\n+///\n+/// # Examples\n+///\n+/// Using implicit synchronization:\n+///\n+/// ```\n+/// use std::io::{self, Write};\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// try!(io::stdout().write(b\"hello world\"));\n ///\n-/// The returned handle implements the `Write` trait.\n+/// # Ok(())\n+/// # }\n+/// ```\n+///\n+/// Using explicit synchronization:\n+///\n+/// ```\n+/// use std::io::{self, Write};\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// let stdout = io::stdout();\n+/// let mut handle = stdout.lock();\n+///\n+/// try!(handle.write(b\"hello world\"));\n+///\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n     static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>>\n@@ -376,12 +432,38 @@ pub struct StderrLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<Maybe<StderrRaw>>>,\n }\n \n-/// Constructs a new reference to the standard error stream of a process.\n+/// Constructs a new handle to the standard error of the current process.\n+///\n+/// This handle is not buffered.\n+///\n+/// # Examples\n+///\n+/// Using implicit synchronization:\n+///\n+/// ```\n+/// use std::io::{self, Write};\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// try!(io::stderr().write(b\"hello world\"));\n+///\n+/// # Ok(())\n+/// # }\n+/// ```\n+///\n+/// Using explicit synchronization:\n+///\n+/// ```\n+/// use std::io::{self, Write};\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// let stderr = io::stderr();\n+/// let mut handle = stderr.lock();\n ///\n-/// Each returned handle is synchronized amongst all other handles created from\n-/// this function. No handles are buffered, however.\n+/// try!(handle.write(b\"hello world\"));\n ///\n-/// The returned handle implements the `Write` trait.\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n     static INSTANCE: Lazy<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> = Lazy::new(stderr_init);"}, {"sha": "c0bced26beffafce9c5c78483aaaa3c2efaf0fe1", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1239e34261f3bfff1a42bf3a20485dbd35c61d30/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1239e34261f3bfff1a42bf3a20485dbd35c61d30/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=1239e34261f3bfff1a42bf3a20485dbd35c61d30", "patch": "@@ -28,6 +28,22 @@ use io::{self, Read, Write, ErrorKind, BufRead};\n /// This function will return an error immediately if any call to `read` or\n /// `write` returns an error. All instances of `ErrorKind::Interrupted` are\n /// handled by this function and the underlying operation is retried.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::io;\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// let mut reader: &[u8] = b\"hello\";\n+/// let mut writer: Vec<u8> = vec![];\n+///\n+/// try!(io::copy(&mut reader, &mut writer));\n+///\n+/// assert_eq!(reader, &writer[..]);\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn copy<R: Read, W: Write>(reader: &mut R, writer: &mut W) -> io::Result<u64> {\n     let mut buf = [0; super::DEFAULT_BUF_SIZE];\n@@ -48,9 +64,24 @@ pub fn copy<R: Read, W: Write>(reader: &mut R, writer: &mut W) -> io::Result<u64\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Empty { _priv: () }\n \n-/// Creates an instance of an empty reader.\n+/// Constructs a new handle to an empty reader.\n ///\n /// All reads from the returned reader will return `Ok(0)`.\n+///\n+/// # Examples\n+///\n+/// A slightly sad example of not reading anything into a buffer:\n+///\n+/// ```\n+/// use std::io;\n+/// use std::io::Read;\n+///\n+/// # fn foo() -> io::Result<String> {\n+/// let mut buffer = String::new();\n+/// try!(io::empty().read_to_string(&mut buffer));\n+/// # Ok(buffer)\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn empty() -> Empty { Empty { _priv: () } }\n "}]}