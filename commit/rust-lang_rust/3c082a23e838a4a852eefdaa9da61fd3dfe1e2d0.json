{"sha": "3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMDgyYTIzZTgzOGE0YTg1MmVlZmRhYTlkYTYxZmQzZGZlMWUyZDA=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-09-10T14:28:47Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "Added StaticMethods trait", "tree": {"sha": "c56c08b3f0c17d474d39882a3cdac849af087dbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c56c08b3f0c17d474d39882a3cdac849af087dbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "html_url": "https://github.com/rust-lang/rust/commit/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d77e34f35ba276b514459b1669818605c9fbf416", "url": "https://api.github.com/repos/rust-lang/rust/commits/d77e34f35ba276b514459b1669818605c9fbf416", "html_url": "https://github.com/rust-lang/rust/commit/d77e34f35ba276b514459b1669818605c9fbf416"}], "stats": {"total": 733, "additions": 390, "deletions": 343}, "files": [{"sha": "83036e65ba3ed37662880b029d2b9ae6d882c970", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 316, "deletions": 308, "changes": 624, "blob_url": "https://github.com/rust-lang/rust/blob/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "patch": "@@ -24,25 +24,14 @@ use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n use rustc::ty::{self, Ty};\n-use interfaces::{BaseTypeMethods, DerivedTypeMethods};\n+use interfaces::{BaseTypeMethods, DerivedTypeMethods, StaticMethods};\n \n use rustc::ty::layout::{Align, LayoutOf};\n \n use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n \n use std::ffi::{CStr, CString};\n \n-pub fn ptrcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstPointerCast(val, ty)\n-    }\n-}\n-\n-pub fn bitcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstBitCast(val, ty)\n-    }\n-}\n \n fn set_global_alignment(cx: &CodegenCx<'ll, '_>,\n                         gv: &'ll Value,\n@@ -63,178 +52,6 @@ fn set_global_alignment(cx: &CodegenCx<'ll, '_>,\n     }\n }\n \n-pub fn addr_of_mut(\n-    cx: &CodegenCx<'ll, '_>,\n-    cv: &'ll Value,\n-    align: Align,\n-    kind: Option<&str>,\n-) -> &'ll Value {\n-    unsafe {\n-        let gv = match kind {\n-            Some(kind) if !cx.tcx.sess.fewer_names() => {\n-                let name = cx.generate_local_symbol_name(kind);\n-                let gv = declare::define_global(cx, &name[..],\n-                    cx.val_ty(cv)).unwrap_or_else(||{\n-                        bug!(\"symbol `{}` is already defined\", name);\n-                });\n-                llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n-                gv\n-            },\n-            _ => declare::define_private_global(cx, cx.val_ty(cv)),\n-        };\n-        llvm::LLVMSetInitializer(gv, cv);\n-        set_global_alignment(cx, gv, align);\n-        SetUnnamedAddr(gv, true);\n-        gv\n-    }\n-}\n-\n-pub fn addr_of(\n-    cx: &CodegenCx<'ll, '_>,\n-    cv: &'ll Value,\n-    align: Align,\n-    kind: Option<&str>,\n-) -> &'ll Value {\n-    if let Some(&gv) = cx.const_globals.borrow().get(&cv) {\n-        unsafe {\n-            // Upgrade the alignment in cases where the same constant is used with different\n-            // alignment requirements\n-            let llalign = align.abi() as u32;\n-            if llalign > llvm::LLVMGetAlignment(gv) {\n-                llvm::LLVMSetAlignment(gv, llalign);\n-            }\n-        }\n-        return gv;\n-    }\n-    let gv = addr_of_mut(cx, cv, align, kind);\n-    unsafe {\n-        llvm::LLVMSetGlobalConstant(gv, True);\n-    }\n-    cx.const_globals.borrow_mut().insert(cv, gv);\n-    gv\n-}\n-\n-pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n-    let instance = Instance::mono(cx.tcx, def_id);\n-    if let Some(&g) = cx.instances.borrow().get(&instance) {\n-        return g;\n-    }\n-\n-    let defined_in_current_codegen_unit = cx.codegen_unit\n-                                            .items()\n-                                            .contains_key(&MonoItem::Static(def_id));\n-    assert!(!defined_in_current_codegen_unit,\n-            \"consts::get_static() should always hit the cache for \\\n-             statics defined in the same CGU, but did not for `{:?}`\",\n-            def_id);\n-\n-    let ty = instance.ty(cx.tcx);\n-    let sym = cx.tcx.symbol_name(instance).as_str();\n-\n-    debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n-\n-    let g = if let Some(id) = cx.tcx.hir.as_local_node_id(def_id) {\n-\n-        let llty = cx.layout_of(ty).llvm_type(cx);\n-        let (g, attrs) = match cx.tcx.hir.get(id) {\n-            Node::Item(&hir::Item {\n-                ref attrs, span, node: hir::ItemKind::Static(..), ..\n-            }) => {\n-                if declare::get_declared_value(cx, &sym[..]).is_some() {\n-                    span_bug!(span, \"Conflicting symbol names for static?\");\n-                }\n-\n-                let g = declare::define_global(cx, &sym[..], llty).unwrap();\n-\n-                if !cx.tcx.is_reachable_non_generic(def_id) {\n-                    unsafe {\n-                        llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n-                    }\n-                }\n-\n-                (g, attrs)\n-            }\n-\n-            Node::ForeignItem(&hir::ForeignItem {\n-                ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n-            }) => {\n-                let fn_attrs = cx.tcx.codegen_fn_attrs(def_id);\n-                (check_and_apply_linkage(cx, &fn_attrs, ty, sym, Some(span)), attrs)\n-            }\n-\n-            item => bug!(\"get_static: expected static, found {:?}\", item)\n-        };\n-\n-        debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n-\n-        for attr in attrs {\n-            if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local_mode(g, cx.tls_model);\n-            }\n-        }\n-\n-        g\n-    } else {\n-        // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-        debug!(\"get_static: sym={} item_attr={:?}\", sym, cx.tcx.item_attrs(def_id));\n-\n-        let attrs = cx.tcx.codegen_fn_attrs(def_id);\n-        let g = check_and_apply_linkage(cx, &attrs, ty, sym, None);\n-\n-        // Thread-local statics in some other crate need to *always* be linked\n-        // against in a thread-local fashion, so we need to be sure to apply the\n-        // thread-local attribute locally if it was present remotely. If we\n-        // don't do this then linker errors can be generated where the linker\n-        // complains that one object files has a thread local version of the\n-        // symbol and another one doesn't.\n-        if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n-            llvm::set_thread_local_mode(g, cx.tls_model);\n-        }\n-\n-        let needs_dll_storage_attr =\n-            cx.use_dll_storage_attrs && !cx.tcx.is_foreign_item(def_id) &&\n-            // ThinLTO can't handle this workaround in all cases, so we don't\n-            // emit the attrs. Instead we make them unnecessary by disallowing\n-            // dynamic linking when cross-language LTO is enabled.\n-            !cx.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled();\n-\n-        // If this assertion triggers, there's something wrong with commandline\n-        // argument validation.\n-        debug_assert!(!(cx.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled() &&\n-                        cx.tcx.sess.target.target.options.is_like_msvc &&\n-                        cx.tcx.sess.opts.cg.prefer_dynamic));\n-\n-        if needs_dll_storage_attr {\n-            // This item is external but not foreign, i.e. it originates from an external Rust\n-            // crate. Since we don't know whether this crate will be linked dynamically or\n-            // statically in the final application, we always mark such symbols as 'dllimport'.\n-            // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs to\n-            // make things work.\n-            //\n-            // However, in some scenarios we defer emission of statics to downstream\n-            // crates, so there are cases where a static with an upstream DefId\n-            // is actually present in the current crate. We can find out via the\n-            // is_codegened_item query.\n-            if !cx.tcx.is_codegened_item(def_id) {\n-                unsafe {\n-                    llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n-                }\n-            }\n-        }\n-        g\n-    };\n-\n-    if cx.use_dll_storage_attrs && cx.tcx.is_dllimport_foreign_item(def_id) {\n-        // For foreign (native) libs we know the exact storage type to use.\n-        unsafe {\n-            llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n-        }\n-    }\n-\n-    cx.instances.borrow_mut().insert(instance, g);\n-    g\n-}\n-\n fn check_and_apply_linkage(\n     cx: &CodegenCx<'ll, 'tcx>,\n     attrs: &CodegenFnAttrs,\n@@ -294,146 +111,337 @@ fn check_and_apply_linkage(\n     }\n }\n \n-pub fn codegen_static<'a, 'tcx>(\n-    cx: &CodegenCx<'a, 'tcx>,\n-    def_id: DefId,\n-    is_mutable: bool,\n-) {\n+pub fn ptrcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n     unsafe {\n-        let attrs = cx.tcx.codegen_fn_attrs(def_id);\n+        llvm::LLVMConstPointerCast(val, ty)\n+    }\n+}\n \n-        let (v, alloc) = match ::mir::codegen_static_initializer(cx, def_id) {\n-            Ok(v) => v,\n-            // Error has already been reported\n-            Err(_) => return,\n-        };\n+impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n-        let g = get_static(cx, def_id);\n+    fn static_ptrcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        ptrcast(val, ty)\n+    }\n \n-        // boolean SSA values are i1, but they have to be stored in i8 slots,\n-        // otherwise some LLVM optimization passes don't work as expected\n-        let mut val_llty = cx.val_ty(v);\n-        let v = if val_llty == cx.type_i1() {\n-            val_llty = cx.type_i8();\n-            llvm::LLVMConstZExt(v, val_llty)\n-        } else {\n-            v\n-        };\n+    fn static_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMConstBitCast(val, ty)\n+        }\n+    }\n+\n+    fn static_addr_of_mut(\n+        &self,\n+        cv: &'ll Value,\n+        align: Align,\n+        kind: Option<&str>,\n+    ) -> &'ll Value {\n+        unsafe {\n+            let gv = match kind {\n+                Some(kind) if !&self.tcx.sess.fewer_names() => {\n+                    let name = &self.generate_local_symbol_name(kind);\n+                    let gv = declare::define_global(&self, &name[..],\n+                        &self.val_ty(cv)).unwrap_or_else(||{\n+                            bug!(\"symbol `{}` is already defined\", name);\n+                    });\n+                    llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n+                    gv\n+                },\n+                _ => declare::define_private_global(&self, &self.val_ty(cv)),\n+            };\n+            llvm::LLVMSetInitializer(gv, cv);\n+            set_global_alignment(&self, gv, align);\n+            SetUnnamedAddr(gv, true);\n+            gv\n+        }\n+    }\n+\n+    fn static_addr_of(\n+        &self,\n+        cv: &'ll Value,\n+        align: Align,\n+        kind: Option<&str>,\n+    ) -> &'ll Value {\n+        if let Some(&gv) = &self.const_globals.borrow().get(&cv) {\n+            unsafe {\n+                // Upgrade the alignment in cases where the same constant is used with different\n+                // alignment requirements\n+                let llalign = align.abi() as u32;\n+                if llalign > llvm::LLVMGetAlignment(gv) {\n+                    llvm::LLVMSetAlignment(gv, llalign);\n+                }\n+            }\n+            return gv;\n+        }\n+        let gv = &self.static_addr_of_mut(cv, align, kind);\n+        unsafe {\n+            llvm::LLVMSetGlobalConstant(gv, True);\n+        }\n+        &self.const_globals.borrow_mut().insert(cv, gv);\n+        gv\n+    }\n+\n+    fn get_static(&self, def_id: DefId) -> &'ll Value {\n+        let instance = Instance::mono(self.tcx, def_id);\n+        if let Some(&g) = &self.instances.borrow().get(&instance) {\n+            return g;\n+        }\n+\n+        let defined_in_current_codegen_unit = &self.codegen_unit\n+                                                .items()\n+                                                .contains_key(&MonoItem::Static(def_id));\n+        assert!(!defined_in_current_codegen_unit,\n+                \"consts::get_static() should always hit the cache for \\\n+                 statics defined in the same CGU, but did not for `{:?}`\",\n+                 def_id);\n+\n+        let ty = instance.ty(self.tcx);\n+        let sym = self.tcx.symbol_name(instance).as_str();\n+\n+        debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n+\n+        let g = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+\n+            let llty = &self.layout_of(ty).llvm_type(&self);\n+            let (g, attrs) = match &self.tcx.hir.get(id) {\n+                Node::Item(&hir::Item {\n+                    ref attrs, span, node: hir::ItemKind::Static(..), ..\n+                }) => {\n+                    if declare::get_declared_value(&self, &sym[..]).is_some() {\n+                        span_bug!(span, \"Conflicting symbol names for static?\");\n+                    }\n+\n+                    let g = declare::define_global(&self, &sym[..], llty).unwrap();\n+\n+                    if !&self.tcx.is_reachable_non_generic(def_id) {\n+                        unsafe {\n+                            llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n+                        }\n+                    }\n+\n+                    (g, attrs)\n+                }\n+\n+                Node::ForeignItem(&hir::ForeignItem {\n+                    ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n+                }) => {\n+                    let fn_attrs = &self.tcx.codegen_fn_attrs(def_id);\n+                    (check_and_apply_linkage(&self, &fn_attrs, ty, sym, Some(span)), attrs)\n+                }\n+\n+                item => bug!(\"get_static: expected static, found {:?}\", item)\n+            };\n+\n+            debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n+\n+            for attr in attrs {\n+                if attr.check_name(\"thread_local\") {\n+                    llvm::set_thread_local_mode(g, self.tls_model);\n+                }\n+            }\n \n-        let instance = Instance::mono(cx.tcx, def_id);\n-        let ty = instance.ty(cx.tcx);\n-        let llty = cx.layout_of(ty).llvm_type(cx);\n-        let g = if val_llty == llty {\n             g\n         } else {\n-            // If we created the global with the wrong type,\n-            // correct the type.\n-            let empty_string = const_cstr!(\"\");\n-            let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n-            let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n-            llvm::LLVMSetValueName(g, empty_string.as_ptr());\n-\n-            let linkage = llvm::LLVMRustGetLinkage(g);\n-            let visibility = llvm::LLVMRustGetVisibility(g);\n-\n-            let new_g = llvm::LLVMRustGetOrInsertGlobal(\n-                cx.llmod, name_string.as_ptr(), val_llty);\n-\n-            llvm::LLVMRustSetLinkage(new_g, linkage);\n-            llvm::LLVMRustSetVisibility(new_g, visibility);\n-\n-            // To avoid breaking any invariants, we leave around the old\n-            // global for the moment; we'll replace all references to it\n-            // with the new global later. (See base::codegen_backend.)\n-            cx.statics_to_rauw.borrow_mut().push((g, new_g));\n-            new_g\n+            // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n+            debug!(\"get_static: sym={} item_attr={:?}\", sym, &self.tcx.item_attrs(def_id));\n+\n+            let attrs = &self.tcx.codegen_fn_attrs(def_id);\n+            let g = check_and_apply_linkage(&self, &attrs, ty, sym, None);\n+\n+            // Thread-local statics in some other crate need to *always* be linked\n+            // against in a thread-local fashion, so we need to be sure to apply the\n+            // thread-local attribute locally if it was present remotely. If we\n+            // don't do this then linker errors can be generated where the linker\n+            // complains that one object files has a thread local version of the\n+            // symbol and another one doesn't.\n+            if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n+                llvm::set_thread_local_mode(g, self.tls_model);\n+            }\n+\n+            let needs_dll_storage_attr =\n+                self.use_dll_storage_attrs && !&self.tcx.is_foreign_item(def_id) &&\n+                // ThinLTO can't handle this workaround in all cases, so we don't\n+                // emit the attrs. Instead we make them unnecessary by disallowing\n+                // dynamic linking when cross-language LTO is enabled.\n+                !&self.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled();\n+\n+            // If this assertion triggers, there's something wrong with commandline\n+            // argument validation.\n+            debug_assert!(!(self.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled() &&\n+                            self.tcx.sess.target.target.options.is_like_msvc &&\n+                            self.tcx.sess.opts.cg.prefer_dynamic));\n+\n+            if needs_dll_storage_attr {\n+                // This item is external but not foreign, i.e. it originates from an external Rust\n+                // crate. Since we don't know whether this crate will be linked dynamically or\n+                // statically in the final application, we always mark such symbols as 'dllimport'.\n+                // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n+                // to make things work.\n+                //\n+                // However, in some scenarios we defer emission of statics to downstream\n+                // crates, so there are cases where a static with an upstream DefId\n+                // is actually present in the current crate. We can find out via the\n+                // is_codegened_item query.\n+                if !&self.tcx.is_codegened_item(def_id) {\n+                    unsafe {\n+                        llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+                    }\n+                }\n+            }\n+            g\n         };\n-        set_global_alignment(cx, g, cx.align_of(ty));\n-        llvm::LLVMSetInitializer(g, v);\n-\n-        // As an optimization, all shared statics which do not have interior\n-        // mutability are placed into read-only memory.\n-        if !is_mutable {\n-            if cx.type_is_freeze(ty) {\n-                llvm::LLVMSetGlobalConstant(g, llvm::True);\n+\n+        if self.use_dll_storage_attrs && self.tcx.is_dllimport_foreign_item(def_id) {\n+            // For foreign (native) libs we know the exact storage type to use.\n+            unsafe {\n+                llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n             }\n         }\n \n-        debuginfo::create_global_var_metadata(cx, def_id, g);\n-\n-        if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n-            llvm::set_thread_local_mode(g, cx.tls_model);\n-\n-            // Do not allow LLVM to change the alignment of a TLS on macOS.\n-            //\n-            // By default a global's alignment can be freely increased.\n-            // This allows LLVM to generate more performant instructions\n-            // e.g. using load-aligned into a SIMD register.\n-            //\n-            // However, on macOS 10.10 or below, the dynamic linker does not\n-            // respect any alignment given on the TLS (radar 24221680).\n-            // This will violate the alignment assumption, and causing segfault at runtime.\n-            //\n-            // This bug is very easy to trigger. In `println!` and `panic!`,\n-            // the `LOCAL_STDOUT`/`LOCAL_STDERR` handles are stored in a TLS,\n-            // which the values would be `mem::replace`d on initialization.\n-            // The implementation of `mem::replace` will use SIMD\n-            // whenever the size is 32 bytes or higher. LLVM notices SIMD is used\n-            // and tries to align `LOCAL_STDOUT`/`LOCAL_STDERR` to a 32-byte boundary,\n-            // which macOS's dyld disregarded and causing crashes\n-            // (see issues #51794, #51758, #50867, #48866 and #44056).\n-            //\n-            // To workaround the bug, we trick LLVM into not increasing\n-            // the global's alignment by explicitly assigning a section to it\n-            // (equivalent to automatically generating a `#[link_section]` attribute).\n-            // See the comment in the `GlobalValue::canIncreaseAlignment()` function\n-            // of `lib/IR/Globals.cpp` for why this works.\n-            //\n-            // When the alignment is not increased, the optimized `mem::replace`\n-            // will use load-unaligned instructions instead, and thus avoiding the crash.\n-            //\n-            // We could remove this hack whenever we decide to drop macOS 10.10 support.\n-            if cx.tcx.sess.target.target.options.is_like_osx {\n-                let sect_name = if alloc.bytes.iter().all(|b| *b == 0) {\n-                    CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n-                } else {\n-                    CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")\n-                };\n-                llvm::LLVMSetSection(g, sect_name.as_ptr());\n+        &self.instances.borrow_mut().insert(instance, g);\n+        g\n+    }\n+\n+    fn codegen_static(\n+        &self,\n+        def_id: DefId,\n+        is_mutable: bool,\n+    ) {\n+        unsafe {\n+            let attrs = &self.tcx.codegen_fn_attrs(def_id);\n+\n+            let (v, alloc) = match ::mir::codegen_static_initializer(&self, def_id) {\n+                Ok(v) => v,\n+                // Error has already been reported\n+                Err(_) => return,\n+            };\n+\n+            let g = &self.get_static(def_id);\n+\n+            // boolean SSA values are i1, but they have to be stored in i8 slots,\n+            // otherwise some LLVM optimization passes don't work as expected\n+            let mut val_llty = self.val_ty(v);\n+            let v = if val_llty == self.type_i1() {\n+                val_llty = self.type_i8();\n+                llvm::LLVMConstZExt(v, val_llty)\n+            } else {\n+                v\n+            };\n+\n+            let instance = Instance::mono(self.tcx, def_id);\n+            let ty = instance.ty(self.tcx);\n+            let llty = self.layout_of(ty).llvm_type(&self);\n+            let g = if val_llty == llty {\n+                g\n+            } else {\n+                // If we created the global with the wrong type,\n+                // correct the type.\n+                let empty_string = const_cstr!(\"\");\n+                let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n+                let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n+                llvm::LLVMSetValueName(g, empty_string.as_ptr());\n+\n+                let linkage = llvm::LLVMRustGetLinkage(g);\n+                let visibility = llvm::LLVMRustGetVisibility(g);\n+\n+                let new_g = llvm::LLVMRustGetOrInsertGlobal(\n+                    &self.llmod, name_string.as_ptr(), val_llty);\n+\n+                llvm::LLVMRustSetLinkage(new_g, linkage);\n+                llvm::LLVMRustSetVisibility(new_g, visibility);\n+\n+                // To avoid breaking any invariants, we leave around the old\n+                // global for the moment; we'll replace all references to it\n+                // with the new global later. (See base::codegen_backend.)\n+                &self.statics_to_rauw.borrow_mut().push((g, new_g));\n+                new_g\n+            };\n+            set_global_alignment(&self, g, self.align_of(ty));\n+            llvm::LLVMSetInitializer(g, v);\n+\n+            // As an optimization, all shared statics which do not have interior\n+            // mutability are placed into read-only memory.\n+            if !is_mutable {\n+                if self.type_is_freeze(ty) {\n+                    llvm::LLVMSetGlobalConstant(g, llvm::True);\n+                }\n             }\n-        }\n \n+            debuginfo::create_global_var_metadata(&self, def_id, g);\n+\n+            if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n+                llvm::set_thread_local_mode(g, self.tls_model);\n+\n+                // Do not allow LLVM to change the alignment of a TLS on macOS.\n+                //\n+                // By default a global's alignment can be freely increased.\n+                // This allows LLVM to generate more performant instructions\n+                // e.g. using load-aligned into a SIMD register.\n+                //\n+                // However, on macOS 10.10 or below, the dynamic linker does not\n+                // respect any alignment given on the TLS (radar 24221680).\n+                // This will violate the alignment assumption, and causing segfault at runtime.\n+                //\n+                // This bug is very easy to trigger. In `println!` and `panic!`,\n+                // the `LOCAL_STDOUT`/`LOCAL_STDERR` handles are stored in a TLS,\n+                // which the values would be `mem::replace`d on initialization.\n+                // The implementation of `mem::replace` will use SIMD\n+                // whenever the size is 32 bytes or higher. LLVM notices SIMD is used\n+                // and tries to align `LOCAL_STDOUT`/`LOCAL_STDERR` to a 32-byte boundary,\n+                // which macOS's dyld disregarded and causing crashes\n+                // (see issues #51794, #51758, #50867, #48866 and #44056).\n+                //\n+                // To workaround the bug, we trick LLVM into not increasing\n+                // the global's alignment by explicitly assigning a section to it\n+                // (equivalent to automatically generating a `#[link_section]` attribute).\n+                // See the comment in the `GlobalValue::canIncreaseAlignment()` function\n+                // of `lib/IR/Globals.cpp` for why this works.\n+                //\n+                // When the alignment is not increased, the optimized `mem::replace`\n+                // will use load-unaligned instructions instead, and thus avoiding the crash.\n+                //\n+                // We could remove this hack whenever we decide to drop macOS 10.10 support.\n+                if self.tcx.sess.target.target.options.is_like_osx {\n+                    let sect_name = if alloc.bytes.iter().all(|b| *b == 0) {\n+                        CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n+                    } else {\n+                        CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")\n+                    };\n+                    llvm::LLVMSetSection(g, sect_name.as_ptr());\n+                }\n+            }\n \n-        // Wasm statics with custom link sections get special treatment as they\n-        // go into custom sections of the wasm executable.\n-        if cx.tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n-            if let Some(section) = attrs.link_section {\n-                let section = llvm::LLVMMDStringInContext(\n-                    cx.llcx,\n-                    section.as_str().as_ptr() as *const _,\n-                    section.as_str().len() as c_uint,\n-                );\n-                let alloc = llvm::LLVMMDStringInContext(\n-                    cx.llcx,\n-                    alloc.bytes.as_ptr() as *const _,\n-                    alloc.bytes.len() as c_uint,\n-                );\n-                let data = [section, alloc];\n-                let meta = llvm::LLVMMDNodeInContext(cx.llcx, data.as_ptr(), 2);\n-                llvm::LLVMAddNamedMetadataOperand(\n-                    cx.llmod,\n-                    \"wasm.custom_sections\\0\".as_ptr() as *const _,\n-                    meta,\n-                );\n+\n+            // Wasm statics with custom link sections get special treatment as they\n+            // go into custom sections of the wasm executable.\n+            if self.tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n+                if let Some(section) = attrs.link_section {\n+                    let section = llvm::LLVMMDStringInContext(\n+                        &self.llcx,\n+                        section.as_str().as_ptr() as *const _,\n+                        section.as_str().len() as c_uint,\n+                    );\n+                    let alloc = llvm::LLVMMDStringInContext(\n+                        &self.llcx,\n+                        alloc.bytes.as_ptr() as *const _,\n+                        alloc.bytes.len() as c_uint,\n+                    );\n+                    let data = [section, alloc];\n+                    let meta = llvm::LLVMMDNodeInContext(&self.llcx, data.as_ptr(), 2);\n+                    llvm::LLVMAddNamedMetadataOperand(\n+                        &self.llmod,\n+                        \"wasm.custom_sections\\0\".as_ptr() as *const _,\n+                        meta,\n+                    );\n+                }\n+            } else {\n+                base::set_link_section(g, &attrs);\n             }\n-        } else {\n-            base::set_link_section(g, &attrs);\n-        }\n \n-        if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n-            // This static will be stored in the llvm.used variable which is an array of i8*\n-            let cast = llvm::LLVMConstPointerCast(g, cx.type_i8p());\n-            cx.used_statics.borrow_mut().push(cast);\n+            if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n+                // This static will be stored in the llvm.used variable which is an array of i8*\n+                let cast = llvm::LLVMConstPointerCast(g, &self.type_i8p());\n+                &self.used_statics.borrow_mut().push(cast);\n+            }\n         }\n     }\n }"}, {"sha": "24cae1e941e5c9c763293ed3635b0d42408b0f93", "filename": "src/librustc_codegen_llvm/interfaces/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs?ref=3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "patch": "@@ -13,9 +13,11 @@ mod backend;\n mod consts;\n mod type_;\n mod intrinsic;\n+mod statics;\n \n pub use self::builder::BuilderMethods;\n pub use self::backend::Backend;\n pub use self::consts::ConstMethods;\n pub use self::type_::{TypeMethods, BaseTypeMethods, DerivedTypeMethods};\n pub use self::intrinsic::{IntrinsicMethods, BaseIntrinsicMethods, DerivedIntrinsicMethods};\n+pub use self::statics::StaticMethods;"}, {"sha": "109ef91dcfa4a09cd56fa0a2aaa873c8129c6f0c", "filename": "src/librustc_codegen_llvm/interfaces/statics.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fstatics.rs?ref=3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::layout::Align;\n+use rustc::hir::def_id::DefId;\n+use super::backend::Backend;\n+\n+pub trait StaticMethods<'tcx>: Backend {\n+    fn static_ptrcast(&self, val: Self::Value, ty: Self::Type) -> Self::Value;\n+    fn static_bitcast(&self, val: Self::Value, ty: Self::Type) -> Self::Value;\n+    fn static_addr_of_mut(\n+        &self,\n+        cv: Self::Value,\n+        align: Align,\n+        kind: Option<&str>,\n+    ) -> Self::Value;\n+    fn static_addr_of(\n+        &self,\n+        cv: Self::Value,\n+        align: Align,\n+        kind: Option<&str>,\n+    ) -> Self::Value;\n+    fn get_static(&self, def_id: DefId) -> Self::Value;\n+    fn codegen_static(\n+        &self,\n+        def_id: DefId,\n+        is_mutable: bool,\n+    );\n+}"}, {"sha": "af433d2ba7823140a71f872f8b425e195c32c07f", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "patch": "@@ -34,6 +34,7 @@ use value::Value;\n \n use interfaces::{\n     BuilderMethods, ConstMethods, BaseTypeMethods, DerivedTypeMethods, DerivedIntrinsicMethods,\n+    StaticMethods,\n };\n \n use rustc::session::Session;\n@@ -853,7 +854,7 @@ fn codegen_msvc_try(\n \n         let tcx = cx.tcx;\n         let tydesc = match tcx.lang_items().msvc_try_filter() {\n-            Some(did) => ::consts::get_static(cx, did),\n+            Some(did) => cx.get_static(did),\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n         let tok = catchpad.catch_pad(cs, &[tydesc, cx.const_i32(0), slot]);"}, {"sha": "2eed9273cad1cd0914ef70c2fc73afebd1c7ec05", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "patch": "@@ -12,11 +12,10 @@ use abi::{FnType, FnTypeExt};\n use callee;\n use context::CodegenCx;\n use builder::Builder;\n-use consts;\n use monomorphize;\n use value::Value;\n \n-use interfaces::{BuilderMethods, ConstMethods, BaseTypeMethods, DerivedTypeMethods};\n+use interfaces::{BuilderMethods, ConstMethods, BaseTypeMethods, DerivedTypeMethods, StaticMethods};\n \n use rustc::ty::{self, Ty};\n use rustc::ty::layout::HasDataLayout;\n@@ -120,7 +119,7 @@ pub fn get_vtable(\n \n     let vtable_const = cx.const_struct(&components, false);\n     let align = cx.data_layout().pointer_align;\n-    let vtable = consts::addr_of(cx, vtable_const, align, Some(\"vtable\"));\n+    let vtable = cx.static_addr_of(vtable_const, align, Some(\"vtable\"));\n \n     debuginfo::create_vtable_metadata(cx, ty, vtable);\n "}, {"sha": "c5e3ad54ef3a7b1e4c7bfe8cbec7ab50a9cea212", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "patch": "@@ -19,7 +19,6 @@ use base;\n use callee;\n use builder::{Builder, MemFlags};\n use common::{self, IntPredicate};\n-use consts;\n use meth;\n use monomorphize;\n use type_of::LayoutLlvmExt;\n@@ -28,6 +27,7 @@ use value::Value;\n \n use interfaces::{\n     BuilderMethods, ConstMethods, BaseTypeMethods, DerivedTypeMethods, DerivedIntrinsicMethods,\n+    StaticMethods,\n };\n \n use syntax::symbol::Symbol;\n@@ -380,10 +380,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         let index = self.codegen_operand(&mut bx, index).immediate();\n \n                         let file_line_col = bx.cx().const_struct(&[filename, line, col], false);\n-                        let file_line_col = consts::addr_of(bx.cx(),\n-                                                            file_line_col,\n-                                                            align,\n-                                                            Some(\"panic_bounds_check_loc\"));\n+                        let file_line_col = bx.cx().static_addr_of(\n+                            file_line_col,\n+                            align,\n+                            Some(\"panic_bounds_check_loc\")\n+                        );\n                         (lang_items::PanicBoundsCheckFnLangItem,\n                          vec![file_line_col, index, len])\n                     }\n@@ -395,10 +396,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                             &[msg_str, filename, line, col],\n                             false\n                         );\n-                        let msg_file_line_col = consts::addr_of(bx.cx(),\n-                                                                msg_file_line_col,\n-                                                                align,\n-                                                                Some(\"panic_loc\"));\n+                        let msg_file_line_col = bx.cx().static_addr_of(\n+                            msg_file_line_col,\n+                            align,\n+                            Some(\"panic_loc\")\n+                        );\n                         (lang_items::PanicFnLangItem,\n                          vec![msg_file_line_col])\n                     }\n@@ -518,10 +520,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         &[msg_str, filename, line, col],\n                         false,\n                     );\n-                    let msg_file_line_col = consts::addr_of(bx.cx,\n-                                                            msg_file_line_col,\n-                                                            align,\n-                                                            Some(\"panic_loc\"));\n+                    let msg_file_line_col = bx.cx.static_addr_of(\n+                        msg_file_line_col,\n+                        align,\n+                        Some(\"panic_loc\"),\n+                    );\n \n                     // Obtain the panic entry point.\n                     let def_id ="}, {"sha": "d448ca1735b734026cf312b11856667fac13d6bc", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "patch": "@@ -19,13 +19,12 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size};\n use builder::Builder;\n use common::{CodegenCx};\n-use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n use value::Value;\n-use interfaces::{BuilderMethods, ConstMethods, BaseTypeMethods, DerivedTypeMethods};\n+use interfaces::{BuilderMethods, ConstMethods, BaseTypeMethods, DerivedTypeMethods, StaticMethods};\n \n use super::super::callee;\n use super::FunctionCx;\n@@ -48,7 +47,7 @@ pub fn scalar_to_llvm(\n             if layout.value == layout::Pointer {\n                 unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n             } else {\n-                consts::bitcast(llval, llty)\n+                cx.static_bitcast(llval, llty)\n             }\n         },\n         Scalar::Ptr(ptr) => {\n@@ -57,29 +56,29 @@ pub fn scalar_to_llvm(\n                 Some(AllocType::Memory(alloc)) => {\n                     let init = const_alloc_to_llvm(cx, alloc);\n                     if alloc.mutability == Mutability::Mutable {\n-                        consts::addr_of_mut(cx, init, alloc.align, None)\n+                        cx.static_addr_of_mut(init, alloc.align, None)\n                     } else {\n-                        consts::addr_of(cx, init, alloc.align, None)\n+                        cx.static_addr_of(init, alloc.align, None)\n                     }\n                 }\n                 Some(AllocType::Function(fn_instance)) => {\n                     callee::get_fn(cx, fn_instance)\n                 }\n                 Some(AllocType::Static(def_id)) => {\n                     assert!(cx.tcx.is_static(def_id).is_some());\n-                    consts::get_static(cx, def_id)\n+                    cx.get_static(def_id)\n                 }\n                 None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n             };\n             let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n-                consts::bitcast(base_addr, cx.type_i8p()),\n+                cx.static_bitcast(base_addr, cx.type_i8p()),\n                 &cx.const_usize(ptr.offset.bytes()),\n                 1,\n             ) };\n             if layout.value != layout::Pointer {\n                 unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n             } else {\n-                consts::bitcast(llval, llty)\n+                cx.static_bitcast(llval, llty)\n             }\n         }\n     }"}, {"sha": "f419be8fe3e88178b316a0b635d3409bebf3d71b", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "patch": "@@ -16,14 +16,14 @@ use rustc::mir::tcx::PlaceTy;\n use base;\n use builder::Builder;\n use common::{CodegenCx, IntPredicate};\n-use consts;\n use type_of::LayoutLlvmExt;\n use value::Value;\n use glue;\n use mir::constant::const_alloc_to_llvm;\n \n use interfaces::{\n     BuilderMethods, ConstMethods, BaseTypeMethods, DerivedTypeMethods, DerivedIntrinsicMethods,\n+    StaticMethods,\n };\n \n use super::{FunctionCx, LocalRef};\n@@ -66,14 +66,14 @@ impl PlaceRef<'tcx, &'ll Value> {\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n         let init = const_alloc_to_llvm(bx.cx(), alloc);\n-        let base_addr = consts::addr_of(bx.cx(), init, layout.align, None);\n+        let base_addr = bx.cx().static_addr_of(init, layout.align, None);\n \n         let llval = unsafe { LLVMConstInBoundsGEP(\n-            consts::bitcast(base_addr, bx.cx().type_i8p()),\n+            bx.cx().static_bitcast(base_addr, bx.cx().type_i8p()),\n             &bx.cx().const_usize(offset.bytes()),\n             1,\n         )};\n-        let llval = consts::bitcast(llval, bx.cx().type_ptr_to(layout.llvm_type(bx.cx())));\n+        let llval = bx.cx().static_bitcast(llval, bx.cx().type_ptr_to(layout.llvm_type(bx.cx())));\n         PlaceRef::new_sized(llval, layout, alloc.align)\n     }\n \n@@ -497,7 +497,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             }\n             mir::Place::Static(box mir::Static { def_id, ty }) => {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n-                PlaceRef::new_sized(consts::get_static(cx, def_id), layout, layout.align)\n+                PlaceRef::new_sized(cx.get_static(def_id), layout, layout.align)\n             },\n             mir::Place::Projection(box mir::Projection {\n                 ref base,"}, {"sha": "08d528ba9213ce742fd6b20f2eef99ff4d54071e", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "patch": "@@ -20,7 +20,6 @@ use base;\n use builder::Builder;\n use callee;\n use common::{self, IntPredicate, RealPredicate};\n-use consts;\n use monomorphize;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n@@ -841,7 +840,7 @@ fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n         let max = bx.cx().const_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bx.icmp(IntPredicate::IntUGE, x, max);\n         let infinity_bits = bx.cx().const_u32(ieee::Single::INFINITY.to_bits() as u32);\n-        let infinity = consts::bitcast(infinity_bits, float_ty);\n+        let infinity = bx.bitcast(infinity_bits, float_ty);\n         bx.select(overflow, infinity, bx.uitofp(x, float_ty))\n     } else {\n         if signed {\n@@ -922,7 +921,7 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n             64 => bx.cx().const_u64(bits as u64),\n             n => bug!(\"unsupported float width {}\", n),\n         };\n-        consts::bitcast(bits_llval, float_ty)\n+        bx.bitcast(bits_llval, float_ty)\n     };\n     let (f_min, f_max) = match bx.cx().float_width(float_ty) {\n         32 => compute_clamp_bounds_single(signed, int_ty),"}, {"sha": "c26cc4efd2ce859fd5a0471af32b2f293f0ccde1", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "patch": "@@ -17,7 +17,6 @@\n use asm;\n use attributes;\n use base;\n-use consts;\n use context::CodegenCx;\n use declare;\n use llvm;\n@@ -30,6 +29,7 @@ use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::TypeFoldable;\n use rustc::ty::layout::LayoutOf;\n use std::fmt;\n+use interfaces::StaticMethods;\n \n pub use rustc::mir::mono::MonoItem;\n \n@@ -54,7 +54,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                         bug!(\"Expected Def::Static for {:?}, found nothing\", def_id)\n                     }\n                 };\n-                consts::codegen_static(&cx, def_id, is_mutable);\n+                cx.codegen_static(def_id, is_mutable);\n             }\n             MonoItem::GlobalAsm(node_id) => {\n                 let item = cx.tcx.hir.expect_item(node_id);"}]}