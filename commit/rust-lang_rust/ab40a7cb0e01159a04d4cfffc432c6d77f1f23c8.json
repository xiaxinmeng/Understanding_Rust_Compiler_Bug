{"sha": "ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNDBhN2NiMGUwMTE1OWEwNGQ0Y2ZmZmM0MzJjNmQ3N2YxZjIzYzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-13T19:28:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-13T19:28:57Z"}, "message": "Auto merge of #43815 - alexcrichton:optimize-alloc, r=sfackler\n\nOptimize allocation paths in RawVec\n\nSince the `Alloc` trait was introduced (https://github.com/rust-lang/rust/pull/42313) and it was integrated everywhere (https://github.com/rust-lang/rust/pull/42727) there's been some slowdowns and regressions that have slipped through. The intention of this PR is to try to tackle at least some of them, but they've been very difficult to quantify up to this point so it probably doesn't solve everything.\n\nThis PR primarily targets the `RawVec` type, specifically the `double` function. The codegen for this function is now much closer to what it was before #42313 landed as many runtime checks have been elided.", "tree": {"sha": "23a6ba2f2c3b1b022fed48b52839c713428d6140", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23a6ba2f2c3b1b022fed48b52839c713428d6140"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8", "html_url": "https://github.com/rust-lang/rust/commit/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a80a873209a79499290201f8657618703a51b73e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a80a873209a79499290201f8657618703a51b73e", "html_url": "https://github.com/rust-lang/rust/commit/a80a873209a79499290201f8657618703a51b73e"}, {"sha": "3a831653d06ceef975b80ef4e41ee0679b44c364", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a831653d06ceef975b80ef4e41ee0679b44c364", "html_url": "https://github.com/rust-lang/rust/commit/3a831653d06ceef975b80ef4e41ee0679b44c364"}], "stats": {"total": 209, "additions": 133, "deletions": 76}, "files": [{"sha": "2b3df15f716183062ba1b28cb9ee15c2f96ebd49", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8", "patch": "@@ -354,15 +354,19 @@ pub enum AllocErr {\n }\n \n impl AllocErr {\n+    #[inline]\n     pub fn invalid_input(details: &'static str) -> Self {\n         AllocErr::Unsupported { details: details }\n     }\n+    #[inline]\n     pub fn is_memory_exhausted(&self) -> bool {\n         if let AllocErr::Exhausted { .. } = *self { true } else { false }\n     }\n+    #[inline]\n     pub fn is_request_unsupported(&self) -> bool {\n         if let AllocErr::Unsupported { .. } = *self { true } else { false }\n     }\n+    #[inline]\n     pub fn description(&self) -> &str {\n         match *self {\n             AllocErr::Exhausted { .. } => \"allocator memory exhausted\","}, {"sha": "820f2d958d9a8fb066bf1bb8598e71f4356cca2d", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8", "patch": "@@ -28,6 +28,7 @@ pub mod __core {\n extern \"Rust\" {\n     #[allocator]\n     fn __rust_alloc(size: usize, align: usize, err: *mut u8) -> *mut u8;\n+    #[cold]\n     fn __rust_oom(err: *const u8) -> !;\n     fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n     fn __rust_usable_size(layout: *const u8,\n@@ -81,6 +82,7 @@ unsafe impl Alloc for Heap {\n     }\n \n     #[inline]\n+    #[cold]\n     fn oom(&mut self, err: AllocErr) -> ! {\n         unsafe {\n             __rust_oom(&err as *const AllocErr as *const u8)"}, {"sha": "6090fc3942a565c66ac056ab8d3f41e04ddab826", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 127, "deletions": 76, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=ab40a7cb0e01159a04d4cfffc432c6d77f1f23c8", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use allocator::{Alloc, Layout};\n-use core::ptr::{self, Unique};\n+use core::cmp;\n use core::mem;\n+use core::ops::Drop;\n+use core::ptr::{self, Unique};\n use core::slice;\n-use heap::Heap;\n+use heap::{Alloc, Layout, Heap};\n use super::boxed::Box;\n-use core::ops::Drop;\n-use core::cmp;\n \n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n@@ -222,6 +221,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n         &mut self.a\n     }\n \n+    fn current_layout(&self) -> Option<Layout> {\n+        if self.cap == 0 {\n+            None\n+        } else {\n+            // We have an allocated chunk of memory, so we can bypass runtime\n+            // checks to get our current layout.\n+            unsafe {\n+                let align = mem::align_of::<T>();\n+                let size = mem::size_of::<T>() * self.cap;\n+                Some(Layout::from_size_align_unchecked(size, align))\n+            }\n+        }\n+    }\n+\n     /// Doubles the size of the type's backing allocation. This is common enough\n     /// to want to do that it's easiest to just have a dedicated method. Slightly\n     /// more efficient logic can be provided for this than the general case.\n@@ -280,27 +293,40 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // 0, getting to here necessarily means the RawVec is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            let (new_cap, ptr_res) = if self.cap == 0 {\n-                // skip to 4 because tiny Vec's are dumb; but not if that would cause overflow\n-                let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n-                let ptr_res = self.a.alloc_array::<T>(new_cap);\n-                (new_cap, ptr_res)\n-            } else {\n-                // Since we guarantee that we never allocate more than isize::MAX bytes,\n-                // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow\n-                let new_cap = 2 * self.cap;\n-                let new_alloc_size = new_cap * elem_size;\n-                alloc_guard(new_alloc_size);\n-                let ptr_res = self.a.realloc_array(self.ptr, self.cap, new_cap);\n-                (new_cap, ptr_res)\n-            };\n-\n-            // If allocate or reallocate fail, we'll get `null` back\n-            let uniq = match ptr_res {\n-                Err(err) => self.a.oom(err),\n-                Ok(uniq) => uniq,\n+            let (new_cap, uniq) = match self.current_layout() {\n+                Some(cur) => {\n+                    // Since we guarantee that we never allocate more than\n+                    // isize::MAX bytes, `elem_size * self.cap <= isize::MAX` as\n+                    // a precondition, so this can't overflow. Additionally the\n+                    // alignment will never be too large as to \"not be\n+                    // satisfiable\", so `Layout::from_size_align` will always\n+                    // return `Some`.\n+                    //\n+                    // tl;dr; we bypass runtime checks due to dynamic assertions\n+                    // in this module, allowing us to use\n+                    // `from_size_align_unchecked`.\n+                    let new_cap = 2 * self.cap;\n+                    let new_size = new_cap * elem_size;\n+                    let new_layout = Layout::from_size_align_unchecked(new_size, cur.align());\n+                    alloc_guard(new_size);\n+                    let ptr_res = self.a.realloc(self.ptr.as_ptr() as *mut u8,\n+                                                 cur,\n+                                                 new_layout);\n+                    match ptr_res {\n+                        Ok(ptr) => (new_cap, Unique::new_unchecked(ptr as *mut T)),\n+                        Err(e) => self.a.oom(e),\n+                    }\n+                }\n+                None => {\n+                    // skip to 4 because tiny Vec's are dumb; but not if that\n+                    // would cause overflow\n+                    let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n+                    match self.a.alloc_array::<T>(new_cap) {\n+                        Ok(ptr) => (new_cap, ptr),\n+                        Err(e) => self.a.oom(e),\n+                    }\n+                }\n             };\n-\n             self.ptr = uniq;\n             self.cap = new_cap;\n         }\n@@ -323,21 +349,27 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn double_in_place(&mut self) -> bool {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n+            let old_layout = match self.current_layout() {\n+                Some(layout) => layout,\n+                None => return false, // nothing to double\n+            };\n \n             // since we set the capacity to usize::MAX when elem_size is\n             // 0, getting to here necessarily means the RawVec is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            // Since we guarantee that we never allocate more than isize::MAX bytes,\n-            // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow\n+            // Since we guarantee that we never allocate more than isize::MAX\n+            // bytes, `elem_size * self.cap <= isize::MAX` as a precondition, so\n+            // this can't overflow.\n+            //\n+            // Similarly like with `double` above we can go straight to\n+            // `Layout::from_size_align_unchecked` as we know this won't\n+            // overflow and the alignment is sufficiently small.\n             let new_cap = 2 * self.cap;\n-            let new_alloc_size = new_cap * elem_size;\n-\n-            alloc_guard(new_alloc_size);\n-\n+            let new_size = new_cap * elem_size;\n+            alloc_guard(new_size);\n             let ptr = self.ptr() as *mut _;\n-            let old_layout = Layout::new::<T>().repeat(self.cap).unwrap().0;\n-            let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n+            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n             match self.a.grow_in_place(ptr, old_layout, new_layout) {\n                 Ok(_) => {\n                     // We can't directly divide `size`.\n@@ -373,8 +405,6 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// Aborts on OOM\n     pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n         unsafe {\n-            let elem_size = mem::size_of::<T>();\n-\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n             // If we make it past the first branch then we are guaranteed to\n@@ -388,21 +418,22 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // Nothing we can really do about these checks :(\n             let new_cap = used_cap.checked_add(needed_extra_cap).expect(\"capacity overflow\");\n-            let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n-            alloc_guard(new_alloc_size);\n-\n-            let result = if self.cap == 0 {\n-                self.a.alloc_array::<T>(new_cap)\n-            } else {\n-                self.a.realloc_array(self.ptr, self.cap, new_cap)\n+            let new_layout = match Layout::array::<T>(new_cap) {\n+                Some(layout) => layout,\n+                None => panic!(\"capacity overflow\"),\n             };\n-\n-            // If allocate or reallocate fail, we'll get `null` back\n-            let uniq = match result {\n-                Err(err) => self.a.oom(err),\n-                Ok(uniq) => uniq,\n+            alloc_guard(new_layout.size());\n+            let res = match self.current_layout() {\n+                Some(layout) => {\n+                    let old_ptr = self.ptr.as_ptr() as *mut u8;\n+                    self.a.realloc(old_ptr, layout, new_layout)\n+                }\n+                None => self.a.alloc(new_layout),\n+            };\n+            let uniq = match res {\n+                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n+                Err(e) => self.a.oom(e),\n             };\n-\n             self.ptr = uniq;\n             self.cap = new_cap;\n         }\n@@ -411,17 +442,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// Calculates the buffer's new size given that it'll hold `used_cap +\n     /// needed_extra_cap` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n-    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize) -> (usize, usize) {\n-        let elem_size = mem::size_of::<T>();\n+    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize) -> usize {\n         // Nothing we can really do about these checks :(\n         let required_cap = used_cap.checked_add(needed_extra_cap)\n             .expect(\"capacity overflow\");\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n         let double_cap = self.cap * 2;\n         // `double_cap` guarantees exponential growth.\n-        let new_cap = cmp::max(double_cap, required_cap);\n-        let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n-        (new_cap, new_alloc_size)\n+        cmp::max(double_cap, required_cap)\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n@@ -489,21 +517,25 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 return;\n             }\n \n-            let (new_cap, new_alloc_size) = self.amortized_new_size(used_cap, needed_extra_cap);\n-            // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_alloc_size);\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n \n-            let result = if self.cap == 0 {\n-                self.a.alloc_array::<T>(new_cap)\n-            } else {\n-                self.a.realloc_array(self.ptr, self.cap, new_cap)\n+            let new_layout = match Layout::array::<T>(new_cap) {\n+                Some(layout) => layout,\n+                None => panic!(\"capacity overflow\"),\n             };\n-\n-            let uniq = match result {\n-                Err(err) => self.a.oom(err),\n-                Ok(uniq) => uniq,\n+            // FIXME: may crash and burn on over-reserve\n+            alloc_guard(new_layout.size());\n+            let res = match self.current_layout() {\n+                Some(layout) => {\n+                    let old_ptr = self.ptr.as_ptr() as *mut u8;\n+                    self.a.realloc(old_ptr, layout, new_layout)\n+                }\n+                None => self.a.alloc(new_layout),\n+            };\n+            let uniq = match res {\n+                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n+                Err(e) => self.a.oom(e),\n             };\n-\n             self.ptr = uniq;\n             self.cap = new_cap;\n         }\n@@ -536,21 +568,24 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // Don't actually need any more capacity. If the current `cap` is 0, we can't\n             // reallocate in place.\n             // Wrapping in case they give a bad `used_cap`\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap || self.cap == 0 {\n+            let old_layout = match self.current_layout() {\n+                Some(layout) => layout,\n+                None => return false,\n+            };\n+            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n                 return false;\n             }\n \n-            let (new_cap, new_alloc_size) = self.amortized_new_size(used_cap, needed_extra_cap);\n-            // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_alloc_size);\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n \n             // Here, `cap < used_cap + needed_extra_cap <= new_cap`\n             // (regardless of whether `self.cap - used_cap` wrapped).\n             // Therefore we can safely call grow_in_place.\n \n             let ptr = self.ptr() as *mut _;\n-            let old_layout = Layout::new::<T>().repeat(self.cap).unwrap().0;\n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n+            // FIXME: may crash and burn on over-reserve\n+            alloc_guard(new_layout.size());\n             match self.a.grow_in_place(ptr, old_layout, new_layout) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n@@ -599,9 +634,24 @@ impl<T, A: Alloc> RawVec<T, A> {\n             }\n         } else if self.cap != amount {\n             unsafe {\n-                match self.a.realloc_array(self.ptr, self.cap, amount) {\n+                // We know here that our `amount` is greater than zero. This\n+                // implies, via the assert above, that capacity is also greater\n+                // than zero, which means that we've got a current layout that\n+                // \"fits\"\n+                //\n+                // We also know that `self.cap` is greater than `amount`, and\n+                // consequently we don't need runtime checks for creating either\n+                // layout\n+                let old_size = elem_size * self.cap;\n+                let new_size = elem_size * amount;\n+                let align = mem::align_of::<T>();\n+                let old_layout = Layout::from_size_align_unchecked(old_size, align);\n+                let new_layout = Layout::from_size_align_unchecked(new_size, align);\n+                match self.a.realloc(self.ptr.as_ptr() as *mut u8,\n+                                     old_layout,\n+                                     new_layout) {\n+                    Ok(p) => self.ptr = Unique::new_unchecked(p as *mut T),\n                     Err(err) => self.a.oom(err),\n-                    Ok(uniq) => self.ptr = uniq,\n                 }\n             }\n             self.cap = amount;\n@@ -631,10 +681,11 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n     pub unsafe fn dealloc_buffer(&mut self) {\n         let elem_size = mem::size_of::<T>();\n-        if elem_size != 0 && self.cap != 0 {\n-            let ptr = self.ptr() as *mut u8;\n-            let layout = Layout::new::<T>().repeat(self.cap).unwrap().0;\n-            self.a.dealloc(ptr, layout);\n+        if elem_size != 0 {\n+            if let Some(layout) = self.current_layout() {\n+                let ptr = self.ptr() as *mut u8;\n+                self.a.dealloc(ptr, layout);\n+            }\n         }\n     }\n }"}]}