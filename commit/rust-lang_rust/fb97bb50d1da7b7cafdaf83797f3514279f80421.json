{"sha": "fb97bb50d1da7b7cafdaf83797f3514279f80421", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiOTdiYjUwZDFkYTdiN2NhZmRhZjgzNzk3ZjM1MTQyNzlmODA0MjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-03T21:48:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-03T21:48:37Z"}, "message": "Auto merge of #51900 - PramodBisht:51813_b, r=nikomatsakis\n\nintroduce dirty list to dataflow\n\n@nikomatsakis my naive implementation never worked, So, I decided to implement using `work_queue` data structure. This PR also includes your commits from `nll-liveness-dirty-list` branch. Those commits should not visible once your branch is merged.\n\nr? @nikomatsakis", "tree": {"sha": "fe7387f1bc360c0551fd0a2df9416286e7e44da8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe7387f1bc360c0551fd0a2df9416286e7e44da8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb97bb50d1da7b7cafdaf83797f3514279f80421", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb97bb50d1da7b7cafdaf83797f3514279f80421", "html_url": "https://github.com/rust-lang/rust/commit/fb97bb50d1da7b7cafdaf83797f3514279f80421", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb97bb50d1da7b7cafdaf83797f3514279f80421/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "739320a6011fd78b15328416d3c488d025974039", "url": "https://api.github.com/repos/rust-lang/rust/commits/739320a6011fd78b15328416d3c488d025974039", "html_url": "https://github.com/rust-lang/rust/commit/739320a6011fd78b15328416d3c488d025974039"}, {"sha": "09df6a0aba257270bf2154a0aa0ca1c9acdddcc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/09df6a0aba257270bf2154a0aa0ca1c9acdddcc8", "html_url": "https://github.com/rust-lang/rust/commit/09df6a0aba257270bf2154a0aa0ca1c9acdddcc8"}], "stats": {"total": 88, "additions": 44, "deletions": 44}, "files": [{"sha": "e4cae5fe6c8266c2d2f1d2eb639061f7536009e7", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fb97bb50d1da7b7cafdaf83797f3514279f80421/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb97bb50d1da7b7cafdaf83797f3514279f80421/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=fb97bb50d1da7b7cafdaf83797f3514279f80421", "patch": "@@ -13,6 +13,7 @@ use syntax::ast::{self, MetaItem};\n use rustc_data_structures::indexed_set::{IdxSet, IdxSetBuf};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::bitslice::{bitwise, BitwiseOperator};\n+use rustc_data_structures::work_queue::WorkQueue;\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n@@ -176,7 +177,6 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitD\n struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O> where O: 'b + BitDenotation\n {\n     builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n-    changed: bool,\n }\n \n impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n@@ -185,12 +185,9 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n         let mut temp = IdxSetBuf::new_empty(self.flow_state.sets.bits_per_block);\n         let mut propcx = PropagationContext {\n             builder: self,\n-            changed: true,\n         };\n-        while propcx.changed {\n-            propcx.changed = false;\n-            propcx.walk_cfg(&mut temp);\n-        }\n+        propcx.walk_cfg(&mut temp);\n+\n     }\n \n     fn build_sets(&mut self) {\n@@ -236,18 +233,20 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD> where BD: BitDenotation\n {\n     fn walk_cfg(&mut self, in_out: &mut IdxSet<BD::Idx>) {\n+        let mut dirty_queue: WorkQueue<mir::BasicBlock> =\n+            WorkQueue::with_all(self.builder.mir.basic_blocks().len());\n         let mir = self.builder.mir;\n-        for (bb_idx, bb_data) in mir.basic_blocks().iter().enumerate() {\n-            let builder = &mut self.builder;\n+        while let Some(bb) = dirty_queue.pop() {\n+            let bb_data = &mir[bb];\n             {\n-                let sets = builder.flow_state.sets.for_block(bb_idx);\n+                let sets = self.builder.flow_state.sets.for_block(bb.index());\n                 debug_assert!(in_out.words().len() == sets.on_entry.words().len());\n                 in_out.overwrite(sets.on_entry);\n                 in_out.union(sets.gen_set);\n                 in_out.subtract(sets.kill_set);\n             }\n-            builder.propagate_bits_into_graph_successors_of(\n-                in_out, &mut self.changed, (mir::BasicBlock::new(bb_idx), bb_data));\n+            self.builder.propagate_bits_into_graph_successors_of(\n+                in_out, (bb, bb_data), &mut dirty_queue);\n         }\n     }\n }\n@@ -806,68 +805,68 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n     fn propagate_bits_into_graph_successors_of(\n         &mut self,\n         in_out: &mut IdxSet<D::Idx>,\n-        changed: &mut bool,\n-        (bb, bb_data): (mir::BasicBlock, &mir::BasicBlockData))\n+        (bb, bb_data): (mir::BasicBlock, &mir::BasicBlockData),\n+        dirty_list: &mut WorkQueue<mir::BasicBlock>)\n     {\n         match bb_data.terminator().kind {\n             mir::TerminatorKind::Return |\n             mir::TerminatorKind::Resume |\n             mir::TerminatorKind::Abort |\n             mir::TerminatorKind::GeneratorDrop |\n             mir::TerminatorKind::Unreachable => {}\n-            mir::TerminatorKind::Goto { ref target } |\n-            mir::TerminatorKind::Assert { ref target, cleanup: None, .. } |\n-            mir::TerminatorKind::Yield { resume: ref target, drop: None, .. } |\n-            mir::TerminatorKind::Drop { ref target, location: _, unwind: None } |\n+            mir::TerminatorKind::Goto { target } |\n+            mir::TerminatorKind::Assert { target, cleanup: None, .. } |\n+            mir::TerminatorKind::Yield { resume: target, drop: None, .. } |\n+            mir::TerminatorKind::Drop { target, location: _, unwind: None } |\n             mir::TerminatorKind::DropAndReplace {\n-                ref target, value: _, location: _, unwind: None\n+                target, value: _, location: _, unwind: None\n             } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n             }\n-            mir::TerminatorKind::Yield { resume: ref target, drop: Some(ref drop), .. } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n-                self.propagate_bits_into_entry_set_for(in_out, changed, drop);\n+            mir::TerminatorKind::Yield { resume: target, drop: Some(drop), .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n             }\n-            mir::TerminatorKind::Assert { ref target, cleanup: Some(ref unwind), .. } |\n-            mir::TerminatorKind::Drop { ref target, location: _, unwind: Some(ref unwind) } |\n+            mir::TerminatorKind::Assert { target, cleanup: Some(unwind), .. } |\n+            mir::TerminatorKind::Drop { target, location: _, unwind: Some(unwind) } |\n             mir::TerminatorKind::DropAndReplace {\n-                ref target, value: _, location: _, unwind: Some(ref unwind)\n+                target, value: _, location: _, unwind: Some(unwind)\n             } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n                 if !self.dead_unwinds.contains(&bb) {\n-                    self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n+                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n                 }\n             }\n             mir::TerminatorKind::SwitchInt { ref targets, .. } => {\n                 for target in targets {\n-                    self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n                 }\n             }\n-            mir::TerminatorKind::Call { ref cleanup, ref destination, func: _, args: _ } => {\n-                if let Some(ref unwind) = *cleanup {\n+            mir::TerminatorKind::Call { cleanup, ref destination, func: _, args: _ } => {\n+                if let Some(unwind) = cleanup {\n                     if !self.dead_unwinds.contains(&bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n                     }\n                 }\n-                if let Some((ref dest_place, ref dest_bb)) = *destination {\n+                if let Some((ref dest_place, dest_bb)) = *destination {\n                     // N.B.: This must be done *last*, after all other\n                     // propagation, as documented in comment above.\n                     self.flow_state.operator.propagate_call_return(\n-                        in_out, bb, *dest_bb, dest_place);\n-                    self.propagate_bits_into_entry_set_for(in_out, changed, dest_bb);\n+                        in_out, bb, dest_bb, dest_place);\n+                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n                 }\n             }\n-            mir::TerminatorKind::FalseEdges { ref real_target, ref imaginary_targets } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, real_target);\n+            mir::TerminatorKind::FalseEdges { real_target, ref imaginary_targets } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n                 for target in imaginary_targets {\n-                    self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n                 }\n             }\n-            mir::TerminatorKind::FalseUnwind { ref real_target, unwind } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, real_target);\n-                if let Some(ref unwind) = unwind {\n+            mir::TerminatorKind::FalseUnwind { real_target, unwind } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n+                if let Some(unwind) = unwind {\n                     if !self.dead_unwinds.contains(&bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n                     }\n                 }\n             }\n@@ -876,14 +875,15 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n \n     fn propagate_bits_into_entry_set_for(&mut self,\n                                          in_out: &IdxSet<D::Idx>,\n-                                         changed: &mut bool,\n-                                         bb: &mir::BasicBlock) {\n+                                         bb: mir::BasicBlock,\n+                                         dirty_queue: &mut WorkQueue<mir::BasicBlock>) {\n         let entry_set = self.flow_state.sets.for_block(bb.index()).on_entry;\n         let set_changed = bitwise(entry_set.words_mut(),\n                                   in_out.words(),\n                                   &self.flow_state.operator);\n         if set_changed {\n-            *changed = true;\n+            dirty_queue.insert(bb);\n         }\n     }\n+\n }"}]}