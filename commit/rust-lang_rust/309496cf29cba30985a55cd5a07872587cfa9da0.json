{"sha": "309496cf29cba30985a55cd5a07872587cfa9da0", "node_id": "C_kwDOAAsO6NoAKDMwOTQ5NmNmMjljYmEzMDk4NWE1NWNkNWEwNzg3MjU4N2NmYTlkYTA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-26T16:51:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-26T16:51:40Z"}, "message": "Rollup merge of #108760 - clubby789:autolintstuff, r=wesleywiser\n\nAdd lint to deny diagnostics composed of static strings\n\nr? ghost\n\nI'm hoping to have a lint that semi-automatically converts simple diagnostics such as `struct_span_err(span, \"msg\").help(\"msg\").span_note(span2, \"msg\").emit()` to typed session diagnostics. It's quite hacky and not entirely working because of problems with `x fix` but should hopefully help reduce some of the work.\nI'm going to start trying to apply what I can from this, but opening this as a draft in case anyone wants to develop on it.\n\ncc #100717", "tree": {"sha": "9006cb2257fc20aa856bef68b5d333e4d124569b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9006cb2257fc20aa856bef68b5d333e4d124569b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/309496cf29cba30985a55cd5a07872587cfa9da0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkSVacCRBK7hj4Ov3rIwAAFm4IAA8XmtDvFHnUpS5UVR1451Rr\nbYxpfW2MZXVBGRWCSSrJExUWw4z41HJNQPd6l/aWb8nUuKTfvyfEnOlhsQ5GZFNh\nVDOgtGyZP6kOLZQGhNzYiyJ/15JlqC53q8FUGGtjsWuZw3bGPxSGJoSQhk8QweCQ\n7kPOSB4YqL8SzWruq0SZgB4u++JNzr9vEEXOSgTykcCVCuiiGesuj36pP7O7FSQP\nvtvjtUCJkKe7P55wts0QJa5yht/OPlMud65oNv7j4YF47L9YdZnVsBeLWOCVGeR+\nTQzO3ULYP90j6sFqQUV6Y8lH0VaCG6aF9ik5uL3Bjtf8VZRMjIyreXQe+/l7dtY=\n=eO5z\n-----END PGP SIGNATURE-----\n", "payload": "tree 9006cb2257fc20aa856bef68b5d333e4d124569b\nparent 8763965a2c7b68a33af5fc55999f9eff26749fd6\nparent 01385136353ac35f16d10bf5890bf0efc80df761\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1682527900 +0200\ncommitter GitHub <noreply@github.com> 1682527900 +0200\n\nRollup merge of #108760 - clubby789:autolintstuff, r=wesleywiser\n\nAdd lint to deny diagnostics composed of static strings\n\nr? ghost\n\nI'm hoping to have a lint that semi-automatically converts simple diagnostics such as `struct_span_err(span, \"msg\").help(\"msg\").span_note(span2, \"msg\").emit()` to typed session diagnostics. It's quite hacky and not entirely working because of problems with `x fix` but should hopefully help reduce some of the work.\nI'm going to start trying to apply what I can from this, but opening this as a draft in case anyone wants to develop on it.\n\ncc #100717\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/309496cf29cba30985a55cd5a07872587cfa9da0", "html_url": "https://github.com/rust-lang/rust/commit/309496cf29cba30985a55cd5a07872587cfa9da0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/309496cf29cba30985a55cd5a07872587cfa9da0/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8763965a2c7b68a33af5fc55999f9eff26749fd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8763965a2c7b68a33af5fc55999f9eff26749fd6", "html_url": "https://github.com/rust-lang/rust/commit/8763965a2c7b68a33af5fc55999f9eff26749fd6"}, {"sha": "01385136353ac35f16d10bf5890bf0efc80df761", "url": "https://api.github.com/repos/rust-lang/rust/commits/01385136353ac35f16d10bf5890bf0efc80df761", "html_url": "https://github.com/rust-lang/rust/commit/01385136353ac35f16d10bf5890bf0efc80df761"}], "stats": {"total": 779, "additions": 578, "deletions": 201}, "files": [{"sha": "74049406426ed0bf97318d58249df61f4bdd4907", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -149,6 +149,25 @@ builtin_macros_format_pos_mismatch = {$n} positional {$n ->\n     [one] argument\n     *[more] arguments\n     } in format string, but {$desc}\n+\n builtin_macros_offset_of_expected_field = expected field\n \n builtin_macros_offset_of_expected_two_args = expected 2 arguments\n+\n+builtin_macros_test_case_non_item = `#[test_case]` attribute is only allowed on items\n+\n+builtin_macros_test_bad_fn = {$kind} functions cannot be used for tests\n+    .label = `{$kind}` because of this\n+\n+builtin_macros_asm_explicit_register_name = explicit register arguments cannot have names\n+\n+builtin_macros_asm_mutually_exclusive = the `{$opt1}` and `{$opt2}` options are mutually exclusive\n+\n+builtin_macros_asm_pure_combine = the `pure` option must be combined with either `nomem` or `readonly`\n+\n+builtin_macros_asm_pure_no_output = asm with the `pure` option must have at least one output\n+\n+builtin_macros_asm_modifier_invalid = asm template modifier must be a single character\n+\n+builtin_macros_test_runner_invalid = `test_runner` argument must be a path\n+builtin_macros_test_runner_nargs = `#![test_runner(..)]` accepts exactly 1 argument"}, {"sha": "bcdd58a090162f6cf5909637cd8d647a4ab93534", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -15,6 +15,8 @@ use rustc_span::{InnerSpan, Span};\n use rustc_target::asm::InlineAsmArch;\n use smallvec::smallvec;\n \n+use crate::errors;\n+\n pub struct AsmArgs {\n     pub templates: Vec<P<ast::Expr>>,\n     pub operands: Vec<(ast::InlineAsmOperand, Span)>,\n@@ -205,7 +207,7 @@ pub fn parse_asm_args<'a>(\n         // of the argument available.\n         if explicit_reg {\n             if name.is_some() {\n-                diag.struct_span_err(span, \"explicit register arguments cannot have names\").emit();\n+                diag.emit_err(errors::AsmExplicitRegisterName { span });\n             }\n             args.reg_args.insert(slot);\n         } else if let Some(name) = name {\n@@ -240,25 +242,19 @@ pub fn parse_asm_args<'a>(\n         && args.options.contains(ast::InlineAsmOptions::READONLY)\n     {\n         let spans = args.options_spans.clone();\n-        diag.struct_span_err(spans, \"the `nomem` and `readonly` options are mutually exclusive\")\n-            .emit();\n+        diag.emit_err(errors::AsmMutuallyExclusive { spans, opt1: \"nomem\", opt2: \"readonly\" });\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE)\n         && args.options.contains(ast::InlineAsmOptions::NORETURN)\n     {\n         let spans = args.options_spans.clone();\n-        diag.struct_span_err(spans, \"the `pure` and `noreturn` options are mutually exclusive\")\n-            .emit();\n+        diag.emit_err(errors::AsmMutuallyExclusive { spans, opt1: \"pure\", opt2: \"noreturn\" });\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE)\n         && !args.options.intersects(ast::InlineAsmOptions::NOMEM | ast::InlineAsmOptions::READONLY)\n     {\n         let spans = args.options_spans.clone();\n-        diag.struct_span_err(\n-            spans,\n-            \"the `pure` option must be combined with either `nomem` or `readonly`\",\n-        )\n-        .emit();\n+        diag.emit_err(errors::AsmPureCombine { spans });\n     }\n \n     let mut have_real_output = false;\n@@ -285,11 +281,7 @@ pub fn parse_asm_args<'a>(\n         }\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE) && !have_real_output {\n-        diag.struct_span_err(\n-            args.options_spans.clone(),\n-            \"asm with the `pure` option must have at least one output\",\n-        )\n-        .emit();\n+        diag.emit_err(errors::AsmPureNoOutput { spans: args.options_spans.clone() });\n     }\n     if args.options.contains(ast::InlineAsmOptions::NORETURN) && !outputs_sp.is_empty() {\n         let err = diag\n@@ -705,11 +697,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                             .ty_span\n                             .map(|sp| template_sp.from_inner(InnerSpan::new(sp.start, sp.end)))\n                             .unwrap_or(template_sp);\n-                        ecx.struct_span_err(\n-                            span,\n-                            \"asm template modifier must be a single character\",\n-                        )\n-                        .emit();\n+                        ecx.emit_err(errors::AsmModifierInvalid { span });\n                         modifier = None;\n                     }\n "}, {"sha": "b146988a3c2357a33e8914d51239ec1caae479e5", "filename": "compiler/rustc_builtin_macros/src/errors.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -551,3 +551,71 @@ pub(crate) struct FormatPositionalMismatch {\n     #[subdiagnostic]\n     pub(crate) highlight: SingleLabelManySpans,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_case_non_item)]\n+pub(crate) struct TestCaseNonItem {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_bad_fn)]\n+pub(crate) struct TestBadFn {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[label]\n+    pub(crate) cause: Span,\n+    pub(crate) kind: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_explicit_register_name)]\n+pub(crate) struct AsmExplicitRegisterName {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_mutually_exclusive)]\n+pub(crate) struct AsmMutuallyExclusive {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+    pub(crate) opt1: &'static str,\n+    pub(crate) opt2: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_pure_combine)]\n+pub(crate) struct AsmPureCombine {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_pure_no_output)]\n+pub(crate) struct AsmPureNoOutput {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_modifier_invalid)]\n+pub(crate) struct AsmModifierInvalid {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_runner_invalid)]\n+pub(crate) struct TestRunnerInvalid {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_runner_nargs)]\n+pub(crate) struct TestRunnerNargs {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}"}, {"sha": "49ee276af4e6f2b13af83b7664d5370d4d185784", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n /// The expansion from a test function to the appropriate test struct for libtest\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n use crate::util::{check_builtin_macro_attribute, warn_on_duplicate_attribute};\n@@ -40,12 +41,7 @@ pub fn expand_test_case(\n             unreachable!()\n         },\n         _ => {\n-            ecx.struct_span_err(\n-                anno_item.span(),\n-                \"`#[test_case]` attribute is only allowed on items\",\n-            )\n-            .emit();\n-\n+            ecx.emit_err(errors::TestCaseNonItem { span: anno_item.span() });\n             return vec![];\n         }\n     };\n@@ -533,15 +529,11 @@ fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     match &i.kind {\n         ast::ItemKind::Fn(box ast::Fn { sig, generics, .. }) => {\n             if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n-                sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n-                    .span_label(span, \"`unsafe` because of this\")\n-                    .emit();\n+                sd.emit_err(errors::TestBadFn { span: i.span, cause: span, kind: \"unsafe\" });\n                 return false;\n             }\n             if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n-                sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n-                    .span_label(span, \"`async` because of this\")\n-                    .emit();\n+                sd.emit_err(errors::TestBadFn { span: i.span, cause: span, kind: \"async\" });\n                 return false;\n             }\n "}, {"sha": "be4ba66c082aa9df702a450d58aac6452af43fc2", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -19,6 +19,8 @@ use tracing::debug;\n \n use std::{iter, mem};\n \n+use crate::errors;\n+\n #[derive(Clone)]\n struct Test {\n     span: Span,\n@@ -385,11 +387,11 @@ fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast\n         [single] => match single.meta_item() {\n             Some(meta_item) if meta_item.is_word() => return Some(meta_item.path.clone()),\n             _ => {\n-                sd.struct_span_err(span, \"`test_runner` argument must be a path\").emit();\n+                sd.emit_err(errors::TestRunnerInvalid { span });\n             }\n         },\n         _ => {\n-            sd.struct_span_err(span, \"`#![test_runner(..)]` accepts exactly 1 argument\").emit();\n+            sd.emit_err(errors::TestRunnerNargs { span });\n         }\n     }\n     None"}, {"sha": "375fdec10075a39eab98cfb5f854a0b5a45737c8", "filename": "compiler/rustc_codegen_ssa/messages.ftl", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fmessages.ftl?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -291,3 +291,16 @@ codegen_ssa_invalid_monomorphization_unsupported_cast = invalid monomorphization\n codegen_ssa_invalid_monomorphization_unsupported_operation = invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n \n codegen_ssa_invalid_monomorphization_expected_vector_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of vector type `{$vector_type}` to be a signed or unsigned integer type\n+\n+codegen_ssa_invalid_no_sanitize = invalid argument for `no_sanitize`\n+    .note = expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\n+\n+codegen_ssa_invalid_link_ordinal_nargs = incorrect number of arguments to `#[link_ordinal]`\n+    .note = the attribute requires exactly one argument\n+\n+codegen_ssa_illegal_link_ordinal_format = illegal ordinal format in `link_ordinal`\n+    .note = an unsuffixed integer value, e.g., `1`, is expected\n+\n+codegen_ssa_target_feature_safe_trait = `#[target_feature(..)]` cannot be applied to safe trait method\n+    .label = cannot be applied to safe trait method\n+    .label_def = not an `unsafe` function"}, {"sha": "5bd42622f2c33c459ca51d249edf119b030eaee1", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -14,6 +14,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span};\n use rustc_target::spec::{abi, SanitizerSet};\n \n+use crate::errors;\n use crate::target_features::from_target_feature;\n use crate::{errors::ExpectedUsedSymbol, target_features::check_target_feature_trait_unsafe};\n \n@@ -334,10 +335,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n                                 codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS\n                             }\n                             _ => {\n-                                tcx.sess\n-                                    .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n-                                    .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n-                                    .emit();\n+                                tcx.sess.emit_err(errors::InvalidNoSanitize { span: item.span() });\n                             }\n                         }\n                     }\n@@ -608,10 +606,7 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n     let sole_meta_list = match meta_item_list {\n         Some([item]) => item.lit(),\n         Some(_) => {\n-            tcx.sess\n-                .struct_span_err(attr.span, \"incorrect number of arguments to `#[link_ordinal]`\")\n-                .note(\"the attribute requires exactly one argument\")\n-                .emit();\n+            tcx.sess.emit_err(errors::InvalidLinkOrdinalNargs { span: attr.span });\n             return None;\n         }\n         _ => None,\n@@ -642,10 +637,7 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n             None\n         }\n     } else {\n-        tcx.sess\n-            .struct_span_err(attr.span, \"illegal ordinal format in `link_ordinal`\")\n-            .note(\"an unsuffixed integer value, e.g., `1`, is expected\")\n-            .emit();\n+        tcx.sess.emit_err(errors::InvalidLinkOrdinalFormat { span: attr.span });\n         None\n     }\n }"}, {"sha": "cf4893b822651a77fdf2adcc07177b165505a8c8", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -981,3 +981,37 @@ impl IntoDiagnosticArg for ExpectedPointerMutability {\n         }\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_invalid_no_sanitize)]\n+#[note]\n+pub struct InvalidNoSanitize {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_invalid_link_ordinal_nargs)]\n+#[note]\n+pub struct InvalidLinkOrdinalNargs {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_illegal_link_ordinal_format)]\n+#[note]\n+pub struct InvalidLinkOrdinalFormat {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_target_feature_safe_trait)]\n+pub struct TargetFeatureSafeTrait {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(codegen_ssa_label_def)]\n+    pub def: Span,\n+}"}, {"sha": "a936b62dd4eba4a218cbab6924a016195835ce25", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use rustc_ast::ast;\n use rustc_attr::InstructionSetAttr;\n use rustc_data_structures::fx::FxHashMap;\n@@ -443,14 +444,10 @@ pub fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_s\n     if let DefKind::AssocFn = tcx.def_kind(id) {\n         let parent_id = tcx.local_parent(id);\n         if let DefKind::Trait | DefKind::Impl { of_trait: true } = tcx.def_kind(parent_id) {\n-            tcx.sess\n-                .struct_span_err(\n-                    attr_span,\n-                    \"`#[target_feature(..)]` cannot be applied to safe trait method\",\n-                )\n-                .span_label(attr_span, \"cannot be applied to safe trait method\")\n-                .span_label(tcx.def_span(id), \"not an `unsafe` function\")\n-                .emit();\n+            tcx.sess.emit_err(errors::TargetFeatureSafeTrait {\n+                span: attr_span,\n+                def: tcx.def_span(id),\n+            });\n         }\n     }\n }"}, {"sha": "70d2718b70639937e99ae0213de0589b62cae944", "filename": "compiler/rustc_expand/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_expand%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_expand%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fmessages.ftl?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -136,3 +136,7 @@ expand_proc_macro_panicked =\n \n expand_proc_macro_derive_tokens =\n     proc-macro derive produced unparsable tokens\n+\n+expand_duplicate_matcher_binding = duplicate matcher binding\n+    .label = duplicate binding\n+    .label2 = previous binding"}, {"sha": "e3a0ae3570eb074c1a0a37cfaa67d507810c44c4", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -397,3 +397,13 @@ pub struct ProcMacroDeriveTokens {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_duplicate_matcher_binding)]\n+pub struct DuplicateMatcherBinding {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(expand_label2)]\n+    pub prev: Span,\n+}"}, {"sha": "75b6396f0be383f4ebd11249820ebb6177b749bd", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -104,6 +104,7 @@\n //! Kleene operators under which a meta-variable is repeating is the concatenation of the stacks\n //! stored when entering a macro definition starting from the state in which the meta-variable is\n //! bound.\n+use crate::errors;\n use crate::mbe::{KleeneToken, TokenTree};\n \n use rustc_ast::token::{Delimiter, Token, TokenKind};\n@@ -281,10 +282,7 @@ fn check_binders(\n                 // Duplicate binders at the top-level macro definition are errors. The lint is only\n                 // for nested macro definitions.\n                 sess.span_diagnostic\n-                    .struct_span_err(span, \"duplicate matcher binding\")\n-                    .span_label(span, \"duplicate binding\")\n-                    .span_label(prev_info.span, \"previous binding\")\n-                    .emit();\n+                    .emit_err(errors::DuplicateMatcherBinding { span, prev: prev_info.span });\n                 *valid = false;\n             } else {\n                 binders.insert(name, BinderInfo { span, ops: ops.into() });"}, {"sha": "5d45d09797b0be0f6a20019ccbfce8eeeb642ae6", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -262,3 +262,17 @@ hir_analysis_transparent_non_zero_sized_enum = the variant of a transparent {$de\n hir_analysis_transparent_non_zero_sized = transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n     .label = needs at most one non-zero-sized field, but has {$field_count}\n     .labels = this field is non-zero-sized\n+\n+hir_analysis_too_large_static = extern static is too large for the current architecture\n+\n+hir_analysis_specialization_trait = implementing `rustc_specialization_trait` traits is unstable\n+    .help = add `#![feature(min_specialization)]` to the crate attributes to enable\n+\n+hir_analysis_closure_implicit_hrtb = implicit types in closure signatures are forbidden when `for<...>` is present\n+    .label = `for<...>` is here\n+\n+hir_analysis_const_specialize = cannot specialize on const impl with non-const impl\n+\n+hir_analysis_static_specialize = cannot specialize on `'static` lifetime\n+\n+hir_analysis_missing_tilde_const = missing `~const` qualifier for specialization"}, {"sha": "68e957f9d8e3af706aaae468783b51553bd9de30", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -170,9 +170,7 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             if matches!(tcx.def_kind(def_id), DefKind::Static(_)\n                 if tcx.def_kind(tcx.local_parent(def_id)) == DefKind::ForeignMod) =>\n         {\n-            tcx.sess\n-                .struct_span_err(span, \"extern static is too large for the current architecture\")\n-                .emit();\n+            tcx.sess.emit_err(errors::TooLargeStatic { span });\n             return;\n         }\n         // Generic statics are rejected, but we still reach this case."}, {"sha": "cd2ec2bef20f9fce53e382ae1d6ac11b7e18457e", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -5,6 +5,7 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n+use crate::errors;\n use rustc_errors::{error_code, struct_span_err};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n@@ -67,13 +68,7 @@ fn enforce_trait_manually_implementable(\n         tcx.trait_def(trait_def_id).specialization_kind\n     {\n         if !tcx.features().specialization && !tcx.features().min_specialization {\n-            tcx.sess\n-                .struct_span_err(\n-                    impl_header_span,\n-                    \"implementing `rustc_specialization_trait` traits is unstable\",\n-                )\n-                .help(\"add `#![feature(min_specialization)]` to the crate attributes to enable\")\n-                .emit();\n+            tcx.sess.emit_err(errors::SpecializationTrait { span: impl_header_span });\n             return;\n         }\n     }"}, {"sha": "1c496f867a0630d7df5a3038fa4ed55d2dffea24", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -455,13 +455,9 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                     .collect::<Vec<_>>();\n \n                 if !infer_spans.is_empty() {\n-                    self.tcx.sess\n-                        .struct_span_err(\n-                            infer_spans,\n-                            \"implicit types in closure signatures are forbidden when `for<...>` is present\",\n-                        )\n-                        .span_label(for_sp, \"`for<...>` is here\")\n-                        .emit();\n+                    self.tcx\n+                        .sess\n+                        .emit_err(errors::ClosureImplicitHrtb { spans: infer_spans, for_sp });\n                 }\n             }\n "}, {"sha": "f82169dee988e2914756a20154df2d590e8a8767", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -633,6 +633,7 @@ pub(crate) struct SIMDFFIHighlyExperimental {\n }\n \n #[derive(Diagnostic)]\n+\n pub enum ImplNotMarkedDefault {\n     #[diag(hir_analysis_impl_not_marked_default, code = \"E0520\")]\n     #[note]\n@@ -769,3 +770,48 @@ pub(crate) struct TransparentNonZeroSized<'a> {\n     pub field_count: usize,\n     pub desc: &'a str,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_too_large_static)]\n+pub(crate) struct TooLargeStatic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_specialization_trait)]\n+#[help]\n+pub(crate) struct SpecializationTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_closure_implicit_hrtb)]\n+pub(crate) struct ClosureImplicitHrtb {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[label]\n+    pub for_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_const_specialize)]\n+pub(crate) struct ConstSpecialize {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_static_specialize)]\n+pub(crate) struct StaticSpecialize {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_missing_tilde_const)]\n+pub(crate) struct MissingTildeConst {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "56f456e55577e4ea22b960defd934924706bdc3b", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -65,8 +65,8 @@\n //! cause use after frees with purely safe code in the same way as specializing\n //! on traits with methods can.\n \n-use crate::constrained_generic_params as cgp;\n use crate::errors::SubstsOnOverriddenImpl;\n+use crate::{constrained_generic_params as cgp, errors};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n@@ -137,9 +137,7 @@ fn check_constness(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node,\n \n     if let hir::Constness::Const = impl2_constness {\n         if let hir::Constness::NotConst = impl1_constness {\n-            tcx.sess\n-                .struct_span_err(span, \"cannot specialize on const impl with non-const impl\")\n-                .emit();\n+            tcx.sess.emit_err(errors::ConstSpecialize { span });\n         }\n     }\n }\n@@ -293,7 +291,7 @@ fn check_static_lifetimes<'tcx>(\n     span: Span,\n ) {\n     if tcx.any_free_region_meets(parent_substs, |r| r.is_static()) {\n-        tcx.sess.struct_span_err(span, \"cannot specialize on `'static` lifetime\").emit();\n+        tcx.sess.emit_err(errors::StaticSpecialize { span });\n     }\n }\n \n@@ -438,7 +436,7 @@ fn trait_predicates_eq<'tcx>(\n     // the one on the base.\n     match (trait_pred2.constness, trait_pred1.constness) {\n         (ty::BoundConstness::ConstIfConst, ty::BoundConstness::NotConst) => {\n-            tcx.sess.struct_span_err(span, \"missing `~const` qualifier for specialization\").emit();\n+            tcx.sess.emit_err(errors::MissingTildeConst { span });\n         }\n         _ => {}\n     }"}, {"sha": "603ea1440e9ca8d1f6927d289e445abfb80f8a68", "filename": "compiler/rustc_hir_typeck/messages.ftl", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fmessages.ftl?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -62,3 +62,16 @@ hir_typeck_fru_suggestion =\n         [NONE]{\"\"}\n         *[other] {\" \"}from `{$expr}`\n     }, separate the last named field with a comma\n+\n+hir_typeck_const_select_must_be_const = this argument must be a `const fn`\n+    .help = consult the documentation on `const_eval_select` for more information\n+\n+hir_typeck_const_select_must_be_fn = this argument must be a function item\n+    .note = expected a function item, found {$ty}\n+    .help = consult the documentation on `const_eval_select` for more information\n+\n+hir_typeck_union_pat_multiple_fields = union patterns should have exactly one field\n+hir_typeck_union_pat_dotdot = `..` cannot be used in union patterns\n+\n+hir_typeck_arg_mismatch_indeterminate = argument type mismatch was detected, but rustc had trouble determining where\n+    .note = we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new"}, {"sha": "48c40d216034e00c56cda3a76fbdae8a6c942508", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -228,3 +228,42 @@ impl HelpUseLatestEdition {\n         }\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_const_select_must_be_const)]\n+#[help]\n+pub struct ConstSelectMustBeConst {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_const_select_must_be_fn)]\n+#[note]\n+#[help]\n+pub struct ConstSelectMustBeFn<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_union_pat_multiple_fields)]\n+pub struct UnionPatMultipleFields {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_union_pat_dotdot)]\n+pub struct UnionPatDotDot {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_arg_mismatch_indeterminate)]\n+pub struct ArgMismatchIndeterminate {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "f42c825d9e8b18030af7bd3afe53b4870816d5e3", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -2,8 +2,8 @@ use crate::coercion::CoerceMany;\n use crate::fn_ctxt::arg_matrix::{ArgMatrix, Compatibility, Error, ExpectedIdx, ProvidedIdx};\n use crate::gather_locals::Declaration;\n use crate::method::MethodCallee;\n-use crate::Expectation::*;\n use crate::TupleArgumentsFlag::*;\n+use crate::{errors, Expectation::*};\n use crate::{\n     struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, Needs, RawTy,\n     TupleArgumentsFlag,\n@@ -283,19 +283,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if idx == 1 && !self.tcx.is_const_fn_raw(*def_id) {\n                         self.tcx\n                             .sess\n-                            .struct_span_err(provided_arg.span, \"this argument must be a `const fn`\")\n-                            .help(\"consult the documentation on `const_eval_select` for more information\")\n-                            .emit();\n+                            .emit_err(errors::ConstSelectMustBeConst { span: provided_arg.span });\n                     }\n                 } else {\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(provided_arg.span, \"this argument must be a function item\")\n-                        .note(format!(\"expected a function item, found {checked_ty}\"))\n-                        .help(\n-                            \"consult the documentation on `const_eval_select` for more information\",\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(errors::ConstSelectMustBeFn {\n+                        span: provided_arg.span,\n+                        ty: checked_ty,\n+                    });\n                 }\n             }\n \n@@ -744,17 +738,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if cfg!(debug_assertions) {\n                 span_bug!(error_span, \"expected errors from argument matrix\");\n             } else {\n-                tcx.sess\n-                    .struct_span_err(\n-                        error_span,\n-                        \"argument type mismatch was detected, \\\n-                        but rustc had trouble determining where\",\n-                    )\n-                    .note(\n-                        \"we would appreciate a bug report: \\\n-                        https://github.com/rust-lang/rust/issues/new\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(errors::ArgMismatchIndeterminate { span: error_span });\n             }\n             return;\n         }"}, {"sha": "d69a16d45ae543ee441b5cf776c47e48f40b73ad", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -1,4 +1,4 @@\n-use crate::{FnCtxt, RawTy};\n+use crate::{errors, FnCtxt, RawTy};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n@@ -1410,12 +1410,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Report an error if an incorrect number of fields was specified.\n         if adt.is_union() {\n             if fields.len() != 1 {\n-                tcx.sess\n-                    .struct_span_err(pat.span, \"union patterns should have exactly one field\")\n-                    .emit();\n+                tcx.sess.emit_err(errors::UnionPatMultipleFields { span: pat.span });\n             }\n             if has_rest_pat {\n-                tcx.sess.struct_span_err(pat.span, \"`..` cannot be used in union patterns\").emit();\n+                tcx.sess.emit_err(errors::UnionPatDotDot { span: pat.span });\n             }\n         } else if !unmentioned_fields.is_empty() {\n             let accessible_unmentioned_fields: Vec<_> = unmentioned_fields"}, {"sha": "3c6dbb466db7aec804d666fd4fe02a35a180640c", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -99,6 +99,8 @@ lint_diag_out_of_impl =\n \n lint_untranslatable_diag = diagnostics should be created using translatable messages\n \n+lint_trivial_untranslatable_diag = diagnostic with static strings only\n+\n lint_bad_opt_access = {$msg}\n \n lint_cstring_ptr = getting the inner pointer of a temporary `CString`"}, {"sha": "595b50c4063ca206167bc14efa7d818b87fe1d58", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -4,6 +4,7 @@\n use crate::lints::{\n     BadOptAccessDiag, DefaultHashTypesDiag, DiagOutOfImpl, LintPassByHand, NonExistentDocKeyword,\n     QueryInstability, TyQualified, TykindDiag, TykindKind, UntranslatableDiag,\n+    UntranslatableDiagnosticTrivial,\n };\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n@@ -366,7 +367,15 @@ declare_tool_lint! {\n     report_in_external_macro: true\n }\n \n-declare_lint_pass!(Diagnostics => [ UNTRANSLATABLE_DIAGNOSTIC, DIAGNOSTIC_OUTSIDE_OF_IMPL ]);\n+declare_tool_lint! {\n+    /// The `untranslatable_diagnostic_trivial` lint detects diagnostics created using only static strings.\n+    pub rustc::UNTRANSLATABLE_DIAGNOSTIC_TRIVIAL,\n+    Deny,\n+    \"prevent creation of diagnostics which cannot be translated, which use only static strings\",\n+    report_in_external_macro: true\n+}\n+\n+declare_lint_pass!(Diagnostics => [ UNTRANSLATABLE_DIAGNOSTIC, DIAGNOSTIC_OUTSIDE_OF_IMPL, UNTRANSLATABLE_DIAGNOSTIC_TRIVIAL ]);\n \n impl LateLintPass<'_> for Diagnostics {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n@@ -423,6 +432,75 @@ impl LateLintPass<'_> for Diagnostics {\n     }\n }\n \n+impl EarlyLintPass for Diagnostics {\n+    #[allow(unused_must_use)]\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &ast::Stmt) {\n+        // Looking for a straight chain of method calls from 'struct_span_err' to 'emit'.\n+        let ast::StmtKind::Semi(expr) = &stmt.kind else {\n+            return;\n+        };\n+        let ast::ExprKind::MethodCall(meth) = &expr.kind else {\n+            return;\n+        };\n+        if meth.seg.ident.name != sym::emit || !meth.args.is_empty() {\n+            return;\n+        }\n+        let mut segments = vec![];\n+        let mut cur = &meth.receiver;\n+        let fake = &[].into();\n+        loop {\n+            match &cur.kind {\n+                ast::ExprKind::Call(func, args) => {\n+                    if let ast::ExprKind::Path(_, path) = &func.kind {\n+                        segments.push((path.segments.last().unwrap().ident.name, args))\n+                    }\n+                    break;\n+                }\n+                ast::ExprKind::MethodCall(method) => {\n+                    segments.push((method.seg.ident.name, &method.args));\n+                    cur = &method.receiver;\n+                }\n+                ast::ExprKind::MacCall(mac) => {\n+                    segments.push((mac.path.segments.last().unwrap().ident.name, fake));\n+                    break;\n+                }\n+                _ => {\n+                    break;\n+                }\n+            }\n+        }\n+        segments.reverse();\n+        if segments.is_empty() {\n+            return;\n+        }\n+        if segments[0].0.as_str() != \"struct_span_err\" {\n+            return;\n+        }\n+        if !segments.iter().all(|(name, args)| {\n+            let arg = match name.as_str() {\n+                \"struct_span_err\" | \"span_note\" | \"span_label\" | \"span_help\" => &args[1],\n+                \"note\" | \"help\" => &args[0],\n+                _ => {\n+                    return false;\n+                }\n+            };\n+            if let ast::ExprKind::Lit(lit) = arg.kind\n+                && let ast::token::LitKind::Str = lit.kind {\n+                    true\n+            } else {\n+                false\n+            }\n+        }) {\n+            return;\n+        }\n+        cx.emit_spanned_lint(\n+            UNTRANSLATABLE_DIAGNOSTIC_TRIVIAL,\n+            stmt.span,\n+            UntranslatableDiagnosticTrivial,\n+        );\n+    }\n+}\n+\n declare_tool_lint! {\n     /// The `bad_opt_access` lint detects accessing options by field instead of\n     /// the wrapper function."}, {"sha": "319eb2ea445ed3c93e8fede7cdf3fad7c0bb2738", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -518,6 +518,7 @@ fn register_internals(store: &mut LintStore) {\n     store.register_lints(&TyTyKind::get_lints());\n     store.register_late_pass(|_| Box::new(TyTyKind));\n     store.register_lints(&Diagnostics::get_lints());\n+    store.register_early_pass(|| Box::new(Diagnostics));\n     store.register_late_pass(|_| Box::new(Diagnostics));\n     store.register_lints(&BadOptAccess::get_lints());\n     store.register_late_pass(|_| Box::new(BadOptAccess));"}, {"sha": "848f6a9ecb532286cb1b7844a689c0901f7636e7", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -820,6 +820,10 @@ pub struct DiagOutOfImpl;\n #[diag(lint_untranslatable_diag)]\n pub struct UntranslatableDiag;\n \n+#[derive(LintDiagnostic)]\n+#[diag(lint_trivial_untranslatable_diag)]\n+pub struct UntranslatableDiagnosticTrivial;\n+\n #[derive(LintDiagnostic)]\n #[diag(lint_bad_opt_access)]\n pub struct BadOptAccessDiag<'a> {"}, {"sha": "d45fa90a11b086138acf9683ef1658bee66245d4", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -742,3 +742,33 @@ parse_bad_return_type_notation_output =\n parse_bad_return_type_notation_dotdot =\n     return type notation uses `()` instead of `(..)` for elided arguments\n     .suggestion = remove the `..`\n+\n+parse_bad_assoc_type_bounds = bounds on associated types do not belong here\n+    .label = belongs in `where` clause\n+\n+parse_attr_after_generic = trailing attribute after generic parameter\n+    .label = attributes must go before parameters\n+\n+parse_attr_without_generics = attribute without generic parameters\n+    .label = attributes are only permitted when preceding parameters\n+\n+parse_where_generics = generic parameters on `where` clauses are reserved for future use\n+    .label = currently unsupported\n+\n+parse_generics_in_path = unexpected generic arguments in path\n+\n+parse_assoc_lifetime = associated lifetimes are not supported\n+    .label = the lifetime is given here\n+    .help = if you meant to specify a trait object, write `dyn Trait + 'lifetime`\n+\n+parse_tilde_const_lifetime = `~const` may only modify trait bounds, not lifetime bounds\n+\n+parse_maybe_lifetime = `?` may only modify trait bounds, not lifetime bounds\n+\n+parse_parenthesized_lifetime = parenthesized lifetime bounds are not supported\n+    .suggestion = remove the parentheses\n+\n+parse_const_bounds_missing_tilde = const bounds must start with `~`\n+    .suggestion = add `~`\n+\n+parse_underscore_literal_suffix = underscore literal suffix is not allowed"}, {"sha": "b0e1189851a1b7ac87d55456d88e8efe47aff16f", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -2332,3 +2332,92 @@ pub(crate) struct BadReturnTypeNotationDotDot {\n     #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_bad_assoc_type_bounds)]\n+pub(crate) struct BadAssocTypeBounds {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_attr_after_generic)]\n+pub(crate) struct AttrAfterGeneric {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_attr_without_generics)]\n+pub(crate) struct AttrWithoutGenerics {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_where_generics)]\n+pub(crate) struct WhereOnGenerics {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_generics_in_path)]\n+pub(crate) struct GenericsInPath {\n+    #[primary_span]\n+    pub span: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_assoc_lifetime)]\n+#[help]\n+pub(crate) struct AssocLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub lifetime: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_tilde_const_lifetime)]\n+pub(crate) struct TildeConstLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_maybe_lifetime)]\n+pub(crate) struct MaybeLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_parenthesized_lifetime)]\n+pub(crate) struct ParenthesizedLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(style = \"short\", applicability = \"machine-applicable\", code = \"{snippet}\")]\n+    pub sugg: Option<Span>,\n+    pub snippet: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_const_bounds_missing_tilde)]\n+pub(crate) struct ConstMissingTilde {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"~\", applicability = \"machine-applicable\")]\n+    pub start: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_underscore_literal_suffix)]\n+pub(crate) struct UnderscoreLiteralSuffix {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "a4a75fcb969957f10c1293e949aa5dd7d00c96bc", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -209,11 +209,7 @@ impl<'a> StringReader<'a> {\n                         if string == \"_\" {\n                             self.sess\n                                 .span_diagnostic\n-                                .struct_span_err(\n-                                    self.mk_sp(suffix_start, self.pos),\n-                                    \"underscore literal suffix is not allowed\",\n-                                )\n-                                .emit();\n+                                .emit_err(errors::UnderscoreLiteralSuffix { span: self.mk_sp(suffix_start, self.pos) });\n                             None\n                         } else {\n                             Some(Symbol::intern(string))"}, {"sha": "61a7ae93bfa8bbb997672e50936b266a5a68465c", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -1,5 +1,5 @@\n use crate::errors::{\n-    MultipleWhereClauses, UnexpectedDefaultValueForLifetimeInGenericParameters,\n+    self, MultipleWhereClauses, UnexpectedDefaultValueForLifetimeInGenericParameters,\n     UnexpectedSelfInGenericParameters, WhereClauseBeforeTupleStructBody,\n     WhereClauseBeforeTupleStructBodySugg,\n };\n@@ -181,12 +181,9 @@ impl<'a> Parser<'a> {\n                         let snapshot = this.create_snapshot_for_diagnostic();\n                         match this.parse_ty_where_predicate() {\n                             Ok(where_predicate) => {\n-                                this.struct_span_err(\n-                                    where_predicate.span(),\n-                                    \"bounds on associated types do not belong here\",\n-                                )\n-                                .span_label(where_predicate.span(), \"belongs in `where` clause\")\n-                                .emit();\n+                                this.sess.emit_err(errors::BadAssocTypeBounds {\n+                                    span: where_predicate.span(),\n+                                });\n                                 // FIXME - try to continue parsing other generics?\n                                 return Ok((None, TrailingToken::None));\n                             }\n@@ -201,22 +198,11 @@ impl<'a> Parser<'a> {\n                         // Check for trailing attributes and stop parsing.\n                         if !attrs.is_empty() {\n                             if !params.is_empty() {\n-                                this.struct_span_err(\n-                                    attrs[0].span,\n-                                    \"trailing attribute after generic parameter\",\n-                                )\n-                                .span_label(attrs[0].span, \"attributes must go before parameters\")\n-                                .emit();\n+                                this.sess\n+                                    .emit_err(errors::AttrAfterGeneric { span: attrs[0].span });\n                             } else {\n-                                this.struct_span_err(\n-                                    attrs[0].span,\n-                                    \"attribute without generic parameters\",\n-                                )\n-                                .span_label(\n-                                    attrs[0].span,\n-                                    \"attributes are only permitted when preceding parameters\",\n-                                )\n-                                .emit();\n+                                this.sess\n+                                    .emit_err(errors::AttrWithoutGenerics { span: attrs[0].span });\n                             }\n                         }\n                         return Ok((None, TrailingToken::None));\n@@ -304,12 +290,7 @@ impl<'a> Parser<'a> {\n         // change we parse those generics now, but report an error.\n         if self.choose_generics_over_qpath(0) {\n             let generics = self.parse_generics()?;\n-            self.struct_span_err(\n-                generics.span,\n-                \"generic parameters on `where` clauses are reserved for future use\",\n-            )\n-            .span_label(generics.span, \"currently unsupported\")\n-            .emit();\n+            self.sess.emit_err(errors::WhereOnGenerics { span: generics.span });\n         }\n \n         loop {"}, {"sha": "6cceb47ff83841c4d4853ac6c957a3b6af18310a", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -150,16 +150,13 @@ impl<'a> Parser<'a> {\n             //\n             if style == PathStyle::Mod && path.segments.iter().any(|segment| segment.args.is_some())\n             {\n-                parser\n-                    .struct_span_err(\n-                        path.segments\n-                            .iter()\n-                            .filter_map(|segment| segment.args.as_ref())\n-                            .map(|arg| arg.span())\n-                            .collect::<Vec<_>>(),\n-                        \"unexpected generic arguments in path\",\n-                    )\n-                    .emit();\n+                let span = path\n+                    .segments\n+                    .iter()\n+                    .filter_map(|segment| segment.args.as_ref())\n+                    .map(|arg| arg.span())\n+                    .collect::<Vec<_>>();\n+                parser.sess.emit_err(errors::GenericsInPath { span });\n             }\n         };\n \n@@ -620,10 +617,7 @@ impl<'a> Parser<'a> {\n                 c.into()\n             }\n             Some(GenericArg::Lifetime(lt)) => {\n-                self.struct_span_err(span, \"associated lifetimes are not supported\")\n-                    .span_label(lt.ident.span, \"the lifetime is given here\")\n-                    .help(\"if you meant to specify a trait object, write `dyn Trait + 'lifetime`\")\n-                    .emit();\n+                self.sess.emit_err(errors::AssocLifetime { span, lifetime: lt.ident.span });\n                 self.mk_ty(span, ast::TyKind::Err).into()\n             }\n             None => {"}, {"sha": "f5f6788362ba916d79e72310912b59ee95bf9689", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -1,7 +1,7 @@\n use super::{Parser, PathStyle, TokenType};\n \n use crate::errors::{\n-    DynAfterMut, ExpectedFnPathFoundFnKeyword, ExpectedMutOrConstInRawPointerType,\n+    self, DynAfterMut, ExpectedFnPathFoundFnKeyword, ExpectedMutOrConstInRawPointerType,\n     FnPointerCannotBeAsync, FnPointerCannotBeConst, FnPtrWithGenerics, FnPtrWithGenericsSugg,\n     InvalidDynKeyword, LifetimeAfterMut, NeedPlusAfterTraitObjectLifetime,\n     NegativeBoundsNotSupported, NegativeBoundsNotSupportedSugg, NestedCVariadicType,\n@@ -807,36 +807,26 @@ impl<'a> Parser<'a> {\n     /// Emits an error if any trait bound modifiers were present.\n     fn error_lt_bound_with_modifiers(&self, modifiers: BoundModifiers) {\n         if let Some(span) = modifiers.maybe_const {\n-            self.struct_span_err(\n-                span,\n-                \"`~const` may only modify trait bounds, not lifetime bounds\",\n-            )\n-            .emit();\n+            self.sess.emit_err(errors::TildeConstLifetime { span });\n         }\n \n         if let Some(span) = modifiers.maybe {\n-            self.struct_span_err(span, \"`?` may only modify trait bounds, not lifetime bounds\")\n-                .emit();\n+            self.sess.emit_err(errors::MaybeLifetime { span });\n         }\n     }\n \n     /// Recover on `('lifetime)` with `(` already eaten.\n     fn recover_paren_lifetime(&mut self, lo: Span, inner_lo: Span) -> PResult<'a, ()> {\n         let inner_span = inner_lo.to(self.prev_token.span);\n         self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n-        let mut err = self.struct_span_err(\n-            lo.to(self.prev_token.span),\n-            \"parenthesized lifetime bounds are not supported\",\n-        );\n-        if let Ok(snippet) = self.span_to_snippet(inner_span) {\n-            err.span_suggestion_short(\n-                lo.to(self.prev_token.span),\n-                \"remove the parentheses\",\n-                snippet,\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-        err.emit();\n+        let span = lo.to(self.prev_token.span);\n+        let (sugg, snippet) = if let Ok(snippet) = self.span_to_snippet(inner_span) {\n+            (Some(span), snippet)\n+        } else {\n+            (None, String::new())\n+        };\n+\n+        self.sess.emit_err(errors::ParenthesizedLifetime { span, sugg, snippet });\n         Ok(())\n     }\n \n@@ -857,15 +847,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Const) {\n             let span = self.prev_token.span;\n             self.sess.gated_spans.gate(sym::const_trait_impl, span);\n-\n-            self.struct_span_err(span, \"const bounds must start with `~`\")\n-                .span_suggestion(\n-                    span.shrink_to_lo(),\n-                    \"add `~`\",\n-                    \"~\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(errors::ConstMissingTilde { span, start: span.shrink_to_lo() });\n \n             Some(span)\n         } else {"}, {"sha": "32409499047cd315ca8190b22b7400101c283dec", "filename": "compiler/rustc_resolve/messages.ftl", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_resolve%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_resolve%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fmessages.ftl?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -226,3 +226,10 @@ resolve_add_as_non_derive =\n \n resolve_proc_macro_same_crate = can't use a procedural macro from the same crate that defines it\n     .help = you can define integration tests in a directory named `tests`\n+\n+resolve_imported_crate = `$crate` may not be imported\n+\n+resolve_macro_use_extern_crate_self = `#[macro_use]` is not supported on `extern crate self`\n+\n+resolve_accessible_unsure = not sure whether the path is accessible or not\n+    .note = the type may have associated items, but we are currently not checking them"}, {"sha": "3799679cb1eac162501bbddc00753a07c2634eaf", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -9,7 +9,9 @@ use crate::def_collector::collect_definitions;\n use crate::imports::{Import, ImportKind};\n use crate::macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n-use crate::{Determinacy, ExternPreludeEntry, Finalize, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{\n+    errors, Determinacy, ExternPreludeEntry, Finalize, Module, ModuleKind, ModuleOrUniformRoot,\n+};\n use crate::{\n     MacroData, NameBinding, NameBindingKind, ParentScope, PathResult, PerNS, ResolutionError,\n };\n@@ -523,11 +525,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                             ident.name = crate_name;\n                         }\n \n-                        self.r\n-                            .tcx\n-                            .sess\n-                            .struct_span_err(item.span, \"`$crate` may not be imported\")\n-                            .emit();\n+                        self.r.tcx.sess.emit_err(errors::CrateImported { span: item.span });\n                     }\n                 }\n \n@@ -1028,11 +1026,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                         self.r\n                             .tcx\n                             .sess\n-                            .struct_span_err(\n-                                attr.span,\n-                                \"`#[macro_use]` is not supported on `extern crate self`\",\n-                            )\n-                            .emit();\n+                            .emit_err(errors::MacroUseExternCrateSelf { span: attr.span });\n                     }\n                 }\n                 let ill_formed = |span| {"}, {"sha": "4f9f1c7e85648a3326176882ed6789ec6699b551", "filename": "compiler/rustc_resolve/src/errors.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -517,3 +517,25 @@ pub(crate) struct ProcMacroSameCrate {\n     #[help]\n     pub(crate) is_test: bool,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_imported_crate)]\n+pub(crate) struct CrateImported {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_macro_use_extern_crate_self)]\n+pub(crate) struct MacroUseExternCrateSelf {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_accessible_unsure)]\n+#[note]\n+pub(crate) struct CfgAccessibleUnsure {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}"}, {"sha": "b30c1cd226cb6efdf92899594c230558f04006cd", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -436,9 +436,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n                 // HACK(Urgau): This shouldn't be necessary\n                 PathResult::Failed { is_error_from_last_segment: false, .. } => {\n                     self.tcx.sess\n-                        .struct_span_err(span, \"not sure whether the path is accessible or not\")\n-                        .note(\"the type may have associated items, but we are currently not checking them\")\n-                        .emit();\n+                        .emit_err(errors::CfgAccessibleUnsure { span });\n \n                     // If we get a partially resolved NonModule in one namespace, we should get the\n                     // same result in any other namespaces, so we can return early."}, {"sha": "abf19c30e3deba5febfb3c59c10a6cbc1b7501df", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309496cf29cba30985a55cd5a07872587cfa9da0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=309496cf29cba30985a55cd5a07872587cfa9da0", "patch": "@@ -651,6 +651,7 @@ symbols! {\n         edition_panic,\n         eh_catch_typeinfo,\n         eh_personality,\n+        emit,\n         emit_enum,\n         emit_enum_variant,\n         emit_enum_variant_arg,"}]}