{"sha": "d6736a1440d42f6af967a8a20ab8d73522112b72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NzM2YTE0NDBkNDJmNmFmOTY3YThhMjBhYjhkNzM1MjIxMTJiNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-18T02:06:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-18T02:06:37Z"}, "message": "auto merge of #14880 : SimonSapin/rust/byte-literals, r=alexcrichton\n\nSee #14646 (tracking issue) and rust-lang/rfcs#69.\r\n\r\nThis does not close the tracking issue, as the `bytes!()` macro still needs to be removed. It will be later, after a snapshot is made with the changes in this PR, so that the new syntax can be used when bootstrapping the compiler.", "tree": {"sha": "2a92204127cf1512a60c81ecbb5700288d8f1b92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a92204127cf1512a60c81ecbb5700288d8f1b92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6736a1440d42f6af967a8a20ab8d73522112b72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6736a1440d42f6af967a8a20ab8d73522112b72", "html_url": "https://github.com/rust-lang/rust/commit/d6736a1440d42f6af967a8a20ab8d73522112b72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6736a1440d42f6af967a8a20ab8d73522112b72/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c81a186e9d835ca66865bd9807524b805a06d8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c81a186e9d835ca66865bd9807524b805a06d8d", "html_url": "https://github.com/rust-lang/rust/commit/5c81a186e9d835ca66865bd9807524b805a06d8d"}, {"sha": "3744d828513092d1ed64c4c6f8cd2536f7a5ff0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3744d828513092d1ed64c4c6f8cd2536f7a5ff0d", "html_url": "https://github.com/rust-lang/rust/commit/3744d828513092d1ed64c4c6f8cd2536f7a5ff0d"}], "stats": {"total": 577, "additions": 469, "deletions": 108}, "files": [{"sha": "cc41b8edfbf8d888a63a32e0a249e2eda6d0ec32", "filename": "src/doc/rust.md", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -234,7 +234,7 @@ rule. A literal is a form of constant expression, so is evaluated (primarily)\n at compile time.\n \n ~~~~ {.ebnf .gram}\n-literal : string_lit | char_lit | num_lit ;\n+literal : string_lit | char_lit | byte_string_lit | byte_lit | num_lit ;\n ~~~~\n \n #### Character and string literals\n@@ -244,17 +244,17 @@ char_lit : '\\x27' char_body '\\x27' ;\n string_lit : '\"' string_body * '\"' | 'r' raw_string ;\n \n char_body : non_single_quote\n-          | '\\x5c' [ '\\x27' | common_escape ] ;\n+          | '\\x5c' [ '\\x27' | common_escape | unicode_escape ] ;\n \n string_body : non_double_quote\n-            | '\\x5c' [ '\\x22' | common_escape ] ;\n+            | '\\x5c' [ '\\x22' | common_escape | unicode_escape ] ;\n raw_string : '\"' raw_string_body '\"' | '#' raw_string '#' ;\n \n common_escape : '\\x5c'\n               | 'n' | 'r' | 't' | '0'\n               | 'x' hex_digit 2\n-              | 'u' hex_digit 4\n-              | 'U' hex_digit 8 ;\n+unicode_escape : 'u' hex_digit 4\n+               | 'U' hex_digit 8 ;\n \n hex_digit : 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n           | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n@@ -294,7 +294,7 @@ the following forms:\n     escaped in order to denote *itself*.\n \n Raw string literals do not process any escapes. They start with the character\n-`U+0072` (`r`), followed zero or more of the character `U+0023` (`#`) and a\n+`U+0072` (`r`), followed by zero or more of the character `U+0023` (`#`) and a\n `U+0022` (double-quote) character. The _raw string body_ is not defined in the\n EBNF grammar above: it can contain any sequence of Unicode characters and is\n terminated only by another `U+0022` (double-quote) character, followed by the\n@@ -319,6 +319,65 @@ r##\"foo #\"# bar\"##;                // foo #\"# bar\n \"\\\\x52\"; r\"\\x52\";                  // \\x52\n ~~~~\n \n+#### Byte and byte string literals\n+\n+~~~~ {.ebnf .gram}\n+byte_lit : 'b' '\\x27' byte_body '\\x27' ;\n+byte_string_lit : 'b' '\"' string_body * '\"' | 'b' 'r' raw_byte_string ;\n+\n+byte_body : ascii_non_single_quote\n+          | '\\x5c' [ '\\x27' | common_escape ] ;\n+\n+byte_string_body : ascii_non_double_quote\n+            | '\\x5c' [ '\\x22' | common_escape ] ;\n+raw_byte_string : '\"' raw_byte_string_body '\"' | '#' raw_byte_string '#' ;\n+\n+~~~~\n+\n+A _byte literal_ is a single ASCII character (in the `U+0000` to `U+007F` range)\n+enclosed within two `U+0027` (single-quote) characters,\n+with the exception of `U+0027` itself,\n+which must be _escaped_ by a preceding U+005C character (`\\`),\n+or a single _escape_.\n+It is equivalent to a `u8` unsigned 8-bit integer _number literal_.\n+\n+A _byte string literal_ is a sequence of ASCII characters and _escapes_\n+enclosed within two `U+0022` (double-quote) characters,\n+with the exception of `U+0022` itself,\n+which must be _escaped_ by a preceding `U+005C` character (`\\`),\n+or a _raw byte string literal_.\n+It is equivalent to a `&'static [u8]` borrowed vectior unsigned 8-bit integers.\n+\n+Some additional _escapes_ are available in either byte or non-raw byte string\n+literals. An escape starts with a `U+005C` (`\\`) and continues with one of\n+the following forms:\n+\n+  * An _byte escape_ escape starts with `U+0078` (`x`) and is\n+    followed by exactly two _hex digits_. It denotes the byte\n+    equal to the provided hex value.\n+  * A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072`\n+    (`r`), or `U+0074` (`t`), denoting the bytes values `0x0A` (ASCII LF),\n+    `0x0D` (ASCII CR) or `0x09` (ASCII HT) respectively.\n+  * The _backslash escape_ is the character `U+005C` (`\\`) which must be\n+    escaped in order to denote its ASCII encoding `0x5C`.\n+\n+Raw byte string literals do not process any escapes.\n+They start with the character `U+0072` (`r`),\n+followed by `U+0062` (`b`),\n+followed by zero or more of the character `U+0023` (`#`),\n+and a `U+0022` (double-quote) character.\n+The _raw string body_ is not defined in the EBNF grammar above:\n+it can contain any sequence of ASCII characters and is\n+terminated only by another `U+0022` (double-quote) character, followed by the\n+same number of `U+0023` (`#`) characters that preceded the opening `U+0022`\n+(double-quote) character.\n+A raw byte string literal can not contain any non-ASCII byte.\n+\n+All characters contained in the raw string body represent their ASCII encoding,\n+the characters `U+0022` (double-quote) (except when followed by at least as\n+many `U+0023` (`#`) characters as were used to start the raw string literal) or\n+`U+005C` (`\\`) do not have any special meaning.\n+\n #### Number literals\n \n ~~~~ {.ebnf .gram}"}, {"sha": "84ffb7fb20e744535d1333cabd9b21f00d770535", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -560,6 +560,8 @@ Section: Comparing strings\n \n // share the implementation of the lang-item vs. non-lang-item\n // eq_slice.\n+/// NOTE: This function is (ab)used in rustc::middle::trans::_match\n+/// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[inline]\n fn eq_slice_(a: &str, b: &str) -> bool {\n     #[allow(ctypes)]\n@@ -572,6 +574,8 @@ fn eq_slice_(a: &str, b: &str) -> bool {\n }\n \n /// Bytewise slice equality\n+/// NOTE: This function is (ab)used in rustc::middle::trans::_match\n+/// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[cfg(not(test))]\n #[lang=\"str_eq\"]\n #[inline]"}, {"sha": "ff5cada05ea2e18adbc63282cbbdf86d075d5567", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -182,7 +182,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n         #[allow(unused_variable)]\n         fn run(&mut self, start: uint, end: uint) -> Vec<Option<uint>> {\n             let mut matched = false;\n-            let prefix_bytes: &[u8] = &$prefix_bytes;\n+            let prefix_bytes: &[u8] = $prefix_bytes;\n             let mut clist = &mut Threads::new(self.which);\n             let mut nlist = &mut Threads::new(self.which);\n "}, {"sha": "72def2c10da32faa38e281b50f42e939256c5c04", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -506,6 +506,7 @@ pub fn lit_to_const(lit: &Lit) -> const_val {\n         LitBinary(ref data) => {\n             const_binary(Rc::new(data.iter().map(|x| *x).collect()))\n         }\n+        LitByte(n) => const_uint(n as u64),\n         LitChar(n) => const_uint(n as u64),\n         LitInt(n, _) => const_int(n),\n         LitUint(n, _) => const_uint(n),\n@@ -528,6 +529,7 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n         (&const_float(a), &const_float(b)) => compare_vals(a, b),\n         (&const_str(ref a), &const_str(ref b)) => compare_vals(a, b),\n         (&const_bool(a), &const_bool(b)) => compare_vals(a, b),\n+        (&const_binary(ref a), &const_binary(ref b)) => compare_vals(a, b),\n         _ => None\n     }\n }"}, {"sha": "bf42f76f1a2769853ddeb928313d3b96bdd86813", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -805,6 +805,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n                     } else { t };\n                     let (min, max) = uint_ty_range(uint_type);\n                     let lit_val: u64 = match lit.node {\n+                        ast::LitByte(_v) => return,  // _v is u8, within range by definition\n                         ast::LitInt(v, _) => v as u64,\n                         ast::LitUint(v, _) => v,\n                         ast::LitIntUnsuffixed(v) => v as u64,"}, {"sha": "808d894be43869234976875d2c3ce2f6b32125be", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -1273,13 +1273,24 @@ fn compare_values<'a>(\n                     val: bool_to_i1(result.bcx, result.val)\n                 }\n             }\n-            _ => cx.sess().bug(\"only scalars and strings supported in compare_values\"),\n+            _ => cx.sess().bug(\"only strings supported in compare_values\"),\n         },\n         ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n             ty::ty_str => compare_str(cx, lhs, rhs, rhs_t),\n-            _ => cx.sess().bug(\"only scalars and strings supported in compare_values\"),\n+            ty::ty_vec(mt, _) => match ty::get(mt.ty).sty {\n+                ty::ty_uint(ast::TyU8) => {\n+                    // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n+                    // which calls memcmp().\n+                    let t = ty::mk_str_slice(cx.tcx(), ty::ReStatic, ast::MutImmutable);\n+                    let lhs = BitCast(cx, lhs, type_of::type_of(cx.ccx(), t).ptr_to());\n+                    let rhs = BitCast(cx, rhs, type_of::type_of(cx.ccx(), t).ptr_to());\n+                    compare_str(cx, lhs, rhs, rhs_t)\n+                },\n+                _ => cx.sess().bug(\"only byte strings supported in compare_values\"),\n+            },\n+            _ => cx.sess().bug(\"on string and byte strings supported in compare_values\"),\n         },\n-        _ => cx.sess().bug(\"only scalars and strings supported in compare_values\"),\n+        _ => cx.sess().bug(\"only scalars, byte strings, and strings supported in compare_values\"),\n     }\n }\n "}, {"sha": "338821537e8c6d098a095a6f63120dd6ccdf6c8d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -43,6 +43,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     match lit.node {\n+        ast::LitByte(b) => C_integral(Type::uint_from_ty(cx, ast::TyU8), b as u64, false),\n         ast::LitChar(i) => C_integral(Type::char(cx), i as u64, false),\n         ast::LitInt(i, t) => C_integral(Type::int_from_ty(cx, t), i as u64, true),\n         ast::LitUint(u, t) => C_integral(Type::uint_from_ty(cx, t), u, false),"}, {"sha": "9615372bef19b9ac2d9060722ced8f2d0029aa40", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -1715,6 +1715,7 @@ pub fn check_lit(fcx: &FnCtxt, lit: &ast::Lit) -> ty::t {\n         ast::LitBinary(..) => {\n             ty::mk_slice(tcx, ty::ReStatic, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable })\n         }\n+        ast::LitByte(_) => ty::mk_u8(),\n         ast::LitChar(_) => ty::mk_char(),\n         ast::LitInt(_, t) => ty::mk_mach_int(t),\n         ast::LitUint(_, t) => ty::mk_mach_uint(t),"}, {"sha": "5e84a90121f26a903bdc7195f527dda43cfa8d4c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -1924,6 +1924,14 @@ fn lit_to_str(lit: &ast::Lit) -> String {\n     match lit.node {\n         ast::LitStr(ref st, _) => st.get().to_string(),\n         ast::LitBinary(ref data) => format!(\"{:?}\", data.as_slice()),\n+        ast::LitByte(b) => {\n+            let mut res = String::from_str(\"b'\");\n+            (b as char).escape_default(|c| {\n+                res.push_char(c);\n+            });\n+            res.push_char('\\'');\n+            res\n+        },\n         ast::LitChar(c) => format!(\"'{}'\", c),\n         ast::LitInt(i, _t) => i.to_str(),\n         ast::LitUint(u, _t) => u.to_str(),"}, {"sha": "daa9ee3da844f88568d20df17b8eccece1425cd5", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -140,7 +140,8 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n             }\n \n             // text literals\n-            t::LIT_CHAR(..) | t::LIT_STR(..) | t::LIT_STR_RAW(..) => \"string\",\n+            t::LIT_BYTE(..) | t::LIT_BINARY(..) | t::LIT_BINARY_RAW(..) |\n+                t::LIT_CHAR(..) | t::LIT_STR(..) | t::LIT_STR_RAW(..) => \"string\",\n \n             // number literals\n             t::LIT_INT(..) | t::LIT_UINT(..) | t::LIT_INT_UNSUFFIXED(..) |"}, {"sha": "aeafc0e306c21e0e270c5ea8b0f626b888b80f08", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -616,6 +616,7 @@ pub type Lit = Spanned<Lit_>;\n pub enum Lit_ {\n     LitStr(InternedString, StrStyle),\n     LitBinary(Rc<Vec<u8> >),\n+    LitByte(u8),\n     LitChar(char),\n     LitInt(i64, IntTy),\n     LitUint(u64, UintTy),"}, {"sha": "670e38327d6c421bebc5181f0abe1fffa7e1c066", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -47,6 +47,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitBool(b) => {\n                         accumulator.push_str(format!(\"{}\", b).as_slice());\n                     }\n+                    ast::LitByte(..) |\n                     ast::LitBinary(..) => {\n                         cx.span_err(e.span, \"cannot concatenate a binary literal\");\n                     }"}, {"sha": "407715ab4dae096e681d7a104f6aba9adf98da12", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -436,6 +436,12 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> Gc<ast::Expr> {\n                                 vec!(mk_binop(cx, sp, binop)));\n         }\n \n+        LIT_BYTE(i) => {\n+            let e_byte = cx.expr_lit(sp, ast::LitByte(i));\n+\n+            return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_BYTE\"), vec!(e_byte));\n+        }\n+\n         LIT_CHAR(i) => {\n             let e_char = cx.expr_lit(sp, ast::LitChar(i));\n "}, {"sha": "9039f346edb522cf4180b850534cc8bb211f495e", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 179, "deletions": 78, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -636,6 +636,67 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n+    /// Scan for a single (possibly escaped) byte or char\n+    /// in a byte, (non-raw) byte string, char, or (non-raw) string literal.\n+    /// `start` is the position of `first_source_char`, which is already consumed.\n+    fn scan_char_or_byte(&mut self, start: BytePos, first_source_char: char,\n+                         ascii_only: bool, delim: char) -> Option<char> {\n+        match first_source_char {\n+            '\\\\' => {\n+                // '\\X' for some X must be a character constant:\n+                let escaped = self.curr;\n+                let escaped_pos = self.last_pos;\n+                self.bump();\n+                match escaped {\n+                    None => {},  // EOF here is an error that will be checked later.\n+                    Some(e) => {\n+                        return Some(match e {\n+                            'n' => '\\n',\n+                            'r' => '\\r',\n+                            't' => '\\t',\n+                            '\\\\' => '\\\\',\n+                            '\\'' => '\\'',\n+                            '\"' => '\"',\n+                            '0' => '\\x00',\n+                            'x' => self.scan_numeric_escape(2u, delim),\n+                            'u' if !ascii_only => self.scan_numeric_escape(4u, delim),\n+                            'U' if !ascii_only => self.scan_numeric_escape(8u, delim),\n+                            '\\n' if delim == '\"' => {\n+                                self.consume_whitespace();\n+                                return None\n+                            },\n+                            c => {\n+                                let last_pos = self.last_pos;\n+                                self.err_span_char(\n+                                    escaped_pos, last_pos,\n+                                    if ascii_only { \"unknown byte escape\" }\n+                                    else { \"unknown character escape\" },\n+                                    c);\n+                                c\n+                            }\n+                        })\n+                    }\n+                }\n+            }\n+            '\\t' | '\\n' | '\\r' | '\\'' if delim == '\\'' => {\n+                let last_pos = self.last_pos;\n+                self.err_span_char(\n+                    start, last_pos,\n+                    if ascii_only { \"byte constant must be escaped\" }\n+                    else { \"character constant must be escaped\" },\n+                    first_source_char);\n+            }\n+            _ => if ascii_only && first_source_char > '\\x7F' {\n+                let last_pos = self.last_pos;\n+                self.err_span_char(\n+                    start, last_pos,\n+                    \"byte constant must be ASCII. \\\n+                     Use a \\\\xHH escape for a non-ASCII byte\", first_source_char);\n+            }\n+        }\n+        Some(first_source_char)\n+    }\n+\n     fn binop(&mut self, op: token::BinOp) -> token::Token {\n         self.bump();\n         if self.curr_is('=') {\n@@ -650,10 +711,15 @@ impl<'a> StringReader<'a> {\n     /// token, and updates the interner\n     fn next_token_inner(&mut self) -> token::Token {\n         let c = self.curr;\n-        if ident_start(c) && !self.nextch_is('\"') && !self.nextch_is('#') {\n+        if ident_start(c) && match (c.unwrap(), self.nextch(), self.nextnextch()) {\n             // Note: r as in r\" or r#\" is part of a raw string literal,\n-            // not an identifier, and is handled further down.\n-\n+            // b as in b' is part of a byte literal.\n+            // They are not identifiers, and are handled further down.\n+           ('r', Some('\"'), _) | ('r', Some('#'), _) |\n+           ('b', Some('\"'), _) | ('b', Some('\\''), _) |\n+           ('b', Some('r'), Some('\"')) | ('b', Some('r'), Some('#')) => false,\n+           _ => true\n+        } {\n             let start = self.last_pos;\n             while ident_continue(self.curr) {\n                 self.bump();\n@@ -805,43 +871,7 @@ impl<'a> StringReader<'a> {\n             }\n \n             // Otherwise it is a character constant:\n-            match c2 {\n-                '\\\\' => {\n-                    // '\\X' for some X must be a character constant:\n-                    let escaped = self.curr;\n-                    let escaped_pos = self.last_pos;\n-                    self.bump();\n-                    match escaped {\n-                        None => {}\n-                        Some(e) => {\n-                            c2 = match e {\n-                                'n' => '\\n',\n-                                'r' => '\\r',\n-                                't' => '\\t',\n-                                '\\\\' => '\\\\',\n-                                '\\'' => '\\'',\n-                                '\"' => '\"',\n-                                '0' => '\\x00',\n-                                'x' => self.scan_numeric_escape(2u, '\\''),\n-                                'u' => self.scan_numeric_escape(4u, '\\''),\n-                                'U' => self.scan_numeric_escape(8u, '\\''),\n-                                c2 => {\n-                                    let last_bpos = self.last_pos;\n-                                    self.err_span_char(escaped_pos, last_bpos,\n-                                                         \"unknown character escape\", c2);\n-                                    c2\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                '\\t' | '\\n' | '\\r' | '\\'' => {\n-                    let last_bpos = self.last_pos;\n-                    self.err_span_char( start, last_bpos,\n-                        \"character constant must be escaped\", c2);\n-                }\n-                _ => {}\n-            }\n+            c2 = self.scan_char_or_byte(start, c2, /* ascii_only = */ false, '\\'').unwrap();\n             if !self.curr_is('\\'') {\n                 let last_bpos = self.last_pos;\n                 self.fatal_span_verbose(\n@@ -854,6 +884,112 @@ impl<'a> StringReader<'a> {\n             self.bump(); // advance curr past token\n             return token::LIT_CHAR(c2);\n           }\n+          'b' => {\n+            self.bump();\n+            return match self.curr {\n+                Some('\\'') => parse_byte(self),\n+                Some('\"') => parse_byte_string(self),\n+                Some('r') => parse_raw_byte_string(self),\n+                _ => unreachable!()  // Should have been a token::IDENT above.\n+            };\n+\n+            fn parse_byte(self_: &mut StringReader) -> token::Token {\n+                self_.bump();\n+                let start = self_.last_pos;\n+\n+                // the eof will be picked up by the final `'` check below\n+                let mut c2 = self_.curr.unwrap_or('\\x00');\n+                self_.bump();\n+\n+                c2 = self_.scan_char_or_byte(start, c2, /* ascii_only = */ true, '\\'').unwrap();\n+                if !self_.curr_is('\\'') {\n+                    // Byte offsetting here is okay because the\n+                    // character before position `start` are an\n+                    // ascii single quote and ascii 'b'.\n+                    let last_pos = self_.last_pos;\n+                    self_.fatal_span_verbose(\n+                        start - BytePos(2), last_pos,\n+                        \"unterminated byte constant\".to_string());\n+                }\n+                self_.bump(); // advance curr past token\n+                return token::LIT_BYTE(c2 as u8);\n+            }\n+\n+            fn parse_byte_string(self_: &mut StringReader) -> token::Token {\n+                self_.bump();\n+                let start = self_.last_pos;\n+                let mut value = Vec::new();\n+                while !self_.curr_is('\"') {\n+                    if self_.is_eof() {\n+                        let last_pos = self_.last_pos;\n+                        self_.fatal_span(start, last_pos,\n+                                         \"unterminated double quote byte string\");\n+                    }\n+\n+                    let ch_start = self_.last_pos;\n+                    let ch = self_.curr.unwrap();\n+                    self_.bump();\n+                    self_.scan_char_or_byte(ch_start, ch, /* ascii_only = */ true, '\"')\n+                        .map(|ch| value.push(ch as u8));\n+                }\n+                self_.bump();\n+                return token::LIT_BINARY(Rc::new(value));\n+            }\n+\n+            fn parse_raw_byte_string(self_: &mut StringReader) -> token::Token {\n+                let start_bpos = self_.last_pos;\n+                self_.bump();\n+                let mut hash_count = 0u;\n+                while self_.curr_is('#') {\n+                    self_.bump();\n+                    hash_count += 1;\n+                }\n+\n+                if self_.is_eof() {\n+                    let last_pos = self_.last_pos;\n+                    self_.fatal_span(start_bpos, last_pos, \"unterminated raw string\");\n+                } else if !self_.curr_is('\"') {\n+                    let last_pos = self_.last_pos;\n+                    let ch = self_.curr.unwrap();\n+                    self_.fatal_span_char(start_bpos, last_pos,\n+                                    \"only `#` is allowed in raw string delimitation; \\\n+                                     found illegal character\",\n+                                    ch);\n+                }\n+                self_.bump();\n+                let content_start_bpos = self_.last_pos;\n+                let mut content_end_bpos;\n+                'outer: loop {\n+                    match self_.curr {\n+                        None => {\n+                            let last_pos = self_.last_pos;\n+                            self_.fatal_span(start_bpos, last_pos, \"unterminated raw string\")\n+                        },\n+                        Some('\"') => {\n+                            content_end_bpos = self_.last_pos;\n+                            for _ in range(0, hash_count) {\n+                                self_.bump();\n+                                if !self_.curr_is('#') {\n+                                    continue 'outer;\n+                                }\n+                            }\n+                            break;\n+                        },\n+                        Some(c) => if c > '\\x7F' {\n+                            let last_pos = self_.last_pos;\n+                            self_.err_span_char(\n+                                last_pos, last_pos, \"raw byte string must be ASCII\", c);\n+                        }\n+                    }\n+                    self_.bump();\n+                }\n+                self_.bump();\n+                let bytes = self_.with_str_from_to(content_start_bpos,\n+                                                   content_end_bpos,\n+                                                   |s| s.as_bytes().to_owned());\n+                return token::LIT_BINARY_RAW(Rc::new(bytes), hash_count);\n+            }\n+          }\n           '\"' => {\n             let mut accum_str = String::new();\n             let start_bpos = self.last_pos;\n@@ -864,46 +1000,11 @@ impl<'a> StringReader<'a> {\n                     self.fatal_span(start_bpos, last_bpos, \"unterminated double quote string\");\n                 }\n \n+                let ch_start = self.last_pos;\n                 let ch = self.curr.unwrap();\n                 self.bump();\n-                match ch {\n-                  '\\\\' => {\n-                    if self.is_eof() {\n-                        let last_bpos = self.last_pos;\n-                        self.fatal_span(start_bpos, last_bpos,\n-                               \"unterminated double quote string\");\n-                    }\n-\n-                    let escaped = self.curr.unwrap();\n-                    let escaped_pos = self.last_pos;\n-                    self.bump();\n-                    match escaped {\n-                      'n' => accum_str.push_char('\\n'),\n-                      'r' => accum_str.push_char('\\r'),\n-                      't' => accum_str.push_char('\\t'),\n-                      '\\\\' => accum_str.push_char('\\\\'),\n-                      '\\'' => accum_str.push_char('\\''),\n-                      '\"' => accum_str.push_char('\"'),\n-                      '\\n' => self.consume_whitespace(),\n-                      '0' => accum_str.push_char('\\x00'),\n-                      'x' => {\n-                        accum_str.push_char(self.scan_numeric_escape(2u, '\"'));\n-                      }\n-                      'u' => {\n-                        accum_str.push_char(self.scan_numeric_escape(4u, '\"'));\n-                      }\n-                      'U' => {\n-                        accum_str.push_char(self.scan_numeric_escape(8u, '\"'));\n-                      }\n-                      c2 => {\n-                        let last_bpos = self.last_pos;\n-                        self.err_span_char(escaped_pos, last_bpos,\n-                                        \"unknown string escape\", c2);\n-                      }\n-                    }\n-                  }\n-                  _ => accum_str.push_char(ch)\n-                }\n+                self.scan_char_or_byte(ch_start, ch, /* ascii_only = */ false, '\"')\n+                    .map(|ch| accum_str.push_char(ch));\n             }\n             self.bump();\n             return token::LIT_STR(str_to_ident(accum_str.as_slice()));"}, {"sha": "ae2ec216bee60924d3b45e695fe2aa99d4f28132", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -33,7 +33,7 @@ use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n use ast::{Ident, NormalFn, Inherited, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy, Lit, Lit_};\n-use ast::{LitBool, LitFloat, LitFloatUnsuffixed, LitInt, LitChar};\n+use ast::{LitBool, LitFloat, LitFloatUnsuffixed, LitInt, LitChar, LitByte, LitBinary};\n use ast::{LitIntUnsuffixed, LitNil, LitStr, LitUint, Local, LocalLet};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, Matcher, MatchNonterminal};\n use ast::{MatchSeq, MatchTok, Method, MutTy, BiMul, Mutability};\n@@ -1512,6 +1512,7 @@ impl<'a> Parser<'a> {\n     // matches token_lit = LIT_INT | ...\n     pub fn lit_from_token(&mut self, tok: &token::Token) -> Lit_ {\n         match *tok {\n+            token::LIT_BYTE(i) => LitByte(i),\n             token::LIT_CHAR(i) => LitChar(i),\n             token::LIT_INT(i, it) => LitInt(i, it),\n             token::LIT_UINT(u, ut) => LitUint(u, ut),\n@@ -1528,6 +1529,8 @@ impl<'a> Parser<'a> {\n             token::LIT_STR_RAW(s, n) => {\n                 LitStr(self.id_to_interned_str(s), ast::RawStr(n))\n             }\n+            token::LIT_BINARY_RAW(ref v, _) |\n+            token::LIT_BINARY(ref v) => LitBinary(v.clone()),\n             token::LPAREN => { self.expect(&token::RPAREN); LitNil },\n             _ => { self.unexpected_last(tok); }\n         }"}, {"sha": "a2af417ed79a82055ec86c8defc389994ea1788c", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -78,6 +78,7 @@ pub enum Token {\n     DOLLAR,\n \n     /* Literals */\n+    LIT_BYTE(u8),\n     LIT_CHAR(char),\n     LIT_INT(i64, ast::IntTy),\n     LIT_UINT(u64, ast::UintTy),\n@@ -86,6 +87,8 @@ pub enum Token {\n     LIT_FLOAT_UNSUFFIXED(ast::Ident),\n     LIT_STR(ast::Ident),\n     LIT_STR_RAW(ast::Ident, uint), /* raw str delimited by n hash symbols */\n+    LIT_BINARY(Rc<Vec<u8>>),\n+    LIT_BINARY_RAW(Rc<Vec<u8>>, uint), /* raw binary str delimited by n hash symbols */\n \n     /* Name components */\n     // an identifier contains an \"is_mod_name\" boolean,\n@@ -193,6 +196,14 @@ pub fn to_str(t: &Token) -> String {\n       DOLLAR => \"$\".to_string(),\n \n       /* Literals */\n+      LIT_BYTE(b) => {\n+          let mut res = String::from_str(\"b'\");\n+          (b as char).escape_default(|c| {\n+              res.push_char(c);\n+          });\n+          res.push_char('\\'');\n+          res\n+      }\n       LIT_CHAR(c) => {\n           let mut res = String::from_str(\"'\");\n           c.escape_default(|c| {\n@@ -222,17 +233,26 @@ pub fn to_str(t: &Token) -> String {\n         body\n       }\n       LIT_STR(s) => {\n-          (format!(\"\\\"{}\\\"\", get_ident(s).get().escape_default())).to_string()\n+          format!(\"\\\"{}\\\"\", get_ident(s).get().escape_default())\n       }\n       LIT_STR_RAW(s, n) => {\n-          (format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                  delim=\"#\".repeat(n), string=get_ident(s))).to_string()\n+        format!(\"r{delim}\\\"{string}\\\"{delim}\",\n+                 delim=\"#\".repeat(n), string=get_ident(s))\n+      }\n+      LIT_BINARY(ref v) => {\n+          format!(\n+            \"b\\\"{}\\\"\",\n+            v.iter().map(|&b| b as char).collect::<String>().escape_default())\n+      }\n+      LIT_BINARY_RAW(ref s, n) => {\n+        format!(\"br{delim}\\\"{string}\\\"{delim}\",\n+                 delim=\"#\".repeat(n), string=s.as_slice().to_ascii().as_str_ascii())\n       }\n \n       /* Name components */\n       IDENT(s, _) => get_ident(s).get().to_string(),\n       LIFETIME(s) => {\n-          (format!(\"{}\", get_ident(s))).to_string()\n+          format!(\"{}\", get_ident(s))\n       }\n       UNDERSCORE => \"_\".to_string(),\n \n@@ -273,6 +293,7 @@ pub fn can_begin_expr(t: &Token) -> bool {\n       IDENT(_, _) => true,\n       UNDERSCORE => true,\n       TILDE => true,\n+      LIT_BYTE(_) => true,\n       LIT_CHAR(_) => true,\n       LIT_INT(_, _) => true,\n       LIT_UINT(_, _) => true,\n@@ -281,6 +302,8 @@ pub fn can_begin_expr(t: &Token) -> bool {\n       LIT_FLOAT_UNSUFFIXED(_) => true,\n       LIT_STR(_) => true,\n       LIT_STR_RAW(_, _) => true,\n+      LIT_BINARY(_) => true,\n+      LIT_BINARY_RAW(_, _) => true,\n       POUND => true,\n       AT => true,\n       NOT => true,\n@@ -311,6 +334,7 @@ pub fn close_delimiter_for(t: &Token) -> Option<Token> {\n \n pub fn is_lit(t: &Token) -> bool {\n     match *t {\n+      LIT_BYTE(_) => true,\n       LIT_CHAR(_) => true,\n       LIT_INT(_, _) => true,\n       LIT_UINT(_, _) => true,\n@@ -319,6 +343,8 @@ pub fn is_lit(t: &Token) -> bool {\n       LIT_FLOAT_UNSUFFIXED(_) => true,\n       LIT_STR(_) => true,\n       LIT_STR_RAW(_, _) => true,\n+      LIT_BINARY(_) => true,\n+      LIT_BINARY_RAW(_, _) => true,\n       _ => false\n     }\n }"}, {"sha": "fafebd3c5dc3e13731d5de7d4bfc948b01d11be9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -2305,6 +2305,12 @@ impl<'a> State<'a> {\n         }\n         match lit.node {\n             ast::LitStr(ref st, style) => self.print_string(st.get(), style),\n+            ast::LitByte(byte) => {\n+                let mut res = String::from_str(\"b'\");\n+                (byte as char).escape_default(|c| res.push_char(c));\n+                res.push_char('\\'');\n+                word(&mut self.s, res.as_slice())\n+            }\n             ast::LitChar(ch) => {\n                 let mut res = String::from_str(\"'\");\n                 ch.escape_default(|c| res.push_char(c));\n@@ -2336,19 +2342,9 @@ impl<'a> State<'a> {\n             ast::LitBool(val) => {\n                 if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n             }\n-            ast::LitBinary(ref arr) => {\n-                try!(self.ibox(indent_unit));\n-                try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep_cmnt(Inconsistent,\n-                                        arr.as_slice(),\n-                                        |s, u| {\n-                                            word(&mut s.s,\n-                                                 format!(\"{}\",\n-                                                         *u).as_slice())\n-                                        },\n-                                        |_| lit.span));\n-                try!(word(&mut self.s, \"]\"));\n-                self.end()\n+            ast::LitBinary(ref v) => {\n+                let escaped: String = v.iter().map(|&b| b as char).collect();\n+                word(&mut self.s, format!(\"b\\\"{}\\\"\", escaped.escape_default()).as_slice())\n             }\n         }\n     }"}, {"sha": "436078fa762e57d1d99baa8e45618f8f4e8447f7", "filename": "src/test/compile-fail/byte-literals.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbyte-literals.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// ignore-tidy-tab\n+\n+static FOO: u8 = b'\\f';  //~ ERROR unknown byte escape\n+\n+pub fn main() {\n+    b'\\f';  //~ ERROR unknown byte escape\n+    b'\\x0Z';  //~ ERROR illegal character in numeric character escape: Z\n+    b'\t';  //~ ERROR byte constant must be escaped\n+    b''';  //~ ERROR byte constant must be escaped\n+    b'\u00e9';  //~ ERROR byte constant must be ASCII\n+    b'a  //~ ERROR unterminated byte constant\n+}\n+\n+"}, {"sha": "ec67cdd77e19fa755f81d250e5fac4e2ae88acab", "filename": "src/test/compile-fail/byte-string-literals.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Fbyte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Fbyte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbyte-string-literals.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// ignore-tidy-tab\n+\n+static FOO: &'static [u8] = b\"\\f\";  //~ ERROR unknown byte escape\n+\n+pub fn main() {\n+    b\"\\f\";  //~ ERROR unknown byte escape\n+    b\"\\x0Z\";  //~ ERROR illegal character in numeric character escape: Z\n+    b\"\u00e9\";  //~ ERROR byte constant must be ASCII\n+    b\"a  //~ ERROR unterminated double quote byte string\n+}\n+\n+"}, {"sha": "dc31126e6d6e34108309b2f59a10b506032b7c5c", "filename": "src/test/compile-fail/concat.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconcat.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n fn main() {\n+    concat!(b'f');  //~ ERROR: cannot concatenate a binary literal\n+    concat!(b\"foo\");  //~ ERROR: cannot concatenate a binary literal\n     concat!(foo);   //~ ERROR: expected a literal\n     concat!(foo()); //~ ERROR: expected a literal\n }"}, {"sha": "9a59c4227114b3a18f5b8f75763e3a4eb8392165", "filename": "src/test/compile-fail/lex-unknown-str-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Flex-unknown-str-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Flex-unknown-str-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-unknown-str-escape.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n static s: &'static str =\n-    \"\\\u25cf\" //~ ERROR: unknown string escape\n+    \"\\\u25cf\" //~ ERROR: unknown character escape\n ;"}, {"sha": "83ea9db39b798b1f80009c7bc6a016fe5851477a", "filename": "src/test/compile-fail/raw-byte-string-eof.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Fraw-byte-string-eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Fraw-byte-string-eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fraw-byte-string-eof.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub fn main() {\n+    br##\"a\"#;  //~ unterminated raw string\n+}\n+\n+"}, {"sha": "7a3d1b2318a3186c776a3d5fc504209468b5189a", "filename": "src/test/compile-fail/raw-byte-string-literals.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Fraw-byte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Fcompile-fail%2Fraw-byte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fraw-byte-string-literals.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub fn main() {\n+    br\"\u00e9\";  //~ raw byte string must be ASCII\n+    br##~\"a\"~##;  //~ only `#` is allowed in raw string delimitation\n+}\n+\n+"}, {"sha": "5317fdc391fd68ce7b7db5023d405c46dd0ffbe1", "filename": "src/test/run-pass/byte-literals.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6736a1440d42f6af967a8a20ab8d73522112b72/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbyte-literals.rs?ref=d6736a1440d42f6af967a8a20ab8d73522112b72", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+static FOO: u8 = b'\\xF0';\n+static BAR: &'static [u8] = b\"a\\xF0\\t\";\n+static BAZ: &'static [u8] = br\"a\\n\";\n+\n+pub fn main() {\n+    assert_eq!(b'a', 97u8);\n+    assert_eq!(b'\\n', 10u8);\n+    assert_eq!(b'\\r', 13u8);\n+    assert_eq!(b'\\t', 9u8);\n+    assert_eq!(b'\\\\', 92u8);\n+    assert_eq!(b'\\'', 39u8);\n+    assert_eq!(b'\\\"', 34u8);\n+    assert_eq!(b'\\0', 0u8);\n+    assert_eq!(b'\\xF0', 240u8);\n+    assert_eq!(FOO, 240u8);\n+\n+    assert_eq!([42, ..b'\\t'].as_slice(), &[42, 42, 42, 42, 42, 42, 42, 42, 42]);\n+\n+    match 42 {\n+        b'*' => {},\n+        _ => fail!()\n+    }\n+\n+    match 100 {\n+        b'a' .. b'z' => {},\n+        _ => fail!()\n+    }\n+\n+    assert_eq!(b\"a\\n\\r\\t\\\\\\'\\\"\\0\\xF0\",\n+               &[97u8, 10u8, 13u8, 9u8, 92u8, 39u8, 34u8, 0u8, 240u8]);\n+    assert_eq!(b\"a\\\n+                 b\", &[97u8, 98u8]);\n+    assert_eq!(BAR, &[97u8, 240u8, 9u8]);\n+\n+    match &[97u8, 10u8] {\n+        b\"a\\n\" => {},\n+        _ => fail!(),\n+    }\n+\n+    assert_eq!(BAZ, &[97u8, 92u8, 110u8]);\n+    assert_eq!(br\"a\\n\", &[97u8, 92u8, 110u8]);\n+    assert_eq!(br\"a\\n\", b\"a\\\\n\");\n+    assert_eq!(br###\"a\"##b\"###, &[97u8, 34u8, 35u8, 35u8, 98u8]);\n+    assert_eq!(br###\"a\"##b\"###, b\"a\\\"##b\");\n+}"}]}