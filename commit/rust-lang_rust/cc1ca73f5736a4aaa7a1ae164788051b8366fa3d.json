{"sha": "cc1ca73f5736a4aaa7a1ae164788051b8366fa3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMWNhNzNmNTczNmE0YWFhN2ExYWUxNjQ3ODgwNTFiODM2NmZhM2Q=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-03T13:48:56Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-03T13:48:56Z"}, "message": "jit interpretation of constants", "tree": {"sha": "00c2c521a2a01160b277bb3d58085765f4854a13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00c2c521a2a01160b277bb3d58085765f4854a13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXUYrIAAoJEFbW7qD8Z6xGKMcQAK/wosha6NNCYlzBcmZ/K3Ib\n/PgeNraNYxDSpWgOC7I02u/ASFwVtKRoGamw4XzQNEIAB2IF+fA9fgz/26daXqH1\nwHIe0yhUd2sxkcUB7fjDNFmVkwFA4yl39zjG4RQJ97RBI7oNCtXH5ENizb+4GCan\nn4gxX/86bWaeJz9rD/OIhDT3yxGw0AL8X9liQmMFLzkgoPOkZTRk20xVSauoBrCz\nVjq12E/DU7AKHzT9gWPEDqT7qCqUEs4eRVUp8FEuVJDEJr0NPf64gENw91DgSjln\nj/5YiBS1oLsjVX9WclAUJvQkcMNnJ6FV5NIrhKOz5IA+EdGzC274F2I0SyydwPsg\nyQXmP27ky0klOlT55WZoRYbaahCz5dZV1Hj6/E2SFgyVWqGbDFC04d7RDgewO3Op\nyTrljDEiBhDdN1JUZeKQqepMSYS/Vn4+vDyaTSZpCNDVtTe9Cn47JOcV79NdvPAR\nZ8+xvIYtF8mb9e8NXavRAZO6GE0sg5B4NWOBfif7UCg7KB1ZRGuOLtPylF1aV86o\nxTk1BdmZfiqSqc+w0gdjw7pbEF7JmiOydiOvwssrmcILmePgJ7EfF9iWcKl7GM3C\nK20X8sqqzwT0iPA5gMtFAlcSshzyoOGPcypAGeEas9gkQYWzU0otCFGSqE4QesyK\nDotnEAYRPeKK5CH7neZq\n=8xR0\n-----END PGP SIGNATURE-----", "payload": "tree 00c2c521a2a01160b277bb3d58085765f4854a13\nparent 05f829cc9f2627c14f93bf70540311390d36f043\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1464961736 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1464961736 +0200\n\njit interpretation of constants"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d", "html_url": "https://github.com/rust-lang/rust/commit/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05f829cc9f2627c14f93bf70540311390d36f043", "url": "https://api.github.com/repos/rust-lang/rust/commits/05f829cc9f2627c14f93bf70540311390d36f043", "html_url": "https://github.com/rust-lang/rust/commit/05f829cc9f2627c14f93bf70540311390d36f043"}], "stats": {"total": 212, "additions": 139, "deletions": 73}, "files": [{"sha": "7e59b2674e87f6ce82ee550eb8e34b22a9c422ad", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=cc1ca73f5736a4aaa7a1ae164788051b8366fa3d", "patch": "@@ -129,9 +129,9 @@ enum TerminatorTarget {\n }\n \n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n-enum ConstantId {\n+enum ConstantId<'tcx> {\n     Promoted { index: usize },\n-    Static { def_id: DefId },\n+    Static { def_id: DefId, substs: &'tcx Substs<'tcx> },\n }\n \n \n@@ -156,13 +156,7 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n         let mut nested_fecx = FnEvalContext::new(self);\n \n         nested_fecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, None);\n-        let return_ptr = match mir.return_ty {\n-            ty::FnConverging(ty) => {\n-                let size = nested_fecx.type_size(ty);\n-                Some(nested_fecx.memory.allocate(size))\n-            }\n-            ty::FnDiverging => None,\n-        };\n+        let return_ptr = nested_fecx.alloc_ret_ptr(mir.return_ty);\n         nested_fecx.frame_mut().return_ptr = return_ptr;\n \n         nested_fecx.run()?;\n@@ -178,6 +172,16 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         }\n     }\n \n+    fn alloc_ret_ptr(&mut self, ty: ty::FnOutput<'tcx>) -> Option<Pointer> {\n+        match ty {\n+            ty::FnConverging(ty) => {\n+                let size = self.type_size(ty);\n+                Some(self.memory.allocate(size))\n+            }\n+            ty::FnDiverging => None,\n+        }\n+    }\n+\n     fn maybe_report<T>(&self, span: codemap::Span, r: EvalResult<T>) -> EvalResult<T> {\n         if let Err(ref e) = r {\n             let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n@@ -207,6 +211,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             loop {\n                 match stepper.step()? {\n+                    Constant => trace!(\"next statement requires the computation of a constant\"),\n                     Assignment => trace!(\"{:?}\", stepper.stmt()),\n                     Terminator => {\n                         trace!(\"{:?}\", stepper.term().kind);\n@@ -998,7 +1003,14 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 use rustc::mir::repr::Literal::*;\n                 match *literal {\n                     Value { ref value } => Ok(self.const_to_ptr(value)?),\n-                    Item { .. } => Err(EvalError::Unimplemented(format!(\"literal items (e.g. mentions of function items) are unimplemented\"))),\n+                    Item { def_id, substs } => {\n+                        let item_ty = self.tcx.lookup_item_type(def_id).subst(self.tcx, substs);\n+                        if item_ty.ty.is_fn() {\n+                            Err(EvalError::Unimplemented(\"unimplemented: mentions of function items\".to_string()))\n+                        } else {\n+                            Ok(*self.statics.get(&def_id).expect(\"static should have been cached (rvalue)\"))\n+                        }\n+                    },\n                     Promoted { index } => Ok(*self.frame().promoted.get(&index).expect(\"a promoted constant hasn't been precomputed\")),\n                 }\n             }\n@@ -1014,7 +1026,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             Var(i) => self.frame().locals[self.frame().var_offset + i as usize],\n             Temp(i) => self.frame().locals[self.frame().temp_offset + i as usize],\n \n-            Static(def_id) => *self.gecx.statics.get(&def_id).expect(\"static should have been cached\"),\n+            Static(def_id) => *self.gecx.statics.get(&def_id).expect(\"static should have been cached (lvalue)\"),\n \n             Projection(ref proj) => {\n                 let base = self.eval_lvalue(&proj.base)?;"}, {"sha": "b84680f7337837acf2c0b448d1c45ba6355f2b31", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 104, "deletions": 61, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=cc1ca73f5736a4aaa7a1ae164788051b8366fa3d", "patch": "@@ -6,13 +6,15 @@ use super::{\n };\n use error::EvalResult;\n use rustc::mir::repr as mir;\n-use rustc::ty::{self, subst};\n-use rustc::mir::visit::Visitor;\n+use rustc::ty::subst::{self, Subst};\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::visit::{Visitor, LvalueContext};\n use syntax::codemap::Span;\n use memory::Pointer;\n use std::rc::Rc;\n \n pub enum Event {\n+    Constant,\n     Assignment,\n     Terminator,\n     Done,\n@@ -26,21 +28,19 @@ pub struct Stepper<'fncx, 'a: 'fncx, 'b: 'a + 'mir, 'mir: 'fncx, 'tcx: 'b>{\n     mir: CachedMir<'mir, 'tcx>,\n     process: fn (&mut Stepper<'fncx, 'a, 'b, 'mir, 'tcx>) -> EvalResult<()>,\n     // a stack of constants\n-    constants: Vec<Vec<(ConstantId, Span)>>,\n+    constants: Vec<Vec<(ConstantId<'tcx>, Span, Pointer, CachedMir<'mir, 'tcx>)>>,\n }\n \n impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx> {\n     pub(super) fn new(fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>) -> Self {\n-        let mut stepper = Stepper {\n+        Stepper {\n             block: fncx.frame().next_block,\n             mir: fncx.mir(),\n             fncx: fncx,\n             stmt: vec![0],\n             process: Self::dummy,\n-            constants: Vec::new(),\n-        };\n-        stepper.extract_constants();\n-        stepper\n+            constants: vec![Vec::new()],\n+        }\n     }\n \n     fn dummy(&mut self) -> EvalResult<()> { Ok(()) }\n@@ -81,70 +81,86 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n                 self.block = self.fncx.frame().next_block;\n                 self.mir = self.fncx.mir();\n                 self.stmt.push(0);\n-                self.extract_constants();\n+                self.constants.push(Vec::new());\n             },\n         }\n         Ok(())\n     }\n \n-    fn alloc(&mut self, ty: ty::FnOutput<'tcx>) -> Pointer {\n-        match ty {\n-            ty::FnConverging(ty) => {\n-                let size = self.fncx.type_size(ty);\n-                self.fncx.memory.allocate(size)\n-            }\n-            ty::FnDiverging => panic!(\"there's no such thing as an unreachable static\"),\n-        }\n-    }\n-\n-    pub fn step(&mut self) -> EvalResult<Event> {\n-        (self.process)(self)?;\n-\n-        if self.fncx.stack.is_empty() {\n-            // fuse the iterator\n-            self.process = Self::dummy;\n-            return Ok(Event::Done);\n-        }\n-\n+    fn constant(&mut self) -> EvalResult<()> {\n         match self.constants.last_mut().unwrap().pop() {\n-            Some((ConstantId::Promoted { index }, span)) => {\n-                trace!(\"adding promoted constant {}\", index);\n-                let mir = self.mir.promoted[index].clone();\n-                let return_ptr = self.alloc(mir.return_ty);\n-                self.fncx.frame_mut().promoted.insert(index, return_ptr);\n+            Some((ConstantId::Promoted { index }, span, return_ptr, mir)) => {\n+                trace!(\"adding promoted constant {}, {:?}\", index, span);\n                 let substs = self.fncx.substs();\n                 // FIXME: somehow encode that this is a promoted constant's frame\n                 let def_id = self.fncx.frame().def_id;\n-                self.fncx.push_stack_frame(def_id, span, CachedMir::Owned(Rc::new(mir)), substs, Some(return_ptr));\n+                self.fncx.push_stack_frame(def_id, span, mir, substs, Some(return_ptr));\n                 self.stmt.push(0);\n                 self.constants.push(Vec::new());\n                 self.block = self.fncx.frame().next_block;\n                 self.mir = self.fncx.mir();\n             },\n-            Some((ConstantId::Static { def_id }, span)) => {\n-                trace!(\"adding static {:?}\", def_id);\n-                let mir = self.fncx.load_mir(def_id);\n-                let return_ptr = self.alloc(mir.return_ty);\n+            Some((ConstantId::Static { def_id, substs }, span, return_ptr, mir)) => {\n+                trace!(\"adding static {:?}, {:?}\", def_id, span);\n                 self.fncx.gecx.statics.insert(def_id, return_ptr);\n-                let substs = self.fncx.tcx.mk_substs(subst::Substs::empty());\n                 self.fncx.push_stack_frame(def_id, span, mir, substs, Some(return_ptr));\n                 self.stmt.push(0);\n                 self.constants.push(Vec::new());\n                 self.block = self.fncx.frame().next_block;\n                 self.mir = self.fncx.mir();\n             },\n-            None => {},\n+            None => unreachable!(),\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn step(&mut self) -> EvalResult<Event> {\n+        (self.process)(self)?;\n+\n+        if self.fncx.stack.is_empty() {\n+            // fuse the iterator\n+            self.process = Self::dummy;\n+            return Ok(Event::Done);\n+        }\n+\n+        if !self.constants.last().unwrap().is_empty() {\n+            self.process = Self::constant;\n+            return Ok(Event::Constant);\n         }\n \n         let basic_block = self.mir.basic_block_data(self.block);\n \n-        if basic_block.statements.len() > *self.stmt.last().unwrap() {\n-            self.process = Self::statement;\n-            return Ok(Event::Assignment);\n+        if let Some(ref stmt) = basic_block.statements.get(*self.stmt.last().unwrap()) {\n+            assert!(self.constants.last().unwrap().is_empty());\n+            ConstantExtractor {\n+                constants: &mut self.constants.last_mut().unwrap(),\n+                span: stmt.span,\n+                fncx: self.fncx,\n+                mir: &self.mir,\n+            }.visit_statement(self.block, stmt);\n+            if self.constants.last().unwrap().is_empty() {\n+                self.process = Self::statement;\n+                return Ok(Event::Assignment);\n+            } else {\n+                self.process = Self::constant;\n+                return Ok(Event::Constant);\n+            }\n         }\n \n-        self.process = Self::terminator;\n-        Ok(Event::Terminator)\n+        let terminator = basic_block.terminator();\n+        ConstantExtractor {\n+            constants: &mut self.constants.last_mut().unwrap(),\n+            span: terminator.span,\n+            fncx: self.fncx,\n+            mir: &self.mir,\n+        }.visit_terminator(self.block, terminator);\n+        if self.constants.last().unwrap().is_empty() {\n+            self.process = Self::terminator;\n+            Ok(Event::Terminator)\n+        } else {\n+            self.process = Self::constant;\n+            return Ok(Event::Constant);\n+        }\n     }\n \n     /// returns the basic block index of the currently processed block\n@@ -163,37 +179,64 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n         let block_data = self.mir.basic_block_data(self.block);\n         block_data.terminator()\n     }\n+}\n \n-    fn extract_constants(&mut self) {\n-        let mut extractor = ConstantExtractor {\n-            constants: Vec::new(),\n-        };\n-        extractor.visit_mir(&self.mir);\n-        self.constants.push(extractor.constants);\n-    }\n+struct ConstantExtractor<'a: 'c, 'b: 'a + 'mir + 'c, 'c, 'mir: 'c, 'tcx: 'a + 'b + 'c> {\n+    constants: &'c mut Vec<(ConstantId<'tcx>, Span, Pointer, CachedMir<'mir, 'tcx>)>,\n+    span: Span,\n+    mir: &'c mir::Mir<'tcx>,\n+    fncx: &'c mut FnEvalContext<'a, 'b, 'mir, 'tcx>,\n }\n \n-struct ConstantExtractor {\n-    constants: Vec<(ConstantId, Span)>,\n+impl<'a, 'b, 'c, 'mir, 'tcx> ConstantExtractor<'a, 'b, 'c, 'mir, 'tcx> {\n+    fn constant(&mut self, def_id: DefId, substs: &'tcx subst::Substs<'tcx>, span: Span) {\n+        if self.fncx.gecx.statics.contains_key(&def_id) {\n+            return;\n+        }\n+        let cid = ConstantId::Static {\n+            def_id: def_id,\n+            substs: substs,\n+        };\n+        let mir = self.fncx.load_mir(def_id);\n+        let ptr = self.fncx.alloc_ret_ptr(mir.return_ty).expect(\"there's no such thing as an unreachable static\");\n+        self.constants.push((cid, span, ptr, mir));\n+    }\n }\n \n-impl<'tcx> Visitor<'tcx> for ConstantExtractor {\n+impl<'a, 'b, 'c, 'mir, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'c, 'mir, 'tcx> {\n     fn visit_constant(&mut self, constant: &mir::Constant<'tcx>) {\n         self.super_constant(constant);\n         match constant.literal {\n             // already computed by rustc\n             mir::Literal::Value { .. } => {}\n-            mir::Literal::Item { .. } => {}, // FIXME: unimplemented\n+            mir::Literal::Item { def_id, substs } => {\n+                let item_ty = self.fncx.tcx.lookup_item_type(def_id).subst(self.fncx.tcx, substs);\n+                if item_ty.ty.is_fn() {\n+                    // unimplemented\n+                } else {\n+                    self.constant(def_id, substs, constant.span);\n+                }\n+            },\n             mir::Literal::Promoted { index } => {\n-                self.constants.push((ConstantId::Promoted { index: index }, constant.span));\n+                if self.fncx.frame().promoted.contains_key(&index) {\n+                    return;\n+                }\n+                let mir = self.mir.promoted[index].clone();\n+                let return_ty = mir.return_ty;\n+                let return_ptr = self.fncx.alloc_ret_ptr(return_ty).expect(\"there's no such thing as an unreachable static\");\n+                self.fncx.frame_mut().promoted.insert(index, return_ptr);\n+                let mir = CachedMir::Owned(Rc::new(mir));\n+                self.constants.push((ConstantId::Promoted { index: index }, constant.span, return_ptr, mir));\n             }\n         }\n     }\n \n-    fn visit_statement(&mut self, block: mir::BasicBlock, stmt: &mir::Statement<'tcx>) {\n-        self.super_statement(block, stmt);\n-        if let mir::StatementKind::Assign(mir::Lvalue::Static(def_id), _) = stmt.kind {\n-            self.constants.push((ConstantId::Static { def_id: def_id }, stmt.span));\n+    fn visit_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>, context: LvalueContext) {\n+        self.super_lvalue(lvalue, context);\n+        if let mir::Lvalue::Static(def_id) = *lvalue {\n+            let substs = self.fncx.tcx.mk_substs(subst::Substs::empty());\n+            let span = self.span;\n+            self.constant(def_id, substs, span);\n         }\n     }\n }"}, {"sha": "754d3d9ee7e6dc17860aa38bb73cc930feb5665f", "filename": "tests/compile-fail/unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d/tests%2Fcompile-fail%2Funimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d/tests%2Fcompile-fail%2Funimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funimplemented.rs?ref=cc1ca73f5736a4aaa7a1ae164788051b8366fa3d", "patch": "@@ -1,7 +1,7 @@\n #![feature(custom_attribute)]\n #![allow(dead_code, unused_attributes)]\n \n-//error-pattern:static should have been cached\n+//error-pattern:unimplemented: mentions of function items\n \n \n #[miri_run]"}, {"sha": "3d6b08c340df57ab8fd5a4980f1ce8ff409f1dce", "filename": "tests/run-pass/constants.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d/tests%2Frun-pass%2Fconstants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc1ca73f5736a4aaa7a1ae164788051b8366fa3d/tests%2Frun-pass%2Fconstants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconstants.rs?ref=cc1ca73f5736a4aaa7a1ae164788051b8366fa3d", "patch": "@@ -0,0 +1,11 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+const A: usize = *&5;\n+\n+#[miri_run]\n+fn foo() -> usize {\n+    A\n+}\n+\n+fn main() {}"}]}