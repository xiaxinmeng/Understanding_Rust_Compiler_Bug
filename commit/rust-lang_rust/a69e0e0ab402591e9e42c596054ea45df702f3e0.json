{"sha": "a69e0e0ab402591e9e42c596054ea45df702f3e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2OWUwZTBhYjQwMjU5MWU5ZTQyYzU5NjA1NGVhNDVkZjcwMmYzZTA=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-04T03:16:37Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-04T07:01:10Z"}, "message": "Rearrange `IntRange::from_{ctor,pat}()`.\n\nThis commit moves a lot of code around but doesn't change functionality\nat all. The main goal was for `from_pat()` to no longer call\n`from_ctor()`.\n\nThe increase in inlining resulted in less function call overhead, for a\n3% instruction count win on `unicode_normalization-check-clean`.", "tree": {"sha": "cd2ec97c808fbbb4dbaabdbe8debadd15f18a636", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd2ec97c808fbbb4dbaabdbe8debadd15f18a636"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a69e0e0ab402591e9e42c596054ea45df702f3e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a69e0e0ab402591e9e42c596054ea45df702f3e0", "html_url": "https://github.com/rust-lang/rust/commit/a69e0e0ab402591e9e42c596054ea45df702f3e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a69e0e0ab402591e9e42c596054ea45df702f3e0/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62ea39a1c95037dbdbfb49dc1b89d1b67562fddf", "url": "https://api.github.com/repos/rust-lang/rust/commits/62ea39a1c95037dbdbfb49dc1b89d1b67562fddf", "html_url": "https://github.com/rust-lang/rust/commit/62ea39a1c95037dbdbfb49dc1b89d1b67562fddf"}], "stats": {"total": 109, "additions": 69, "deletions": 40}, "files": [{"sha": "2a7be75650f29ddd09c8855e75edfe684e979145", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 69, "deletions": 40, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a69e0e0ab402591e9e42c596054ea45df702f3e0/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a69e0e0ab402591e9e42c596054ea45df702f3e0/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=a69e0e0ab402591e9e42c596054ea45df702f3e0", "patch": "@@ -834,44 +834,69 @@ struct IntRange<'tcx> {\n }\n \n impl<'tcx> IntRange<'tcx> {\n+    #[inline]\n+    fn is_integral(ty: Ty<'_>) -> bool {\n+        match ty.kind {\n+            ty::Char | ty::Int(_) | ty::Uint(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    #[inline]\n+    fn from_const(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &Const<'tcx>,\n+    ) -> Option<IntRange<'tcx>> {\n+        if Self::is_integral(value.ty) {\n+            let ty = value.ty;\n+            if let Some(val) = value.try_eval_bits(tcx, param_env, ty) {\n+                let bias = IntRange::signed_bias(tcx, ty);\n+                let val = val ^ bias;\n+                Some(IntRange { range: val..=val, ty })\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn from_range(\n+        tcx: TyCtxt<'tcx>,\n+        lo: u128,\n+        hi: u128,\n+        ty: Ty<'tcx>,\n+        end: &RangeEnd,\n+    ) -> Option<IntRange<'tcx>> {\n+        if Self::is_integral(ty) {\n+            // Perform a shift if the underlying types are signed,\n+            // which makes the interval arithmetic simpler.\n+            let bias = IntRange::signed_bias(tcx, ty);\n+            let (lo, hi) = (lo ^ bias, hi ^ bias);\n+            // Make sure the interval is well-formed.\n+            if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n+                None\n+            } else {\n+                let offset = (*end == RangeEnd::Excluded) as u128;\n+                Some(IntRange { range: lo..=(hi - offset), ty })\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn from_ctor(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         ctor: &Constructor<'tcx>,\n     ) -> Option<IntRange<'tcx>> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n-        fn is_integral(ty: Ty<'_>) -> bool {\n-            match ty.kind {\n-                ty::Char | ty::Int(_) | ty::Uint(_) => true,\n-                _ => false,\n-            }\n-        }\n-\n         match ctor {\n-            ConstantRange(lo, hi, ty, end) if is_integral(ty) => {\n-                // Perform a shift if the underlying types are signed,\n-                // which makes the interval arithmetic simpler.\n-                let bias = IntRange::signed_bias(tcx, ty);\n-                let (lo, hi) = (lo ^ bias, hi ^ bias);\n-                // Make sure the interval is well-formed.\n-                if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n-                    None\n-                } else {\n-                    let offset = (*end == RangeEnd::Excluded) as u128;\n-                    Some(IntRange { range: lo..=(hi - offset), ty })\n-                }\n-            }\n-            ConstantValue(val) if is_integral(val.ty) => {\n-                let ty = val.ty;\n-                if let Some(val) = val.try_eval_bits(tcx, param_env, ty) {\n-                    let bias = IntRange::signed_bias(tcx, ty);\n-                    let val = val ^ bias;\n-                    Some(IntRange { range: val..=val, ty })\n-                } else {\n-                    None\n-                }\n-            }\n+            ConstantRange(lo, hi, ty, end) => Self::from_range(tcx, *lo, *hi, ty, end),\n+            ConstantValue(val) => Self::from_const(tcx, param_env, val),\n             _ => None,\n         }\n     }\n@@ -881,22 +906,26 @@ impl<'tcx> IntRange<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         mut pat: &Pat<'tcx>,\n     ) -> Option<IntRange<'tcx>> {\n-        let range = loop {\n+        loop {\n             match pat.kind {\n-                box PatKind::Constant { value } => break ConstantValue(value),\n-                box PatKind::Range(PatRange { lo, hi, end }) => break ConstantRange(\n-                    lo.eval_bits(tcx, param_env, lo.ty),\n-                    hi.eval_bits(tcx, param_env, hi.ty),\n-                    lo.ty,\n-                    end,\n-                ),\n+                box PatKind::Constant { value } => {\n+                    return Self::from_const(tcx, param_env, value);\n+                }\n+                box PatKind::Range(PatRange { lo, hi, end }) => {\n+                    return Self::from_range(\n+                        tcx,\n+                        lo.eval_bits(tcx, param_env, lo.ty),\n+                        hi.eval_bits(tcx, param_env, hi.ty),\n+                        &lo.ty,\n+                        &end,\n+                    );\n+                }\n                 box PatKind::AscribeUserType { ref subpattern, .. } => {\n                     pat = subpattern;\n                 },\n                 _ => return None,\n             }\n-        };\n-        Self::from_ctor(tcx, param_env, &range)\n+        }\n     }\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it."}]}