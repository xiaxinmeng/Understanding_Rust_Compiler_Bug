{"sha": "28cc0c5a7b538452c7495b42b32e09b006c38b82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4Y2MwYzVhN2I1Mzg0NTJjNzQ5NWI0MmIzMmUwOWIwMDZjMzhiODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-18T10:41:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-18T10:41:05Z"}, "message": "Auto merge of #42593 - ibabushkin:on-demand-external-source, r=eddyb\n\nImplement lazy loading of external crates' sources. Fixes #38875\n\nFixes #38875. This is a follow-up to #42507. When a (now correctly translated) span from an external crate is referenced in a error, warning or info message, we still don't have the source code being referenced.\nSince stuffing the source in the serialized metadata of an rlib is extremely wasteful, the following scheme has been implemented:\n\n* File maps now contain a source hash that gets serialized as well.\n* When a span is rendered in a message, the source hash in the corresponding file map(s) is used to try and load the source from the corresponding file on disk. If the file is not found or the hashes don't match, the failed attempt is recorded (and not retried).\n* The machinery fetching source lines from file maps is augmented to use the lazily loaded external source as a secondary fallback for file maps belonging to external crates.\n\nThis required a small change to the expected stderr of one UI test (it now renders a span, where previously was none).\n\nFurther work can be done based on this - some of the machinery previously used to hide external spans is possibly obsolete and the hashing code can be reused in different places as well.\n\nr? @eddyb", "tree": {"sha": "7d4e974a1f310aae2711ee01fcb5126d1931f9e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d4e974a1f310aae2711ee01fcb5126d1931f9e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28cc0c5a7b538452c7495b42b32e09b006c38b82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28cc0c5a7b538452c7495b42b32e09b006c38b82", "html_url": "https://github.com/rust-lang/rust/commit/28cc0c5a7b538452c7495b42b32e09b006c38b82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28cc0c5a7b538452c7495b42b32e09b006c38b82/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78d8416caf65cfb50de61bb9423e9efa026bd45a", "url": "https://api.github.com/repos/rust-lang/rust/commits/78d8416caf65cfb50de61bb9423e9efa026bd45a", "html_url": "https://github.com/rust-lang/rust/commit/78d8416caf65cfb50de61bb9423e9efa026bd45a"}, {"sha": "bd4fe454050fa6ac8c74bc1ee70e0b4b909d245e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd4fe454050fa6ac8c74bc1ee70e0b4b909d245e", "html_url": "https://github.com/rust-lang/rust/commit/bd4fe454050fa6ac8c74bc1ee70e0b4b909d245e"}], "stats": {"total": 338, "additions": 257, "deletions": 81}, "files": [{"sha": "8086434096083a456a6741b93c612f0d12547b5f", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -1682,6 +1682,7 @@ dependencies = [\n name = \"syntax_pos\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n ]\n "}, {"sha": "b9cc3b5fb937fe1927ecba066a1e2d5f4940b3dd", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -336,6 +336,8 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for FileMa\n             crate_of_origin,\n             // Do not hash the source as it is not encoded\n             src: _,\n+            src_hash,\n+            external_src: _,\n             start_pos,\n             end_pos: _,\n             ref lines,\n@@ -350,6 +352,8 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for FileMa\n             index: CRATE_DEF_INDEX,\n         }.hash_stable(hcx, hasher);\n \n+        src_hash.hash_stable(hcx, hasher);\n+\n         // We only hash the relative position within this filemap\n         let lines = lines.borrow();\n         lines.len().hash_stable(hcx, hasher);"}, {"sha": "5e291ea3c152b7e00caa0fcb571f9cd09ef9ba17", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -78,6 +78,17 @@ impl StableHasherResult for [u8; 20] {\n     }\n }\n \n+impl StableHasherResult for u128 {\n+    fn finish(mut hasher: StableHasher<Self>) -> Self {\n+        let hash_bytes: &[u8] = hasher.finalize();\n+        assert!(hash_bytes.len() >= mem::size_of::<u128>());\n+\n+        unsafe {\n+            ::std::ptr::read_unaligned(hash_bytes.as_ptr() as *const u128)\n+        }\n+    }\n+}\n+\n impl StableHasherResult for u64 {\n     fn finish(mut hasher: StableHasher<Self>) -> Self {\n         hasher.state.finalize();"}, {"sha": "2d25d12d3a96e437ffec77d1a8b655498207ab18", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -17,6 +17,7 @@ use RenderSpan::*;\n use snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n use styled_buffer::StyledBuffer;\n \n+use std::borrow::Cow;\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n@@ -131,7 +132,7 @@ impl EmitterWriter {\n         }\n     }\n \n-    fn preprocess_annotations(&self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n+    fn preprocess_annotations(&mut self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n         fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n                                   file: Rc<FileMap>,\n                                   line_index: usize,\n@@ -175,6 +176,7 @@ impl EmitterWriter {\n                 if span_label.span == DUMMY_SP {\n                     continue;\n                 }\n+\n                 let lo = cm.lookup_char_pos(span_label.span.lo);\n                 let mut hi = cm.lookup_char_pos(span_label.span.hi);\n \n@@ -890,10 +892,10 @@ impl EmitterWriter {\n         let mut annotated_files = self.preprocess_annotations(msp);\n \n         // Make sure our primary file comes first\n-        let primary_lo = if let (Some(ref cm), Some(ref primary_span)) =\n+        let (primary_lo, cm) = if let (Some(cm), Some(ref primary_span)) =\n             (self.cm.as_ref(), msp.primary_span().as_ref()) {\n             if primary_span != &&DUMMY_SP {\n-                cm.lookup_char_pos(primary_span.lo)\n+                (cm.lookup_char_pos(primary_span.lo), cm)\n             } else {\n                 emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n                 return Ok(());\n@@ -911,7 +913,7 @@ impl EmitterWriter {\n         // Print out the annotate source lines that correspond with the error\n         for annotated_file in annotated_files {\n             // we can't annotate anything if the source is unavailable.\n-            if annotated_file.file.src.is_none() {\n+            if !cm.ensure_filemap_source_present(annotated_file.file.clone()) {\n                 continue;\n             }\n \n@@ -1012,7 +1014,7 @@ impl EmitterWriter {\n                     } else if line_idx_delta == 2 {\n                         let unannotated_line = annotated_file.file\n                             .get_line(annotated_file.lines[line_idx].line_index)\n-                            .unwrap_or(\"\");\n+                            .unwrap_or_else(|| Cow::from(\"\"));\n \n                         let last_buffer_line_num = buffer.num_lines();\n "}, {"sha": "975b720276e82b8d58c80becad14bc8e396bd147", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -37,6 +37,7 @@ use self::Level::*;\n \n use emitter::{Emitter, EmitterWriter};\n \n+use std::borrow::Cow;\n use std::cell::{RefCell, Cell};\n use std::{error, fmt};\n use std::rc::Rc;\n@@ -49,7 +50,7 @@ pub mod registry;\n pub mod styled_buffer;\n mod lock;\n \n-use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION};\n+use syntax_pos::{BytePos, Loc, FileLinesResult, FileMap, FileName, MultiSpan, Span, NO_EXPANSION};\n \n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum RenderSpan {\n@@ -103,6 +104,7 @@ pub trait CodeMapper {\n     fn span_to_filename(&self, sp: Span) -> FileName;\n     fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span>;\n     fn call_span_if_macro(&self, sp: Span) -> Span;\n+    fn ensure_filemap_source_present(&self, file_map: Rc<FileMap>) -> bool;\n }\n \n impl CodeSuggestion {\n@@ -121,7 +123,7 @@ impl CodeSuggestion {\n         use syntax_pos::{CharPos, Loc, Pos};\n \n         fn push_trailing(buf: &mut String,\n-                         line_opt: Option<&str>,\n+                         line_opt: Option<&Cow<str>>,\n                          lo: &Loc,\n                          hi_opt: Option<&Loc>) {\n             let (lo, hi_opt) = (lo.col.to_usize(), hi_opt.map(|hi| hi.col.to_usize()));\n@@ -183,13 +185,13 @@ impl CodeSuggestion {\n             let cur_lo = cm.lookup_char_pos(sp.lo);\n             for (buf, substitute) in bufs.iter_mut().zip(substitutes) {\n                 if prev_hi.line == cur_lo.line {\n-                    push_trailing(buf, prev_line, &prev_hi, Some(&cur_lo));\n+                    push_trailing(buf, prev_line.as_ref(), &prev_hi, Some(&cur_lo));\n                 } else {\n-                    push_trailing(buf, prev_line, &prev_hi, None);\n+                    push_trailing(buf, prev_line.as_ref(), &prev_hi, None);\n                     // push lines between the previous and current span (if any)\n                     for idx in prev_hi.line..(cur_lo.line - 1) {\n                         if let Some(line) = fm.get_line(idx) {\n-                            buf.push_str(line);\n+                            buf.push_str(line.as_ref());\n                             buf.push('\\n');\n                         }\n                     }\n@@ -205,7 +207,7 @@ impl CodeSuggestion {\n         for buf in &mut bufs {\n             // if the replacement already ends with a newline, don't print the next line\n             if !buf.ends_with('\\n') {\n-                push_trailing(buf, prev_line, &prev_hi, None);\n+                push_trailing(buf, prev_line.as_ref(), &prev_hi, None);\n             }\n             // remove trailing newline\n             buf.pop();"}, {"sha": "728ab30bb17dc6a63e1fc649f5a07271a9f60952", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -765,7 +765,7 @@ impl<'a, 'tcx> CrateMetadata {\n         assert!(!self.is_proc_macro(id));\n         let ast = self.entry(id).ast.unwrap();\n         let def_id = self.local_def_id(id);\n-        let body = ast.decode(self).body.decode(self);\n+        let body = ast.decode((self, tcx)).body.decode((self, tcx));\n         tcx.hir.intern_inlined_body(def_id, body)\n     }\n \n@@ -1149,6 +1149,7 @@ impl<'a, 'tcx> CrateMetadata {\n             // containing the information we need.\n             let syntax_pos::FileMap { name,\n                                       name_was_remapped,\n+                                      src_hash,\n                                       start_pos,\n                                       end_pos,\n                                       lines,\n@@ -1174,6 +1175,7 @@ impl<'a, 'tcx> CrateMetadata {\n             let local_version = local_codemap.new_imported_filemap(name,\n                                                                    name_was_remapped,\n                                                                    self.cnum.as_u32(),\n+                                                                   src_hash,\n                                                                    source_length,\n                                                                    lines,\n                                                                    multibyte_chars);"}, {"sha": "b3d9cf9da36c7669320cb43b956040b5fab6c36d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 39, "deletions": 46, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -158,29 +158,13 @@ impl CodeMap {\n \n     /// Creates a new filemap without setting its line information. If you don't\n     /// intend to set the line information yourself, you should use new_filemap_and_lines.\n-    pub fn new_filemap(&self, filename: FileName, mut src: String) -> Rc<FileMap> {\n+    pub fn new_filemap(&self, filename: FileName, src: String) -> Rc<FileMap> {\n         let start_pos = self.next_start_pos();\n         let mut files = self.files.borrow_mut();\n \n-        // Remove utf-8 BOM if any.\n-        if src.starts_with(\"\\u{feff}\") {\n-            src.drain(..3);\n-        }\n-\n-        let end_pos = start_pos + src.len();\n-\n         let (filename, was_remapped) = self.path_mapping.map_prefix(filename);\n-\n-        let filemap = Rc::new(FileMap {\n-            name: filename,\n-            name_was_remapped: was_remapped,\n-            crate_of_origin: 0,\n-            src: Some(Rc::new(src)),\n-            start_pos: Pos::from_usize(start_pos),\n-            end_pos: Pos::from_usize(end_pos),\n-            lines: RefCell::new(Vec::new()),\n-            multibyte_chars: RefCell::new(Vec::new()),\n-        });\n+        let filemap =\n+            Rc::new(FileMap::new(filename, was_remapped, src, Pos::from_usize(start_pos)));\n \n         files.push(filemap.clone());\n \n@@ -210,6 +194,7 @@ impl CodeMap {\n                                 filename: FileName,\n                                 name_was_remapped: bool,\n                                 crate_of_origin: u32,\n+                                src_hash: u128,\n                                 source_len: usize,\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>)\n@@ -233,6 +218,8 @@ impl CodeMap {\n             name_was_remapped: name_was_remapped,\n             crate_of_origin: crate_of_origin,\n             src: None,\n+            src_hash: src_hash,\n+            external_src: RefCell::new(ExternalSource::AbsentOk),\n             start_pos: start_pos,\n             end_pos: end_pos,\n             lines: RefCell::new(file_local_lines),\n@@ -428,30 +415,31 @@ impl CodeMap {\n                       local_end.fm.start_pos)\n             }));\n         } else {\n-            match local_begin.fm.src {\n-                Some(ref src) => {\n-                    let start_index = local_begin.pos.to_usize();\n-                    let end_index = local_end.pos.to_usize();\n-                    let source_len = (local_begin.fm.end_pos -\n-                                      local_begin.fm.start_pos).to_usize();\n-\n-                    if start_index > end_index || end_index > source_len {\n-                        return Err(SpanSnippetError::MalformedForCodemap(\n-                            MalformedCodemapPositions {\n-                                name: local_begin.fm.name.clone(),\n-                                source_len: source_len,\n-                                begin_pos: local_begin.pos,\n-                                end_pos: local_end.pos,\n-                            }));\n-                    }\n-\n-                    return Ok((&src[start_index..end_index]).to_string())\n-                }\n-                None => {\n-                    return Err(SpanSnippetError::SourceNotAvailable {\n-                        filename: local_begin.fm.name.clone()\n-                    });\n-                }\n+            self.ensure_filemap_source_present(local_begin.fm.clone());\n+\n+            let start_index = local_begin.pos.to_usize();\n+            let end_index = local_end.pos.to_usize();\n+            let source_len = (local_begin.fm.end_pos -\n+                              local_begin.fm.start_pos).to_usize();\n+\n+            if start_index > end_index || end_index > source_len {\n+                return Err(SpanSnippetError::MalformedForCodemap(\n+                    MalformedCodemapPositions {\n+                        name: local_begin.fm.name.clone(),\n+                        source_len: source_len,\n+                        begin_pos: local_begin.pos,\n+                        end_pos: local_end.pos,\n+                    }));\n+            }\n+\n+            if let Some(ref src) = local_begin.fm.src {\n+                return Ok((&src[start_index..end_index]).to_string());\n+            } else if let Some(src) = local_begin.fm.external_src.borrow().get_source() {\n+                return Ok((&src[start_index..end_index]).to_string());\n+            } else {\n+                return Err(SpanSnippetError::SourceNotAvailable {\n+                    filename: local_begin.fm.name.clone()\n+                });\n             }\n         }\n     }\n@@ -572,6 +560,10 @@ impl CodeMapper for CodeMap {\n         }\n         sp\n     }\n+    fn ensure_filemap_source_present(&self, file_map: Rc<FileMap>) -> bool {\n+        let src = self.file_loader.read_file(Path::new(&file_map.name)).ok();\n+        return file_map.add_external_src(src)\n+    }\n }\n \n #[derive(Clone)]\n@@ -617,6 +609,7 @@ impl FilePathMapping {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use std::borrow::Cow;\n     use std::rc::Rc;\n \n     #[test]\n@@ -626,12 +619,12 @@ mod tests {\n                                 \"first line.\\nsecond line\".to_string());\n         fm.next_line(BytePos(0));\n         // Test we can get lines with partial line info.\n-        assert_eq!(fm.get_line(0), Some(\"first line.\"));\n+        assert_eq!(fm.get_line(0), Some(Cow::from(\"first line.\")));\n         // TESTING BROKEN BEHAVIOR: line break declared before actual line break.\n         fm.next_line(BytePos(10));\n-        assert_eq!(fm.get_line(1), Some(\".\"));\n+        assert_eq!(fm.get_line(1), Some(Cow::from(\".\")));\n         fm.next_line(BytePos(12));\n-        assert_eq!(fm.get_line(2), Some(\"second line\"));\n+        assert_eq!(fm.get_line(2), Some(Cow::from(\"second line\")));\n     }\n \n     #[test]"}, {"sha": "e60edafe4ee441aba879abdf67918881685e6c8b", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -314,7 +314,7 @@ impl DiagnosticSpanLine {\n                          h_end: usize)\n                          -> DiagnosticSpanLine {\n         DiagnosticSpanLine {\n-            text: fm.get_line(index).unwrap_or(\"\").to_owned(),\n+            text: fm.get_line(index).map_or(String::new(), |l| l.into_owned()),\n             highlight_start: h_start,\n             highlight_end: h_end,\n         }"}, {"sha": "dd8129bab510fc28d7381b4c20a3fe614efb4c5b", "filename": "src/libsyntax_pos/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibsyntax_pos%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibsyntax_pos%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2FCargo.toml?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -10,3 +10,4 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n serialize = { path = \"../libserialize\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "94656b3aea79e0f5f24e77b94619f2e5fbe47ed6", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 135, "deletions": 22, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -24,6 +24,7 @@\n \n #![feature(const_fn)]\n #![feature(custom_attribute)]\n+#![feature(i128_type)]\n #![feature(optin_builtin_traits)]\n #![allow(unused_attributes)]\n #![feature(specialization)]\n@@ -32,12 +33,17 @@\n #![cfg_attr(stage0, feature(rustc_private))]\n #![cfg_attr(stage0, feature(staged_api))]\n \n+use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::ops::{Add, Sub};\n use std::rc::Rc;\n use std::cmp;\n-\n use std::fmt;\n+use std::hash::Hasher;\n+\n+use rustc_data_structures::stable_hasher::StableHasher;\n+\n+extern crate rustc_data_structures;\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -369,6 +375,35 @@ pub struct MultiByteChar {\n     pub bytes: usize,\n }\n \n+/// The state of the lazy external source loading mechanism of a FileMap.\n+#[derive(PartialEq, Eq, Clone)]\n+pub enum ExternalSource {\n+    /// The external source has been loaded already.\n+    Present(String),\n+    /// No attempt has been made to load the external source.\n+    AbsentOk,\n+    /// A failed attempt has been made to load the external source.\n+    AbsentErr,\n+    /// No external source has to be loaded, since the FileMap represents a local crate.\n+    Unneeded,\n+}\n+\n+impl ExternalSource {\n+    pub fn is_absent(&self) -> bool {\n+        match *self {\n+            ExternalSource::Present(_) => false,\n+            _ => true,\n+        }\n+    }\n+\n+    pub fn get_source(&self) -> Option<&str> {\n+        match *self {\n+            ExternalSource::Present(ref src) => Some(src),\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// A single source in the CodeMap.\n #[derive(Clone)]\n pub struct FileMap {\n@@ -382,6 +417,11 @@ pub struct FileMap {\n     pub crate_of_origin: u32,\n     /// The complete source code\n     pub src: Option<Rc<String>>,\n+    /// The source code's hash\n+    pub src_hash: u128,\n+    /// The external source code (used for external crates, which will have a `None`\n+    /// value as `self.src`.\n+    pub external_src: RefCell<ExternalSource>,\n     /// The start position of this source in the CodeMap\n     pub start_pos: BytePos,\n     /// The end position of this source in the CodeMap\n@@ -394,9 +434,10 @@ pub struct FileMap {\n \n impl Encodable for FileMap {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(\"FileMap\", 6, |s| {\n+        s.emit_struct(\"FileMap\", 7, |s| {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n             s.emit_struct_field(\"name_was_remapped\", 1, |s| self.name_was_remapped.encode(s))?;\n+            s.emit_struct_field(\"src_hash\", 6, |s| self.src_hash.encode(s))?;\n             s.emit_struct_field(\"start_pos\", 2, |s| self.start_pos.encode(s))?;\n             s.emit_struct_field(\"end_pos\", 3, |s| self.end_pos.encode(s))?;\n             s.emit_struct_field(\"lines\", 4, |s| {\n@@ -459,7 +500,10 @@ impl Decodable for FileMap {\n             let name: String = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n             let name_was_remapped: bool =\n                 d.read_struct_field(\"name_was_remapped\", 1, |d| Decodable::decode(d))?;\n-            let start_pos: BytePos = d.read_struct_field(\"start_pos\", 2, |d| Decodable::decode(d))?;\n+            let src_hash: u128 =\n+                d.read_struct_field(\"src_hash\", 6, |d| Decodable::decode(d))?;\n+            let start_pos: BytePos =\n+                d.read_struct_field(\"start_pos\", 2, |d| Decodable::decode(d))?;\n             let end_pos: BytePos = d.read_struct_field(\"end_pos\", 3, |d| Decodable::decode(d))?;\n             let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 4, |d| {\n                 let num_lines: u32 = Decodable::decode(d)?;\n@@ -501,6 +545,8 @@ impl Decodable for FileMap {\n                 start_pos: start_pos,\n                 end_pos: end_pos,\n                 src: None,\n+                src_hash: src_hash,\n+                external_src: RefCell::new(ExternalSource::AbsentOk),\n                 lines: RefCell::new(lines),\n                 multibyte_chars: RefCell::new(multibyte_chars)\n             })\n@@ -515,6 +561,32 @@ impl fmt::Debug for FileMap {\n }\n \n impl FileMap {\n+    pub fn new(name: FileName,\n+               name_was_remapped: bool,\n+               mut src: String,\n+               start_pos: BytePos) -> FileMap {\n+        remove_bom(&mut src);\n+\n+        let mut hasher: StableHasher<u128> = StableHasher::new();\n+        hasher.write(src.as_bytes());\n+        let src_hash = hasher.finish();\n+\n+        let end_pos = start_pos.to_usize() + src.len();\n+\n+        FileMap {\n+            name: name,\n+            name_was_remapped: name_was_remapped,\n+            crate_of_origin: 0,\n+            src: Some(Rc::new(src)),\n+            src_hash: src_hash,\n+            external_src: RefCell::new(ExternalSource::Unneeded),\n+            start_pos: start_pos,\n+            end_pos: Pos::from_usize(end_pos),\n+            lines: RefCell::new(Vec::new()),\n+            multibyte_chars: RefCell::new(Vec::new()),\n+        }\n+    }\n+\n     /// EFFECT: register a start-of-line offset in the\n     /// table of line-beginnings.\n     /// UNCHECKED INVARIANT: these offsets must be added in the right\n@@ -532,26 +604,60 @@ impl FileMap {\n         lines.push(pos);\n     }\n \n-    /// get a line from the list of pre-computed line-beginnings.\n-    /// line-number here is 0-based.\n-    pub fn get_line(&self, line_number: usize) -> Option<&str> {\n-        match self.src {\n-            Some(ref src) => {\n-                let lines = self.lines.borrow();\n-                lines.get(line_number).map(|&line| {\n-                    let begin: BytePos = line - self.start_pos;\n-                    let begin = begin.to_usize();\n-                    // We can't use `lines.get(line_number+1)` because we might\n-                    // be parsing when we call this function and thus the current\n-                    // line is the last one we have line info for.\n-                    let slice = &src[begin..];\n-                    match slice.find('\\n') {\n-                        Some(e) => &slice[..e],\n-                        None => slice\n-                    }\n-                })\n+    /// Add externally loaded source.\n+    /// If the hash of the input doesn't match or no input is supplied via None,\n+    /// it is interpreted as an error and the corresponding enum variant is set.\n+    /// The return value signifies whether some kind of source is present.\n+    pub fn add_external_src(&self, src: Option<String>) -> bool {\n+        if *self.external_src.borrow() == ExternalSource::AbsentOk {\n+            let mut external_src = self.external_src.borrow_mut();\n+            if let Some(src) = src {\n+                let mut hasher: StableHasher<u128> = StableHasher::new();\n+                hasher.write(src.as_bytes());\n+\n+                if hasher.finish() == self.src_hash {\n+                    *external_src = ExternalSource::Present(src);\n+                    return true;\n+                }\n+            } else {\n+                *external_src = ExternalSource::AbsentErr;\n             }\n-            None => None\n+\n+            false\n+        } else {\n+            self.src.is_some() || self.external_src.borrow().get_source().is_some()\n+        }\n+    }\n+\n+    /// Get a line from the list of pre-computed line-beginnings.\n+    /// The line number here is 0-based.\n+    pub fn get_line(&self, line_number: usize) -> Option<Cow<str>> {\n+        fn get_until_newline(src: &str, begin: usize) -> &str {\n+            // We can't use `lines.get(line_number+1)` because we might\n+            // be parsing when we call this function and thus the current\n+            // line is the last one we have line info for.\n+            let slice = &src[begin..];\n+            match slice.find('\\n') {\n+                Some(e) => &slice[..e],\n+                None => slice\n+            }\n+        }\n+\n+        let lines = self.lines.borrow();\n+        let line = if let Some(line) = lines.get(line_number) {\n+            line\n+        } else {\n+            return None;\n+        };\n+        let begin: BytePos = *line - self.start_pos;\n+        let begin = begin.to_usize();\n+\n+        if let Some(ref src) = self.src {\n+            Some(Cow::from(get_until_newline(src, begin)))\n+        } else if let Some(src) = self.external_src.borrow().get_source() {\n+            Some(Cow::Owned(String::from(get_until_newline(src, begin))))\n+        } else {\n+            None\n         }\n     }\n \n@@ -614,6 +720,13 @@ impl FileMap {\n     }\n }\n \n+/// Remove utf-8 BOM if any.\n+fn remove_bom(src: &mut String) {\n+    if src.starts_with(\"\\u{feff}\") {\n+        src.drain(..3);\n+    }\n+}\n+\n // _____________________________________________________________________________\n // Pos, BytePos, CharPos\n //"}, {"sha": "dd58735209b8f2e3dff27a5cd79f13a3ac88ae44", "filename": "src/test/ui/issue-38875/auxiliary/issue_38875_b.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Ftest%2Fui%2Fissue-38875%2Fauxiliary%2Fissue_38875_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Ftest%2Fui%2Fissue-38875%2Fauxiliary%2Fissue_38875_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-38875%2Fauxiliary%2Fissue_38875_b.rs?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub const FOO: usize = *&0;"}, {"sha": "42e3c05a38c7e459ed58b3f5e9574ec8a31cc556", "filename": "src/test/ui/issue-38875/issue_38875.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.rs?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue_38875_b.rs\n+\n+extern crate issue_38875_b;\n+\n+fn main() {\n+    let test_x = [0; issue_38875_b::FOO];\n+}"}, {"sha": "ceed83d9313cdbe14cf928eb1558593b0da77397", "filename": "src/test/ui/issue-38875/issue_38875.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -0,0 +1,14 @@\n+error[E0080]: constant evaluation error\n+  --> $DIR/auxiliary/issue_38875_b.rs:11:24\n+   |\n+11 | pub const FOO: usize = *&0;\n+   |                        ^^^ unimplemented constant expression: deref operation\n+   |\n+note: for repeat count here\n+  --> $DIR/issue_38875.rs:16:22\n+   |\n+16 |     let test_x = [0; issue_38875_b::FOO];\n+   |                      ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error(s)\n+"}, {"sha": "b7b1ddb7b88d8ca54c1f219ffd271a77e56661b1", "filename": "src/test/ui/issue-41652/issue_41652.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Ftest%2Fui%2Fissue-41652%2Fissue_41652.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28cc0c5a7b538452c7495b42b32e09b006c38b82/src%2Ftest%2Fui%2Fissue-41652%2Fissue_41652.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-41652%2Fissue_41652.stderr?ref=28cc0c5a7b538452c7495b42b32e09b006c38b82", "patch": "@@ -6,6 +6,11 @@ error[E0599]: no method named `f` found for type `{integer}` in the current scop\n    |\n    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n note: candidate #1 is defined in the trait `issue_41652_b::Tr`\n+  --> $DIR/auxiliary/issue_41652_b.rs:14:5\n+   |\n+14 | /     fn f()\n+15 | |         where Self: Sized;\n+   | |__________________________^\n    = help: to disambiguate the method call, write `issue_41652_b::Tr::f(3)` instead\n \n error: aborting due to previous error(s)"}]}