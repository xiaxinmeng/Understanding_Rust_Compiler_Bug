{"sha": "ff6b71f78bd00a93a91691bb297d6a379cdc50fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNmI3MWY3OGJkMDBhOTNhOTE2OTFiYjI5N2Q2YTM3OWNkYzUwZmE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-15T00:39:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-15T00:45:17Z"}, "message": "core: Add core::future\n\nFutures will be required for upcoming changes to the task API", "tree": {"sha": "9c10da4361d5ca217ca510ec2d1887645c876a36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c10da4361d5ca217ca510ec2d1887645c876a36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff6b71f78bd00a93a91691bb297d6a379cdc50fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6b71f78bd00a93a91691bb297d6a379cdc50fa", "html_url": "https://github.com/rust-lang/rust/commit/ff6b71f78bd00a93a91691bb297d6a379cdc50fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff6b71f78bd00a93a91691bb297d6a379cdc50fa/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "859e0256524a1f19ca0c79f518d2bb396355f174", "url": "https://api.github.com/repos/rust-lang/rust/commits/859e0256524a1f19ca0c79f518d2bb396355f174", "html_url": "https://github.com/rust-lang/rust/commit/859e0256524a1f19ca0c79f518d2bb396355f174"}], "stats": {"total": 158, "additions": 157, "deletions": 1}, "files": [{"sha": "868762a090f0664b2a2f1c8f9ce70fdfde8cbe04", "filename": "src/libcore/core.rc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff6b71f78bd00a93a91691bb297d6a379cdc50fa/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ff6b71f78bd00a93a91691bb297d6a379cdc50fa/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=ff6b71f78bd00a93a91691bb297d6a379cdc50fa", "patch": "@@ -80,9 +80,12 @@ mod math;\n mod cmath;\n mod sys;\n mod unsafe;\n+mod logging;\n+\n+// Concurrency\n mod comm;\n mod task;\n-mod logging;\n+mod future;\n \n // Compiler support modules\n "}, {"sha": "ae90b9035188cd9d3b55cc26def5fc9e0b969a15", "filename": "src/libcore/future.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/ff6b71f78bd00a93a91691bb297d6a379cdc50fa/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff6b71f78bd00a93a91691bb297d6a379cdc50fa/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=ff6b71f78bd00a93a91691bb297d6a379cdc50fa", "patch": "@@ -0,0 +1,153 @@\n+#[doc = \"\n+\n+A type representing values that may be computed concurrently and\n+operations for working with them.\n+\n+Example:\n+\n+> let delayed_fib = future::spawn {|| fib(5000) };\n+> make_a_sandwitch();\n+> io::println(#fmt(\\\"fib(5000) = %?\\\", delayed_fib.get()))\n+\n+\"];\n+\n+export future;\n+export future::{};\n+export from_value;\n+export from_port;\n+export get;\n+export with;\n+export spawn;\n+\n+import either = either::t;\n+\n+#[doc = \"The future type\"]\n+enum future<A> = {\n+    mutable v: either<@A, comm::port<A>>\n+};\n+\n+#[doc = \"Methods on the `future` type\"]\n+impl future<A:send> for future<A> {\n+\n+    fn get() -> A {\n+        #[doc = \"Get the value of the future\"];\n+\n+        get(self)\n+    }\n+\n+    fn with<B>(blk: fn(A) -> B) -> B {\n+        #[doc = \"Work with the value without copying it\"];\n+\n+        with(self, blk)\n+    }\n+}\n+\n+fn from_value<A>(+val: A) -> future<A> {\n+    #[doc = \"\n+\n+    Create a future from a value. The value is immediately available\n+    and calling `get` later will not block.\n+\n+    \"];\n+\n+    future({\n+        mutable v: either::left(@val)\n+    })\n+}\n+\n+fn from_port<A>(-port: comm::port<A>) -> future<A> {\n+    #[doc = \"\n+\n+    Create a future from a port. The first time that the value is\n+    requested the task will block waiting for the result to be\n+    received on the port.\n+\n+    \"];\n+\n+    future({\n+        mutable v: either::right(port)\n+    })\n+}\n+\n+fn get<A:send>(future: future<A>) -> A {\n+    #[doc = \"Get the value of the future\"];\n+\n+    with(future) {|v| v }\n+}\n+\n+fn with<A:send,B>(future: future<A>, blk: fn(A) -> B) -> B {\n+    #[doc = \"Work with the value without copying it\"];\n+\n+    let v = alt future.v {\n+      either::left(v) { v }\n+      either::right(po) {\n+        let v = @comm::recv(po);\n+        future.v = either::left(v);\n+        v\n+      }\n+    };\n+    blk(*v)\n+}\n+\n+fn spawn<A:send>(+blk: fn~() -> A) -> future<A> {\n+    #[doc = \"\n+\n+    Create a future from a unique closure. The closure will be run\n+    in a new task and its result used as the value of the future.\n+\n+    \"];\n+\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n+    task::spawn {||\n+        comm::send(ch, blk())\n+    };\n+    from_port(po)\n+}\n+\n+#[test]\n+fn test_from_value() {\n+    let f = from_value(\"snail\");\n+    assert get(f) == \"snail\";\n+}\n+\n+#[test]\n+fn test_from_port() {\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n+    comm::send(ch, \"whale\");\n+    let f = from_port(po);\n+    assert get(f) == \"whale\";\n+}\n+\n+#[test]\n+fn test_iface_get() {\n+    let f = from_value(\"fail\");\n+    assert f.get() == \"fail\";\n+}\n+\n+#[test]\n+fn test_with() {\n+    let f = from_value(\"nail\");\n+    assert with(f) {|v| v} == \"nail\";\n+}\n+\n+#[test]\n+fn test_iface_with() {\n+    let f = from_value(\"kale\");\n+    assert f.with {|v| v} == \"kale\";\n+}\n+\n+#[test]\n+fn test_spawn() {\n+    let f = spawn {|| \"bale\" };\n+    assert get(f) == \"bale\";\n+}\n+\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_futurefail() {\n+    let f = spawn {|| fail };\n+    let _x: str = get(f);\n+}\n\\ No newline at end of file"}]}