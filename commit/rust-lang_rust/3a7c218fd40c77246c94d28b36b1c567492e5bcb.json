{"sha": "3a7c218fd40c77246c94d28b36b1c567492e5bcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhN2MyMThmZDQwYzc3MjQ2Yzk0ZDI4YjM2YjFjNTY3NDkyZTViY2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-08T16:28:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-08T16:28:48Z"}, "message": "Merge #4576\n\n4576: Add implementation of extract struct from enum variant r=matklad a=mcrakhman\n\nHi guys! I implemented the extraction functionality including modifying multiple files. The only thing I didn't change the cursor position. I've done it with a previous API, but now snippets have been introduced and I need to figure out how to do it.\r\n\r\nPlease bear in mind that I am a newcomer in the rust-analyzer (and also Rust) world, so I tried to implement the feature to the best of my knowledge, but the API is very new to me, so I am very welcome to introducing changes etc. \n\nCo-authored-by: Mikhail Rakhmanov <rakhmanov.m@gmail.com>", "tree": {"sha": "e3408f17dca2872e79e5b76caad89e9722ed47d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3408f17dca2872e79e5b76caad89e9722ed47d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a7c218fd40c77246c94d28b36b1c567492e5bcb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe3mdACRBK7hj4Ov3rIwAAdHIIABjWhNvZOb5HVMMDzcdcsJ2X\nvrjv+lGzhnbELBx1oKR/9D6StjclPQnGJC6xdX4tyzk1/W7pzC07aboEdxzsAkEN\ncyxzu3DJpSa2vl6ZIShj134h+s4nUidkvm2quKfSutiArlPPv08oxkZG5r515Nk+\nCLZ13CGv1dgY3e1L/tFlfHEVxIF2GlMpQjc6t3/3aZjDxO/nk0NZvrOGvgF1QAsi\nhV9tk/b262oi+h6wyCjy8F7WSu0m9sPa2/ymuJ2M8jqZfqMYwsl4J15cPjUUomDi\nZP6RyBV57G8r+usMzCZ9iw+UTYyRljTD2fYPr+ynZD7bMxQ9efawIEulrvwrcTE=\n=2Ju+\n-----END PGP SIGNATURE-----\n", "payload": "tree e3408f17dca2872e79e5b76caad89e9722ed47d8\nparent 38ac331f7dea94581ec687167c92c65b10daf38d\nparent 5dda9955380c6214aa5720ad640b76b870aaa556\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1591633728 +0000\ncommitter GitHub <noreply@github.com> 1591633728 +0000\n\nMerge #4576\n\n4576: Add implementation of extract struct from enum variant r=matklad a=mcrakhman\n\nHi guys! I implemented the extraction functionality including modifying multiple files. The only thing I didn't change the cursor position. I've done it with a previous API, but now snippets have been introduced and I need to figure out how to do it.\r\n\r\nPlease bear in mind that I am a newcomer in the rust-analyzer (and also Rust) world, so I tried to implement the feature to the best of my knowledge, but the API is very new to me, so I am very welcome to introducing changes etc. \n\nCo-authored-by: Mikhail Rakhmanov <rakhmanov.m@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a7c218fd40c77246c94d28b36b1c567492e5bcb", "html_url": "https://github.com/rust-lang/rust/commit/3a7c218fd40c77246c94d28b36b1c567492e5bcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a7c218fd40c77246c94d28b36b1c567492e5bcb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38ac331f7dea94581ec687167c92c65b10daf38d", "url": "https://api.github.com/repos/rust-lang/rust/commits/38ac331f7dea94581ec687167c92c65b10daf38d", "html_url": "https://github.com/rust-lang/rust/commit/38ac331f7dea94581ec687167c92c65b10daf38d"}, {"sha": "5dda9955380c6214aa5720ad640b76b870aaa556", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dda9955380c6214aa5720ad640b76b870aaa556", "html_url": "https://github.com/rust-lang/rust/commit/5dda9955380c6214aa5720ad640b76b870aaa556"}], "stats": {"total": 403, "additions": 403, "deletions": 0}, "files": [{"sha": "1925db8b2754293f2a7620e99639dcd52b8751fe", "filename": "crates/ra_assists/src/assist_context.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3a7c218fd40c77246c94d28b36b1c567492e5bcb/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7c218fd40c77246c94d28b36b1c567492e5bcb/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=3a7c218fd40c77246c94d28b36b1c567492e5bcb", "patch": "@@ -19,6 +19,7 @@ use crate::{\n     assist_config::{AssistConfig, SnippetCap},\n     Assist, AssistId, GroupLabel, ResolvedAssist,\n };\n+use rustc_hash::FxHashMap;\n \n /// `AssistContext` allows to apply an assist or check if it could be applied.\n ///\n@@ -138,6 +139,16 @@ impl Assists {\n         let label = Assist::new(id, label.into(), None, target);\n         self.add_impl(label, f)\n     }\n+    pub(crate) fn add_in_multiple_files(\n+        &mut self,\n+        id: AssistId,\n+        label: impl Into<String>,\n+        target: TextRange,\n+        f: impl FnOnce(&mut AssistDirector),\n+    ) -> Option<()> {\n+        let label = Assist::new(id, label.into(), None, target);\n+        self.add_impl_multiple_files(label, f)\n+    }\n     pub(crate) fn add_group(\n         &mut self,\n         group: &GroupLabel,\n@@ -162,6 +173,31 @@ impl Assists {\n         Some(())\n     }\n \n+    fn add_impl_multiple_files(\n+        &mut self,\n+        label: Assist,\n+        f: impl FnOnce(&mut AssistDirector),\n+    ) -> Option<()> {\n+        if !self.resolve {\n+            self.buf.push((label, None));\n+            return None;\n+        }\n+        let mut director = AssistDirector::default();\n+        f(&mut director);\n+        let changes = director.finish();\n+        let file_edits: Vec<SourceFileEdit> =\n+            changes.into_iter().map(|mut change| change.source_file_edits.pop().unwrap()).collect();\n+\n+        let source_change = SourceChange {\n+            source_file_edits: file_edits,\n+            file_system_edits: vec![],\n+            is_snippet: false,\n+        };\n+\n+        self.buf.push((label, Some(source_change)));\n+        Some(())\n+    }\n+\n     fn finish(mut self) -> Vec<(Assist, Option<SourceChange>)> {\n         self.buf.sort_by_key(|(label, _edit)| label.target.len());\n         self.buf\n@@ -255,3 +291,27 @@ impl AssistBuilder {\n         res\n     }\n }\n+\n+pub(crate) struct AssistDirector {\n+    builders: FxHashMap<FileId, AssistBuilder>,\n+}\n+\n+impl AssistDirector {\n+    pub(crate) fn perform(&mut self, file_id: FileId, f: impl FnOnce(&mut AssistBuilder)) {\n+        let mut builder = self.builders.entry(file_id).or_insert(AssistBuilder::new(file_id));\n+        f(&mut builder);\n+    }\n+\n+    fn finish(self) -> Vec<SourceChange> {\n+        self.builders\n+            .into_iter()\n+            .map(|(_, builder)| builder.finish())\n+            .collect::<Vec<SourceChange>>()\n+    }\n+}\n+\n+impl Default for AssistDirector {\n+    fn default() -> Self {\n+        AssistDirector { builders: FxHashMap::default() }\n+    }\n+}"}, {"sha": "2c455a1fd367fb195978f38dafbd1f27008a9bf1", "filename": "crates/ra_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/3a7c218fd40c77246c94d28b36b1c567492e5bcb/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7c218fd40c77246c94d28b36b1c567492e5bcb/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=3a7c218fd40c77246c94d28b36b1c567492e5bcb", "patch": "@@ -0,0 +1,326 @@\n+use ra_ide_db::{defs::Definition, search::Reference, RootDatabase};\n+use ra_syntax::{\n+    algo::find_node_at_offset,\n+    ast::{self, AstNode, NameOwner},\n+    SourceFile, SyntaxNode, TextRange, TextSize,\n+};\n+\n+use crate::{\n+    assist_context::{AssistBuilder, AssistDirector},\n+    utils::insert_use_statement,\n+    AssistContext, AssistId, Assists,\n+};\n+use ast::{ArgListOwner, VisibilityOwner};\n+use hir::{EnumVariant, Module, ModuleDef, Name};\n+use ra_db::FileId;\n+use ra_fmt::leading_indent;\n+use rustc_hash::FxHashSet;\n+\n+// Assist: extract_struct_from_enum_variant\n+//\n+// Extracts a struct from enum variant.\n+//\n+// ```\n+// enum A { <|>One(u32, u32) }\n+// ```\n+// ->\n+// ```\n+// struct One(pub u32, pub u32);\n+//\n+// enum A { One(One) }\n+// ```\n+pub(crate) fn extract_struct_from_enum_variant(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n+    let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n+    let field_list = match variant.kind() {\n+        ast::StructKind::Tuple(field_list) => field_list,\n+        _ => return None,\n+    };\n+    let variant_name = variant.name()?.to_string();\n+    let variant_hir = ctx.sema.to_def(&variant)?;\n+    if existing_struct_def(ctx.db, &variant_name, &variant_hir) {\n+        return None;\n+    }\n+    let enum_ast = variant.parent_enum();\n+    let visibility = enum_ast.visibility();\n+    let enum_hir = ctx.sema.to_def(&enum_ast)?;\n+    let variant_hir_name = variant_hir.name(ctx.db);\n+    let enum_module_def = ModuleDef::from(enum_hir);\n+    let current_module = enum_hir.module(ctx.db);\n+    let target = variant.syntax().text_range();\n+    acc.add_in_multiple_files(\n+        AssistId(\"extract_struct_from_enum_variant\"),\n+        \"Extract struct from enum variant\",\n+        target,\n+        |edit| {\n+            let definition = Definition::ModuleDef(ModuleDef::EnumVariant(variant_hir));\n+            let res = definition.find_usages(&ctx.db, None);\n+            let start_offset = variant.parent_enum().syntax().text_range().start();\n+            let mut visited_modules_set = FxHashSet::default();\n+            visited_modules_set.insert(current_module);\n+            for reference in res {\n+                let source_file = ctx.sema.parse(reference.file_range.file_id);\n+                update_reference(\n+                    ctx,\n+                    edit,\n+                    reference,\n+                    &source_file,\n+                    &enum_module_def,\n+                    &variant_hir_name,\n+                    &mut visited_modules_set,\n+                );\n+            }\n+            extract_struct_def(\n+                edit,\n+                enum_ast.syntax(),\n+                &variant_name,\n+                &field_list.to_string(),\n+                start_offset,\n+                ctx.frange.file_id,\n+                &visibility,\n+            );\n+            let list_range = field_list.syntax().text_range();\n+            update_variant(edit, &variant_name, ctx.frange.file_id, list_range);\n+        },\n+    )\n+}\n+\n+fn existing_struct_def(db: &RootDatabase, variant_name: &str, variant: &EnumVariant) -> bool {\n+    variant\n+        .parent_enum(db)\n+        .module(db)\n+        .scope(db, None)\n+        .into_iter()\n+        .any(|(name, _)| name.to_string() == variant_name.to_string())\n+}\n+\n+fn insert_import(\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n+    path: &ast::PathExpr,\n+    module: &Module,\n+    enum_module_def: &ModuleDef,\n+    variant_hir_name: &Name,\n+) -> Option<()> {\n+    let db = ctx.db;\n+    let mod_path = module.find_use_path(db, enum_module_def.clone());\n+    if let Some(mut mod_path) = mod_path {\n+        mod_path.segments.pop();\n+        mod_path.segments.push(variant_hir_name.clone());\n+        insert_use_statement(path.syntax(), &mod_path, ctx, builder.text_edit_builder());\n+    }\n+    Some(())\n+}\n+\n+fn extract_struct_def(\n+    edit: &mut AssistDirector,\n+    enum_ast: &SyntaxNode,\n+    variant_name: &str,\n+    variant_list: &str,\n+    start_offset: TextSize,\n+    file_id: FileId,\n+    visibility: &Option<ast::Visibility>,\n+) -> Option<()> {\n+    let visibility_string = if let Some(visibility) = visibility {\n+        format!(\"{} \", visibility.to_string())\n+    } else {\n+        \"\".to_string()\n+    };\n+    let indent = if let Some(indent) = leading_indent(enum_ast) {\n+        indent.to_string()\n+    } else {\n+        \"\".to_string()\n+    };\n+    let struct_def = format!(\n+        r#\"{}struct {}{};\n+\n+{}\"#,\n+        visibility_string,\n+        variant_name,\n+        list_with_visibility(variant_list),\n+        indent\n+    );\n+    edit.perform(file_id, |builder| {\n+        builder.insert(start_offset, struct_def);\n+    });\n+    Some(())\n+}\n+\n+fn update_variant(\n+    edit: &mut AssistDirector,\n+    variant_name: &str,\n+    file_id: FileId,\n+    list_range: TextRange,\n+) -> Option<()> {\n+    let inside_variant_range = TextRange::new(\n+        list_range.start().checked_add(TextSize::from(1))?,\n+        list_range.end().checked_sub(TextSize::from(1))?,\n+    );\n+    edit.perform(file_id, |builder| {\n+        builder.replace(inside_variant_range, variant_name);\n+    });\n+    Some(())\n+}\n+\n+fn update_reference(\n+    ctx: &AssistContext,\n+    edit: &mut AssistDirector,\n+    reference: Reference,\n+    source_file: &SourceFile,\n+    enum_module_def: &ModuleDef,\n+    variant_hir_name: &Name,\n+    visited_modules_set: &mut FxHashSet<Module>,\n+) -> Option<()> {\n+    let path_expr: ast::PathExpr = find_node_at_offset::<ast::PathExpr>(\n+        source_file.syntax(),\n+        reference.file_range.range.start(),\n+    )?;\n+    let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n+    let list = call.arg_list()?;\n+    let segment = path_expr.path()?.segment()?;\n+    let module = ctx.sema.scope(&path_expr.syntax()).module()?;\n+    let list_range = list.syntax().text_range();\n+    let inside_list_range = TextRange::new(\n+        list_range.start().checked_add(TextSize::from(1))?,\n+        list_range.end().checked_sub(TextSize::from(1))?,\n+    );\n+    edit.perform(reference.file_range.file_id, |builder| {\n+        if !visited_modules_set.contains(&module) {\n+            if insert_import(ctx, builder, &path_expr, &module, enum_module_def, variant_hir_name)\n+                .is_some()\n+            {\n+                visited_modules_set.insert(module);\n+            }\n+        }\n+        builder.replace(inside_list_range, format!(\"{}{}\", segment, list));\n+    });\n+    Some(())\n+}\n+\n+fn list_with_visibility(list: &str) -> String {\n+    list.split(',')\n+        .map(|part| {\n+            let index = if part.chars().next().unwrap() == '(' { 1usize } else { 0 };\n+            let mut mod_part = part.trim().to_string();\n+            mod_part.insert_str(index, \"pub \");\n+            mod_part\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\", \")\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use crate::{\n+        tests::{check_assist, check_assist_not_applicable},\n+        utils::FamousDefs,\n+    };\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_extract_struct_several_fields() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            \"enum A { <|>One(u32, u32) }\",\n+            r#\"struct One(pub u32, pub u32);\n+\n+enum A { One(One) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_one_field() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            \"enum A { <|>One(u32) }\",\n+            r#\"struct One(pub u32);\n+\n+enum A { One(One) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_pub_visibility() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            \"pub enum A { <|>One(u32, u32) }\",\n+            r#\"pub struct One(pub u32, pub u32);\n+\n+pub enum A { One(One) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_with_complex_imports() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"mod my_mod {\n+    fn another_fn() {\n+        let m = my_other_mod::MyEnum::MyField(1, 1);\n+    }\n+\n+    pub mod my_other_mod {\n+        fn another_fn() {\n+            let m = MyEnum::MyField(1, 1);\n+        }\n+\n+        pub enum MyEnum {\n+            <|>MyField(u8, u8),\n+        }\n+    }\n+}\n+\n+fn another_fn() {\n+    let m = my_mod::my_other_mod::MyEnum::MyField(1, 1);\n+}\"#,\n+            r#\"use my_mod::my_other_mod::MyField;\n+\n+mod my_mod {\n+    use my_other_mod::MyField;\n+\n+    fn another_fn() {\n+        let m = my_other_mod::MyEnum::MyField(MyField(1, 1));\n+    }\n+\n+    pub mod my_other_mod {\n+        fn another_fn() {\n+            let m = MyEnum::MyField(MyField(1, 1));\n+        }\n+\n+        pub struct MyField(pub u8, pub u8);\n+\n+        pub enum MyEnum {\n+            MyField(MyField),\n+        }\n+    }\n+}\n+\n+fn another_fn() {\n+    let m = my_mod::my_other_mod::MyEnum::MyField(MyField(1, 1));\n+}\"#,\n+        );\n+    }\n+\n+    fn check_not_applicable(ra_fixture: &str) {\n+        let fixture =\n+            format!(\"//- main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n+        check_assist_not_applicable(extract_struct_from_enum_variant, &fixture)\n+    }\n+\n+    #[test]\n+    fn test_extract_enum_not_applicable_for_element_with_no_fields() {\n+        check_not_applicable(\"enum A { <|>One }\");\n+    }\n+\n+    #[test]\n+    fn test_extract_enum_not_applicable_if_struct_exists() {\n+        check_not_applicable(\n+            r#\"struct One;\n+        enum A { <|>One(u8) }\"#,\n+        );\n+    }\n+}"}, {"sha": "185428bd5593c75c4dc241e0707c7bdedd36fdc5", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a7c218fd40c77246c94d28b36b1c567492e5bcb/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7c218fd40c77246c94d28b36b1c567492e5bcb/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=3a7c218fd40c77246c94d28b36b1c567492e5bcb", "patch": "@@ -115,6 +115,7 @@ mod handlers {\n     mod change_return_type_to_result;\n     mod change_visibility;\n     mod early_return;\n+    mod extract_struct_from_enum_variant;\n     mod fill_match_arms;\n     mod fix_visibility;\n     mod flip_binexpr;\n@@ -155,6 +156,7 @@ mod handlers {\n             change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n             early_return::convert_to_guarded_return,\n+            extract_struct_from_enum_variant::extract_struct_from_enum_variant,\n             fill_match_arms::fill_match_arms,\n             fix_visibility::fix_visibility,\n             flip_binexpr::flip_binexpr,"}, {"sha": "40a223727c1fa580dd3e15acd7df94581cf856e4", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3a7c218fd40c77246c94d28b36b1c567492e5bcb/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7c218fd40c77246c94d28b36b1c567492e5bcb/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=3a7c218fd40c77246c94d28b36b1c567492e5bcb", "patch": "@@ -337,6 +337,21 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_extract_struct_from_enum_variant() {\n+    check_doc_test(\n+        \"extract_struct_from_enum_variant\",\n+        r#####\"\n+enum A { <|>One(u32, u32) }\n+\"#####,\n+        r#####\"\n+struct One(pub u32, pub u32);\n+\n+enum A { One(One) }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_fill_match_arms() {\n     check_doc_test("}]}