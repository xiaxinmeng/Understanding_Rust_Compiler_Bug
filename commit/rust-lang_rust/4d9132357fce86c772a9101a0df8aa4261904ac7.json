{"sha": "4d9132357fce86c772a9101a0df8aa4261904ac7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkOTEzMjM1N2ZjZTg2Yzc3MmE5MTAxYTBkZjhhYTQyNjE5MDRhYzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-12T05:28:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-12T05:28:24Z"}, "message": "Auto merge of #36355 - bluss:vec-extend-from-slice-aliasing-workaround, r=alexcrichton\n\nWork around pointer aliasing issue in Vec::extend_from_slice, extend_with_element\n\nDue to missing noalias annotations for &mut T in general (issue #31681),\nin larger programs extend_from_slice and extend_with_element may both\ncompile very poorly. What is observed is that the .set_len() calls are\nnot lifted out of the loop, even for `Vec<u8>`.\n\nUse a local length variable for the Vec length instead, and use a scope\nguard to write this value back to self.len when the scope ends or on\npanic. Then the alias analysis is easy.\n\nThis affects extend_from_slice, extend_with_element, the vec![x; n]\nmacro, Write impls for Vec<u8>, BufWriter, etc (but may / may not\nhave triggered since inlining can be enough for the compiler to get it right).\n\nFixes #32155\nFixes #33518\nCloses #17844", "tree": {"sha": "0402761b3a3f402745e4d875873cbe12071a07ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0402761b3a3f402745e4d875873cbe12071a07ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d9132357fce86c772a9101a0df8aa4261904ac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d9132357fce86c772a9101a0df8aa4261904ac7", "html_url": "https://github.com/rust-lang/rust/commit/4d9132357fce86c772a9101a0df8aa4261904ac7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d9132357fce86c772a9101a0df8aa4261904ac7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f5f325f9ad05a3ce3d2663bd6d1163bf288de9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5f325f9ad05a3ce3d2663bd6d1163bf288de9f", "html_url": "https://github.com/rust-lang/rust/commit/0f5f325f9ad05a3ce3d2663bd6d1163bf288de9f"}, {"sha": "765700ba7a3743b9af5cb12092ea1293dbe07068", "url": "https://api.github.com/repos/rust-lang/rust/commits/765700ba7a3743b9af5cb12092ea1293dbe07068", "html_url": "https://github.com/rust-lang/rust/commit/765700ba7a3743b9af5cb12092ea1293dbe07068"}], "stats": {"total": 68, "additions": 55, "deletions": 13}, "files": [{"sha": "7388e88343432934c0f28a3f077e93fb83a8f217", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4d9132357fce86c772a9101a0df8aa4261904ac7/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d9132357fce86c772a9101a0df8aa4261904ac7/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=4d9132357fce86c772a9101a0df8aa4261904ac7", "patch": "@@ -1046,21 +1046,27 @@ impl<T: Clone> Vec<T> {\n         self.reserve(n);\n \n         unsafe {\n-            let len = self.len();\n-            let mut ptr = self.as_mut_ptr().offset(len as isize);\n+            let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n+            // Use SetLenOnDrop to work around bug where compiler\n+            // may not realize the store through `ptr` trough self.set_len()\n+            // don't alias.\n+            let mut local_len = SetLenOnDrop::new(&mut self.len);\n+\n             // Write all elements except the last one\n-            for i in 1..n {\n+            for _ in 1..n {\n                 ptr::write(ptr, value.clone());\n                 ptr = ptr.offset(1);\n                 // Increment the length in every step in case clone() panics\n-                self.set_len(len + i);\n+                local_len.increment_len(1);\n             }\n \n             if n > 0 {\n                 // We can write the last element directly without cloning needlessly\n                 ptr::write(ptr, value);\n-                self.set_len(len + n);\n+                local_len.increment_len(1);\n             }\n+\n+            // len set by scope guard\n         }\n     }\n \n@@ -1085,20 +1091,56 @@ impl<T: Clone> Vec<T> {\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n         self.reserve(other.len());\n \n-        for i in 0..other.len() {\n+        // Unsafe code so this can be optimised to a memcpy (or something\n+        // similarly fast) when T is Copy. LLVM is easily confused, so any\n+        // extra operations during the loop can prevent this optimisation.\n+        unsafe {\n             let len = self.len();\n-\n-            // Unsafe code so this can be optimised to a memcpy (or something\n-            // similarly fast) when T is Copy. LLVM is easily confused, so any\n-            // extra operations during the loop can prevent this optimisation.\n-            unsafe {\n-                ptr::write(self.get_unchecked_mut(len), other.get_unchecked(i).clone());\n-                self.set_len(len + 1);\n+            let ptr = self.get_unchecked_mut(len) as *mut T;\n+            // Use SetLenOnDrop to work around bug where compiler\n+            // may not realize the store through `ptr` trough self.set_len()\n+            // don't alias.\n+            let mut local_len = SetLenOnDrop::new(&mut self.len);\n+\n+            for i in 0..other.len() {\n+                ptr::write(ptr.offset(i as isize), other.get_unchecked(i).clone());\n+                local_len.increment_len(1);\n             }\n+\n+            // len set by scope guard\n         }\n     }\n }\n \n+// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n+//\n+// The idea is: The length field in SetLenOnDrop is a local variable\n+// that the optimizer will see does not alias with any stores through the Vec's data\n+// pointer. This is a workaround for alias analysis issue #32155\n+struct SetLenOnDrop<'a> {\n+    len: &'a mut usize,\n+    local_len: usize,\n+}\n+\n+impl<'a> SetLenOnDrop<'a> {\n+    #[inline]\n+    fn new(len: &'a mut usize) -> Self {\n+        SetLenOnDrop { local_len: *len, len: len }\n+    }\n+\n+    #[inline]\n+    fn increment_len(&mut self, increment: usize) {\n+        self.local_len += increment;\n+    }\n+}\n+\n+impl<'a> Drop for SetLenOnDrop<'a> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        *self.len = self.local_len;\n+    }\n+}\n+\n impl<T: PartialEq> Vec<T> {\n     /// Removes consecutive repeated elements in the vector.\n     ///"}]}