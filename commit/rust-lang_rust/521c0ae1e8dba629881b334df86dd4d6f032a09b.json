{"sha": "521c0ae1e8dba629881b334df86dd4d6f032a09b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMWMwYWUxZThkYmE2Mjk4ODFiMzM0ZGY4NmRkNGQ2ZjAzMmEwOWI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-11T19:30:19Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-11T19:30:19Z"}, "message": "Rollup merge of #33401 - GuillaumeGomez:index_indication, r=pnkfelix\n\nAdd rustc_on_unimplemented for Index implementation on slice\n\nReopening of #31071.\n\nIt also extends the possibility of `#[rustc_on_unimplemented]` by providing a small type filter in order to find the ones which corresponds the most.\n\nr? @pnkfelix", "tree": {"sha": "8d86cf5758ec0c4616c236e86d93acd8d1adec8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d86cf5758ec0c4616c236e86d93acd8d1adec8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/521c0ae1e8dba629881b334df86dd4d6f032a09b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/521c0ae1e8dba629881b334df86dd4d6f032a09b", "html_url": "https://github.com/rust-lang/rust/commit/521c0ae1e8dba629881b334df86dd4d6f032a09b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/521c0ae1e8dba629881b334df86dd4d6f032a09b/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e37f8593e42335829e98fed27b8ececbad61a05d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e37f8593e42335829e98fed27b8ececbad61a05d", "html_url": "https://github.com/rust-lang/rust/commit/e37f8593e42335829e98fed27b8ececbad61a05d"}, {"sha": "4a3acfd9371f59368108ad5e7be28f4268ed862b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a3acfd9371f59368108ad5e7be28f4268ed862b", "html_url": "https://github.com/rust-lang/rust/commit/4a3acfd9371f59368108ad5e7be28f4268ed862b"}], "stats": {"total": 404, "additions": 384, "deletions": 20}, "files": [{"sha": "e1bbdf4a7ae41ccf5b15741516c021329d9c8373", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=521c0ae1e8dba629881b334df86dd4d6f032a09b", "patch": "@@ -43,6 +43,7 @@\n // Since libcore defines many fundamental lang items, all tests live in a\n // separate crate, libcoretest, to avoid bizarre issues.\n \n+#![cfg_attr(stage0, allow(unused_attributes))]\n #![crate_name = \"core\"]\n #![stable(feature = \"core\", since = \"1.6.0\")]\n #![crate_type = \"rlib\"]"}, {"sha": "e4b98ed6445c7775d1db38e683956f70ee15463e", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=521c0ae1e8dba629881b334df86dd4d6f032a09b", "patch": "@@ -523,6 +523,8 @@ impl<T> SliceExt for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(unused_attributes)]\n+#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n@@ -533,6 +535,8 @@ impl<T> ops::Index<usize> for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(unused_attributes)]\n+#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n impl<T> ops::IndexMut<usize> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {"}, {"sha": "41982ddc78b65e69662f37f6c0ad2aa5e5f06ea4", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=521c0ae1e8dba629881b334df86dd4d6f032a09b", "patch": "@@ -167,7 +167,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap = FnvHashMap<ty::BoundRegion,ty::Region>;\n+pub type SkolemizationMap = FnvHashMap<ty::BoundRegion, ty::Region>;\n \n /// Why did we require that the two types be related?\n ///"}, {"sha": "508261ddfdd6c6d85105719e4cc14a34388843b5", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 259, "deletions": 18, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=521c0ae1e8dba629881b334df86dd4d6f032a09b", "patch": "@@ -26,16 +26,17 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n-use infer::InferCtxt;\n-use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n+use infer::{InferCtxt, TypeOrigin};\n+use ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, Ty, TyCtxt, TypeFoldable, TypeVariants};\n use ty::fast_reject;\n-use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::fold::TypeFolder;\n+use ty::subst::{self, ParamSpace, Subst};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n use std::fmt;\n-use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::ast;\n+use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::errors::DiagnosticBuilder;\n \n@@ -60,6 +61,128 @@ impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n     }\n }\n \n+// Enum used to differentiate the \"big\" and \"little\" weights.\n+enum Weight {\n+    Coarse,\n+    Precise,\n+}\n+\n+trait AssociatedWeight {\n+    fn get_weight(&self) -> (u32, u32);\n+}\n+\n+impl<'a> AssociatedWeight for TypeVariants<'a> {\n+    // Left number is for \"global\"/\"big\" weight and right number is for better precision.\n+    fn get_weight(&self) -> (u32, u32) {\n+        match *self {\n+            TypeVariants::TyBool => (1, 1),\n+            TypeVariants::TyChar => (1, 2),\n+            TypeVariants::TyStr => (1, 3),\n+\n+            TypeVariants::TyInt(_) => (2, 1),\n+            TypeVariants::TyUint(_) => (2, 2),\n+            TypeVariants::TyFloat(_) => (2, 3),\n+            TypeVariants::TyRawPtr(_) => (2, 4),\n+\n+            TypeVariants::TyEnum(_, _) => (3, 1),\n+            TypeVariants::TyStruct(_, _) => (3, 2),\n+            TypeVariants::TyBox(_) => (3, 3),\n+            TypeVariants::TyTuple(_) => (3, 4),\n+\n+            TypeVariants::TyArray(_, _) => (4, 1),\n+            TypeVariants::TySlice(_) => (4, 2),\n+\n+            TypeVariants::TyRef(_, _) => (5, 1),\n+            TypeVariants::TyFnDef(_, _, _) => (5, 2),\n+            TypeVariants::TyFnPtr(_) => (5, 3),\n+\n+            TypeVariants::TyTrait(_) => (6, 1),\n+\n+            TypeVariants::TyClosure(_, _) => (7, 1),\n+\n+            TypeVariants::TyProjection(_) => (8, 1),\n+            TypeVariants::TyParam(_) => (8, 2),\n+            TypeVariants::TyInfer(_) => (8, 3),\n+\n+            TypeVariants::TyError => (9, 1),\n+        }\n+    }\n+}\n+\n+// The \"closer\" the types are, the lesser the weight.\n+fn get_weight_diff(a: &ty::TypeVariants, b: &TypeVariants, weight: Weight) -> u32 {\n+    let (w1, w2) = match weight {\n+        Weight::Coarse => (a.get_weight().0, b.get_weight().0),\n+        Weight::Precise => (a.get_weight().1, b.get_weight().1),\n+    };\n+    if w1 < w2 {\n+        w2 - w1\n+    } else {\n+        w1 - w2\n+    }\n+}\n+\n+// Once we have \"globally matching\" types, we need to run another filter on them.\n+//\n+// In the function `get_best_matching_type`, we got the types which might fit the\n+// most to the type we're looking for. This second filter now intends to get (if\n+// possible) the type which fits the most.\n+//\n+// For example, the trait expects an `usize` and here you have `u32` and `i32`.\n+// Obviously, the \"correct\" one is `u32`.\n+fn filter_matching_types<'tcx>(weights: &[(usize, u32)],\n+                               imps: &[(DefId, subst::Substs<'tcx>)],\n+                               trait_types: &[ty::Ty<'tcx>])\n+                               -> usize {\n+    let matching_weight = weights[0].1;\n+    let iter = weights.iter().filter(|&&(_, weight)| weight == matching_weight);\n+    let mut filtered_weights = vec!();\n+\n+    for &(pos, _) in iter {\n+        let mut weight = 0;\n+        for (type_to_compare, original_type) in imps[pos].1\n+                                                         .types\n+                                                         .get_slice(ParamSpace::TypeSpace)\n+                                                         .iter()\n+                                                         .zip(trait_types.iter()) {\n+            weight += get_weight_diff(&type_to_compare.sty, &original_type.sty, Weight::Precise);\n+        }\n+        filtered_weights.push((pos, weight));\n+    }\n+    filtered_weights.sort_by(|a, b| a.1.cmp(&b.1));\n+    filtered_weights[0].0\n+}\n+\n+// Here, we run the \"big\" filter. Little example:\n+//\n+// We receive a `String`, an `u32` and an `i32`.\n+// The trait expected an `usize`.\n+// From human point of view, it's easy to determine that `String` doesn't correspond to\n+// the expected type at all whereas `u32` and `i32` could.\n+//\n+// This first filter intends to only keep the types which match the most.\n+fn get_best_matching_type<'tcx>(imps: &[(DefId, subst::Substs<'tcx>)],\n+                                trait_types: &[ty::Ty<'tcx>]) -> usize {\n+    let mut weights = vec!();\n+    for (pos, imp) in imps.iter().enumerate() {\n+        let mut weight = 0;\n+        for (type_to_compare, original_type) in imp.1\n+                                                   .types\n+                                                   .get_slice(ParamSpace::TypeSpace)\n+                                                   .iter()\n+                                                   .zip(trait_types.iter()) {\n+            weight += get_weight_diff(&type_to_compare.sty, &original_type.sty, Weight::Coarse);\n+        }\n+        weights.push((pos, weight));\n+    }\n+    weights.sort_by(|a, b| a.1.cmp(&b.1));\n+    if weights[0].1 == weights[1].1 {\n+        filter_matching_types(&weights, &imps, trait_types)\n+    } else {\n+        weights[0].0\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n         for error in errors {\n@@ -126,16 +249,101 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn impl_substs(&self,\n+                   did: DefId,\n+                   obligation: PredicateObligation<'tcx>)\n+                   -> subst::Substs<'tcx> {\n+        let tcx = self.tcx;\n+\n+        let ity = tcx.lookup_item_type(did);\n+        let (tps, rps, _) =\n+            (ity.generics.types.get_slice(subst::TypeSpace),\n+             ity.generics.regions.get_slice(subst::TypeSpace),\n+             ity.ty);\n+\n+        let rps = self.region_vars_for_defs(obligation.cause.span, rps);\n+        let mut substs = subst::Substs::new(\n+            subst::VecPerParamSpace::empty(),\n+            subst::VecPerParamSpace::new(rps, Vec::new(), Vec::new()));\n+        self.type_vars_for_defs(obligation.cause.span,\n+                                subst::ParamSpace::TypeSpace,\n+                                &mut substs,\n+                                tps);\n+        substs\n+    }\n+\n+    fn get_current_failing_impl(&self,\n+                                trait_ref: &TraitRef<'tcx>,\n+                                obligation: &PredicateObligation<'tcx>)\n+                                -> Option<(DefId, subst::Substs<'tcx>)> {\n+        let simp = fast_reject::simplify_type(self.tcx,\n+                                              trait_ref.self_ty(),\n+                                              true);\n+        let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n+\n+        match simp {\n+            Some(_) => {\n+                let mut matching_impls = Vec::new();\n+                trait_def.for_each_impl(self.tcx, |def_id| {\n+                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                    let substs = self.impl_substs(def_id, obligation.clone());\n+                    let imp = imp.subst(self.tcx, &substs);\n+\n+                    if self.eq_types(true,\n+                                      TypeOrigin::Misc(obligation.cause.span),\n+                                      trait_ref.self_ty(),\n+                                      imp.self_ty()).is_ok() {\n+                        matching_impls.push((def_id, imp.substs.clone()));\n+                    }\n+                });\n+                if matching_impls.len() == 0 {\n+                    None\n+                } else if matching_impls.len() == 1 {\n+                    Some(matching_impls[0].clone())\n+                } else {\n+                    let end = trait_ref.input_types().len() - 1;\n+                    // we need to determine which type is the good one!\n+                    Some(matching_impls[get_best_matching_type(&matching_impls,\n+                                                               &trait_ref.input_types()[0..end])]\n+                                                              .clone())\n+                }\n+            },\n+            None => None,\n+        }\n+    }\n+\n+    fn find_attr(&self,\n+                 def_id: DefId,\n+                 attr_name: &str)\n+                 -> Option<ast::Attribute> {\n+        for item in self.tcx.get_attrs(def_id).iter() {\n+            if item.check_name(attr_name) {\n+                return Some(item.clone());\n+            }\n+        }\n+        None\n+    }\n+\n     fn on_unimplemented_note(&self,\n                              trait_ref: ty::PolyTraitRef<'tcx>,\n-                             span: Span) -> Option<String> {\n+                             obligation: &PredicateObligation<'tcx>) -> Option<String> {\n         let trait_ref = trait_ref.skip_binder();\n-        let def_id = trait_ref.def_id;\n+        let def_id = match self.get_current_failing_impl(trait_ref, obligation) {\n+            Some((def_id, _)) => {\n+                if let Some(_) = self.find_attr(def_id, \"rustc_on_unimplemented\") {\n+                    def_id\n+                } else {\n+                    trait_ref.def_id\n+                }\n+            },\n+            None => trait_ref.def_id,\n+        };\n+        let span = obligation.cause.span;\n         let mut report = None;\n         for item in self.tcx.get_attrs(def_id).iter() {\n             if item.check_name(\"rustc_on_unimplemented\") {\n                 let err_sp = item.meta().span.substitute_dummy(span);\n-                let def = self.tcx.lookup_trait_def(def_id);\n+                let def = self.tcx.lookup_trait_def(trait_ref.def_id);\n                 let trait_str = def.trait_ref.to_string();\n                 if let Some(ref istring) = item.value_str() {\n                     let mut generic_map = def.generics.types.iter_enumerated()\n@@ -195,6 +403,37 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         report\n     }\n \n+    fn find_similar_impl_candidates(&self,\n+                                    trait_ref: ty::PolyTraitRef<'tcx>)\n+                                    -> Vec<ty::TraitRef<'tcx>>\n+    {\n+        let simp = fast_reject::simplify_type(self.tcx,\n+                                              trait_ref.skip_binder().self_ty(),\n+                                              true);\n+        let mut impl_candidates = Vec::new();\n+        let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id());\n+\n+        match simp {\n+            Some(simp) => trait_def.for_each_impl(self.tcx, |def_id| {\n+                let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                let imp_simp = fast_reject::simplify_type(self.tcx,\n+                                                          imp.self_ty(),\n+                                                          true);\n+                if let Some(imp_simp) = imp_simp {\n+                    if simp != imp_simp {\n+                        return;\n+                    }\n+                }\n+                impl_candidates.push(imp);\n+            }),\n+            None => trait_def.for_each_impl(self.tcx, |def_id| {\n+                impl_candidates.push(\n+                    self.tcx.impl_trait_ref(def_id).unwrap());\n+            })\n+        };\n+        impl_candidates\n+    }\n+\n     fn report_similar_impl_candidates(&self,\n                                       trait_ref: ty::PolyTraitRef<'tcx>,\n                                       err: &mut DiagnosticBuilder)\n@@ -425,8 +664,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 // Try to report a help message\n \n                                 if !trait_ref.has_infer_types() &&\n-                                    self.predicate_can_apply(trait_ref)\n-                                {\n+                                    self.predicate_can_apply(trait_ref) {\n                                     // If a where-clause may be useful, remind the\n                                     // user that they can add it.\n                                     //\n@@ -435,22 +673,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                     //     \"the type `T` can't be frobnicated\"\n                                     // which is somewhat confusing.\n                                     err.help(&format!(\"consider adding a `where {}` bound\",\n-                                        trait_ref.to_predicate()\n-                                        ));\n-                                } else if let Some(s) =\n-                                        self.on_unimplemented_note(trait_ref, span) {\n-                                    // Otherwise, if there is an on-unimplemented note,\n-                                    // display it.\n+                                                      trait_ref.to_predicate()));\n+                                } else if let Some(s) = self.on_unimplemented_note(trait_ref,\n+                                                                                   obligation) {\n+                                    // If it has a custom \"#[rustc_on_unimplemented]\"\n+                                    // error message, let's display it!\n                                     err.note(&s);\n                                 } else {\n                                     // If we can't show anything useful, try to find\n                                     // similar impls.\n-\n-                                    self.report_similar_impl_candidates(trait_ref, &mut err);\n+                                    let impl_candidates =\n+                                        self.find_similar_impl_candidates(trait_ref);\n+                                    if impl_candidates.len() > 0 {\n+                                        self.report_similar_impl_candidates(trait_ref, &mut err);\n+                                    }\n                                 }\n                                 err\n                             }\n-                        },\n+                        }\n+\n                         ty::Predicate::Equate(ref predicate) => {\n                             let predicate = self.resolve_type_vars_if_possible(predicate);\n                             let err = self.equality_predicate(span,"}, {"sha": "2db9ceb8a05c8ddc8517fd7364f1c16b76682759", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=521c0ae1e8dba629881b334df86dd4d6f032a09b", "patch": "@@ -136,7 +136,6 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n }\n \n impl<'tcx> Encodable for Substs<'tcx> {\n-\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n             ecx.encode_substs(rbml_w, self);"}, {"sha": "4471b625d7912fd4b79ac1913aaaa3cb687e4774", "filename": "src/test/compile-fail/check_on_unimplemented.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented.rs?ref=521c0ae1e8dba629881b334df86dd4d6f032a09b", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test if the on_unimplemented message override works\n+\n+#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_on_unimplemented = \"invalid\"]\n+trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n+impl Index<usize> for [i32] {\n+    type Output = i32;\n+    fn index(&self, index: usize) -> &i32 {\n+        &self[index]\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() {\n+    Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32); //~ ERROR E0277\n+                                                     //~| NOTE a usize is required\n+                                                     //~| NOTE required by\n+}"}, {"sha": "d594b1cea8bce38d74f47f1576bc68ce4cbafdcf", "filename": "src/test/compile-fail/check_on_unimplemented_on_slice.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented_on_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented_on_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented_on_slice.rs?ref=521c0ae1e8dba629881b334df86dd4d6f032a09b", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test new Index error message for slices\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_error]\n+fn main() {\n+    let x = &[1, 2, 3] as &[i32];\n+    x[1i32]; //~ ERROR E0277\n+             //~| NOTE a usize is required\n+}"}, {"sha": "1a5b5ff206ad0de73445c8057ff7663f094fb593", "filename": "src/test/compile-fail/on_unimplemented.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521c0ae1e8dba629881b334df86dd4d6f032a09b/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs?ref=521c0ae1e8dba629881b334df86dd4d6f032a09b", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test if the on_unimplemented message override works\n+\n+#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_on_unimplemented = \"invalid\"]\n+trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+#[rustc_on_unimplemented = \"a isize is required to index into a slice\"]\n+impl Index<isize> for [i32] {\n+    type Output = i32;\n+    fn index(&self, index: isize) -> &i32 {\n+        &self[index as usize]\n+    }\n+}\n+\n+#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n+impl Index<usize> for [i32] {\n+    type Output = i32;\n+    fn index(&self, index: usize) -> &i32 {\n+        &self[index]\n+    }\n+}\n+\n+trait Foo<A, B> {\n+    fn f(&self, a: &A, b: &B);\n+}\n+\n+#[rustc_on_unimplemented = \"two i32 Foo trait takes\"]\n+impl Foo<i32, i32> for [i32] {\n+    fn f(&self, a: &i32, b: &i32) {}\n+}\n+\n+#[rustc_on_unimplemented = \"two u32 Foo trait takes\"]\n+impl Foo<u32, u32> for [i32] {\n+    fn f(&self, a: &u32, b: &u32) {}\n+}\n+\n+#[rustc_error]\n+fn main() {\n+    Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32); //~ ERROR E0277\n+                                                     //~| NOTE a usize is required\n+                                                     //~| NOTE required by\n+    Index::<i32>::index(&[1, 2, 3] as &[i32], 2i32); //~ ERROR E0277\n+                                                     //~| NOTE a isize is required\n+                                                     //~| NOTE required by\n+\n+    Foo::<usize, usize>::f(&[1, 2, 3] as &[i32], &2usize, &2usize); //~ ERROR E0277\n+                                                                    //~| NOTE two u32 Foo trait\n+                                                                    //~| NOTE required by\n+}"}]}