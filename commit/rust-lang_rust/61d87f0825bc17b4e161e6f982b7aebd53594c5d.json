{"sha": "61d87f0825bc17b4e161e6f982b7aebd53594c5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZDg3ZjA4MjViYzE3YjRlMTYxZTZmOTgyYjdhZWJkNTM1OTRjNWQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-14T09:57:49Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-14T09:57:49Z"}, "message": "Rollup merge of #33576 - soltanmm:vtable, r=nikomatsakis\n\nPlumb inference obligations through selection, take 2\n\nUsing a `SnapshotVec` and dumping inferred obligations into `Vtable` variants.\n\nr? @nikomatsakis", "tree": {"sha": "1408f083385c17654e8cec516c8665a05f464a32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1408f083385c17654e8cec516c8665a05f464a32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61d87f0825bc17b4e161e6f982b7aebd53594c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61d87f0825bc17b4e161e6f982b7aebd53594c5d", "html_url": "https://github.com/rust-lang/rust/commit/61d87f0825bc17b4e161e6f982b7aebd53594c5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61d87f0825bc17b4e161e6f982b7aebd53594c5d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c62d65cfbfbcac57b46fd650cb8b367094857be6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c62d65cfbfbcac57b46fd650cb8b367094857be6", "html_url": "https://github.com/rust-lang/rust/commit/c62d65cfbfbcac57b46fd650cb8b367094857be6"}, {"sha": "f52b655621dc0e3ba8d2b37de9a68f96a65ab660", "url": "https://api.github.com/repos/rust-lang/rust/commits/f52b655621dc0e3ba8d2b37de9a68f96a65ab660", "html_url": "https://github.com/rust-lang/rust/commit/f52b655621dc0e3ba8d2b37de9a68f96a65ab660"}], "stats": {"total": 340, "additions": 235, "deletions": 105}, "files": [{"sha": "65df056fd424b2ae71d1b213230758ca0068eb1f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=61d87f0825bc17b4e161e6f982b7aebd53594c5d", "patch": "@@ -239,7 +239,7 @@ pub enum Vtable<'tcx, N> {\n     VtableParam(Vec<N>),\n \n     /// Virtual calls through an object\n-    VtableObject(VtableObjectData<'tcx>),\n+    VtableObject(VtableObjectData<'tcx, N>),\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n@@ -250,7 +250,7 @@ pub enum Vtable<'tcx, N> {\n     VtableClosure(VtableClosureData<'tcx, N>),\n \n     /// Same as above, but for a fn pointer type with the given signature.\n-    VtableFnPointer(ty::Ty<'tcx>),\n+    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n }\n \n /// Identifies a particular impl in the source, along with a set of\n@@ -293,14 +293,22 @@ pub struct VtableBuiltinData<N> {\n /// A vtable for some object-safe trait `Foo` automatically derived\n /// for the object type `Foo`.\n #[derive(PartialEq,Eq,Clone)]\n-pub struct VtableObjectData<'tcx> {\n+pub struct VtableObjectData<'tcx, N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n \n     /// The vtable is formed by concatenating together the method lists of\n     /// the base object trait and all supertraits; this is the start of\n     /// `upcast_trait_ref`'s methods in that vtable.\n-    pub vtable_base: usize\n+    pub vtable_base: usize,\n+\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq)]\n+pub struct VtableFnPointerData<'tcx, N> {\n+    pub fn_ty: ty::Ty<'tcx>,\n+    pub nested: Vec<N>\n }\n \n /// Creates predicate obligations from the generic bounds.\n@@ -569,7 +577,20 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableBuiltin(i) => i.nested,\n             VtableDefaultImpl(d) => d.nested,\n             VtableClosure(c) => c.nested,\n-            VtableObject(_) | VtableFnPointer(..) => vec![]\n+            VtableObject(d) => d.nested,\n+            VtableFnPointer(d) => d.nested,\n+        }\n+    }\n+\n+    fn nested_obligations_mut(&mut self) -> &mut Vec<N> {\n+        match self {\n+            &mut VtableImpl(ref mut i) => &mut i.nested,\n+            &mut VtableParam(ref mut n) => n,\n+            &mut VtableBuiltin(ref mut i) => &mut i.nested,\n+            &mut VtableDefaultImpl(ref mut d) => &mut d.nested,\n+            &mut VtableClosure(ref mut c) => &mut c.nested,\n+            &mut VtableObject(ref mut d) => &mut d.nested,\n+            &mut VtableFnPointer(ref mut d) => &mut d.nested,\n         }\n     }\n \n@@ -578,18 +599,25 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(i) => VtableImpl(VtableImplData {\n                 impl_def_id: i.impl_def_id,\n                 substs: i.substs,\n-                nested: i.nested.into_iter().map(f).collect()\n+                nested: i.nested.into_iter().map(f).collect(),\n             }),\n             VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n             VtableBuiltin(i) => VtableBuiltin(VtableBuiltinData {\n-                nested: i.nested.into_iter().map(f).collect()\n+                nested: i.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableObject(o) => VtableObject(VtableObjectData {\n+                upcast_trait_ref: o.upcast_trait_ref,\n+                vtable_base: o.vtable_base,\n+                nested: o.nested.into_iter().map(f).collect(),\n             }),\n-            VtableObject(o) => VtableObject(o),\n             VtableDefaultImpl(d) => VtableDefaultImpl(VtableDefaultImplData {\n                 trait_def_id: d.trait_def_id,\n-                nested: d.nested.into_iter().map(f).collect()\n+                nested: d.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n+                fn_ty: p.fn_ty,\n+                nested: p.nested.into_iter().map(f).collect(),\n             }),\n-            VtableFnPointer(f) => VtableFnPointer(f),\n             VtableClosure(c) => VtableClosure(VtableClosureData {\n                 closure_def_id: c.closure_def_id,\n                 substs: c.substs,"}, {"sha": "9abb179f288967bf448915d6302241988fa46680", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=61d87f0825bc17b4e161e6f982b7aebd53594c5d", "patch": "@@ -19,6 +19,7 @@ use super::PredicateObligation;\n use super::SelectionContext;\n use super::SelectionError;\n use super::VtableClosureData;\n+use super::VtableFnPointerData;\n use super::VtableImplData;\n use super::util;\n \n@@ -158,7 +159,7 @@ enum ProjectionTyCandidate<'tcx> {\n     Closure(VtableClosureData<'tcx, PredicateObligation<'tcx>>),\n \n     // fn pointer return type\n-    FnPointer(Ty<'tcx>),\n+    FnPointer(VtableFnPointerData<'tcx, PredicateObligation<'tcx>>),\n }\n \n struct ProjectionTyCandidateSet<'tcx> {\n@@ -873,9 +874,9 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n             candidate_set.vec.push(\n                 ProjectionTyCandidate::Closure(data));\n         }\n-        super::VtableFnPointer(fn_type) => {\n+        super::VtableFnPointer(data) => {\n             candidate_set.vec.push(\n-                ProjectionTyCandidate::FnPointer(fn_type));\n+                ProjectionTyCandidate::FnPointer(data));\n         }\n         super::VtableParam(..) => {\n             // This case tell us nothing about the value of an\n@@ -941,19 +942,22 @@ fn confirm_candidate<'cx, 'gcx, 'tcx>(\n             confirm_closure_candidate(selcx, obligation, closure_vtable)\n         }\n \n-        ProjectionTyCandidate::FnPointer(fn_type) => {\n-            confirm_fn_pointer_candidate(selcx, obligation, fn_type)\n+        ProjectionTyCandidate::FnPointer(fn_pointer_vtable) => {\n+            confirm_fn_pointer_candidate(selcx, obligation, fn_pointer_vtable)\n         }\n     }\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    fn_type: Ty<'tcx>)\n+    fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n-    let fn_type = selcx.infcx().shallow_resolve(fn_type);\n+    // FIXME(#32730) propagate obligations (fn pointer vtable nested obligations ONLY come from\n+    // unification in inference)\n+    assert!(fn_pointer_vtable.nested.is_empty());\n+    let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n     let sig = fn_type.fn_sig();\n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n }"}, {"sha": "5307749b87b6adf3515bbc2a7f360f46809f49a0", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 129, "deletions": 72, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=61d87f0825bc17b4e161e6f982b7aebd53594c5d", "patch": "@@ -30,7 +30,7 @@ use super::SelectionResult;\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n             VtableFnPointer, VtableObject, VtableDefaultImpl};\n use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n-            VtableClosureData, VtableDefaultImplData};\n+            VtableClosureData, VtableDefaultImplData, VtableFnPointerData};\n use super::util;\n \n use hir::def_id::DefId;\n@@ -42,13 +42,24 @@ use traits;\n use ty::fast_reject;\n use ty::relate::TypeRelation;\n \n+use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n use std::cell::RefCell;\n use std::fmt;\n+use std::marker::PhantomData;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n use util::nodemap::FnvHashMap;\n \n+struct InferredObligationsSnapshotVecDelegate<'tcx> {\n+    phantom: PhantomData<&'tcx i32>,\n+}\n+impl<'tcx> SnapshotVecDelegate for InferredObligationsSnapshotVecDelegate<'tcx> {\n+    type Value = PredicateObligation<'tcx>;\n+    type Undo = ();\n+    fn reverse(_: &mut Vec<Self::Value>, _: Self::Undo) {}\n+}\n+\n pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n \n@@ -74,6 +85,8 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     intercrate: bool,\n+\n+    inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n }\n \n // A stack that walks back up the stack frame.\n@@ -300,6 +313,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: false,\n+            inferred_obligations: SnapshotVec::new(),\n         }\n     }\n \n@@ -308,6 +322,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: true,\n+            inferred_obligations: SnapshotVec::new(),\n         }\n     }\n \n@@ -331,6 +346,46 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx.projection_mode()\n     }\n \n+    /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n+    /// context's self.\n+    fn in_snapshot<R, F>(&mut self, f: F) -> R\n+        where F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> R\n+    {\n+        // The irrefutable nature of the operation means we don't need to snapshot the\n+        // inferred_obligations vector.\n+        self.infcx.in_snapshot(|snapshot| f(self, snapshot))\n+    }\n+\n+    /// Wraps a probe s.t. obligations collected during it are ignored and old obligations are\n+    /// retained.\n+    fn probe<R, F>(&mut self, f: F) -> R\n+        where F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> R\n+    {\n+        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n+        let result = self.infcx.probe(|snapshot| f(self, snapshot));\n+        self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n+        result\n+    }\n+\n+    /// Wraps a commit_if_ok s.t. obligations collected during it are not returned in selection if\n+    /// the transaction fails and s.t. old obligations are retained.\n+    fn commit_if_ok<T, E, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> Result<T, E>\n+    {\n+        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n+        match self.infcx.commit_if_ok(|snapshot| f(self, snapshot)) {\n+            Ok(ok) => {\n+                self.inferred_obligations.commit(inferred_obligations_snapshot);\n+                Ok(ok)\n+            },\n+            Err(err) => {\n+                self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n+                Err(err)\n+            }\n+        }\n+    }\n+\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -359,7 +414,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         match self.candidate_from_obligation(&stack)? {\n             None => Ok(None),\n-            Some(candidate) => Ok(Some(self.confirm_candidate(obligation, candidate)?)),\n+            Some(candidate) => {\n+                let mut candidate = self.confirm_candidate(obligation, candidate)?;\n+                // FIXME(#32730) remove this assertion once inferred obligations are propagated\n+                // from inference\n+                assert!(self.inferred_obligations.len() == 0);\n+                let inferred_obligations = (*self.inferred_obligations).into_iter().cloned();\n+                candidate.nested_obligations_mut().extend(inferred_obligations);\n+                Ok(Some(candidate))\n+            },\n         }\n     }\n \n@@ -381,8 +444,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_obligation({:?})\",\n                obligation);\n \n-        self.infcx.probe(|_| {\n-            self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+        self.probe(|this, _| {\n+            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n                 .may_apply()\n         })\n     }\n@@ -397,8 +460,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_obligation_conservatively({:?})\",\n                obligation);\n \n-        self.infcx.probe(|_| {\n-            self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+        self.probe(|this, _| {\n+            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n                 == EvaluatedToOk\n         })\n     }\n@@ -460,8 +523,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // does this code ever run?\n                 match self.infcx.equality_predicate(obligation.cause.span, p) {\n                     Ok(InferOk { obligations, .. }) => {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n+                        self.inferred_obligations.extend(obligations);\n                         EvaluatedToOk\n                     },\n                     Err(_) => EvaluatedToErr\n@@ -643,11 +705,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"evaluate_candidate: depth={} candidate={:?}\",\n                stack.obligation.recursion_depth, candidate);\n-        let result = self.infcx.probe(|_| {\n+        let result = self.probe(|this, _| {\n             let candidate = (*candidate).clone();\n-            match self.confirm_candidate(stack.obligation, candidate) {\n+            match this.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => {\n-                    self.evaluate_predicates_recursively(\n+                    this.evaluate_predicates_recursively(\n                         stack.list(),\n                         selection.nested_obligations().iter())\n                 }\n@@ -1107,8 +1169,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"assemble_candidates_for_projected_tys: trait_def_id={:?}\",\n                trait_def_id);\n \n-        let result = self.infcx.probe(|snapshot| {\n-            self.match_projection_obligation_against_bounds_from_trait(obligation,\n+        let result = self.probe(|this, snapshot| {\n+            this.match_projection_obligation_against_bounds_from_trait(obligation,\n                                                                        snapshot)\n         });\n \n@@ -1156,12 +1218,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             util::elaborate_predicates(self.tcx(), bounds.predicates.into_vec())\n             .filter_to_traits()\n             .find(\n-                |bound| self.infcx.probe(\n-                    |_| self.match_projection(obligation,\n-                                              bound.clone(),\n-                                              skol_trait_predicate.trait_ref.clone(),\n-                                              &skol_map,\n-                                              snapshot)));\n+                |bound| self.probe(\n+                    |this, _| this.match_projection(obligation,\n+                                                    bound.clone(),\n+                                                    skol_trait_predicate.trait_ref.clone(),\n+                                                    &skol_map,\n+                                                    snapshot)));\n \n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n                 matching_bound={:?}\",\n@@ -1196,8 +1258,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                              trait_bound.clone(),\n                                              ty::Binder(skol_trait_ref.clone())) {\n             Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n             }\n             Err(_) => { return false; }\n         }\n@@ -1239,10 +1300,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                  where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                  -> EvaluationResult\n     {\n-        self.infcx().probe(move |_| {\n-            match self.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n+        self.probe(move |this, _| {\n+            match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n-                    self.evaluate_predicates_recursively(stack.list(), obligations.iter())\n+                    this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n                 Err(()) => EvaluatedToErr\n             }\n@@ -1361,8 +1422,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.tcx(),\n             obligation.predicate.0.trait_ref.self_ty(),\n             |impl_def_id| {\n-                self.infcx.probe(|snapshot| {\n-                    if let Ok(_) = self.match_impl(impl_def_id, obligation, snapshot) {\n+                self.probe(|this, snapshot| {\n+                    if let Ok(_) = this.match_impl(impl_def_id, obligation, snapshot) {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n                     }\n                 });\n@@ -1448,12 +1509,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return;\n         }\n \n-        self.infcx.in_snapshot(|snapshot| {\n+        self.probe(|this, snapshot| {\n             let (self_ty, _) =\n-                self.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n+                this.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n             let poly_trait_ref = match self_ty.sty {\n                 ty::TyTrait(ref data) => {\n-                    match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n+                    match this.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n                         Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n                             if data.bounds.builtin_bounds.contains(&bound) {\n                                 debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n@@ -1465,7 +1526,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         _ => {}\n                     }\n \n-                    data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+                    data.principal_trait_ref_with_self_ty(this.tcx(), self_ty)\n                 }\n                 ty::TyInfer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -1486,11 +1547,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n             // but `Foo` is declared as `trait Foo : Bar<u32>`.\n             let upcast_trait_refs =\n-                util::supertraits(self.tcx(), poly_trait_ref)\n+                util::supertraits(this.tcx(), poly_trait_ref)\n                 .filter(|upcast_trait_ref| {\n-                    self.infcx.probe(|_| {\n+                    this.probe(|this, _| {\n                         let upcast_trait_ref = upcast_trait_ref.clone();\n-                        self.match_poly_trait_ref(obligation, upcast_trait_ref).is_ok()\n+                        this.match_poly_trait_ref(obligation, upcast_trait_ref).is_ok()\n                     })\n                 })\n                 .count();\n@@ -1894,23 +1955,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         types.skip_binder().into_iter().flat_map(|ty| { // binder moved -\\\n             let ty: ty::Binder<Ty<'tcx>> = ty::Binder(ty); // <----------/\n \n-            self.infcx.in_snapshot(|snapshot| {\n+            self.in_snapshot(|this, snapshot| {\n                 let (skol_ty, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(&ty, snapshot);\n+                    this.infcx().skolemize_late_bound_regions(&ty, snapshot);\n                 let Normalized { value: normalized_ty, mut obligations } =\n-                    project::normalize_with_depth(self,\n+                    project::normalize_with_depth(this,\n                                                   cause.clone(),\n                                                   recursion_depth,\n                                                   &skol_ty);\n                 let skol_obligation =\n-                    self.tcx().predicate_for_trait_def(\n+                    this.tcx().predicate_for_trait_def(\n                                                   cause.clone(),\n                                                   trait_def_id,\n                                                   recursion_depth,\n                                                   normalized_ty,\n                                                   vec![]);\n                 obligations.push(skol_obligation);\n-                self.infcx().plug_leaks(skol_map, snapshot, &obligations)\n+                this.infcx().plug_leaks(skol_map, snapshot, &obligations)\n             })\n         }).collect()\n     }\n@@ -1977,9 +2038,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             FnPointerCandidate => {\n-                let fn_type =\n+                let data =\n                     self.confirm_fn_pointer_candidate(obligation)?;\n-                Ok(VtableFnPointer(fn_type))\n+                Ok(VtableFnPointer(data))\n             }\n \n             ProjectionCandidate => {\n@@ -1997,9 +2058,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn confirm_projection_candidate(&mut self,\n                                     obligation: &TraitObligation<'tcx>)\n     {\n-        self.infcx.in_snapshot(|snapshot| {\n+        self.in_snapshot(|this, snapshot| {\n             let result =\n-                self.match_projection_obligation_against_bounds_from_trait(obligation,\n+                this.match_projection_obligation_against_bounds_from_trait(obligation,\n                                                                            snapshot);\n             assert!(result);\n         })\n@@ -2140,12 +2201,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             trait_def_id,\n             nested);\n \n-        let trait_obligations = self.infcx.in_snapshot(|snapshot| {\n+        let trait_obligations = self.in_snapshot(|this, snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n-            let cause = self.derived_cause(obligation, ImplDerivedObligation);\n-            self.impl_or_trait_obligations(cause,\n+                this.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n+            let cause = this.derived_cause(obligation, ImplDerivedObligation);\n+            this.impl_or_trait_obligations(cause,\n                                            obligation.recursion_depth + 1,\n                                            trait_def_id,\n                                            &trait_ref.substs,\n@@ -2174,13 +2235,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.in_snapshot(|snapshot| {\n+        self.in_snapshot(|this, snapshot| {\n             let (substs, skol_map) =\n-                self.rematch_impl(impl_def_id, obligation,\n+                this.rematch_impl(impl_def_id, obligation,\n                                   snapshot);\n             debug!(\"confirm_impl_candidate substs={:?}\", substs);\n-            let cause = self.derived_cause(obligation, ImplDerivedObligation);\n-            self.vtable_impl(impl_def_id, substs, cause,\n+            let cause = this.derived_cause(obligation, ImplDerivedObligation);\n+            this.vtable_impl(impl_def_id, substs, cause,\n                              obligation.recursion_depth + 1,\n                              skol_map, snapshot)\n         })\n@@ -2227,7 +2288,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     fn confirm_object_candidate(&mut self,\n                                 obligation: &TraitObligation<'tcx>)\n-                                -> VtableObjectData<'tcx>\n+                                -> VtableObjectData<'tcx, PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_object_candidate({:?})\",\n                obligation);\n@@ -2251,18 +2312,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let vtable_base;\n \n         {\n+            let tcx = self.tcx();\n+\n             // We want to find the first supertrait in the list of\n             // supertraits that we can unify with, and do that\n             // unification. We know that there is exactly one in the list\n             // where we can unify because otherwise select would have\n             // reported an ambiguity. (When we do find a match, also\n             // record it for later.)\n             let nonmatching =\n-                util::supertraits(self.tcx(), poly_trait_ref)\n+                util::supertraits(tcx, poly_trait_ref)\n                 .take_while(|&t| {\n                     match\n-                        self.infcx.commit_if_ok(\n-                            |_| self.match_poly_trait_ref(obligation, t))\n+                        self.commit_if_ok(\n+                            |this, _| this.match_poly_trait_ref(obligation, t))\n                     {\n                         Ok(_) => { upcast_trait_ref = Some(t); false }\n                         Err(_) => { true }\n@@ -2274,20 +2337,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // entries, so that we can compute the offset for the selected\n             // trait.\n             vtable_base =\n-                nonmatching.map(|t| self.tcx().count_own_vtable_entries(t))\n+                nonmatching.map(|t| tcx.count_own_vtable_entries(t))\n                            .sum();\n \n         }\n \n         VtableObjectData {\n             upcast_trait_ref: upcast_trait_ref.unwrap(),\n             vtable_base: vtable_base,\n+            nested: vec![]\n         }\n     }\n \n-    fn confirm_fn_pointer_candidate(&mut self,\n-                                    obligation: &TraitObligation<'tcx>)\n-                                    -> Result<ty::Ty<'tcx>,SelectionError<'tcx>>\n+    fn confirm_fn_pointer_candidate(&mut self, obligation: &TraitObligation<'tcx>)\n+        -> Result<VtableFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n     {\n         debug!(\"confirm_fn_pointer_candidate({:?})\",\n                obligation);\n@@ -2305,7 +2368,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                      obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)?;\n-        Ok(self_ty)\n+        Ok(VtableFnPointerData { fn_ty: self_ty, nested: vec![] })\n     }\n \n     fn confirm_closure_candidate(&mut self,\n@@ -2384,8 +2447,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                        origin,\n                                        expected_trait_ref.clone(),\n                                        obligation_trait_ref.clone())\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n             .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n \n@@ -2420,8 +2482,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_trait, target)\n                     .map_err(|_| Unimplemented)?;\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n \n                 // Register one obligation for 'a: 'b.\n                 let cause = ObligationCause::new(obligation.cause.span,\n@@ -2494,8 +2555,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, a, b)\n                     .map_err(|_| Unimplemented)?;\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n             }\n \n             // Struct<T> -> Struct<U>.\n@@ -2554,8 +2614,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_struct, target)\n                     .map_err(|_| Unimplemented)?;\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n@@ -2649,8 +2708,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n                 ()\n             })?;\n-        // FIXME(#32730) propagate obligations\n-        assert!(obligations.is_empty());\n+        self.inferred_obligations.extend(obligations);\n \n         if let Err(e) = self.infcx.leak_check(false, &skol_map, snapshot) {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n@@ -2703,7 +2761,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the\n     /// obligation is satisfied.\n-    fn match_poly_trait_ref(&self,\n+    fn match_poly_trait_ref(&mut self,\n                             obligation: &TraitObligation<'tcx>,\n                             poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                             -> Result<(),()>\n@@ -2717,8 +2775,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                        origin,\n                                        poly_trait_ref,\n                                        obligation.predicate.to_poly_trait_ref())\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n             .map_err(|_| ())\n     }\n "}, {"sha": "e210d2da94cfd4db09435da2ae56025172f31c4b", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=61d87f0825bc17b4e161e6f982b7aebd53594c5d", "patch": "@@ -99,11 +99,20 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableDefaultImplData<N> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for traits::VtableObjectData<'tcx> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableObject(upcast={:?}, vtable_base={})\",\n+        write!(f, \"VtableObject(upcast={:?}, vtable_base={}, nested={:?})\",\n                self.upcast_trait_ref,\n-               self.vtable_base)\n+               self.vtable_base,\n+               self.nested)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableFnPointer(fn_ty={:?}, nested={:?})\",\n+               self.fn_ty,\n+               self.nested)\n     }\n }\n \n@@ -185,19 +194,26 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n                     })\n                 })\n             }\n-            traits::VtableFnPointer(ty) => {\n-                tcx.lift(&ty).map(traits::VtableFnPointer)\n+            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n+                tcx.lift(&fn_ty).map(|fn_ty| {\n+                    traits::VtableFnPointer(traits::VtableFnPointerData {\n+                        fn_ty: fn_ty,\n+                        nested: nested,\n+                    })\n+                })\n             }\n             traits::VtableParam(n) => Some(traits::VtableParam(n)),\n             traits::VtableBuiltin(d) => Some(traits::VtableBuiltin(d)),\n             traits::VtableObject(traits::VtableObjectData {\n                 upcast_trait_ref,\n-                vtable_base\n+                vtable_base,\n+                nested\n             }) => {\n                 tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n                     traits::VtableObject(traits::VtableObjectData {\n                         upcast_trait_ref: trait_ref,\n-                        vtable_base: vtable_base\n+                        vtable_base: vtable_base,\n+                        nested: nested\n                     })\n                 })\n             }\n@@ -276,16 +292,30 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinDa\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx, N> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableObjectData {\n             upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n-            vtable_base: self.vtable_base\n+            vtable_base: self.vtable_base,\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.upcast_trait_ref.visit_with(visitor) || self.nested.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableFnPointerData<'tcx, N> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::VtableFnPointerData {\n+            fn_ty: self.fn_ty.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.upcast_trait_ref.visit_with(visitor)\n+        self.fn_ty.visit_with(visitor) || self.nested.visit_with(visitor)\n     }\n }\n "}, {"sha": "f8149565aa66b64e50263236845c8bf53d53497f", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=61d87f0825bc17b4e161e6f982b7aebd53594c5d", "patch": "@@ -473,9 +473,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Given an upcast trait object described by `object`, returns the\n     /// index of the method `method_def_id` (which should be part of\n     /// `object.upcast_trait_ref`) within the vtable for `object`.\n-    pub fn get_vtable_index_of_object_method(self,\n-                                             object: &super::VtableObjectData<'tcx>,\n-                                             method_def_id: DefId) -> usize {\n+    pub fn get_vtable_index_of_object_method<N>(self,\n+                                                object: &super::VtableObjectData<'tcx, N>,\n+                                                method_def_id: DefId) -> usize {\n         // Count number of methods preceding the one we are selecting and\n         // add them to the total offset.\n         // Skip over associated types and constants."}, {"sha": "dac074ab91e1bfe11c67876f0d3dce2bc7bfc492", "filename": "src/librustc_data_structures/snapshot_vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs?ref=61d87f0825bc17b4e161e6f982b7aebd53594c5d", "patch": "@@ -213,3 +213,11 @@ impl<D: SnapshotVecDelegate> ops::IndexMut<usize> for SnapshotVec<D> {\n         self.get_mut(index)\n     }\n }\n+\n+impl<D: SnapshotVecDelegate> Extend<D::Value> for SnapshotVec<D> {\n+    fn extend<T>(&mut self, iterable: T) where T: IntoIterator<Item=D::Value> {\n+        for item in iterable {\n+            self.push(item);\n+        }\n+    }\n+}"}, {"sha": "c0c5ea818b2d726c241a5710c000b3be2b44ad85", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=61d87f0825bc17b4e161e6f982b7aebd53594c5d", "patch": "@@ -188,9 +188,9 @@ impl<'tcx> Callee<'tcx> {\n                 };\n                 Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n-            traits::VtableFnPointer(fn_ty) => {\n+            traits::VtableFnPointer(vtable_fn_pointer) => {\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n+                let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, vtable_fn_pointer.fn_ty);\n \n                 let method_ty = def_ty(tcx, def_id, substs);\n                 let fn_ptr_ty = match method_ty.sty {"}, {"sha": "64ee18fccef37f32a1b63be1a47d4b945624fea2", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61d87f0825bc17b4e161e6f982b7aebd53594c5d/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=61d87f0825bc17b4e161e6f982b7aebd53594c5d", "patch": "@@ -176,7 +176,10 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                          trait_closure_kind);\n                 vec![llfn].into_iter()\n             }\n-            traits::VtableFnPointer(bare_fn_ty) => {\n+            traits::VtableFnPointer(\n+                traits::VtableFnPointerData {\n+                    fn_ty: bare_fn_ty,\n+                    nested: _ }) => {\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n                 vec![trans_fn_pointer_shim(ccx, trait_closure_kind, bare_fn_ty)].into_iter()\n             }"}]}