{"sha": "54e22eb7dbb615bd44355028d3fd867aa93c0972", "node_id": "C_kwDOAAsO6NoAKDU0ZTIyZWI3ZGJiNjE1YmQ0NDM1NTAyOGQzZmQ4NjdhYTkzYzA5NzI", "commit": {"author": {"name": "Hans Kratz", "email": "hans@appfour.com", "date": "2021-12-18T14:30:30Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2022-01-19T14:59:22Z"}, "message": "Fix CVE-2022-21658 for UNIX-like", "tree": {"sha": "fdbbd0ceb4b1e04dd17a9b01b48c6e880e7f8549", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdbbd0ceb4b1e04dd17a9b01b48c6e880e7f8549"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54e22eb7dbb615bd44355028d3fd867aa93c0972", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmHoJ0oACgkQzXazX3c0\ndp6CHg//Wa7xy0R05ZuV+olfvMSFdncG33Tfmr1jnHNUSDXwFlQvoFYL3/ILpuaB\nEzS0I/ysrBjsYIzdAgXUV3TcF/ThOGvk97Pkhjnsjhd73C+vkYo7qqN0qSBwGwa8\noyA8U2Kxt3i+wG5Hy3LCXRYa9O5GrWM5kvTwgAsa6qgxhy8vl/rT+LbZEyO/s5KO\nNe52RjWy/tiLSBP0jys52qdqZgwjmvzU25Gx115j9wqVC8e9dNr0gM9il2f7GHiw\nfNBgLJdhZwX6EQnFO91RtFUaRa2v3wdu2CS3XeTF0XzGIX9YB+UcnIK6kvGJMLFN\n/0Oplv6ZQOUALkPG4xB1CSvPBEPVRA5XTLraVKUL6tr9NqxTx8MbZGbJdCOHSwtF\nPPx7QPgVgfa/9tG1VvQMZU7vHlwoDcMic6EMemF9/IQpQVSFE/ki+LGcOa1uY6QR\nJPJnUJ0Paqa9uoIamRrYTYSoe5ZjkWWeEPVNzT8HlpTMf8cPk2uQ4Te1UFN8eLnE\npjuRAceRaFH5ldV+xjmfAc8XKY8ljdwmMjGgfz8SYMxqChGmTN+D5fOic1K2bJyT\nRnsAlxU9+bgbllzzh/0M6AC4TuQxlslYugMvT1KAM+XDnaV522fV4RMT1qJJKyUa\neQs1UKUEDS4pq6VIi0iSHFzkELnjRk6D8uKttk4XOUjwO6tYatg=\n=0R2l\n-----END PGP SIGNATURE-----", "payload": "tree fdbbd0ceb4b1e04dd17a9b01b48c6e880e7f8549\nparent 5ab67bff1e2230217ce133165605f8dc0d588178\nauthor Hans Kratz <hans@appfour.com> 1639837830 +0100\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1642604362 +0100\n\nFix CVE-2022-21658 for UNIX-like\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54e22eb7dbb615bd44355028d3fd867aa93c0972", "html_url": "https://github.com/rust-lang/rust/commit/54e22eb7dbb615bd44355028d3fd867aa93c0972", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54e22eb7dbb615bd44355028d3fd867aa93c0972/comments", "author": {"login": "hkratz", "id": 3736990, "node_id": "MDQ6VXNlcjM3MzY5OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/3736990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hkratz", "html_url": "https://github.com/hkratz", "followers_url": "https://api.github.com/users/hkratz/followers", "following_url": "https://api.github.com/users/hkratz/following{/other_user}", "gists_url": "https://api.github.com/users/hkratz/gists{/gist_id}", "starred_url": "https://api.github.com/users/hkratz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hkratz/subscriptions", "organizations_url": "https://api.github.com/users/hkratz/orgs", "repos_url": "https://api.github.com/users/hkratz/repos", "events_url": "https://api.github.com/users/hkratz/events{/privacy}", "received_events_url": "https://api.github.com/users/hkratz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ab67bff1e2230217ce133165605f8dc0d588178", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ab67bff1e2230217ce133165605f8dc0d588178", "html_url": "https://github.com/rust-lang/rust/commit/5ab67bff1e2230217ce133165605f8dc0d588178"}], "stats": {"total": 364, "additions": 351, "deletions": 13}, "files": [{"sha": "a62c01ef29b27d59407dec2c1f6410fa657d17d7", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/54e22eb7dbb615bd44355028d3fd867aa93c0972/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54e22eb7dbb615bd44355028d3fd867aa93c0972/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=54e22eb7dbb615bd44355028d3fd867aa93c0972", "patch": "@@ -4,8 +4,10 @@ use crate::fs::{self, File, OpenOptions};\n use crate::io::{ErrorKind, SeekFrom};\n use crate::path::Path;\n use crate::str;\n+use crate::sync::Arc;\n use crate::sys_common::io::test::{tmpdir, TempDir};\n use crate::thread;\n+use crate::time::{Duration, Instant};\n \n use rand::{rngs::StdRng, RngCore, SeedableRng};\n \n@@ -601,6 +603,21 @@ fn recursive_rmdir_of_symlink() {\n     assert!(canary.exists());\n }\n \n+#[test]\n+fn recursive_rmdir_of_file_fails() {\n+    // test we do not delete a directly specified file.\n+    let tmpdir = tmpdir();\n+    let canary = tmpdir.join(\"do_not_delete\");\n+    check!(check!(File::create(&canary)).write(b\"foo\"));\n+    let result = fs::remove_dir_all(&canary);\n+    #[cfg(unix)]\n+    error!(result, \"Not a directory\");\n+    #[cfg(windows)]\n+    error!(result, 267); // ERROR_DIRECTORY - The directory name is invalid.\n+    assert!(result.is_err());\n+    assert!(canary.exists());\n+}\n+\n #[test]\n // only Windows makes a distinction between file and directory symlinks.\n #[cfg(windows)]\n@@ -620,6 +637,59 @@ fn recursive_rmdir_of_file_symlink() {\n     }\n }\n \n+#[test]\n+#[ignore] // takes too much time\n+fn recursive_rmdir_toctou() {\n+    // Test for time-of-check to time-of-use issues.\n+    //\n+    // Scenario:\n+    // The attacker wants to get directory contents deleted, to which he does not have access.\n+    // He has a way to get a privileged Rust binary call `std::fs::remove_dir_all()` on a\n+    // directory he controls, e.g. in his home directory.\n+    //\n+    // The POC sets up the `attack_dest/attack_file` which the attacker wants to have deleted.\n+    // The attacker repeatedly creates a directory and replaces it with a symlink from\n+    // `victim_del` to `attack_dest` while the victim code calls `std::fs::remove_dir_all()`\n+    // on `victim_del`. After a few seconds the attack has succeeded and\n+    // `attack_dest/attack_file` is deleted.\n+    let tmpdir = tmpdir();\n+    let victim_del_path = tmpdir.join(\"victim_del\");\n+    let victim_del_path_clone = victim_del_path.clone();\n+\n+    // setup dest\n+    let attack_dest_dir = tmpdir.join(\"attack_dest\");\n+    let attack_dest_dir = attack_dest_dir.as_path();\n+    fs::create_dir(attack_dest_dir).unwrap();\n+    let attack_dest_file = tmpdir.join(\"attack_dest/attack_file\");\n+    File::create(&attack_dest_file).unwrap();\n+\n+    let drop_canary_arc = Arc::new(());\n+    let drop_canary_weak = Arc::downgrade(&drop_canary_arc);\n+\n+    eprintln!(\"x: {:?}\", &victim_del_path);\n+\n+    // victim just continuously removes `victim_del`\n+    thread::spawn(move || {\n+        while drop_canary_weak.upgrade().is_some() {\n+            let _ = fs::remove_dir_all(&victim_del_path_clone);\n+        }\n+    });\n+\n+    // attacker (could of course be in a separate process)\n+    let start_time = Instant::now();\n+    while Instant::now().duration_since(start_time) < Duration::from_secs(1000) {\n+        if !attack_dest_file.exists() {\n+            panic!(\n+                \"Victim deleted symlinked file outside of victim_del. Attack succeeded in {:?}.\",\n+                Instant::now().duration_since(start_time)\n+            );\n+        }\n+        let _ = fs::create_dir(&victim_del_path);\n+        let _ = fs::remove_dir(&victim_del_path);\n+        let _ = symlink_dir(attack_dest_dir, &victim_del_path);\n+    }\n+}\n+\n #[test]\n fn unicode_path_is_dir() {\n     assert!(Path::new(\".\").is_dir());"}, {"sha": "16460bee66ff2571c6d3266ca73b9d5758842ce2", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 277, "deletions": 11, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/54e22eb7dbb615bd44355028d3fd867aa93c0972/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54e22eb7dbb615bd44355028d3fd867aa93c0972/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=54e22eb7dbb615bd44355028d3fd867aa93c0972", "patch": "@@ -64,7 +64,7 @@ use libc::{\n     dirent64, fstat64, ftruncate64, lseek64, lstat64, off64_t, open64, readdir64_r, stat64,\n };\n \n-pub use crate::sys_common::fs::{remove_dir_all, try_exists};\n+pub use crate::sys_common::fs::try_exists;\n \n pub struct File(FileDesc);\n \n@@ -228,7 +228,7 @@ pub struct DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\"\n     ))]\n-    name: Box<[u8]>,\n+    name: CString,\n }\n \n #[derive(Clone, Debug)]\n@@ -455,8 +455,6 @@ impl Iterator for ReadDir {\n         target_os = \"illumos\"\n     ))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        use crate::slice;\n-\n         unsafe {\n             loop {\n                 // Although readdir_r(3) would be a correct function to use here because\n@@ -474,14 +472,10 @@ impl Iterator for ReadDir {\n                     };\n                 }\n \n-                let name = (*entry_ptr).d_name.as_ptr();\n-                let namelen = libc::strlen(name) as usize;\n-\n                 let ret = DirEntry {\n                     entry: *entry_ptr,\n-                    name: slice::from_raw_parts(name as *const u8, namelen as usize)\n-                        .to_owned()\n-                        .into_boxed_slice(),\n+                    // d_name is guaranteed to be null-terminated.\n+                    name: CStr::from_ptr((*entry_ptr).d_name.as_ptr()).to_owned(),\n                     dir: Arc::clone(&self.inner),\n                 };\n                 if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n@@ -664,7 +658,26 @@ impl DirEntry {\n         target_os = \"redox\"\n     ))]\n     fn name_bytes(&self) -> &[u8] {\n-        &*self.name\n+        self.name.as_bytes()\n+    }\n+\n+    #[cfg(not(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"fuchsia\",\n+        target_os = \"redox\"\n+    )))]\n+    fn name_cstr(&self) -> &CStr {\n+        unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }\n+    }\n+    #[cfg(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"fuchsia\",\n+        target_os = \"redox\"\n+    ))]\n+    fn name_cstr(&self) -> &CStr {\n+        &self.name\n     }\n \n     pub fn file_name_os_str(&self) -> &OsStr {\n@@ -1437,3 +1450,256 @@ pub fn chroot(dir: &Path) -> io::Result<()> {\n     cvt(unsafe { libc::chroot(dir.as_ptr()) })?;\n     Ok(())\n }\n+\n+pub use remove_dir_impl::remove_dir_all;\n+\n+// Fallback for REDOX\n+#[cfg(target_os = \"redox\")]\n+mod remove_dir_impl {\n+    pub use crate::sys_common::fs::remove_dir_all;\n+}\n+\n+// Dynamically choose implementation Macos x86-64: modern for 10.10+, fallback for older versions\n+#[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n+mod remove_dir_impl {\n+    use super::{cstr, lstat, Dir, InnerReadDir, ReadDir};\n+    use crate::ffi::CStr;\n+    use crate::io;\n+    use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n+    use crate::os::unix::prelude::{OwnedFd, RawFd};\n+    use crate::path::{Path, PathBuf};\n+    use crate::sync::Arc;\n+    use crate::sys::weak::weak;\n+    use crate::sys::{cvt, cvt_r};\n+    use libc::{c_char, c_int, DIR};\n+\n+    pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {\n+        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n+        let fd = cvt_r(|| unsafe {\n+            openat.get().unwrap()(\n+                parent_fd.unwrap_or(libc::AT_FDCWD),\n+                p.as_ptr(),\n+                libc::O_CLOEXEC | libc::O_RDONLY | libc::O_NOFOLLOW | libc::O_DIRECTORY,\n+            )\n+        })?;\n+        Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n+    }\n+\n+    fn fdreaddir(dir_fd: OwnedFd) -> io::Result<(ReadDir, RawFd)> {\n+        weak!(fn fdopendir(c_int) -> *mut DIR, \"fdopendir$INODE64\");\n+        let ptr = unsafe { fdopendir.get().unwrap()(dir_fd.as_raw_fd()) };\n+        if ptr.is_null() {\n+            return Err(io::Error::last_os_error());\n+        }\n+        let dirp = Dir(ptr);\n+        // file descriptor is automatically closed by libc::closedir() now, so give up ownership\n+        let new_parent_fd = dir_fd.into_raw_fd();\n+        // a valid root is not needed because we do not call any functions involving the full path\n+        // of the DirEntrys.\n+        let dummy_root = PathBuf::new();\n+        Ok((\n+            ReadDir {\n+                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n+                end_of_stream: false,\n+            },\n+            new_parent_fd,\n+        ))\n+    }\n+\n+    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n+        weak!(fn unlinkat(c_int, *const c_char, c_int) -> c_int);\n+\n+        let pcstr = cstr(p)?;\n+\n+        // entry is expected to be a directory, open as such\n+        let fd = openat_nofollow_dironly(parent_fd, &pcstr)?;\n+\n+        // open the directory passing ownership of the fd\n+        let (dir, fd) = fdreaddir(fd)?;\n+        for child in dir {\n+            let child = child?;\n+            match child.entry.d_type {\n+                libc::DT_DIR => {\n+                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                }\n+                libc::DT_UNKNOWN => {\n+                    match cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })\n+                    {\n+                        // type unknown - try to unlink\n+                        Err(err) if err.raw_os_error() == Some(libc::EPERM) => {\n+                            // if the file is a directory unlink fails with EPERM\n+                            remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                        }\n+                        result => {\n+                            result?;\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    // not a directory -> unlink\n+                    cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })?;\n+                }\n+            }\n+        }\n+\n+        // unlink the directory after removing its contents\n+        cvt(unsafe {\n+            unlinkat.get().unwrap()(\n+                parent_fd.unwrap_or(libc::AT_FDCWD),\n+                pcstr.as_ptr(),\n+                libc::AT_REMOVEDIR,\n+            )\n+        })?;\n+        Ok(())\n+    }\n+\n+    fn remove_dir_all_modern(p: &Path) -> io::Result<()> {\n+        // We cannot just call remove_dir_all_recursive() here because that would not delete a passed\n+        // symlink. No need to worry about races, because remove_dir_all_recursive() does not recurse\n+        // into symlinks.\n+        let attr = lstat(p)?;\n+        if attr.file_type().is_symlink() {\n+            crate::fs::remove_file(p)\n+        } else {\n+            remove_dir_all_recursive(None, p)\n+        }\n+    }\n+\n+    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n+        if openat.get().is_some() {\n+            // openat() is available with macOS 10.10+, just like unlinkat() and fdopendir()\n+            remove_dir_all_modern(p)\n+        } else {\n+            // fall back to classic implementation\n+            crate::sys_common::fs::remove_dir_all(p)\n+        }\n+    }\n+}\n+\n+// Modern implementation using openat(), unlinkat() and fdopendir()\n+#[cfg(not(any(all(target_os = \"macos\", target_arch = \"x86_64\"), target_os = \"redox\")))]\n+mod remove_dir_impl {\n+    use super::{cstr, lstat, Dir, DirEntry, InnerReadDir, ReadDir};\n+    use crate::ffi::CStr;\n+    use crate::io;\n+    use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n+    use crate::os::unix::prelude::{OwnedFd, RawFd};\n+    use crate::path::{Path, PathBuf};\n+    use crate::sync::Arc;\n+    use crate::sys::{cvt, cvt_r};\n+    use libc::{fdopendir, openat, unlinkat};\n+\n+    pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {\n+        let fd = cvt_r(|| unsafe {\n+            openat(\n+                parent_fd.unwrap_or(libc::AT_FDCWD),\n+                p.as_ptr(),\n+                libc::O_CLOEXEC | libc::O_RDONLY | libc::O_NOFOLLOW | libc::O_DIRECTORY,\n+            )\n+        })?;\n+        Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n+    }\n+\n+    fn fdreaddir(dir_fd: OwnedFd) -> io::Result<(ReadDir, RawFd)> {\n+        let ptr = unsafe { fdopendir(dir_fd.as_raw_fd()) };\n+        if ptr.is_null() {\n+            return Err(io::Error::last_os_error());\n+        }\n+        let dirp = Dir(ptr);\n+        // file descriptor is automatically closed by libc::closedir() now, so give up ownership\n+        let new_parent_fd = dir_fd.into_raw_fd();\n+        // a valid root is not needed because we do not call any functions involving the full path\n+        // of the DirEntrys.\n+        let dummy_root = PathBuf::new();\n+        Ok((\n+            ReadDir {\n+                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n+                #[cfg(not(any(\n+                    target_os = \"solaris\",\n+                    target_os = \"illumos\",\n+                    target_os = \"fuchsia\",\n+                    target_os = \"redox\",\n+                )))]\n+                end_of_stream: false,\n+            },\n+            new_parent_fd,\n+        ))\n+    }\n+\n+    #[cfg(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\"\n+    ))]\n+    fn is_dir(_ent: &DirEntry) -> Option<bool> {\n+        None\n+    }\n+\n+    #[cfg(not(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\"\n+    )))]\n+    fn is_dir(ent: &DirEntry) -> Option<bool> {\n+        match ent.entry.d_type {\n+            libc::DT_UNKNOWN => None,\n+            libc::DT_DIR => Some(true),\n+            _ => Some(false),\n+        }\n+    }\n+\n+    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n+        let pcstr = cstr(p)?;\n+\n+        // entry is expected to be a directory, open as such\n+        let fd = openat_nofollow_dironly(parent_fd, &pcstr)?;\n+\n+        // open the directory passing ownership of the fd\n+        let (dir, fd) = fdreaddir(fd)?;\n+        for child in dir {\n+            let child = child?;\n+            match is_dir(&child) {\n+                Some(true) => {\n+                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                }\n+                Some(false) => {\n+                    cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) })?;\n+                }\n+                None => match cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) }) {\n+                    // type unknown - try to unlink\n+                    Err(err)\n+                        if err.raw_os_error() == Some(libc::EISDIR)\n+                            || err.raw_os_error() == Some(libc::EPERM) =>\n+                    {\n+                        // if the file is a directory unlink fails with EISDIR on Linux and EPERM everyhwere else\n+                        remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                    }\n+                    result => {\n+                        result?;\n+                    }\n+                },\n+            }\n+        }\n+\n+        // unlink the directory after removing its contents\n+        cvt(unsafe {\n+            unlinkat(parent_fd.unwrap_or(libc::AT_FDCWD), pcstr.as_ptr(), libc::AT_REMOVEDIR)\n+        })?;\n+        Ok(())\n+    }\n+\n+    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+        // We cannot just call remove_dir_all_recursive() here because that would not delete a passed\n+        // symlink. No need to worry about races, because remove_dir_all_recursive() does not recurse\n+        // into symlinks.\n+        let attr = lstat(p)?;\n+        if attr.file_type().is_symlink() {\n+            crate::fs::remove_file(p)\n+        } else {\n+            remove_dir_all_recursive(None, p)\n+        }\n+    }\n+}"}, {"sha": "da63c068384a2b56a4926360db10c4213646d616", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54e22eb7dbb615bd44355028d3fd867aa93c0972/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54e22eb7dbb615bd44355028d3fd867aa93c0972/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=54e22eb7dbb615bd44355028d3fd867aa93c0972", "patch": "@@ -73,12 +73,14 @@ impl<F> ExternWeak<F> {\n \n pub(crate) macro dlsym {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n+         dlsym!(fn $name($($t),*) -> $ret, stringify!($name));\n+    ),\n+    (fn $name:ident($($t:ty),*) -> $ret:ty, $sym:expr) => (\n         static DLSYM: DlsymWeak<unsafe extern \"C\" fn($($t),*) -> $ret> =\n-            DlsymWeak::new(concat!(stringify!($name), '\\0'));\n+            DlsymWeak::new(concat!($sym, '\\0'));\n         let $name = &DLSYM;\n     )\n }\n-\n pub(crate) struct DlsymWeak<F> {\n     name: &'static str,\n     addr: AtomicUsize,"}]}