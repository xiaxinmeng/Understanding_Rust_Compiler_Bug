{"sha": "400d343796065e57e78d92b4cf74c78bec38452a", "node_id": "C_kwDOAAsO6NoAKDQwMGQzNDM3OTYwNjVlNTdlNzhkOTJiNGNmNzRjNzhiZWMzODQ1MmE", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-02-25T20:34:25Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-03-01T13:56:00Z"}, "message": "Suggest adding `Copy` bound when Adt is moved out\n\nPreviously we've only suggested adding `Copy` bounds when the type being\nmoved/copied is a type parameter (generic). With this commit we also\nsuggest adding bounds when a type\n- Can be copy\n- All predicates that need to be satisfied for that are based on type\n  params\n\ni.e. we will suggest `T: Copy` for `Option<T>`, but won't suggest\nanything for `Option<String>`.\n\nFuture work: it would be nice to also suggest adding `.clone()` calls", "tree": {"sha": "c2afe0d6d352b5e5fc3b6efd43912b1fae728a8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2afe0d6d352b5e5fc3b6efd43912b1fae728a8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/400d343796065e57e78d92b4cf74c78bec38452a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/400d343796065e57e78d92b4cf74c78bec38452a", "html_url": "https://github.com/rust-lang/rust/commit/400d343796065e57e78d92b4cf74c78bec38452a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/400d343796065e57e78d92b4cf74c78bec38452a/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff", "html_url": "https://github.com/rust-lang/rust/commit/4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff"}], "stats": {"total": 63, "additions": 62, "deletions": 1}, "files": [{"sha": "e8ecb3cb6f3e761ecf41e48c5fa164f1f6b71fb2", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/400d343796065e57e78d92b4cf74c78bec38452a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400d343796065e57e78d92b4cf74c78bec38452a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=400d343796065e57e78d92b4cf74c78bec38452a", "patch": "@@ -5,16 +5,21 @@ use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, suggest_constraining_type_param, Ty};\n+use rustc_middle::ty::{\n+    self, suggest_constraining_type_param, suggest_constraining_type_params, PredicateKind, Ty,\n+};\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::TraitEngineExt as _;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n@@ -423,7 +428,63 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             None,\n                         );\n                     }\n+                } else {\n+                    // Try to find predicates on *generic params* that would allow copying `ty`\n+\n+                    let tcx = self.infcx.tcx;\n+                    let generics = tcx.generics_of(self.mir_def_id());\n+                    if let Some(hir_generics) = tcx\n+                        .typeck_root_def_id(self.mir_def_id().to_def_id())\n+                        .as_local()\n+                        .and_then(|def_id| tcx.hir().get_generics(def_id))\n+                    {\n+                        let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n+                            let mut fulfill_cx =\n+                                <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n+\n+                            let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n+                            let cause = ObligationCause::new(\n+                                span,\n+                                self.mir_hir_id(),\n+                                rustc_infer::traits::ObligationCauseCode::MiscObligation,\n+                            );\n+                            fulfill_cx.register_bound(&infcx, self.param_env, ty, copy_did, cause);\n+                            let errors = fulfill_cx.select_where_possible(&infcx);\n+\n+                            // Only emit suggestion if all required predicates are on generic\n+                            errors\n+                                .into_iter()\n+                                .map(|err| match err.obligation.predicate.kind().skip_binder() {\n+                                    PredicateKind::Trait(predicate) => {\n+                                        match predicate.self_ty().kind() {\n+                                            ty::Param(param_ty) => Ok((\n+                                                generics.type_param(param_ty, tcx),\n+                                                predicate\n+                                                    .trait_ref\n+                                                    .print_only_trait_path()\n+                                                    .to_string(),\n+                                            )),\n+                                            _ => Err(()),\n+                                        }\n+                                    }\n+                                    _ => Err(()),\n+                                })\n+                                .collect()\n+                        });\n+\n+                        if let Ok(predicates) = predicates {\n+                            suggest_constraining_type_params(\n+                                tcx,\n+                                hir_generics,\n+                                &mut err,\n+                                predicates.iter().map(|(param, constraint)| {\n+                                    (param.name.as_str(), &**constraint, None)\n+                                }),\n+                            );\n+                        }\n+                    }\n                 }\n+\n                 let span = if let Some(local) = place.as_local() {\n                     let decl = &self.body.local_decls[local];\n                     Some(decl.source_info.span)"}]}