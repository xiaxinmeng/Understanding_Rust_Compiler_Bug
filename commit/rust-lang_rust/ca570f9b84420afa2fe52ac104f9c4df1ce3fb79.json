{"sha": "ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNTcwZjliODQ0MjBhZmEyZmU1MmFjMTA0ZjljNGRmMWNlM2ZiNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-01T00:47:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-01T00:47:05Z"}, "message": "Auto merge of #7265 - Jarcho:manual_str_repeat, r=giraffate\n\nAdd lint `manual_str_repeat`\n\nfixes: #7260\n\nThere's a similar function for slices. Should this be renamed to include it, or should that be a separate lint? If we are going to have them as one lint a better name will be needed. `manual_repeat` isn't exactly clear as it's replacing a call to `iter::repeat`.\n\nchangelog: Add new lint `manual_str_repeat`", "tree": {"sha": "c089f5f3c657544f10e1411b1ff54a008c0adf72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c089f5f3c657544f10e1411b1ff54a008c0adf72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "html_url": "https://github.com/rust-lang/rust/commit/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "860cb8f977030f1b673d690c62cd337c524d88ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/860cb8f977030f1b673d690c62cd337c524d88ca", "html_url": "https://github.com/rust-lang/rust/commit/860cb8f977030f1b673d690c62cd337c524d88ca"}, {"sha": "cfddf0927bd71b859bc1e749ec159285433a3849", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfddf0927bd71b859bc1e749ec159285433a3849", "html_url": "https://github.com/rust-lang/rust/commit/cfddf0927bd71b859bc1e749ec159285433a3849"}], "stats": {"total": 369, "additions": 359, "deletions": 10}, "files": [{"sha": "41af8e190ddf3581503dc5cd0b902f68cb1e0f20", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -2493,6 +2493,7 @@ Released 2018-09-13\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or\n [`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n+[`manual_str_repeat`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_str_repeat\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`manual_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_unwrap_or"}, {"sha": "e7dd3952b3ac96b19bf7aae3ad288730663deb2f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -762,6 +762,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         methods::MANUAL_FILTER_MAP,\n         methods::MANUAL_FIND_MAP,\n         methods::MANUAL_SATURATING_ARITHMETIC,\n+        methods::MANUAL_STR_REPEAT,\n         methods::MAP_COLLECT_RESULT_UNIT,\n         methods::MAP_FLATTEN,\n         methods::MAP_UNWRAP_OR,\n@@ -1298,6 +1299,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n         LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n+        LintId::of(methods::MANUAL_STR_REPEAT),\n         LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n         LintId::of(methods::NEW_RET_NO_SELF),\n         LintId::of(methods::OK_EXPECT),\n@@ -1735,6 +1737,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(loops::NEEDLESS_COLLECT),\n         LintId::of(methods::EXPECT_FUN_CALL),\n         LintId::of(methods::ITER_NTH),\n+        LintId::of(methods::MANUAL_STR_REPEAT),\n         LintId::of(methods::OR_FUN_CALL),\n         LintId::of(methods::SINGLE_CHAR_PATTERN),\n         LintId::of(misc::CMP_OWNED),"}, {"sha": "aca96e06ef2e779c9be14100770758b1ed88781e", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -7,7 +7,6 @@ use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use std::iter;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for calls of `mem::discriminant()` on a non-enum type.\n@@ -67,7 +66,7 @@ impl<'tcx> LateLintPass<'tcx> for MemDiscriminant {\n                                 }\n                             }\n \n-                            let derefs: String = iter::repeat('*').take(derefs_needed).collect();\n+                            let derefs = \"*\".repeat(derefs_needed);\n                             diag.span_suggestion(\n                                 param.span,\n                                 \"try dereferencing\","}, {"sha": "1a32af5dc7a386fdd5e03c3832e8c105d6fc47f8", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -8,7 +8,6 @@ use rustc_hir::{BindingAnnotation, Expr, ExprKind, MatchSource, Node, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, adjustment::Adjust};\n use rustc_span::symbol::{sym, Symbol};\n-use std::iter;\n \n use super::CLONE_DOUBLE_REF;\n use super::CLONE_ON_COPY;\n@@ -54,8 +53,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol,\n                             ty = inner;\n                             n += 1;\n                         }\n-                        let refs: String = iter::repeat('&').take(n + 1).collect();\n-                        let derefs: String = iter::repeat('*').take(n).collect();\n+                        let refs = \"&\".repeat(n + 1);\n+                        let derefs = \"*\".repeat(n);\n                         let explicit = format!(\"<{}{}>::clone({})\", refs, ty, snip);\n                         diag.span_suggestion(\n                             expr.span,"}, {"sha": "919e2628c523cf2c75da29f965a066c4b1da15b2", "filename": "clippy_lints/src/methods/manual_str_repeat.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -0,0 +1,99 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n+use clippy_utils::sugg::Sugg;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n+use clippy_utils::{is_expr_path_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, LangItem};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_span::symbol::sym;\n+use std::borrow::Cow;\n+\n+use super::MANUAL_STR_REPEAT;\n+\n+enum RepeatKind {\n+    String,\n+    Char(char),\n+}\n+\n+fn get_ty_param(ty: Ty<'_>) -> Option<Ty<'_>> {\n+    if let ty::Adt(_, subs) = ty.kind() {\n+        subs.types().next()\n+    } else {\n+        None\n+    }\n+}\n+\n+fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n+    if let ExprKind::Lit(lit) = &e.kind {\n+        match lit.node {\n+            LitKind::Str(..) => Some(RepeatKind::String),\n+            LitKind::Char(c) => Some(RepeatKind::Char(c)),\n+            _ => None,\n+        }\n+    } else {\n+        let ty = cx.typeck_results().expr_ty(e);\n+        if is_type_diagnostic_item(cx, ty, sym::string_type)\n+            || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, TyS::is_str))\n+            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, TyS::is_str))\n+        {\n+            Some(RepeatKind::String)\n+        } else {\n+            let ty = ty.peel_refs();\n+            (ty.is_str() || is_type_diagnostic_item(cx, ty, sym::string_type)).then(|| RepeatKind::String)\n+        }\n+    }\n+}\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    collect_expr: &Expr<'_>,\n+    take_expr: &Expr<'_>,\n+    take_self_arg: &Expr<'_>,\n+    take_arg: &Expr<'_>,\n+) {\n+    if_chain! {\n+        if let ExprKind::Call(repeat_fn, [repeat_arg]) = take_self_arg.kind;\n+        if is_expr_path_def_path(cx, repeat_fn, &paths::ITER_REPEAT);\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(collect_expr), sym::string_type);\n+        if let Some(collect_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id);\n+        if let Some(take_id) = cx.typeck_results().type_dependent_def_id(take_expr.hir_id);\n+        if let Some(iter_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+        if cx.tcx.trait_of_item(collect_id) == Some(iter_trait_id);\n+        if cx.tcx.trait_of_item(take_id) == Some(iter_trait_id);\n+        if let Some(repeat_kind) = parse_repeat_arg(cx, repeat_arg);\n+        let ctxt = collect_expr.span.ctxt();\n+        if ctxt == take_expr.span.ctxt();\n+        if ctxt == take_self_arg.span.ctxt();\n+        then {\n+            let mut app = Applicability::MachineApplicable;\n+            let count_snip = snippet_with_context(cx, take_arg.span, ctxt, \"..\", &mut app).0;\n+\n+            let val_str = match repeat_kind {\n+                RepeatKind::Char(_) if repeat_arg.span.ctxt() != ctxt => return,\n+                RepeatKind::Char('\\'') => r#\"\"'\"\"#.into(),\n+                RepeatKind::Char('\"') => r#\"\"\\\"\"\"#.into(),\n+                RepeatKind::Char(_) =>\n+                    match snippet_with_applicability(cx, repeat_arg.span, \"..\", &mut app) {\n+                        Cow::Owned(s) => Cow::Owned(format!(\"\\\"{}\\\"\", &s[1..s.len() - 1])),\n+                        s @ Cow::Borrowed(_) => s,\n+                    },\n+                RepeatKind::String =>\n+                    Sugg::hir_with_context(cx, repeat_arg, ctxt, \"..\", &mut app).maybe_par().to_string().into(),\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_STR_REPEAT,\n+                collect_expr.span,\n+                \"manual implementation of `str::repeat` using iterators\",\n+                \"try this\",\n+                format!(\"{}.repeat({})\", val_str, count_snip),\n+                app\n+            )\n+        }\n+    }\n+}"}, {"sha": "c8ae972f18ca62a5d4ba0f3e19ca803fa4169f7a", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -32,6 +32,7 @@ mod iter_nth_zero;\n mod iter_skip_next;\n mod iterator_step_by_zero;\n mod manual_saturating_arithmetic;\n+mod manual_str_repeat;\n mod map_collect_result_unit;\n mod map_flatten;\n mod map_unwrap_or;\n@@ -62,7 +63,7 @@ mod zst_offset;\n use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, paths, return_ty};\n+use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -1664,6 +1665,27 @@ declare_clippy_lint! {\n     \"checks for `.splitn(0, ..)` and `.splitn(1, ..)`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for manual implementations of `str::repeat`\n+    ///\n+    /// **Why is this bad?** These are both harder to read, as well as less performant.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// let x: String = std::iter::repeat('x').take(10).collect();\n+    ///\n+    /// // Good\n+    /// let x: String = \"x\".repeat(10);\n+    /// ```\n+    pub MANUAL_STR_REPEAT,\n+    perf,\n+    \"manual implementation of `str::repeat`\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -1737,7 +1759,8 @@ impl_lint_pass!(Methods => [\n     FROM_ITER_INSTEAD_OF_COLLECT,\n     INSPECT_FOR_EACH,\n     IMPLICIT_CLONE,\n-    SUSPICIOUS_SPLITN\n+    SUSPICIOUS_SPLITN,\n+    MANUAL_STR_REPEAT\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -1981,6 +2004,11 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 Some((\"map\", [m_recv, m_arg], _)) => {\n                     map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n                 },\n+                Some((\"take\", [take_self_arg, take_arg], _)) => {\n+                    if meets_msrv(msrv, &msrvs::STR_REPEAT) {\n+                        manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n+                    }\n+                },\n                 _ => {},\n             },\n             (\"count\", []) => match method_call!(recv) {"}, {"sha": "0e33ae740d946cd00e6c2903d56094a53e9bb441", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -124,7 +124,7 @@ macro_rules! define_Conf {\n define_Conf! {\n     /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION. Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE. The minimum rust version that the project supports\n+    /// Lint: MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE. The minimum rust version that the project supports\n     (msrv: Option<String> = None),\n     /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about. NB: `bar` is not here since it has legitimate uses\n     (blacklisted_names: Vec<String> = [\"foo\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),"}, {"sha": "4a9c4fd0276b378074b0b9895512f22a2e5a65d1", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -26,4 +26,5 @@ msrv_aliases! {\n     1,34,0 { TRY_FROM }\n     1,30,0 { ITERATOR_FIND_MAP }\n     1,17,0 { FIELD_INIT_SHORTHAND, STATIC_IN_CONST }\n+    1,16,0 { STR_REPEAT }\n }"}, {"sha": "efc0ec50fdc947f9d209be2256d8c41ecf1f906b", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -2,15 +2,15 @@\n #![deny(clippy::missing_docs_in_private_items)]\n \n use crate::higher;\n-use crate::source::{snippet, snippet_opt, snippet_with_macro_callsite};\n+use crate::source::{snippet, snippet_opt, snippet_with_context, snippet_with_macro_callsite};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{ast, token};\n use rustc_ast_pretty::pprust::token_kind_to_string;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{EarlyContext, LateContext, LintContext};\n use rustc_span::source_map::{CharPos, Span};\n-use rustc_span::{BytePos, Pos};\n+use rustc_span::{BytePos, Pos, SyntaxContext};\n use std::borrow::Cow;\n use std::convert::TryInto;\n use std::fmt::Display;\n@@ -90,6 +90,29 @@ impl<'a> Sugg<'a> {\n         Self::hir_from_snippet(expr, snippet)\n     }\n \n+    /// Same as `hir`, but first walks the span up to the given context. This will result in the\n+    /// macro call, rather then the expansion, if the span is from a child context. If the span is\n+    /// not from a child context, it will be used directly instead.\n+    ///\n+    /// e.g. Given the expression `&vec![]`, getting a snippet from the span for `vec![]` as a HIR\n+    /// node would result in `box []`. If given the context of the address of expression, this\n+    /// function will correctly get a snippet of `vec![]`.\n+    pub fn hir_with_context(\n+        cx: &LateContext<'_>,\n+        expr: &hir::Expr<'_>,\n+        ctxt: SyntaxContext,\n+        default: &'a str,\n+        applicability: &mut Applicability,\n+    ) -> Self {\n+        let (snippet, in_macro) = snippet_with_context(cx, expr.span, ctxt, default, applicability);\n+\n+        if in_macro {\n+            Sugg::NonParen(snippet)\n+        } else {\n+            Self::hir_from_snippet(expr, snippet)\n+        }\n+    }\n+\n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n     fn hir_from_snippet(expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {"}, {"sha": "dc140257f32108c9c4c48d84578481b54d641dcf", "filename": "tests/ui/manual_str_repeat.fixed", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/tests%2Fui%2Fmanual_str_repeat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/tests%2Fui%2Fmanual_str_repeat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_str_repeat.fixed?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -0,0 +1,66 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_str_repeat)]\n+\n+use std::borrow::Cow;\n+use std::iter::{repeat, FromIterator};\n+\n+fn main() {\n+    let _: String = \"test\".repeat(10);\n+    let _: String = \"x\".repeat(10);\n+    let _: String = \"'\".repeat(10);\n+    let _: String = \"\\\"\".repeat(10);\n+\n+    let x = \"test\";\n+    let count = 10;\n+    let _ = x.repeat(count + 2);\n+\n+    macro_rules! m {\n+        ($e:expr) => {{ $e }};\n+    }\n+    // FIXME: macro args are fine\n+    let _: String = repeat(m!(\"test\")).take(m!(count)).collect();\n+\n+    let x = &x;\n+    let _: String = (*x).repeat(count);\n+\n+    macro_rules! repeat_m {\n+        ($e:expr) => {{ repeat($e) }};\n+    }\n+    // Don't lint, repeat is from a macro.\n+    let _: String = repeat_m!(\"test\").take(count).collect();\n+\n+    let x: Box<str> = Box::from(\"test\");\n+    let _: String = x.repeat(count);\n+\n+    #[derive(Clone)]\n+    struct S;\n+    impl FromIterator<Box<S>> for String {\n+        fn from_iter<T: IntoIterator<Item = Box<S>>>(_: T) -> Self {\n+            Self::new()\n+        }\n+    }\n+    // Don't lint, wrong box type\n+    let _: String = repeat(Box::new(S)).take(count).collect();\n+\n+    let _: String = Cow::Borrowed(\"test\").repeat(count);\n+\n+    let x = \"x\".to_owned();\n+    let _: String = x.repeat(count);\n+\n+    let x = 'x';\n+    // Don't lint, not char literal\n+    let _: String = repeat(x).take(count).collect();\n+}\n+\n+fn _msrv_1_15() {\n+    #![clippy::msrv = \"1.15\"]\n+    // `str::repeat` was stabilized in 1.16. Do not lint this\n+    let _: String = std::iter::repeat(\"test\").take(10).collect();\n+}\n+\n+fn _msrv_1_16() {\n+    #![clippy::msrv = \"1.16\"]\n+    let _: String = \"test\".repeat(10);\n+}"}, {"sha": "0d69c989b2ed84a0b616f773aa963e9ca30c9d14", "filename": "tests/ui/manual_str_repeat.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/tests%2Fui%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/tests%2Fui%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_str_repeat.rs?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -0,0 +1,66 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_str_repeat)]\n+\n+use std::borrow::Cow;\n+use std::iter::{repeat, FromIterator};\n+\n+fn main() {\n+    let _: String = std::iter::repeat(\"test\").take(10).collect();\n+    let _: String = std::iter::repeat('x').take(10).collect();\n+    let _: String = std::iter::repeat('\\'').take(10).collect();\n+    let _: String = std::iter::repeat('\"').take(10).collect();\n+\n+    let x = \"test\";\n+    let count = 10;\n+    let _ = repeat(x).take(count + 2).collect::<String>();\n+\n+    macro_rules! m {\n+        ($e:expr) => {{ $e }};\n+    }\n+    // FIXME: macro args are fine\n+    let _: String = repeat(m!(\"test\")).take(m!(count)).collect();\n+\n+    let x = &x;\n+    let _: String = repeat(*x).take(count).collect();\n+\n+    macro_rules! repeat_m {\n+        ($e:expr) => {{ repeat($e) }};\n+    }\n+    // Don't lint, repeat is from a macro.\n+    let _: String = repeat_m!(\"test\").take(count).collect();\n+\n+    let x: Box<str> = Box::from(\"test\");\n+    let _: String = repeat(x).take(count).collect();\n+\n+    #[derive(Clone)]\n+    struct S;\n+    impl FromIterator<Box<S>> for String {\n+        fn from_iter<T: IntoIterator<Item = Box<S>>>(_: T) -> Self {\n+            Self::new()\n+        }\n+    }\n+    // Don't lint, wrong box type\n+    let _: String = repeat(Box::new(S)).take(count).collect();\n+\n+    let _: String = repeat(Cow::Borrowed(\"test\")).take(count).collect();\n+\n+    let x = \"x\".to_owned();\n+    let _: String = repeat(x).take(count).collect();\n+\n+    let x = 'x';\n+    // Don't lint, not char literal\n+    let _: String = repeat(x).take(count).collect();\n+}\n+\n+fn _msrv_1_15() {\n+    #![clippy::msrv = \"1.15\"]\n+    // `str::repeat` was stabilized in 1.16. Do not lint this\n+    let _: String = std::iter::repeat(\"test\").take(10).collect();\n+}\n+\n+fn _msrv_1_16() {\n+    #![clippy::msrv = \"1.16\"]\n+    let _: String = std::iter::repeat(\"test\").take(10).collect();\n+}"}, {"sha": "c65116897164409e7b4ecb3862bfce925418b6c9", "filename": "tests/ui/manual_str_repeat.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/tests%2Fui%2Fmanual_str_repeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca570f9b84420afa2fe52ac104f9c4df1ce3fb79/tests%2Fui%2Fmanual_str_repeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_str_repeat.stderr?ref=ca570f9b84420afa2fe52ac104f9c4df1ce3fb79", "patch": "@@ -0,0 +1,64 @@\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:10:21\n+   |\n+LL |     let _: String = std::iter::repeat(\"test\").take(10).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"test\".repeat(10)`\n+   |\n+   = note: `-D clippy::manual-str-repeat` implied by `-D warnings`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:11:21\n+   |\n+LL |     let _: String = std::iter::repeat('x').take(10).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"x\".repeat(10)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:12:21\n+   |\n+LL |     let _: String = std::iter::repeat('/'').take(10).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"'\".repeat(10)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:13:21\n+   |\n+LL |     let _: String = std::iter::repeat('\"').take(10).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"/\"\".repeat(10)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:17:13\n+   |\n+LL |     let _ = repeat(x).take(count + 2).collect::<String>();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `x.repeat(count + 2)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:26:21\n+   |\n+LL |     let _: String = repeat(*x).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(*x).repeat(count)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:35:21\n+   |\n+LL |     let _: String = repeat(x).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `x.repeat(count)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:47:21\n+   |\n+LL |     let _: String = repeat(Cow::Borrowed(\"test\")).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Cow::Borrowed(\"test\").repeat(count)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:50:21\n+   |\n+LL |     let _: String = repeat(x).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `x.repeat(count)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:65:21\n+   |\n+LL |     let _: String = std::iter::repeat(\"test\").take(10).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"test\".repeat(10)`\n+\n+error: aborting due to 10 previous errors\n+"}]}