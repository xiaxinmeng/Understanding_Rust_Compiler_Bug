{"sha": "a4dd57705c7b203ad0efed4ddcc0e3959e65d627", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZGQ1NzcwNWM3YjIwM2FkMGVmZWQ0ZGRjYzBlMzk1OWU2NWQ2Mjc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-19T22:47:15Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-19T22:47:15Z"}, "message": "Move type cache and node type table into type context.", "tree": {"sha": "f9a09366b611645dec789c295332604e5dbd85c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9a09366b611645dec789c295332604e5dbd85c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4dd57705c7b203ad0efed4ddcc0e3959e65d627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4dd57705c7b203ad0efed4ddcc0e3959e65d627", "html_url": "https://github.com/rust-lang/rust/commit/a4dd57705c7b203ad0efed4ddcc0e3959e65d627", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a7b5449959b44fcc98d9fd0d5f81d86b44fd399", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399", "html_url": "https://github.com/rust-lang/rust/commit/8a7b5449959b44fcc98d9fd0d5f81d86b44fd399"}], "stats": {"total": 637, "additions": 270, "deletions": 367}, "files": [{"sha": "6b7ae110ab2146cf41822a74362322a6c2faab23", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=a4dd57705c7b203ad0efed4ddcc0e3959e65d627", "patch": "@@ -97,21 +97,18 @@ fn compile_input(session::session sess,\n                         bind resolve::resolve_crate(sess, crate));\n \n     auto ty_cx = ty::mk_ctxt(sess, def_map);\n-    auto typeck_result =\n-        time[typeck::typecheck_result](time_passes, \"typechecking\",\n-            bind typeck::check_crate(ty_cx, crate));\n-    auto node_type_table = typeck_result._0;\n-    auto type_cache = typeck_result._1;\n+    time[()](time_passes, \"typechecking\",\n+             bind typeck::check_crate(ty_cx, crate));\n \n     if (sess.get_opts().run_typestate) {\n         time(time_passes, \"typestate checking\",\n-             bind middle::tstate::ck::check_crate(node_type_table,\n-                                                  ty_cx, crate));\n+             bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n \n-    auto llmod = time[llvm::ModuleRef](time_passes, \"translation\",\n-        bind trans::trans_crate(sess, crate, ty_cx, node_type_table,\n-                                type_cache, output));\n+    auto llmod =\n+        time[llvm::ModuleRef](time_passes, \"translation\",\n+                              bind trans::trans_crate(sess, crate,\n+                                                      ty_cx, output));\n \n     time[()](time_passes, \"LLVM passes\",\n              bind link::write::run_passes(sess, llmod, output));\n@@ -128,8 +125,8 @@ fn pretty_print_input(session::session sess, eval::env env, str input,\n         crate = creader::read_crates(sess, crate);\n         auto def_map = resolve::resolve_crate(sess, crate);\n         auto ty_cx = ty::mk_ctxt(sess, def_map);\n-        auto typeck_result = typeck::check_crate(ty_cx, crate);\n-        mode = pprust::mo_typed(ty_cx, typeck_result._0, typeck_result._1);\n+        typeck::check_crate(ty_cx, crate);\n+        mode = pprust::mo_typed(ty_cx);\n     } else {\n         mode = pprust::mo_untyped;\n     }"}, {"sha": "7ce0fe0a11dd4ac83aa6756a91773625bb2ac20d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 47, "deletions": 82, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a4dd57705c7b203ad0efed4ddcc0e3959e65d627", "patch": "@@ -19,7 +19,6 @@ import back::x86;\n import back::abi;\n import back::upcall;\n \n-import middle::ty::node_type_table;\n import middle::ty::pat_ty;\n \n import util::common;\n@@ -110,7 +109,6 @@ state type crate_ctxt = rec(session::session sess,\n                             hashmap[ast::def_id, @ast::item] items,\n                             hashmap[ast::def_id,\n                                     @ast::native_item] native_items,\n-                            ty::type_cache type_cache,\n                             hashmap[ast::def_id, str] item_symbols,\n                             // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n                             hashmap[ty::t, uint] tag_sizes,\n@@ -130,8 +128,7 @@ state type crate_ctxt = rec(session::session sess,\n                             hashmap[ty::t, str] type_short_names,\n                             ty::ctxt tcx,\n                             stats stats,\n-                            @upcall::upcalls upcalls,\n-                            node_type_table node_types);\n+                            @upcall::upcalls upcalls);\n \n type local_ctxt = rec(vec[str] path,\n                       vec[str] module_path,\n@@ -3358,7 +3355,7 @@ fn target_type(&@crate_ctxt cx, &ty::t t) -> ty::t {\n \n // Converts an annotation to a type\n fn node_ann_type(&@crate_ctxt cx, &ast::ann a) -> ty::t {\n-    ret target_type(cx, ty::ann_to_monotype(cx.tcx, cx.node_types, a));\n+    ret target_type(cx, ty::ann_to_monotype(cx.tcx, a));\n }\n \n fn node_type(&@crate_ctxt cx, &ast::span sp, &ast::ann a) -> TypeRef {\n@@ -3369,25 +3366,22 @@ fn trans_unary(&@block_ctxt cx, ast::unop op,\n                &@ast::expr e, &ast::ann a) -> result {\n \n     auto sub = trans_expr(cx, e);\n-    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types, e);\n+    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n \n     alt (op) {\n         case (ast::bitnot) {\n             sub = autoderef(sub.bcx, sub.val,\n-                            ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                        cx.fcx.lcx.ccx.node_types, e));\n+                            ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n             ret res(sub.bcx, sub.bcx.build.Not(sub.val));\n         }\n         case (ast::not) {\n             sub = autoderef(sub.bcx, sub.val,\n-                            ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                        cx.fcx.lcx.ccx.node_types, e));\n+                            ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n             ret res(sub.bcx, sub.bcx.build.Not(sub.val));\n         }\n         case (ast::neg) {\n             sub = autoderef(sub.bcx, sub.val,\n-                            ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                        cx.fcx.lcx.ccx.node_types, e));\n+                            ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n             if(ty::struct(cx.fcx.lcx.ccx.tcx, e_ty) == ty::ty_float) {\n                 ret res(sub.bcx, sub.bcx.build.FNeg(sub.val));\n             }\n@@ -3396,8 +3390,7 @@ fn trans_unary(&@block_ctxt cx, ast::unop op,\n             }\n         }\n         case (ast::box(_)) {\n-            auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                    cx.fcx.lcx.ccx.node_types, e);\n+            auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n             auto e_val = sub.val;\n             auto box_ty = node_ann_type(sub.bcx.fcx.lcx.ccx, a);\n             sub = trans_malloc_boxed(sub.bcx, e_ty);\n@@ -3659,14 +3652,12 @@ fn trans_binary(&@block_ctxt cx, ast::binop op,\n             // Lazy-eval and\n             auto lhs_res = trans_expr(cx, a);\n             lhs_res = autoderef(lhs_res.bcx, lhs_res.val,\n-                                ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                            cx.fcx.lcx.ccx.node_types, a));\n+                                ty::expr_ty(cx.fcx.lcx.ccx.tcx, a));\n \n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n             rhs_res = autoderef(rhs_res.bcx, rhs_res.val,\n-                                ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                            cx.fcx.lcx.ccx.node_types, b));\n+                                ty::expr_ty(cx.fcx.lcx.ccx.tcx, b));\n \n             auto lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n             auto lhs_false_res = res(lhs_false_cx, C_bool(false));\n@@ -3688,14 +3679,12 @@ fn trans_binary(&@block_ctxt cx, ast::binop op,\n             // Lazy-eval or\n             auto lhs_res = trans_expr(cx, a);\n             lhs_res = autoderef(lhs_res.bcx, lhs_res.val,\n-                                ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                            cx.fcx.lcx.ccx.node_types, a));\n+                                ty::expr_ty(cx.fcx.lcx.ccx.tcx, a));\n \n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n             rhs_res = autoderef(rhs_res.bcx, rhs_res.val,\n-                                ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                            cx.fcx.lcx.ccx.node_types, b));\n+                                ty::expr_ty(cx.fcx.lcx.ccx.tcx, b));\n \n             auto lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n             auto lhs_true_res = res(lhs_true_cx, C_bool(true));\n@@ -3714,12 +3703,10 @@ fn trans_binary(&@block_ctxt cx, ast::binop op,\n         case (_) {\n             // Remaining cases are eager:\n             auto lhs = trans_expr(cx, a);\n-            auto lhty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                    cx.fcx.lcx.ccx.node_types, a);\n+            auto lhty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, a);\n             lhs = autoderef(lhs.bcx, lhs.val, lhty);\n             auto rhs = trans_expr(lhs.bcx, b);\n-            auto rhty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                    cx.fcx.lcx.ccx.node_types, b);\n+            auto rhty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, b);\n             rhs = autoderef(rhs.bcx, rhs.val, rhty);\n             ret trans_eager_binop(rhs.bcx, op,\n                 autoderefed_ty(cx.fcx.lcx.ccx, lhty), lhs.val, rhs.val);\n@@ -3803,8 +3790,7 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond,\n             // If we have an else expression, then the entire\n             // if expression can have a non-nil type.\n             // FIXME: This isn't quite right, particularly re: dynamic types\n-            auto expr_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                       cx.fcx.lcx.ccx.node_types, elexpr);\n+            auto expr_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, elexpr);\n             if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n                 expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n             } else {\n@@ -3862,8 +3848,7 @@ fn trans_for(&@block_ctxt cx,\n     }\n \n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-    auto seq_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types,\n-                              seq);\n+    auto seq_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, seq);\n     auto seq_res = trans_expr(cx, seq);\n     auto it = iter_sequence(seq_res.bcx, seq_res.val, seq_ty,\n                             bind inner(_, local, _, _, body, next_cx));\n@@ -4192,7 +4177,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n \n         case (ast::pat_lit(?lt, ?ann)) {\n             auto lllit = trans_lit(cx.fcx.lcx.ccx, *lt, ann);\n-            auto lltype = ty::ann_to_type(cx.fcx.lcx.ccx.node_types, ann);\n+            auto lltype = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n             auto lleq = trans_compare(cx, ast::eq, lltype, llval, lllit);\n \n             auto matched_cx = new_sub_block_ctxt(lleq.bcx, \"matched_cx\");\n@@ -4229,8 +4214,8 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                                       C_int(variant_tag));\n             cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n \n-            auto ty_params = ty::ann_to_type_params(cx.fcx.lcx.ccx.node_types,\n-                                                    ann);\n+            auto ty_params =\n+                ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx.node_types, ann);\n \n             if (vec::len[@ast::pat](subpats) > 0u) {\n                 auto llblobptr = matched_cx.build.GEP(lltagptr,\n@@ -4243,9 +4228,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                     matched_cx = rslt.bcx;\n \n                     auto llsubval = load_if_immediate(matched_cx,\n-                        llsubvalptr, pat_ty(cx.fcx.lcx.ccx.tcx,\n-                                            cx.fcx.lcx.ccx.node_types,\n-                                            subpat));\n+                        llsubvalptr, pat_ty(cx.fcx.lcx.ccx.tcx, subpat));\n                     auto subpat_res = trans_pat_match(matched_cx, subpat,\n                                                       llsubval, next_cx);\n                     matched_cx = subpat_res.bcx;\n@@ -4295,7 +4278,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat,\n             auto llblobptr = cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n \n             auto ty_param_substs =\n-                ty::ann_to_type_params(cx.fcx.lcx.ccx.node_types, ann);\n+                ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx.node_types, ann);\n \n             auto this_cx = cx;\n             auto i = 0;\n@@ -4342,7 +4325,7 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr,\n                                   \"non-exhaustive match failure\");\n \n     // FIXME: This isn't quite right, particularly re: dynamic types\n-    auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.node_types, ann);\n+    auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n     auto expr_llty;\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n         expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n@@ -4407,8 +4390,8 @@ fn lval_generic_fn(&@block_ctxt cx,\n         lv = trans_external_path(cx, fn_id, tpt);\n     }\n \n-    auto tys = ty::ann_to_type_params(cx.fcx.lcx.ccx.node_types, ann);\n-    auto monoty = ty::ann_to_type(cx.fcx.lcx.ccx.node_types, ann);\n+    auto tys = ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+    auto monoty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n \n     if (vec::len[ty::t](tys) != 0u) {\n         auto bcx = lv.res.bcx;\n@@ -4485,20 +4468,17 @@ fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n         }\n         case (ast::def_fn(?did)) {\n             auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                                           cx.fcx.lcx.ccx.tcx,\n-                                           cx.fcx.lcx.ccx.type_cache, did);\n+                                            cx.fcx.lcx.ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, ann);\n         }\n         case (ast::def_obj(?did)) {\n             auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                                           cx.fcx.lcx.ccx.tcx,\n-                                           cx.fcx.lcx.ccx.type_cache, did);\n+                                           cx.fcx.lcx.ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, ann);\n         }\n         case (ast::def_variant(?tid, ?vid)) {\n             auto v_tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                                             cx.fcx.lcx.ccx.tcx,\n-                                             cx.fcx.lcx.ccx.type_cache, vid);\n+                                             cx.fcx.lcx.ccx.tcx, vid);\n             alt (ty::struct(cx.fcx.lcx.ccx.tcx, v_tyt._1)) {\n                 case (ty::ty_fn(_, _, _)) {\n                     // N-ary variant.\n@@ -4540,8 +4520,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n         }\n         case (ast::def_native_fn(?did)) {\n             auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                                           cx.fcx.lcx.ccx.tcx,\n-                                           cx.fcx.lcx.ccx.type_cache, did);\n+                                           cx.fcx.lcx.ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, ann);\n         }\n         case (_) {\n@@ -4595,9 +4574,7 @@ fn trans_index(&@block_ctxt cx, &ast::span sp, &@ast::expr base,\n                &@ast::expr idx, &ast::ann ann) -> lval_result {\n \n     auto lv = trans_expr(cx, base);\n-    lv = autoderef(lv.bcx, lv.val, ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                               cx.fcx.lcx.ccx.node_types,\n-                                               base));\n+    lv = autoderef(lv.bcx, lv.val, ty::expr_ty(cx.fcx.lcx.ccx.tcx, base));\n     auto ix = trans_expr(lv.bcx, idx);\n     auto v = lv.val;\n     auto bcx = ix.bcx;\n@@ -4663,8 +4640,7 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n         }\n         case (ast::expr_field(?base, ?ident, ?ann)) {\n             auto r = trans_expr(cx, base);\n-            auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                 cx.fcx.lcx.ccx.node_types, base);\n+            auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, base);\n             ret trans_field(r.bcx, e.span, r.val, t, ident, ann);\n         }\n         case (ast::expr_index(?base, ?idx, ?ann)) {\n@@ -4725,8 +4701,7 @@ fn trans_cast(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n     if (!ty::type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n         // TODO: native-to-native casts\n         if (ty::type_is_native(cx.fcx.lcx.ccx.tcx,\n-                              ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                          cx.fcx.lcx.ccx.node_types, e))) {\n+                              ty::expr_ty(cx.fcx.lcx.ccx.tcx, e))) {\n             e_res.val = e_res.bcx.build.PtrToInt(e_res.val, lldsttype);\n         } else if (ty::type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n             e_res.val = e_res.bcx.build.IntToPtr(e_res.val, lldsttype);\n@@ -4818,7 +4793,7 @@ fn trans_bind_thunk(&@local_ctxt cx,\n \n             // Arg provided at binding time; thunk copies it from closure.\n             case (some[@ast::expr](?e)) {\n-                auto e_ty = ty::expr_ty(cx.ccx.tcx, cx.ccx.node_types, e);\n+                auto e_ty = ty::expr_ty(cx.ccx.tcx, e);\n                 auto bound_arg =\n                     GEP_tup_like(bcx, closure_ty, llclosure,\n                                  [0,\n@@ -4914,8 +4889,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n         let vec[ValueRef] lltydescs;\n         alt (f_res.generic) {\n             case (none[generic_info]) {\n-                outgoing_fty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                           cx.fcx.lcx.ccx.node_types, f);\n+                outgoing_fty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, f);\n                 lltydescs = [];\n             }\n             case (some[generic_info](?ginfo)) {\n@@ -4944,8 +4918,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n \n                 vec::push[ValueRef](bound_vals, arg.val);\n                 vec::push[ty::t](bound_tys,\n-                                 ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                             cx.fcx.lcx.ccx.node_types, e));\n+                                 ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n \n                 i += 1u;\n             }\n@@ -5095,7 +5068,7 @@ fn trans_arg_expr(&@block_ctxt cx,\n \n     auto val;\n     auto bcx = cx;\n-    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types, e);\n+    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n \n     if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, e_ty)) {\n         auto re = trans_expr(bcx, e);\n@@ -5295,13 +5268,12 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f,\n         }\n \n         case (_) {\n-            fn_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types,\n-                                f);\n+            fn_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, f);\n         }\n \n     }\n \n-    auto ret_ty = ty::ann_to_type(cx.fcx.lcx.ccx.node_types, ann);\n+    auto ret_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n     auto args_res = trans_args(f_res.res.bcx,\n                                llenv, f_res.llobj,\n                                f_res.generic,\n@@ -5356,8 +5328,7 @@ fn trans_tup(&@block_ctxt cx, &vec[ast::elt] elts,\n     let int i = 0;\n \n     for (ast::elt e in elts) {\n-        auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types,\n-                                e.expr);\n+        auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e.expr);\n         auto src_res = trans_expr(bcx, e.expr);\n         bcx = src_res.bcx;\n         auto dst_res = GEP_tup_like(bcx, t, tup_val, [0, i]);\n@@ -5675,7 +5646,7 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n     // lval cases fall through to trans_lval and then\n     // possibly load the result (if it's non-structural).\n \n-    auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types, e);\n+    auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n     auto sub = trans_lval(cx, e);\n     ret res(sub.res.bcx, load_if_immediate(sub.res.bcx, sub.res.val, t));\n }\n@@ -5736,7 +5707,7 @@ fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n     cx.build.CondBr(test, log_cx.llbb, after_cx.llbb);\n \n     auto sub = trans_expr(log_cx, e);\n-    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types, e);\n+    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n \n     auto log_bcx = sub.bcx;\n     if (ty::type_is_fp(cx.fcx.lcx.ccx.tcx, e_ty)) {\n@@ -5854,8 +5825,7 @@ fn trans_put(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n     alt (e) {\n         case (none[@ast::expr]) { }\n         case (some[@ast::expr](?x)) {\n-            auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                    cx.fcx.lcx.ccx.node_types, x);\n+            auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, x);\n             auto arg = rec(mode=ty::mo_alias, ty=e_ty);\n             auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx,\n                                                  x.span, [arg]);\n@@ -5916,8 +5886,7 @@ fn trans_ret(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n \n     alt (e) {\n         case (some[@ast::expr](?x)) {\n-            auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                 cx.fcx.lcx.ccx.node_types, x);\n+            auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, x);\n             auto r = trans_expr(cx, x);\n             bcx = r.bcx;\n             val = r.val;\n@@ -6310,8 +6279,7 @@ fn trans_block(&@block_ctxt cx, &ast::block b) -> result {\n             if (is_terminated(bcx)) {\n                 ret r;\n             } else {\n-                auto r_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n-                                        cx.fcx.lcx.ccx.node_types, e);\n+                auto r_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n                 if (!ty::type_is_nil(cx.fcx.lcx.ccx.tcx, r_ty)) {\n                     // The value resulting from the block gets copied into an\n                     // alloca created in an outer scope and its refcount\n@@ -6539,7 +6507,7 @@ fn is_terminated(&@block_ctxt cx) -> bool {\n }\n \n fn arg_tys_of_fn(&@crate_ctxt ccx, ast::ann ann) -> vec[ty::arg] {\n-    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.node_types, ann))) {\n+    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx.node_types, ann))) {\n         case (ty::ty_fn(_, ?arg_tys, _)) {\n             ret arg_tys;\n         }\n@@ -6558,7 +6526,7 @@ fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty::t t) -> ty::t {\n \n \n fn ret_ty_of_fn(&@crate_ctxt ccx, ast::ann ann) -> ty::t {\n-    ret ret_ty_of_fn_ty(ccx, ty::ann_to_type(ccx.node_types, ann));\n+    ret ret_ty_of_fn_ty(ccx, ty::ann_to_type(ccx.tcx.node_types, ann));\n }\n \n fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n@@ -8006,9 +7974,8 @@ fn create_crate_map(&@crate_ctxt ccx) -> ValueRef {\n     ret map;\n }\n \n-fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n-               &ty::node_type_table node_types, &ty::type_cache type_cache,\n-               &str output)\n+fn trans_crate(&session::session sess, &@ast::crate crate,\n+               &ty::ctxt tcx, &str output)\n         -> ModuleRef {\n     auto llmod =\n         llvm::LLVMModuleCreateWithNameInContext(str::buf(\"rust_out\"),\n@@ -8043,7 +8010,6 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n                     item_ids = new_def_hash[ValueRef](),\n                     items = new_def_hash[@ast::item](),\n                     native_items = new_def_hash[@ast::native_item](),\n-                    type_cache = type_cache,\n                     item_symbols = new_def_hash[str](),\n                     tag_sizes = tag_sizes,\n                     discrims = new_def_hash[ValueRef](),\n@@ -8066,8 +8032,7 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n                                 mutable n_glues_created = 0u,\n                                 mutable n_null_glues = 0u,\n                                 mutable n_real_glues = 0u),\n-                    upcalls = upcall::declare_upcalls(tn, llmod),\n-                    node_types = node_types);\n+                    upcalls = upcall::declare_upcalls(tn, llmod));\n     auto cx = new_local_ctxt(ccx);\n \n     create_typedefs(ccx);"}, {"sha": "39e72c0edc71c422c70e4143803a4806ebd27fee", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=a4dd57705c7b203ad0efed4ddcc0e3959e65d627", "patch": "@@ -167,7 +167,6 @@ type fn_ctxt    = rec(fn_info enclosing,\n                       crate_ctxt ccx);\n \n type crate_ctxt = rec(ty::ctxt tcx,\n-                      ty::node_type_table node_types,\n                       node_ann_table node_anns,\n                       fn_info_map fm);\n \n@@ -370,9 +369,8 @@ fn num_locals(fn_info m) -> uint {\n   ret m.vars.size();\n }\n \n-fn new_crate_ctxt(ty::node_type_table nt, ty::ctxt cx) -> crate_ctxt {\n-    ret rec(tcx=cx, node_types=nt, \n-            node_anns=@new_uint_hash[ts_ann](),\n+fn new_crate_ctxt(ty::ctxt cx) -> crate_ctxt {\n+    ret rec(tcx=cx, node_anns=@new_uint_hash[ts_ann](),\n             fm=@new_def_hash[fn_info]());\n }\n "}, {"sha": "bfd19bbf21350f1f426700ad167ec55a80b00d4d", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=a4dd57705c7b203ad0efed4ddcc0e3959e65d627", "patch": "@@ -128,7 +128,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n     if (f.proto == ast::proto_fn\n         && ! promises(*post, fcx.id, enclosing)\n         && ! type_is_nil(fcx.ccx.tcx,\n-                         ret_ty_of_fn(fcx.ccx.node_types, fcx.ccx.tcx, a)) ) {\n+                         ret_ty_of_fn(fcx.ccx.tcx, a)) ) {\n         /* FIXME: call span_err, not span_warn, once I finish implementing\n            ! annotations */\n         fcx.ccx.tcx.sess.span_warn(f.body.span, \"In function \" + fcx.name +\n@@ -159,8 +159,8 @@ fn fn_states(&crate_ctxt ccx, &_fn f, &ident i, &def_id id, &ann a) -> () {\n     check_fn_states(fcx, f, a);\n }\n \n-fn check_crate(ty::node_type_table nt, ty::ctxt cx, @crate crate) -> () {\n-    let crate_ctxt ccx = new_crate_ctxt(nt, cx);\n+fn check_crate(ty::ctxt cx, @crate crate) -> () {\n+    let crate_ctxt ccx = new_crate_ctxt(cx);\n \n     /* Build the global map from function id to var-to-bit-num-map */\n     mk_f_to_fn_info(ccx, crate);"}, {"sha": "155b29f1b2ad06f42793353bcb7a4818f871d33e", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=a4dd57705c7b203ad0efed4ddcc0e3959e65d627", "patch": "@@ -58,13 +58,15 @@ type creader_cache = hashmap[tup(int,uint,uint),ty::t];\n type ctxt = rec(@type_store ts,\n                 session::session sess,\n                 resolve::def_map def_map,\n+                node_type_table node_types,\n+                type_cache tcache,\n                 creader_cache rcache,\n                 hashmap[t,str] short_names_cache);\n type ty_ctxt = ctxt;    // Needed for disambiguation from unify::ctxt.\n \n // Convert from method type to function type.  Pretty easy; we just drop\n // 'ident'.\n-fn method_ty_to_fn_ty(ctxt cx, method m) -> t {\n+fn method_ty_to_fn_ty(&ctxt cx, method m) -> t {\n     ret mk_fn(cx, m.proto, m.inputs, m.output);\n }\n \n@@ -215,9 +217,19 @@ fn mk_rcache() -> creader_cache {\n }\n \n fn mk_ctxt(session::session s, resolve::def_map dm) -> ctxt {\n+\n+    let vec[mutable option::t[ty::ty_param_substs_opt_and_ty]] ntt_sub =\n+        [mutable];\n+    let node_type_table ntt = @mutable ntt_sub;\n+\n+    auto tcache =\n+        common::new_def_hash[ty::ty_param_count_and_ty]();\n+\n     ret rec(ts = mk_type_store(),\n             sess = s,\n             def_map = dm,\n+            node_types = ntt,\n+            tcache = tcache,\n             rcache = mk_rcache(),\n             short_names_cache =\n                 map::mk_hashmap[ty::t,str](ty::hash_ty, ty::eq_ty));\n@@ -489,9 +501,9 @@ fn path_to_str(&ast::path pth) -> str {\n     ret result;\n }\n \n-fn ty_to_str(ctxt cx, &t typ) -> str {\n+fn ty_to_str(&ctxt cx, &t typ) -> str {\n \n-    fn fn_input_to_str(ctxt cx, &rec(mode mode, t ty) input) -> str {\n+    fn fn_input_to_str(&ctxt cx, &rec(mode mode, t ty) input) -> str {\n         auto s;\n         alt (input.mode) {\n             case (mo_val) { s = \"\"; }\n@@ -502,7 +514,7 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n         ret s + ty_to_str(cx, input.ty);\n     }\n \n-    fn fn_to_str(ctxt cx,\n+    fn fn_to_str(&ctxt cx,\n                  ast::proto proto,\n                  option::t[ast::ident] ident,\n                  vec[arg] inputs, t output) -> str {\n@@ -536,16 +548,16 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n             ret s;\n     }\n \n-    fn method_to_str(ctxt cx, &method m) -> str {\n+    fn method_to_str(&ctxt cx, &method m) -> str {\n         ret fn_to_str(cx, m.proto, some[ast::ident](m.ident),\n                       m.inputs, m.output) + \";\";\n     }\n \n-    fn field_to_str(ctxt cx, &field f) -> str {\n+    fn field_to_str(&ctxt cx, &field f) -> str {\n         ret mt_to_str(cx, f.mt) + \" \" + f.ident;\n     }\n \n-    fn mt_to_str(ctxt cx, &mt m) -> str {\n+    fn mt_to_str(&ctxt cx, &mt m) -> str {\n         auto mstr;\n         alt (m.mut) {\n             case (ast::mut)       { mstr = \"mutable \"; }\n@@ -648,7 +660,7 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n     ret s;\n }\n \n-fn ty_to_short_str(ctxt cx, t typ) -> str {\n+fn ty_to_short_str(&ctxt cx, t typ) -> str {\n     auto f = def_to_str;\n     auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata::ac_no_abbrevs);\n     auto s = metadata::Encode::ty_str(ecx, typ);\n@@ -660,7 +672,7 @@ fn ty_to_short_str(ctxt cx, t typ) -> str {\n \n type ty_walk = fn(t);\n \n-fn walk_ty(ctxt cx, ty_walk walker, t ty) {\n+fn walk_ty(&ctxt cx, ty_walk walker, t ty) {\n     alt (struct(cx, ty)) {\n         case (ty_nil)           { /* no-op */ }\n         case (ty_bot)           { /* no-op */ }\n@@ -724,7 +736,7 @@ fn walk_ty(ctxt cx, ty_walk walker, t ty) {\n \n type ty_fold = fn(t) -> t;\n \n-fn fold_ty(ctxt cx, ty_fold fld, t ty_0) -> t {\n+fn fold_ty(&ctxt cx, ty_fold fld, t ty_0) -> t {\n     auto ty = ty_0;\n     alt (struct(cx, ty)) {\n         case (ty_nil)           { /* no-op */ }\n@@ -819,13 +831,13 @@ fn fold_ty(ctxt cx, ty_fold fld, t ty_0) -> t {\n \n // Type utilities\n \n-fn rename(ctxt cx, t typ, str new_cname) -> t {\n+fn rename(&ctxt cx, t typ, str new_cname) -> t {\n     ret gen_ty_full(cx, struct(cx, typ), some[str](new_cname));\n }\n \n // Returns a type with the structural part taken from `struct_ty` and the\n // canonical name from `cname_ty`.\n-fn copy_cname(ctxt cx, t struct_ty, t cname_ty) -> t {\n+fn copy_cname(&ctxt cx, t struct_ty, t cname_ty) -> t {\n     ret gen_ty_full(cx, struct(cx, struct_ty), cname(cx, cname_ty));\n }\n \n@@ -1484,8 +1496,8 @@ fn ann_has_type_params(&node_type_table ntt, &ast::ann ann) -> bool {\n \n // Returns the type of an annotation, with type parameter substitutions\n // performed if applicable.\n-fn ann_to_monotype(ctxt cx, &node_type_table ntt, ast::ann a) -> t {\n-    auto tpot = ann_to_ty_param_substs_opt_and_ty(ntt, a);\n+fn ann_to_monotype(&ctxt cx, ast::ann a) -> t {\n+    auto tpot = ann_to_ty_param_substs_opt_and_ty(cx.node_types, a);\n     alt (tpot._0) {\n         case (none[vec[t]]) { ret tpot._1; }\n         case (some[vec[t]](?tps)) {\n@@ -1518,8 +1530,8 @@ fn bot_ann(uint node_id, ctxt tcx) -> ast::ann {\n \n \n // Returns the number of distinct type parameters in the given type.\n-fn count_ty_params(ctxt cx, t ty) -> uint {\n-    fn counter(ctxt cx, @mutable vec[uint] param_indices, t ty) {\n+fn count_ty_params(&ctxt cx, t ty) -> uint {\n+    fn counter(&ctxt cx, @mutable vec[uint] param_indices, t ty) {\n         alt (struct(cx, ty)) {\n             case (ty_param(?param_idx)) {\n                 auto seen = false;\n@@ -1650,28 +1662,28 @@ fn item_ty(&node_type_table ntt, &@ast::item it) -> ty_param_count_and_ty {\n     ret tup(ty_param_count, result_ty);\n }\n \n-fn stmt_ty(&ctxt cx, &node_type_table ntt, &@ast::stmt s) -> t {\n+fn stmt_ty(&ctxt cx, &@ast::stmt s) -> t {\n     alt (s.node) {\n         case (ast::stmt_expr(?e,_)) {\n-            ret expr_ty(cx, ntt, e);\n+            ret expr_ty(cx, e);\n         }\n         case (_) {\n             ret mk_nil(cx);\n         }\n     }\n }\n \n-fn block_ty(&ctxt cx, &node_type_table ntt, &ast::block b) -> t {\n+fn block_ty(&ctxt cx, &ast::block b) -> t {\n     alt (b.node.expr) {\n-        case (some[@ast::expr](?e)) { ret expr_ty(cx, ntt, e); }\n+        case (some[@ast::expr](?e)) { ret expr_ty(cx, e); }\n         case (none[@ast::expr])     { ret mk_nil(cx); }\n     }\n }\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-fn pat_ty(&ctxt cx, &node_type_table ntt, &@ast::pat pat) -> t {\n-    ret ann_to_monotype(cx, ntt, pat_ann(pat));\n+fn pat_ty(&ctxt cx, &@ast::pat pat) -> t {\n+    ret ann_to_monotype(cx, pat_ann(pat));\n }\n \n fn item_ann(&@ast::item it) -> ast::ann {\n@@ -1743,15 +1755,16 @@ fn expr_ann(&@ast::expr e) -> ast::ann {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-fn expr_ty(&ctxt cx, &node_type_table ntt, &@ast::expr expr) -> t {\n-    ret ann_to_monotype(cx, ntt, expr_ann(expr));\n+fn expr_ty(&ctxt cx, &@ast::expr expr) -> t {\n+    ret ann_to_monotype(cx, expr_ann(expr));\n }\n \n-fn expr_ty_params_and_ty(&ctxt cx, &node_type_table ntt, &@ast::expr expr)\n+fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr)\n         -> tup(vec[t], t) {\n     auto a = expr_ann(expr);\n \n-    ret tup(ann_to_type_params(ntt, a), ann_to_type(ntt, a));\n+    ret tup(ann_to_type_params(cx.node_types, a),\n+            ann_to_type(cx.node_types, a));\n }\n \n fn expr_has_ty_params(&node_type_table ntt, &@ast::expr expr) -> bool {\n@@ -2644,7 +2657,7 @@ fn substitute_type_params(&ctxt cx, &vec[t] bindings, &t typ) -> t {\n     if (!type_contains_bound_params(cx, typ)) {\n         ret typ;\n     }\n-    fn replacer(ctxt cx, vec[t] bindings, t typ) -> t {\n+    fn replacer(&ctxt cx, vec[t] bindings, t typ) -> t {\n         alt (struct(cx, typ)) {\n             case (ty_bound_param(?param_index)) {\n                 ret bindings.(param_index);\n@@ -2662,7 +2675,7 @@ fn bind_params_in_type(&ctxt cx, &t typ) -> t {\n     if (!type_contains_params(cx, typ)) {\n         ret typ;\n     }\n-    fn binder(ctxt cx, t typ) -> t {\n+    fn binder(&ctxt cx, t typ) -> t {\n         alt (struct(cx, typ)) {\n             case (ty_bound_param(?index)) {\n                 log_err \"bind_params_in_type() called on type that already \" +\n@@ -2701,20 +2714,18 @@ fn def_has_ty_params(&ast::def def) -> bool {\n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n fn lookup_item_type(session::session sess,\n-                    ctxt cx,\n-                    &type_cache cache,\n-                    ast::def_id did) -> ty_param_count_and_ty {\n+                    ctxt cx, ast::def_id did) -> ty_param_count_and_ty {\n     if (did._0 == sess.get_targ_crate_num()) {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already; we simply return it.\n-        ret cache.get(did);\n+        ret cx.tcache.get(did);\n     }\n \n-    alt (cache.find(did)) {\n+    alt (cx.tcache.find(did)) {\n         case (some[ty_param_count_and_ty](?tpt)) { ret tpt; }\n         case (none[ty_param_count_and_ty]) {\n             auto tyt = creader::get_type(sess, cx, did);\n-            cache.insert(did, tyt);\n+            cx.tcache.insert(did, tyt);\n             ret tyt;\n         }\n     }\n@@ -2731,8 +2742,8 @@ fn ret_ty_of_fn_ty(ty_ctxt tcx, t a_ty) -> t {\n     }\n }\n \n-fn ret_ty_of_fn(node_type_table ntt, ty_ctxt tcx, ast::ann ann) -> t {\n-    ret ret_ty_of_fn_ty(tcx, ann_to_type(ntt, ann));\n+fn ret_ty_of_fn(ty_ctxt tcx, ast::ann ann) -> t {\n+    ret ret_ty_of_fn_ty(tcx, ann_to_type(tcx.node_types, ann));\n }\n \n // Local Variables:"}, {"sha": "28f95e7c15d60bf1860b8bfad92a4963b898d661", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 155, "deletions": 224, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=a4dd57705c7b203ad0efed4ddcc0e3959e65d627", "patch": "@@ -66,15 +66,13 @@ type unify_cache = hashmap[unify_cache_entry,ty::unify::result];\n type obj_info = rec(vec[ast::obj_field] obj_fields, ast::def_id this_obj);\n \n type crate_ctxt = rec(session::session sess,\n-                      ty::type_cache type_cache,\n                       @ty_item_table item_items,\n                       mutable vec[obj_info] obj_infos,\n                       @fn_purity_table fn_purity_table,\n                       unify_cache unify_cache,\n                       mutable uint cache_hits,\n                       mutable uint cache_misses,\n-                      ty::ctxt tcx,\n-                      node_type_table node_types);\n+                      ty::ctxt tcx);\n \n type fn_ctxt = rec(ty::t ret_ty,\n                    ast::purity purity,\n@@ -151,28 +149,23 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &ast::span sp, &ast::def defn)\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast::def_fn(?id)) {\n-            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n-                                     fcx.ccx.type_cache, id);\n+            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx, id);\n         }\n         case (ast::def_native_fn(?id)) {\n-            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n-                                     fcx.ccx.type_cache, id);\n+            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx, id);\n         }\n         case (ast::def_const(?id)) {\n-            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n-                                     fcx.ccx.type_cache, id);\n+            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx, id);\n         }\n         case (ast::def_variant(_, ?vid)) {\n-            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n-                                     fcx.ccx.type_cache, vid);\n+            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx, vid);\n         }\n         case (ast::def_binding(?id)) {\n             // assert (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast::def_obj(?id)) {\n-            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n-                                     fcx.ccx.type_cache, id);\n+            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx, id);\n         }\n \n         case (ast::def_mod(_)) {\n@@ -385,7 +378,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n // ast_ty_to_ty.\n fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast::ty ast_ty) -> ty::t {\n     fn getter(@crate_ctxt ccx, &ast::def_id id) -> ty::ty_param_count_and_ty {\n-        ret ty::lookup_item_type(ccx.sess, ccx.tcx, ccx.type_cache, id);\n+        ret ty::lookup_item_type(ccx.sess, ccx.tcx, id);\n     }\n     auto f = bind getter(ccx, _);\n     ret ast_ty_to_ty(ccx.tcx, f, ast_ty);\n@@ -405,26 +398,26 @@ mod write {\n     }\n \n     // Writes a type parameter count and type pair into the node type table.\n-    fn ty(&ty::ctxt tcx, &node_type_table ntt, uint node_id,\n+    fn ty(&ty::ctxt tcx, uint node_id,\n           &ty_param_substs_opt_and_ty tpot) {\n         assert (!ty::type_contains_vars(tcx, tpot._1));\n-        be inner(ntt, node_id, tpot);\n+        be inner(tcx.node_types, node_id, tpot);\n     }\n \n     // Writes a type parameter count and type pair into the node type table.\n     // This function allows for the possibility of type variables, which will\n     // be rewritten later during the fixup phase.\n     fn ty_fixup(&@stmt_ctxt scx, uint node_id,\n                 &ty_param_substs_opt_and_ty tpot) {\n-        inner(scx.fcx.ccx.node_types, node_id, tpot);\n+        inner(scx.fcx.ccx.tcx.node_types, node_id, tpot);\n         if (ty::type_contains_vars(scx.fcx.ccx.tcx, tpot._1)) {\n             scx.fixups += [node_id];\n         }\n     }\n \n     // Writes a type with no type parameters into the node type table.\n-    fn ty_only(&ty::ctxt tcx, &node_type_table ntt, uint node_id, ty::t typ) {\n-        be ty(tcx, ntt, node_id, tup(none[vec[ty::t]], typ));\n+    fn ty_only(&ty::ctxt tcx, uint node_id, ty::t typ) {\n+        be ty(tcx, node_id, tup(none[vec[ty::t]], typ));\n     }\n \n     // Writes a type with no type parameters into the node type table. This\n@@ -434,14 +427,14 @@ mod write {\n     }\n \n     // Writes a nil type into the node type table.\n-    fn nil_ty(&ty::ctxt tcx, &node_type_table ntt, uint node_id) {\n-        be ty(tcx, ntt, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n+    fn nil_ty(&ty::ctxt tcx, uint node_id) {\n+        be ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n     }\n \n     // Writes the bottom type into the node type table.\n-    fn bot_ty(&ty::ctxt tcx, &node_type_table ntt, uint node_id) {\n+    fn bot_ty(&ty::ctxt tcx, uint node_id) {\n         // FIXME: Should be mk_bot(), but this breaks lots of stuff.\n-        be ty(tcx, ntt, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n+        be ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n     }\n }\n \n@@ -464,9 +457,7 @@ mod write {\n mod collect {\n     type ctxt = rec(session::session sess,\n                     @ty_item_table id_to_ty_item,\n-                    ty::type_cache type_cache,\n-                    ty::ctxt tcx,\n-                    node_type_table node_types);\n+                    ty::ctxt tcx);\n     type env = rec(@ctxt cx, ast::native_abi abi);\n \n     fn ty_of_fn_decl(&@ctxt cx,\n@@ -481,7 +472,7 @@ mod collect {\n         auto t_fn = ty::mk_fn(cx.tcx, proto, input_tys, output_ty);\n         auto ty_param_count = vec::len[ast::ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n-        cx.type_cache.insert(def_id, tpt);\n+        cx.tcx.tcache.insert(def_id, tpt);\n         ret tpt;\n     }\n \n@@ -497,7 +488,7 @@ mod collect {\n         auto t_fn = ty::mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n         auto ty_param_count = vec::len[ast::ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n-        cx.type_cache.insert(def_id, tpt);\n+        cx.tcx.tcache.insert(def_id, tpt);\n         ret tpt;\n     }\n \n@@ -565,7 +556,7 @@ mod collect {\n         auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1);\n \n         auto tpt = tup(t_obj._0, t_fn);\n-        cx.type_cache.insert(ctor_id, tpt);\n+        cx.tcx.tcache.insert(ctor_id, tpt);\n         ret tpt;\n     }\n \n@@ -579,7 +570,7 @@ mod collect {\n             case (ast::item_const(?ident, ?t, _, ?def_id, _)) {\n                 auto typ = convert(t);\n                 auto tpt = tup(0u, typ);\n-                cx.type_cache.insert(def_id, tpt);\n+                cx.tcx.tcache.insert(def_id, tpt);\n                 ret tpt;\n             }\n \n@@ -591,12 +582,12 @@ mod collect {\n \n             case (ast::item_obj(?ident, ?obj_info, ?tps, ?odid, _)) {\n                 auto t_obj = ty_of_obj(cx, ident, obj_info, tps);\n-                cx.type_cache.insert(odid.ty, t_obj);\n+                cx.tcx.tcache.insert(odid.ty, t_obj);\n                 ret t_obj;\n             }\n \n             case (ast::item_ty(?ident, ?t, ?tps, ?def_id, _)) {\n-                alt (cx.type_cache.find(def_id)) {\n+                alt (cx.tcx.tcache.find(def_id)) {\n                     case (some[ty::ty_param_count_and_ty](?tpt)) {\n                         ret tpt;\n                     }\n@@ -608,7 +599,7 @@ mod collect {\n                 auto typ = convert(t);\n                 auto ty_param_count = vec::len[ast::ty_param](tps);\n                 auto tpt = tup(ty_param_count, typ);\n-                cx.type_cache.insert(def_id, tpt);\n+                cx.tcx.tcache.insert(def_id, tpt);\n                 ret tpt;\n             }\n \n@@ -626,7 +617,7 @@ mod collect {\n \n                 auto ty_param_count = vec::len[ast::ty_param](tps);\n                 auto tpt = tup(ty_param_count, t);\n-                cx.type_cache.insert(def_id, tpt);\n+                cx.tcx.tcache.insert(def_id, tpt);\n                 ret tpt;\n             }\n \n@@ -647,7 +638,7 @@ mod collect {\n                                          def_id);\n             }\n             case (ast::native_item_ty(_, ?def_id)) {\n-                alt (cx.type_cache.find(def_id)) {\n+                alt (cx.tcx.tcache.find(def_id)) {\n                     case (some[ty::ty_param_count_and_ty](?tpt)) {\n                         ret tpt;\n                     }\n@@ -656,7 +647,7 @@ mod collect {\n \n                 auto t = ty::mk_native(cx.tcx);\n                 auto tpt = tup(0u, t);\n-                cx.type_cache.insert(def_id, tpt);\n+                cx.tcx.tcache.insert(def_id, tpt);\n                 ret tpt;\n             }\n         }\n@@ -699,13 +690,12 @@ mod collect {\n             }\n \n             auto tpt = tup(ty_param_count, result_ty);\n-            cx.type_cache.insert(variant.node.id, tpt);\n+            cx.tcx.tcache.insert(variant.node.id, tpt);\n             auto variant_t = rec(\n                 ann=triv_ann(variant.node.ann.id, result_ty)\n                 with variant.node\n             );\n-            write::ty_only(cx.tcx, cx.node_types, variant.node.ann.id,\n-                           result_ty);\n+            write::ty_only(cx.tcx, variant.node.ann.id, result_ty);\n             result += [fold::respan(variant.span, variant_t)];\n         }\n \n@@ -756,7 +746,7 @@ mod collect {\n             }\n             case (ast::item_tag(_, ?variants, ?ty_params, ?tag_id, ?ann)) {\n                 auto tpt = ty_of_item(cx, it);\n-                write::ty_only(cx.tcx, cx.node_types, ann.id, tpt._1);\n+                write::ty_only(cx.tcx, ann.id, tpt._1);\n \n                 get_tag_variant_types(cx, tag_id, variants, ty_params);\n             }\n@@ -768,7 +758,7 @@ mod collect {\n                 // we write into the table for this item.\n                 auto tpt = ty_of_obj_ctor(cx, ident, object, odid.ctor,\n                                           ty_params);\n-                write::ty_only(cx.tcx, cx.node_types, ann.id, tpt._1);\n+                write::ty_only(cx.tcx, ann.id, tpt._1);\n \n                 // Write the methods into the type table.\n                 //\n@@ -778,8 +768,7 @@ mod collect {\n                 auto method_types = get_obj_method_types(cx, object);\n                 auto i = 0u;\n                 while (i < vec::len[@ast::method](object.methods)) {\n-                    write::ty_only(cx.tcx, cx.node_types,\n-                                   object.methods.(i).node.ann.id,\n+                    write::ty_only(cx.tcx, object.methods.(i).node.ann.id,\n                                    ty::method_ty_to_fn_ty(cx.tcx,\n                                        method_types.(i)));\n                     i += 1u;\n@@ -793,8 +782,7 @@ mod collect {\n                 i = 0u;\n                 while (i < vec::len[ty::arg](args)) {\n                     auto fld = object.fields.(i);\n-                    write::ty_only(cx.tcx, cx.node_types, fld.ann.id,\n-                                   args.(i).ty);\n+                    write::ty_only(cx.tcx, fld.ann.id, args.(i).ty);\n                     i += 1u;\n                 }\n \n@@ -806,8 +794,7 @@ mod collect {\n                         let vec[arg] no_args = [];\n                         auto t = ty::mk_fn(cx.tcx, ast::proto_fn, no_args,\n                                            ty::mk_nil(cx.tcx));\n-                        write::ty_only(cx.tcx, cx.node_types, m.node.ann.id,\n-                                       t);\n+                        write::ty_only(cx.tcx, m.node.ann.id, t);\n                     }\n                 }\n             }\n@@ -816,8 +803,7 @@ mod collect {\n                 // of the item in passing. All we have to do here is to write\n                 // it into the node type table.\n                 auto tpt = ty_of_item(cx, it);\n-                write::ty_only(cx.tcx, cx.node_types, ty::item_ann(it).id,\n-                               tpt._1);\n+                write::ty_only(cx.tcx, ty::item_ann(it).id, tpt._1);\n             }\n         }\n     }\n@@ -835,41 +821,31 @@ mod collect {\n                 // FIXME: Native types have no annotation. Should they? --pcw\n             }\n             case (ast::native_item_fn(_,_,_,_,_,?a)) {\n-                write::ty_only(cx.tcx, cx.node_types, a.id, tpt._1);\n+                write::ty_only(cx.tcx, a.id, tpt._1);\n             }\n         }\n     }\n \n     fn collect_item_types(&session::session sess, &ty::ctxt tcx,\n-                          &@ast::crate crate)\n-            -> tup(ty::type_cache, @ty_item_table, node_type_table) {\n+                          &@ast::crate crate) -> @ty_item_table {\n         // First pass: collect all type item IDs.\n         auto module = crate.node.module;\n         auto id_to_ty_item = @common::new_def_hash[any_item]();\n \n-        let vec[mutable option::t[ty::ty_param_substs_opt_and_ty]] ntt_sub =\n-            [mutable];\n-        let node_type_table ntt = @mutable ntt_sub;\n-\n         auto visit = rec(\n             visit_item_pre = bind collect(id_to_ty_item, _),\n             visit_native_item_pre = bind collect_native(id_to_ty_item, _)\n             with walk::default_visitor()\n         );\n         walk::walk_crate(visit, *crate);\n \n-        // Second pass: translate the types of all items.\n-        auto type_cache = common::new_def_hash[ty::ty_param_count_and_ty]();\n-\n         // We have to propagate the surrounding ABI to the native items\n         // contained within the native module.\n         auto abi = @mutable none[ast::native_abi];\n \n         auto cx = @rec(sess=sess,\n                        id_to_ty_item=id_to_ty_item,\n-                       type_cache=type_cache,\n-                       tcx=tcx,\n-                       node_types=ntt);\n+                       tcx=tcx);\n \n         visit = rec(\n             visit_item_pre = bind convert(cx,abi,_),\n@@ -878,7 +854,7 @@ mod collect {\n         );\n         walk::walk_crate(visit, *crate);\n \n-        ret tup(type_cache, id_to_ty_item, ntt);\n+        ret id_to_ty_item;\n     }\n }\n \n@@ -1113,7 +1089,7 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n \n     let vec[ty::t] result = [];\n \n-    auto tpt = ty::lookup_item_type(ccx.sess, ccx.tcx, ccx.type_cache, vid);\n+    auto tpt = ty::lookup_item_type(ccx.sess, ccx.tcx, vid);\n     alt (struct(ccx.tcx, tpt._1)) {\n         case (ty::ty_fn(_, ?ins, _)) {\n             // N-ary variant.\n@@ -1160,17 +1136,17 @@ mod Pushdown {\n         alt (pat.node) {\n             case (ast::pat_wild(?ann)) {\n                 auto t = Demand::simple(scx, pat.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::pat_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(scx, pat.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::pat_bind(?id, ?did, ?ann)) {\n                 auto t = Demand::simple(scx, pat.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 scx.fcx.locals.insert(did, t);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n@@ -1187,18 +1163,18 @@ mod Pushdown {\n                 }\n \n                 // Get the types of the arguments of the variant.\n-              \n+\n                 let vec[ty::t] tparams = [];\n                 auto j = 0u;\n                 auto actual_ty_params =\n-                  ty::ann_to_type_params(scx.fcx.ccx.node_types, ann);\n+                  ty::ann_to_type_params(scx.fcx.ccx.tcx.node_types, ann);\n \n                 for (ty::t some_ty in tag_tps) {\n                     let ty::t t1 = some_ty;\n                     let ty::t t2 = actual_ty_params.(j);\n-                    \n+\n                     let ty::t res = Demand::simple(scx, pat.span, t1, t2);\n-                    \n+\n                     vec::push(tparams, res);\n                     j += 1u;\n                 }\n@@ -1218,9 +1194,9 @@ mod Pushdown {\n                 }\n \n                 auto tps =\n-                    ty::ann_to_type_params(scx.fcx.ccx.node_types, ann);\n-                auto tt = ann_to_type(scx.fcx.ccx.node_types, ann);\n-                \n+                    ty::ann_to_type_params(scx.fcx.ccx.tcx.node_types, ann);\n+                auto tt = ann_to_type(scx.fcx.ccx.tcx.node_types, ann);\n+\n                 let ty_param_substs_and_ty res_t = Demand::full(scx, pat.span,\n                       expected, tt, tps, NO_AUTODEREF);\n \n@@ -1230,7 +1206,7 @@ mod Pushdown {\n                 // TODO: push down type from \"expected\".\n                 write::ty_fixup(scx, ann.id,\n                     ty::ann_to_ty_param_substs_opt_and_ty\n-                        (scx.fcx.ccx.node_types, a_1));\n+                        (scx.fcx.ccx.tcx.node_types, a_1));\n             }\n         }\n     }\n@@ -1252,7 +1228,7 @@ mod Pushdown {\n                 // TODO: enforce mutability\n \n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_vec(?mt)) {\n                         for (@ast::expr e_0 in es_0) {\n@@ -1268,7 +1244,7 @@ mod Pushdown {\n             }\n             case (ast::expr_tup(?es_0, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_tup(?mts)) {\n                         auto i = 0u;\n@@ -1287,7 +1263,7 @@ mod Pushdown {\n             case (ast::expr_rec(?fields_0, ?base_0, ?ann)) {\n \n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_rec(?field_mts)) {\n                         alt (base_0) {\n@@ -1328,7 +1304,7 @@ mod Pushdown {\n             }\n             case (ast::expr_bind(?sube, ?es, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_call(?sube, ?es, ?ann)) {\n@@ -1337,39 +1313,39 @@ mod Pushdown {\n                 // produce a box; things like expr_binary or expr_bind can't,\n                 // so there's no need.\n                 auto t = Demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_self_method(?id, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_unary(?uop, ?sube, ?ann)) {\n                 // See note in expr_unary for why we're calling\n                 // Demand::autoderef.\n                 auto t = Demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_cast(?sube, ?ast_ty, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n                 pushdown_block(scx, expected, then_0);\n \n                 alt (else_0) {\n@@ -1382,57 +1358,57 @@ mod Pushdown {\n             }\n             case (ast::expr_for(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_while(?cond, ?bloc, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_do_while(?bloc, ?cond, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_block(?bloc, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n                 pushdown_expr(scx, expected, lhs_0);\n                 pushdown_expr(scx, expected, rhs_0);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n                 pushdown_expr(scx, expected, lhs_0);\n                 pushdown_expr(scx, expected, rhs_0);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_field(?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_index(?base, ?index, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_path(?pth, ?ann)) {\n                 auto tp_substs_0 =\n-                    ty::ann_to_type_params(scx.fcx.ccx.node_types, ann);\n-                auto t_0 = ann_to_type(scx.fcx.ccx.node_types, ann);\n+                    ty::ann_to_type_params(scx.fcx.ccx.tcx.node_types, ann);\n+                auto t_0 = ann_to_type(scx.fcx.ccx.tcx.node_types, ann);\n \n                 auto result_0 = Demand::full(scx, e.span, expected, t_0,\n                                              tp_substs_0, adk);\n@@ -1442,7 +1418,7 @@ mod Pushdown {\n                 // provided by the programmer.\n                 auto ty_params_opt;\n                 alt (ty::ann_to_ty_param_substs_opt_and_ty\n-                        (scx.fcx.ccx.node_types, ann)._0) {\n+                        (scx.fcx.ccx.tcx.node_types, ann)._0) {\n                     case (none[vec[ty::t]]) {\n                         ty_params_opt = none[vec[ty::t]];\n                     }\n@@ -1455,7 +1431,7 @@ mod Pushdown {\n             }\n             case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n             /* FIXME: should this check the type annotations? */\n@@ -1471,13 +1447,13 @@ mod Pushdown {\n \n             case (ast::expr_port(?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n \n             case (ast::expr_chan(?es, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_chan(?subty)) {\n                         auto pt = ty::mk_port(scx.fcx.ccx.tcx, subty);\n@@ -1495,25 +1471,21 @@ mod Pushdown {\n                 auto t = expected;\n                 for (ast::arm arm_0 in arms_0) {\n                     pushdown_block(scx, expected, arm_0.block);\n-                    auto bty = block_ty(scx.fcx.ccx.tcx,\n-                                        scx.fcx.ccx.node_types,\n-                                        arm_0.block);\n+                    auto bty = block_ty(scx.fcx.ccx.tcx, arm_0.block);\n                     t = Demand::simple(scx, e.span, t, bty);\n                 }\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n \n             case (ast::expr_recv(?lval, ?expr, ?ann)) {\n                 pushdown_expr(scx, next_ty_var(scx), lval);\n-                auto t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                 lval);\n+                auto t = expr_ty(scx.fcx.ccx.tcx, lval);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n \n             case (ast::expr_send(?lval, ?expr, ?ann)) {\n                 pushdown_expr(scx, next_ty_var(scx), expr);\n-                auto t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                 expr);\n+                auto t = expr_ty(scx.fcx.ccx.tcx, expr);\n                 pushdown_expr(scx, ty::mk_chan(scx.fcx.ccx.tcx, t), lval);\n             }\n \n@@ -1523,7 +1495,7 @@ mod Pushdown {\n                 // produce a box; things like expr_binary or expr_bind can't,\n                 // so there's no need.\n                 auto t = Demand::autoderef(scx, e.span, expected,\n-                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n \n@@ -1541,14 +1513,12 @@ mod Pushdown {\n         alt (bloc.node.expr) {\n             case (some[@ast::expr](?e_0)) {\n                 pushdown_expr(scx, expected, e_0);\n-                write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                              bloc.node.a.id);\n+                write::nil_ty(scx.fcx.ccx.tcx, bloc.node.a.id);\n             }\n             case (none[@ast::expr]) {\n                 Demand::simple(scx, bloc.span, expected,\n                                ty::mk_nil(scx.fcx.ccx.tcx));\n-                write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                              bloc.node.a.id);\n+                write::nil_ty(scx.fcx.ccx.tcx, bloc.node.a.id);\n             }\n         }\n     }\n@@ -1572,8 +1542,7 @@ mod writeback {\n             }\n         }\n \n-        write::ty_only(fcx.ccx.tcx, fcx.ccx.node_types, local.ann.id,\n-                       local_ty);\n+        write::ty_only(fcx.ccx.tcx, local.ann.id, local_ty);\n     }\n \n     fn resolve_local_types(&@fn_ctxt fcx, &ast::ann ann) {\n@@ -1584,15 +1553,15 @@ mod writeback {\n             }\n         }\n \n-        auto tpot = ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.node_types,\n-                                                          ann);\n+        auto tpot =\n+            ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.tcx.node_types,\n+                                                  ann);\n         auto tt = tpot._1;\n         if (!ty::type_contains_locals(fcx.ccx.tcx, tt)) { ret; }\n \n         auto f = bind resolver(fcx, _);\n         auto new_type = ty::fold_ty(fcx.ccx.tcx, f, tt);\n-        write::ty(fcx.ccx.tcx, fcx.ccx.node_types, ann.id,\n-                  tup(tpot._0, new_type));\n+        write::ty(fcx.ccx.tcx, ann.id, tup(tpot._0, new_type));\n     }\n \n     fn visit_stmt_pre(@fn_ctxt fcx, &@ast::stmt s) {\n@@ -1651,7 +1620,7 @@ fn replace_expr_type(&@stmt_ctxt scx,\n                      &@ast::expr expr,\n                      &tup(vec[ty::t], ty::t) new_tyt) {\n     auto new_tps;\n-    if (ty::expr_has_ty_params(scx.fcx.ccx.node_types, expr)) {\n+    if (ty::expr_has_ty_params(scx.fcx.ccx.tcx.node_types, expr)) {\n         new_tps = some[vec[ty::t]](new_tyt._0);\n     } else {\n         new_tps = none[vec[ty::t]];\n@@ -1698,12 +1667,12 @@ fn check_pat(&@stmt_ctxt scx, &@ast::pat pat) {\n             auto vdef = ast::variant_def_ids\n                 (scx.fcx.ccx.tcx.def_map.get(old_ann.id));\n             auto t = ty::lookup_item_type(scx.fcx.ccx.sess, scx.fcx.ccx.tcx,\n-                                          scx.fcx.ccx.type_cache, vdef._1)._1;\n+                                          vdef._1)._1;\n             auto len = vec::len[ast::ident](p.node.idents);\n             auto last_id = p.node.idents.(len - 1u);\n \n             auto tpt = ty::lookup_item_type(scx.fcx.ccx.sess, scx.fcx.ccx.tcx,\n-                                            scx.fcx.ccx.type_cache, vdef._0);\n+                                            vdef._0);\n \n             auto path_tpot = instantiate_path(scx, p, tpt, pat.span);\n \n@@ -1833,8 +1802,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             alt (a_opt) {\n                 case (some[@ast::expr](?a)) {\n                     check_expr(scx, a);\n-                    auto typ = expr_ty(scx.fcx.ccx.tcx,\n-                                       scx.fcx.ccx.node_types, a);\n+                    auto typ = expr_ty(scx.fcx.ccx.tcx, a);\n                     vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n                 }\n                 case (none[@ast::expr]) {\n@@ -1846,8 +1814,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n         auto rt_0 = next_ty_var(scx);\n         auto t_0;\n-        alt (struct(scx.fcx.ccx.tcx,\n-                    expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, f))) {\n+        alt (struct(scx.fcx.ccx.tcx, expr_ty(scx.fcx.ccx.tcx, f))) {\n             case (ty::ty_fn(?proto, _, _))   {\n                 t_0 = ty::mk_fn(scx.fcx.ccx.tcx, proto, arg_tys_0, rt_0);\n             }\n@@ -1859,15 +1826,13 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     \"check_call_or_bind(): fn expr doesn't have fn type,\"\n                     + \" instead having: \" +\n                     ty_to_str(scx.fcx.ccx.tcx,\n-                              expr_ty(scx.fcx.ccx.tcx,\n-                                      scx.fcx.ccx.node_types, f)));\n+                              expr_ty(scx.fcx.ccx.tcx, f)));\n                 fail;\n             }\n         }\n \n         // Unify the callee and arguments.\n-        auto tpt_0 = ty::expr_ty_params_and_ty(scx.fcx.ccx.tcx,\n-                                               scx.fcx.ccx.node_types, f);\n+        auto tpt_0 = ty::expr_ty_params_and_ty(scx.fcx.ccx.tcx, f);\n         auto tpt_1 = Demand::full(scx, f.span, tpt_0._1, t_0, tpt_0._0,\n                                   NO_AUTODEREF);\n         replace_expr_type(scx, f, tpt_1);\n@@ -1878,13 +1843,13 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                         &ast::ann a) {\n         check_expr(scx, lhs);\n         check_expr(scx, rhs);\n-        auto lhs_t0 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, lhs);\n-        auto rhs_t0 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, rhs);\n+        auto lhs_t0 = expr_ty(scx.fcx.ccx.tcx, lhs);\n+        auto rhs_t0 = expr_ty(scx.fcx.ccx.tcx, rhs);\n \n         Pushdown::pushdown_expr(scx, rhs_t0, lhs);\n-        auto lhs_t1 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, lhs);\n+        auto lhs_t1 = expr_ty(scx.fcx.ccx.tcx, lhs);\n         Pushdown::pushdown_expr(scx, lhs_t1, rhs);\n-        auto rhs_t1 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, rhs);\n+        auto rhs_t1 = expr_ty(scx.fcx.ccx.tcx, rhs);\n \n         auto ann = triv_ann(a.id, rhs_t1);\n         write::ty_only_fixup(scx, a.id, rhs_t1);\n@@ -1910,15 +1875,12 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         case (ast::expr_binary(?binop, ?lhs, ?rhs, ?a)) {\n             check_expr(scx, lhs);\n             check_expr(scx, rhs);\n-            auto lhs_t0 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  lhs);\n-            auto rhs_t0 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  rhs);\n+            auto lhs_t0 = expr_ty(scx.fcx.ccx.tcx, lhs);\n+            auto rhs_t0 = expr_ty(scx.fcx.ccx.tcx, rhs);\n \n             // FIXME: Binops have a bit more subtlety than this.\n             Pushdown::pushdown_expr_full(scx, rhs_t0, lhs, AUTODEREF_OK);\n-            auto lhs_t1 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  lhs);\n+            auto lhs_t1 = expr_ty(scx.fcx.ccx.tcx, lhs);\n             Pushdown::pushdown_expr_full(scx, lhs_t1, rhs, AUTODEREF_OK);\n \n             auto t = strip_boxes(scx.fcx.ccx.tcx, lhs_t0);\n@@ -1938,8 +1900,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         case (ast::expr_unary(?unop, ?oper, ?a)) {\n             check_expr(scx, oper);\n \n-            auto oper_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  oper);\n+            auto oper_t = expr_ty(scx.fcx.ccx.tcx, oper);\n             alt (unop) {\n                 case (ast::box(?mut)) {\n                     oper_t = ty::mk_box(scx.fcx.ccx.tcx,\n@@ -1988,21 +1949,20 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n         case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?a)) {\n             check_expr(scx, expanded);\n-            auto t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                             expanded);\n+            auto t = expr_ty(scx.fcx.ccx.tcx, expanded);\n             write::ty_only_fixup(scx, a.id, t);\n         }\n \n         case (ast::expr_fail(?a)) {\n-            write::bot_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::bot_ty(scx.fcx.ccx.tcx, a.id);\n         }\n \n         case (ast::expr_break(?a)) {\n-            write::bot_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::bot_ty(scx.fcx.ccx.tcx, a.id);\n         }\n \n         case (ast::expr_cont(?a)) {\n-            write::bot_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::bot_ty(scx.fcx.ccx.tcx, a.id);\n         }\n \n         case (ast::expr_ret(?expr_opt, ?a)) {\n@@ -2015,16 +1975,14 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                             \"returning non-nil\");\n                     }\n \n-                    write::bot_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  a.id);\n+                    write::bot_ty(scx.fcx.ccx.tcx, a.id);\n                 }\n \n                 case (some[@ast::expr](?e)) {\n                     check_expr(scx, e);\n                     Pushdown::pushdown_expr(scx, scx.fcx.ret_ty, e);\n \n-                    write::bot_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  a.id);\n+                    write::bot_ty(scx.fcx.ccx.tcx, a.id);\n                 }\n             }\n         }\n@@ -2041,16 +1999,14 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                             \"put; in iterator yielding non-nil\");\n                     }\n \n-                    write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  a.id);\n+                    write::nil_ty(scx.fcx.ccx.tcx, a.id);\n                 }\n \n                 case (some[@ast::expr](?e)) {\n                     check_expr(scx, e);\n                     Pushdown::pushdown_expr(scx, scx.fcx.ret_ty, e);\n \n-                    write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  a.id);\n+                    write::nil_ty(scx.fcx.ccx.tcx, a.id);\n                 }\n             }\n         }\n@@ -2062,18 +2018,18 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             check_expr(scx, e);\n             Pushdown::pushdown_expr(scx, scx.fcx.ret_ty, e);\n \n-            write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::nil_ty(scx.fcx.ccx.tcx, a.id);\n         }\n \n         case (ast::expr_log(?l, ?e, ?a)) {\n             auto expr_t = check_expr(scx, e);\n-            write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::nil_ty(scx.fcx.ccx.tcx, a.id);\n         }\n \n         case (ast::expr_check(?e, ?a)) {\n             check_expr(scx, e);\n             Demand::simple(scx, expr.span, ty::mk_bool(scx.fcx.ccx.tcx),\n-                expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e));\n+                expr_ty(scx.fcx.ccx.tcx, e));\n             /* e must be a call expr where all arguments are either\n              literals or slots */\n             alt (e.node) {\n@@ -2095,8 +2051,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                             require_pure_function(scx.fcx.ccx, d_id,\n                                                   expr.span);\n \n-                            write::nil_ty(scx.fcx.ccx.tcx,\n-                                          scx.fcx.ccx.node_types, a.id);\n+                            write::nil_ty(scx.fcx.ccx.tcx, a.id);\n                         }\n                         case (_) {\n                            scx.fcx.ccx.sess.span_err(expr.span,\n@@ -2114,10 +2069,10 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n         case (ast::expr_assert(?e, ?a)) {\n             check_expr(scx, e);\n-            auto ety = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e);\n+            auto ety = expr_ty(scx.fcx.ccx.tcx, e);\n             Demand::simple(scx, expr.span, ty::mk_bool(scx.fcx.ccx.tcx), ety);\n \n-            write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::nil_ty(scx.fcx.ccx.tcx, a.id);\n         }\n \n         case (ast::expr_assign(?lhs, ?rhs, ?a)) {\n@@ -2135,14 +2090,12 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             check_expr(scx, lhs);\n             check_expr(scx, rhs);\n-            auto rhs_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                 rhs);\n+            auto rhs_t = expr_ty(scx.fcx.ccx.tcx, rhs);\n \n             auto chan_t = ty::mk_chan(scx.fcx.ccx.tcx, rhs_t);\n             Pushdown::pushdown_expr(scx, chan_t, lhs);\n             auto item_t;\n-            auto lhs_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                 lhs);\n+            auto lhs_t = expr_ty(scx.fcx.ccx.tcx, lhs);\n             alt (struct(scx.fcx.ccx.tcx, lhs_t)) {\n                 case (ty::ty_chan(?it)) { item_t = it; }\n                 case (_) { fail; }\n@@ -2157,14 +2110,12 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             check_expr(scx, lhs);\n             check_expr(scx, rhs);\n-            auto lhs_t1 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  lhs);\n+            auto lhs_t1 = expr_ty(scx.fcx.ccx.tcx, lhs);\n \n             auto port_t = ty::mk_port(scx.fcx.ccx.tcx, lhs_t1);\n             Pushdown::pushdown_expr(scx, port_t, rhs);\n             auto item_t;\n-            auto rhs_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                 rhs);\n+            auto rhs_t = expr_ty(scx.fcx.ccx.tcx, rhs);\n             alt (struct(scx.fcx.ccx.tcx, rhs_t)) {\n                 case (ty::ty_port(?it)) { item_t = it; }\n                 case (_) { fail; }\n@@ -2180,16 +2131,14 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                                     cond);\n \n             check_block(scx, thn);\n-            auto thn_t = block_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  thn);\n+            auto thn_t = block_ty(scx.fcx.ccx.tcx, thn);\n \n             auto elsopt_t;\n             alt (elsopt) {\n                 case (some[@ast::expr](?els)) {\n                     check_expr(scx, els);\n                     Pushdown::pushdown_expr(scx, thn_t, els);\n-                    elsopt_t = expr_ty(scx.fcx.ccx.tcx,\n-                                       scx.fcx.ccx.node_types, els);\n+                    elsopt_t = expr_ty(scx.fcx.ccx.tcx, els);\n                 }\n                 case (none[@ast::expr]) {\n                     elsopt_t = ty::mk_nil(scx.fcx.ccx.tcx);\n@@ -2236,8 +2185,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             Pushdown::pushdown_expr(scx, ty::mk_bool(scx.fcx.ccx.tcx), cond);\n             check_block(scx, body);\n \n-            auto typ = block_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                body);\n+            auto typ = block_ty(scx.fcx.ccx.tcx, body);\n             write::ty_only_fixup(scx, a.id, typ);\n         }\n \n@@ -2246,14 +2194,13 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             // Typecheck the patterns first, so that we get types for all the\n             // bindings.\n-            auto pattern_ty = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                      expr);\n+            auto pattern_ty = expr_ty(scx.fcx.ccx.tcx, expr);\n \n             let vec[@ast::pat] pats = [];\n             for (ast::arm arm in arms) {\n                 check_pat(scx, arm.pat);\n                 pattern_ty = Demand::simple(scx, arm.pat.span, pattern_ty,\n-                    pat_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, arm.pat));\n+                    pat_ty(scx.fcx.ccx.tcx, arm.pat));\n                 pats += [arm.pat];\n             }\n \n@@ -2268,8 +2215,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             for (ast::arm arm in arms) {\n                 check_block(scx, arm.block);\n \n-                auto bty = block_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                    arm.block);\n+                auto bty = block_ty(scx.fcx.ccx.tcx, arm.block);\n                 result_ty = Demand::simple(scx, arm.block.span, result_ty,\n                                            bty);\n             }\n@@ -2288,8 +2234,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             check_block(scx, b);\n             alt (b.node.expr) {\n                 case (some[@ast::expr](?expr)) {\n-                    auto typ = expr_ty(scx.fcx.ccx.tcx,\n-                                       scx.fcx.ccx.node_types, expr);\n+                    auto typ = expr_ty(scx.fcx.ccx.tcx, expr);\n                     write::ty_only_fixup(scx, a.id, typ);\n                 }\n                 case (none[@ast::expr]) {\n@@ -2307,7 +2252,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             auto proto_1;\n             let vec[ty::arg] arg_tys_1 = [];\n             auto rt_1;\n-            auto fty = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, f);\n+            auto fty = expr_ty(scx.fcx.ccx.tcx, f);\n             alt (struct(scx.fcx.ccx.tcx, fty)) {\n                 case (ty::ty_fn(?proto, ?arg_tys, ?rt)) {\n                     proto_1 = proto;\n@@ -2347,7 +2292,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             // Pull the return type out of the type of the function.\n             auto rt_1 = ty::mk_nil(scx.fcx.ccx.tcx); // FIXME: typestate botch\n-            auto fty = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, f);\n+            auto fty = expr_ty(scx.fcx.ccx.tcx, f);\n             alt (struct(scx.fcx.ccx.tcx, fty)) {\n                 case (ty::ty_fn(_,_,?rt))           { rt_1 = rt; }\n                 case (ty::ty_native_fn(_, _, ?rt))  { rt_1 = rt; }\n@@ -2367,7 +2312,8 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             auto oinfo_opt = get_obj_info(scx.fcx.ccx);\n             auto this_obj_id = option::get[obj_info](oinfo_opt).this_obj;\n             this_obj_ty = ty::lookup_item_type(scx.fcx.ccx.sess,\n-                scx.fcx.ccx.tcx, scx.fcx.ccx.type_cache, this_obj_id)._1;\n+                                               scx.fcx.ccx.tcx,\n+                                               this_obj_id)._1;\n \n             // Grab this method's type out of the current object type.\n             alt (struct(scx.fcx.ccx.tcx, this_obj_ty)) {\n@@ -2391,7 +2337,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             check_call(scx, f, args);\n \n             // Check the return type\n-            auto fty = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, f);\n+            auto fty = expr_ty(scx.fcx.ccx.tcx, f);\n             alt (struct(scx.fcx.ccx.tcx, fty)) {\n                 case (ty::ty_fn(_,_,?rt)) {\n                     alt (struct(scx.fcx.ccx.tcx, rt)) {\n@@ -2419,12 +2365,12 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             auto t_1 = ast_ty_to_ty_crate(scx.fcx.ccx, t);\n             // FIXME: there are more forms of cast to support, eventually.\n             if (! (type_is_scalar(scx.fcx.ccx.tcx,\n-                    expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e)) &&\n+                    expr_ty(scx.fcx.ccx.tcx, e)) &&\n                     type_is_scalar(scx.fcx.ccx.tcx, t_1))) {\n                 scx.fcx.ccx.sess.span_err(expr.span,\n                     \"non-scalar cast: \" +\n                     ty_to_str(scx.fcx.ccx.tcx,\n-                        expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e)) +\n+                        expr_ty(scx.fcx.ccx.tcx, e)) +\n                     \" as \" + ty_to_str(scx.fcx.ccx.tcx, t_1));\n             }\n \n@@ -2437,14 +2383,12 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 t = next_ty_var(scx);\n             } else {\n                 check_expr(scx, args.(0));\n-                t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                            args.(0));\n+                t = expr_ty(scx.fcx.ccx.tcx, args.(0));\n             }\n \n             for (@ast::expr e in args) {\n                 check_expr(scx, e);\n-                auto expr_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                      e);\n+                auto expr_t = expr_ty(scx.fcx.ccx.tcx, e);\n                 Demand::simple(scx, expr.span, t, expr_t);\n             }\n \n@@ -2457,8 +2401,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             for (ast::elt e in elts) {\n                 check_expr(scx, e.expr);\n-                auto ety = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                   e.expr);\n+                auto ety = expr_ty(scx.fcx.ccx.tcx, e.expr);\n                 elts_mt += [rec(ty=ety, mut=e.mut)];\n             }\n \n@@ -2477,8 +2420,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             for (ast::field f in fields) {\n                 check_expr(scx, f.expr);\n-                auto expr_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                      f.expr);\n+                auto expr_t = expr_ty(scx.fcx.ccx.tcx, f.expr);\n \n                 auto expr_mt = rec(ty=expr_t, mut=f.mut);\n                 vec::push[field](fields_t, rec(ident=f.ident, mt=expr_mt));\n@@ -2492,8 +2434,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n                 case (some[@ast::expr](?bexpr)) {\n                     check_expr(scx, bexpr);\n-                    auto bexpr_t = expr_ty(scx.fcx.ccx.tcx,\n-                                           scx.fcx.ccx.node_types, bexpr);\n+                    auto bexpr_t = expr_ty(scx.fcx.ccx.tcx, bexpr);\n \n                     let vec[field] base_fields = [];\n \n@@ -2530,8 +2471,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n         case (ast::expr_field(?base, ?field, ?a)) {\n             check_expr(scx, base);\n-            auto base_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  base);\n+            auto base_t = expr_ty(scx.fcx.ccx.tcx, base);\n             base_t = strip_boxes(scx.fcx.ccx.tcx, base_t);\n             alt (struct(scx.fcx.ccx.tcx, base_t)) {\n                 case (ty::ty_tup(?args)) {\n@@ -2577,13 +2517,11 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n         case (ast::expr_index(?base, ?idx, ?a)) {\n             check_expr(scx, base);\n-            auto base_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                  base);\n+            auto base_t = expr_ty(scx.fcx.ccx.tcx, base);\n             base_t = strip_boxes(scx.fcx.ccx.tcx, base_t);\n \n             check_expr(scx, idx);\n-            auto idx_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                 idx);\n+            auto idx_t = expr_ty(scx.fcx.ccx.tcx, idx);\n             alt (struct(scx.fcx.ccx.tcx, base_t)) {\n                 case (ty::ty_vec(?mt)) {\n                     if (! type_is_integral(scx.fcx.ccx.tcx, idx_t)) {\n@@ -2621,7 +2559,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n         case (ast::expr_chan(?x, ?a)) {\n             check_expr(scx, x);\n-            auto port_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, x);\n+            auto port_t = expr_ty(scx.fcx.ccx.tcx, x);\n             alt (struct(scx.fcx.ccx.tcx, port_t)) {\n                 case (ty::ty_port(?subtype)) {\n                     auto ct = ty::mk_chan(scx.fcx.ccx.tcx, subtype);\n@@ -2685,7 +2623,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n             }\n \n             auto a_res = local.ann;\n-            write::ty_only(fcx.ccx.tcx, fcx.ccx.node_types, a_res.id, t);\n+            write::ty_only(fcx.ccx.tcx, a_res.id, t);\n \n             auto initopt = local.init;\n             alt (local.init) {\n@@ -2703,7 +2641,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n \n fn check_and_pushdown_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n     check_expr(scx, expr);\n-    auto ety = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, expr);\n+    auto ety = expr_ty(scx.fcx.ccx.tcx, expr);\n     Pushdown::pushdown_expr(scx, ety, expr);\n }\n \n@@ -2723,7 +2661,7 @@ fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) {\n         }\n     }\n \n-    write::nil_ty(fcx.ccx.tcx, fcx.ccx.node_types, node_id);\n+    write::nil_ty(fcx.ccx.tcx, node_id);\n }\n \n fn check_block(&@stmt_ctxt scx, &ast::block block) {\n@@ -2733,18 +2671,18 @@ fn check_block(&@stmt_ctxt scx, &ast::block block) {\n         case (none[@ast::expr]) { /* empty */ }\n         case (some[@ast::expr](?e)) {\n             check_expr(scx, e);\n-            auto ety = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e);\n+            auto ety = expr_ty(scx.fcx.ccx.tcx, e);\n             Pushdown::pushdown_expr(scx, ety, e);\n         }\n     }\n \n-    write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, block.node.a.id);\n+    write::nil_ty(scx.fcx.ccx.tcx, block.node.a.id);\n }\n \n fn check_const(&@crate_ctxt ccx, &span sp, &@ast::expr e, &ast::ann ann) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n-    auto rty = ann_to_type(ccx.node_types, ann);\n+    auto rty = ann_to_type(ccx.tcx.node_types, ann);\n     let @fn_ctxt fcx = @rec(ret_ty = rty,\n                             purity = ast::pure_fn,\n                             locals = @common::new_def_hash[ty::t](),\n@@ -2764,7 +2702,7 @@ fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n     alt (get_obj_info(ccx)) {\n         case (option::some[obj_info](?oinfo)) {\n             for (ast::obj_field f in oinfo.obj_fields) {\n-                auto field_ty = ty::ann_to_type(ccx.node_types, f.ann);\n+                auto field_ty = ty::ann_to_type(ccx.tcx.node_types, f.ann);\n                 local_ty_table.insert(f.id, field_ty);\n             }\n         }\n@@ -2884,11 +2822,9 @@ fn mk_fn_purity_table(&@ast::crate crate) -> @fn_purity_table {\n     ret res;\n }\n \n-type typecheck_result = tup(node_type_table, ty::type_cache);\n-\n-fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n+fn check_crate(&ty::ctxt tcx, &@ast::crate crate) {\n     auto sess = tcx.sess;\n-    auto result = collect::collect_item_types(sess, tcx, crate);\n+    auto all_items = collect::collect_item_types(sess, tcx, crate);\n \n     let vec[obj_info] obj_infos = [];\n \n@@ -2897,18 +2833,15 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n     auto unify_cache =\n         map::mk_hashmap[unify_cache_entry,ty::unify::result](hasher, eqer);\n     auto fpt = mk_fn_purity_table(crate); // use a variation on collect\n-    let node_type_table node_types = result._2;\n \n     auto ccx = @rec(sess=sess,\n-                    type_cache=result._0,\n-                    item_items=result._1,\n+                    item_items=all_items,\n                     mutable obj_infos=obj_infos,\n                     fn_purity_table=fpt,\n                     unify_cache=unify_cache,\n                     mutable cache_hits=0u,\n                     mutable cache_misses=0u,\n-                    tcx=tcx,\n-                    node_types=node_types);\n+                    tcx=tcx);\n \n     auto visit = rec(visit_item_pre = bind check_item(ccx, _)\n                      with walk::default_visitor());\n@@ -2917,8 +2850,6 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n \n     log #fmt(\"cache hit rate: %u/%u\", ccx.cache_hits,\n              ccx.cache_hits + ccx.cache_misses);\n-\n-    ret tup(node_types, ccx.type_cache);\n }\n \n //"}, {"sha": "695f7bf9c275d735ee715de9a2f5dcc9a1b89d05", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd57705c7b203ad0efed4ddcc0e3959e65d627/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=a4dd57705c7b203ad0efed4ddcc0e3959e65d627", "patch": "@@ -14,7 +14,7 @@ const uint default_columns = 78u;\n \n tag mode {\n     mo_untyped;\n-    mo_typed(ty::ctxt, ty::node_type_table, ty::type_cache);\n+    mo_typed(ty::ctxt);\n }\n \n type ps = @rec(pp::ps s,\n@@ -406,7 +406,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n \n     alt (s.mode) {\n         case (mo_untyped) { /* no-op */ }\n-        case (mo_typed(_, _, _)) { popen(s); }\n+        case (mo_typed(_)) { popen(s); }\n     }\n \n     alt (expr.node) {\n@@ -719,10 +719,10 @@ fn print_expr(ps s, &@ast::expr expr) {\n     // Print the type if necessary.\n     alt (s.mode) {\n         case (mo_untyped) { /* no-op */ }\n-        case (mo_typed(?tcx, ?ntt, ?tc)) {\n+        case (mo_typed(?tcx)) {\n             space(s.s);\n             wrd1(s, \"as\");\n-            wrd(s.s, ty::ty_to_str(tcx, ty::expr_ty(tcx, ntt, expr)));\n+            wrd(s.s, ty::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n             pclose(s);\n         }\n     }\n@@ -747,8 +747,9 @@ fn print_decl(ps s, @ast::decl decl) {\n                     // Print the type if necessary.\n                     alt (s.mode) {\n                         case (mo_untyped) { /* no-op */ }\n-                        case (mo_typed(?tcx, ?ntt, ?tc)) {\n-                            auto lty = ty::ann_to_type(ntt, loc.ann);\n+                        case (mo_typed(?tcx)) {\n+                            auto lty =\n+                                ty::ann_to_type(tcx.node_types, loc.ann);\n                             wrd1(s, ty::ty_to_str(tcx, lty));\n                         }\n                     }"}]}