{"sha": "dee53d7c90812d0cbabe7f19b35c125432c1c8c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZTUzZDdjOTA4MTJkMGNiYWJlN2YxOWIzNWMxMjU0MzJjMWM4Yzc=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-09T17:10:54Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-15T15:02:49Z"}, "message": "Fix suggestion to constrain trait for method to be found", "tree": {"sha": "f38f0299fec582b440bb4e3c12b750c4f347efbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f38f0299fec582b440bb4e3c12b750c4f347efbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dee53d7c90812d0cbabe7f19b35c125432c1c8c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dee53d7c90812d0cbabe7f19b35c125432c1c8c7", "html_url": "https://github.com/rust-lang/rust/commit/dee53d7c90812d0cbabe7f19b35c125432c1c8c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dee53d7c90812d0cbabe7f19b35c125432c1c8c7/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e413dc36a83a5aad3ab6270373000693a917e92b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e413dc36a83a5aad3ab6270373000693a917e92b", "html_url": "https://github.com/rust-lang/rust/commit/e413dc36a83a5aad3ab6270373000693a917e92b"}], "stats": {"total": 234, "additions": 191, "deletions": 43}, "files": [{"sha": "f2d001eadedde1cf9c543479a9795b38185d8b6d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 70, "deletions": 43, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/dee53d7c90812d0cbabe7f19b35c125432c1c8c7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee53d7c90812d0cbabe7f19b35c125432c1c8c7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dee53d7c90812d0cbabe7f19b35c125432c1c8c7", "patch": "@@ -777,19 +777,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 \"items from traits can only be used if the trait is implemented and in scope\"\n             });\n-            let mut msg = format!(\n+            let message = |action| format!(\n                 \"the following {traits_define} an item `{name}`, perhaps you need to {action} \\\n                  {one_of_them}:\",\n                 traits_define = if candidates.len() == 1 {\n                     \"trait defines\"\n                 } else {\n                     \"traits define\"\n                 },\n-                action = if let Some(param) = param_type {\n-                    format!(\"restrict type parameter `{}` with\", param)\n-                } else {\n-                    \"implement\".to_string()\n-                },\n+                action = action,\n                 one_of_them = if candidates.len() == 1 {\n                     \"it\"\n                 } else {\n@@ -809,50 +805,81 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // Get the `hir::Param` to verify whether it already has any bounds.\n                         // We do this to avoid suggesting code that ends up as `T: FooBar`,\n                         // instead we suggest `T: Foo + Bar` in that case.\n-                        let mut has_bounds = None;\n-                        let mut impl_trait = false;\n-                        if let Node::GenericParam(ref param) = hir.get(id) {\n-                            let kind = &param.kind;\n-                            if let hir::GenericParamKind::Type { synthetic: Some(_), .. } = kind {\n-                                // We've found `fn foo(x: impl Trait)` instead of\n-                                // `fn foo<T>(x: T)`. We want to suggest the correct\n-                                // `fn foo(x: impl Trait + TraitBound)` instead of\n-                                // `fn foo<T: TraitBound>(x: T)`. (See #63706.)\n-                                impl_trait = true;\n-                                has_bounds = param.bounds.get(1);\n-                            } else {\n-                                has_bounds = param.bounds.get(0);\n+                        match hir.get(id) {\n+                            Node::GenericParam(ref param) => {\n+                                let mut impl_trait = false;\n+                                let has_bounds = if let hir::GenericParamKind::Type {\n+                                    synthetic: Some(_), ..\n+                                } = &param.kind {\n+                                    // We've found `fn foo(x: impl Trait)` instead of\n+                                    // `fn foo<T>(x: T)`. We want to suggest the correct\n+                                    // `fn foo(x: impl Trait + TraitBound)` instead of\n+                                    // `fn foo<T: TraitBound>(x: T)`. (#63706)\n+                                    impl_trait = true;\n+                                    param.bounds.get(1)\n+                                } else {\n+                                    param.bounds.get(0)\n+                                };\n+                                let sp = hir.span(id);\n+                                let sp = if let Some(first_bound) = has_bounds {\n+                                    // `sp` only covers `T`, change it so that it covers\n+                                    // `T:` when appropriate\n+                                    sp.until(first_bound.span())\n+                                } else {\n+                                    sp\n+                                };\n+                                // FIXME: contrast `t.def_id` against `param.bounds` to not suggest\n+                                // traits already there. That can happen when the cause is that\n+                                // we're in a const scope or associated function used as a method.\n+                                err.span_suggestions(\n+                                    sp,\n+                                    &message(format!(\n+                                        \"restrict type parameter `{}` with\",\n+                                        param.name.ident().as_str(),\n+                                    )),\n+                                    candidates.iter().map(|t| format!(\n+                                        \"{}{} {}{}\",\n+                                        param.name.ident().as_str(),\n+                                        if impl_trait { \" +\" } else { \":\" },\n+                                        self.tcx.def_path_str(t.def_id),\n+                                        if has_bounds.is_some() { \" + \"} else { \"\" },\n+                                    )),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                suggested = true;\n+                            }\n+                            Node::Item(hir::Item {\n+                                kind: hir::ItemKind::Trait(.., bounds, _), ident, ..\n+                            }) => {\n+                                let (sp, sep, article) = if bounds.is_empty() {\n+                                    (ident.span.shrink_to_hi(), \":\", \"a\")\n+                                } else {\n+                                    (bounds.last().unwrap().span().shrink_to_hi(), \" +\", \"another\")\n+                                };\n+                                err.span_suggestions(\n+                                    sp,\n+                                    &message(format!(\"add {} supertrait for\", article)),\n+                                    candidates.iter().map(|t| format!(\n+                                        \"{} {}\",\n+                                        sep,\n+                                        self.tcx.def_path_str(t.def_id),\n+                                    )),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                suggested = true;\n                             }\n+                            _ => {}\n                         }\n-                        let sp = hir.span(id);\n-                        // `sp` only covers `T`, change it so that it covers `T:` when appropriate.\n-                        let sp = if let Some(first_bound) = has_bounds {\n-                            sp.until(first_bound.span())\n-                        } else {\n-                            sp\n-                        };\n-\n-                        // FIXME: contrast `t.def_id` against `param.bounds` to not suggest traits\n-                        // already there. That can happen when the cause is that we're in a const\n-                        // scope or associated function used as a method.\n-                        err.span_suggestions(\n-                            sp,\n-                            &msg[..],\n-                            candidates.iter().map(|t| format!(\n-                                \"{}{} {}{}\",\n-                                param,\n-                                if impl_trait { \" +\" } else { \":\" },\n-                                self.tcx.def_path_str(t.def_id),\n-                                if has_bounds.is_some() { \" + \" } else { \"\" },\n-                            )),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        suggested = true;\n                     }\n                 };\n             }\n \n             if !suggested {\n+                let mut msg = message(if let Some(param) = param_type {\n+                    format!(\"restrict type parameter `{}` with\", param)\n+                } else {\n+                    \"implement\".to_string()\n+                });\n                 for (i, trait_info) in candidates.iter().enumerate() {\n                     msg.push_str(&format!(\n                         \"\\ncandidate #{}: `{}`\","}, {"sha": "dda9e931353b21be902616f225b67f3c112c7bfa", "filename": "src/test/ui/suggestions/constrain-trait.fixed", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dee53d7c90812d0cbabe7f19b35c125432c1c8c7/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/dee53d7c90812d0cbabe7f19b35c125432c1c8c7/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.fixed?ref=dee53d7c90812d0cbabe7f19b35c125432c1c8c7", "patch": "@@ -0,0 +1,47 @@\n+// run-rustfix\n+// check-only\n+\n+#[derive(Debug)]\n+struct Demo {\n+    a: String\n+}\n+\n+trait GetString {\n+    fn get_a(&self) -> &String;\n+}\n+\n+trait UseString: std::fmt::Debug + GetString {\n+    fn use_string(&self) {\n+        println!(\"{:?}\", self.get_a()); //~ ERROR no method named `get_a` found for type `&Self`\n+    }\n+}\n+\n+trait UseString2: GetString {\n+    fn use_string(&self) {\n+        println!(\"{:?}\", self.get_a()); //~ ERROR no method named `get_a` found for type `&Self`\n+    }\n+}\n+\n+impl GetString for Demo {\n+    fn get_a(&self) -> &String {\n+        &self.a\n+    }\n+}\n+\n+impl UseString for Demo {}\n+impl UseString2 for Demo {}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{Demo, UseString};\n+\n+    #[test]\n+    fn it_works() {\n+        let d = Demo { a: \"test\".to_string() };\n+        d.use_string();\n+    }\n+}\n+\n+\n+fn main() {}"}, {"sha": "4ef0eff5bd7699b1417319c8b4c72ce203759043", "filename": "src/test/ui/suggestions/constrain-trait.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dee53d7c90812d0cbabe7f19b35c125432c1c8c7/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee53d7c90812d0cbabe7f19b35c125432c1c8c7/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.rs?ref=dee53d7c90812d0cbabe7f19b35c125432c1c8c7", "patch": "@@ -0,0 +1,47 @@\n+// run-rustfix\n+// check-only\n+\n+#[derive(Debug)]\n+struct Demo {\n+    a: String\n+}\n+\n+trait GetString {\n+    fn get_a(&self) -> &String;\n+}\n+\n+trait UseString: std::fmt::Debug {\n+    fn use_string(&self) {\n+        println!(\"{:?}\", self.get_a()); //~ ERROR no method named `get_a` found for type `&Self`\n+    }\n+}\n+\n+trait UseString2 {\n+    fn use_string(&self) {\n+        println!(\"{:?}\", self.get_a()); //~ ERROR no method named `get_a` found for type `&Self`\n+    }\n+}\n+\n+impl GetString for Demo {\n+    fn get_a(&self) -> &String {\n+        &self.a\n+    }\n+}\n+\n+impl UseString for Demo {}\n+impl UseString2 for Demo {}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{Demo, UseString};\n+\n+    #[test]\n+    fn it_works() {\n+        let d = Demo { a: \"test\".to_string() };\n+        d.use_string();\n+    }\n+}\n+\n+\n+fn main() {}"}, {"sha": "3cc351ac80aed245af906e9420278697274feeb1", "filename": "src/test/ui/suggestions/constrain-trait.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dee53d7c90812d0cbabe7f19b35c125432c1c8c7/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee53d7c90812d0cbabe7f19b35c125432c1c8c7/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.stderr?ref=dee53d7c90812d0cbabe7f19b35c125432c1c8c7", "patch": "@@ -0,0 +1,27 @@\n+error[E0599]: no method named `get_a` found for type `&Self` in the current scope\n+  --> $DIR/constrain-trait.rs:15:31\n+   |\n+LL |         println!(\"{:?}\", self.get_a());\n+   |                               ^^^^^ method not found in `&Self`\n+   |\n+   = help: items from traits can only be used if the type parameter is bounded by the trait\n+help: the following trait defines an item `get_a`, perhaps you need to add another supertrait for it:\n+   |\n+LL | trait UseString: std::fmt::Debug + GetString {\n+   |                                  ^^^^^^^^^^^\n+\n+error[E0599]: no method named `get_a` found for type `&Self` in the current scope\n+  --> $DIR/constrain-trait.rs:21:31\n+   |\n+LL |         println!(\"{:?}\", self.get_a());\n+   |                               ^^^^^ method not found in `&Self`\n+   |\n+   = help: items from traits can only be used if the type parameter is bounded by the trait\n+help: the following trait defines an item `get_a`, perhaps you need to add a supertrait for it:\n+   |\n+LL | trait UseString2: GetString {\n+   |                 ^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}]}