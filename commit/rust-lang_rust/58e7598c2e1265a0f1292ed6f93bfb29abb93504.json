{"sha": "58e7598c2e1265a0f1292ed6f93bfb29abb93504", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZTc1OThjMmUxMjY1YTBmMTI5MmVkNmY5M2JmYjI5YWJiOTM1MDQ=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-26T17:11:19Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:10Z"}, "message": "added gensym_copy mechanism to ensure sharing of pointers in the interner\n\nthis makes comparisons constant-time, and enables spelling-comparison\nof identifiers, crucial in many parts of resolve.", "tree": {"sha": "926acafd1d74b6d1d359fe66840d64f0f5fa2bb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/926acafd1d74b6d1d359fe66840d64f0f5fa2bb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58e7598c2e1265a0f1292ed6f93bfb29abb93504", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58e7598c2e1265a0f1292ed6f93bfb29abb93504", "html_url": "https://github.com/rust-lang/rust/commit/58e7598c2e1265a0f1292ed6f93bfb29abb93504", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58e7598c2e1265a0f1292ed6f93bfb29abb93504/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d33001a90319fc242dcf43ec3c7e1fa1c11d847", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d33001a90319fc242dcf43ec3c7e1fa1c11d847", "html_url": "https://github.com/rust-lang/rust/commit/9d33001a90319fc242dcf43ec3c7e1fa1c11d847"}], "stats": {"total": 136, "additions": 88, "deletions": 48}, "files": [{"sha": "17928338f37c09bcdecbc81a524f634b6804b03a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/58e7598c2e1265a0f1292ed6f93bfb29abb93504/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e7598c2e1265a0f1292ed6f93bfb29abb93504/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=58e7598c2e1265a0f1292ed6f93bfb29abb93504", "patch": "@@ -15,12 +15,12 @@ use parse::token;\n use util::interner::StrInterner;\n use util::interner;\n \n+use std::cast;\n use std::char;\n use std::cmp::Equiv;\n use std::local_data;\n use std::rand;\n use std::rand::RngUtil;\n-use std::ptr::to_unsafe_ptr;\n \n #[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n pub enum binop {\n@@ -382,30 +382,8 @@ pub fn token_to_binop(tok: &Token) -> Option<ast::BinOp> {\n   }\n }\n \n-pub struct ident_interner {\n-    priv interner: StrInterner,\n-}\n-\n-impl ident_interner {\n-    pub fn intern(&self, val: &str) -> Name {\n-        self.interner.intern(val)\n-    }\n-    pub fn gensym(&self, val: &str) -> Name {\n-        self.interner.gensym(val)\n-    }\n-    pub fn get(&self, idx: Name) -> @str {\n-        self.interner.get(idx)\n-    }\n-    // is this really something that should be exposed?\n-    pub fn len(&self) -> uint {\n-        self.interner.len()\n-    }\n-    pub fn find_equiv<Q:Hash + IterBytes + Equiv<@str>>(&self, val: &Q)\n-                                                     -> Option<Name> {\n-        self.interner.find_equiv(val)\n-    }\n-}\n-\n+// looks like we can get rid of this completely...\n+pub type ident_interner = StrInterner;\n \n // return a fresh interner, preloaded with special identifiers.\n fn mk_fresh_ident_interner() -> @ident_interner {\n@@ -486,9 +464,7 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n         \"typeof\",             // 67\n     ];\n \n-    @ident_interner {\n-        interner: interner::StrInterner::prefill(init_vec)\n-    }\n+    @interner::StrInterner::prefill(init_vec)\n }\n \n // if an interner exists in TLS, return it. Otherwise, prepare a\n@@ -509,7 +485,7 @@ pub fn get_ident_interner() -> @ident_interner {\n /* for when we don't care about the contents; doesn't interact with TLD or\n    serialization */\n pub fn mk_fake_ident_interner() -> @ident_interner {\n-    @ident_interner { interner: interner::StrInterner::new() }\n+    @interner::StrInterner::new()\n }\n \n // maps a string to its interned representation\n@@ -545,10 +521,11 @@ pub fn gensym_ident(str : &str) -> ast::Ident {\n }\n \n // create a fresh name that maps to the same string as the old one.\n-// note that this guarantees that ptr_eq(ident_to_str(src),interner_get(fresh_name(src)));\n+// note that this guarantees that str_ptr_eq(ident_to_str(src),interner_get(fresh_name(src)));\n // that is, that the new name and the old one are connected to ptr_eq strings.\n pub fn fresh_name(src : &ast::Ident) -> Name {\n-    gensym(ident_to_str(src))\n+    let interner = get_ident_interner();\n+    interner.gensym_copy(src.name)\n     // following: debug version. Could work in final except that it's incompatible with\n     // good error messages and uses of struct names in ambiguous could-be-binding\n     // locations. Also definitely destroys the guarantee given above about ptr_eq.\n@@ -557,18 +534,26 @@ pub fn fresh_name(src : &ast::Ident) -> Name {\n }\n \n // it looks like there oughta be a str_ptr_eq fn, but no one bothered to implement it?\n-pub fn str_ptr_eq<T>(a: @str, b: @str) -> bool {\n-    // doesn't compile! ...because of rebase mangling. this should be fixed\n-    // in the commit that follows this.\n-    let (a_ptr, b_ptr): (*uint, *uint) = (to_unsafe_ptr(a), to_unsafe_ptr(b));\n-    a_ptr == b_ptr\n-}\n-\n \n+// determine whether two @str values are pointer-equal\n+pub fn str_ptr_eq(a : @str, b : @str) -> bool {\n+    unsafe {\n+        let p : uint = cast::transmute(a);\n+        let q : uint = cast::transmute(b);\n+        let result = p == q;\n+        // got to transmute them back, to make sure the ref count is correct:\n+        let junk1 : @str = cast::transmute(p);\n+        let junk2 : @str = cast::transmute(q);\n+        result\n+    }\n+}\n \n // return true when two identifiers refer (through the intern table) to the same ptr_eq\n // string. This is used to compare identifiers in places where hygienic comparison is\n // not wanted (i.e. not lexical vars).\n+pub fn ident_spelling_eq(a : &ast::Ident, b : &ast::Ident) -> bool {\n+    str_ptr_eq(interner_get(a.name),interner_get(b.name))\n+}\n \n // create a fresh mark.\n pub fn fresh_mark() -> Mrk {\n@@ -721,13 +706,21 @@ mod test {\n     use ast_util;\n \n \n-    #[test] fn t1() {\n+    #[test] fn str_ptr_eq_tests(){\n+        let a = @\"abc\";\n+        let b = @\"abc\";\n+        let c = a;\n+        assert!(str_ptr_eq(a,c));\n+        assert!(!str_ptr_eq(a,b));\n+    }\n+\n+    #[test] fn fresh_name_pointer_sharing() {\n         let ghi = str_to_ident(\"ghi\");\n         assert_eq!(ident_to_str(&ghi),@\"ghi\");\n+        assert!(str_ptr_eq(ident_to_str(&ghi),ident_to_str(&ghi)))\n         let fresh = ast::Ident::new(fresh_name(&ghi));\n         assert_eq!(ident_to_str(&fresh),@\"ghi\");\n         assert!(str_ptr_eq(ident_to_str(&ghi),ident_to_str(&fresh)));\n-        assert_eq!(3,4);\n     }\n \n }"}, {"sha": "2b1e7eaa9b26d592a0fd6dd98e449f8a07d7817d", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 55, "deletions": 8, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/58e7598c2e1265a0f1292ed6f93bfb29abb93504/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e7598c2e1265a0f1292ed6f93bfb29abb93504/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=58e7598c2e1265a0f1292ed6f93bfb29abb93504", "patch": "@@ -117,6 +117,23 @@ impl StrInterner {\n         new_idx\n     }\n \n+    // I want these gensyms to share name pointers\n+    // with existing entries. This would be automatic,\n+    // except that the existing gensym creates its\n+    // own managed ptr using to_managed. I think that\n+    // adding this utility function is the most\n+    // lightweight way to get what I want, though not\n+    // necessarily the cleanest.\n+\n+    // create a gensym with the same name as an existing\n+    // entry.\n+    pub fn gensym_copy(&self, idx : uint) -> uint {\n+        let new_idx = self.len();\n+        // leave out of map to avoid colliding\n+        self.vect.push(self.vect[idx]);\n+        new_idx\n+    }\n+\n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n@@ -144,23 +161,23 @@ mod tests {\n     }\n \n     #[test]\n-    fn i2 () {\n+    fn interner_tests () {\n         let i : Interner<@str> = Interner::new();\n         // first one is zero:\n-        assert_eq!(i.intern (@\"dog\"), 0);\n+        assert_eq!(i.intern(@\"dog\"), 0);\n         // re-use gets the same entry:\n-        assert_eq!(i.intern (@\"dog\"), 0);\n+        assert_eq!(i.intern(@\"dog\"), 0);\n         // different string gets a different #:\n-        assert_eq!(i.intern (@\"cat\"), 1);\n-        assert_eq!(i.intern (@\"cat\"), 1);\n+        assert_eq!(i.intern(@\"cat\"), 1);\n+        assert_eq!(i.intern(@\"cat\"), 1);\n         // dog is still at zero\n-        assert_eq!(i.intern (@\"dog\"), 0);\n+        assert_eq!(i.intern(@\"dog\"), 0);\n         // gensym gets 3\n-        assert_eq!(i.gensym (@\"zebra\" ), 2);\n+        assert_eq!(i.gensym(@\"zebra\" ), 2);\n         // gensym of same string gets new number :\n         assert_eq!(i.gensym (@\"zebra\" ), 3);\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym (@\"dog\"), 4);\n+        assert_eq!(i.gensym(@\"dog\"), 4);\n         assert_eq!(i.get(0), @\"dog\");\n         assert_eq!(i.get(1), @\"cat\");\n         assert_eq!(i.get(2), @\"zebra\");\n@@ -176,4 +193,34 @@ mod tests {\n         assert_eq!(i.get(2), @\"Carol\");\n         assert_eq!(i.intern(@\"Bob\"), 1);\n     }\n+\n+    #[test]\n+    fn string_interner_tests() {\n+        let i : StrInterner = StrInterner::new();\n+        // first one is zero:\n+        assert_eq!(i.intern(\"dog\"), 0);\n+        // re-use gets the same entry:\n+        assert_eq!(i.intern (\"dog\"), 0);\n+        // different string gets a different #:\n+        assert_eq!(i.intern(\"cat\"), 1);\n+        assert_eq!(i.intern(\"cat\"), 1);\n+        // dog is still at zero\n+        assert_eq!(i.intern(\"dog\"), 0);\n+        // gensym gets 3\n+        assert_eq!(i.gensym(\"zebra\"), 2);\n+        // gensym of same string gets new number :\n+        assert_eq!(i.gensym(\"zebra\"), 3);\n+        // gensym of *existing* string gets new number:\n+        assert_eq!(i.gensym(\"dog\"), 4);\n+        // gensym tests again with gensym_copy:\n+        assert_eq!(i.gensym_copy(2), 5);\n+        assert_eq!(i.get(5), @\"zebra\");\n+        assert_eq!(i.gensym_copy(2), 6);\n+        assert_eq!(i.get(6), @\"zebra\");\n+        assert_eq!(i.get(0), @\"dog\");\n+        assert_eq!(i.get(1), @\"cat\");\n+        assert_eq!(i.get(2), @\"zebra\");\n+        assert_eq!(i.get(3), @\"zebra\");\n+        assert_eq!(i.get(4), @\"dog\");\n+    }\n }"}]}