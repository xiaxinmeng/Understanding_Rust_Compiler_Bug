{"sha": "f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzOWUwMTUxNjNmNGExZGRmYTYxNWNiYjBmOWEyNzk5OWJlMmMyMGI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-05T01:47:31Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-05T21:23:35Z"}, "message": "check for overflow when doing pointer arithmetic", "tree": {"sha": "d87909079c3bcbca15f12ef5d6eeec7729a77d44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d87909079c3bcbca15f12ef5d6eeec7729a77d44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "html_url": "https://github.com/rust-lang/rust/commit/f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70227c87bfecc96beebb62be1fff19ed4aa8e167", "url": "https://api.github.com/repos/rust-lang/rust/commits/70227c87bfecc96beebb62be1fff19ed4aa8e167", "html_url": "https://github.com/rust-lang/rust/commit/70227c87bfecc96beebb62be1fff19ed4aa8e167"}], "stats": {"total": 109, "additions": 76, "deletions": 33}, "files": [{"sha": "42df2398b46bb94b82e0b3a35b98902940050903", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "patch": "@@ -23,6 +23,7 @@ pub enum EvalError<'tcx> {\n     },\n     ReadPointerAsBytes,\n     InvalidPointerMath,\n+    OverflowingPointerMath,\n     ReadUndefBytes,\n     DeadLocal,\n     InvalidBoolOp(mir::BinOp),\n@@ -82,6 +83,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n             EvalError::InvalidPointerMath =>\n                 \"attempted to do math or a comparison on pointers into different allocations\",\n+            EvalError::OverflowingPointerMath =>\n+                \"attempted to do overflowing math on a pointer\",\n             EvalError::ReadUndefBytes =>\n                 \"attempted to read undefined bytes\",\n             EvalError::DeadLocal =>"}, {"sha": "4b61762176608d02ab306aa07774c41552f5f639", "filename": "src/eval_context.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "patch": "@@ -391,7 +391,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME(solson)\n         let dest_ptr = self.force_allocation(dest)?.to_ptr();\n \n-        let discr_dest = dest_ptr.offset(discr_offset);\n+        let discr_dest = dest_ptr.offset(discr_offset)?;\n         self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n \n         let dest = Lvalue::Ptr {\n@@ -550,7 +550,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 // FIXME(solson)\n                                 let dest = self.force_allocation(dest)?.to_ptr();\n \n-                                let dest = dest.offset(offset.bytes());\n+                                let dest = dest.offset(offset.bytes())?;\n                                 let dest_size = self.type_size(ty)?\n                                     .expect(\"bad StructWrappedNullablePointer discrfield\");\n                                 self.memory.write_int(dest, 0, dest_size)?;\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let dest = self.force_allocation(dest)?.to_ptr();\n \n                 for i in 0..length {\n-                    let elem_dest = dest.offset(i * elem_size);\n+                    let elem_dest = dest.offset(i * elem_size)?;\n                     self.write_value_to_ptr(value, elem_dest, elem_ty)?;\n                 }\n             }\n@@ -841,11 +841,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n+    pub(super) fn wrapping_pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n+        // FIXME: assuming here that type size is < i64::max_value()\n+        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        let offset = offset.overflowing_mul(pointee_size).0;\n+        Ok(ptr.wrapping_signed_offset(offset))\n+    }\n+\n     pub(super) fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n-        // FIXME: Check overflow, out-of-bounds\n-        Ok(ptr.signed_offset(offset * pointee_size))\n+        // FIXME: Check out-of-bounds\n+        return if let Some(offset) = offset.checked_mul(pointee_size) {\n+            ptr.signed_offset(offset)\n+        } else {\n+            Err(EvalError::OverflowingPointerMath)\n+        }\n     }\n \n     pub(super) fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n@@ -1099,8 +1110,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n         let field_0_size = self.type_size(field_0_ty)?.expect(\"pair element type must be sized\");\n         let field_1_size = self.type_size(field_1_ty)?.expect(\"pair element type must be sized\");\n-        self.memory.write_primval(ptr.offset(field_0), a, field_0_size)?;\n-        self.memory.write_primval(ptr.offset(field_1), b, field_1_size)?;\n+        self.memory.write_primval(ptr.offset(field_0)?, a, field_0_size)?;\n+        self.memory.write_primval(ptr.offset(field_1)?, b, field_1_size)?;\n         Ok(())\n     }\n \n@@ -1217,7 +1228,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Ok(Value::ByVal(PrimVal::Ptr(p)))\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n-            let extra = ptr.offset(self.memory.pointer_size());\n+            let extra = ptr.offset(self.memory.pointer_size())?;\n             let extra = match self.tcx.struct_tail(pointee_ty).sty {\n                 ty::TyDynamic(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n                 ty::TySlice(..) |\n@@ -1402,8 +1413,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                     let src_field_offset = self.get_field_offset(src_ty, i)?.bytes();\n                     let dst_field_offset = self.get_field_offset(dest_ty, i)?.bytes();\n-                    let src_f_ptr = src_ptr.offset(src_field_offset);\n-                    let dst_f_ptr = dest.offset(dst_field_offset);\n+                    let src_f_ptr = src_ptr.offset(src_field_offset)?;\n+                    let dst_f_ptr = dest.offset(dst_field_offset)?;\n                     if src_fty == dst_fty {\n                         self.copy(src_f_ptr, dst_f_ptr, src_fty)?;\n                     } else {"}, {"sha": "e4deddbfb48b4882cbded0b16ca25e7f41f106e8", "filename": "src/lvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "patch": "@@ -270,7 +270,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             _ => offset.bytes(),\n         };\n \n-        let ptr = base_ptr.offset(offset);\n+        let ptr = base_ptr.offset(offset)?;\n \n         let field_ty = self.monomorphize(field_ty, self.substs());\n \n@@ -363,7 +363,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let usize = self.tcx.types.usize;\n                 let n = self.value_to_primval(n_ptr, usize)?.to_u64()?;\n                 assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n-                let ptr = base_ptr.offset(n * elem_size);\n+                let ptr = base_ptr.offset(n * elem_size)?;\n                 (ptr, LvalueExtra::None)\n             }\n \n@@ -384,7 +384,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     u64::from(offset)\n                 };\n \n-                let ptr = base_ptr.offset(index * elem_size);\n+                let ptr = base_ptr.offset(index * elem_size)?;\n                 (ptr, LvalueExtra::None)\n             }\n \n@@ -398,7 +398,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 assert!(u64::from(from) <= n - u64::from(to));\n-                let ptr = base_ptr.offset(u64::from(from) * elem_size);\n+                let ptr = base_ptr.offset(u64::from(from) * elem_size)?;\n                 let extra = LvalueExtra::Length(n - u64::from(to) - u64::from(from));\n                 (ptr, extra)\n             }"}, {"sha": "46d5968abac22a344f1fda7744110d45e0a10582", "filename": "src/memory.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "patch": "@@ -60,20 +60,32 @@ impl Pointer {\n         Pointer { alloc_id, offset }\n     }\n \n-    pub fn signed_offset(self, i: i64) -> Self {\n+    pub fn wrapping_signed_offset<'tcx>(self, i: i64) -> Self {\n+        Pointer::new(self.alloc_id, self.offset.wrapping_add(i as u64))\n+    }\n+\n+    pub fn signed_offset<'tcx>(self, i: i64) -> EvalResult<'tcx, Self> {\n         // FIXME: is it possible to over/underflow here?\n         if i < 0 {\n             // trickery to ensure that i64::min_value() works fine\n             // this formula only works for true negative values, it panics for zero!\n             let n = u64::max_value() - (i as u64) + 1;\n-            Pointer::new(self.alloc_id, self.offset - n)\n+            if let Some(res) = self.offset.checked_sub(n) {\n+                Ok(Pointer::new(self.alloc_id, res))\n+            } else {\n+                Err(EvalError::OverflowingPointerMath)\n+            }\n         } else {\n             self.offset(i as u64)\n         }\n     }\n \n-    pub fn offset(self, i: u64) -> Self {\n-        Pointer::new(self.alloc_id, self.offset + i)\n+    pub fn offset<'tcx>(self, i: u64) -> EvalResult<'tcx, Self> {\n+        if let Some(res) = self.offset.checked_add(i) {\n+            Ok(Pointer::new(self.alloc_id, res))\n+        } else {\n+            Err(EvalError::OverflowingPointerMath)\n+        }\n     }\n \n     pub fn points_to_zst(&self) -> bool {\n@@ -271,7 +283,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n             self.memory_usage -= size - new_size;\n-            self.clear_relocations(ptr.offset(new_size), size - new_size)?;\n+            self.clear_relocations(ptr.offset(new_size)?, size - new_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n             // `as usize` is fine here, since it is smaller than `size`, which came from a usize\n             alloc.bytes.truncate(new_size as usize);\n@@ -919,7 +931,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     fn check_relocation_edges(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n         let overlapping_start = self.relocations(ptr, 0)?.count();\n-        let overlapping_end = self.relocations(ptr.offset(size), 0)?.count();\n+        let overlapping_end = self.relocations(ptr.offset(size)?, 0)?.count();\n         if overlapping_start + overlapping_end != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }"}, {"sha": "31886e9cc6d915ee8bc8dcd2d088f54dbc4e7dba", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // FIXME: Switch to non-checked, wrapped version of pointer_offset\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n-                let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n+                let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_primval(dest, PrimVal::Ptr(result_ptr), dest_ty)?;\n             }\n "}, {"sha": "ebf8723e827e17891c638662adfbd023bafb7f92", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 match arg_val {\n                                     Value::ByRef(ptr) => {\n                                         for ((offset, ty), arg_local) in offsets.zip(fields).zip(arg_locals) {\n-                                            let arg = Value::ByRef(ptr.offset(offset));\n+                                            let arg = Value::ByRef(ptr.offset(offset)?);\n                                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                                             trace!(\"writing arg {:?} to {:?} (type: {})\", arg, dest, ty);\n                                             self.write_value(arg, dest, ty)?;\n@@ -387,7 +387,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let (_, vtable) = self.eval_operand(&arg_operands[0])?.expect_ptr_vtable_pair(&self.memory)?;\n-                let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3)))?;\n+                let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3))?)?;\n                 let instance = self.memory.get_fn(fn_ptr.alloc_id)?;\n                 let mut arg_operands = arg_operands.to_vec();\n                 let ty = self.operand_ty(&arg_operands[0]);\n@@ -473,7 +473,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                 let (offset, ty) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n-                let nonnull = adt_ptr.offset(offset.bytes());\n+                let nonnull = adt_ptr.offset(offset.bytes())?;\n                 trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n                 let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n@@ -654,7 +654,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(num - idx as u64 - 1);\n+                    let new_ptr = ptr.offset(num - idx as u64 - 1)?;\n                     self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n@@ -666,7 +666,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(idx as u64);\n+                    let new_ptr = ptr.offset(idx as u64)?;\n                     self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;"}, {"sha": "bf9e47da991a114200045091149c580fd406e9ef", "filename": "src/traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "patch": "@@ -56,14 +56,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let drop = self.memory.create_fn_alloc(drop);\n         self.memory.write_ptr(vtable, drop)?;\n \n-        self.memory.write_usize(vtable.offset(ptr_size), size)?;\n-        self.memory.write_usize(vtable.offset(ptr_size * 2), align)?;\n+        self.memory.write_usize(vtable.offset(ptr_size)?, size)?;\n+        self.memory.write_usize(vtable.offset(ptr_size * 2)?, align)?;\n \n         for (i, method) in ::rustc::traits::get_vtable_methods(self.tcx, trait_ref).enumerate() {\n             if let Some((def_id, substs)) = method {\n                 let instance = ::eval_context::resolve(self.tcx, def_id, substs);\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n-                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64)), fn_ptr)?;\n+                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64))?, fn_ptr)?;\n             }\n         }\n \n@@ -88,8 +88,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub fn read_size_and_align_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n-        let size = self.memory.read_usize(vtable.offset(pointer_size))?;\n-        let align = self.memory.read_usize(vtable.offset(pointer_size * 2))?;\n+        let size = self.memory.read_usize(vtable.offset(pointer_size)?)?;\n+        let align = self.memory.read_usize(vtable.offset(pointer_size * 2)?)?;\n         Ok((size, align))\n     }\n "}, {"sha": "efe5aac71f5bce015f5f591ab82ef7f2532a6bc7", "filename": "src/value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'tcx: 'a> Value {\n         match *self {\n             ByRef(ref_ptr) => {\n                 let ptr = mem.read_ptr(ref_ptr)?;\n-                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size()))?;\n+                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size())?)?;\n                 Ok((ptr, vtable))\n             }\n \n@@ -105,7 +105,7 @@ impl<'a, 'tcx: 'a> Value {\n         match *self {\n             ByRef(ref_ptr) => {\n                 let ptr = mem.read_ptr(ref_ptr)?;\n-                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size()))?;\n+                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size())?)?;\n                 Ok((ptr, len))\n             },\n             ByValPair(ptr, val) => {"}, {"sha": "fa93d0daf76c5dcb6b9e4981aa18658cbf4295e7", "filename": "tests/compile-fail/ptr_offset_overflow.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/tests%2Fcompile-fail%2Fptr_offset_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/tests%2Fcompile-fail%2Fptr_offset_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_offset_overflow.rs?ref=f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "patch": "@@ -0,0 +1,8 @@\n+//error-pattern: overflowing math on a pointer\n+fn main() {\n+    let v = [1i8, 2];\n+    let x = &v[1] as *const i8;\n+    // One of them is guaranteed to overflow\n+    let _ = unsafe { x.offset(isize::max_value()) };\n+    let _ = unsafe { x.offset(isize::min_value()) };\n+}"}, {"sha": "3383c3b80148209239c12898ad861fd58236b4c3", "filename": "tests/run-pass/ptr_arith_offset_overflow.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39e015163f4a1ddfa615cbb0f9a27999be2c20b/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs?ref=f39e015163f4a1ddfa615cbb0f9a27999be2c20b", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let v = [1i16, 2];\n+    let x = &v[1] as *const i16;\n+    // Adding 2*isize::max and then 1 is like substracting 1\n+    let x = x.wrapping_offset(isize::max_value());\n+    let x = x.wrapping_offset(isize::max_value());\n+    let x = x.wrapping_offset(1);\n+    assert_eq!(unsafe { *x }, 1);\n+}"}]}