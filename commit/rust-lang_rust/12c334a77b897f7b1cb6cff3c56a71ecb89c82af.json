{"sha": "12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYzMzNGE3N2I4OTdmN2IxY2I2Y2ZmM2M1NmE3MWVjYjg5YzgyYWY=", "commit": {"author": {"name": "Richo Healey", "email": "richo@psych0tik.net", "date": "2014-06-21T10:39:03Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-08T20:01:43Z"}, "message": "std: Rename the `ToStr` trait to `ToString`, and `to_str` to `to_string`.\n\n[breaking-change]", "tree": {"sha": "1f5a85061a69058875391ec6171cf8b446996dff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f5a85061a69058875391ec6171cf8b446996dff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "html_url": "https://github.com/rust-lang/rust/commit/12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/comments", "author": {"login": "richo", "id": 476418, "node_id": "MDQ6VXNlcjQ3NjQxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/476418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richo", "html_url": "https://github.com/richo", "followers_url": "https://api.github.com/users/richo/followers", "following_url": "https://api.github.com/users/richo/following{/other_user}", "gists_url": "https://api.github.com/users/richo/gists{/gist_id}", "starred_url": "https://api.github.com/users/richo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richo/subscriptions", "organizations_url": "https://api.github.com/users/richo/orgs", "repos_url": "https://api.github.com/users/richo/repos", "events_url": "https://api.github.com/users/richo/events{/privacy}", "received_events_url": "https://api.github.com/users/richo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfe4ddfdea45533c98657701509bb7185fd96cba", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfe4ddfdea45533c98657701509bb7185fd96cba", "html_url": "https://github.com/rust-lang/rust/commit/bfe4ddfdea45533c98657701509bb7185fd96cba"}], "stats": {"total": 2947, "additions": 1557, "deletions": 1390}, "files": [{"sha": "4de66d8746fbea72f45206832e1ef93c56a2ba9e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -187,7 +187,7 @@ pub fn log_config(config: &Config) {\n                     opt_str(&config.filter\n                                    .as_ref()\n                                    .map(|re| {\n-                                       re.to_str().into_string()\n+                                       re.to_string().into_string()\n                                    }))));\n     logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n     logv(c, format!(\"host-rustcflags: {}\","}, {"sha": "7681792bdf53d1e1af5f92fe111e710f398410d6", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -31,7 +31,7 @@ pub fn load_errors(re: &Regex, testfile: &Path) -> Vec<ExpectedError> {\n fn parse_expected(line_num: uint, line: &str, re: &Regex) -> Option<ExpectedError> {\n     re.captures(line).and_then(|caps| {\n         let adjusts = caps.name(\"adjusts\").len();\n-        let kind = caps.name(\"kind\").to_ascii().to_lower().into_str();\n+        let kind = caps.name(\"kind\").to_ascii().to_lower().into_string();\n         let msg = caps.name(\"msg\").trim().to_string();\n \n         debug!(\"line={} kind={} msg={}\", line_num, kind, msg);"}, {"sha": "369e6b0af645c82505bf6e08e7ed0df5b6f852b6", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -41,7 +41,7 @@ pub fn make_new_path(path: &str) -> String {\n       Some(curr) => {\n         format!(\"{}{}{}\", path, path_div(), curr)\n       }\n-      None => path.to_str()\n+      None => path.to_string()\n     }\n }\n "}, {"sha": "6ef273e7a1a59099021bfdb11f3de3816f1ac9c3", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -465,7 +465,7 @@ fn stringifier(channel: &DuplexStream<String, uint>) {\n     let mut value: uint;\n     loop {\n         value = channel.recv();\n-        channel.send(value.to_str());\n+        channel.send(value.to_string());\n         if value == 0 { break; }\n     }\n }\n@@ -478,7 +478,7 @@ send strings (the first type parameter) and receive `uint` messages\n (the second type parameter). The body itself simply loops, reading\n from the channel and then sending its response back.  The actual\n response itself is simply the stringified version of the received value,\n-`uint::to_str(value)`.\n+`uint::to_string(value)`.\n \n Here is the code for the parent task:\n \n@@ -492,7 +492,7 @@ use std::comm::duplex;\n #     let mut value: uint;\n #     loop {\n #         value = channel.recv();\n-#         channel.send(value.to_str());\n+#         channel.send(value.to_string());\n #         if value == 0u { break; }\n #     }\n # }"}, {"sha": "b429f3020a73c1414ca293193b2ee27735823f1c", "filename": "src/doc/po/ja/complement-cheatsheet.md.po", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fdoc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fdoc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -23,7 +23,7 @@ msgstr \"\"\n #| \"[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz [win-exe]: \"\n #| \"http://static.rust-lang.org/dist/rust-nightly-install.exe\"\n msgid \"\"\n-\"Use [`ToStr`](http://static.rust-lang.org/doc/master/std/to_str/trait.ToStr.\"\n+\"Use [`ToString`](http://static.rust-lang.org/doc/master/std/to_str/trait.ToString.\"\n \"html).\"\n msgstr \"\"\n \"[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz\\n\"\n@@ -34,7 +34,7 @@ msgstr \"\"\n #, fuzzy\n #| msgid \"\"\n #| \"~~~~ let x: f64 = 4.0; let y: uint = x as uint; assert!(y == 4u); ~~~~\"\n-msgid \"~~~ let x: int = 42; let y: String = x.to_str(); ~~~\"\n+msgid \"~~~ let x: int = 42; let y: String = x.to_string(); ~~~\"\n msgstr \"\"\n \"~~~~\\n\"\n \"let x: f64 = 4.0;\\n\""}, {"sha": "a28a62d01c2674d561ac69661fb19b6240dd0dc0", "filename": "src/doc/po/ja/rust.md.po", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fdoc%2Fpo%2Fja%2Frust.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fdoc%2Fpo%2Fja%2Frust.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Frust.md.po?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -1656,7 +1656,7 @@ msgstr \"\"\n #| msgid \"~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"impl Printable for int {\\n\"\n-\"  fn to_string(&self) -> String { self.to_str() }\\n\"\n+\"  fn to_string(&self) -> String { self.to_string() }\\n\"\n \"}\\n\"\n msgstr \"\"\n \"~~~~ {.ignore}\\n\""}, {"sha": "597cf5b7ac509cfde4b42385ee3d07557b68d0ab", "filename": "src/doc/po/ja/tutorial.md.po", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -4410,9 +4410,9 @@ msgstr \"\"\n \n #. type: Plain text\n #: src/doc/tutorial.md:2528\n-msgid \"#[deriving(Rand, ToStr)] enum ABC { A, B, C } ~~~\"\n+msgid \"#[deriving(Rand, ToString)] enum ABC { A, B, C } ~~~\"\n msgstr \"\"\n-\"#[deriving(Rand, ToStr)]\\n\"\n+\"#[deriving(Rand, ToString)]\\n\"\n \"enum ABC { A, B, C }\\n\"\n \"~~~\"\n \n@@ -4422,15 +4422,15 @@ msgstr \"\"\n #| msgid \"\"\n #| \"The full list of derivable traits is `Eq`, `TotalEq`, `Ord`, `TotalOrd`, \"\n #| \"`Encodable` `Decodable`, `Clone`, `DeepClone`, `Hash`, `Rand`, \"\n-#| \"`Zero`, and `ToStr`.\"\n+#| \"`Zero`, and `ToString`.\"\n msgid \"\"\n \"The full list of derivable traits is `Eq`, `TotalEq`, `Ord`, `TotalOrd`, \"\n \"`Encodable` `Decodable`, `Clone`, `DeepClone`, `Hash`, `Rand`, \"\n-\"`Default`, `Zero`, and `ToStr`.\"\n+\"`Default`, `Zero`, and `ToString`.\"\n msgstr \"\"\n \"\u5b9f\u88c5\u3092\u81ea\u52d5\u7684\u306b\u5c0e\u51fa\u53ef\u80fd\u306a\u30c8\u30ec\u30a4\u30c8\u306f\u3001 `Eq`, `TotalEq`, `Ord`, `TotalOrd`, \"\n \"`Encodable` `Decodable`, `Clone`, `DeepClone`, `Hash`, `Rand`, `Zero`, \"\n-\"\u304a\u3088\u3073 `ToStr` \u3067\u3059\u3002.\"\n+\"\u304a\u3088\u3073 `ToString` \u3067\u3059\u3002.\"\n \n #. type: Plain text\n #: src/doc/tutorial.md:2534"}, {"sha": "9d5a6fa42a830239fb21695527511b85fc6abe1f", "filename": "src/doc/rust.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -3671,15 +3671,15 @@ An example of an object type:\n \n ~~~~\n trait Printable {\n-  fn to_string(&self) -> String;\n+  fn stringify(&self) -> String;\n }\n \n impl Printable for int {\n-  fn to_string(&self) -> String { self.to_str() }\n+  fn stringify(&self) -> String { self.to_string() }\n }\n \n fn print(a: Box<Printable>) {\n-   println!(\"{}\", a.to_string());\n+   println!(\"{}\", a.stringify());\n }\n \n fn main() {"}, {"sha": "86df9cba4cdf5317b8a148f97dbde8b912a2607e", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -100,7 +100,7 @@ syn keyword rustTrait RawPtr\n syn keyword rustTrait Buffer Writer Reader Seek\n syn keyword rustTrait Str StrVector StrSlice OwnedStr\n syn keyword rustTrait IntoMaybeOwned StrAllocating\n-syn keyword rustTrait ToStr IntoStr\n+syn keyword rustTrait ToString IntoStr\n syn keyword rustTrait Tuple1 Tuple2 Tuple3 Tuple4\n syn keyword rustTrait Tuple5 Tuple6 Tuple7 Tuple8\n syn keyword rustTrait Tuple9 Tuple10 Tuple11 Tuple12"}, {"sha": "905c27ee82c9470cc1c2af5e70af59115727993f", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -60,17 +60,17 @@ enum BitvVariant { Big(BigBitv), Small(SmallBitv) }\n /// bv.set(3, true);\n /// bv.set(5, true);\n /// bv.set(7, true);\n-/// println!(\"{}\", bv.to_str());\n+/// println!(\"{}\", bv.to_string());\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n ///\n /// // flip all values in bitvector, producing non-primes less than 10\n /// bv.negate();\n-/// println!(\"{}\", bv.to_str());\n+/// println!(\"{}\", bv.to_string());\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n ///\n /// // reset bitvector to empty\n /// bv.clear();\n-/// println!(\"{}\", bv.to_str());\n+/// println!(\"{}\", bv.to_string());\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n pub struct Bitv {\n@@ -996,10 +996,10 @@ mod tests {\n     #[test]\n     fn test_to_str() {\n         let zerolen = Bitv::new();\n-        assert_eq!(zerolen.to_str().as_slice(), \"\");\n+        assert_eq!(zerolen.to_string().as_slice(), \"\");\n \n         let eightbits = Bitv::with_capacity(8u, false);\n-        assert_eq!(eightbits.to_str().as_slice(), \"00000000\")\n+        assert_eq!(eightbits.to_string().as_slice(), \"00000000\")\n     }\n \n     #[test]\n@@ -1022,7 +1022,7 @@ mod tests {\n         let mut b = bitv::Bitv::with_capacity(2, false);\n         b.set(0, true);\n         b.set(1, false);\n-        assert_eq!(b.to_str().as_slice(), \"10\");\n+        assert_eq!(b.to_string().as_slice(), \"10\");\n     }\n \n     #[test]\n@@ -1333,7 +1333,7 @@ mod tests {\n     fn test_from_bytes() {\n         let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n         let str = format!(\"{}{}{}\", \"10110110\", \"00000000\", \"11111111\");\n-        assert_eq!(bitv.to_str().as_slice(), str.as_slice());\n+        assert_eq!(bitv.to_string().as_slice(), str.as_slice());\n     }\n \n     #[test]\n@@ -1352,7 +1352,7 @@ mod tests {\n     fn test_from_bools() {\n         let bools = vec![true, false, true, true];\n         let bitv: Bitv = bools.iter().map(|n| *n).collect();\n-        assert_eq!(bitv.to_str().as_slice(), \"1011\");\n+        assert_eq!(bitv.to_string().as_slice(), \"1011\");\n     }\n \n     #[test]\n@@ -1787,7 +1787,7 @@ mod tests {\n         s.insert(10);\n         s.insert(50);\n         s.insert(2);\n-        assert_eq!(\"{1, 2, 10, 50}\".to_string(), s.to_str());\n+        assert_eq!(\"{1, 2, 10, 50}\".to_string(), s.to_string());\n     }\n \n     fn rng() -> rand::IsaacRng {"}, {"sha": "2d138b1a1895f3d45406c15d00dbc9bdf5c9c421", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -787,7 +787,6 @@ mod test_btree {\n     fn insert_test_one() {\n         let b = BTree::new(1i, \"abc\".to_string(), 2);\n         let is_insert = b.insert(2i, \"xyz\".to_string());\n-        //println!(\"{}\", is_insert.clone().to_str());\n         assert!(is_insert.root.is_leaf());\n     }\n \n@@ -798,7 +797,7 @@ mod test_btree {\n         let leaf_elt_3 = LeafElt::new(3i, \"ccc\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3));\n         let b = BTree::new_with_node_len(n, 3, 2);\n-        //println!(\"{}\", b.clone().insert(4, \"ddd\".to_string()).to_str());\n+        //println!(\"{}\", b.clone().insert(4, \"ddd\".to_string()).to_string());\n         assert!(b.insert(4, \"ddd\".to_string()).root.is_leaf());\n     }\n \n@@ -810,7 +809,7 @@ mod test_btree {\n         let leaf_elt_4 = LeafElt::new(4i, \"ddd\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n-        //println!(\"{}\", b.clone().insert(5, \"eee\".to_string()).to_str());\n+        //println!(\"{}\", b.clone().insert(5, \"eee\".to_string()).to_string());\n         assert!(!b.insert(5, \"eee\".to_string()).root.is_leaf());\n     }\n \n@@ -827,7 +826,7 @@ mod test_btree {\n         b = b.clone().insert(7, \"ggg\".to_string());\n         b = b.clone().insert(8, \"hhh\".to_string());\n         b = b.clone().insert(0, \"omg\".to_string());\n-        //println!(\"{}\", b.clone().to_str());\n+        //println!(\"{}\", b.clone().to_string());\n         assert!(!b.root.is_leaf());\n     }\n \n@@ -905,11 +904,11 @@ mod test_btree {\n         assert!(&b2.cmp(&b) == &Greater)\n     }\n \n-    //Tests the BTree's to_str() method.\n+    //Tests the BTree's to_string() method.\n     #[test]\n     fn btree_tostr_test() {\n         let b = BTree::new(1i, \"abc\".to_string(), 2);\n-        assert_eq!(b.to_str(), \"Key: 1, value: abc;\".to_string())\n+        assert_eq!(b.to_string(), \"Key: 1, value: abc;\".to_string())\n     }\n \n }"}, {"sha": "ed2d67388766700ebd3b99ddf4ec9d739d05ea88", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -1041,12 +1041,12 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let list: DList<int> = range(0i, 10).collect();\n-        assert!(list.to_str().as_slice() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        assert!(list.to_string().as_slice() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                    .map(|&s| s)\n                                                                    .collect();\n-        assert!(list.to_str().as_slice() == \"[just, one, test, more]\");\n+        assert!(list.to_string().as_slice() == \"[just, one, test, more]\");\n     }\n \n     #[cfg(test)]"}, {"sha": "ca62b1235d5549e01a6f3b6ed0fc522149a1ce71", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -491,7 +491,7 @@ mod test_map {\n         map.insert(1, 2i);\n         map.insert(3, 4i);\n \n-        let map_str = map.to_str();\n+        let map_str = map.to_string();\n         let map_str = map_str.as_slice();\n         assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n         assert_eq!(format!(\"{}\", empty), \"{}\".to_string());"}, {"sha": "63c95fa25cb0da74b5d57b1d25569fb3eb363a41", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 137, "deletions": 120, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -657,7 +657,7 @@ impl<'a> StrAllocating for MaybeOwned<'a> {\n     #[inline]\n     fn into_string(self) -> String {\n         match self {\n-            Slice(s) => s.to_string(),\n+            Slice(s) => String::from_str(s),\n             Owned(s) => s\n         }\n     }\n@@ -673,7 +673,7 @@ impl<'a> Clone for MaybeOwned<'a> {\n     fn clone(&self) -> MaybeOwned<'a> {\n         match *self {\n             Slice(s) => Slice(s),\n-            Owned(ref s) => Owned(s.to_string())\n+            Owned(ref s) => Owned(String::from_str(s.as_slice()))\n         }\n     }\n }\n@@ -762,7 +762,7 @@ pub mod raw {\n             let a = vec![65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = a.as_ptr();\n             let c = from_buf_len(b, 3u);\n-            assert_eq!(c, \"AAA\".to_string());\n+            assert_eq!(c, String::from_str(\"AAA\"));\n         }\n     }\n }\n@@ -776,12 +776,6 @@ pub trait StrAllocating: Str {\n     /// Convert `self` into a `String`, not making a copy if possible.\n     fn into_string(self) -> String;\n \n-    /// Convert `self` into a `String`.\n-    #[inline]\n-    fn to_string(&self) -> String {\n-        String::from_str(self.as_slice())\n-    }\n-\n     #[allow(missing_doc)]\n     #[deprecated = \"replaced by .into_string()\"]\n     fn into_owned(self) -> String {\n@@ -933,7 +927,7 @@ pub trait StrAllocating: Str {\n impl<'a> StrAllocating for &'a str {\n     #[inline]\n     fn into_string(self) -> String {\n-        self.to_string()\n+        String::from_str(self)\n     }\n }\n \n@@ -963,11 +957,19 @@ impl OwnedStr for String {\n \n #[cfg(test)]\n mod tests {\n-    use std::prelude::*;\n     use std::iter::AdditiveIterator;\n     use std::default::Default;\n+    use std::char::Char;\n+    use std::clone::Clone;\n+    use std::cmp::{Equal, Greater, Less, Ord, Eq, PartialOrd, PartialEq, Equiv};\n+    use std::result::{Ok, Err};\n+    use std::option::{Some, None};\n+    use std::ptr::RawPtr;\n+    use std::iter::{Iterator, DoubleEndedIterator};\n+    use Collection;\n \n-    use str::*;\n+    use super::*;\n+    use std::slice::{Vector, ImmutableVector};\n     use string::String;\n     use vec::Vec;\n \n@@ -1028,17 +1030,17 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let empty = \"\".to_string();\n+        let empty = String::from_str(\"\");\n         let s: String = empty.as_slice().chars().collect();\n         assert_eq!(empty, s);\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\".to_string();\n+        let data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n         let s: String = data.as_slice().chars().collect();\n         assert_eq!(data, s);\n     }\n \n     #[test]\n     fn test_into_bytes() {\n-        let data = \"asdf\".to_string();\n+        let data = String::from_str(\"asdf\");\n         let buf = data.into_bytes();\n         assert_eq!(b\"asdf\", buf.as_slice());\n     }\n@@ -1055,7 +1057,7 @@ mod tests {\n         assert!(data.slice(2u, 4u).find_str(\"ab\").is_none());\n \n         let string = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let mut data = string.to_string();\n+        let mut data = String::from_str(string);\n         data.push_str(string);\n         assert!(data.as_slice().find_str(\"\u0e44\u0e17\u534e\").is_none());\n         assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\"), Some(0u));\n@@ -1092,24 +1094,27 @@ mod tests {\n         fn t(v: &[String], s: &str) {\n             assert_eq!(v.concat().as_slice(), s);\n         }\n-        t([\"you\".to_string(), \"know\".to_string(), \"I'm\".to_string(),\n-          \"no\".to_string(), \"good\".to_string()], \"youknowI'mnogood\");\n+        t([String::from_str(\"you\"), String::from_str(\"know\"),\n+           String::from_str(\"I'm\"),\n+           String::from_str(\"no\"), String::from_str(\"good\")],\n+          \"youknowI'mnogood\");\n         let v: &[String] = [];\n         t(v, \"\");\n-        t([\"hi\".to_string()], \"hi\");\n+        t([String::from_str(\"hi\")], \"hi\");\n     }\n \n     #[test]\n     fn test_connect() {\n         fn t(v: &[String], sep: &str, s: &str) {\n             assert_eq!(v.connect(sep).as_slice(), s);\n         }\n-        t([\"you\".to_string(), \"know\".to_string(), \"I'm\".to_string(),\n-           \"no\".to_string(), \"good\".to_string()],\n+        t([String::from_str(\"you\"), String::from_str(\"know\"),\n+           String::from_str(\"I'm\"),\n+           String::from_str(\"no\"), String::from_str(\"good\")],\n           \" \", \"you know I'm no good\");\n         let v: &[String] = [];\n         t(v, \" \", \"\");\n-        t([\"hi\".to_string()], \" \", \"hi\");\n+        t([String::from_str(\"hi\")], \" \", \"hi\");\n     }\n \n     #[test]\n@@ -1136,11 +1141,11 @@ mod tests {\n \n     #[test]\n     fn test_repeat() {\n-        assert_eq!(\"x\".repeat(4), \"xxxx\".to_string());\n-        assert_eq!(\"hi\".repeat(4), \"hihihihi\".to_string());\n-        assert_eq!(\"\u0e44\u0e17\u534e\".repeat(3), \"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\".to_string());\n-        assert_eq!(\"\".repeat(4), \"\".to_string());\n-        assert_eq!(\"hi\".repeat(0), \"\".to_string());\n+        assert_eq!(\"x\".repeat(4), String::from_str(\"xxxx\"));\n+        assert_eq!(\"hi\".repeat(4), String::from_str(\"hihihihi\"));\n+        assert_eq!(\"\u0e44\u0e17\u534e\".repeat(3), String::from_str(\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\"));\n+        assert_eq!(\"\".repeat(4), String::from_str(\"\"));\n+        assert_eq!(\"hi\".repeat(0), String::from_str(\"\"));\n     }\n \n     #[test]\n@@ -1168,9 +1173,9 @@ mod tests {\n         }\n         let letters = a_million_letter_a();\n         assert!(half_a_million_letter_a() ==\n-            unsafe {raw::slice_bytes(letters.as_slice(),\n+            unsafe {String::from_str(raw::slice_bytes(letters.as_slice(),\n                                      0u,\n-                                     500000)}.to_string());\n+                                     500000))});\n     }\n \n     #[test]\n@@ -1204,13 +1209,13 @@ mod tests {\n     #[test]\n     fn test_replace() {\n         let a = \"a\";\n-        assert_eq!(\"\".replace(a, \"b\"), \"\".to_string());\n-        assert_eq!(\"a\".replace(a, \"b\"), \"b\".to_string());\n-        assert_eq!(\"ab\".replace(a, \"b\"), \"bb\".to_string());\n+        assert_eq!(\"\".replace(a, \"b\"), String::from_str(\"\"));\n+        assert_eq!(\"a\".replace(a, \"b\"), String::from_str(\"b\"));\n+        assert_eq!(\"ab\".replace(a, \"b\"), String::from_str(\"bb\"));\n         let test = \"test\";\n         assert!(\" test test \".replace(test, \"toast\") ==\n-            \" toast toast \".to_string());\n-        assert_eq!(\" test test \".replace(test, \"\"), \"   \".to_string());\n+            String::from_str(\" toast toast \"));\n+        assert_eq!(\" test test \".replace(test, \"\"), String::from_str(\"   \"));\n     }\n \n     #[test]\n@@ -1285,7 +1290,7 @@ mod tests {\n         }\n         let letters = a_million_letter_x();\n         assert!(half_a_million_letter_x() ==\n-            letters.as_slice().slice(0u, 3u * 500000u).to_string());\n+            String::from_str(letters.as_slice().slice(0u, 3u * 500000u)));\n     }\n \n     #[test]\n@@ -1513,7 +1518,7 @@ mod tests {\n             let a = vec![65, 65, 65, 65, 65, 65, 65, 0];\n             let b = a.as_ptr();\n             let c = raw::from_c_str(b);\n-            assert_eq!(c, \"AAAAAAA\".to_string());\n+            assert_eq!(c, String::from_str(\"AAAAAAA\"));\n         }\n     }\n \n@@ -1535,7 +1540,7 @@ mod tests {\n     fn test_as_bytes_fail() {\n         // Don't double free. (I'm not sure if this exercises the\n         // original problem code path anymore.)\n-        let s = \"\".to_string();\n+        let s = String::from_str(\"\");\n         let _bytes = s.as_bytes();\n         fail!();\n     }\n@@ -1578,10 +1583,10 @@ mod tests {\n \n     #[test]\n     fn vec_str_conversions() {\n-        let s1: String = \"All mimsy were the borogoves\".to_string();\n+        let s1: String = String::from_str(\"All mimsy were the borogoves\");\n \n         let v: Vec<u8> = Vec::from_slice(s1.as_bytes());\n-        let s2: String = from_utf8(v.as_slice()).unwrap().to_string();\n+        let s2: String = String::from_str(from_utf8(v.as_slice()).unwrap());\n         let mut i: uint = 0u;\n         let n1: uint = s1.len();\n         let n2: uint = v.len();\n@@ -1624,21 +1629,21 @@ mod tests {\n     #[test]\n     fn test_utf16() {\n         let pairs =\n-            [(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\".to_string(),\n+            [(String::from_str(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\"),\n               vec![0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n                 0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n                 0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n                 0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n \n-             (\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\".to_string(),\n+             (String::from_str(\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\"),\n               vec![0xd801_u16, 0xdc12_u16, 0xd801_u16,\n                 0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n                 0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n                 0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n                 0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n                 0x000a_u16]),\n \n-             (\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\".to_string(),\n+             (String::from_str(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\"),\n               vec![0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n                 0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n                 0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n@@ -1647,7 +1652,7 @@ mod tests {\n                 0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n                 0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n \n-             (\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\".to_string(),\n+             (String::from_str(\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\"),\n               vec![0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n                 0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n                 0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n@@ -1660,7 +1665,7 @@ mod tests {\n                 0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n                 0x000a_u16 ]),\n              // Issue #12318, even-numbered non-BMP planes\n-             (\"\\U00020000\".to_string(),\n+             (String::from_str(\"\\U00020000\"),\n               vec![0xD840, 0xDC00])];\n \n         for p in pairs.iter() {\n@@ -1698,16 +1703,16 @@ mod tests {\n     fn test_utf16_lossy() {\n         // completely positive cases tested above.\n         // lead + eof\n-        assert_eq!(from_utf16_lossy([0xD800]), \"\\uFFFD\".to_string());\n+        assert_eq!(from_utf16_lossy([0xD800]), String::from_str(\"\\uFFFD\"));\n         // lead + lead\n-        assert_eq!(from_utf16_lossy([0xD800, 0xD800]), \"\\uFFFD\\uFFFD\".to_string());\n+        assert_eq!(from_utf16_lossy([0xD800, 0xD800]), String::from_str(\"\\uFFFD\\uFFFD\"));\n \n         // isolated trail\n-        assert_eq!(from_utf16_lossy([0x0061, 0xDC00]), \"a\\uFFFD\".to_string());\n+        assert_eq!(from_utf16_lossy([0x0061, 0xDC00]), String::from_str(\"a\\uFFFD\"));\n \n         // general\n         assert_eq!(from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]),\n-                   \"\\uFFFD\ud801\udc8b\\uFFFD\".to_string());\n+                   String::from_str(\"\\uFFFD\ud801\udc8b\\uFFFD\"));\n     }\n \n     #[test]\n@@ -1752,27 +1757,29 @@ mod tests {\n \n     #[test]\n     fn test_escape_unicode() {\n-        assert_eq!(\"abc\".escape_unicode(), \"\\\\x61\\\\x62\\\\x63\".to_string());\n-        assert_eq!(\"a c\".escape_unicode(), \"\\\\x61\\\\x20\\\\x63\".to_string());\n-        assert_eq!(\"\\r\\n\\t\".escape_unicode(), \"\\\\x0d\\\\x0a\\\\x09\".to_string());\n-        assert_eq!(\"'\\\"\\\\\".escape_unicode(), \"\\\\x27\\\\x22\\\\x5c\".to_string());\n-        assert_eq!(\"\\x00\\x01\\xfe\\xff\".escape_unicode(), \"\\\\x00\\\\x01\\\\xfe\\\\xff\".to_string());\n-        assert_eq!(\"\\u0100\\uffff\".escape_unicode(), \"\\\\u0100\\\\uffff\".to_string());\n-        assert_eq!(\"\\U00010000\\U0010ffff\".escape_unicode(), \"\\\\U00010000\\\\U0010ffff\".to_string());\n-        assert_eq!(\"ab\\ufb00\".escape_unicode(), \"\\\\x61\\\\x62\\\\ufb00\".to_string());\n-        assert_eq!(\"\\U0001d4ea\\r\".escape_unicode(), \"\\\\U0001d4ea\\\\x0d\".to_string());\n+        assert_eq!(\"abc\".escape_unicode(), String::from_str(\"\\\\x61\\\\x62\\\\x63\"));\n+        assert_eq!(\"a c\".escape_unicode(), String::from_str(\"\\\\x61\\\\x20\\\\x63\"));\n+        assert_eq!(\"\\r\\n\\t\".escape_unicode(), String::from_str(\"\\\\x0d\\\\x0a\\\\x09\"));\n+        assert_eq!(\"'\\\"\\\\\".escape_unicode(), String::from_str(\"\\\\x27\\\\x22\\\\x5c\"));\n+        assert_eq!(\"\\x00\\x01\\xfe\\xff\".escape_unicode(), String::from_str(\"\\\\x00\\\\x01\\\\xfe\\\\xff\"));\n+        assert_eq!(\"\\u0100\\uffff\".escape_unicode(), String::from_str(\"\\\\u0100\\\\uffff\"));\n+        assert_eq!(\"\\U00010000\\U0010ffff\".escape_unicode(),\n+                   String::from_str(\"\\\\U00010000\\\\U0010ffff\"));\n+        assert_eq!(\"ab\\ufb00\".escape_unicode(), String::from_str(\"\\\\x61\\\\x62\\\\ufb00\"));\n+        assert_eq!(\"\\U0001d4ea\\r\".escape_unicode(), String::from_str(\"\\\\U0001d4ea\\\\x0d\"));\n     }\n \n     #[test]\n     fn test_escape_default() {\n-        assert_eq!(\"abc\".escape_default(), \"abc\".to_string());\n-        assert_eq!(\"a c\".escape_default(), \"a c\".to_string());\n-        assert_eq!(\"\\r\\n\\t\".escape_default(), \"\\\\r\\\\n\\\\t\".to_string());\n-        assert_eq!(\"'\\\"\\\\\".escape_default(), \"\\\\'\\\\\\\"\\\\\\\\\".to_string());\n-        assert_eq!(\"\\u0100\\uffff\".escape_default(), \"\\\\u0100\\\\uffff\".to_string());\n-        assert_eq!(\"\\U00010000\\U0010ffff\".escape_default(), \"\\\\U00010000\\\\U0010ffff\".to_string());\n-        assert_eq!(\"ab\\ufb00\".escape_default(), \"ab\\\\ufb00\".to_string());\n-        assert_eq!(\"\\U0001d4ea\\r\".escape_default(), \"\\\\U0001d4ea\\\\r\".to_string());\n+        assert_eq!(\"abc\".escape_default(), String::from_str(\"abc\"));\n+        assert_eq!(\"a c\".escape_default(), String::from_str(\"a c\"));\n+        assert_eq!(\"\\r\\n\\t\".escape_default(), String::from_str(\"\\\\r\\\\n\\\\t\"));\n+        assert_eq!(\"'\\\"\\\\\".escape_default(), String::from_str(\"\\\\'\\\\\\\"\\\\\\\\\"));\n+        assert_eq!(\"\\u0100\\uffff\".escape_default(), String::from_str(\"\\\\u0100\\\\uffff\"));\n+        assert_eq!(\"\\U00010000\\U0010ffff\".escape_default(),\n+                   String::from_str(\"\\\\U00010000\\\\U0010ffff\"));\n+        assert_eq!(\"ab\\ufb00\".escape_default(), String::from_str(\"ab\\\\ufb00\"));\n+        assert_eq!(\"\\U0001d4ea\\r\".escape_default(), String::from_str(\"\\\\U0001d4ea\\\\r\"));\n     }\n \n     #[test]\n@@ -2013,30 +2020,39 @@ mod tests {\n \n     #[test]\n     fn test_nfd_chars() {\n-        assert_eq!(\"abc\".nfd_chars().collect::<String>(), \"abc\".to_string());\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfd_chars().collect::<String>(), \"d\\u0307\\u01c4\".to_string());\n-        assert_eq!(\"\\u2026\".nfd_chars().collect::<String>(), \"\\u2026\".to_string());\n-        assert_eq!(\"\\u2126\".nfd_chars().collect::<String>(), \"\\u03a9\".to_string());\n-        assert_eq!(\"\\u1e0b\\u0323\".nfd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_string());\n-        assert_eq!(\"\\u1e0d\\u0307\".nfd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_string());\n-        assert_eq!(\"a\\u0301\".nfd_chars().collect::<String>(), \"a\\u0301\".to_string());\n-        assert_eq!(\"\\u0301a\".nfd_chars().collect::<String>(), \"\\u0301a\".to_string());\n-        assert_eq!(\"\\ud4db\".nfd_chars().collect::<String>(), \"\\u1111\\u1171\\u11b6\".to_string());\n-        assert_eq!(\"\\uac1c\".nfd_chars().collect::<String>(), \"\\u1100\\u1162\".to_string());\n+        assert_eq!(\"abc\".nfd_chars().collect::<String>(), String::from_str(\"abc\"));\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfd_chars().collect::<String>(),\n+                   String::from_str(\"d\\u0307\\u01c4\"));\n+        assert_eq!(\"\\u2026\".nfd_chars().collect::<String>(), String::from_str(\"\\u2026\"));\n+        assert_eq!(\"\\u2126\".nfd_chars().collect::<String>(), String::from_str(\"\\u03a9\"));\n+        assert_eq!(\"\\u1e0b\\u0323\".nfd_chars().collect::<String>(),\n+                   String::from_str(\"d\\u0323\\u0307\"));\n+        assert_eq!(\"\\u1e0d\\u0307\".nfd_chars().collect::<String>(),\n+                   String::from_str(\"d\\u0323\\u0307\"));\n+        assert_eq!(\"a\\u0301\".nfd_chars().collect::<String>(), String::from_str(\"a\\u0301\"));\n+        assert_eq!(\"\\u0301a\".nfd_chars().collect::<String>(), String::from_str(\"\\u0301a\"));\n+        assert_eq!(\"\\ud4db\".nfd_chars().collect::<String>(),\n+                   String::from_str(\"\\u1111\\u1171\\u11b6\"));\n+        assert_eq!(\"\\uac1c\".nfd_chars().collect::<String>(), String::from_str(\"\\u1100\\u1162\"));\n     }\n \n     #[test]\n     fn test_nfkd_chars() {\n-        assert_eq!(\"abc\".nfkd_chars().collect::<String>(), \"abc\".to_string());\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_chars().collect::<String>(), \"d\\u0307DZ\\u030c\".to_string());\n-        assert_eq!(\"\\u2026\".nfkd_chars().collect::<String>(), \"...\".to_string());\n-        assert_eq!(\"\\u2126\".nfkd_chars().collect::<String>(), \"\\u03a9\".to_string());\n-        assert_eq!(\"\\u1e0b\\u0323\".nfkd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_string());\n-        assert_eq!(\"\\u1e0d\\u0307\".nfkd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_string());\n-        assert_eq!(\"a\\u0301\".nfkd_chars().collect::<String>(), \"a\\u0301\".to_string());\n-        assert_eq!(\"\\u0301a\".nfkd_chars().collect::<String>(), \"\\u0301a\".to_string());\n-        assert_eq!(\"\\ud4db\".nfkd_chars().collect::<String>(), \"\\u1111\\u1171\\u11b6\".to_string());\n-        assert_eq!(\"\\uac1c\".nfkd_chars().collect::<String>(), \"\\u1100\\u1162\".to_string());\n+        assert_eq!(\"abc\".nfkd_chars().collect::<String>(), String::from_str(\"abc\"));\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_chars().collect::<String>(),\n+                   String::from_str(\"d\\u0307DZ\\u030c\"));\n+        assert_eq!(\"\\u2026\".nfkd_chars().collect::<String>(), String::from_str(\"...\"));\n+        assert_eq!(\"\\u2126\".nfkd_chars().collect::<String>(), String::from_str(\"\\u03a9\"));\n+        assert_eq!(\"\\u1e0b\\u0323\".nfkd_chars().collect::<String>(),\n+                   String::from_str(\"d\\u0323\\u0307\"));\n+        assert_eq!(\"\\u1e0d\\u0307\".nfkd_chars().collect::<String>(),\n+                   String::from_str(\"d\\u0323\\u0307\"));\n+        assert_eq!(\"a\\u0301\".nfkd_chars().collect::<String>(), String::from_str(\"a\\u0301\"));\n+        assert_eq!(\"\\u0301a\".nfkd_chars().collect::<String>(),\n+                   String::from_str(\"\\u0301a\"));\n+        assert_eq!(\"\\ud4db\".nfkd_chars().collect::<String>(),\n+String::from_str(\"\\u1111\\u1171\\u11b6\"));\n+        assert_eq!(\"\\uac1c\".nfkd_chars().collect::<String>(), String::from_str(\"\\u1100\\u1162\"));\n     }\n \n     #[test]\n@@ -2090,10 +2106,10 @@ mod tests {\n             v.iter().map(|x| x.len()).sum()\n         }\n \n-        let s = \"01234\".to_string();\n+        let s = String::from_str(\"01234\");\n         assert_eq!(5, sum_len([\"012\", \"\", \"34\"]));\n-        assert_eq!(5, sum_len([\"01\".to_string(), \"2\".to_string(),\n-                               \"34\".to_string(), \"\".to_string()]));\n+        assert_eq!(5, sum_len([String::from_str(\"01\"), String::from_str(\"2\"),\n+                               String::from_str(\"34\"), String::from_str(\"\")]));\n         assert_eq!(5, sum_len([s.as_slice()]));\n     }\n \n@@ -2112,10 +2128,10 @@ mod tests {\n     #[test]\n     fn test_str_from_utf8_owned() {\n         let xs = Vec::from_slice(b\"hello\");\n-        assert_eq!(from_utf8_owned(xs), Ok(\"hello\".to_string()));\n+        assert_eq!(from_utf8_owned(xs), Ok(String::from_str(\"hello\")));\n \n         let xs = Vec::from_slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes());\n-        assert_eq!(from_utf8_owned(xs), Ok(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_string()));\n+        assert_eq!(from_utf8_owned(xs), Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n \n         let xs = Vec::from_slice(b\"hello\\xFF\");\n         assert_eq!(from_utf8_owned(xs),\n@@ -2131,53 +2147,49 @@ mod tests {\n         assert_eq!(from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD There\\uFFFD Goodbye\".to_string()));\n+        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"Hello\\uFFFD There\\uFFFD Goodbye\")));\n \n         let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\".to_string()));\n+        assert_eq!(from_utf8_lossy(xs),\n+                   Owned(String::from_str(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\")));\n \n         let xs = b\"\\xF5foo\\xF5\\x80bar\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\".to_string()));\n+        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\")));\n \n         let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\".to_string()));\n+        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\")));\n \n         let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\".to_string()));\n+        assert_eq!(from_utf8_lossy(xs),\n+                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\")));\n \n         let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n-                                               foo\\U00010000bar\".to_string()));\n+        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n+                                               foo\\U00010000bar\")));\n \n         // surrogates\n         let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n-                                               \\uFFFD\\uFFFD\\uFFFDbar\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_from_str() {\n-      let owned: Option<::std::string::String> = from_str(\"string\");\n-      assert_eq!(owned.as_ref().map(|s| s.as_slice()), Some(\"string\"));\n+        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n+                                               \\uFFFD\\uFFFD\\uFFFDbar\")));\n     }\n \n     #[test]\n     fn test_maybe_owned_traits() {\n         let s = Slice(\"abcde\");\n         assert_eq!(s.len(), 5);\n         assert_eq!(s.as_slice(), \"abcde\");\n-        assert_eq!(s.to_str().as_slice(), \"abcde\");\n+        assert_eq!(String::from_str(s.as_slice()).as_slice(), \"abcde\");\n         assert_eq!(format!(\"{}\", s).as_slice(), \"abcde\");\n-        assert!(s.lt(&Owned(\"bcdef\".to_string())));\n+        assert!(s.lt(&Owned(String::from_str(\"bcdef\"))));\n         assert_eq!(Slice(\"\"), Default::default());\n \n-        let o = Owned(\"abcde\".to_string());\n+        let o = Owned(String::from_str(\"abcde\"));\n         assert_eq!(o.len(), 5);\n         assert_eq!(o.as_slice(), \"abcde\");\n-        assert_eq!(o.to_str().as_slice(), \"abcde\");\n+        assert_eq!(String::from_str(o.as_slice()).as_slice(), \"abcde\");\n         assert_eq!(format!(\"{}\", o).as_slice(), \"abcde\");\n         assert!(o.lt(&Slice(\"bcdef\")));\n-        assert_eq!(Owned(\"\".to_string()), Default::default());\n+        assert_eq!(Owned(String::from_str(\"\")), Default::default());\n \n         assert!(s.cmp(&o) == Equal);\n         assert!(s.equiv(&o));\n@@ -2192,39 +2204,44 @@ mod tests {\n         assert!(s.is_slice());\n         assert!(!s.is_owned());\n \n-        let o = Owned(\"abcde\".to_string());\n+        let o = Owned(String::from_str(\"abcde\"));\n         assert!(!o.is_slice());\n         assert!(o.is_owned());\n     }\n \n     #[test]\n     fn test_maybe_owned_clone() {\n-        assert_eq!(Owned(\"abcde\".to_string()), Slice(\"abcde\").clone());\n-        assert_eq!(Owned(\"abcde\".to_string()), Owned(\"abcde\".to_string()).clone());\n+        assert_eq!(Owned(String::from_str(\"abcde\")), Slice(\"abcde\").clone());\n+        assert_eq!(Owned(String::from_str(\"abcde\")), Owned(String::from_str(\"abcde\")).clone());\n         assert_eq!(Slice(\"abcde\"), Slice(\"abcde\").clone());\n-        assert_eq!(Slice(\"abcde\"), Owned(\"abcde\".to_string()).clone());\n+        assert_eq!(Slice(\"abcde\"), Owned(String::from_str(\"abcde\")).clone());\n     }\n \n     #[test]\n     fn test_maybe_owned_into_string() {\n-        assert_eq!(Slice(\"abcde\").into_string(), \"abcde\".to_string());\n-        assert_eq!(Owned(\"abcde\".to_string()).into_string(), \"abcde\".to_string());\n+        assert_eq!(Slice(\"abcde\").into_string(), String::from_str(\"abcde\"));\n+        assert_eq!(Owned(String::from_str(\"abcde\")).into_string(),\n+                   String::from_str(\"abcde\"));\n     }\n \n     #[test]\n     fn test_into_maybe_owned() {\n         assert_eq!(\"abcde\".into_maybe_owned(), Slice(\"abcde\"));\n-        assert_eq!((\"abcde\".to_string()).into_maybe_owned(), Slice(\"abcde\"));\n-        assert_eq!(\"abcde\".into_maybe_owned(), Owned(\"abcde\".to_string()));\n-        assert_eq!((\"abcde\".to_string()).into_maybe_owned(), Owned(\"abcde\".to_string()));\n+        assert_eq!((String::from_str(\"abcde\")).into_maybe_owned(), Slice(\"abcde\"));\n+        assert_eq!(\"abcde\".into_maybe_owned(), Owned(String::from_str(\"abcde\")));\n+        assert_eq!((String::from_str(\"abcde\")).into_maybe_owned(),\n+                   Owned(String::from_str(\"abcde\")));\n     }\n }\n \n #[cfg(test)]\n mod bench {\n     use test::Bencher;\n     use super::*;\n-    use std::prelude::*;\n+    use vec::Vec;\n+    use std::iter::{Iterator, DoubleEndedIterator};\n+    use std::collections::Collection;\n+    use std::slice::Vector;\n \n     #[bench]\n     fn char_iterator(b: &mut Bencher) {"}, {"sha": "74b9465f2a5690c560837f70598e63fbc03e5ee9", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -354,7 +354,7 @@ impl<'a, S: Str> Equiv<S> for String {\n \n impl<S: Str> Add<S, String> for String {\n     fn add(&self, other: &S) -> String {\n-        let mut s = self.to_string();\n+        let mut s = String::from_str(self.as_slice());\n         s.push_str(other.as_slice());\n         return s;\n     }\n@@ -369,6 +369,12 @@ mod tests {\n     use str::{Str, StrSlice};\n     use super::String;\n \n+    #[test]\n+    fn test_from_str() {\n+      let owned: Option<::std::string::String> = from_str(\"string\");\n+      assert_eq!(owned.as_ref().map(|s| s.as_slice()), Some(\"string\"));\n+    }\n+\n     #[bench]\n     fn bench_with_capacity(b: &mut Bencher) {\n         b.iter(|| {"}, {"sha": "ef5b51fd00b3f5a6894db5356f68371fac385d98", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -70,7 +70,7 @@ static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n /**\n  * Converts a number to its string representation as a byte vector.\n  * This is meant to be a common base implementation for all numeric string\n- * conversion functions like `to_str()` or `to_str_radix()`.\n+ * conversion functions like `to_string()` or `to_str_radix()`.\n  *\n  * # Arguments\n  * - `num`           - The number to convert. Accepts any number that"}, {"sha": "5393c207344348a9e7575b91ed9f652ddbee3470", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -167,12 +167,6 @@ fn test_escape_unicode() {\n     assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n }\n \n-#[test]\n-fn test_to_str() {\n-    let s = 't'.to_str();\n-    assert_eq!(s.as_slice(), \"t\");\n-}\n-\n #[test]\n fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {"}, {"sha": "0b04a07ea888af5a667fa1ad61015c0382141c5d", "filename": "src/libdebug/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibdebug%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibdebug%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Ffmt.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -45,7 +45,7 @@ impl<T> Poly for T {\n             // If we have a specified width for formatting, then we have to make\n             // this allocation of a new string\n             _ => {\n-                let s = repr::repr_to_str(self);\n+                let s = repr::repr_to_string(self);\n                 f.pad(s.as_slice())\n             }\n         }"}, {"sha": "3e541929dbf0883957cd74cd4f5046d1a52882f8", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -73,7 +73,7 @@ int_repr!(u64, \"u64\")\n \n macro_rules! num_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n     fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        let s = self.to_str();\n+        let s = self.to_string();\n         writer.write(s.as_bytes()).and_then(|()| {\n             writer.write($suffix)\n         })\n@@ -564,7 +564,7 @@ pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n     }\n }\n \n-pub fn repr_to_str<T>(t: &T) -> String {\n+pub fn repr_to_string<T>(t: &T) -> String {\n     let mut result = io::MemWriter::new();\n     write_repr(&mut result as &mut io::Writer, t).unwrap();\n     String::from_utf8(result.unwrap()).unwrap()"}, {"sha": "bb3e90958f14229d266bfc986be70ba7d89e1952", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -59,7 +59,7 @@\n //!     ];\n //!     let matches = match getopts(args.tail(), opts) {\n //!         Ok(m) => { m }\n-//!         Err(f) => { fail!(f.to_str()) }\n+//!         Err(f) => { fail!(f.to_string()) }\n //!     };\n //!     if matches.opt_present(\"h\") {\n //!         print_usage(program.as_slice(), opts);\n@@ -222,9 +222,9 @@ impl Name {\n         }\n     }\n \n-    fn to_str(&self) -> String {\n+    fn to_string(&self) -> String {\n         match *self {\n-            Short(ch) => ch.to_str(),\n+            Short(ch) => ch.to_string(),\n             Long(ref s) => s.to_string()\n         }\n     }\n@@ -501,7 +501,7 @@ impl Fail_ {\n     /// Convert a `Fail_` enum into an error string.\n     #[deprecated=\"use `Show` (`{}` format specifier)\"]\n     pub fn to_err_msg(self) -> String {\n-        self.to_str()\n+        self.to_string()\n     }\n }\n \n@@ -609,12 +609,12 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 name_pos += 1;\n                 let optid = match find_opt(opts.as_slice(), (*nm).clone()) {\n                   Some(id) => id,\n-                  None => return Err(UnrecognizedOption(nm.to_str()))\n+                  None => return Err(UnrecognizedOption(nm.to_string()))\n                 };\n                 match opts.get(optid).hasarg {\n                   No => {\n                     if !i_arg.is_none() {\n-                        return Err(UnexpectedArgument(nm.to_str()));\n+                        return Err(UnexpectedArgument(nm.to_string()));\n                     }\n                     vals.get_mut(optid).push(Given);\n                   }\n@@ -635,7 +635,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     if !i_arg.is_none() {\n                         vals.get_mut(optid).push(Val(i_arg.clone().unwrap()));\n                     } else if i + 1 == l {\n-                        return Err(ArgumentMissing(nm.to_str()));\n+                        return Err(ArgumentMissing(nm.to_string()));\n                     } else {\n                         i += 1;\n                         vals.get_mut(optid).push(Val(args[i].clone()));\n@@ -652,12 +652,12 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n         let occ = opts.get(i).occur;\n         if occ == Req {\n             if n == 0 {\n-                return Err(OptionMissing(opts.get(i).name.to_str()));\n+                return Err(OptionMissing(opts.get(i).name.to_string()));\n             }\n         }\n         if occ != Multi {\n             if n > 1 {\n-                return Err(OptionDuplicated(opts.get(i).name.to_str()));\n+                return Err(OptionDuplicated(opts.get(i).name.to_string()));\n             }\n         }\n         i += 1;"}, {"sha": "668000b2db42caab6e71356ff1a6f937ba6059d7", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -703,11 +703,11 @@ mod test {\n         for &p in pats.iter() {\n             let pat = Pattern::new(p);\n             for c in \"abcdefghijklmnopqrstuvwxyz\".chars() {\n-                assert!(pat.matches(c.to_str().as_slice()));\n+                assert!(pat.matches(c.to_string().as_slice()));\n             }\n             for c in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".chars() {\n                 let options = MatchOptions {case_sensitive: false, .. MatchOptions::new()};\n-                assert!(pat.matches_with(c.to_str().as_slice(), options));\n+                assert!(pat.matches_with(c.to_string().as_slice(), options));\n             }\n             assert!(pat.matches(\"1\"));\n             assert!(pat.matches(\"2\"));"}, {"sha": "662722e08d96fe1e09e0a01974b046802628808d", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -666,7 +666,7 @@ mod tests {\n         let mut writer = MemWriter::new();\n         render(&g, &mut writer).unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        match r.read_to_str() {\n+        match r.read_to_string() {\n             Ok(string) => Ok(string.to_string()),\n             Err(err) => Err(err),\n         }\n@@ -768,7 +768,7 @@ r#\"digraph hasse_diagram {\n \n         render(&g, &mut writer).unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        let r = r.read_to_str();\n+        let r = r.read_to_string();\n \n         assert_eq!(r.unwrap().as_slice(),\n r#\"digraph syntax_tree {"}, {"sha": "dbca4ff7ff719a9575a8dafe09c2b5adb629afc1", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -259,7 +259,7 @@ pub fn to_utf16(s: &CString) -> IoResult<Vec<u16>> {\n         None => Err(IoError {\n             code: libc::ERROR_INVALID_NAME as uint,\n             extra: 0,\n-            detail: Some(\"valid unicode input required\".to_str()),\n+            detail: Some(\"valid unicode input required\".to_string()),\n         })\n     }\n }"}, {"sha": "0e019fa7e8fbdadf7b04ea38dd5e09a22ba5edc1", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -43,7 +43,7 @@ fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint\n         return Err(IoError {\n             code: ERROR as uint,\n             extra: 0,\n-            detail: Some(\"path must be smaller than SUN_LEN\".to_str()),\n+            detail: Some(\"path must be smaller than SUN_LEN\".to_string()),\n         })\n     }\n     s.sun_family = libc::AF_UNIX as libc::sa_family_t;"}, {"sha": "ec40ff89bd2cdb9fdf6d46576c80c8005d5abfc1", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -479,7 +479,7 @@ impl rtio::RtioPipe for UnixStream {\n                             Err(IoError {\n                                 code: libc::ERROR_OPERATION_ABORTED as uint,\n                                 extra: amt,\n-                                detail: Some(\"short write during write\".to_str()),\n+                                detail: Some(\"short write during write\".to_string()),\n                             })\n                         } else {\n                             Err(util::timeout(\"write timed out\"))"}, {"sha": "71702d180b9e0efaffb630e01fcecb23803e1c65", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -170,7 +170,7 @@ impl rtio::RtioProcess for Process {\n             Some(..) => return Err(IoError {\n                 code: ERROR as uint,\n                 extra: 0,\n-                detail: Some(\"can't kill an exited process\".to_str()),\n+                detail: Some(\"can't kill an exited process\".to_string()),\n             }),\n             None => {}\n         }\n@@ -301,7 +301,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n         return Err(IoError {\n             code: libc::ERROR_CALL_NOT_IMPLEMENTED as uint,\n             extra: 0,\n-            detail: Some(\"unsupported gid/uid requested on windows\".to_str()),\n+            detail: Some(\"unsupported gid/uid requested on windows\".to_string()),\n         })\n     }\n "}, {"sha": "06046cc74cfd85d7828d92b2f0688756764bf57a", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -30,7 +30,7 @@ pub fn timeout(desc: &'static str) -> IoError {\n     IoError {\n         code: ERROR as uint,\n         extra: 0,\n-        detail: Some(desc.to_str()),\n+        detail: Some(desc.to_string()),\n     }\n }\n \n@@ -40,7 +40,7 @@ pub fn short_write(n: uint, desc: &'static str) -> IoError {\n     IoError {\n         code: ERROR as uint,\n         extra: n,\n-        detail: Some(desc.to_str()),\n+        detail: Some(desc.to_string()),\n     }\n }\n "}, {"sha": "046ba96f45a38185e28770381c58094ca4713e77", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -2737,7 +2737,7 @@ mod bigint_tests {\n         // attempt to allocate a vector of size (-1u) == huge.\n         let x: BigInt =\n             from_str(format!(\"1{}\", \"0\".repeat(36)).as_slice()).unwrap();\n-        let _y = x.to_str();\n+        let _y = x.to_string();\n     }\n \n     #[test]\n@@ -2842,14 +2842,14 @@ mod bench {\n     }\n \n     #[bench]\n-    fn to_str(b: &mut Bencher) {\n+    fn to_string(b: &mut Bencher) {\n         let fac = factorial(100);\n         let fib = fib(100);\n         b.iter(|| {\n-            fac.to_str();\n+            fac.to_string();\n         });\n         b.iter(|| {\n-            fib.to_str();\n+            fib.to_string();\n         });\n     }\n "}, {"sha": "f4a3ac97a4ef762bca048dee50bab92cea967fc7", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -347,9 +347,9 @@ mod test {\n     }\n \n     #[test]\n-    fn test_to_str() {\n+    fn test_to_string() {\n         fn test(c : Complex64, s: String) {\n-            assert_eq!(c.to_str(), s);\n+            assert_eq!(c.to_string(), s);\n         }\n         test(_0_0i, \"0+0i\".to_string());\n         test(_1_0i, \"1+0i\".to_string());"}, {"sha": "a279ede6fa5347d68b85d7251fb3ad20a4b43752", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -17,6 +17,7 @@ use std::fmt;\n use std::from_str::FromStr;\n use std::num;\n use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n+\n use bigint::{BigInt, BigUint, Sign, Plus, Minus};\n \n /// Represents the ratio between 2 numbers.\n@@ -603,7 +604,7 @@ mod test {\n     fn test_to_from_str() {\n         fn test(r: Rational, s: String) {\n             assert_eq!(FromStr::from_str(s.as_slice()), Some(r));\n-            assert_eq!(r.to_str(), s);\n+            assert_eq!(r.to_string(), s);\n         }\n         test(_1, \"1\".to_string());\n         test(_0, \"0\".to_string());"}, {"sha": "95ed334c5d4ec8eb91ef867cd32e191859b54f76", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -87,7 +87,7 @@ fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])\n     let re = match Regex::new(regex.as_slice()) {\n         Ok(re) => re,\n         Err(err) => {\n-            cx.span_err(sp, err.to_str().as_slice());\n+            cx.span_err(sp, err.to_string().as_slice());\n             return DummyResult::any(sp)\n         }\n     };\n@@ -621,19 +621,19 @@ fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<String> {\n     let regex = match entry.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(ref s, _) => s.to_str(),\n+                ast::LitStr(ref s, _) => s.to_string(),\n                 _ => {\n                     cx.span_err(entry.span, format!(\n                         \"expected string literal but got `{}`\",\n-                        pprust::lit_to_str(lit)).as_slice());\n+                        pprust::lit_to_string(lit)).as_slice());\n                     return None\n                 }\n             }\n         }\n         _ => {\n             cx.span_err(entry.span, format!(\n                 \"expected string literal but got `{}`\",\n-                pprust::expr_to_str(entry)).as_slice());\n+                pprust::expr_to_string(entry)).as_slice());\n             return None\n         }\n     };"}, {"sha": "4f915342ee0eebe37759ede1a15e9cac670a4a31", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -773,7 +773,7 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n                                             t: ty::t,\n                                             name: &str) -> String {\n-    let s = ppaux::ty_to_str(ccx.tcx(), t);\n+    let s = ppaux::ty_to_string(ccx.tcx(), t);\n     let path = [PathName(token::intern(s.as_slice())),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);"}, {"sha": "324ed3b567ec44436b0d81166b3910b9fc95b0d9", "filename": "src/librustc/back/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -340,13 +340,13 @@ mod svh_visitor {\n                 // trees might be faster. Implementing this is far\n                 // easier in short term.\n                 let macro_defn_as_string =\n-                    pprust::to_str(|pp_state| pp_state.print_mac(macro));\n+                    pprust::to_string(|pp_state| pp_state.print_mac(macro));\n                 macro_defn_as_string.hash(self.st);\n             } else {\n                 // It is not possible to observe any kind of macro\n                 // invocation at this stage except `macro_rules!`.\n                 fail!(\"reached macro somehow: {}\",\n-                      pprust::to_str(|pp_state| pp_state.print_mac(macro)));\n+                      pprust::to_string(|pp_state| pp_state.print_mac(macro)));\n             }\n \n             visit::walk_mac(self, macro, e);"}, {"sha": "6a016edcd2868fce87671e901d207f62464ec2b5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -594,15 +594,15 @@ impl pprust::PpAnn for IdentifiedAnnotation {\n         match node {\n             pprust::NodeItem(item) => {\n                 try!(pp::space(&mut s.s));\n-                s.synth_comment(item.id.to_str())\n+                s.synth_comment(item.id.to_string())\n             }\n             pprust::NodeBlock(blk) => {\n                 try!(pp::space(&mut s.s));\n                 s.synth_comment(format!(\"block {}\", blk.id))\n             }\n             pprust::NodeExpr(expr) => {\n                 try!(pp::space(&mut s.s));\n-                try!(s.synth_comment(expr.id.to_str()));\n+                try!(s.synth_comment(expr.id.to_string()));\n                 s.pclose()\n             }\n             pprust::NodePat(pat) => {\n@@ -636,7 +636,7 @@ impl pprust::PpAnn for TypedAnnotation {\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s,\n-                              ppaux::ty_to_str(\n+                              ppaux::ty_to_string(\n                                   tcx,\n                                   ty::expr_ty(tcx, expr)).as_slice()));\n                 s.pclose()"}, {"sha": "ad0d8cac1e3578fa8aebf0ec4d13d56b2a2aea3d", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -251,7 +251,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n         match getopts::getopts(args.as_slice(), config::optgroups().as_slice()) {\n             Ok(m) => m,\n             Err(f) => {\n-                early_error(f.to_str().as_slice());\n+                early_error(f.to_string().as_slice());\n             }\n         };\n \n@@ -450,7 +450,7 @@ fn monitor(f: proc():Send) {\n                     emitter.emit(None, note.as_slice(), diagnostic::Note)\n                 }\n \n-                match r.read_to_str() {\n+                match r.read_to_string() {\n                     Ok(s) => println!(\"{}\", s),\n                     Err(e) => {\n                         emitter.emit(None,"}, {"sha": "0860d111a9ef04a2f254bbf2de4b615856651cd2", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -347,7 +347,7 @@ fn mk_test_module(cx: &TestCtxt) -> Gc<ast::Item> {\n         span: DUMMY_SP,\n      };\n \n-    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_str(&item));\n+    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));\n \n     box(GC) item\n }"}, {"sha": "a4425183cde64ad79f46fa646d43ab8aca5b3e3c", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -1883,7 +1883,7 @@ impl TypeNames {\n         self.named_types.borrow().find_equiv(&s).map(|x| Type::from_ref(*x))\n     }\n \n-    pub fn type_to_str(&self, ty: Type) -> String {\n+    pub fn type_to_string(&self, ty: Type) -> String {\n         unsafe {\n             let s = llvm::LLVMTypeToString(ty.to_ref());\n             let ret = from_c_str(s);\n@@ -1893,11 +1893,11 @@ impl TypeNames {\n     }\n \n     pub fn types_to_str(&self, tys: &[Type]) -> String {\n-        let strs: Vec<String> = tys.iter().map(|t| self.type_to_str(*t)).collect();\n+        let strs: Vec<String> = tys.iter().map(|t| self.type_to_string(*t)).collect();\n         format!(\"[{}]\", strs.connect(\",\"))\n     }\n \n-    pub fn val_to_str(&self, val: ValueRef) -> String {\n+    pub fn val_to_string(&self, val: ValueRef) -> String {\n         unsafe {\n             let s = llvm::LLVMValueToString(val);\n             let ret = from_c_str(s);"}, {"sha": "98a6f7d5ed38d2879255f6065f3c7510839e3179", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -31,7 +31,7 @@ use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::typeck::astconv::ast_ty_to_ty;\n use middle::typeck::infer;\n use middle::{typeck, ty, def, pat_util, stability};\n-use util::ppaux::{ty_to_str};\n+use util::ppaux::{ty_to_string};\n use util::nodemap::NodeSet;\n use lint::{Context, LintPass, LintArray};\n \n@@ -412,14 +412,14 @@ impl HeapMemory {\n         });\n \n         if n_uniq > 0 {\n-            let s = ty_to_str(cx.tcx, ty);\n+            let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n             cx.span_lint(OWNED_HEAP_MEMORY, span, m.as_slice());\n             cx.span_lint(HEAP_MEMORY, span, m.as_slice());\n         }\n \n         if n_box > 0 {\n-            let s = ty_to_str(cx.tcx, ty);\n+            let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n             cx.span_lint(MANAGED_HEAP_MEMORY, span, m.as_slice());\n             cx.span_lint(HEAP_MEMORY, span, m.as_slice());"}, {"sha": "61aaf068c1098bd06ce1e6e9c9433542bfc7e2a7", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -666,7 +666,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         for &(lint, span, ref msg) in v.iter() {\n             tcx.sess.span_bug(span,\n                               format!(\"unprocessed lint {} at {}: {}\",\n-                                      lint.as_str(), tcx.map.node_to_str(*id), *msg).as_slice())\n+                                      lint.as_str(), tcx.map.node_to_string(*id), *msg).as_slice())\n         }\n     }\n "}, {"sha": "edf46c214ba63fa4b94757ab2dafc19f9fc91aed", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -148,12 +148,12 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n                    ident, path_opt);\n             let name = match *path_opt {\n                 Some((ref path_str, _)) => {\n-                    let name = path_str.get().to_str();\n+                    let name = path_str.get().to_string();\n                     validate_crate_name(Some(e.sess), name.as_slice(),\n                                         Some(i.span));\n                     name\n                 }\n-                None => ident.get().to_str(),\n+                None => ident.get().to_string(),\n             };\n             Some(CrateInfo {\n                 ident: ident.get().to_string(),"}, {"sha": "1cf420dd2f8cd655e8291c623cfcd2a641cc5e11", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -1087,7 +1087,7 @@ fn list_crate_attributes(md: ebml::Doc, hash: &Svh,\n \n     let r = get_attributes(md);\n     for attr in r.iter() {\n-        try!(write!(out, \"{}\\n\", pprust::attribute_to_str(attr)));\n+        try!(write!(out, \"{}\\n\", pprust::attribute_to_string(attr)));\n     }\n \n     write!(out, \"\\n\\n\")"}, {"sha": "a9208045d250ae4783becf936f8420ab51ac5fdb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -101,7 +101,7 @@ fn encode_impl_type_basename(ebml_w: &mut Encoder, name: Ident) {\n }\n \n pub fn encode_def_id(ebml_w: &mut Encoder, id: DefId) {\n-    ebml_w.wr_tagged_str(tag_def_id, def_to_str(id).as_slice());\n+    ebml_w.wr_tagged_str(tag_def_id, def_to_string(id).as_slice());\n }\n \n #[deriving(Clone)]\n@@ -116,7 +116,7 @@ fn encode_trait_ref(ebml_w: &mut Encoder,\n                     tag: uint) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n-        ds: def_to_str,\n+        ds: def_to_string,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n@@ -141,7 +141,7 @@ fn encode_family(ebml_w: &mut Encoder, c: char) {\n     ebml_w.end_tag();\n }\n \n-pub fn def_to_str(did: DefId) -> String {\n+pub fn def_to_string(did: DefId) -> String {\n     format!(\"{}:{}\", did.krate, did.node)\n }\n \n@@ -151,7 +151,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut Encoder,\n                              tag: uint) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n-        ds: def_to_str,\n+        ds: def_to_string,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n@@ -172,7 +172,7 @@ fn encode_region_param_defs(ebml_w: &mut Encoder,\n         ebml_w.end_tag();\n \n         ebml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             def_to_str(param.def_id).as_slice());\n+                             def_to_string(param.def_id).as_slice());\n \n         ebml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -204,7 +204,7 @@ fn encode_bounds_and_type(ebml_w: &mut Encoder,\n \n fn encode_variant_id(ebml_w: &mut Encoder, vid: DefId) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n-    let s = def_to_str(vid);\n+    let s = def_to_string(vid);\n     ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n@@ -214,7 +214,7 @@ pub fn write_type(ecx: &EncodeContext,\n                   typ: ty::t) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n-        ds: def_to_str,\n+        ds: def_to_string,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n@@ -236,7 +236,7 @@ fn encode_method_fty(ecx: &EncodeContext,\n \n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n-        ds: def_to_str,\n+        ds: def_to_string,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n@@ -266,14 +266,14 @@ fn encode_disr_val(_: &EncodeContext,\n                    ebml_w: &mut Encoder,\n                    disr_val: ty::Disr) {\n     ebml_w.start_tag(tag_disr_val);\n-    let s = disr_val.to_str();\n+    let s = disr_val.to_string();\n     ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n \n fn encode_parent_item(ebml_w: &mut Encoder, id: DefId) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n-    let s = def_to_str(id);\n+    let s = def_to_string(id);\n     ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n@@ -291,7 +291,7 @@ fn encode_struct_fields(ebml_w: &mut Encoder,\n         encode_struct_field_family(ebml_w, f.vis);\n         encode_def_id(ebml_w, f.id);\n         ebml_w.start_tag(tag_item_field_origin);\n-        let s = def_to_str(origin);\n+        let s = def_to_string(origin);\n         ebml_w.writer.write(s.as_bytes());\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n@@ -382,7 +382,7 @@ fn encode_reexported_static_method(ebml_w: &mut Encoder,\n             exp.name, token::get_ident(method_ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n     ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    ebml_w.wr_str(def_to_str(method_def_id).as_slice());\n+    ebml_w.wr_str(def_to_string(method_def_id).as_slice());\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_items_data_item_reexport_name);\n     ebml_w.wr_str(format!(\"{}::{}\",\n@@ -529,7 +529,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                        id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n                 ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                ebml_w.wr_str(def_to_str(exp.def_id).as_slice());\n+                ebml_w.wr_str(def_to_string(exp.def_id).as_slice());\n                 ebml_w.end_tag();\n                 ebml_w.start_tag(tag_items_data_item_reexport_name);\n                 ebml_w.wr_str(exp.name.as_slice());\n@@ -562,12 +562,12 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     // Encode info about all the module children.\n     for item in md.items.iter() {\n         ebml_w.start_tag(tag_mod_child);\n-        ebml_w.wr_str(def_to_str(local_def(item.id)).as_slice());\n+        ebml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n         ebml_w.end_tag();\n \n         each_auxiliary_node_id(*item, |auxiliary_node_id| {\n             ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_str(local_def(\n+            ebml_w.wr_str(def_to_string(local_def(\n                         auxiliary_node_id)).as_slice());\n             ebml_w.end_tag();\n             true\n@@ -579,10 +579,10 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                 debug!(\"(encoding info for module) ... encoding impl {} \\\n                         ({:?}/{:?})\",\n                         token::get_ident(ident),\n-                        did, ecx.tcx.map.node_to_str(did));\n+                        did, ecx.tcx.map.node_to_string(did));\n \n                 ebml_w.start_tag(tag_mod_impl);\n-                ebml_w.wr_str(def_to_str(local_def(did)).as_slice());\n+                ebml_w.wr_str(def_to_string(local_def(did)).as_slice());\n                 ebml_w.end_tag();\n             }\n             _ => {}\n@@ -659,7 +659,7 @@ fn encode_provided_source(ebml_w: &mut Encoder,\n                           source_opt: Option<DefId>) {\n     for source in source_opt.iter() {\n         ebml_w.start_tag(tag_item_method_provided_source);\n-        let s = def_to_str(*source);\n+        let s = def_to_string(*source);\n         ebml_w.writer.write(s.as_bytes());\n         ebml_w.end_tag();\n     }\n@@ -916,7 +916,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     }\n \n     debug!(\"encoding info for item at {}\",\n-           tcx.sess.codemap().span_to_str(item.span));\n+           tcx.sess.codemap().span_to_string(item.span));\n \n     let def_id = local_def(item.id);\n     let stab = stability::lookup(tcx, ast_util::local_def(item.id));\n@@ -987,7 +987,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n             ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_str(local_def(foreign_item.id)).as_slice());\n+            ebml_w.wr_str(def_to_string(local_def(foreign_item.id)).as_slice());\n             ebml_w.end_tag();\n         }\n         encode_visibility(ebml_w, vis);\n@@ -1111,7 +1111,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         for &method_def_id in methods.iter() {\n             ebml_w.start_tag(tag_item_impl_method);\n-            let s = def_to_str(method_def_id);\n+            let s = def_to_string(method_def_id);\n             ebml_w.writer.write(s.as_bytes());\n             ebml_w.end_tag();\n         }\n@@ -1174,7 +1174,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             ebml_w.end_tag();\n \n             ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_str(method_def_id).as_slice());\n+            ebml_w.wr_str(def_to_string(method_def_id).as_slice());\n             ebml_w.end_tag();\n         }\n         encode_path(ebml_w, path.clone());\n@@ -1327,7 +1327,7 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n     // See above\n     let ecx: &EncodeContext = unsafe { mem::transmute(ecx_ptr) };\n     debug!(\"writing foreign item {}::{}\",\n-            ecx.tcx.map.path_to_str(ni.id),\n+            ecx.tcx.map.path_to_string(ni.id),\n             token::get_ident(ni.ident));\n \n     let mut ebml_w = unsafe {\n@@ -1693,12 +1693,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n     ebml_w.start_tag(tag_misc_info_crate_items);\n     for &item in krate.module.items.iter() {\n         ebml_w.start_tag(tag_mod_child);\n-        ebml_w.wr_str(def_to_str(local_def(item.id)).as_slice());\n+        ebml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n         ebml_w.end_tag();\n \n         each_auxiliary_node_id(item, |auxiliary_node_id| {\n             ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_str(local_def(\n+            ebml_w.wr_str(def_to_string(local_def(\n                         auxiliary_node_id)).as_slice());\n             ebml_w.end_tag();\n             true\n@@ -1939,7 +1939,7 @@ pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> String {\n     let mut wr = MemWriter::new();\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),\n-        ds: def_to_str,\n+        ds: def_to_string,\n         tcx: tcx,\n         abbrevs: &RefCell::new(HashMap::new())\n     }, t);"}, {"sha": "11b1687dc55999163defd6f49b10f3e731c0d5a2", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -28,7 +28,7 @@ use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n use middle::{ty, typeck};\n-use util::ppaux::ty_to_str;\n+use util::ppaux::ty_to_string;\n \n use syntax::{ast, ast_map, ast_util, codemap, fold};\n use syntax::codemap::Span;\n@@ -86,7 +86,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n         e::IIMethodRef(_, _, m) => m.id,\n     };\n     debug!(\"> Encoding inlined item: {} ({})\",\n-           ecx.tcx.map.path_to_str(id),\n+           ecx.tcx.map.path_to_string(id),\n            ebml_w.writer.tell());\n \n     let ii = simplify_ast(ii);\n@@ -99,7 +99,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     ebml_w.end_tag();\n \n     debug!(\"< Encoded inlined fn: {} ({})\",\n-           ecx.tcx.map.path_to_str(id),\n+           ecx.tcx.map.path_to_string(id),\n            ebml_w.writer.tell());\n }\n \n@@ -119,7 +119,7 @@ pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n         debug!(\"> Decoding inlined fn: {}::?\",\n         {\n             // Do an Option dance to use the path after it is moved below.\n-            let s = ast_map::path_to_str(ast_map::Values(path.iter()));\n+            let s = ast_map::path_to_string(ast_map::Values(path.iter()));\n             path_as_str = Some(s);\n             path_as_str.as_ref().map(|x| x.as_slice())\n         });\n@@ -147,7 +147,7 @@ pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n         match ii {\n           ast::IIItem(i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_str(&*i));\n+                   syntax::print::pprust::item_to_string(&*i));\n           }\n           _ => { }\n         }\n@@ -826,7 +826,7 @@ impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n     fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a> {\n         tyencode::ctxt {\n             diag: self.tcx.sess.diagnostic(),\n-            ds: e::def_to_str,\n+            ds: e::def_to_string,\n             tcx: self.tcx,\n             abbrevs: &self.type_abbrevs\n         }\n@@ -1391,7 +1391,7 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(xcx);\n                         debug!(\"inserting ty for node {:?}: {}\",\n-                               id, ty_to_str(dcx.tcx, ty));\n+                               id, ty_to_string(dcx.tcx, ty));\n                         dcx.tcx.node_types.borrow_mut().insert(id as uint, ty);\n                     }\n                     c::tag_table_item_subst => {\n@@ -1561,7 +1561,7 @@ fn test_simplification() {\n     ).unwrap());\n     match (item_out, item_exp) {\n       (ast::IIItem(item_out), ast::IIItem(item_exp)) => {\n-        assert!(pprust::item_to_str(item_out) == pprust::item_to_str(item_exp));\n+        assert!(pprust::item_to_string(item_out) == pprust::item_to_string(item_exp));\n       }\n       _ => fail!()\n     }"}, {"sha": "db8ab8c83fbdc78ae18f20bdb60d96bb08ae431a", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -351,7 +351,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 \"it\".to_string()\n             } else {\n                 format!(\"`{}`\",\n-                        self.bccx.loan_path_to_str(&*old_loan.loan_path))\n+                        self.bccx.loan_path_to_string(&*old_loan.loan_path))\n             };\n \n             match (new_loan.kind, old_loan.kind) {\n@@ -360,7 +360,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as mutable \\\n                                 more than once at a time\",\n-                                self.bccx.loan_path_to_str(\n+                                self.bccx.loan_path_to_string(\n                                     &*new_loan.loan_path)).as_slice());\n                 }\n \n@@ -369,7 +369,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                         new_loan.span,\n                         format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed\",\n-                                self.bccx.loan_path_to_str(&*new_loan.loan_path),\n+                                self.bccx.loan_path_to_string(&*new_loan.loan_path),\n                                 old_pronoun).as_slice());\n                 }\n \n@@ -378,7 +378,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as {} because \\\n                                 previous closure requires unique access\",\n-                                self.bccx.loan_path_to_str(&*new_loan.loan_path),\n+                                self.bccx.loan_path_to_string(&*new_loan.loan_path),\n                                 new_loan.kind.to_user_str()).as_slice());\n                 }\n \n@@ -387,7 +387,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as {} because \\\n                                 {} is also borrowed as {}\",\n-                                self.bccx.loan_path_to_str(&*new_loan.loan_path),\n+                                self.bccx.loan_path_to_string(&*new_loan.loan_path),\n                                 new_loan.kind.to_user_str(),\n                                 old_pronoun,\n                                 old_loan.kind.to_user_str()).as_slice());\n@@ -399,7 +399,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                     self.bccx.span_note(\n                         span,\n                         format!(\"borrow occurs due to use of `{}` in closure\",\n-                                self.bccx.loan_path_to_str(\n+                                self.bccx.loan_path_to_string(\n                                     &*new_loan.loan_path)).as_slice());\n                 }\n                 _ => { }\n@@ -410,30 +410,30 @@ impl<'a> CheckLoanCtxt<'a> {\n                     format!(\"the mutable borrow prevents subsequent \\\n                             moves, borrows, or modification of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_str(\n+                            self.bccx.loan_path_to_string(\n                                 &*old_loan.loan_path))\n                 }\n \n                 ty::ImmBorrow => {\n                     format!(\"the immutable borrow prevents subsequent \\\n                             moves or mutable borrows of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n+                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n                 }\n \n                 ty::UniqueImmBorrow => {\n                     format!(\"the unique capture prevents subsequent \\\n                             moves or borrows of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n+                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n                 }\n             };\n \n             let borrow_summary = match old_loan.cause {\n                 euv::ClosureCapture(_) => {\n                     format!(\"previous borrow of `{}` occurs here due to \\\n                             use in closure\",\n-                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n+                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n                 }\n \n                 euv::OverloadedOperator(..) |\n@@ -442,7 +442,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 euv::ClosureInvocation(..) |\n                 euv::RefBinding(..) => {\n                     format!(\"previous borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n+                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n                 }\n             };\n \n@@ -518,12 +518,12 @@ impl<'a> CheckLoanCtxt<'a> {\n                 self.bccx.span_err(\n                     span,\n                     format!(\"cannot use `{}` because it was mutably borrowed\",\n-                            self.bccx.loan_path_to_str(copy_path).as_slice())\n+                            self.bccx.loan_path_to_string(copy_path).as_slice())\n                     .as_slice());\n                 self.bccx.span_note(\n                     loan_span,\n                     format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_str(&*loan_path).as_slice())\n+                            self.bccx.loan_path_to_string(&*loan_path).as_slice())\n                     .as_slice());\n             }\n         }\n@@ -543,19 +543,19 @@ impl<'a> CheckLoanCtxt<'a> {\n                 let err_message = match move_kind {\n                     move_data::Captured =>\n                         format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                self.bccx.loan_path_to_str(move_path).as_slice()),\n+                                self.bccx.loan_path_to_string(move_path).as_slice()),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n                         format!(\"cannot move out of `{}` because it is borrowed\",\n-                                self.bccx.loan_path_to_str(move_path).as_slice())\n+                                self.bccx.loan_path_to_string(move_path).as_slice())\n                 };\n \n                 self.bccx.span_err(span, err_message.as_slice());\n                 self.bccx.span_note(\n                     loan_span,\n                     format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_str(&*loan_path).as_slice())\n+                            self.bccx.loan_path_to_string(&*loan_path).as_slice())\n                     .as_slice());\n             }\n         }\n@@ -567,7 +567,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                                        borrow_kind: ty::BorrowKind)\n                                        -> UseError {\n         debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={})\",\n-               self.tcx().map.node_to_str(expr_id),\n+               self.tcx().map.node_to_string(expr_id),\n                use_path.repr(self.tcx()));\n \n         let mut ret = UseOk;\n@@ -690,15 +690,15 @@ impl<'a> CheckLoanCtxt<'a> {\n                     assignment_span,\n                     format!(\"cannot assign to {} {} `{}`\",\n                             assignee_cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_str(&*assignee_cmt),\n-                            self.bccx.loan_path_to_str(&*lp)).as_slice());\n+                            self.bccx.cmt_to_string(&*assignee_cmt),\n+                            self.bccx.loan_path_to_string(&*lp)).as_slice());\n             }\n             None => {\n                 self.bccx.span_err(\n                     assignment_span,\n                     format!(\"cannot assign to {} {}\",\n                             assignee_cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_str(&*assignee_cmt)).as_slice());\n+                            self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n             }\n         }\n         return;\n@@ -824,10 +824,10 @@ impl<'a> CheckLoanCtxt<'a> {\n         self.bccx.span_err(\n             span,\n             format!(\"cannot assign to `{}` because it is borrowed\",\n-                    self.bccx.loan_path_to_str(loan_path)).as_slice());\n+                    self.bccx.loan_path_to_string(loan_path)).as_slice());\n         self.bccx.span_note(\n             loan.span,\n             format!(\"borrow of `{}` occurs here\",\n-                    self.bccx.loan_path_to_str(loan_path)).as_slice());\n+                    self.bccx.loan_path_to_string(loan_path)).as_slice());\n     }\n }"}, {"sha": "9876e12d5ccac539efb1d03ff7ba34ae4ad00cb8", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -120,7 +120,7 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n             bccx.span_err(\n                 move_from.span,\n                 format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_str(&*move_from)).as_slice());\n+                        bccx.cmt_to_string(&*move_from)).as_slice());\n         }\n \n         mc::cat_downcast(ref b) |\n@@ -145,7 +145,7 @@ fn note_move_destination(bccx: &BorrowckCtxt,\n                          move_to_span: codemap::Span,\n                          pat_ident: &ast::Ident,\n                          is_first_note: bool) {\n-    let pat_name = pprust::ident_to_str(pat_ident);\n+    let pat_name = pprust::ident_to_string(pat_ident);\n     if is_first_note {\n         bccx.span_note(\n             move_to_span,"}, {"sha": "426a1fbede56b7fb9dca84c9f5e033e7fc9b95df", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -418,7 +418,7 @@ impl<'a> BorrowckCtxt<'a> {\n     pub fn report(&self, err: BckError) {\n         self.span_err(\n             err.span,\n-            self.bckerr_to_str(&err).as_slice());\n+            self.bckerr_to_string(&err).as_slice());\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -439,7 +439,7 @@ impl<'a> BorrowckCtxt<'a> {\n                     use_span,\n                     format!(\"{} of possibly uninitialized variable: `{}`\",\n                             verb,\n-                            self.loan_path_to_str(lp)).as_slice());\n+                            self.loan_path_to_string(lp)).as_slice());\n             }\n             _ => {\n                 let partially = if lp == moved_lp {\"\"} else {\"partially \"};\n@@ -448,7 +448,7 @@ impl<'a> BorrowckCtxt<'a> {\n                     format!(\"{} of {}moved value: `{}`\",\n                             verb,\n                             partially,\n-                            self.loan_path_to_str(lp)).as_slice());\n+                            self.loan_path_to_string(lp)).as_slice());\n             }\n         }\n \n@@ -472,7 +472,7 @@ impl<'a> BorrowckCtxt<'a> {\n                 self.tcx.sess.span_note(\n                     expr_span,\n                     format!(\"`{}` moved here because it has type `{}`, which is {}\",\n-                            self.loan_path_to_str(moved_lp),\n+                            self.loan_path_to_string(moved_lp),\n                             expr_ty.user_string(self.tcx),\n                             suggestion).as_slice());\n             }\n@@ -483,7 +483,7 @@ impl<'a> BorrowckCtxt<'a> {\n                     format!(\"`{}` moved here because it has type `{}`, \\\n                              which is moved by default (use `ref` to \\\n                              override)\",\n-                            self.loan_path_to_str(moved_lp),\n+                            self.loan_path_to_string(moved_lp),\n                             pat_ty.user_string(self.tcx)).as_slice());\n             }\n \n@@ -506,7 +506,7 @@ impl<'a> BorrowckCtxt<'a> {\n                     expr_span,\n                     format!(\"`{}` moved into closure environment here because it \\\n                             has type `{}`, which is {}\",\n-                            self.loan_path_to_str(moved_lp),\n+                            self.loan_path_to_string(moved_lp),\n                             expr_ty.user_string(self.tcx),\n                             suggestion).as_slice());\n             }\n@@ -536,7 +536,7 @@ impl<'a> BorrowckCtxt<'a> {\n         self.tcx.sess.span_err(\n             span,\n             format!(\"re-assignment of immutable variable `{}`\",\n-                    self.loan_path_to_str(lp)).as_slice());\n+                    self.loan_path_to_string(lp)).as_slice());\n         self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n     }\n \n@@ -552,20 +552,20 @@ impl<'a> BorrowckCtxt<'a> {\n         self.tcx.sess.span_end_note(s, m);\n     }\n \n-    pub fn bckerr_to_str(&self, err: &BckError) -> String {\n+    pub fn bckerr_to_string(&self, err: &BckError) -> String {\n         match err.code {\n             err_mutbl => {\n                 let descr = match opt_loan_path(&err.cmt) {\n                     None => {\n                         format!(\"{} {}\",\n                                 err.cmt.mutbl.to_user_str(),\n-                                self.cmt_to_str(&*err.cmt))\n+                                self.cmt_to_string(&*err.cmt))\n                     }\n                     Some(lp) => {\n                         format!(\"{} {} `{}`\",\n                                 err.cmt.mutbl.to_user_str(),\n-                                self.cmt_to_str(&*err.cmt),\n-                                self.loan_path_to_str(&*lp))\n+                                self.cmt_to_string(&*err.cmt),\n+                                self.loan_path_to_string(&*lp))\n                     }\n                 };\n \n@@ -589,17 +589,17 @@ impl<'a> BorrowckCtxt<'a> {\n                 let msg = match opt_loan_path(&err.cmt) {\n                     None => \"borrowed value\".to_string(),\n                     Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_str(&*lp))\n+                        format!(\"`{}`\", self.loan_path_to_string(&*lp))\n                     }\n                 };\n                 format!(\"{} does not live long enough\", msg)\n             }\n             err_borrowed_pointer_too_short(..) => {\n                 let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_str(&*lp))\n+                        format!(\"`{}`\", self.loan_path_to_string(&*lp))\n                     }\n-                    None => self.cmt_to_str(&*err.cmt),\n+                    None => self.cmt_to_string(&*err.cmt),\n                 };\n \n                 format!(\"lifetime of {} is too short to guarantee \\\n@@ -691,9 +691,9 @@ impl<'a> BorrowckCtxt<'a> {\n             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n                 let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_str(&*lp))\n+                        format!(\"`{}`\", self.loan_path_to_string(&*lp))\n                     }\n-                    None => self.cmt_to_str(&*err.cmt),\n+                    None => self.cmt_to_string(&*err.cmt),\n                 };\n                 note_and_explain_region(\n                     self.tcx,\n@@ -710,7 +710,7 @@ impl<'a> BorrowckCtxt<'a> {\n         }\n     }\n \n-    pub fn append_loan_path_to_str(&self,\n+    pub fn append_loan_path_to_string(&self,\n                                    loan_path: &LoanPath,\n                                    out: &mut String) {\n         match *loan_path {\n@@ -720,56 +720,56 @@ impl<'a> BorrowckCtxt<'a> {\n             }\n \n             LpExtend(ref lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n-                self.append_autoderefd_loan_path_to_str(&**lp_base, out);\n+                self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 match fname {\n                     mc::NamedField(fname) => {\n                         out.push_char('.');\n                         out.push_str(token::get_name(fname).get());\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push_char('#'); // invent a notation here\n-                        out.push_str(idx.to_str().as_slice());\n+                        out.push_str(idx.to_string().as_slice());\n                     }\n                 }\n             }\n \n             LpExtend(ref lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n-                self.append_autoderefd_loan_path_to_str(&**lp_base, out);\n+                self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push_str(\"[..]\");\n             }\n \n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 out.push_char('*');\n-                self.append_loan_path_to_str(&**lp_base, out);\n+                self.append_loan_path_to_string(&**lp_base, out);\n             }\n         }\n     }\n \n-    pub fn append_autoderefd_loan_path_to_str(&self,\n+    pub fn append_autoderefd_loan_path_to_string(&self,\n                                               loan_path: &LoanPath,\n                                               out: &mut String) {\n         match *loan_path {\n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 // For a path like `(*x).f` or `(*x)[3]`, autoderef\n                 // rules would normally allow users to omit the `*x`.\n                 // So just serialize such paths to `x.f` or x[3]` respectively.\n-                self.append_autoderefd_loan_path_to_str(&**lp_base, out)\n+                self.append_autoderefd_loan_path_to_string(&**lp_base, out)\n             }\n \n             LpVar(..) | LpUpvar(..) | LpExtend(_, _, LpInterior(..)) => {\n-                self.append_loan_path_to_str(loan_path, out)\n+                self.append_loan_path_to_string(loan_path, out)\n             }\n         }\n     }\n \n-    pub fn loan_path_to_str(&self, loan_path: &LoanPath) -> String {\n+    pub fn loan_path_to_string(&self, loan_path: &LoanPath) -> String {\n         let mut result = String::new();\n-        self.append_loan_path_to_str(loan_path, &mut result);\n+        self.append_loan_path_to_string(loan_path, &mut result);\n         result\n     }\n \n-    pub fn cmt_to_str(&self, cmt: &mc::cmt_) -> String {\n-        self.mc().cmt_to_str(cmt)\n+    pub fn cmt_to_string(&self, cmt: &mc::cmt_) -> String {\n+        self.mc().cmt_to_string(cmt)\n     }\n }\n \n@@ -815,11 +815,11 @@ impl Repr for LoanPath {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match self {\n             &LpVar(id) => {\n-                format!(\"$({})\", tcx.map.node_to_str(id))\n+                format!(\"$({})\", tcx.map.node_to_string(id))\n             }\n \n             &LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n-                let s = tcx.map.node_to_str(var_id);\n+                let s = tcx.map.node_to_string(var_id);\n                 format!(\"$({} captured by id={})\", s, closure_expr_id)\n             }\n "}, {"sha": "9f44f0babc72abfaae37bf70e1133627ee020df8", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -64,7 +64,7 @@ impl<'a> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a> {\n         } else if n.data.id == ast::DUMMY_NODE_ID {\n             dot::LabelStr(\"(dummy_node)\".into_maybe_owned())\n         } else {\n-            let s = self.ast_map.node_to_str(n.data.id);\n+            let s = self.ast_map.node_to_string(n.data.id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n             dot::EscStr(s.into_maybe_owned())\n@@ -80,7 +80,7 @@ impl<'a> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a> {\n             } else {\n                 put_one = true;\n             }\n-            let s = self.ast_map.node_to_str(node_id);\n+            let s = self.ast_map.node_to_string(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n             label = label.append(format!(\"exiting scope_{} {}\","}, {"sha": "33bf6ceed4f2b848d9811072495d8b0d0dd47dad", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -108,7 +108,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n                  .span_err(e.span,\n                            format!(\"can not cast to `{}` in a constant \\\n                                     expression\",\n-                                   ppaux::ty_to_str(v.tcx, ety)).as_slice())\n+                                   ppaux::ty_to_string(v.tcx, ety)).as_slice())\n             }\n           }\n           ExprPath(ref pth) => {"}, {"sha": "599f5f4024f28ab2d98c3a29156790f22a7a5e80", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -22,10 +22,10 @@ use syntax::ast::*;\n use syntax::ast_util::{is_unguarded, walk_pat};\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use syntax::owned_slice::OwnedSlice;\n-use syntax::print::pprust::pat_to_str;\n+use syntax::print::pprust::pat_to_string;\n use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n-use util::ppaux::ty_to_str;\n+use util::ppaux::ty_to_string;\n \n struct Matrix(Vec<Vec<Gc<Pat>>>);\n \n@@ -47,7 +47,7 @@ impl fmt::Show for Matrix {\n \n         let &Matrix(ref m) = self;\n         let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n-            row.iter().map(|&pat| pat_to_str(pat)).collect::<Vec<String>>()\n+            row.iter().map(|&pat| pat_to_string(pat)).collect::<Vec<String>>()\n         }).collect();\n \n         let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0u);\n@@ -147,7 +147,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                    // We know the type is inhabited, so this must be wrong\n                    cx.tcx.sess.span_err(ex.span, format!(\"non-exhaustive patterns: \\\n                                 type {} is non-empty\",\n-                                ty_to_str(cx.tcx, pat_ty)).as_slice());\n+                                ty_to_string(cx.tcx, pat_ty)).as_slice());\n                }\n                // If the type *is* empty, it's vacuously exhaustive\n                return;\n@@ -222,7 +222,8 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n                 [] => wild(),\n                 _ => unreachable!()\n             };\n-            let msg = format!(\"non-exhaustive patterns: `{0}` not covered\", pat_to_str(&*witness));\n+            let msg = format!(\"non-exhaustive patterns: `{0}` not covered\",\n+                              pat_to_string(&*witness));\n             cx.tcx.sess.span_err(sp, msg.as_slice());\n         }\n         NotUseful => {\n@@ -780,7 +781,7 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n         Some(pat) => {\n             let msg = format!(\n                 \"refutable pattern in {} binding: `{}` not covered\",\n-                name, pat_to_str(&*pat)\n+                name, pat_to_string(&*pat)\n             );\n             cx.tcx.sess.span_err(loc.pat.span, msg.as_slice());\n         },\n@@ -802,7 +803,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             Some(pat) => {\n                 let msg = format!(\n                     \"refutable pattern in function argument: `{}` not covered\",\n-                    pat_to_str(&*pat)\n+                    pat_to_string(&*pat)\n                 );\n                 cx.tcx.sess.span_err(input.pat.span, msg.as_slice());\n             },"}, {"sha": "1e948afb7018fe745ffc05f1e5db7dc33291e65d", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -75,7 +75,7 @@ impl<'a> CheckStaticVisitor<'a> {\n impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n \n     fn visit_item(&mut self, i: &ast::Item, _is_const: bool) {\n-        debug!(\"visit_item(item={})\", pprust::item_to_str(i));\n+        debug!(\"visit_item(item={})\", pprust::item_to_string(i));\n         match i.node {\n             ast::ItemStatic(_, mutability, ref expr) => {\n                 match mutability {\n@@ -99,7 +99,7 @@ impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n     /// of a static item, this method does nothing but walking\n     /// down through it.\n     fn visit_expr(&mut self, e: &ast::Expr, is_const: bool) {\n-        debug!(\"visit_expr(expr={})\", pprust::expr_to_str(e));\n+        debug!(\"visit_expr(expr={})\", pprust::expr_to_string(e));\n \n         if !is_const {\n             return visit::walk_expr(self, e, is_const);"}, {"sha": "7d9178162a65adb11de93f371623b028d93cda68", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -164,18 +164,18 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n             let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n             let (start, end) = self.compute_id_range_frozen(cfgidx);\n             let on_entry = self.on_entry.slice(start, end);\n-            let entry_str = bits_to_str(on_entry);\n+            let entry_str = bits_to_string(on_entry);\n \n             let gens = self.gens.slice(start, end);\n             let gens_str = if gens.iter().any(|&u| u != 0) {\n-                format!(\" gen: {}\", bits_to_str(gens))\n+                format!(\" gen: {}\", bits_to_string(gens))\n             } else {\n                 \"\".to_string()\n             };\n \n             let kills = self.kills.slice(start, end);\n             let kills_str = if kills.iter().any(|&u| u != 0) {\n-                format!(\" kill: {}\", bits_to_str(kills))\n+                format!(\" kill: {}\", bits_to_string(kills))\n             } else {\n                 \"\".to_string()\n             };\n@@ -289,15 +289,15 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n     fn apply_gen_kill(&mut self, cfgidx: CFGIndex, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `id` to `bits`\n         debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n-               self.analysis_name, cfgidx, mut_bits_to_str(bits));\n+               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n         let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.slice(start, end);\n         bitwise(bits, gens, &Union);\n         let kills = self.kills.slice(start, end);\n         bitwise(bits, kills, &Subtract);\n \n         debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [after]\",\n-               self.analysis_name, cfgidx, mut_bits_to_str(bits));\n+               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n     }\n \n     fn compute_id_range_frozen(&self, cfgidx: CFGIndex) -> (uint, uint) {\n@@ -334,7 +334,7 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         let (start, end) = self.compute_id_range_frozen(cfgidx);\n         let on_entry = self.on_entry.slice(start, end);\n         debug!(\"{:s} each_bit_on_entry_frozen(id={:?}, on_entry={})\",\n-               self.analysis_name, id, bits_to_str(on_entry));\n+               self.analysis_name, id, bits_to_string(on_entry));\n         self.each_bit(on_entry, f)\n     }\n \n@@ -348,7 +348,7 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         let (start, end) = self.compute_id_range_frozen(cfgidx);\n         let gens = self.gens.slice(start, end);\n         debug!(\"{:s} each_gen_bit(id={:?}, gens={})\",\n-               self.analysis_name, id, bits_to_str(gens));\n+               self.analysis_name, id, bits_to_string(gens));\n         self.each_bit(gens, f)\n     }\n \n@@ -426,10 +426,10 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n             if changed {\n                 let bits = self.kills.mut_slice(start, end);\n                 debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n-                       self.analysis_name, flow_exit, mut_bits_to_str(bits));\n+                       self.analysis_name, flow_exit, mut_bits_to_string(bits));\n                 bits.copy_from(orig_kills.as_slice());\n                 debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n-                       self.analysis_name, flow_exit, mut_bits_to_str(bits));\n+                       self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }\n             true\n         });\n@@ -483,10 +483,10 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 cfg: &cfg::CFG,\n                 in_out: &mut [uint]) {\n         debug!(\"DataFlowContext::walk_cfg(in_out={}) {:s}\",\n-               bits_to_str(in_out), self.dfcx.analysis_name);\n+               bits_to_string(in_out), self.dfcx.analysis_name);\n         cfg.graph.each_node(|node_index, node| {\n             debug!(\"DataFlowContext::walk_cfg idx={} id={} begin in_out={}\",\n-                   node_index, node.data.id, bits_to_str(in_out));\n+                   node_index, node.data.id, bits_to_string(in_out));\n \n             let (start, end) = self.dfcx.compute_id_range(node_index);\n \n@@ -526,7 +526,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n         let source = edge.source();\n         let cfgidx = edge.target();\n         debug!(\"{:s} propagate_bits_into_entry_set_for(pred_bits={}, {} to {})\",\n-               self.dfcx.analysis_name, bits_to_str(pred_bits), source, cfgidx);\n+               self.dfcx.analysis_name, bits_to_string(pred_bits), source, cfgidx);\n         let (start, end) = self.dfcx.compute_id_range(cfgidx);\n         let changed = {\n             // (scoping mutable borrow of self.dfcx.on_entry)\n@@ -536,17 +536,17 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n         if changed {\n             debug!(\"{:s} changed entry set for {:?} to {}\",\n                    self.dfcx.analysis_name, cfgidx,\n-                   bits_to_str(self.dfcx.on_entry.slice(start, end)));\n+                   bits_to_string(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;\n         }\n     }\n }\n \n-fn mut_bits_to_str(words: &mut [uint]) -> String {\n-    bits_to_str(words)\n+fn mut_bits_to_string(words: &mut [uint]) -> String {\n+    bits_to_string(words)\n }\n \n-fn bits_to_str(words: &[uint]) -> String {\n+fn bits_to_string(words: &[uint]) -> String {\n     let mut result = String::new();\n     let mut sep = '[';\n \n@@ -582,7 +582,7 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],\n \n fn set_bit(words: &mut [uint], bit: uint) -> bool {\n     debug!(\"set_bit: words={} bit={}\",\n-           mut_bits_to_str(words), bit_str(bit));\n+           mut_bits_to_string(words), bit_str(bit));\n     let word = bit / uint::BITS;\n     let bit_in_word = bit % uint::BITS;\n     let bit_mask = 1 << bit_in_word;"}, {"sha": "782a380e23a0ecdd3aa98e2f5cbb1adf858d941d", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -68,7 +68,7 @@ impl<'a> EffectCheckVisitor<'a> {\n             _ => return\n         };\n         debug!(\"effect: checking index with base type {}\",\n-                ppaux::ty_to_str(self.tcx, base_type));\n+                ppaux::ty_to_string(self.tcx, base_type));\n         match ty::get(base_type).sty {\n             ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n                 ty::ty_str => {\n@@ -147,7 +147,7 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n                 let method_call = MethodCall::expr(expr.id);\n                 let base_type = self.tcx.method_map.borrow().get(&method_call).ty;\n                 debug!(\"effect: method call case, base type is {}\",\n-                       ppaux::ty_to_str(self.tcx, base_type));\n+                       ppaux::ty_to_string(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span,\n                                         \"invocation of unsafe method\")\n@@ -156,15 +156,15 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n             ast::ExprCall(base, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: call case, base type is {}\",\n-                       ppaux::ty_to_str(self.tcx, base_type));\n+                       ppaux::ty_to_string(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             ast::ExprUnary(ast::UnDeref, base) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: unary case, base type is {}\",\n-                        ppaux::ty_to_str(self.tcx, base_type));\n+                        ppaux::ty_to_string(self.tcx, base_type));\n                 match ty::get(base_type).sty {\n                     ty::ty_ptr(_) => {\n                         self.require_unsafe(expr.span,"}, {"sha": "d432ced5226cee32781cfffea24c12d9eedfa8d8", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -15,13 +15,13 @@ use middle::subst;\n use middle::ty;\n use middle::typeck::{MethodCall, NoAdjustment};\n use middle::typeck;\n-use util::ppaux::{Repr, ty_to_str};\n+use util::ppaux::{Repr, ty_to_string};\n use util::ppaux::UserString;\n \n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::print::pprust::{expr_to_str, ident_to_str};\n+use syntax::print::pprust::{expr_to_string, ident_to_string};\n use syntax::{visit};\n use syntax::visit::Visitor;\n \n@@ -126,7 +126,7 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n         cx.tcx.sess.span_err(self_type.span,\n             format!(\"the type `{}', which does not fulfill `{}`, cannot implement this \\\n                     trait\",\n-                    ty_to_str(cx.tcx, self_ty),\n+                    ty_to_string(cx.tcx, self_ty),\n                     missing.user_string(cx.tcx)).as_slice());\n         cx.tcx.sess.span_note(self_type.span,\n             format!(\"types implementing this trait must fulfill `{}`\",\n@@ -246,7 +246,7 @@ fn check_fn(\n }\n \n pub fn check_expr(cx: &mut Context, e: &Expr) {\n-    debug!(\"kind::check_expr({})\", expr_to_str(e));\n+    debug!(\"kind::check_expr({})\", expr_to_string(e));\n \n     // Handle any kind bounds on type parameters\n     check_bounds_on_type_parameters(cx, e);\n@@ -492,7 +492,7 @@ pub fn check_typaram_bounds(cx: &Context,\n             sp,\n             format!(\"instantiating a type parameter with an incompatible type \\\n                      `{}`, which does not fulfill `{}`\",\n-                    ty_to_str(cx.tcx, ty),\n+                    ty_to_string(cx.tcx, ty),\n                     missing.user_string(cx.tcx)).as_slice());\n     });\n }\n@@ -509,14 +509,14 @@ pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n                 format!(\"cannot implicitly borrow variable of type `{}` in a \\\n                          bounded stack closure (implicit reference does not \\\n                          fulfill `{}`)\",\n-                        ty_to_str(cx.tcx, rty),\n+                        ty_to_string(cx.tcx, rty),\n                         missing.user_string(cx.tcx)).as_slice())\n             }\n             None => {\n                 cx.tcx.sess.span_err(sp,\n                 format!(\"cannot capture variable of type `{}`, which does \\\n                          not fulfill `{}`, in a bounded closure\",\n-                        ty_to_str(cx.tcx, ty),\n+                        ty_to_string(cx.tcx, ty),\n                         missing.user_string(cx.tcx)).as_slice())\n             }\n         }\n@@ -533,20 +533,20 @@ pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n         cx.tcx.sess.span_err(sp,\n             format!(\"cannot pack type `{}`, which does not fulfill \\\n                      `{}`, as a trait bounded by {}\",\n-                    ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx),\n+                    ty_to_string(cx.tcx, ty), missing.user_string(cx.tcx),\n                     bounds.user_string(cx.tcx)).as_slice());\n     });\n }\n \n fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n     debug!(\"type_contents({})={}\",\n-           ty_to_str(cx.tcx, ty),\n-           ty::type_contents(cx.tcx, ty).to_str());\n+           ty_to_string(cx.tcx, ty),\n+           ty::type_contents(cx.tcx, ty).to_string());\n     if ty::type_moves_by_default(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n             sp,\n             format!(\"copying a value of non-copyable type `{}`\",\n-                    ty_to_str(cx.tcx, ty)).as_slice());\n+                    ty_to_string(cx.tcx, ty)).as_slice());\n         cx.tcx.sess.span_note(sp, format!(\"{}\", reason).as_slice());\n     }\n }\n@@ -558,7 +558,7 @@ pub fn check_static(tcx: &ty::ctxt, ty: ty::t, sp: Span) -> bool {\n             tcx.sess.span_err(sp,\n                 format!(\"value may contain references; \\\n                          add `'static` bound to `{}`\",\n-                        ty_to_str(tcx, ty)).as_slice());\n+                        ty_to_string(tcx, ty)).as_slice());\n           }\n           _ => {\n             tcx.sess.span_err(sp, \"value may contain references\");\n@@ -643,7 +643,7 @@ pub fn check_cast_for_escaping_regions(\n             //         source_span,\n             //         format!(\"source contains reference with lifetime \\\n             //               not found in the target type `{}`\",\n-            //              ty_to_str(cx.tcx, target_ty)));\n+            //              ty_to_string(cx.tcx, target_ty)));\n             //     note_and_explain_region(\n             //         cx.tcx, \"source data is only valid for \", r, \"\");\n             // }\n@@ -683,15 +683,15 @@ fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: String, sp: Span) {\n                           format!(\"variable `{}` has dynamically sized type \\\n                                    `{}`\",\n                                   name,\n-                                  ty_to_str(tcx, ty)).as_slice());\n+                                  ty_to_string(tcx, ty)).as_slice());\n     }\n }\n \n // Check that any variables in a pattern have types with statically known size.\n fn check_pat(cx: &mut Context, pat: &Pat) {\n     let var_name = match pat.node {\n         PatWild => Some(\"_\".to_string()),\n-        PatIdent(_, ref path1, _) => Some(ident_to_str(&path1.node).to_string()),\n+        PatIdent(_, ref path1, _) => Some(ident_to_string(&path1.node).to_string()),\n         _ => None\n     };\n \n@@ -702,7 +702,7 @@ fn check_pat(cx: &mut Context, pat: &Pat) {\n             match ty {\n                 Some(ty) => {\n                     debug!(\"kind: checking sized-ness of variable {}: {}\",\n-                           name, ty_to_str(cx.tcx, *ty));\n+                           name, ty_to_string(cx.tcx, *ty));\n                     check_sized(cx.tcx, *ty, name, pat.span);\n                 }\n                 None => {} // extern fn args"}, {"sha": "79742d3173434cd5bafcef3173eccbbbc4f80d5c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -121,7 +121,7 @@ use syntax::ast::*;\n use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n-use syntax::print::pprust::{expr_to_str, block_to_str};\n+use syntax::print::pprust::{expr_to_string, block_to_string};\n use syntax::{visit, ast_util};\n use syntax::visit::{Visitor, FnKind};\n \n@@ -152,17 +152,17 @@ enum LiveNodeKind {\n     ExitNode\n }\n \n-fn live_node_kind_to_str(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n+fn live_node_kind_to_string(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n     let cm = cx.sess.codemap();\n     match lnk {\n         FreeVarNode(s) => {\n-            format!(\"Free var node [{}]\", cm.span_to_str(s))\n+            format!(\"Free var node [{}]\", cm.span_to_string(s))\n         }\n         ExprNode(s) => {\n-            format!(\"Expr node [{}]\", cm.span_to_str(s))\n+            format!(\"Expr node [{}]\", cm.span_to_string(s))\n         }\n         VarDefNode(s) => {\n-            format!(\"Var def node [{}]\", cm.span_to_str(s))\n+            format!(\"Var def node [{}]\", cm.span_to_string(s))\n         }\n         ExitNode => \"Exit node\".to_string(),\n     }\n@@ -272,8 +272,8 @@ impl<'a> IrMaps<'a> {\n         self.lnks.push(lnk);\n         self.num_live_nodes += 1;\n \n-        debug!(\"{} is of kind {}\", ln.to_str(),\n-               live_node_kind_to_str(lnk, self.tcx));\n+        debug!(\"{} is of kind {}\", ln.to_string(),\n+               live_node_kind_to_string(lnk, self.tcx));\n \n         ln\n     }\n@@ -282,7 +282,7 @@ impl<'a> IrMaps<'a> {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n \n-        debug!(\"{} is node {}\", ln.to_str(), node_id);\n+        debug!(\"{} is node {}\", ln.to_string(), node_id);\n     }\n \n     fn add_variable(&mut self, vk: VarKind) -> Variable {\n@@ -297,7 +297,7 @@ impl<'a> IrMaps<'a> {\n             ImplicitRet => {}\n         }\n \n-        debug!(\"{} is {:?}\", v.to_str(), vk);\n+        debug!(\"{} is {:?}\", v.to_string(), vk);\n \n         v\n     }\n@@ -317,7 +317,7 @@ impl<'a> IrMaps<'a> {\n     fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds.get(var.get()) {\n             &Local(LocalInfo { ident: nm, .. }) | &Arg(_, nm) => {\n-                token::get_ident(nm).get().to_str()\n+                token::get_ident(nm).get().to_string()\n             },\n             &ImplicitRet => \"<implicit-ret>\".to_string()\n         }\n@@ -675,7 +675,7 @@ impl<'a> Liveness<'a> {\n         for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n-                try!(write!(wr, \" {}\", Variable(var_idx).to_str()));\n+                try!(write!(wr, \" {}\", Variable(var_idx).to_string()));\n             }\n         }\n         Ok(())\n@@ -717,7 +717,7 @@ impl<'a> Liveness<'a> {\n             self.write_vars(wr, ln, |idx| self.users.get(idx).reader);\n             write!(wr, \"  writes\");\n             self.write_vars(wr, ln, |idx| self.users.get(idx).writer);\n-            write!(wr, \"  precedes {}]\", self.successors.get(ln.get()).to_str());\n+            write!(wr, \"  precedes {}]\", self.successors.get(ln.get()).to_string());\n         }\n         str::from_utf8(wr.unwrap().as_slice()).unwrap().to_string()\n     }\n@@ -766,7 +766,7 @@ impl<'a> Liveness<'a> {\n         });\n \n         debug!(\"merge_from_succ(ln={}, succ={}, first_merge={}, changed={})\",\n-               ln.to_str(), self.ln_str(succ_ln), first_merge, changed);\n+               ln.to_string(), self.ln_str(succ_ln), first_merge, changed);\n         return changed;\n \n         fn copy_if_invalid(src: LiveNode, dst: &mut LiveNode) -> bool {\n@@ -787,14 +787,14 @@ impl<'a> Liveness<'a> {\n         self.users.get_mut(idx).reader = invalid_node();\n         self.users.get_mut(idx).writer = invalid_node();\n \n-        debug!(\"{} defines {} (idx={}): {}\", writer.to_str(), var.to_str(),\n+        debug!(\"{} defines {} (idx={}): {}\", writer.to_string(), var.to_string(),\n                idx, self.ln_str(writer));\n     }\n \n     // Either read, write, or both depending on the acc bitset\n     fn acc(&mut self, ln: LiveNode, var: Variable, acc: uint) {\n         debug!(\"{} accesses[{:x}] {}: {}\",\n-               ln.to_str(), acc, var.to_str(), self.ln_str(ln));\n+               ln.to_string(), acc, var.to_string(), self.ln_str(ln));\n \n         let idx = self.idx(ln, var);\n         let user = self.users.get_mut(idx);\n@@ -822,7 +822,7 @@ impl<'a> Liveness<'a> {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for block, {}\", block_to_str(body));\n+        debug!(\"compute: using id for block, {}\", block_to_string(body));\n \n         let exit_ln = self.s.exit_ln;\n         let entry_ln: LiveNode =\n@@ -837,7 +837,7 @@ impl<'a> Liveness<'a> {\n                    }\n                    body.id\n                },\n-               entry_ln.to_str());\n+               entry_ln.to_string());\n \n         entry_ln\n     }\n@@ -928,7 +928,7 @@ impl<'a> Liveness<'a> {\n \n     fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n                               -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\", expr_to_str(expr));\n+        debug!(\"propagate_through_expr: {}\", expr_to_string(expr));\n \n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n@@ -942,7 +942,7 @@ impl<'a> Liveness<'a> {\n           }\n \n           ExprFnBlock(_, ref blk) | ExprProc(_, ref blk) => {\n-              debug!(\"{} is an ExprFnBlock or ExprProc\", expr_to_str(expr));\n+              debug!(\"{} is an ExprFnBlock or ExprProc\", expr_to_string(expr));\n \n               /*\n               The next-node for a break is the successor of the entire\n@@ -1314,7 +1314,7 @@ impl<'a> Liveness<'a> {\n             first_merge = false;\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n-               expr.id, block_to_str(body));\n+               expr.id, block_to_string(body));\n \n         let cond_ln = self.propagate_through_opt_expr(cond, ln);\n         let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {"}, {"sha": "33ab2ed3632405adaa0fa90286535f4ae84cb4fa", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -66,7 +66,7 @@ use middle::def;\n use middle::ty;\n use middle::typeck;\n use util::nodemap::NodeMap;\n-use util::ppaux::{ty_to_str, Repr};\n+use util::ppaux::{ty_to_string, Repr};\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n@@ -217,7 +217,7 @@ pub fn deref_kind(tcx: &ty::ctxt, t: ty::t) -> deref_kind {\n       None => {\n         tcx.sess.bug(\n             format!(\"deref_cat() invoked on non-derefable type {}\",\n-                    ty_to_str(tcx, t)).as_slice());\n+                    ty_to_string(tcx, t)).as_slice());\n       }\n     }\n }\n@@ -980,7 +980,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         // get the type of the *subpattern* and use that.\n \n         debug!(\"cat_pattern: id={} pat={} cmt={}\",\n-               pat.id, pprust::pat_to_str(pat),\n+               pat.id, pprust::pat_to_string(pat),\n                cmt.repr(self.tcx()));\n \n         op(self, cmt.clone(), pat);\n@@ -1105,7 +1105,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         Ok(())\n     }\n \n-    pub fn cmt_to_str(&self, cmt: &cmt_) -> String {\n+    pub fn cmt_to_string(&self, cmt: &cmt_) -> String {\n         match cmt.cat {\n           cat_static_item => {\n               \"static item\".to_string()\n@@ -1151,10 +1151,10 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n               \"captured outer variable\".to_string()\n           }\n           cat_discr(ref cmt, _) => {\n-            self.cmt_to_str(&**cmt)\n+            self.cmt_to_string(&**cmt)\n           }\n           cat_downcast(ref cmt) => {\n-            self.cmt_to_str(&**cmt)\n+            self.cmt_to_string(&**cmt)\n           }\n         }\n     }\n@@ -1311,7 +1311,7 @@ impl Repr for InteriorKind {\n     fn repr(&self, _tcx: &ty::ctxt) -> String {\n         match *self {\n             InteriorField(NamedField(fld)) => {\n-                token::get_name(fld).get().to_str()\n+                token::get_name(fld).get().to_string()\n             }\n             InteriorField(PositionalField(i)) => format!(\"#{:?}\", i),\n             InteriorElement(_) => \"[]\".to_string(),"}, {"sha": "7630321bd559b0bbc5cd4b8b3b57e21e88bfa6db", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -375,7 +375,7 @@ enum FieldName {\n impl<'a> PrivacyVisitor<'a> {\n     // used when debugging\n     fn nodestr(&self, id: ast::NodeId) -> String {\n-        self.tcx.map.node_to_str(id).to_string()\n+        self.tcx.map.node_to_string(id).to_string()\n     }\n \n     // Determines whether the given definition is public from the point of view\n@@ -423,7 +423,7 @@ impl<'a> PrivacyVisitor<'a> {\n         }\n \n         debug!(\"privacy - local {} not public all the way down\",\n-               self.tcx.map.node_to_str(did.node));\n+               self.tcx.map.node_to_string(did.node));\n         // return quickly for things in the same module\n         if self.parents.find(&did.node) == self.parents.find(&self.curitem) {\n             debug!(\"privacy - same parent, we're done here\");"}, {"sha": "26bb0b62cb05fbb1b8869c1bf4e34ad8057b3ba8", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -336,7 +336,7 @@ impl<'a> ReachableContext<'a> {\n                     .bug(format!(\"found unexpected thingy in worklist: {}\",\n                                  self.tcx\n                                      .map\n-                                     .node_to_str(search_item)).as_slice())\n+                                     .node_to_string(search_item)).as_slice())\n             }\n         }\n     }"}, {"sha": "df4d3b7efe432ea6ffada1db2c3bac9569f4bc8e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -821,7 +821,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n                                body.id={}, \\\n                                cx.parent={})\",\n            id,\n-           visitor.sess.codemap().span_to_str(sp),\n+           visitor.sess.codemap().span_to_string(sp),\n            body.id,\n            cx.parent);\n "}, {"sha": "8d1fc3cad07039f34cead17079f4d3e96d24a7cb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -790,7 +790,7 @@ impl PrimitiveTypeTable {\n }\n \n \n-fn namespace_error_to_str(ns: NamespaceError) -> &'static str {\n+fn namespace_error_to_string(ns: NamespaceError) -> &'static str {\n     match ns {\n         NoError                 => \"\",\n         ModuleError | TypeError => \"type or module\",\n@@ -1071,14 +1071,14 @@ impl<'a> Resolver<'a> {\n                     let ns = ns.unwrap();\n                     self.resolve_error(sp,\n                         format!(\"duplicate definition of {} `{}`\",\n-                             namespace_error_to_str(duplicate_type),\n+                             namespace_error_to_string(duplicate_type),\n                              token::get_ident(name)).as_slice());\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n                                  format!(\"first definition of {} `{}` here\",\n-                                      namespace_error_to_str(duplicate_type),\n+                                      namespace_error_to_string(duplicate_type),\n                                       token::get_ident(name)).as_slice());\n                         }\n                     }\n@@ -1508,7 +1508,7 @@ impl<'a> Resolver<'a> {\n                                                               false,\n                                                               true));\n                     debug!(\"(build reduced graph for item) found extern `{}`\",\n-                            self.module_to_str(&*external_module));\n+                            self.module_to_string(&*external_module));\n                     parent.module().external_module_children.borrow_mut()\n                                    .insert(name.name, external_module.clone());\n                     self.build_reduced_graph_for_external_crate(external_module);\n@@ -1862,7 +1862,7 @@ impl<'a> Resolver<'a> {\n     /// Builds the reduced graph rooted at the given external module.\n     fn populate_external_module(&mut self, module: Rc<Module>) {\n         debug!(\"(populating external module) attempting to populate {}\",\n-               self.module_to_str(&*module));\n+               self.module_to_string(&*module));\n \n         let def_id = match module.def_id.get() {\n             None => {\n@@ -1930,7 +1930,7 @@ impl<'a> Resolver<'a> {\n             SingleImport(target, _) => {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n-                       self.idents_to_str(module_.imports.borrow().last().unwrap()\n+                       self.idents_to_string(module_.imports.borrow().last().unwrap()\n                                                  .module_path.as_slice()),\n                        token::get_ident(target));\n \n@@ -2003,7 +2003,7 @@ impl<'a> Resolver<'a> {\n     /// submodules.\n     fn resolve_imports_for_module_subtree(&mut self, module_: Rc<Module>) {\n         debug!(\"(resolving imports for module subtree) resolving {}\",\n-               self.module_to_str(&*module_));\n+               self.module_to_string(&*module_));\n         let orig_module = replace(&mut self.current_module, module_.clone());\n         self.resolve_imports_for_module(module_.clone());\n         self.current_module = orig_module;\n@@ -2030,7 +2030,7 @@ impl<'a> Resolver<'a> {\n         if module.all_imports_resolved() {\n             debug!(\"(resolving imports for module) all imports resolved for \\\n                    {}\",\n-                   self.module_to_str(&*module));\n+                   self.module_to_string(&*module));\n             return;\n         }\n \n@@ -2047,7 +2047,7 @@ impl<'a> Resolver<'a> {\n                         None => (import_directive.span, String::new())\n                     };\n                     let msg = format!(\"unresolved import `{}`{}\",\n-                                      self.import_path_to_str(\n+                                      self.import_path_to_string(\n                                           import_directive.module_path\n                                                           .as_slice(),\n                                           import_directive.subclass),\n@@ -2063,7 +2063,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn idents_to_str(&self, idents: &[Ident]) -> String {\n+    fn idents_to_string(&self, idents: &[Ident]) -> String {\n         let mut first = true;\n         let mut result = String::new();\n         for ident in idents.iter() {\n@@ -2077,15 +2077,15 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn path_idents_to_str(&self, path: &Path) -> String {\n+    fn path_idents_to_string(&self, path: &Path) -> String {\n         let identifiers: Vec<ast::Ident> = path.segments\n                                              .iter()\n                                              .map(|seg| seg.identifier)\n                                              .collect();\n-        self.idents_to_str(identifiers.as_slice())\n+        self.idents_to_string(identifiers.as_slice())\n     }\n \n-    fn import_directive_subclass_to_str(&mut self,\n+    fn import_directive_subclass_to_string(&mut self,\n                                         subclass: ImportDirectiveSubclass)\n                                         -> String {\n         match subclass {\n@@ -2096,16 +2096,16 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn import_path_to_str(&mut self,\n+    fn import_path_to_string(&mut self,\n                           idents: &[Ident],\n                           subclass: ImportDirectiveSubclass)\n                           -> String {\n         if idents.is_empty() {\n-            self.import_directive_subclass_to_str(subclass)\n+            self.import_directive_subclass_to_string(subclass)\n         } else {\n             (format!(\"{}::{}\",\n-                     self.idents_to_str(idents),\n-                     self.import_directive_subclass_to_str(\n+                     self.idents_to_string(idents),\n+                     self.import_directive_subclass_to_string(\n                          subclass))).to_string()\n         }\n     }\n@@ -2124,8 +2124,8 @@ impl<'a> Resolver<'a> {\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in \\\n                 `{}`\",\n-               self.idents_to_str(module_path.as_slice()),\n-               self.module_to_str(&*module_));\n+               self.idents_to_string(module_path.as_slice()),\n+               self.module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n         let container = if module_path.len() == 0 {\n@@ -2231,9 +2231,9 @@ impl<'a> Resolver<'a> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n                 `{}` id {}, last private {:?}\",\n                token::get_ident(target),\n-               self.module_to_str(&*containing_module),\n+               self.module_to_string(&*containing_module),\n                token::get_ident(source),\n-               self.module_to_str(module_),\n+               self.module_to_string(module_),\n                directive.id,\n                lp);\n \n@@ -2420,7 +2420,7 @@ impl<'a> Resolver<'a> {\n         if value_result.is_unbound() && type_result.is_unbound() {\n             let msg = format!(\"There is no `{}` in `{}`\",\n                               token::get_ident(source),\n-                              self.module_to_str(&*containing_module));\n+                              self.module_to_string(&*containing_module));\n             return Failed(Some((directive.span, msg)));\n         }\n         let value_used_public = value_used_reexport || value_used_public;\n@@ -2494,7 +2494,7 @@ impl<'a> Resolver<'a> {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {:?} into `{}`\",\n                    target_import_resolution.type_target.is_none(),\n-                   self.module_to_str(module_));\n+                   self.module_to_string(module_));\n \n             if !target_import_resolution.is_public {\n                 debug!(\"(resolving glob import) nevermind, just kidding\");\n@@ -2590,9 +2590,9 @@ impl<'a> Resolver<'a> {\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                to `{}`\",\n-               token::get_name(name).get().to_str(),\n-               self.module_to_str(&*containing_module),\n-               self.module_to_str(module_));\n+               token::get_name(name).get().to_string(),\n+               self.module_to_string(&*containing_module),\n+               self.module_to_string(module_));\n \n         // Merge the child item into the import resolution.\n         if name_bindings.defined_in_public_namespace(ValueNS) {\n@@ -2652,18 +2652,18 @@ impl<'a> Resolver<'a> {\n                                               false) {\n                 Failed(None) => {\n                     let segment_name = token::get_ident(name);\n-                    let module_name = self.module_to_str(&*search_module);\n+                    let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n                     let msg = if \"???\" == module_name.as_slice() {\n                         span.hi = span.lo + Pos::from_uint(segment_name.get().len());\n \n                         match search_parent_externals(name.name,\n                                                      &self.current_module) {\n                             Some(module) => {\n-                                let path_str = self.idents_to_str(module_path);\n-                                let target_mod_str = self.module_to_str(&*module);\n+                                let path_str = self.idents_to_string(module_path);\n+                                let target_mod_str = self.module_to_string(&*module);\n                                 let current_mod_str =\n-                                    self.module_to_str(&*self.current_module);\n+                                    self.module_to_string(&*self.current_module);\n \n                                 let prefix = if target_mod_str == current_mod_str {\n                                     \"self::\".to_string()\n@@ -2771,8 +2771,8 @@ impl<'a> Resolver<'a> {\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at \\\n                `{}`\",\n-               self.idents_to_str(module_path),\n-               self.module_to_str(&*module_));\n+               self.idents_to_string(module_path),\n+               self.module_to_string(&*module_));\n \n         // Resolve the module prefix, if any.\n         let module_prefix_result = self.resolve_module_prefix(module_.clone(),\n@@ -2783,7 +2783,7 @@ impl<'a> Resolver<'a> {\n         let last_private;\n         match module_prefix_result {\n             Failed(None) => {\n-                let mpath = self.idents_to_str(module_path);\n+                let mpath = self.idents_to_string(module_path);\n                 let mpath = mpath.as_slice();\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n@@ -2865,7 +2865,7 @@ impl<'a> Resolver<'a> {\n                 namespace {:?} in `{}`\",\n                token::get_ident(name),\n                namespace,\n-               self.module_to_str(&*module_));\n+               self.module_to_string(&*module_));\n \n         // The current module node is handled specially. First, check for\n         // its immediate children.\n@@ -3098,7 +3098,7 @@ impl<'a> Resolver<'a> {\n                 break\n             }\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n-                   self.module_to_str(&*containing_module));\n+                   self.module_to_string(&*containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n                 None => return Failed(None),\n                 Some(new_module) => {\n@@ -3109,7 +3109,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         debug!(\"(resolving module prefix) finished resolving prefix at {}\",\n-               self.module_to_str(&*containing_module));\n+               self.module_to_string(&*containing_module));\n \n         return Success(PrefixFound(containing_module, i));\n     }\n@@ -3129,7 +3129,7 @@ impl<'a> Resolver<'a> {\n                               -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n                token::get_name(name).get(),\n-               self.module_to_str(&*module_));\n+               self.module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n         self.populate_module_if_necessary(&module_);\n@@ -3262,19 +3262,19 @@ impl<'a> Resolver<'a> {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording \\\n                         exports for local module `{}`\",\n-                       self.module_to_str(&*module_));\n+                       self.module_to_string(&*module_));\n             }\n             None => {\n                 // Record exports for the root module.\n                 debug!(\"(recording exports for module subtree) recording \\\n                         exports for root module `{}`\",\n-                       self.module_to_str(&*module_));\n+                       self.module_to_string(&*module_));\n             }\n             Some(_) => {\n                 // Bail out.\n                 debug!(\"(recording exports for module subtree) not recording \\\n                         exports for `{}`\",\n-                       self.module_to_str(&*module_));\n+                       self.module_to_string(&*module_));\n                 return;\n             }\n         }\n@@ -3390,15 +3390,15 @@ impl<'a> Resolver<'a> {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n                                token::get_ident(name),\n-                               self.module_to_str(&*orig_module));\n+                               self.module_to_string(&*orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `{}` in `{}`\",\n                                        token::get_ident(name),\n-                                       self.module_to_str(&*orig_module));\n+                                       self.module_to_string(&*orig_module));\n                             }\n                             Some(module_) => {\n                                 self.current_module = module_;\n@@ -3892,7 +3892,7 @@ impl<'a> Resolver<'a> {\n                                    reference_type: TraitReferenceType) {\n         match self.resolve_path(id, &trait_reference.path, TypeNS, true) {\n             None => {\n-                let path_str = self.path_idents_to_str(&trait_reference.path);\n+                let path_str = self.path_idents_to_string(&trait_reference.path);\n                 let usage_str = match reference_type {\n                     TraitBoundingTypeParameter => \"bound type parameter with\",\n                     TraitImplementation        => \"implement\",\n@@ -3911,7 +3911,7 @@ impl<'a> Resolver<'a> {\n                     (def, _) => {\n                         self.resolve_error(trait_reference.path.span,\n                                            format!(\"`{}` is not a trait\",\n-                                                   self.path_idents_to_str(\n+                                                   self.path_idents_to_string(\n                                                         &trait_reference.path)));\n \n                         // If it's a typedef, give a note\n@@ -3959,7 +3959,7 @@ impl<'a> Resolver<'a> {\n                                                             .identifier),\n                                        def);\n                                 debug!(\"(resolving struct) writing resolution for `{}` (id {})\",\n-                                       this.path_idents_to_str(path),\n+                                       this.path_idents_to_string(path),\n                                        path_id);\n                                 this.record_def(path_id, (def, lp));\n                             }\n@@ -4071,7 +4071,7 @@ impl<'a> Resolver<'a> {\n             let method_name = method.ident.name;\n \n             if self.method_map.borrow().find(&(method_name, did)).is_none() {\n-                let path_str = self.path_idents_to_str(&trait_ref.path);\n+                let path_str = self.path_idents_to_string(&trait_ref.path);\n                 self.resolve_error(method.span,\n                                     format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(method_name),\n@@ -4281,13 +4281,13 @@ impl<'a> Resolver<'a> {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `{}` \\\n                                 (id {})\",\n-                               self.path_idents_to_str(path),\n+                               self.path_idents_to_string(path),\n                                path_id);\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n                         let msg = format!(\"use of undeclared type name `{}`\",\n-                                          self.path_idents_to_str(path));\n+                                          self.path_idents_to_string(path));\n                         self.resolve_error(ty.span, msg.as_slice());\n                     }\n                 }\n@@ -4488,7 +4488,7 @@ impl<'a> Resolver<'a> {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n-                                              self.path_idents_to_str(path));\n+                                              self.path_idents_to_string(path));\n                             self.resolve_error(path.span, msg.as_slice());\n                         }\n                     }\n@@ -4718,7 +4718,7 @@ impl<'a> Resolver<'a> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `{}`\",\n-                                          self.idents_to_str(\n+                                          self.idents_to_string(\n                                                module_path_idents.as_slice()));\n                         (path.span, msg)\n                     }\n@@ -4794,7 +4794,7 @@ impl<'a> Resolver<'a> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.idents_to_str(\n+                                          self.idents_to_string(\n                                                module_path_idents.as_slice()));\n                         (path.span, msg)\n                     }\n@@ -4999,7 +4999,7 @@ impl<'a> Resolver<'a> {\n         match get_module(self, path.span, ident_path.as_slice()) {\n             Some(module) => match module.children.borrow().find(&name) {\n                 Some(binding) => {\n-                    let p_str = self.path_idents_to_str(&path);\n+                    let p_str = self.path_idents_to_string(&path);\n                     match binding.def_for_namespace(ValueNS) {\n                         Some(DefStaticMethod(_, provenance, _)) => {\n                             match provenance {\n@@ -5021,7 +5021,7 @@ impl<'a> Resolver<'a> {\n         let method_map = self.method_map.borrow();\n         match self.current_trait_ref {\n             Some((did, ref trait_ref)) => {\n-                let path_str = self.path_idents_to_str(&trait_ref.path);\n+                let path_str = self.path_idents_to_string(&trait_ref.path);\n \n                 match method_map.find(&(name, did)) {\n                     Some(&SelfStatic) => return StaticTraitMethod(path_str),\n@@ -5094,7 +5094,7 @@ impl<'a> Resolver<'a> {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `{}`\",\n-                               self.path_idents_to_str(path));\n+                               self.path_idents_to_string(path));\n \n                         // First-class methods are not supported yet; error\n                         // out here.\n@@ -5114,7 +5114,7 @@ impl<'a> Resolver<'a> {\n                         self.record_def(expr.id, def);\n                     }\n                     None => {\n-                        let wrong_name = self.path_idents_to_str(path);\n+                        let wrong_name = self.path_idents_to_string(path);\n                         // Be helpful if the name refers to a struct\n                         // (The pattern matching def_tys where the id is in self.structs\n                         // matches on regular structs while excluding tuple- and enum-like\n@@ -5210,7 +5210,7 @@ impl<'a> Resolver<'a> {\n                         debug!(\"(resolving expression) didn't find struct \\\n                                 def: {:?}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n-                                          self.path_idents_to_str(path));\n+                                          self.path_idents_to_string(path));\n                         self.resolve_error(path.span, msg.as_slice());\n                     }\n                 }\n@@ -5510,7 +5510,7 @@ impl<'a> Resolver<'a> {\n     //\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n-    fn module_to_str(&self, module: &Module) -> String {\n+    fn module_to_string(&self, module: &Module) -> String {\n         let mut idents = Vec::new();\n \n         fn collect_mod(idents: &mut Vec<ast::Ident>, module: &Module) {\n@@ -5531,14 +5531,14 @@ impl<'a> Resolver<'a> {\n         if idents.len() == 0 {\n             return \"???\".to_string();\n         }\n-        self.idents_to_str(idents.move_iter().rev()\n+        self.idents_to_string(idents.move_iter().rev()\n                                  .collect::<Vec<ast::Ident>>()\n                                  .as_slice())\n     }\n \n     #[allow(dead_code)]   // useful for debugging\n     fn dump_module(&mut self, module_: Rc<Module>) {\n-        debug!(\"Dump of module `{}`:\", self.module_to_str(&*module_));\n+        debug!(\"Dump of module `{}`:\", self.module_to_string(&*module_));\n \n         debug!(\"Children:\");\n         self.populate_module_if_necessary(&module_);"}, {"sha": "1c85413a8d8eb7a02f401790aa209e8620210036", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -24,7 +24,7 @@ use syntax::codemap::Span;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n-use syntax::print::pprust::{lifetime_to_str};\n+use syntax::print::pprust::{lifetime_to_string};\n use syntax::visit;\n use syntax::visit::Visitor;\n use util::nodemap::NodeMap;\n@@ -372,7 +372,7 @@ impl<'a> LifetimeContext<'a> {\n         }\n \n         debug!(\"lifetime_ref={} id={} resolved to {:?}\",\n-                lifetime_to_str(lifetime_ref),\n+                lifetime_to_string(lifetime_ref),\n                 lifetime_ref.id,\n                 def);\n         self.named_region_map.insert(lifetime_ref.id, def);"}, {"sha": "d16e2bbf66b937ff57a33236813c1de91cdee6e6", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -51,7 +51,7 @@ use syntax::parse::token;\n use syntax::parse::token::{get_ident,keywords};\n use syntax::visit;\n use syntax::visit::Visitor;\n-use syntax::print::pprust::{path_to_str,ty_to_str};\n+use syntax::print::pprust::{path_to_string,ty_to_string};\n \n use middle::save::span_utils::SpanUtils;\n use middle::save::recorder::Recorder;\n@@ -108,7 +108,7 @@ impl <'l> DxrVisitor<'l> {\n         if spans.len() < path.segments.len() {\n             error!(\"Mis-calculated spans for path '{}'. \\\n                     Found {} spans, expected {}. Found spans:\",\n-                   path_to_str(path), spans.len(), path.segments.len());\n+                   path_to_string(path), spans.len(), path.segments.len());\n             for s in spans.iter() {\n                 let loc = self.sess.codemap().lookup_char_pos(s.lo);\n                 error!(\"    '{}' in {}, line {}\",\n@@ -126,7 +126,7 @@ impl <'l> DxrVisitor<'l> {\n             let sub_path = ast::Path{span: *span, // span for the last segment\n                                      global: path.global,\n                                      segments: segs};\n-            let qualname = path_to_str(&sub_path);\n+            let qualname = path_to_string(&sub_path);\n             result.push((*span, qualname));\n             segs = sub_path.segments;\n         }\n@@ -249,15 +249,15 @@ impl <'l> DxrVisitor<'l> {\n             self.collecting = false;\n             let span_utils = self.span;\n             for &(id, ref p, _, _) in self.collected_paths.iter() {\n-                let typ = ppaux::ty_to_str(&self.analysis.ty_cx,\n+                let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n                     *self.analysis.ty_cx.node_types.borrow().get(&(id as uint)));\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n                                     span_utils.span_for_last_ident(p.span),\n                                     id,\n                                     qualname,\n-                                    path_to_str(p).as_slice(),\n+                                    path_to_string(p).as_slice(),\n                                     typ.as_slice());\n             }\n             self.collected_paths.clear();\n@@ -280,7 +280,7 @@ impl <'l> DxrVisitor<'l> {\n                     match item.node {\n                         ast::ItemImpl(_, _, ty, _) => {\n                             let mut result = String::from_str(\"<\");\n-                            result.push_str(ty_to_str(&*ty).as_slice());\n+                            result.push_str(ty_to_string(&*ty).as_slice());\n \n                             match ty::trait_of_method(&self.analysis.ty_cx,\n                                                       ast_util::local_def(method.id)) {\n@@ -400,7 +400,7 @@ impl <'l> DxrVisitor<'l> {\n             ast::NamedField(ident, _) => {\n                 let name = get_ident(ident);\n                 let qualname = format!(\"{}::{}\", qualname, name);\n-                let typ = ppaux::ty_to_str(&self.analysis.ty_cx,\n+                let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n                     *self.analysis.ty_cx.node_types.borrow().get(&(field.node.id as uint)));\n                 match self.span.sub_span_before_token(field.span, token::COLON) {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n@@ -452,7 +452,7 @@ impl <'l> DxrVisitor<'l> {\n                   decl: ast::P<ast::FnDecl>,\n                   ty_params: &ast::Generics,\n                   body: ast::P<ast::Block>) {\n-        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n \n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Fn);\n         self.fmt.fn_str(item.span,\n@@ -482,7 +482,7 @@ impl <'l> DxrVisitor<'l> {\n                       mt: ast::Mutability,\n                       expr: &ast::Expr)\n     {\n-        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n \n         // If the variable is immutable, save the initialising expression.\n         let value = match mt {\n@@ -497,7 +497,7 @@ impl <'l> DxrVisitor<'l> {\n                             get_ident(item.ident).get(),\n                             qualname.as_slice(),\n                             value.as_slice(),\n-                            ty_to_str(&*typ).as_slice(),\n+                            ty_to_string(&*typ).as_slice(),\n                             e.cur_scope);\n \n         // walk type and init value\n@@ -510,7 +510,7 @@ impl <'l> DxrVisitor<'l> {\n                       e: DxrVisitorEnv,\n                       def: &ast::StructDef,\n                       ty_params: &ast::Generics) {\n-        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n \n         let ctor_id = match def.ctor_id {\n             Some(node_id) => node_id,\n@@ -538,7 +538,7 @@ impl <'l> DxrVisitor<'l> {\n                     e: DxrVisitorEnv,\n                     enum_definition: &ast::EnumDef,\n                     ty_params: &ast::Generics) {\n-        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n         match self.span.sub_span_after_keyword(item.span, keywords::Enum) {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n                                                 Some(sub_span),\n@@ -639,7 +639,7 @@ impl <'l> DxrVisitor<'l> {\n                      generics: &ast::Generics,\n                      trait_refs: &Vec<ast::TraitRef>,\n                      methods: &Vec<ast::TraitMethod>) {\n-        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n \n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         self.fmt.trait_str(item.span,\n@@ -678,7 +678,7 @@ impl <'l> DxrVisitor<'l> {\n                    item: &ast::Item,  // The module in question, represented as an item.\n                    e: DxrVisitorEnv,\n                    m: &ast::Mod) {\n-        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n \n         let cm = self.sess.codemap();\n         let filename = cm.span_to_filename(m.inner);\n@@ -971,8 +971,8 @@ impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n                 self.process_trait(item, e, generics, trait_refs, methods),\n             ast::ItemMod(ref m) => self.process_mod(item, e, m),\n             ast::ItemTy(ty, ref ty_params) => {\n-                let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n-                let value = ty_to_str(&*ty);\n+                let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+                let value = ty_to_string(&*ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 self.fmt.typedef_str(item.span,\n                                      sub_span,\n@@ -1231,7 +1231,7 @@ impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n                     return\n                 }\n \n-                let id = String::from_str(\"$\").append(ex.id.to_str().as_slice());\n+                let id = String::from_str(\"$\").append(ex.id.to_string().as_slice());\n                 self.process_formals(&decl.inputs, id.as_slice(), e);\n \n                 // walk arg and return types\n@@ -1288,7 +1288,7 @@ impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n                 def::DefBinding(id, _)  => self.fmt.variable_str(p.span,\n                                                                  sub_span,\n                                                                  id,\n-                                                                 path_to_str(p).as_slice(),\n+                                                                 path_to_string(p).as_slice(),\n                                                                  value.as_slice(),\n                                                                  \"\"),\n                 def::DefVariant(_,id,_) => self.fmt.ref_str(ref_kind,\n@@ -1331,15 +1331,15 @@ impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n         for &(id, ref p, ref immut, _) in self.collected_paths.iter() {\n             let value = if *immut { value.to_owned() } else { \"<mutable>\".to_owned() };\n             let types = self.analysis.ty_cx.node_types.borrow();\n-            let typ = ppaux::ty_to_str(&self.analysis.ty_cx, *types.get(&(id as uint)));\n+            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&(id as uint)));\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n             self.fmt.variable_str(p.span,\n                                   sub_span,\n                                   id,\n-                                  path_to_str(p).as_slice(),\n+                                  path_to_string(p).as_slice(),\n                                   value.as_slice(),\n                                   typ.as_slice());\n         }"}, {"sha": "7869aec1683c20c115814223a1e706ecb478b516", "filename": "src/librustc/middle/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -252,7 +252,7 @@ impl<'a> FmtStrs<'a> {\n         // the local case they can be overridden in one block and there is no nice way\n         // to refer to such a scope in english, so we just hack it by appending the\n         // variable def's node id\n-        let qualname = String::from_str(name).append(\"$\").append(id.to_str().as_slice());\n+        let qualname = String::from_str(name).append(\"$\").append(id.to_string().as_slice());\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,"}, {"sha": "3cfd1aaee8ff39a37e0f6c9a9d1dcfccdd01cfcd", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -214,7 +214,7 @@ use middle::trans::type_of;\n use middle::trans::debuginfo;\n use middle::ty;\n use util::common::indenter;\n-use util::ppaux::{Repr, vec_map_to_str};\n+use util::ppaux::{Repr, vec_map_to_string};\n \n use std;\n use std::collections::HashMap;\n@@ -409,7 +409,7 @@ fn expand_nested_bindings<'a, 'b>(\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n-           bcx.val_to_str(val));\n+           bcx.val_to_string(val));\n     let _indenter = indenter();\n \n     m.iter().map(|br| {\n@@ -449,7 +449,7 @@ fn enter_match<'a, 'b>(\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n-           bcx.val_to_str(val));\n+           bcx.val_to_string(val));\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n@@ -485,7 +485,7 @@ fn enter_default<'a, 'b>(\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n-           bcx.val_to_str(val));\n+           bcx.val_to_string(val));\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n@@ -541,7 +541,7 @@ fn enter_opt<'a, 'b>(\n            m.repr(bcx.tcx()),\n            *opt,\n            col,\n-           bcx.val_to_str(val));\n+           bcx.val_to_string(val));\n     let _indenter = indenter();\n \n     let ctor = match opt {\n@@ -922,7 +922,7 @@ fn compare_values<'a>(\n         let did = langcall(cx,\n                            None,\n                            format!(\"comparison of `{}`\",\n-                                   cx.ty_to_str(rhs_t)).as_slice(),\n+                                   cx.ty_to_string(rhs_t)).as_slice(),\n                            StrEqFnLangItem);\n         callee::trans_lang_call(cx, did, [lhs, rhs], None)\n     }\n@@ -988,7 +988,7 @@ fn insert_lllocals<'a>(mut bcx: &'a Block<'a>, bindings_map: &BindingsMap,\n \n         debug!(\"binding {:?} to {}\",\n                binding_info.id,\n-               bcx.val_to_str(llval));\n+               bcx.val_to_string(llval));\n         bcx.fcx.lllocals.borrow_mut().insert(binding_info.id, datum);\n \n         if bcx.sess().opts.debuginfo == FullDebugInfo {\n@@ -1011,9 +1011,9 @@ fn compile_guard<'a, 'b>(\n                  -> &'b Block<'b> {\n     debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n-           bcx.expr_to_str(guard_expr),\n+           bcx.expr_to_string(guard_expr),\n            m.repr(bcx.tcx()),\n-           vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n+           vec_map_to_string(vals, |v| bcx.val_to_string(*v)));\n     let _indenter = indenter();\n \n     let mut bcx = insert_lllocals(bcx, &data.bindings_map, None);\n@@ -1050,7 +1050,7 @@ fn compile_submatch<'a, 'b>(\n     debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n-           vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n+           vec_map_to_string(vals, |v| bcx.val_to_string(*v)));\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n@@ -1155,7 +1155,7 @@ fn compile_submatch_continue<'a, 'b>(\n     debug!(\"options={:?}\", opts);\n     let mut kind = no_branch;\n     let mut test_val = val;\n-    debug!(\"test_val={}\", bcx.val_to_str(test_val));\n+    debug!(\"test_val={}\", bcx.val_to_string(test_val));\n     if opts.len() > 0u {\n         match *opts.get(0) {\n             var(_, ref repr, _) => {"}, {"sha": "898cb036ea5374954c7bd9d59a812135cc9569cf", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -63,7 +63,7 @@ use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel};\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::IntType;\n-use util::ppaux::ty_to_str;\n+use util::ppaux::ty_to_string;\n \n type Hint = attr::ReprAttr;\n \n@@ -135,7 +135,7 @@ pub fn represent_node(bcx: &Block, node: ast::NodeId) -> Rc<Repr> {\n \n /// Decides how to represent a given type.\n pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n-    debug!(\"Representing: {}\", ty_to_str(cx.tcx(), t));\n+    debug!(\"Representing: {}\", ty_to_string(cx.tcx(), t));\n     match cx.adt_reprs.borrow().find(&t) {\n         Some(repr) => return repr.clone(),\n         None => {}"}, {"sha": "84b253306ff57ccf9a79adeca63140a4388c3ccb", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -71,7 +71,7 @@ use middle::trans::value::Value;\n use middle::ty;\n use middle::typeck;\n use util::common::indenter;\n-use util::ppaux::{Repr, ty_to_str};\n+use util::ppaux::{Repr, ty_to_string};\n use util::sha2::Sha256;\n use util::nodemap::NodeMap;\n \n@@ -301,7 +301,7 @@ fn require_alloc_fn(bcx: &Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n         Ok(id) => id,\n         Err(s) => {\n             bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n-                                     bcx.ty_to_str(info_ty),\n+                                     bcx.ty_to_string(info_ty),\n                                      s).as_slice());\n         }\n     }\n@@ -706,7 +706,7 @@ pub fn iter_structural_ty<'r,\n                       let variant_cx =\n                           fcx.new_temp_block(\n                               format!(\"enum-iter-variant-{}\",\n-                                      variant.disr_val.to_str().as_slice())\n+                                      variant.disr_val.to_string().as_slice())\n                                      .as_slice());\n                       match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::single_result(r) => {\n@@ -809,7 +809,7 @@ pub fn fail_if_zero_or_overflows<'a>(\n         }\n         _ => {\n             cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n-                                  ty_to_str(cx.tcx(), rhs_t)).as_slice());\n+                                  ty_to_string(cx.tcx(), rhs_t)).as_slice());\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -903,7 +903,7 @@ pub fn invoke<'a>(\n             debug!(\"invoke at ???\");\n         }\n         Some(id) => {\n-            debug!(\"invoke at {}\", bcx.tcx().map.node_to_str(id));\n+            debug!(\"invoke at {}\", bcx.tcx().map.node_to_string(id));\n         }\n     }\n \n@@ -1173,7 +1173,7 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n            if id == -1 {\n                \"\".to_string()\n            } else {\n-               ccx.tcx.map.path_to_str(id).to_string()\n+               ccx.tcx.map.path_to_string(id).to_string()\n            },\n            id, param_substs.repr(ccx.tcx()));\n \n@@ -1474,7 +1474,7 @@ pub fn trans_fn(ccx: &CrateContext,\n                 param_substs: &param_substs,\n                 id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_str(id).to_string());\n+    let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_string(id).to_string());\n     debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx(), id));\n@@ -1527,7 +1527,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ty_to_str(ccx.tcx(), ctor_ty)).as_slice())\n+                    ty_to_string(ccx.tcx(), ctor_ty)).as_slice())\n     };\n \n     let arena = TypedArena::new();\n@@ -2010,7 +2010,7 @@ fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n         _ => ccx.tcx.map.with_path(id, |mut path| {\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n-                path.last().unwrap().to_str()\n+                path.last().unwrap().to_string()\n             } else {\n                 match weak_lang_items::link_name(attrs) {\n                     Some(name) => name.get().to_string(),"}, {"sha": "ce11cd24f7b047688a4e3181a1d44cc0bd0fffcb", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -122,8 +122,8 @@ pub fn Invoke(cx: &Block,\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n     debug!(\"Invoke({} with arguments ({}))\",\n-           cx.val_to_str(fn_),\n-           args.iter().map(|a| cx.val_to_str(*a)).collect::<Vec<String>>().connect(\", \"));\n+           cx.val_to_string(fn_),\n+           args.iter().map(|a| cx.val_to_string(*a)).collect::<Vec<String>>().connect(\", \"));\n     B(cx).invoke(fn_, args, then, catch, attributes)\n }\n "}, {"sha": "3a9e3e4cf9b07f5162f7b2a512c2e3b39d97b4f0", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -161,9 +161,9 @@ impl<'a> Builder<'a> {\n         self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {} with args ({})\",\n-               self.ccx.tn.val_to_str(llfn),\n+               self.ccx.tn.val_to_string(llfn),\n                args.iter()\n-                   .map(|&v| self.ccx.tn.val_to_str(v))\n+                   .map(|&v| self.ccx.tn.val_to_string(v))\n                    .collect::<Vec<String>>()\n                    .connect(\", \"));\n \n@@ -497,8 +497,8 @@ impl<'a> Builder<'a> {\n \n     pub fn store(&self, val: ValueRef, ptr: ValueRef) {\n         debug!(\"Store {} -> {}\",\n-               self.ccx.tn.val_to_str(val),\n-               self.ccx.tn.val_to_str(ptr));\n+               self.ccx.tn.val_to_string(val),\n+               self.ccx.tn.val_to_string(ptr));\n         assert!(self.llbuilder.is_not_null());\n         self.count_insn(\"store\");\n         unsafe {\n@@ -508,8 +508,8 @@ impl<'a> Builder<'a> {\n \n     pub fn volatile_store(&self, val: ValueRef, ptr: ValueRef) {\n         debug!(\"Store {} -> {}\",\n-               self.ccx.tn.val_to_str(val),\n-               self.ccx.tn.val_to_str(ptr));\n+               self.ccx.tn.val_to_string(val),\n+               self.ccx.tn.val_to_string(ptr));\n         assert!(self.llbuilder.is_not_null());\n         self.count_insn(\"store.volatile\");\n         unsafe {\n@@ -520,8 +520,8 @@ impl<'a> Builder<'a> {\n \n     pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n         debug!(\"Store {} -> {}\",\n-               self.ccx.tn.val_to_str(val),\n-               self.ccx.tn.val_to_str(ptr));\n+               self.ccx.tn.val_to_string(val),\n+               self.ccx.tn.val_to_string(ptr));\n         self.count_insn(\"store.atomic\");\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n@@ -760,7 +760,7 @@ impl<'a> Builder<'a> {\n         if self.ccx.sess().asm_comments() {\n             let s = format!(\"{} ({})\",\n                             text,\n-                            self.ccx.sess().codemap().span_to_str(sp));\n+                            self.ccx.sess().codemap().span_to_string(sp));\n             debug!(\"{}\", s.as_slice());\n             self.add_comment(s.as_slice());\n         }\n@@ -794,11 +794,11 @@ impl<'a> Builder<'a> {\n                          else          { lib::llvm::False };\n \n         let argtys = inputs.iter().map(|v| {\n-            debug!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_str(*v));\n+            debug!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_string(*v));\n             val_ty(*v)\n         }).collect::<Vec<_>>();\n \n-        debug!(\"Asm Output Type: {:?}\", self.ccx.tn.type_to_str(output));\n+        debug!(\"Asm Output Type: {:?}\", self.ccx.tn.type_to_string(output));\n         let fty = Type::func(argtys.as_slice(), &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n@@ -812,9 +812,9 @@ impl<'a> Builder<'a> {\n         self.count_insn(\"call\");\n \n         debug!(\"Call {} with args ({})\",\n-               self.ccx.tn.val_to_str(llfn),\n+               self.ccx.tn.val_to_string(llfn),\n                args.iter()\n-                   .map(|&v| self.ccx.tn.val_to_str(v))\n+                   .map(|&v| self.ccx.tn.val_to_string(v))\n                    .collect::<Vec<String>>()\n                    .connect(\", \"));\n "}, {"sha": "2e4a3d9fd7e3ed910a1fd38c8a7bbe27c3b3457a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -108,7 +108,7 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n                     expr.span,\n                     format!(\"type of callee is neither bare-fn nor closure: \\\n                              {}\",\n-                            bcx.ty_to_str(datum.ty)).as_slice());\n+                            bcx.ty_to_string(datum.ty)).as_slice());\n             }\n         }\n     }\n@@ -905,7 +905,7 @@ pub fn trans_arg_datum<'a>(\n \n     let arg_datum_ty = arg_datum.ty;\n \n-    debug!(\"   arg datum: {}\", arg_datum.to_str(bcx.ccx()));\n+    debug!(\"   arg datum: {}\", arg_datum.to_string(bcx.ccx()));\n \n     let mut val;\n     if ty::type_is_bot(arg_datum_ty) {\n@@ -949,11 +949,11 @@ pub fn trans_arg_datum<'a>(\n             // this could happen due to e.g. subtyping\n             let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n             debug!(\"casting actual type ({}) to match formal ({})\",\n-                   bcx.val_to_str(val), bcx.llty_str(llformal_arg_ty));\n+                   bcx.val_to_string(val), bcx.llty_str(llformal_arg_ty));\n             val = PointerCast(bcx, val, llformal_arg_ty);\n         }\n     }\n \n-    debug!(\"--- trans_arg_datum passing {}\", bcx.val_to_str(val));\n+    debug!(\"--- trans_arg_datum passing {}\", bcx.val_to_string(val));\n     Result::new(bcx, val)\n }"}, {"sha": "0485b100446577910abe00672a4dc468f1421012", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -85,7 +85,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"push_ast_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_str(id));\n+               self.ccx.tcx.map.node_to_string(id));\n \n         // FIXME(#2202) -- currently closure bodies have a parent\n         // region, which messes up the assertion below, since there\n@@ -109,7 +109,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                                id: ast::NodeId,\n                                exits: [&'a Block<'a>, ..EXIT_MAX]) {\n         debug!(\"push_loop_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_str(id));\n+               self.ccx.tcx.map.node_to_string(id));\n         assert_eq!(Some(id), self.top_ast_scope());\n \n         self.push_scope(CleanupScope::new(LoopScopeKind(id, exits)));\n@@ -133,7 +133,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"pop_and_trans_ast_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_str(cleanup_scope));\n+               self.ccx.tcx.map.node_to_string(cleanup_scope));\n \n         assert!(self.top_scope(|s| s.kind.is_ast_with_id(cleanup_scope)));\n \n@@ -152,7 +152,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"pop_loop_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_str(cleanup_scope));\n+               self.ccx.tcx.map.node_to_string(cleanup_scope));\n \n         assert!(self.top_scope(|s| s.kind.is_loop_with_id(cleanup_scope)));\n \n@@ -246,7 +246,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_str(val),\n+               self.ccx.tn.val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n \n         self.schedule_clean(cleanup_scope, drop as Box<Cleanup>);\n@@ -272,7 +272,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_drop_and_zero_mem({:?}, val={}, ty={}, zero={})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_str(val),\n+               self.ccx.tn.val_to_string(val),\n                ty.repr(self.ccx.tcx()),\n                true);\n \n@@ -298,7 +298,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_drop_immediate({:?}, val={}, ty={})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_str(val),\n+               self.ccx.tn.val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n \n         self.schedule_clean(cleanup_scope, drop as Box<Cleanup>);\n@@ -318,7 +318,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_str(val),\n+               self.ccx.tn.val_to_string(val),\n                heap);\n \n         self.schedule_clean(cleanup_scope, drop as Box<Cleanup>);\n@@ -358,7 +358,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         self.ccx.sess().bug(\n             format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx.map.node_to_str(cleanup_scope)).as_slice());\n+                    self.ccx.tcx.map.node_to_string(cleanup_scope)).as_slice());\n     }\n \n     fn schedule_clean_in_custom_scope(&self,"}, {"sha": "ef147eb22b5064cf321ed6c2ad20b9853329b43b", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -27,7 +27,7 @@ use middle::trans::type_of::*;\n use middle::trans::type_::Type;\n use middle::ty;\n use util::ppaux::Repr;\n-use util::ppaux::ty_to_str;\n+use util::ppaux::ty_to_string;\n \n use arena::TypedArena;\n use syntax::ast;\n@@ -104,8 +104,8 @@ pub struct EnvValue {\n }\n \n impl EnvValue {\n-    pub fn to_str(&self, ccx: &CrateContext) -> String {\n-        format!(\"{}({})\", self.action, self.datum.to_str(ccx))\n+    pub fn to_string(&self, ccx: &CrateContext) -> String {\n+        format!(\"{}({})\", self.action, self.datum.to_string(ccx))\n     }\n }\n \n@@ -124,7 +124,7 @@ pub fn mk_closure_tys(tcx: &ty::ctxt,\n         }\n     }).collect();\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n-    debug!(\"cdata_ty={}\", ty_to_str(tcx, cdata_ty));\n+    debug!(\"cdata_ty={}\", ty_to_string(tcx, cdata_ty));\n     return cdata_ty;\n }\n \n@@ -196,16 +196,16 @@ pub fn store_environment<'a>(\n     let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, store, cdata_ty);\n \n     let llbox = PointerCast(bcx, llbox, llboxptr_ty);\n-    debug!(\"tuplify_box_ty = {}\", ty_to_str(tcx, cbox_ty));\n+    debug!(\"tuplify_box_ty = {}\", ty_to_string(tcx, cbox_ty));\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n     for (i, bv) in bound_values.move_iter().enumerate() {\n-        debug!(\"Copy {} into closure\", bv.to_str(ccx));\n+        debug!(\"Copy {} into closure\", bv.to_string(ccx));\n \n         if ccx.sess().asm_comments() {\n             add_comment(bcx, format!(\"Copy {} into closure\",\n-                                     bv.to_str(ccx)).as_slice());\n+                                     bv.to_string(ccx)).as_slice());\n         }\n \n         let bound_data = GEPi(bcx, llbox, [0u, abi::box_field_body, i]);"}, {"sha": "23a391cb86dfefd35e534603313cee49f4f8d4da", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -196,13 +196,13 @@ impl param_substs {\n     }\n }\n \n-fn param_substs_to_str(this: &param_substs, tcx: &ty::ctxt) -> String {\n+fn param_substs_to_string(this: &param_substs, tcx: &ty::ctxt) -> String {\n     format!(\"param_substs({})\", this.substs.repr(tcx))\n }\n \n impl Repr for param_substs {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        param_substs_to_str(self, tcx)\n+        param_substs_to_string(self, tcx)\n     }\n }\n \n@@ -436,11 +436,11 @@ impl<'a> Block<'a> {\n         token::get_ident(ident).get().to_string()\n     }\n \n-    pub fn node_id_to_str(&self, id: ast::NodeId) -> String {\n-        self.tcx().map.node_to_str(id).to_string()\n+    pub fn node_id_to_string(&self, id: ast::NodeId) -> String {\n+        self.tcx().map.node_to_string(id).to_string()\n     }\n \n-    pub fn expr_to_str(&self, e: &ast::Expr) -> String {\n+    pub fn expr_to_string(&self, e: &ast::Expr) -> String {\n         e.repr(self.tcx())\n     }\n \n@@ -454,15 +454,15 @@ impl<'a> Block<'a> {\n         }\n     }\n \n-    pub fn val_to_str(&self, val: ValueRef) -> String {\n-        self.ccx().tn.val_to_str(val)\n+    pub fn val_to_string(&self, val: ValueRef) -> String {\n+        self.ccx().tn.val_to_string(val)\n     }\n \n     pub fn llty_str(&self, ty: Type) -> String {\n-        self.ccx().tn.type_to_str(ty)\n+        self.ccx().tn.type_to_string(ty)\n     }\n \n-    pub fn ty_to_str(&self, t: ty::t) -> String {\n+    pub fn ty_to_string(&self, t: ty::t) -> String {\n         t.repr(self.tcx())\n     }\n \n@@ -645,7 +645,7 @@ pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n         debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n-               cx.tn.val_to_str(v), us, cx.tn.val_to_str(r));\n+               cx.tn.val_to_string(v), us, cx.tn.val_to_string(r));\n \n         return r;\n     }"}, {"sha": "c35767f99a8352b4bed711311a9f0783b5ebbc1c", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -31,7 +31,7 @@ use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::trans::debuginfo;\n use middle::ty;\n-use util::ppaux::{Repr, ty_to_str};\n+use util::ppaux::{Repr, ty_to_string};\n \n use std::c_str::ToCStr;\n use std::gc::Gc;\n@@ -59,7 +59,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n                 _ => cx.sess().span_bug(lit.span,\n                         format!(\"integer literal has type {} (expected int \\\n                                  or uint)\",\n-                                ty_to_str(cx.tcx(), lit_int_ty)).as_slice())\n+                                ty_to_string(cx.tcx(), lit_int_ty)).as_slice())\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -155,14 +155,14 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n                 }\n                 _ => {\n                     cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n-                                          ty_to_str(cx.tcx(), t)).as_slice())\n+                                          ty_to_string(cx.tcx(), t)).as_slice())\n                 }\n             };\n             (dv, mt.ty)\n         }\n         None => {\n             cx.sess().bug(format!(\"can't dereference const of type {}\",\n-                                  ty_to_str(cx.tcx(), t)).as_slice())\n+                                  ty_to_string(cx.tcx(), t)).as_slice())\n         }\n     }\n }\n@@ -285,7 +285,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n         cx.sess().bug(format!(\"const {} of type {} has size {} instead of {}\",\n-                         e.repr(cx.tcx()), ty_to_str(cx.tcx(), ety),\n+                         e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n                          csize, tsize).as_slice());\n     }\n     (llconst, inlineable)"}, {"sha": "acc44d08d3cb041b0e548ff2e1b9e8df5d80ee8d", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -126,8 +126,8 @@ pub fn trans_if<'a>(bcx: &'a Block<'a>,\n                     dest: expr::Dest)\n                     -> &'a Block<'a> {\n     debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={:?}, dest={})\",\n-           bcx.to_str(), if_id, bcx.expr_to_str(cond), thn.id,\n-           dest.to_str(bcx.ccx()));\n+           bcx.to_str(), if_id, bcx.expr_to_string(cond), thn.id,\n+           dest.to_string(bcx.ccx()));\n     let _icx = push_ctxt(\"trans_if\");\n     let mut bcx = bcx;\n "}, {"sha": "b65f5a5c7d6b69794d5270ecb01b5d8f9b995854", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -23,7 +23,7 @@ use middle::trans::glue;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty;\n-use util::ppaux::{ty_to_str};\n+use util::ppaux::{ty_to_string};\n \n use syntax::ast;\n \n@@ -596,10 +596,10 @@ impl<K:KindOps> Datum<K> {\n     }\n \n     #[allow(dead_code)] // useful for debugging\n-    pub fn to_str(&self, ccx: &CrateContext) -> String {\n+    pub fn to_string(&self, ccx: &CrateContext) -> String {\n         format!(\"Datum({}, {}, {:?})\",\n-                ccx.tn.val_to_str(self.val),\n-                ty_to_str(ccx.tcx(), self.ty),\n+                ccx.tn.val_to_string(self.val),\n+                ty_to_string(ccx.tcx(), self.ty),\n                 self.kind)\n     }\n "}, {"sha": "9acd04871999aecf94f0dd2ee4e1e4467ee618ff", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -270,7 +270,7 @@ impl TypeMap {\n                                    metadata: DIType) {\n         if !self.type_to_metadata.insert(ty::type_id(type_), metadata) {\n             cx.sess().bug(format!(\"Type metadata for ty::t '{}' is already in the TypeMap!\",\n-                                   ppaux::ty_to_str(cx.tcx(), type_)).as_slice());\n+                                   ppaux::ty_to_string(cx.tcx(), type_)).as_slice());\n         }\n     }\n \n@@ -504,7 +504,7 @@ impl TypeMap {\n             },\n             _ => {\n                 cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n-                                      ppaux::ty_to_str(cx.tcx(), type_).as_slice(),\n+                                      ppaux::ty_to_string(cx.tcx(), type_).as_slice(),\n                                       ty::get(type_).sty).as_slice())\n             }\n         };\n@@ -808,7 +808,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let type_metadata = type_metadata(cx, variable_type, span);\n \n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n-    let var_name = token::get_ident(ident).get().to_str();\n+    let var_name = token::get_ident(ident).get().to_string();\n     let linkage_name =\n         namespace_node.mangled_name_of_contained_item(var_name.as_slice());\n     let var_scope = namespace_node.scope;\n@@ -1056,7 +1056,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n         FunctionDebugContext(box ref function_debug_context) => {\n             let cx = fcx.ccx;\n \n-            debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_str(span));\n+            debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n \n             if function_debug_context.source_locations_enabled.get() {\n                 let loc = span_start(cx, span);\n@@ -1812,7 +1812,7 @@ impl RecursiveTypeDescription {\n                        type_map.find_metadata_for_type(unfinished_type).is_none() {\n                         cx.sess().bug(format!(\"Forward declaration of potentially recursive type \\\n                                               '{}' was not found in TypeMap!\",\n-                                              ppaux::ty_to_str(cx.tcx(), unfinished_type))\n+                                              ppaux::ty_to_string(cx.tcx(), unfinished_type))\n                                       .as_slice());\n                     }\n                 }\n@@ -2245,7 +2245,7 @@ fn describe_enum_variant(cx: &CrateContext,\n         Some(ref names) => {\n             names.iter()\n                  .map(|ident| {\n-                     token::get_ident(*ident).get().to_str().into_string()\n+                     token::get_ident(*ident).get().to_string().into_string()\n                  }).collect()\n         }\n         None => variant_info.args.iter().map(|_| \"\".to_string()).collect()\n@@ -2872,7 +2872,7 @@ fn trait_pointer_metadata(cx: &CrateContext,\n         ty::ty_uniq(pointee_type) => pointee_type,\n         ty::ty_rptr(_, ty::mt { ty, .. }) => ty,\n         _ => {\n-            let pp_type_name = ppaux::ty_to_str(cx.tcx(), trait_pointer_type);\n+            let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_pointer_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-pointer type in \\\n                                    trait_pointer_metadata(): {}\",\n                                    pp_type_name.as_slice()).as_slice());\n@@ -2882,7 +2882,7 @@ fn trait_pointer_metadata(cx: &CrateContext,\n     let def_id = match ty::get(trait_object_type).sty {\n         ty::ty_trait(box ty::TyTrait { def_id, .. }) => def_id,\n         _ => {\n-            let pp_type_name = ppaux::ty_to_str(cx.tcx(), trait_object_type);\n+            let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_object_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n                                    pp_type_name.as_slice()).as_slice());\n@@ -3064,7 +3064,7 @@ fn type_metadata(cx: &CrateContext,\n                                                  the debuginfo::TypeMap but it \\\n                                                  was not. (ty::t = {})\",\n                                                 unique_type_id_str.as_slice(),\n-                                                ppaux::ty_to_str(cx.tcx(), t));\n+                                                ppaux::ty_to_string(cx.tcx(), t));\n                     cx.sess().span_bug(usage_site_span, error_message.as_slice());\n                 }\n             };\n@@ -3079,7 +3079,7 @@ fn type_metadata(cx: &CrateContext,\n                                                      debuginfo::TypeMap. \\\n                                                      UniqueTypeId={}, ty::t={}\",\n                             unique_type_id_str.as_slice(),\n-                            ppaux::ty_to_str(cx.tcx(), t));\n+                            ppaux::ty_to_string(cx.tcx(), t));\n                         cx.sess().span_bug(usage_site_span, error_message.as_slice());\n                     }\n                 }\n@@ -3879,7 +3879,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n         ty::ty_infer(_) |\n         ty::ty_param(_) => {\n             cx.sess().bug(format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", ppaux::ty_to_str(cx.tcx(), t)).as_slice());\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)).as_slice());\n         }\n     }\n "}, {"sha": "516c46564cd9ffe32eeda2c7bb959b987a25b3c1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -75,7 +75,7 @@ use middle::trans::type_::Type;\n \n use syntax::ast;\n use syntax::codemap;\n-use syntax::print::pprust::{expr_to_str};\n+use syntax::print::pprust::{expr_to_string};\n \n use std::gc::Gc;\n \n@@ -91,9 +91,9 @@ pub enum Dest {\n }\n \n impl Dest {\n-    pub fn to_str(&self, ccx: &CrateContext) -> String {\n+    pub fn to_string(&self, ccx: &CrateContext) -> String {\n         match *self {\n-            SaveIn(v) => format!(\"SaveIn({})\", ccx.tn.val_to_str(v)),\n+            SaveIn(v) => format!(\"SaveIn({})\", ccx.tn.val_to_string(v)),\n             Ignore => \"Ignore\".to_string()\n         }\n     }\n@@ -148,7 +148,7 @@ pub fn trans<'a>(bcx: &'a Block<'a>,\n      * the stack.\n      */\n \n-    debug!(\"trans(expr={})\", bcx.expr_to_str(expr));\n+    debug!(\"trans(expr={})\", bcx.expr_to_string(expr));\n \n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n@@ -178,7 +178,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         Some(adj) => { adj }\n     };\n     debug!(\"unadjusted datum for expr {}: {}\",\n-           expr.id, datum.to_str(bcx.ccx()));\n+           expr.id, datum.to_string(bcx.ccx()));\n     match adjustment {\n         AutoAddEnv(..) => {\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n@@ -216,7 +216,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n             datum = scratch.to_expr_datum();\n         }\n     }\n-    debug!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n+    debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n     fn auto_slice<'a>(\n@@ -325,7 +325,7 @@ fn trans_unadjusted<'a>(bcx: &'a Block<'a>,\n \n     let mut bcx = bcx;\n \n-    debug!(\"trans_unadjusted(expr={})\", bcx.expr_to_str(expr));\n+    debug!(\"trans_unadjusted(expr={})\", bcx.expr_to_string(expr));\n     let _indenter = indenter();\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n@@ -545,8 +545,8 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n \n             let (base, len) = base_datum.get_vec_base_and_len(bcx);\n \n-            debug!(\"trans_index: base {}\", bcx.val_to_str(base));\n-            debug!(\"trans_index: len {}\", bcx.val_to_str(len));\n+            debug!(\"trans_index: base {}\", bcx.val_to_string(base));\n+            debug!(\"trans_index: len {}\", bcx.val_to_string(len));\n \n             let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n@@ -780,7 +780,7 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             let expr_ty = expr_ty(bcx, expr);\n             let store = ty::ty_closure_store(expr_ty);\n             debug!(\"translating block function {} with type {}\",\n-                   expr_to_str(expr), expr_ty.repr(tcx));\n+                   expr_to_string(expr), expr_ty.repr(tcx));\n             closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {\n@@ -893,7 +893,7 @@ fn trans_def_dps_unadjusted<'a>(\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n                 \"Non-DPS def {:?} referened by {}\",\n-                def, bcx.node_id_to_str(ref_expr.id)).as_slice());\n+                def, bcx.node_id_to_string(ref_expr.id)).as_slice());\n         }\n     }\n }\n@@ -974,7 +974,7 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n             }\n         };\n         debug!(\"take_local(nid={:?}, v={}, ty={})\",\n-               nid, bcx.val_to_str(datum.val), bcx.ty_to_str(datum.ty));\n+               nid, bcx.val_to_string(datum.val), bcx.ty_to_string(datum.ty));\n         datum\n     }\n }\n@@ -1462,13 +1462,13 @@ fn trans_binary<'a>(bcx: &'a Block<'a>,\n \n             debug!(\"trans_binary (expr {}): lhs_datum={}\",\n                    expr.id,\n-                   lhs_datum.to_str(ccx));\n+                   lhs_datum.to_string(ccx));\n             let lhs_ty = lhs_datum.ty;\n             let lhs = lhs_datum.to_llscalarish(bcx);\n \n             debug!(\"trans_binary (expr {}): rhs_datum={}\",\n                    expr.id,\n-                   rhs_datum.to_str(ccx));\n+                   rhs_datum.to_string(ccx));\n             let rhs_ty = rhs_datum.ty;\n             let rhs = rhs_datum.to_llscalarish(bcx);\n             trans_eager_binop(bcx, expr, binop_ty, op,\n@@ -1729,7 +1729,7 @@ fn trans_assign_op<'a>(\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n \n-    debug!(\"trans_assign_op(expr={})\", bcx.expr_to_str(expr));\n+    debug!(\"trans_assign_op(expr={})\", bcx.expr_to_string(expr));\n \n     // User-defined operator methods cannot be used with `+=` etc right now\n     assert!(!bcx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n@@ -1799,7 +1799,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n     debug!(\"deref_once(expr={}, datum={}, method_call={})\",\n            expr.repr(bcx.tcx()),\n-           datum.to_str(ccx),\n+           datum.to_string(ccx),\n            method_call);\n \n     let mut bcx = bcx;\n@@ -1877,7 +1877,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n     };\n \n     debug!(\"deref_once(expr={}, method_call={}, result={})\",\n-           expr.id, method_call, r.datum.to_str(ccx));\n+           expr.id, method_call, r.datum.to_string(ccx));\n \n     return r;\n "}, {"sha": "0b12cd3da8254acc582fa84b204851de59c0056c", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -266,8 +266,8 @@ pub fn trans_native_call<'a>(\n             llfn={}, \\\n             llretptr={})\",\n            callee_ty.repr(tcx),\n-           ccx.tn.val_to_str(llfn),\n-           ccx.tn.val_to_str(llretptr));\n+           ccx.tn.val_to_string(llfn),\n+           ccx.tn.val_to_string(llretptr));\n \n     let (fn_abi, fn_sig) = match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n@@ -314,9 +314,9 @@ pub fn trans_native_call<'a>(\n \n         debug!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n                i,\n-               ccx.tn.val_to_str(llarg_rust),\n+               ccx.tn.val_to_string(llarg_rust),\n                rust_indirect,\n-               ccx.tn.type_to_str(arg_tys[i].ty));\n+               ccx.tn.type_to_string(arg_tys[i].ty));\n \n         // Ensure that we always have the Rust value indirectly,\n         // because it makes bitcasting easier.\n@@ -330,7 +330,7 @@ pub fn trans_native_call<'a>(\n         }\n \n         debug!(\"llarg_rust={} (after indirection)\",\n-               ccx.tn.val_to_str(llarg_rust));\n+               ccx.tn.val_to_string(llarg_rust));\n \n         // Check whether we need to do any casting\n         match arg_tys[i].cast {\n@@ -339,7 +339,7 @@ pub fn trans_native_call<'a>(\n         }\n \n         debug!(\"llarg_rust={} (after casting)\",\n-               ccx.tn.val_to_str(llarg_rust));\n+               ccx.tn.val_to_string(llarg_rust));\n \n         // Finally, load the value if needed for the foreign ABI\n         let foreign_indirect = arg_tys[i].is_indirect();\n@@ -355,7 +355,7 @@ pub fn trans_native_call<'a>(\n         };\n \n         debug!(\"argument {}, llarg_foreign={}\",\n-               i, ccx.tn.val_to_str(llarg_foreign));\n+               i, ccx.tn.val_to_string(llarg_foreign));\n \n         // fill padding with undef value\n         match arg_tys[i].pad {\n@@ -430,10 +430,10 @@ pub fn trans_native_call<'a>(\n             None => fn_type.ret_ty.ty\n         };\n \n-        debug!(\"llretptr={}\", ccx.tn.val_to_str(llretptr));\n-        debug!(\"llforeign_retval={}\", ccx.tn.val_to_str(llforeign_retval));\n-        debug!(\"llrust_ret_ty={}\", ccx.tn.type_to_str(llrust_ret_ty));\n-        debug!(\"llforeign_ret_ty={}\", ccx.tn.type_to_str(llforeign_ret_ty));\n+        debug!(\"llretptr={}\", ccx.tn.val_to_string(llretptr));\n+        debug!(\"llforeign_retval={}\", ccx.tn.val_to_string(llforeign_retval));\n+        debug!(\"llrust_ret_ty={}\", ccx.tn.type_to_string(llrust_ret_ty));\n+        debug!(\"llforeign_ret_ty={}\", ccx.tn.type_to_string(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n             base::store_ty(bcx, llforeign_retval, llretptr, fn_sig.output)\n@@ -538,7 +538,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let llfn = base::register_fn_llvmty(ccx, sp, sym, node_id, cconv, llfn_ty);\n     add_argument_attributes(&tys, llfn);\n     debug!(\"register_rust_fn_with_foreign_abi(node_id={:?}, llfn_ty={}, llfn={})\",\n-           node_id, ccx.tn.type_to_str(llfn_ty), ccx.tn.val_to_str(llfn));\n+           node_id, ccx.tn.type_to_string(llfn_ty), ccx.tn.val_to_string(llfn));\n     llfn\n }\n \n@@ -583,13 +583,13 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             _ => {\n                 ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                         expected a bare fn ty\",\n-                                       ccx.tcx.map.path_to_str(id),\n+                                       ccx.tcx.map.path_to_string(id),\n                                        t.repr(tcx)).as_slice());\n             }\n         };\n \n         debug!(\"build_rust_fn: path={} id={} t={}\",\n-               ccx.tcx.map.path_to_str(id),\n+               ccx.tcx.map.path_to_string(id),\n                id, t.repr(tcx));\n \n         let llfn = base::decl_internal_rust_fn(ccx, t, ps.as_slice());\n@@ -610,8 +610,8 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         let t = ty::node_id_to_type(tcx, id);\n \n         debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={}, t={})\",\n-               ccx.tn.val_to_str(llrustfn),\n-               ccx.tn.val_to_str(llwrapfn),\n+               ccx.tn.val_to_string(llrustfn),\n+               ccx.tn.val_to_string(llwrapfn),\n                t.repr(ccx.tcx()));\n \n         // Avoid all the Rust generation stuff and just generate raw\n@@ -668,11 +668,11 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             match foreign_outptr {\n                 Some(llforeign_outptr) => {\n                     debug!(\"out pointer, foreign={}\",\n-                           ccx.tn.val_to_str(llforeign_outptr));\n+                           ccx.tn.val_to_string(llforeign_outptr));\n                     let llrust_retptr =\n                         builder.bitcast(llforeign_outptr, llrust_ret_ty.ptr_to());\n                     debug!(\"out pointer, foreign={} (casted)\",\n-                           ccx.tn.val_to_str(llrust_retptr));\n+                           ccx.tn.val_to_string(llrust_retptr));\n                     llrust_args.push(llrust_retptr);\n                     return_alloca = None;\n                 }\n@@ -683,8 +683,8 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                             allocad={}, \\\n                             llrust_ret_ty={}, \\\n                             return_ty={}\",\n-                           ccx.tn.val_to_str(slot),\n-                           ccx.tn.type_to_str(llrust_ret_ty),\n+                           ccx.tn.val_to_string(slot),\n+                           ccx.tn.type_to_string(llrust_ret_ty),\n                            tys.fn_sig.output.repr(tcx));\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n@@ -712,7 +712,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             let mut llforeign_arg = llvm::LLVMGetParam(llwrapfn, foreign_index);\n \n             debug!(\"llforeign_arg {}{}: {}\", \"#\",\n-                   i, ccx.tn.val_to_str(llforeign_arg));\n+                   i, ccx.tn.val_to_string(llforeign_arg));\n             debug!(\"rust_indirect = {}, foreign_indirect = {}\",\n                    rust_indirect, foreign_indirect);\n \n@@ -751,12 +751,12 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             };\n \n             debug!(\"llrust_arg {}{}: {}\", \"#\",\n-                   i, ccx.tn.val_to_str(llrust_arg));\n+                   i, ccx.tn.val_to_string(llrust_arg));\n             llrust_args.push(llrust_arg);\n         }\n \n         // Perform the call itself\n-        debug!(\"calling llrustfn = {}, t = {}\", ccx.tn.val_to_str(llrustfn), t.repr(ccx.tcx()));\n+        debug!(\"calling llrustfn = {}, t = {}\", ccx.tn.val_to_string(llrustfn), t.repr(ccx.tcx()));\n         let attributes = base::get_fn_llvm_attributes(ccx, t);\n         let llrust_ret_val = builder.call(llrustfn, llrust_args.as_slice(), attributes.as_slice());\n \n@@ -876,9 +876,9 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n            ret_def={}\",\n            ty.repr(ccx.tcx()),\n            ccx.tn.types_to_str(llsig.llarg_tys.as_slice()),\n-           ccx.tn.type_to_str(llsig.llret_ty),\n+           ccx.tn.type_to_string(llsig.llret_ty),\n            ccx.tn.types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n-           ccx.tn.type_to_str(fn_ty.ret_ty.ty),\n+           ccx.tn.type_to_string(fn_ty.ret_ty.ty),\n            ret_def);\n \n     ForeignTypes {"}, {"sha": "4d9f004e3dcd111ea895016269df715a4b5f83ce", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -167,11 +167,11 @@ pub fn lazily_emit_visit_glue(ccx: &CrateContext, ti: &tydesc_info) -> ValueRef\n     match ti.visit_glue.get() {\n         Some(visit_glue) => visit_glue,\n         None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx(), ti.ty));\n+            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_string(ccx.tcx(), ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n             ti.visit_glue.set(Some(glue_fn));\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n-            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx(), ti.ty));\n+            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_string(ccx.tcx(), ti.ty));\n             glue_fn\n         }\n     }\n@@ -432,13 +432,13 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n \n     if ccx.sess().count_type_sizes() {\n         println!(\"{}\\t{}\", llsize_of_real(ccx, llty),\n-                 ppaux::ty_to_str(ccx.tcx(), t));\n+                 ppaux::ty_to_string(ccx.tcx(), t));\n     }\n \n     let llsize = llsize_of(ccx, llty);\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n-    debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx(), t), name);\n+    debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_string(ccx.tcx(), t), name);\n     let gvar = name.as_slice().with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type().to_ref(), buf)\n@@ -447,10 +447,10 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n     note_unique_llvm_symbol(ccx, name);\n \n     let ty_name = token::intern_and_get_ident(\n-        ppaux::ty_to_str(ccx.tcx(), t).as_slice());\n+        ppaux::ty_to_string(ccx.tcx(), t).as_slice());\n     let ty_name = C_str_slice(ccx, ty_name);\n \n-    debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx(), t));\n+    debug!(\"--- declare_tydesc {}\", ppaux::ty_to_string(ccx.tcx(), t));\n     tydesc_info {\n         ty: t,\n         tydesc: gvar,\n@@ -468,7 +468,7 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n         ccx,\n         t,\n         format!(\"glue_{}\", name).as_slice());\n-    debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx(), t));\n+    debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_string(ccx.tcx(), t));\n     let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil());\n     note_unique_llvm_symbol(ccx, fn_nm);\n     return llfn;"}, {"sha": "28bdc6852e8484f175ca5976689022c858dc0dbc", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -29,7 +29,7 @@ use middle::ty;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::parse::token;\n-use util::ppaux::ty_to_str;\n+use util::ppaux::ty_to_string;\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n     let name = match token::get_ident(item.ident).get() {\n@@ -398,10 +398,10 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n                     format!(\"transmute called on types with different sizes: \\\n                              {} ({} bit{}) to \\\n                              {} ({} bit{})\",\n-                            ty_to_str(ccx.tcx(), in_type),\n+                            ty_to_string(ccx.tcx(), in_type),\n                             in_type_size,\n                             if in_type_size == 1 {\"\"} else {\"s\"},\n-                            ty_to_str(ccx.tcx(), out_type),\n+                            ty_to_string(ccx.tcx(), out_type),\n                             out_type_size,\n                             if out_type_size == 1 {\"\"} else {\"s\"}).as_slice());\n             }\n@@ -587,14 +587,14 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                .span_err(transmute_restriction.span,\n                 format!(\"transmute called on types with different sizes: \\\n                          {} ({} bit{}) to {} ({} bit{})\",\n-                        ty_to_str(ccx.tcx(), transmute_restriction.from),\n+                        ty_to_string(ccx.tcx(), transmute_restriction.from),\n                         from_type_size as uint,\n                         if from_type_size == 1 {\n                             \"\"\n                         } else {\n                             \"s\"\n                         },\n-                        ty_to_str(ccx.tcx(), transmute_restriction.to),\n+                        ty_to_string(ccx.tcx(), transmute_restriction.to),\n                         to_type_size as uint,\n                         if to_type_size == 1 {\n                             \"\""}, {"sha": "f7884ca5643f76d5990c3bf2ae37ae8ef7f54ca9", "filename": "src/librustc/middle/trans/llrepr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -25,13 +25,13 @@ impl<'a, T:LlvmRepr> LlvmRepr for &'a [T] {\n \n impl LlvmRepr for Type {\n     fn llrepr(&self, ccx: &CrateContext) -> String {\n-        ccx.tn.type_to_str(*self)\n+        ccx.tn.type_to_string(*self)\n     }\n }\n \n impl LlvmRepr for ValueRef {\n     fn llrepr(&self, ccx: &CrateContext) -> String {\n-        ccx.tn.val_to_str(*self)\n+        ccx.tn.val_to_string(*self)\n     }\n }\n "}, {"sha": "e50eb8f0be99353c77e94f67535404414401f733", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -23,7 +23,7 @@ use middle::trans::meth;\n use middle::trans::type_::Type;\n use middle::trans::type_of::*;\n use middle::ty;\n-use util::ppaux::ty_to_str;\n+use util::ppaux::ty_to_string;\n \n use std::rc::Rc;\n use arena::TypedArena;\n@@ -98,7 +98,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n         debug!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n         for (i, a) in args.iter().enumerate() {\n-            debug!(\"arg {}: {}\", i, bcx.val_to_str(*a));\n+            debug!(\"arg {}: {}\", i, bcx.val_to_string(*a));\n         }\n         let result = unpack_result!(bcx, callee::trans_call_inner(\n             self.bcx, None, mth_ty,\n@@ -129,7 +129,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n     pub fn visit_ty(&mut self, t: ty::t) {\n         let bcx = self.bcx;\n         let tcx = bcx.tcx();\n-        debug!(\"reflect::visit_ty {}\", ty_to_str(bcx.tcx(), t));\n+        debug!(\"reflect::visit_ty {}\", ty_to_string(bcx.tcx(), t));\n \n         match ty::get(t).sty {\n           ty::ty_bot => self.leaf(\"bot\"),\n@@ -175,7 +175,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                   ty::ty_trait(..) => {\n                       let extra = [\n                           self.c_slice(token::intern_and_get_ident(\n-                                  ty_to_str(tcx, t).as_slice()))\n+                                  ty_to_string(tcx, t).as_slice()))\n                       ];\n                       self.visit(\"trait\", extra);\n                   }\n@@ -204,7 +204,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                   ty::ty_trait(..) => {\n                       let extra = [\n                           self.c_slice(token::intern_and_get_ident(\n-                                  ty_to_str(tcx, t).as_slice()))\n+                                  ty_to_string(tcx, t).as_slice()))\n                       ];\n                       self.visit(\"trait\", extra);\n                   }\n@@ -269,7 +269,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n \n               let extra = (vec!(\n                   self.c_slice(\n-                      token::intern_and_get_ident(ty_to_str(tcx,\n+                      token::intern_and_get_ident(ty_to_string(tcx,\n                                                             t).as_slice())),\n                   self.c_bool(named_fields),\n                   self.c_uint(fields.len())"}, {"sha": "a6e554039e77e6ff9f12d2178830577491d9739b", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -29,7 +29,7 @@ use middle::trans::machine::{llsize_of, nonzero_llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n-use util::ppaux::ty_to_str;\n+use util::ppaux::ty_to_string;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -73,12 +73,12 @@ pub struct VecTypes {\n }\n \n impl VecTypes {\n-    pub fn to_str(&self, ccx: &CrateContext) -> String {\n+    pub fn to_string(&self, ccx: &CrateContext) -> String {\n         format!(\"VecTypes {{unit_ty={}, llunit_ty={}, \\\n                  llunit_size={}, llunit_alloc_size={}}}\",\n-                ty_to_str(ccx.tcx(), self.unit_ty),\n-                ccx.tn.type_to_str(self.llunit_ty),\n-                ccx.tn.val_to_str(self.llunit_size),\n+                ty_to_string(ccx.tcx(), self.unit_ty),\n+                ccx.tn.type_to_string(self.llunit_ty),\n+                ccx.tn.val_to_string(self.llunit_size),\n                 self.llunit_alloc_size)\n     }\n }\n@@ -97,7 +97,7 @@ pub fn trans_fixed_vstore<'a>(\n     // generate the content.\n \n     debug!(\"trans_fixed_vstore(vstore_expr={}, dest={:?})\",\n-           bcx.expr_to_str(vstore_expr), dest.to_str(bcx.ccx()));\n+           bcx.expr_to_string(vstore_expr), dest.to_string(bcx.ccx()));\n \n     let vt = vec_types_from_expr(bcx, vstore_expr);\n \n@@ -129,7 +129,7 @@ pub fn trans_slice_vstore<'a>(\n     let mut bcx = bcx;\n \n     debug!(\"trans_slice_vstore(vstore_expr={}, dest={})\",\n-           bcx.expr_to_str(vstore_expr), dest.to_str(ccx));\n+           bcx.expr_to_string(vstore_expr), dest.to_string(ccx));\n \n     // Handle the &\"...\" case:\n     match content_expr.node {\n@@ -150,7 +150,7 @@ pub fn trans_slice_vstore<'a>(\n     // Handle the &[...] case:\n     let vt = vec_types_from_expr(bcx, vstore_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug!(\"vt={}, count={:?}\", vt.to_str(ccx), count);\n+    debug!(\"vt={}, count={:?}\", vt.to_string(ccx), count);\n \n     let llcount = C_uint(ccx, count);\n     let llfixed;\n@@ -202,8 +202,8 @@ pub fn trans_lit_str<'a>(\n      */\n \n     debug!(\"trans_lit_str(lit_expr={}, dest={})\",\n-           bcx.expr_to_str(lit_expr),\n-           dest.to_str(bcx.ccx()));\n+           bcx.expr_to_string(lit_expr),\n+           dest.to_string(bcx.ccx()));\n \n     match dest {\n         Ignore => bcx,\n@@ -233,7 +233,7 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n      * the array elements into them.\n      */\n \n-    debug!(\"trans_uniq_vstore(vstore_expr={})\", bcx.expr_to_str(vstore_expr));\n+    debug!(\"trans_uniq_vstore(vstore_expr={})\", bcx.expr_to_string(vstore_expr));\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n@@ -297,7 +297,7 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n     let dataptr = get_dataptr(bcx, val);\n \n     debug!(\"alloc_uniq_vec() returned val={}, dataptr={}\",\n-           bcx.val_to_str(val), bcx.val_to_str(dataptr));\n+           bcx.val_to_string(val), bcx.val_to_string(dataptr));\n \n     let bcx = write_content(bcx, &vt, vstore_expr,\n                             content_expr, SaveIn(dataptr));\n@@ -319,9 +319,9 @@ pub fn write_content<'a>(\n     let mut bcx = bcx;\n \n     debug!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n-           vt.to_str(bcx.ccx()),\n-           dest.to_str(bcx.ccx()),\n-           bcx.expr_to_str(vstore_expr));\n+           vt.to_string(bcx.ccx()),\n+           dest.to_string(bcx.ccx()),\n+           bcx.expr_to_string(vstore_expr));\n \n     match content_expr.node {\n         ast::ExprLit(lit) => {\n@@ -361,7 +361,7 @@ pub fn write_content<'a>(\n                     for (i, element) in elements.iter().enumerate() {\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n                         debug!(\"writing index {:?} with lleltptr={:?}\",\n-                               i, bcx.val_to_str(lleltptr));\n+                               i, bcx.val_to_string(lleltptr));\n                         bcx = expr::trans_into(bcx, &**element,\n                                                SaveIn(lleltptr));\n                         fcx.schedule_drop_mem("}, {"sha": "50c81596edffe9ac1145979f97804c934131c217", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -199,7 +199,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n                 t,\n                 t_norm.repr(cx.tcx()),\n                 t_norm,\n-                cx.tn.type_to_str(llty));\n+                cx.tn.type_to_string(llty));\n         cx.lltypes.borrow_mut().insert(t, llty);\n         return llty;\n     }\n@@ -291,7 +291,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     debug!(\"--> mapped t={} {:?} to llty={}\",\n             t.repr(cx.tcx()),\n             t,\n-            cx.tn.type_to_str(llty));\n+            cx.tn.type_to_string(llty));\n \n     cx.lltypes.borrow_mut().insert(t, llty);\n "}, {"sha": "f9eda70d16ef201e94efd0312ab9a5a3e9369fd7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -32,8 +32,8 @@ use middle::typeck::MethodCall;\n use middle::ty_fold;\n use middle::ty_fold::{TypeFoldable,TypeFolder};\n use middle;\n-use util::ppaux::{note_and_explain_region, bound_region_ptr_to_str};\n-use util::ppaux::{trait_store_to_str, ty_to_str};\n+use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n+use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet, FnvHashMap};\n@@ -2243,26 +2243,26 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n     fn type_requires(cx: &ctxt, seen: &mut Vec<DefId>,\n                      r_ty: t, ty: t) -> bool {\n         debug!(\"type_requires({}, {})?\",\n-               ::util::ppaux::ty_to_str(cx, r_ty),\n-               ::util::ppaux::ty_to_str(cx, ty));\n+               ::util::ppaux::ty_to_string(cx, r_ty),\n+               ::util::ppaux::ty_to_string(cx, ty));\n \n         let r = {\n             get(r_ty).sty == get(ty).sty ||\n                 subtypes_require(cx, seen, r_ty, ty)\n         };\n \n         debug!(\"type_requires({}, {})? {}\",\n-               ::util::ppaux::ty_to_str(cx, r_ty),\n-               ::util::ppaux::ty_to_str(cx, ty),\n+               ::util::ppaux::ty_to_string(cx, r_ty),\n+               ::util::ppaux::ty_to_string(cx, ty),\n                r);\n         return r;\n     }\n \n     fn subtypes_require(cx: &ctxt, seen: &mut Vec<DefId>,\n                         r_ty: t, ty: t) -> bool {\n         debug!(\"subtypes_require({}, {})?\",\n-               ::util::ppaux::ty_to_str(cx, r_ty),\n-               ::util::ppaux::ty_to_str(cx, ty));\n+               ::util::ppaux::ty_to_string(cx, r_ty),\n+               ::util::ppaux::ty_to_string(cx, ty));\n \n         let r = match get(ty).sty {\n             // fixed length vectors need special treatment compared to\n@@ -2337,8 +2337,8 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n         };\n \n         debug!(\"subtypes_require({}, {})? {}\",\n-               ::util::ppaux::ty_to_str(cx, r_ty),\n-               ::util::ppaux::ty_to_str(cx, ty),\n+               ::util::ppaux::ty_to_string(cx, r_ty),\n+               ::util::ppaux::ty_to_string(cx, ty),\n                r);\n \n         return r;\n@@ -2381,7 +2381,7 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n     fn type_structurally_recursive(cx: &ctxt, sp: Span, seen: &mut Vec<DefId>,\n                                    ty: t) -> Representability {\n         debug!(\"type_structurally_recursive: {}\",\n-               ::util::ppaux::ty_to_str(cx, ty));\n+               ::util::ppaux::ty_to_string(cx, ty));\n \n         // Compare current type to previously seen types\n         match get(ty).sty {\n@@ -2441,7 +2441,7 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n     }\n \n     debug!(\"is_type_representable: {}\",\n-           ::util::ppaux::ty_to_str(cx, ty));\n+           ::util::ppaux::ty_to_string(cx, ty));\n \n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack\n@@ -2595,7 +2595,7 @@ pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n         Some(t) => t.clone(),\n         None => cx.sess.bug(\n             format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-                    cx.map.node_to_str(id)).as_slice())\n+                    cx.map.node_to_string(id)).as_slice())\n     }\n }\n \n@@ -2608,7 +2608,7 @@ pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n        Some(t) => t,\n        None => cx.sess.bug(\n            format!(\"node_id_to_type: no type for node `{}`\",\n-                   cx.map.node_to_str(id)).as_slice())\n+                   cx.map.node_to_string(id)).as_slice())\n     }\n }\n \n@@ -2842,7 +2842,7 @@ pub fn adjust_ty(cx: &ctxt,\n                                         format!(\"the {}th autoderef failed: \\\n                                                 {}\",\n                                                 i,\n-                                                ty_to_str(cx, adjusted_ty))\n+                                                ty_to_string(cx, adjusted_ty))\n                                                           .as_slice());\n                                 }\n                             }\n@@ -3220,11 +3220,11 @@ pub fn param_tys_in_type(ty: t) -> Vec<ParamTy> {\n     rslt\n }\n \n-pub fn ty_sort_str(cx: &ctxt, t: t) -> String {\n+pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n     match get(t).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n         ty_uint(_) | ty_float(_) | ty_str => {\n-            ::util::ppaux::ty_to_str(cx, t)\n+            ::util::ppaux::ty_to_string(cx, t)\n         }\n \n         ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n@@ -3277,18 +3277,18 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n         terr_mismatch => \"types differ\".to_string(),\n         terr_fn_style_mismatch(values) => {\n             format!(\"expected {} fn but found {} fn\",\n-                    values.expected.to_str(),\n-                    values.found.to_str())\n+                    values.expected.to_string(),\n+                    values.found.to_string())\n         }\n         terr_abi_mismatch(values) => {\n             format!(\"expected {} fn but found {} fn\",\n-                    values.expected.to_str(),\n-                    values.found.to_str())\n+                    values.expected.to_string(),\n+                    values.found.to_string())\n         }\n         terr_onceness_mismatch(values) => {\n             format!(\"expected {} fn but found {} fn\",\n-                    values.expected.to_str(),\n-                    values.found.to_str())\n+                    values.expected.to_string(),\n+                    values.found.to_string())\n         }\n         terr_sigil_mismatch(values) => {\n             format!(\"expected {}, found {}\",\n@@ -3344,22 +3344,22 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n         terr_regions_insufficiently_polymorphic(br, _) => {\n             format!(\"expected bound lifetime parameter {}, \\\n                      but found concrete lifetime\",\n-                    bound_region_ptr_to_str(cx, br))\n+                    bound_region_ptr_to_string(cx, br))\n         }\n         terr_regions_overly_polymorphic(br, _) => {\n             format!(\"expected concrete lifetime, \\\n                      but found bound lifetime parameter {}\",\n-                    bound_region_ptr_to_str(cx, br))\n+                    bound_region_ptr_to_string(cx, br))\n         }\n         terr_trait_stores_differ(_, ref values) => {\n             format!(\"trait storage differs: expected `{}` but found `{}`\",\n-                    trait_store_to_str(cx, (*values).expected),\n-                    trait_store_to_str(cx, (*values).found))\n+                    trait_store_to_string(cx, (*values).expected),\n+                    trait_store_to_string(cx, (*values).found))\n         }\n         terr_sorts(values) => {\n             format!(\"expected {} but found {}\",\n-                    ty_sort_str(cx, values.expected),\n-                    ty_sort_str(cx, values.found))\n+                    ty_sort_string(cx, values.expected),\n+                    ty_sort_string(cx, values.found))\n         }\n         terr_traits(values) => {\n             format!(\"expected trait `{}` but found trait `{}`\",\n@@ -3384,13 +3384,13 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n         }\n         terr_int_mismatch(ref values) => {\n             format!(\"expected `{}` but found `{}`\",\n-                    values.expected.to_str(),\n-                    values.found.to_str())\n+                    values.expected.to_string(),\n+                    values.found.to_string())\n         }\n         terr_float_mismatch(ref values) => {\n             format!(\"expected `{}` but found `{}`\",\n-                    values.expected.to_str(),\n-                    values.found.to_str())\n+                    values.expected.to_string(),\n+                    values.found.to_string())\n         }\n         terr_variadic_mismatch(ref values) => {\n             format!(\"expected {} fn but found {} function\",\n@@ -3701,7 +3701,7 @@ pub fn substd_enum_variants(cx: &ctxt,\n }\n \n pub fn item_path_str(cx: &ctxt, id: ast::DefId) -> String {\n-    with_path(cx, id, |path| ast_map::path_to_str(path)).to_string()\n+    with_path(cx, id, |path| ast_map::path_to_string(path)).to_string()\n }\n \n pub enum DtorKind {\n@@ -3973,7 +3973,7 @@ fn each_super_struct(cx: &ctxt, mut did: ast::DefId, f: |ast::DefId|) {\n             None => {\n                 cx.sess.bug(\n                     format!(\"ID not mapped to super-struct: {}\",\n-                            cx.map.node_to_str(did.node)).as_slice());\n+                            cx.map.node_to_string(did.node)).as_slice());\n             }\n         }\n     }\n@@ -3995,7 +3995,7 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n                 _ => {\n                     cx.sess.bug(\n                         format!(\"ID not mapped to struct fields: {}\",\n-                                cx.map.node_to_str(did.node)).as_slice());\n+                                cx.map.node_to_string(did.node)).as_slice());\n                 }\n             }\n         });\n@@ -4621,7 +4621,7 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n }\n \n impl Variance {\n-    pub fn to_str(self) -> &'static str {\n+    pub fn to_string(self) -> &'static str {\n         match self {\n             Covariant => \"+\",\n             Contravariant => \"-\","}, {"sha": "d565f144f36567cc4231239605d627928b1bd643", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -66,7 +66,7 @@ use syntax::abi;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::owned_slice::OwnedSlice;\n-use syntax::print::pprust::{lifetime_to_str, path_to_str};\n+use syntax::print::pprust::{lifetime_to_string, path_to_string};\n \n pub trait AstConv {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n@@ -108,7 +108,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n     };\n \n     debug!(\"ast_region_to_region(lifetime={} id={}) yields {}\",\n-            lifetime_to_str(lifetime),\n+            lifetime_to_string(lifetime),\n             lifetime.id, r.repr(tcx));\n \n     r\n@@ -142,7 +142,7 @@ pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n     };\n \n     debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {}\",\n-            opt_lifetime.as_ref().map(|e| lifetime_to_str(e)),\n+            opt_lifetime.as_ref().map(|e| lifetime_to_string(e)),\n             r.repr(this.tcx()));\n \n     r\n@@ -331,7 +331,7 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n                                       format!(\"unbound path {}\",\n-                                              path_to_str(path)).as_slice())\n+                                              path_to_string(path)).as_slice())\n                 }\n                 Some(&d) => d\n             };\n@@ -394,7 +394,7 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n                         .sess\n                         .span_bug(ast_ty.span,\n                                   format!(\"unbound path {}\",\n-                                          path_to_str(path)).as_slice())\n+                                          path_to_string(path)).as_slice())\n                 }\n                 Some(&d) => d\n             };\n@@ -793,7 +793,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n                                      format!(\"unbound path {}\",\n-                                             path_to_str(path)).as_slice())\n+                                             path_to_string(path)).as_slice())\n                     }\n                     Some(&d) => d\n                 };\n@@ -808,7 +808,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 }\n                 match a_def {\n                     def::DefTrait(_) => {\n-                        let path_str = path_to_str(path);\n+                        let path_str = path_to_string(path);\n                         tcx.sess.span_err(\n                             ast_ty.span,\n                             format!(\"reference to trait `{name}` where a \\\n@@ -835,7 +835,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     def::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                             format!(\"found module name used as a type: {}\",\n-                                    tcx.map.node_to_str(id.node)).as_slice());\n+                                    tcx.map.node_to_string(id.node)).as_slice());\n                     }\n                     def::DefPrimTy(_) => {\n                         fail!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");"}, {"sha": "2232cc4965785fcab7d6aa3b4f787a27c6665c48", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -399,11 +399,11 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                     variant_id, substitutions, etc);\n         }\n         Some(&def::DefStruct(..)) | Some(&def::DefVariant(..)) => {\n-            let name = pprust::path_to_str(path);\n+            let name = pprust::path_to_string(path);\n             tcx.sess.span_err(span,\n                               format!(\"mismatched types: expected `{}` but \\\n                                        found `{}`\",\n-                                      fcx.infcx().ty_to_str(expected),\n+                                      fcx.infcx().ty_to_string(expected),\n                                       name).as_slice());\n         }\n         _ => {\n@@ -525,9 +525,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                        .span_err(path.span,\n                                  format!(\"`{}` does not name the \\\n                                           structure `{}`\",\n-                                         pprust::path_to_str(path),\n+                                         pprust::path_to_string(path),\n                                          fcx.infcx()\n-                                            .ty_to_str(expected)).as_slice())\n+                                            .ty_to_string(expected)).as_slice())\n                 }\n \n                 check_struct_pat(pcx, pat.id, pat.span, expected, path,\n@@ -747,7 +747,7 @@ fn check_pointer_pat(pcx: &pat_ctxt,\n                 tcx.sess.span_err(\n                     span,\n                     format!(\"type `{}` cannot be dereferenced\",\n-                            fcx.infcx().ty_to_str(expected)).as_slice());\n+                            fcx.infcx().ty_to_string(expected)).as_slice());\n                 fcx.write_error(pat_id);\n             }\n             _ => {"}, {"sha": "c1a000841a4d1f4cfb274c2ead2798896d6279d8", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -30,14 +30,14 @@ itself (note that inherent impls can only be defined in the same\n module as the type itself).\n \n Inherent candidates are not always derived from impls.  If you have a\n-trait instance, such as a value of type `Box<ToStr>`, then the trait\n-methods (`to_str()`, in this case) are inherently associated with it.\n+trait instance, such as a value of type `Box<ToString>`, then the trait\n+methods (`to_string()`, in this case) are inherently associated with it.\n Another case is type parameters, in which case the methods of their\n bounds are inherent.\n \n Extension candidates are derived from imported traits.  If I have the\n-trait `ToStr` imported, and I call `to_str()` on a value of type `T`,\n-then we will go off to find out whether there is an impl of `ToStr`\n+trait `ToString` imported, and I call `to_string()` on a value of type `T`,\n+then we will go off to find out whether there is an impl of `ToString`\n for `T`.  These kinds of method calls are called \"extension methods\".\n They can be defined in any module, not only the one that defined `T`.\n Furthermore, you must import the trait to call such a method.\n@@ -376,7 +376,7 @@ impl<'a> LookupContext<'a> {\n                    autoderefs: uint)\n                    -> Option<Option<MethodCallee>> {\n         debug!(\"search_step: self_ty={} autoderefs={}\",\n-               self.ty_to_str(self_ty), autoderefs);\n+               self.ty_to_string(self_ty), autoderefs);\n \n         match self.deref_args {\n             check::DontDerefArgs => {\n@@ -508,7 +508,7 @@ impl<'a> LookupContext<'a> {\n                                             did: DefId,\n                                             substs: &subst::Substs) {\n         debug!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n-               self.did_to_str(did),\n+               self.did_to_string(did),\n                substs.repr(self.tcx()));\n         let _indenter = indenter();\n         let tcx = self.tcx();\n@@ -733,7 +733,7 @@ impl<'a> LookupContext<'a> {\n             None => None,\n             Some(method) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n-                       adjustment {:?} for {}\", adjustment, self.ty_to_str( self_ty));\n+                       adjustment {:?} for {}\", adjustment, self.ty_to_string( self_ty));\n                 match adjustment {\n                     Some((self_expr_id, adj)) => {\n                         self.fcx.write_adjustment(self_expr_id, adj);\n@@ -809,7 +809,7 @@ impl<'a> LookupContext<'a> {\n \n     fn auto_slice_vec(&self, mt: ty::mt, autoderefs: uint) -> Option<MethodCallee> {\n         let tcx = self.tcx();\n-        debug!(\"auto_slice_vec {}\", ppaux::ty_to_str(tcx, mt.ty));\n+        debug!(\"auto_slice_vec {}\", ppaux::ty_to_string(tcx, mt.ty));\n \n         // First try to borrow to a slice\n         let entry = self.search_for_some_kind_of_autorefd_method(\n@@ -886,7 +886,7 @@ impl<'a> LookupContext<'a> {\n          * `~[]` to `&[]`.\n          */\n \n-        debug!(\"search_for_autosliced_method {}\", ppaux::ty_to_str(self.tcx(), self_ty));\n+        debug!(\"search_for_autosliced_method {}\", ppaux::ty_to_string(self.tcx(), self_ty));\n \n         let sty = ty::get(self_ty).sty.clone();\n         match sty {\n@@ -939,7 +939,7 @@ impl<'a> LookupContext<'a> {\n \n             ty_infer(TyVar(_)) => {\n                 self.bug(format!(\"unexpected type: {}\",\n-                                 self.ty_to_str(self_ty)).as_slice());\n+                                 self.ty_to_string(self_ty)).as_slice());\n             }\n         }\n     }\n@@ -993,7 +993,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn search_for_method(&self, rcvr_ty: ty::t) -> Option<MethodCallee> {\n-        debug!(\"search_for_method(rcvr_ty={})\", self.ty_to_str(rcvr_ty));\n+        debug!(\"search_for_method(rcvr_ty={})\", self.ty_to_string(rcvr_ty));\n         let _indenter = indenter();\n \n         // I am not sure that inherent methods should have higher\n@@ -1094,7 +1094,7 @@ impl<'a> LookupContext<'a> {\n         let tcx = self.tcx();\n \n         debug!(\"confirm_candidate(rcvr_ty={}, candidate={})\",\n-               self.ty_to_str(rcvr_ty),\n+               self.ty_to_string(rcvr_ty),\n                candidate.repr(self.tcx()));\n \n         self.enforce_object_limitations(candidate);\n@@ -1177,7 +1177,7 @@ impl<'a> LookupContext<'a> {\n             fn_style: bare_fn_ty.fn_style,\n             abi: bare_fn_ty.abi.clone(),\n         });\n-        debug!(\"after replacing bound regions, fty={}\", self.ty_to_str(fty));\n+        debug!(\"after replacing bound regions, fty={}\", self.ty_to_string(fty));\n \n         // Before, we only checked whether self_ty could be a subtype\n         // of rcvr_ty; now we actually make it so (this may cause\n@@ -1191,8 +1191,8 @@ impl<'a> LookupContext<'a> {\n             Err(_) => {\n                 self.bug(format!(\n                         \"{} was a subtype of {} but now is not?\",\n-                        self.ty_to_str(rcvr_ty),\n-                        self.ty_to_str(transformed_self_ty)).as_slice());\n+                        self.ty_to_string(rcvr_ty),\n+                        self.ty_to_string(transformed_self_ty)).as_slice());\n             }\n         }\n \n@@ -1288,7 +1288,7 @@ impl<'a> LookupContext<'a> {\n     // candidate method's `self_ty`.\n     fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n         debug!(\"is_relevant(rcvr_ty={}, candidate={})\",\n-               self.ty_to_str(rcvr_ty), candidate.repr(self.tcx()));\n+               self.ty_to_string(rcvr_ty), candidate.repr(self.tcx()));\n \n         return match candidate.method_ty.explicit_self {\n             SelfStatic => {\n@@ -1457,11 +1457,11 @@ impl<'a> LookupContext<'a> {\n         self.fcx.tcx()\n     }\n \n-    fn ty_to_str(&self, t: ty::t) -> String {\n-        self.fcx.infcx().ty_to_str(t)\n+    fn ty_to_string(&self, t: ty::t) -> String {\n+        self.fcx.infcx().ty_to_string(t)\n     }\n \n-    fn did_to_str(&self, did: DefId) -> String {\n+    fn did_to_string(&self, did: DefId) -> String {\n         ty::item_path_str(self.tcx(), did)\n     }\n "}, {"sha": "9f5fcb61f5fd0e9646416a7d13f12b9c1853376d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -397,8 +397,8 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n         };\n         self.assign(local.id, o_ty);\n         debug!(\"Local variable {} is assigned type {}\",\n-               self.fcx.pat_to_str(&*local.pat),\n-               self.fcx.infcx().ty_to_str(\n+               self.fcx.pat_to_string(&*local.pat),\n+               self.fcx.infcx().ty_to_string(\n                    self.fcx.inh.locals.borrow().get_copy(&local.id)));\n         visit::walk_local(self, local, ());\n     }\n@@ -411,7 +411,7 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n                 self.assign(p.id, None);\n                 debug!(\"Pattern binding {} is assigned to {}\",\n                        token::get_ident(path1.node),\n-                       self.fcx.infcx().ty_to_str(\n+                       self.fcx.infcx().ty_to_string(\n                            self.fcx.inh.locals.borrow().get_copy(&p.id)));\n               }\n               _ => {}\n@@ -534,7 +534,7 @@ fn span_for_field(tcx: &ty::ctxt, field: &ty::field_ty, struct_id: ast::DefId) -\n     let item = match tcx.map.find(struct_id.node) {\n         Some(ast_map::NodeItem(item)) => item,\n         None => fail!(\"node not in ast map: {}\", struct_id.node),\n-        _ => fail!(\"expected item, found {}\", tcx.map.node_to_str(struct_id.node))\n+        _ => fail!(\"expected item, found {}\", tcx.map.node_to_string(struct_id.node))\n     };\n \n     match item.node {\n@@ -803,7 +803,7 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n                     format!(\n                         \"method `{}` is not a member of trait `{}`\",\n                         token::get_ident(impl_method_ty.ident),\n-                        pprust::path_to_str(&ast_trait_ref.path)).as_slice());\n+                        pprust::path_to_string(&ast_trait_ref.path)).as_slice());\n             }\n         }\n     }\n@@ -870,7 +870,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                 format!(\"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n                         token::get_ident(trait_m.ident),\n-                        pprust::explicit_self_to_str(\n+                        pprust::explicit_self_to_string(\n                             impl_m.explicit_self)).as_slice());\n             return;\n         }\n@@ -880,7 +880,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                 format!(\"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n                         token::get_ident(trait_m.ident),\n-                        pprust::explicit_self_to_str(\n+                        pprust::explicit_self_to_string(\n                             trait_m.explicit_self)).as_slice());\n             return;\n         }\n@@ -1051,7 +1051,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                                            declaration\",\n                                           token::get_ident(trait_m.ident),\n                                           i,\n-                                          ppaux::trait_ref_to_str(\n+                                          ppaux::trait_ref_to_string(\n                                               tcx,\n                                               &*impl_trait_bound)).as_slice())\n             }\n@@ -1101,8 +1101,8 @@ fn check_cast(fcx: &FnCtxt,\n \n     let t_e = fcx.expr_ty(e);\n \n-    debug!(\"t_1={}\", fcx.infcx().ty_to_str(t_1));\n-    debug!(\"t_e={}\", fcx.infcx().ty_to_str(t_e));\n+    debug!(\"t_1={}\", fcx.infcx().ty_to_string(t_1));\n+    debug!(\"t_e={}\", fcx.infcx().ty_to_string(t_e));\n \n     if ty::type_is_error(t_e) {\n         fcx.write_error(id);\n@@ -1126,13 +1126,13 @@ fn check_cast(fcx: &FnCtxt,\n         fcx.type_error_message(span, |actual| {\n             format!(\"cast from nil: `{}` as `{}`\",\n                     actual,\n-                    fcx.infcx().ty_to_str(t_1))\n+                    fcx.infcx().ty_to_string(t_1))\n         }, t_e, None);\n     } else if ty::type_is_nil(t_1) {\n         fcx.type_error_message(span, |actual| {\n             format!(\"cast to nil: `{}` as `{}`\",\n                     actual,\n-                    fcx.infcx().ty_to_str(t_1))\n+                    fcx.infcx().ty_to_string(t_1))\n         }, t_e, None);\n     }\n \n@@ -1149,7 +1149,7 @@ fn check_cast(fcx: &FnCtxt,\n                 format!(\"illegal cast; cast through an \\\n                          integer first: `{}` as `{}`\",\n                         actual,\n-                        fcx.infcx().ty_to_str(t_1))\n+                        fcx.infcx().ty_to_string(t_1))\n             }, t_e, None);\n         }\n         // casts from C-like enums are allowed\n@@ -1217,7 +1217,7 @@ fn check_cast(fcx: &FnCtxt,\n         fcx.type_error_message(span, |actual| {\n             format!(\"non-scalar cast: `{}` as `{}`\",\n                     actual,\n-                    fcx.infcx().ty_to_str(t_1))\n+                    fcx.infcx().ty_to_string(t_1))\n         }, t_e, None);\n     }\n \n@@ -1286,7 +1286,7 @@ impl<'a> FnCtxt<'a> {\n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: ty::t) {\n         debug!(\"write_ty({}, {}) in fcx {}\",\n-               node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());\n+               node_id, ppaux::ty_to_string(self.tcx(), ty), self.tag());\n         self.inh.node_types.borrow_mut().insert(node_id, ty);\n     }\n \n@@ -1343,7 +1343,7 @@ impl<'a> FnCtxt<'a> {\n         ast_ty_to_ty(self, self.infcx(), ast_t)\n     }\n \n-    pub fn pat_to_str(&self, pat: &ast::Pat) -> String {\n+    pub fn pat_to_string(&self, pat: &ast::Pat) -> String {\n         pat.repr(self.tcx())\n     }\n \n@@ -1363,7 +1363,7 @@ impl<'a> FnCtxt<'a> {\n             None => {\n                 self.tcx().sess.bug(\n                     format!(\"no type for node {}: {} in fcx {}\",\n-                            id, self.tcx().map.node_to_str(id),\n+                            id, self.tcx().map.node_to_string(id),\n                             self.tag()).as_slice());\n             }\n         }\n@@ -1375,7 +1375,7 @@ impl<'a> FnCtxt<'a> {\n             None => {\n                 self.tcx().sess.bug(\n                     format!(\"no method entry for node {}: {} in fcx {}\",\n-                            id, self.tcx().map.node_to_str(id),\n+                            id, self.tcx().map.node_to_string(id),\n                             self.tag()).as_slice());\n             }\n         }\n@@ -1842,7 +1842,7 @@ fn check_argument_types(fcx: &FnCtxt,\n     };\n \n     debug!(\"check_argument_types: formal_tys={:?}\",\n-           formal_tys.iter().map(|t| fcx.infcx().ty_to_str(*t)).collect::<Vec<String>>());\n+           formal_tys.iter().map(|t| fcx.infcx().ty_to_string(*t)).collect::<Vec<String>>());\n \n     // Check the arguments.\n     // We do this in a pretty awful way: first we typecheck any arguments\n@@ -2410,7 +2410,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                              operation `{}` not \\\n                                              supported for floating \\\n                                              point SIMD vector `{}`\",\n-                                            ast_util::binop_to_str(op),\n+                                            ast_util::binop_to_string(op),\n                                             actual)\n                                 },\n                                 lhs_t,\n@@ -2440,7 +2440,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                    |actual| {\n                     format!(\"binary operation `{}` cannot be applied \\\n                              to type `{}`\",\n-                            ast_util::binop_to_str(op),\n+                            ast_util::binop_to_string(op),\n                             actual)\n                 },\n                 lhs_t,\n@@ -2457,7 +2457,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                  operation `{}=` \\\n                                                  cannot be applied to \\\n                                                  type `{}`\",\n-                                                ast_util::binop_to_str(op),\n+                                                ast_util::binop_to_string(op),\n                                                 actual)\n                                    },\n                                    lhs_t,\n@@ -2506,7 +2506,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                          trait_did, [lhs_expr, rhs], DontAutoderefReceiver, || {\n             fcx.type_error_message(ex.span, |actual| {\n                 format!(\"binary operation `{}` cannot be applied to type `{}`\",\n-                        ast_util::binop_to_str(op),\n+                        ast_util::binop_to_string(op),\n                         actual)\n             }, lhs_resolved_t, None)\n         })\n@@ -2594,7 +2594,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                            expected_sig);\n         let fty_sig = fn_ty.sig.clone();\n         let fty = ty::mk_closure(tcx, fn_ty);\n-        debug!(\"check_expr_fn fty={}\", fcx.infcx().ty_to_str(fty));\n+        debug!(\"check_expr_fn fty={}\", fcx.infcx().ty_to_string(fty));\n \n         fcx.write_ty(expr.id, fty);\n \n@@ -2628,7 +2628,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n                 match ty::get(base_t).sty {\n                     ty::ty_struct(base_id, ref substs) => {\n-                        debug!(\"struct named {}\", ppaux::ty_to_str(tcx, base_t));\n+                        debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n                         lookup_field_ty(tcx, base_id, fields.as_slice(),\n                                         field.node.name, &(*substs))\n@@ -3386,7 +3386,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         tcx.sess\n                            .span_err(path.span,\n                                      format!(\"`{}` does not name a structure\",\n-                                             pprust::path_to_str(\n+                                             pprust::path_to_string(\n                                                  path)).as_slice())\n                     }\n                 }\n@@ -3454,10 +3454,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     }\n \n     debug!(\"type of expr({}) {} is...\", expr.id,\n-           syntax::print::pprust::expr_to_str(expr));\n+           syntax::print::pprust::expr_to_string(expr));\n     debug!(\"... {}, expected is {}\",\n-           ppaux::ty_to_str(tcx, fcx.expr_ty(expr)),\n-           expected.repr(tcx))\n+           ppaux::ty_to_string(tcx, fcx.expr_ty(expr)),\n+           expected.repr(tcx));\n \n     unifier();\n }\n@@ -3792,7 +3792,7 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n                      format!(\"this type cannot be instantiated without an \\\n                               instance of itself; consider using \\\n                               `Option<{}>`\",\n-                             ppaux::ty_to_str(tcx, item_ty)).as_slice());\n+                             ppaux::ty_to_string(tcx, item_ty)).as_slice());\n         false\n     } else {\n         true\n@@ -3853,7 +3853,7 @@ pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n                                         dynamically sized types may only \\\n                                         appear as the final type in a \\\n                                         variant\",\n-                                       ppaux::ty_to_str(ccx.tcx,\n+                                       ppaux::ty_to_string(ccx.tcx,\n                                                         *t)).as_slice());\n                     }\n                 }\n@@ -3918,7 +3918,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n \n             match v.node.disr_expr {\n                 Some(e) => {\n-                    debug!(\"disr expr, checking {}\", pprust::expr_to_str(&*e));\n+                    debug!(\"disr expr, checking {}\", pprust::expr_to_string(&*e));\n \n                     let inh = blank_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n@@ -4522,7 +4522,7 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n                              tps: &OwnedSlice<ast::TyParam>,\n                              ty: ty::t) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={})\",\n-           tps.len(), ppaux::ty_to_str(ccx.tcx, ty));\n+           tps.len(), ppaux::ty_to_string(ccx.tcx, ty));\n \n     // make a vector of booleans initially false, set to true when used\n     if tps.len() == 0u { return; }\n@@ -4840,7 +4840,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                            fty,\n                            || {\n                 format!(\"intrinsic has wrong type: expected `{}`\",\n-                        ppaux::ty_to_str(ccx.tcx, fty))\n+                        ppaux::ty_to_string(ccx.tcx, fty))\n             });\n     }\n }"}, {"sha": "924934e4bcdc5e34eac00cc6af2f3b450e597988", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -133,7 +133,7 @@ use middle::typeck::infer;\n use middle::typeck::MethodCall;\n use middle::pat_util;\n use util::nodemap::NodeMap;\n-use util::ppaux::{ty_to_str, region_to_str, Repr};\n+use util::ppaux::{ty_to_string, region_to_string, Repr};\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -876,7 +876,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n     let r_deref_expr = ty::ReScope(deref_expr.id);\n     for i in range(0u, derefs) {\n         debug!(\"constrain_autoderefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n-               rcx.fcx.infcx().ty_to_str(derefd_ty),\n+               rcx.fcx.infcx().ty_to_string(derefd_ty),\n                i, derefs);\n \n         let method_call = MethodCall::autoderef(deref_expr.id, i);\n@@ -948,7 +948,7 @@ fn constrain_index(rcx: &mut Rcx,\n      */\n \n     debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n-           rcx.fcx.infcx().ty_to_str(indexed_ty));\n+           rcx.fcx.infcx().ty_to_string(indexed_ty));\n \n     let r_index_expr = ty::ReScope(index_expr.id);\n     match ty::get(indexed_ty).sty {\n@@ -984,7 +984,7 @@ fn constrain_regions_in_type_of_node(\n                            |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n-           ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n+           ty_to_string(tcx, ty), ty_to_string(tcx, ty0),\n            id, minimum_lifetime);\n     constrain_regions_in_type(rcx, minimum_lifetime, origin, ty);\n }\n@@ -1011,8 +1011,8 @@ fn constrain_regions_in_type(\n     let tcx = rcx.fcx.ccx.tcx;\n \n     debug!(\"constrain_regions_in_type(minimum_lifetime={}, ty={})\",\n-           region_to_str(tcx, \"\", false, minimum_lifetime),\n-           ty_to_str(tcx, ty));\n+           region_to_string(tcx, \"\", false, minimum_lifetime),\n+           ty_to_string(tcx, ty));\n \n     relate_nested_regions(tcx, Some(minimum_lifetime), ty, |r_sub, r_sup| {\n         debug!(\"relate_nested_regions(r_sub={}, r_sup={})\",\n@@ -1190,7 +1190,7 @@ fn link_region_from_node_type(rcx: &Rcx,\n     let rptr_ty = rcx.resolve_node_type(id);\n     if !ty::type_is_bot(rptr_ty) && !ty::type_is_error(rptr_ty) {\n         let tcx = rcx.fcx.ccx.tcx;\n-        debug!(\"rptr_ty={}\", ty_to_str(tcx, rptr_ty));\n+        debug!(\"rptr_ty={}\", ty_to_string(tcx, rptr_ty));\n         let r = ty::ty_region(tcx, span, rptr_ty);\n         link_region(rcx, span, r, ty::BorrowKind::from_mutbl(mutbl),\n                     cmt_borrowed);"}, {"sha": "53e26f8696f61fe9e2f964bef5d03e41fccb2e25", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -30,7 +30,7 @@ pub fn replace_late_bound_regions_in_fn_sig(\n     let mut map = HashMap::new();\n     let fn_sig = {\n         let mut f = ty_fold::RegionFolder::regions(tcx, |r| {\n-            debug!(\"region r={}\", r.to_str());\n+            debug!(\"region r={}\", r.to_string());\n             match r {\n                 ty::ReLateBound(s, br) if s == fn_sig.binder_id => {\n                     *map.find_or_insert_with(br, |_| mapf(br))\n@@ -153,7 +153,7 @@ pub fn relate_free_regions(tcx: &ty::ctxt, fn_sig: &ty::FnSig) {\n     }\n \n     for &t in all_tys.iter() {\n-        debug!(\"relate_free_regions(t={})\", ppaux::ty_to_str(tcx, t));\n+        debug!(\"relate_free_regions(t={})\", ppaux::ty_to_string(tcx, t));\n         relate_nested_regions(tcx, None, t, |a, b| {\n             match (&a, &b) {\n                 (&ty::ReFree(free_a), &ty::ReFree(free_b)) => {"}, {"sha": "d2a1ef786bd29f209ed1bba40cfa5dd3e5539cab", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -16,7 +16,7 @@ use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n use middle::typeck::check::writeback;\n-use middle::typeck::infer::fixup_err_to_str;\n+use middle::typeck::infer::fixup_err_to_string;\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n use middle::typeck::{vtable_origin, vtable_res, vtable_param_res};\n@@ -35,7 +35,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n-use syntax::print::pprust::expr_to_str;\n+use syntax::print::pprust::expr_to_string;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -154,8 +154,8 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n                 vcx.tcx().sess.span_fatal(span,\n                     format!(\"failed to find an implementation of \\\n                           trait {} for {}\",\n-                         vcx.infcx.trait_ref_to_str(&*trait_ref),\n-                         vcx.infcx.ty_to_str(ty)).as_slice());\n+                         vcx.infcx.trait_ref_to_string(&*trait_ref),\n+                         vcx.infcx.ty_to_string(ty)).as_slice());\n             }\n         }\n         true\n@@ -205,8 +205,8 @@ fn relate_trait_refs(vcx: &VtableContext,\n                 let tcx = vcx.tcx();\n                 tcx.sess.span_err(span,\n                     format!(\"expected {}, but found {} ({})\",\n-                            ppaux::trait_ref_to_str(tcx, &r_exp_trait_ref),\n-                            ppaux::trait_ref_to_str(tcx, &r_act_trait_ref),\n+                            ppaux::trait_ref_to_string(tcx, &r_exp_trait_ref),\n+                            ppaux::trait_ref_to_string(tcx, &r_act_trait_ref),\n                             ty::type_err_to_str(tcx, err)).as_slice());\n             }\n         }\n@@ -385,8 +385,8 @@ fn search_for_vtable(vcx: &VtableContext,\n \n         debug!(\"(checking vtable) num 2 relating trait \\\n                 ty {} to of_trait_ref {}\",\n-               vcx.infcx.trait_ref_to_str(&*trait_ref),\n-               vcx.infcx.trait_ref_to_str(&*of_trait_ref));\n+               vcx.infcx.trait_ref_to_string(&*trait_ref),\n+               vcx.infcx.trait_ref_to_string(&*of_trait_ref));\n \n         relate_trait_refs(vcx, span, of_trait_ref, trait_ref.clone());\n \n@@ -488,7 +488,7 @@ fn fixup_ty(vcx: &VtableContext,\n             tcx.sess.span_fatal(span,\n                 format!(\"cannot determine a type for this bounded type \\\n                          parameter: {}\",\n-                        fixup_err_to_str(e)).as_slice())\n+                        fixup_err_to_string(e)).as_slice())\n         }\n         Err(_) => {\n             None\n@@ -527,7 +527,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     }\n \n     debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n-           ex.id, is_early, expr_to_str(ex));\n+           ex.id, is_early, expr_to_string(ex));\n     let _indent = indenter();\n \n     let cx = fcx.ccx;\n@@ -626,7 +626,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                           ex.span,\n                           format!(\"can only cast an boxed pointer \\\n                                    to a boxed object, not a {}\",\n-                               ty::ty_sort_str(fcx.tcx(), src_ty)).as_slice());\n+                               ty::ty_sort_string(fcx.tcx(), src_ty)).as_slice());\n                   }\n                   _ => {}\n               }\n@@ -639,7 +639,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                           ex.span,\n                           format!(\"can only cast an &-pointer \\\n                                    to an &-object, not a {}\",\n-                                  ty::ty_sort_str(fcx.tcx(), src_ty)).as_slice());\n+                                  ty::ty_sort_string(fcx.tcx(), src_ty)).as_slice());\n                   }\n                   _ => {}\n               }\n@@ -657,7 +657,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n             let did = def.def_id();\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n-                   fcx.infcx().ty_to_str(item_ty.ty));\n+                   fcx.infcx().ty_to_string(item_ty.ty));\n             debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n                    item_ty.generics.types.repr(fcx.tcx()));\n             let vcx = fcx.vtable_context();"}, {"sha": "59b65fdbec790231b0b999bf282a642c21834278", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -31,7 +31,7 @@ use std::cell::Cell;\n \n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::print::pprust::pat_to_str;\n+use syntax::print::pprust::pat_to_string;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -159,7 +159,7 @@ impl<'cx> Visitor<()> for WritebackCx<'cx> {\n         self.visit_node_id(ResolvingPattern(p.span), p.id);\n \n         debug!(\"Type for pattern binding {} (id {}) resolved to {}\",\n-               pat_to_str(p),\n+               pat_to_string(p),\n                p.id,\n                ty::node_id_to_type(self.tcx(), p.id).repr(self.tcx()));\n \n@@ -403,23 +403,23 @@ impl<'cx> Resolver<'cx> {\n                         span,\n                         format!(\"cannot determine a type for \\\n                                  this expression: {}\",\n-                                infer::fixup_err_to_str(e)).as_slice())\n+                                infer::fixup_err_to_string(e)).as_slice())\n                 }\n \n                 ResolvingLocal(span) => {\n                     self.tcx.sess.span_err(\n                         span,\n                         format!(\"cannot determine a type for \\\n                                  this local variable: {}\",\n-                                infer::fixup_err_to_str(e)).as_slice())\n+                                infer::fixup_err_to_string(e)).as_slice())\n                 }\n \n                 ResolvingPattern(span) => {\n                     self.tcx.sess.span_err(\n                         span,\n                         format!(\"cannot determine a type for \\\n                                  this pattern binding: {}\",\n-                                infer::fixup_err_to_str(e)).as_slice())\n+                                infer::fixup_err_to_string(e)).as_slice())\n                 }\n \n                 ResolvingUpvar(upvar_id) => {\n@@ -430,8 +430,8 @@ impl<'cx> Resolver<'cx> {\n                                  captured variable `{}`: {}\",\n                                 ty::local_var_name_str(\n                                     self.tcx,\n-                                    upvar_id.var_id).get().to_str(),\n-                                infer::fixup_err_to_str(e)).as_slice());\n+                                    upvar_id.var_id).get().to_string(),\n+                                infer::fixup_err_to_string(e)).as_slice());\n                 }\n \n                 ResolvingImplRes(span) => {"}, {"sha": "11a8d9e42762a3b4b409fcb8fa8e54e74b6a7b6d", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -63,7 +63,7 @@ use syntax::codemap;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n-use syntax::print::pprust::{path_to_str};\n+use syntax::print::pprust::{path_to_string};\n use syntax::visit;\n \n struct CollectItemTypesVisitor<'a> {\n@@ -665,7 +665,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n             ccx.tcx.sess.span_fatal(\n                 ast_trait_ref.path.span,\n                 format!(\"`{}` is not a trait\",\n-                        path_to_str(&ast_trait_ref.path)).as_slice());\n+                        path_to_string(&ast_trait_ref.path)).as_slice());\n         }\n     }\n }\n@@ -844,7 +844,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             debug!(\"type of {} (id {}) is {}\",\n                     token::get_ident(it.ident),\n                     it.id,\n-                    ppaux::ty_to_str(tcx, pty.ty));\n+                    ppaux::ty_to_string(tcx, pty.ty));\n \n             ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n             return pty;\n@@ -1144,7 +1144,7 @@ fn ty_generics(ccx: &CrateCtxt,\n                         format!(\"incompatible bounds on type parameter {}, \\\n                                  bound {} does not allow unsized type\",\n                         token::get_ident(ident),\n-                        ppaux::trait_ref_to_str(tcx,\n+                        ppaux::trait_ref_to_string(tcx,\n                                                 &*trait_ref)).as_slice());\n                 }\n                 true"}, {"sha": "2b5c95990c3860fe96d8d76a3a8a651fd5c9508a", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -90,7 +90,7 @@ use syntax::codemap;\n use syntax::parse::token;\n use syntax::print::pprust;\n use util::ppaux::UserString;\n-use util::ppaux::bound_region_to_str;\n+use util::ppaux::bound_region_to_string;\n use util::ppaux::note_and_explain_region;\n \n pub trait ErrorReporting {\n@@ -442,7 +442,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_str()).as_slice());\n+                                .to_string()).as_slice());\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n@@ -454,7 +454,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_str()).as_slice(),\n+                                .to_string()).as_slice(),\n                     sup,\n                     \"\");\n             }\n@@ -500,7 +500,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                             outlive the enclosing closure\",\n                             ty::local_var_name_str(self.tcx,\n                                                    id).get()\n-                                                      .to_str()).as_slice());\n+                                                      .to_string()).as_slice());\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -1046,7 +1046,7 @@ impl<'a> Rebuilder<'a> {\n                                 .sess\n                                 .fatal(format!(\n                                         \"unbound path {}\",\n-                                        pprust::path_to_str(path)).as_slice())\n+                                        pprust::path_to_string(path)).as_slice())\n                         }\n                         Some(&d) => d\n                     };\n@@ -1231,7 +1231,7 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                                 opt_explicit_self: Option<ast::ExplicitSelf_>,\n                                 generics: &ast::Generics,\n                                 span: codemap::Span) {\n-        let suggested_fn = pprust::fun_to_str(decl, fn_style, ident,\n+        let suggested_fn = pprust::fun_to_string(decl, fn_style, ident,\n                                               opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n@@ -1249,11 +1249,11 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n             infer::Coercion(_) => \" for automatic coercion\".to_string(),\n             infer::LateBoundRegion(_, br) => {\n                 format!(\" for {}in function call\",\n-                        bound_region_to_str(self.tcx, \"lifetime parameter \", true, br))\n+                        bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n             }\n             infer::BoundRegionInFnType(_, br) => {\n                 format!(\" for {}in function type\",\n-                        bound_region_to_str(self.tcx, \"lifetime parameter \", true, br))\n+                        bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n             }\n             infer::EarlyBoundRegion(_, name) => {\n                 format!(\" for lifetime parameter `{}\",\n@@ -1265,7 +1265,7 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 format!(\" for capture of `{}` by closure\",\n-                        ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_str())\n+                        ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_string())\n             }\n         };\n \n@@ -1334,7 +1334,7 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                         \"...so that closure can access `{}`\",\n                         ty::local_var_name_str(self.tcx, upvar_id.var_id)\n                             .get()\n-                            .to_str()).as_slice())\n+                            .to_string()).as_slice())\n             }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_note(\n@@ -1359,7 +1359,7 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                             does not outlive the enclosing closure\",\n                             ty::local_var_name_str(\n                                 self.tcx,\n-                                id).get().to_str()).as_slice());\n+                                id).get().to_string()).as_slice());\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1508,7 +1508,7 @@ impl LifeGiver {\n         let mut lifetime;\n         loop {\n             let mut s = String::from_str(\"'\");\n-            s.push_str(num_to_str(self.counter.get()).as_slice());\n+            s.push_str(num_to_string(self.counter.get()).as_slice());\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n                                     token::str_to_ident(s.as_slice()).name);\n@@ -1521,7 +1521,7 @@ impl LifeGiver {\n         return lifetime;\n \n         // 0 .. 25 generates a .. z, 26 .. 51 generates aa .. zz, and so on\n-        fn num_to_str(counter: uint) -> String {\n+        fn num_to_string(counter: uint) -> String {\n             let mut s = String::new();\n             let (n, r) = (counter/26 + 1, counter % 26);\n             let letter: char = from_u32((r+97) as u32).unwrap();"}, {"sha": "b6628c22ae60ae2961b34a5c911e34a21f773d3e", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -26,7 +26,7 @@ use syntax::ast::{NormalFn, UnsafeFn, NodeId};\n use syntax::ast::{Onceness, FnStyle};\n use std::collections::HashMap;\n use util::common::{indenter};\n-use util::ppaux::mt_to_str;\n+use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n pub struct Glb<'f>(pub CombineFields<'f>);  // \"greatest lower bound\" (common subtype)\n@@ -50,8 +50,8 @@ impl<'f> Combine for Glb<'f> {\n \n         debug!(\"{}.mts({}, {})\",\n                self.tag(),\n-               mt_to_str(tcx, a),\n-               mt_to_str(tcx, b));\n+               mt_to_string(tcx, a),\n+               mt_to_string(tcx, b));\n \n         match (a.mutbl, b.mutbl) {\n           // If one side or both is mut, then the GLB must use"}, {"sha": "708eb498f8421ea5fb059a08ccf5b109b9a2459d", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -39,7 +39,7 @@ use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::unify::{Root, UnifyKey};\n+use middle::typeck::infer::unify::*;\n use middle::typeck::infer::sub::Sub;\n use util::ppaux::Repr;\n \n@@ -436,8 +436,7 @@ pub enum LatticeVarResult<K,T> {\n  * - If the variables do not both have an upper bound, we will unify\n  *   the variables and return the unified variable, in which case the\n  *   result is a variable.  This is indicated with a `VarResult`\n- *   return.\n- */\n+ *   return. */\n pub fn lattice_vars<L:LatticeDir+Combine,\n                     T:LatticeValue,\n                     K:UnifyKey<Bounds<T>>>("}, {"sha": "6a50038afe77fc20ea89f51d6648952e9ea1972c", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -25,7 +25,7 @@ use syntax::ast::{Many, Once, NodeId};\n use syntax::ast::{NormalFn, UnsafeFn};\n use syntax::ast::{Onceness, FnStyle};\n use syntax::ast::{MutMutable, MutImmutable};\n-use util::ppaux::mt_to_str;\n+use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n pub struct Lub<'f>(pub CombineFields<'f>);  // least-upper-bound: common supertype\n@@ -49,8 +49,8 @@ impl<'f> Combine for Lub<'f> {\n \n         debug!(\"{}.mts({}, {})\",\n                self.tag(),\n-               mt_to_str(tcx, a),\n-               mt_to_str(tcx, b));\n+               mt_to_string(tcx, a),\n+               mt_to_string(tcx, b));\n \n         if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability)"}, {"sha": "16e758df9dbbd2ad7c3354f7d716bace80d93f5b", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -44,7 +44,7 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n use util::common::indent;\n-use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr};\n+use util::ppaux::{bound_region_to_string, ty_to_string, trait_ref_to_string, Repr};\n \n pub mod doc;\n pub mod macros;\n@@ -245,7 +245,7 @@ pub enum fixup_err {\n     region_var_bound_by_region_var(RegionVid, RegionVid)\n }\n \n-pub fn fixup_err_to_str(f: fixup_err) -> String {\n+pub fn fixup_err_to_string(f: fixup_err) -> String {\n     match f {\n       unresolved_int_ty(_) => {\n           \"cannot determine the type of this integer; add a suffix to \\\n@@ -662,19 +662,19 @@ impl<'a> InferCtxt<'a> {\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n \n-    pub fn ty_to_str(&self, t: ty::t) -> String {\n-        ty_to_str(self.tcx,\n+    pub fn ty_to_string(&self, t: ty::t) -> String {\n+        ty_to_string(self.tcx,\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n-    pub fn tys_to_str(&self, ts: &[ty::t]) -> String {\n-        let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_str(*t)).collect();\n+    pub fn tys_to_string(&self, ts: &[ty::t]) -> String {\n+        let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_string(*t)).collect();\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_str(&self, t: &ty::TraitRef) -> String {\n+    pub fn trait_ref_to_string(&self, t: &ty::TraitRef) -> String {\n         let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n-        trait_ref_to_str(self.tcx, &t)\n+        trait_ref_to_string(self.tcx, &t)\n     }\n \n     pub fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n@@ -707,8 +707,8 @@ impl<'a> InferCtxt<'a> {\n                 self.tcx.sess.bug(\n                     format!(\"resolve_type_vars_if_possible() yielded {} \\\n                              when supplied with {}\",\n-                            self.ty_to_str(dummy0),\n-                            self.ty_to_str(dummy1)).as_slice());\n+                            self.ty_to_string(dummy0),\n+                            self.ty_to_string(dummy1)).as_slice());\n             }\n         }\n     }\n@@ -761,7 +761,7 @@ impl<'a> InferCtxt<'a> {\n                 Some(e) => {\n                     self.tcx.sess.span_err(sp,\n                         format!(\"{}{}\",\n-                                mk_msg(Some(self.ty_to_str(e)), actual_ty),\n+                                mk_msg(Some(self.ty_to_string(e)), actual_ty),\n                                 error_str).as_slice());\n                 }\n             }\n@@ -783,7 +783,7 @@ impl<'a> InferCtxt<'a> {\n             return;\n         }\n \n-        self.type_error_message_str(sp, |_e, a| { mk_msg(a) }, self.ty_to_str(actual_ty), err);\n+        self.type_error_message_str(sp, |_e, a| { mk_msg(a) }, self.ty_to_string(actual_ty), err);\n     }\n \n     pub fn report_mismatched_types(&self,\n@@ -800,7 +800,7 @@ impl<'a> InferCtxt<'a> {\n                 // if I leave out : String, it infers &str and complains\n                 |actual: String| {\n                     format!(\"mismatched types: expected `{}` but found `{}`\",\n-                            self.ty_to_str(resolved_expected),\n+                            self.ty_to_string(resolved_expected),\n                             actual)\n                 }\n             }\n@@ -819,7 +819,7 @@ impl<'a> InferCtxt<'a> {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n                 debug!(\"Bound region {} maps to {:?}\",\n-                       bound_region_to_str(self.tcx, \"\", false, br),\n+                       bound_region_to_string(self.tcx, \"\", false, br),\n                        rvar);\n                 rvar\n             });"}, {"sha": "2ae95309d41d98a76e6c00b8f254ddffd415a08c", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -56,7 +56,7 @@ use middle::typeck::infer::{unresolved_float_ty, unresolved_int_ty};\n use middle::typeck::infer::{unresolved_ty};\n use syntax::codemap::Span;\n use util::common::indent;\n-use util::ppaux::{Repr, ty_to_str};\n+use util::ppaux::{Repr, ty_to_string};\n \n pub static resolve_nested_tvar: uint = 0b0000000001;\n pub static resolve_rvar: uint        = 0b0000000010;\n@@ -121,7 +121,7 @@ impl<'a> ResolveState<'a> {\n         self.err = None;\n \n         debug!(\"Resolving {} (modes={:x})\",\n-               ty_to_str(self.infcx.tcx, typ),\n+               ty_to_string(self.infcx.tcx, typ),\n                self.modes);\n \n         // n.b. This is a hokey mess because the current fold doesn't\n@@ -133,8 +133,8 @@ impl<'a> ResolveState<'a> {\n         match self.err {\n           None => {\n             debug!(\"Resolved to {} + {} (modes={:x})\",\n-                   ty_to_str(self.infcx.tcx, rty),\n-                   ty_to_str(self.infcx.tcx, rty),\n+                   ty_to_string(self.infcx.tcx, rty),\n+                   ty_to_string(self.infcx.tcx, rty),\n                    self.modes);\n             return Ok(rty);\n           }"}, {"sha": "44c147bfe7f62f962b75c813b4e608b4136d5deb", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -22,7 +22,7 @@ use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::then;\n use middle::typeck::infer::{TypeTrace, Subtype};\n use util::common::{indenter};\n-use util::ppaux::{bound_region_to_str, Repr};\n+use util::ppaux::{bound_region_to_string, Repr};\n \n use syntax::ast::{Onceness, FnStyle, MutImmutable, MutMutable};\n \n@@ -176,7 +176,7 @@ impl<'f> Combine for Sub<'f> {\n             replace_late_bound_regions_in_fn_sig(self.get_ref().infcx.tcx, b, |br| {\n                 let skol = self.get_ref().infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {:?}\",\n-                       bound_region_to_str(self.get_ref().infcx.tcx, \"\", false, br),\n+                       bound_region_to_string(self.get_ref().infcx.tcx, \"\", false, br),\n                        skol);\n                 skol\n             })"}, {"sha": "e66dcd118c92892186cb85857d2e6a4b4ef801c7", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -37,7 +37,7 @@ use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note};\n use syntax::ast;\n-use util::ppaux::{ty_to_str, UserString};\n+use util::ppaux::{ty_to_string, UserString};\n \n struct Env<'a> {\n     krate: ast::Crate,\n@@ -225,16 +225,16 @@ impl<'a> Env<'a> {\n     pub fn assert_subtype(&self, a: ty::t, b: ty::t) {\n         if !self.is_subtype(a, b) {\n             fail!(\"{} is not a subtype of {}, but it should be\",\n-                  self.ty_to_str(a),\n-                  self.ty_to_str(b));\n+                  self.ty_to_string(a),\n+                  self.ty_to_string(b));\n         }\n     }\n \n     pub fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n         if self.is_subtype(a, b) {\n             fail!(\"{} is a subtype of {}, but it shouldn't be\",\n-                  self.ty_to_str(a),\n-                  self.ty_to_str(b));\n+                  self.ty_to_string(a),\n+                  self.ty_to_string(b));\n         }\n     }\n \n@@ -243,8 +243,8 @@ impl<'a> Env<'a> {\n         self.assert_subtype(b, a);\n     }\n \n-    pub fn ty_to_str(&self, a: ty::t) -> String {\n-        ty_to_str(self.tcx, a)\n+    pub fn ty_to_string(&self, a: ty::t) -> String {\n+        ty_to_string(self.tcx, a)\n     }\n \n     pub fn t_fn(&self,\n@@ -328,9 +328,9 @@ impl<'a> Env<'a> {\n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: ty::t, t2: ty::t, t_glb: ty::t) {\n         debug!(\"check_glb(t1={}, t2={}, t_glb={})\",\n-               self.ty_to_str(t1),\n-               self.ty_to_str(t2),\n-               self.ty_to_str(t_glb));\n+               self.ty_to_string(t1),\n+               self.ty_to_string(t2),\n+               self.ty_to_string(t_glb));\n         match self.glb().tys(t1, t2) {\n             Err(e) => {\n                 fail!(\"unexpected error computing LUB: {:?}\", e)\n@@ -350,7 +350,7 @@ impl<'a> Env<'a> {\n         match self.lub().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail!(\"unexpected success computing LUB: {}\", self.ty_to_str(t))\n+                fail!(\"unexpected success computing LUB: {}\", self.ty_to_string(t))\n             }\n         }\n     }\n@@ -360,7 +360,7 @@ impl<'a> Env<'a> {\n         match self.glb().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail!(\"unexpected success computing GLB: {}\", self.ty_to_str(t))\n+                fail!(\"unexpected success computing GLB: {}\", self.ty_to_string(t))\n             }\n         }\n     }"}, {"sha": "ad6864ba487921680001aa59e6b180a3032207ac", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -276,7 +276,7 @@ pub struct CrateCtxt<'a> {\n \n // Functions that write types into the node type table\n pub fn write_ty_to_tcx(tcx: &ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n-    debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_str(tcx, ty));\n+    debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_string(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n     tcx.node_types.borrow_mut().insert(node_id as uint, ty);\n }\n@@ -383,14 +383,14 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n                 || {\n                     format!(\"main function expects type: `{}`\",\n-                            ppaux::ty_to_str(ccx.tcx, se_ty))\n+                            ppaux::ty_to_string(ccx.tcx, se_ty))\n                 });\n         }\n         _ => {\n             tcx.sess.span_bug(main_span,\n                               format!(\"main has a non-function type: found \\\n                                        `{}`\",\n-                                      ppaux::ty_to_str(tcx,\n+                                      ppaux::ty_to_string(tcx,\n                                                        main_t)).as_slice());\n         }\n     }\n@@ -436,15 +436,15 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             require_same_types(tcx, None, false, start_span, start_t, se_ty,\n                 || {\n                     format!(\"start function expects type: `{}`\",\n-                            ppaux::ty_to_str(ccx.tcx, se_ty))\n+                            ppaux::ty_to_string(ccx.tcx, se_ty))\n                 });\n \n         }\n         _ => {\n             tcx.sess.span_bug(start_span,\n                               format!(\"start has a non-function type: found \\\n                                        `{}`\",\n-                                      ppaux::ty_to_str(tcx,\n+                                      ppaux::ty_to_string(tcx,\n                                                        start_t)).as_slice());\n         }\n     }"}, {"sha": "8b5d16620b0f5898d02a5f0b89bdea289b6a34c2", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -547,7 +547,7 @@ impl<'a> ConstraintContext<'a> {\n             None => {\n                 self.tcx().sess.bug(format!(\n                         \"no inferred index entry for {}\",\n-                        self.tcx().map.node_to_str(param_id)).as_slice());\n+                        self.tcx().map.node_to_string(param_id)).as_slice());\n             }\n         }\n     }\n@@ -588,8 +588,8 @@ impl<'a> ConstraintContext<'a> {\n             let is_inferred;\n             macro_rules! cannot_happen { () => { {\n                 fail!(\"invalid parent: {:s} for {:s}\",\n-                      tcx.map.node_to_str(parent_id),\n-                      tcx.map.node_to_str(param_id));\n+                      tcx.map.node_to_string(parent_id),\n+                      tcx.map.node_to_string(param_id));\n             } } }\n \n             match parent {\n@@ -658,7 +658,7 @@ impl<'a> ConstraintContext<'a> {\n                       InferredIndex(index): InferredIndex,\n                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraint(index={}, variance={})\",\n-                index, variance.to_str());\n+                index, variance.to_string());\n         self.constraints.push(Constraint { inferred: InferredIndex(index),\n                                            variance: variance });\n     }\n@@ -975,7 +975,7 @@ impl<'a> SolveContext<'a> {\n                                 .param_id,\n                             old_value,\n                             new_value,\n-                            term.to_str());\n+                            term.to_string());\n \n                     *self.solutions.get_mut(inferred) = new_value;\n                     changed = true;"}, {"sha": "542bc68ef738cf260464a69e20e1160bab7206f8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 76, "deletions": 66, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -105,7 +105,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           BrFresh(_) => \"an anonymous lifetime defined on\".to_string(),\n           _ => {\n               format!(\"the lifetime {} as defined on\",\n-                      bound_region_ptr_to_str(cx, fr.bound_region))\n+                      bound_region_ptr_to_string(cx, fr.bound_region))\n           }\n         };\n \n@@ -145,11 +145,11 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n     }\n }\n \n-pub fn bound_region_ptr_to_str(cx: &ctxt, br: BoundRegion) -> String {\n-    bound_region_to_str(cx, \"\", false, br)\n+pub fn bound_region_ptr_to_string(cx: &ctxt, br: BoundRegion) -> String {\n+    bound_region_to_string(cx, \"\", false, br)\n }\n \n-pub fn bound_region_to_str(cx: &ctxt,\n+pub fn bound_region_to_string(cx: &ctxt,\n                            prefix: &str, space: bool,\n                            br: BoundRegion) -> String {\n     let space_str = if space { \" \" } else { \"\" };\n@@ -170,11 +170,11 @@ pub fn bound_region_to_str(cx: &ctxt,\n // In general, if you are giving a region error message,\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n-pub fn region_ptr_to_str(cx: &ctxt, region: Region) -> String {\n-    region_to_str(cx, \"&\", true, region)\n+pub fn region_ptr_to_string(cx: &ctxt, region: Region) -> String {\n+    region_to_string(cx, \"&\", true, region)\n }\n \n-pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> String {\n+pub fn region_to_string(cx: &ctxt, prefix: &str, space: bool, region: Region) -> String {\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n@@ -190,56 +190,66 @@ pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> St\n         ty::ReEarlyBound(_, _, _, name) => {\n             token::get_name(name).get().to_string()\n         }\n-        ty::ReLateBound(_, br) => bound_region_to_str(cx, prefix, space, br),\n-        ty::ReFree(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n+        ty::ReLateBound(_, br) => bound_region_to_string(cx, prefix, space, br),\n+        ty::ReFree(ref fr) => bound_region_to_string(cx, prefix, space, fr.bound_region),\n         ty::ReInfer(ReSkolemized(_, br)) => {\n-            bound_region_to_str(cx, prefix, space, br)\n+            bound_region_to_string(cx, prefix, space, br)\n         }\n         ty::ReInfer(ReVar(_)) => prefix.to_string(),\n         ty::ReStatic => format!(\"{}'static{}\", prefix, space_str),\n         ty::ReEmpty => format!(\"{}'<empty>{}\", prefix, space_str),\n     }\n }\n \n-pub fn mutability_to_str(m: ast::Mutability) -> String {\n+pub fn mutability_to_string(m: ast::Mutability) -> String {\n     match m {\n         ast::MutMutable => \"mut \".to_string(),\n         ast::MutImmutable => \"\".to_string(),\n     }\n }\n \n-pub fn mt_to_str(cx: &ctxt, m: &mt) -> String {\n-    format!(\"{}{}\", mutability_to_str(m.mutbl), ty_to_str(cx, m.ty))\n+pub fn mt_to_string(cx: &ctxt, m: &mt) -> String {\n+    format!(\"{}{}\", mutability_to_string(m.mutbl), ty_to_string(cx, m.ty))\n }\n \n+#[cfg(stage0)]\n pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> String {\n+    trait_store_to_string(cx, s)\n+}\n+\n+pub fn trait_store_to_string(cx: &ctxt, s: ty::TraitStore) -> String {\n     match s {\n         ty::UniqTraitStore => \"Box \".to_string(),\n         ty::RegionTraitStore(r, m) => {\n-            format!(\"{}{}\", region_ptr_to_str(cx, r), mutability_to_str(m))\n+            format!(\"{}{}\", region_ptr_to_string(cx, r), mutability_to_string(m))\n         }\n     }\n }\n \n-pub fn vec_map_to_str<T>(ts: &[T], f: |t: &T| -> String) -> String {\n+pub fn vec_map_to_string<T>(ts: &[T], f: |t: &T| -> String) -> String {\n     let tstrs = ts.iter().map(f).collect::<Vec<String>>();\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n-pub fn fn_sig_to_str(cx: &ctxt, typ: &ty::FnSig) -> String {\n+pub fn fn_sig_to_string(cx: &ctxt, typ: &ty::FnSig) -> String {\n     format!(\"fn{}{} -> {}\", typ.binder_id, typ.inputs.repr(cx),\n             typ.output.repr(cx))\n }\n \n-pub fn trait_ref_to_str(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n+pub fn trait_ref_to_string(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n     trait_ref.user_string(cx).to_string()\n }\n \n+#[cfg(stage0)]\n pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n-    fn fn_input_to_str(cx: &ctxt, input: ty::t) -> String {\n-        ty_to_str(cx, input).to_string()\n+    ty_to_string(cx, typ)\n+}\n+\n+pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n+    fn fn_input_to_string(cx: &ctxt, input: ty::t) -> String {\n+        ty_to_string(cx, input).to_string()\n     }\n-    fn bare_fn_to_str(cx: &ctxt,\n+    fn bare_fn_to_string(cx: &ctxt,\n                       fn_style: ast::FnStyle,\n                       abi: abi::Abi,\n                       ident: Option<ast::Ident>,\n@@ -249,13 +259,13 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n         match fn_style {\n             ast::NormalFn => {}\n             _ => {\n-                s.push_str(fn_style.to_str().as_slice());\n+                s.push_str(fn_style.to_string().as_slice());\n                 s.push_char(' ');\n             }\n         };\n \n         if abi != abi::Rust {\n-            s.push_str(format!(\"extern {} \", abi.to_str()).as_slice());\n+            s.push_str(format!(\"extern {} \", abi.to_string()).as_slice());\n         };\n \n         s.push_str(\"fn\");\n@@ -268,25 +278,25 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n             _ => { }\n         }\n \n-        push_sig_to_str(cx, &mut s, '(', ')', sig);\n+        push_sig_to_string(cx, &mut s, '(', ')', sig);\n \n         s\n     }\n \n-    fn closure_to_str(cx: &ctxt, cty: &ty::ClosureTy) -> String {\n+    fn closure_to_string(cx: &ctxt, cty: &ty::ClosureTy) -> String {\n         let mut s = String::new();\n \n         match cty.store {\n             ty::UniqTraitStore => {}\n             ty::RegionTraitStore(region, _) => {\n-                s.push_str(region_to_str(cx, \"\", true, region).as_slice());\n+                s.push_str(region_to_string(cx, \"\", true, region).as_slice());\n             }\n         }\n \n         match cty.fn_style {\n             ast::NormalFn => {}\n             _ => {\n-                s.push_str(cty.fn_style.to_str().as_slice());\n+                s.push_str(cty.fn_style.to_string().as_slice());\n                 s.push_char(' ');\n             }\n         };\n@@ -295,14 +305,14 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n             ty::UniqTraitStore => {\n                 assert_eq!(cty.onceness, ast::Once);\n                 s.push_str(\"proc\");\n-                push_sig_to_str(cx, &mut s, '(', ')', &cty.sig);\n+                push_sig_to_string(cx, &mut s, '(', ')', &cty.sig);\n             }\n             ty::RegionTraitStore(..) => {\n                 match cty.onceness {\n                     ast::Many => {}\n                     ast::Once => s.push_str(\"once \")\n                 }\n-                push_sig_to_str(cx, &mut s, '|', '|', &cty.sig);\n+                push_sig_to_string(cx, &mut s, '|', '|', &cty.sig);\n             }\n         }\n \n@@ -314,13 +324,13 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n         s\n     }\n \n-    fn push_sig_to_str(cx: &ctxt,\n+    fn push_sig_to_string(cx: &ctxt,\n                        s: &mut String,\n                        bra: char,\n                        ket: char,\n                        sig: &ty::FnSig) {\n         s.push_char(bra);\n-        let strs: Vec<String> = sig.inputs.iter().map(|a| fn_input_to_str(cx, *a)).collect();\n+        let strs: Vec<String> = sig.inputs.iter().map(|a| fn_input_to_string(cx, *a)).collect();\n         s.push_str(strs.connect(\", \").as_slice());\n         if sig.variadic {\n             s.push_str(\", ...\");\n@@ -332,7 +342,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n             if ty::type_is_bot(sig.output) {\n                 s.push_char('!');\n             } else {\n-                s.push_str(ty_to_str(cx, sig.output).as_slice());\n+                s.push_str(ty_to_string(cx, sig.output).as_slice());\n             }\n         }\n     }\n@@ -349,33 +359,33 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n       ty_bot => \"!\".to_string(),\n       ty_bool => \"bool\".to_string(),\n       ty_char => \"char\".to_string(),\n-      ty_int(t) => ast_util::int_ty_to_str(t, None).to_string(),\n-      ty_uint(t) => ast_util::uint_ty_to_str(t, None).to_string(),\n-      ty_float(t) => ast_util::float_ty_to_str(t).to_string(),\n-      ty_box(typ) => format!(\"Gc<{}>\", ty_to_str(cx, typ)),\n-      ty_uniq(typ) => format!(\"Box<{}>\", ty_to_str(cx, typ)),\n+      ty_int(t) => ast_util::int_ty_to_string(t, None).to_string(),\n+      ty_uint(t) => ast_util::uint_ty_to_string(t, None).to_string(),\n+      ty_float(t) => ast_util::float_ty_to_string(t).to_string(),\n+      ty_box(typ) => format!(\"Gc<{}>\", ty_to_string(cx, typ)),\n+      ty_uniq(typ) => format!(\"Box<{}>\", ty_to_string(cx, typ)),\n       ty_ptr(ref tm) => {\n           format!(\"*{} {}\", match tm.mutbl {\n               ast::MutMutable => \"mut\",\n               ast::MutImmutable => \"const\",\n-          }, ty_to_str(cx, tm.ty))\n+          }, ty_to_string(cx, tm.ty))\n       }\n       ty_rptr(r, ref tm) => {\n-          let mut buf = region_ptr_to_str(cx, r);\n-          buf.push_str(mt_to_str(cx, tm).as_slice());\n+          let mut buf = region_ptr_to_string(cx, r);\n+          buf.push_str(mt_to_string(cx, tm).as_slice());\n           buf\n       }\n       ty_tup(ref elems) => {\n-        let strs: Vec<String> = elems.iter().map(|elem| ty_to_str(cx, *elem)).collect();\n+        let strs: Vec<String> = elems.iter().map(|elem| ty_to_string(cx, *elem)).collect();\n         format!(\"({})\", strs.connect(\",\"))\n       }\n       ty_closure(ref f) => {\n-          closure_to_str(cx, *f)\n+          closure_to_string(cx, *f)\n       }\n       ty_bare_fn(ref f) => {\n-          bare_fn_to_str(cx, f.fn_style, f.abi, None, &f.sig)\n+          bare_fn_to_string(cx, f.fn_style, f.abi, None, &f.sig)\n       }\n-      ty_infer(infer_ty) => infer_ty.to_str(),\n+      ty_infer(infer_ty) => infer_ty.to_string(),\n       ty_err => \"[type error]\".to_string(),\n       ty_param(ParamTy {idx: id, def_id: did, ..}) => {\n           let ident = match cx.ty_param_defs.borrow().find(&did.node) {\n@@ -413,9 +423,9 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n       ty_vec(ref mt, sz) => {\n           match sz {\n               Some(n) => {\n-                  format!(\"[{}, .. {}]\", mt_to_str(cx, mt), n)\n+                  format!(\"[{}, .. {}]\", mt_to_string(cx, mt), n)\n               }\n-              None => format!(\"[{}]\", ty_to_str(cx, mt.ty)),\n+              None => format!(\"[{}]\", ty_to_string(cx, mt.ty)),\n           }\n       }\n     }\n@@ -433,7 +443,7 @@ pub fn parameterized(cx: &ctxt,\n         subst::ErasedRegions => { }\n         subst::NonerasedRegions(ref regions) => {\n             for &r in regions.iter() {\n-                let s = region_to_str(cx, \"\", false, r);\n+                let s = region_to_string(cx, \"\", false, r);\n                 if !s.is_empty() {\n                     strs.push(s)\n                 } else {\n@@ -463,7 +473,7 @@ pub fn parameterized(cx: &ctxt,\n     };\n \n     for t in tps.slice_to(tps.len() - num_defaults).iter() {\n-        strs.push(ty_to_str(cx, *t))\n+        strs.push(ty_to_string(cx, *t))\n     }\n \n     if cx.sess.verbose() {\n@@ -530,7 +540,7 @@ impl<T:Repr> Repr for Box<T> {\n }\n \n fn repr_vec<T:Repr>(tcx: &ctxt, v: &[T]) -> String {\n-    vec_map_to_str(v, |t| t.repr(tcx))\n+    vec_map_to_string(v, |t| t.repr(tcx))\n }\n \n impl<'a, T:Repr> Repr for &'a [T] {\n@@ -576,13 +586,13 @@ impl Repr for ty::RegionParameterDef {\n \n impl Repr for ty::t {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        ty_to_str(tcx, *self)\n+        ty_to_string(tcx, *self)\n     }\n }\n \n impl Repr for ty::mt {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        mt_to_str(tcx, self)\n+        mt_to_string(tcx, self)\n     }\n }\n \n@@ -639,39 +649,39 @@ impl Repr for ty::ParamBounds {\n \n impl Repr for ty::TraitRef {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        trait_ref_to_str(tcx, self)\n+        trait_ref_to_string(tcx, self)\n     }\n }\n \n impl Repr for ast::Expr {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"expr({}: {})\", self.id, pprust::expr_to_str(self))\n+        format!(\"expr({}: {})\", self.id, pprust::expr_to_string(self))\n     }\n }\n \n impl Repr for ast::Path {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"path({})\", pprust::path_to_str(self))\n+        format!(\"path({})\", pprust::path_to_string(self))\n     }\n }\n \n impl Repr for ast::Item {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"item({})\", tcx.map.node_to_str(self.id))\n+        format!(\"item({})\", tcx.map.node_to_string(self.id))\n     }\n }\n \n impl Repr for ast::Stmt {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"stmt({}: {})\",\n                 ast_util::stmt_id(self),\n-                pprust::stmt_to_str(self))\n+                pprust::stmt_to_string(self))\n     }\n }\n \n impl Repr for ast::Pat {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"pat({}: {})\", self.id, pprust::pat_to_str(self))\n+        format!(\"pat({}: {})\", self.id, pprust::pat_to_string(self))\n     }\n }\n \n@@ -787,10 +797,10 @@ impl Repr for ty::ItemVariances {\n \n impl Repr for ty::Variance {\n     fn repr(&self, _: &ctxt) -> String {\n-        // The first `.to_str()` returns a &'static str (it is not an implementation\n-        // of the ToStr trait). Because of that, we need to call `.to_str()` again\n+        // The first `.to_string()` returns a &'static str (it is not an implementation\n+        // of the ToString trait). Because of that, we need to call `.to_string()` again\n         // if we want to have a `String`.\n-        self.to_str().to_str()\n+        self.to_string().to_string()\n     }\n }\n \n@@ -835,14 +845,14 @@ impl Repr for ty::BareFnTy {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"BareFnTy {{fn_style: {:?}, abi: {}, sig: {}}}\",\n                 self.fn_style,\n-                self.abi.to_str(),\n+                self.abi.to_string(),\n                 self.sig.repr(tcx))\n     }\n }\n \n impl Repr for ty::FnSig {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        fn_sig_to_str(tcx, self)\n+        fn_sig_to_string(tcx, self)\n     }\n }\n \n@@ -892,7 +902,7 @@ impl Repr for typeck::MethodObject {\n \n impl Repr for ty::TraitStore {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        trait_store_to_str(tcx, *self)\n+        trait_store_to_string(tcx, *self)\n     }\n }\n \n@@ -922,7 +932,7 @@ impl Repr for ty::BuiltinBounds {\n \n impl Repr for Span {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        tcx.sess.codemap().span_to_str(*self).to_string()\n+        tcx.sess.codemap().span_to_string(*self).to_string()\n     }\n }\n \n@@ -953,7 +963,7 @@ impl UserString for ty::TraitRef {\n \n impl UserString for ty::t {\n     fn user_string(&self, tcx: &ctxt) -> String {\n-        ty_to_str(tcx, *self)\n+        ty_to_string(tcx, *self)\n     }\n }\n \n@@ -965,13 +975,13 @@ impl UserString for ast::Ident {\n \n impl Repr for abi::Abi {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        self.to_str()\n+        self.to_string()\n     }\n }\n \n impl UserString for abi::Abi {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n-        self.to_str()\n+        self.to_string()\n     }\n }\n "}, {"sha": "b3891432e2146e280317216cdedcb4f2aa877c16", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -99,7 +99,7 @@ fn try_inline_def(cx: &core::DocContext,\n     cx.inlined.borrow_mut().get_mut_ref().insert(did);\n     ret.push(clean::Item {\n         source: clean::Span::empty(),\n-        name: Some(fqn.last().unwrap().to_str()),\n+        name: Some(fqn.last().unwrap().to_string()),\n         attrs: load_attrs(tcx, did),\n         inner: inner,\n         visibility: Some(ast::Public),\n@@ -136,7 +136,7 @@ pub fn record_extern_fqn(cx: &core::DocContext,\n     match cx.maybe_typed {\n         core::Typed(ref tcx) => {\n             let fqn = csearch::get_item_path(tcx, did);\n-            let fqn = fqn.move_iter().map(|i| i.to_str()).collect();\n+            let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n             cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n         }\n         core::NotTyped(..) => {}"}, {"sha": "6c40ee21040ad2f41c0c6c2c0548cd90d5dba1bd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -408,7 +408,7 @@ impl Clean<Attribute> for ast::MetaItem {\n                 List(s.get().to_string(), l.clean().move_iter().collect())\n             }\n             ast::MetaNameValue(ref s, ref v) => {\n-                NameValue(s.get().to_string(), lit_to_str(v))\n+                NameValue(s.get().to_string(), lit_to_string(v))\n             }\n         }\n     }\n@@ -539,7 +539,7 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n                  external_path(\"Share\", &empty)),\n         };\n         let fqn = csearch::get_item_path(tcx, did);\n-        let fqn = fqn.move_iter().map(|i| i.to_str()).collect();\n+        let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n         cx.external_paths.borrow_mut().get_mut_ref().insert(did,\n                                                             (fqn, TypeTrait));\n         TraitBound(ResolvedPath {\n@@ -558,7 +558,7 @@ impl Clean<TyParamBound> for ty::TraitRef {\n             core::NotTyped(_) => return RegionBound,\n         };\n         let fqn = csearch::get_item_path(tcx, self.def_id);\n-        let fqn = fqn.move_iter().map(|i| i.to_str())\n+        let fqn = fqn.move_iter().map(|i| i.to_string())\n                      .collect::<Vec<String>>();\n         let path = external_path(fqn.last().unwrap().as_slice(),\n                                  &self.substs);\n@@ -1137,7 +1137,7 @@ impl Primitive {\n         return None\n     }\n \n-    pub fn to_str(&self) -> &'static str {\n+    pub fn to_string(&self) -> &'static str {\n         match *self {\n             Int => \"int\",\n             I8 => \"i8\",\n@@ -1163,7 +1163,7 @@ impl Primitive {\n     pub fn to_url_str(&self) -> &'static str {\n         match *self {\n             Unit => \"unit\",\n-            other => other.to_str(),\n+            other => other.to_string(),\n         }\n     }\n \n@@ -1242,7 +1242,7 @@ impl Clean<Type> for ty::t {\n                     lifetimes: Vec::new(), type_params: Vec::new()\n                 },\n                 decl: (ast_util::local_def(0), &fty.sig).clean(),\n-                abi: fty.abi.to_str(),\n+                abi: fty.abi.to_string(),\n             }),\n             ty::ty_closure(ref fty) => {\n                 let decl = box ClosureDecl {\n@@ -1262,14 +1262,14 @@ impl Clean<Type> for ty::t {\n             ty::ty_trait(box ty::TyTrait { def_id: did, ref substs, .. }) => {\n                 let fqn = csearch::get_item_path(get_cx().tcx(), did);\n                 let fqn: Vec<String> = fqn.move_iter().map(|i| {\n-                    i.to_str()\n+                    i.to_string()\n                 }).collect();\n                 let kind = match ty::get(*self).sty {\n                     ty::ty_struct(..) => TypeStruct,\n                     ty::ty_trait(..) => TypeTrait,\n                     _ => TypeEnum,\n                 };\n-                let path = external_path(fqn.last().unwrap().to_str().as_slice(),\n+                let path = external_path(fqn.last().unwrap().to_string().as_slice(),\n                                          substs);\n                 get_cx().external_paths.borrow_mut().get_mut_ref()\n                                        .insert(did, (fqn, kind));\n@@ -1577,7 +1577,7 @@ impl Clean<PathSegment> for ast::PathSegment {\n     }\n }\n \n-fn path_to_str(p: &ast::Path) -> String {\n+fn path_to_string(p: &ast::Path) -> String {\n     let mut s = String::new();\n     let mut first = true;\n     for i in p.segments.iter().map(|x| token::get_ident(x.identifier)) {\n@@ -1643,7 +1643,7 @@ impl Clean<BareFunctionDecl> for ast::BareFnTy {\n                 type_params: Vec::new(),\n             },\n             decl: self.decl.clean(),\n-            abi: self.abi.to_str(),\n+            abi: self.abi.to_string(),\n         }\n     }\n }\n@@ -1916,7 +1916,7 @@ impl ToSource for syntax::codemap::Span {\n     }\n }\n \n-fn lit_to_str(lit: &ast::Lit) -> String {\n+fn lit_to_string(lit: &ast::Lit) -> String {\n     match lit.node {\n         ast::LitStr(ref st, _) => st.get().to_string(),\n         ast::LitBinary(ref data) => format!(\"{:?}\", data.as_slice()),\n@@ -1929,12 +1929,12 @@ fn lit_to_str(lit: &ast::Lit) -> String {\n             res\n         },\n         ast::LitChar(c) => format!(\"'{}'\", c),\n-        ast::LitInt(i, _t) => i.to_str(),\n-        ast::LitUint(u, _t) => u.to_str(),\n-        ast::LitIntUnsuffixed(i) => i.to_str(),\n+        ast::LitInt(i, _t) => i.to_string(),\n+        ast::LitUint(u, _t) => u.to_string(),\n+        ast::LitIntUnsuffixed(i) => i.to_string(),\n         ast::LitFloat(ref f, _t) => f.get().to_string(),\n         ast::LitFloatUnsuffixed(ref f) => f.get().to_string(),\n-        ast::LitBool(b) => b.to_str(),\n+        ast::LitBool(b) => b.to_string(),\n         ast::LitNil => \"\".to_string(),\n     }\n }\n@@ -1947,7 +1947,7 @@ fn name_from_pat(p: &ast::Pat) -> String {\n         PatWild => \"_\".to_string(),\n         PatWildMulti => \"..\".to_string(),\n         PatIdent(_, ref p, _) => token::get_ident(p.node).get().to_string(),\n-        PatEnum(ref p, _) => path_to_str(p),\n+        PatEnum(ref p, _) => path_to_string(p),\n         PatStruct(..) => fail!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),\n         PatTup(..) => \"(tuple arg NYI)\".to_string(),"}, {"sha": "382e299d28d9690b81c40315d1ab228f9850b6b3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -351,7 +351,7 @@ impl fmt::Show for clean::Type {\n                 tybounds(f, typarams)\n             }\n             clean::Self(..) => f.write(\"Self\".as_bytes()),\n-            clean::Primitive(prim) => primitive_link(f, prim, prim.to_str()),\n+            clean::Primitive(prim) => primitive_link(f, prim, prim.to_string()),\n             clean::Closure(ref decl, ref region) => {\n                 write!(f, \"{style}{lifetimes}|{args}|{bounds}{arrow}\",\n                        style = FnStyleSpace(decl.fn_style),\n@@ -405,7 +405,7 @@ impl fmt::Show for clean::Type {\n                        } else {\n                            let mut m = decl.bounds\n                                            .iter()\n-                                           .map(|s| s.to_str());\n+                                           .map(|s| s.to_string());\n                            format!(\n                                \": {}\",\n                                m.collect::<Vec<String>>().connect(\" + \"))\n@@ -607,7 +607,7 @@ impl<'a> fmt::Show for Stability<'a> {\n         match *stab {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n-                       lvl = stability.level.to_str(),\n+                       lvl = stability.level.to_string(),\n                        reason = stability.text)\n             }\n             None => Ok(())\n@@ -621,7 +621,7 @@ impl<'a> fmt::Show for ConciseStability<'a> {\n         match *stab {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n-                       lvl = stability.level.to_str(),\n+                       lvl = stability.level.to_string(),\n                        colon = if stability.text.len() > 0 { \": \" } else { \"\" },\n                        reason = stability.text)\n             }"}, {"sha": "19a9bcb9a17ab97878d6d73fe031bb47df1c0da1", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -229,7 +229,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         // Transform the contents of the header into a hyphenated string\n         let id = s.as_slice().words().map(|s| {\n             match s.to_ascii_opt() {\n-                Some(s) => s.to_lower().into_str(),\n+                Some(s) => s.to_lower().into_string(),\n                 None => s.to_string()\n             }\n         }).collect::<Vec<String>>().connect(\"-\");"}, {"sha": "eeeee8cedf1831a1c5cc07c590140abd90cd472e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -428,7 +428,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n         }\n         try!(write!(&mut w, r#\"[{:u},\"{}\",\"{}\",{}\"#,\n                     item.ty, item.name, path,\n-                    item.desc.to_json().to_str()));\n+                    item.desc.to_json().to_string()));\n         match item.parent {\n             Some(nodeid) => {\n                 let pathid = *nodeid_to_pathid.find(&nodeid).unwrap();"}, {"sha": "b53363738ac94f59c5c8ab26281052b73b78de60", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -367,7 +367,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n         }\n     };\n     match json::from_reader(&mut input) {\n-        Err(s) => Err(s.to_str()),\n+        Err(s) => Err(s.to_string()),\n         Ok(json::Object(obj)) => {\n             let mut obj = obj;\n             // Make sure the schema is what we expect"}, {"sha": "06f4e71871d40ba4c3d36a483a1d62b8abcd5ef3", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -804,7 +804,7 @@ mod bench {\n         Mary had a little lamb, Little lamb\n         Mary had a little lamb, Little lamb\";\n \n-    fn bench_to_str(b: &mut Bencher, s: &str) {\n+    fn bench_to_string(b: &mut Bencher, s: &str) {\n         b.iter(|| {\n             let c_str = s.to_c_str();\n             check(s, c_str.as_ptr());\n@@ -813,17 +813,17 @@ mod bench {\n \n     #[bench]\n     fn bench_to_c_str_short(b: &mut Bencher) {\n-        bench_to_str(b, s_short)\n+        bench_to_string(b, s_short)\n     }\n \n     #[bench]\n     fn bench_to_c_str_medium(b: &mut Bencher) {\n-        bench_to_str(b, s_medium)\n+        bench_to_string(b, s_medium)\n     }\n \n     #[bench]\n     fn bench_to_c_str_long(b: &mut Bencher) {\n-        bench_to_str(b, s_long)\n+        bench_to_string(b, s_long)\n     }\n \n     fn bench_to_c_str_unchecked(b: &mut Bencher, s: &str) {"}, {"sha": "972a28dda62bb8dbffa0cde586e61493cf087ad0", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -393,7 +393,7 @@ impl fmt::Show for UvError {\n #[test]\n fn error_smoke_test() {\n     let err: UvError = UvError(uvll::EOF);\n-    assert_eq!(err.to_str(), \"EOF: end of file\".to_string());\n+    assert_eq!(err.to_string(), \"EOF: end of file\".to_string());\n }\n \n #[cfg(unix)]"}, {"sha": "45f93d9d1289801e52a1cd5c66b9acdab06aba3b", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -676,7 +676,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     fn join_multicast(&mut self, multi: rtio::IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n-            multi.to_str().with_c_str(|m_addr| {\n+            multi.to_string().with_c_str(|m_addr| {\n                 uvll::uv_udp_set_membership(self.handle,\n                                             m_addr, ptr::null(),\n                                             uvll::UV_JOIN_GROUP)\n@@ -687,7 +687,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     fn leave_multicast(&mut self, multi: rtio::IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n-            multi.to_str().with_c_str(|m_addr| {\n+            multi.to_string().with_c_str(|m_addr| {\n                 uvll::uv_udp_set_membership(self.handle,\n                                             m_addr, ptr::null(),\n                                             uvll::UV_LEAVE_GROUP)"}, {"sha": "95eac25ab5bd126247ec9f7860b026a1ab9fc6c7", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -270,7 +270,7 @@ pub fn parse(s: &str) -> Option<Version> {\n     let v = parse_iter(&mut s.chars());\n     match v {\n         Some(v) => {\n-            if v.to_str().equiv(&s) {\n+            if v.to_string().equiv(&s) {\n                 Some(v)\n             } else {\n                 None\n@@ -391,11 +391,11 @@ fn test_show() {\n }\n \n #[test]\n-fn test_to_str() {\n-    assert_eq!(parse(\"1.2.3\").unwrap().to_str(), \"1.2.3\".to_string());\n-    assert_eq!(parse(\"1.2.3-alpha1\").unwrap().to_str(), \"1.2.3-alpha1\".to_string());\n-    assert_eq!(parse(\"1.2.3+build.42\").unwrap().to_str(), \"1.2.3+build.42\".to_string());\n-    assert_eq!(parse(\"1.2.3-alpha1+42\").unwrap().to_str(), \"1.2.3-alpha1+42\".to_string());\n+fn test_to_string() {\n+    assert_eq!(parse(\"1.2.3\").unwrap().to_string(), \"1.2.3\".to_string());\n+    assert_eq!(parse(\"1.2.3-alpha1\").unwrap().to_string(), \"1.2.3-alpha1\".to_string());\n+    assert_eq!(parse(\"1.2.3+build.42\").unwrap().to_string(), \"1.2.3+build.42\".to_string());\n+    assert_eq!(parse(\"1.2.3-alpha1+42\").unwrap().to_string(), \"1.2.3-alpha1+42\".to_string());\n }\n \n #[test]"}, {"sha": "df4d3437b1ce673b9385e2c829cff26325d03b7f", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -130,7 +130,7 @@ fn main() {\n     // Serialize using `ToJson`\n     let test2 = TestStruct1 {data_int: 1, data_str:\"toto\".to_string(), data_vector:vec![2,3,4,5]};\n     let tjson: json::Json = test2.to_json();\n-    let json_str: String = tjson.to_str();\n+    let json_str: String = tjson.to_string();\n \n     // Deserialize like before\n     let decoded: TestStruct1 = json::decode(json_str.as_slice()).unwrap();\n@@ -2202,59 +2202,59 @@ mod tests {\n \n     #[test]\n     fn test_write_null() {\n-        assert_eq!(Null.to_str().into_string(), \"null\".to_string());\n+        assert_eq!(Null.to_string().into_string(), \"null\".to_string());\n         assert_eq!(Null.to_pretty_str().into_string(), \"null\".to_string());\n     }\n \n \n     #[test]\n     fn test_write_number() {\n-        assert_eq!(Number(3.0).to_str().into_string(), \"3\".to_string());\n+        assert_eq!(Number(3.0).to_string().into_string(), \"3\".to_string());\n         assert_eq!(Number(3.0).to_pretty_str().into_string(), \"3\".to_string());\n \n-        assert_eq!(Number(3.1).to_str().into_string(), \"3.1\".to_string());\n+        assert_eq!(Number(3.1).to_string().into_string(), \"3.1\".to_string());\n         assert_eq!(Number(3.1).to_pretty_str().into_string(), \"3.1\".to_string());\n \n-        assert_eq!(Number(-1.5).to_str().into_string(), \"-1.5\".to_string());\n+        assert_eq!(Number(-1.5).to_string().into_string(), \"-1.5\".to_string());\n         assert_eq!(Number(-1.5).to_pretty_str().into_string(), \"-1.5\".to_string());\n \n-        assert_eq!(Number(0.5).to_str().into_string(), \"0.5\".to_string());\n+        assert_eq!(Number(0.5).to_string().into_string(), \"0.5\".to_string());\n         assert_eq!(Number(0.5).to_pretty_str().into_string(), \"0.5\".to_string());\n \n-        assert_eq!(Number(f64::NAN).to_str().into_string(), \"null\".to_string());\n+        assert_eq!(Number(f64::NAN).to_string().into_string(), \"null\".to_string());\n         assert_eq!(Number(f64::NAN).to_pretty_str().into_string(), \"null\".to_string());\n \n-        assert_eq!(Number(f64::INFINITY).to_str().into_string(), \"null\".to_string());\n+        assert_eq!(Number(f64::INFINITY).to_string().into_string(), \"null\".to_string());\n         assert_eq!(Number(f64::INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n \n-        assert_eq!(Number(f64::NEG_INFINITY).to_str().into_string(), \"null\".to_string());\n+        assert_eq!(Number(f64::NEG_INFINITY).to_string().into_string(), \"null\".to_string());\n         assert_eq!(Number(f64::NEG_INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert_eq!(String(\"\".to_string()).to_str().into_string(), \"\\\"\\\"\".to_string());\n+        assert_eq!(String(\"\".to_string()).to_string().into_string(), \"\\\"\\\"\".to_string());\n         assert_eq!(String(\"\".to_string()).to_pretty_str().into_string(), \"\\\"\\\"\".to_string());\n \n-        assert_eq!(String(\"foo\".to_string()).to_str().into_string(), \"\\\"foo\\\"\".to_string());\n+        assert_eq!(String(\"foo\".to_string()).to_string().into_string(), \"\\\"foo\\\"\".to_string());\n         assert_eq!(String(\"foo\".to_string()).to_pretty_str().into_string(), \"\\\"foo\\\"\".to_string());\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert_eq!(Boolean(true).to_str().into_string(), \"true\".to_string());\n+        assert_eq!(Boolean(true).to_string().into_string(), \"true\".to_string());\n         assert_eq!(Boolean(true).to_pretty_str().into_string(), \"true\".to_string());\n \n-        assert_eq!(Boolean(false).to_str().into_string(), \"false\".to_string());\n+        assert_eq!(Boolean(false).to_string().into_string(), \"false\".to_string());\n         assert_eq!(Boolean(false).to_pretty_str().into_string(), \"false\".to_string());\n     }\n \n     #[test]\n     fn test_write_list() {\n-        assert_eq!(List(vec![]).to_str().into_string(), \"[]\".to_string());\n+        assert_eq!(List(vec![]).to_string().into_string(), \"[]\".to_string());\n         assert_eq!(List(vec![]).to_pretty_str().into_string(), \"[]\".to_string());\n \n-        assert_eq!(List(vec![Boolean(true)]).to_str().into_string(), \"[true]\".to_string());\n+        assert_eq!(List(vec![Boolean(true)]).to_string().into_string(), \"[true]\".to_string());\n         assert_eq!(\n             List(vec![Boolean(true)]).to_pretty_str().into_string(),\n             \"\\\n@@ -2268,7 +2268,7 @@ mod tests {\n             Null,\n             List(vec![String(\"foo\\nbar\".to_string()), Number(3.5)])]);\n \n-        assert_eq!(long_test_list.to_str().into_string(),\n+        assert_eq!(long_test_list.to_string().into_string(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_string());\n         assert_eq!(\n             long_test_list.to_pretty_str().into_string(),\n@@ -2286,13 +2286,13 @@ mod tests {\n \n     #[test]\n     fn test_write_object() {\n-        assert_eq!(mk_object([]).to_str().into_string(), \"{}\".to_string());\n+        assert_eq!(mk_object([]).to_string().into_string(), \"{}\".to_string());\n         assert_eq!(mk_object([]).to_pretty_str().into_string(), \"{}\".to_string());\n \n         assert_eq!(\n             mk_object([\n                 (\"a\".to_string(), Boolean(true))\n-            ]).to_str().into_string(),\n+            ]).to_string().into_string(),\n             \"{\\\"a\\\":true}\".to_string()\n         );\n         assert_eq!(\n@@ -2311,7 +2311,7 @@ mod tests {\n             ]);\n \n         assert_eq!(\n-            complex_obj.to_str().into_string(),\n+            complex_obj.to_string().into_string(),\n             \"{\\\n                 \\\"b\\\":[\\\n                     {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n@@ -2344,7 +2344,7 @@ mod tests {\n \n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n-        assert_eq!(a.clone(), from_str(a.to_str().as_slice()).unwrap());\n+        assert_eq!(a.clone(), from_str(a.to_string().as_slice()).unwrap());\n         assert_eq!(a.clone(),\n                    from_str(a.to_pretty_str().as_slice()).unwrap());\n     }"}, {"sha": "796147ce7a05dd0c14a52806c93ceade93da5b45", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -345,10 +345,10 @@ impl<'a> AsciiStr for &'a [Ascii] {\n \n impl IntoStr for Vec<Ascii> {\n     #[inline]\n-    fn into_str(self) -> String {\n+    fn into_string(self) -> String {\n         unsafe {\n             let s: &str = mem::transmute(self.as_slice());\n-            s.to_string()\n+            String::from_str(s)\n         }\n     }\n }\n@@ -438,12 +438,12 @@ unsafe fn str_map_bytes(string: String, map: &'static [u8]) -> String {\n         *b = map[*b as uint];\n     }\n \n-    str::from_utf8(bytes.as_slice()).unwrap().to_string()\n+    String::from_str(str::from_utf8(bytes.as_slice()).unwrap())\n }\n \n #[inline]\n unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> String {\n-    let mut s = string.to_string();\n+    let mut s = String::from_str(string);\n     for b in s.as_mut_bytes().mut_iter() {\n         *b = map[*b as uint];\n     }\n@@ -578,12 +578,12 @@ mod tests {\n         assert_eq!(v.as_slice().to_ascii(), v2ascii!([40, 32, 59]));\n         assert_eq!(\"( ;\".to_string().as_slice().to_ascii(), v2ascii!([40, 32, 59]));\n \n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_string());\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_string());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_string(), \"abcdef&?#\".to_string());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_string(), \"ABCDEF&?#\".to_string());\n \n-        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_string());\n-        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_string());\n-        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_string());\n+        assert_eq!(\"\".to_ascii().to_lower().into_string(), \"\".to_string());\n+        assert_eq!(\"YMCA\".to_ascii().to_lower().into_string(), \"ymca\".to_string());\n+        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_string(), \"ABCDEFXYZ:.;\".to_string());\n \n         assert!(\"aBcDeF&?#\".to_ascii().eq_ignore_case(\"AbCdEf&?#\".to_ascii()));\n \n@@ -595,11 +595,11 @@ mod tests {\n \n     #[test]\n     fn test_ascii_vec_ng() {\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_string());\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_string());\n-        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_string());\n-        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_string());\n-        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_string());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_string(), \"abcdef&?#\".to_string());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_string(), \"ABCDEF&?#\".to_string());\n+        assert_eq!(\"\".to_ascii().to_lower().into_string(), \"\".to_string());\n+        assert_eq!(\"YMCA\".to_ascii().to_lower().into_string(), \"ymca\".to_string());\n+        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_string(), \"ABCDEFXYZ:.;\".to_string());\n     }\n \n     #[test]\n@@ -615,9 +615,9 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_ascii_into_str() {\n-        assert_eq!(vec2ascii![40, 32, 59].into_str(), \"( ;\".to_string());\n-        assert_eq!(vec2ascii!(40, 32, 59).into_str(), \"( ;\".to_string());\n+    fn test_ascii_into_string() {\n+        assert_eq!(vec2ascii![40, 32, 59].into_string(), \"( ;\".to_string());\n+        assert_eq!(vec2ascii!(40, 32, 59).into_string(), \"( ;\".to_string());\n     }\n \n     #[test]\n@@ -757,8 +757,8 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_to_str() {\n-        let s = Ascii{ chr: 't' as u8 }.to_str();\n+    fn test_to_string() {\n+        let s = Ascii{ chr: 't' as u8 }.to_string();\n         assert_eq!(s, \"t\".to_string());\n     }\n "}, {"sha": "a02402271d08383bdc76faa2ebd942459e7f444e", "filename": "src/libstd/collections/lru_cache.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -319,20 +319,20 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_to_str() {\n+    fn test_to_string() {\n         let mut cache: LruCache<int, int> = LruCache::new(3);\n         cache.put(1, 10);\n         cache.put(2, 20);\n         cache.put(3, 30);\n-        assert_eq!(cache.to_str(), \"{3: 30, 2: 20, 1: 10}\".to_string());\n+        assert_eq!(cache.to_string(), \"{3: 30, 2: 20, 1: 10}\".to_string());\n         cache.put(2, 22);\n-        assert_eq!(cache.to_str(), \"{2: 22, 3: 30, 1: 10}\".to_string());\n+        assert_eq!(cache.to_string(), \"{2: 22, 3: 30, 1: 10}\".to_string());\n         cache.put(6, 60);\n-        assert_eq!(cache.to_str(), \"{6: 60, 2: 22, 3: 30}\".to_string());\n+        assert_eq!(cache.to_string(), \"{6: 60, 2: 22, 3: 30}\".to_string());\n         cache.get(&3);\n-        assert_eq!(cache.to_str(), \"{3: 30, 6: 60, 2: 22}\".to_string());\n+        assert_eq!(cache.to_string(), \"{3: 30, 6: 60, 2: 22}\".to_string());\n         cache.change_capacity(2);\n-        assert_eq!(cache.to_str(), \"{3: 30, 6: 60}\".to_string());\n+        assert_eq!(cache.to_string(), \"{3: 30, 6: 60}\".to_string());\n     }\n \n     #[test]\n@@ -343,6 +343,6 @@ mod tests {\n         cache.clear();\n         assert!(cache.get(&1).is_none());\n         assert!(cache.get(&2).is_none());\n-        assert_eq!(cache.to_str(), \"{}\".to_string());\n+        assert_eq!(cache.to_string(), \"{}\".to_string());\n     }\n }"}, {"sha": "86283f03381dd1c68d4c7130f49bd726c57ff3f1", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -209,13 +209,11 @@ mod test {\n #[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n pub mod dl {\n-    use prelude::*;\n \n     use c_str::{CString, ToCStr};\n     use libc;\n     use ptr;\n     use result::*;\n-    use str::StrAllocating;\n     use string::String;\n \n     pub unsafe fn open_external<T: ToCStr>(filename: T) -> *mut u8 {\n@@ -243,9 +241,8 @@ pub mod dl {\n             let ret = if ptr::null() == last_error {\n                 Ok(result)\n             } else {\n-                Err(CString::new(last_error, false).as_str()\n-                                                   .unwrap()\n-                                                   .to_string())\n+                Err(String::from_str(CString::new(last_error, false).as_str()\n+                    .unwrap()))\n             };\n \n             ret"}, {"sha": "21b1e0560a5dba49ff6d0b715196d0f4d91ba957", "filename": "src/libstd/from_str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffrom_str.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -14,7 +14,6 @@\n \n use option::{Option, Some, None};\n use string::String;\n-use str::StrAllocating;\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n@@ -55,7 +54,7 @@ impl FromStr for bool {\n impl FromStr for String {\n     #[inline]\n     fn from_str(s: &str) -> Option<String> {\n-        Some(s.to_string())\n+        Some(String::from_str(s))\n     }\n }\n "}, {"sha": "ed183cbf3bc2191dac321c7a6f582144080f4d9c", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -915,7 +915,7 @@ mod test {\n     macro_rules! error( ($e:expr, $s:expr) => (\n         match $e {\n             Ok(val) => fail!(\"Should have been an error, was {:?}\", val),\n-            Err(ref err) => assert!(err.to_str().as_slice().contains($s.as_slice()),\n+            Err(ref err) => assert!(err.to_string().as_slice().contains($s.as_slice()),\n                                     format!(\"`{}` did not contain `{}`\", err, $s))\n         }\n     ) )\n@@ -1167,7 +1167,7 @@ mod test {\n         for n in range(0i,3) {\n             let f = dir.join(format!(\"{}.txt\", n));\n             let mut w = check!(File::create(&f));\n-            let msg_str = format!(\"{}{}\", prefix, n.to_str());\n+            let msg_str = format!(\"{}{}\", prefix, n.to_string());\n             let msg = msg_str.as_slice().as_bytes();\n             check!(w.write(msg));\n         }"}, {"sha": "7d293f363f0dd48331c655fcdfa4d551e0a214e9", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -532,7 +532,7 @@ mod test {\n         writer.write_line(\"testing\").unwrap();\n         writer.write_str(\"testing\").unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str().unwrap(), \"testingtesting\\ntesting\".to_string());\n+        assert_eq!(r.read_to_string().unwrap(), \"testingtesting\\ntesting\".to_string());\n     }\n \n     #[test]\n@@ -542,14 +542,14 @@ mod test {\n         writer.write_char('\\n').unwrap();\n         writer.write_char('\u1ec7').unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str().unwrap(), \"a\\n\u1ec7\".to_string());\n+        assert_eq!(r.read_to_string().unwrap(), \"a\\n\u1ec7\".to_string());\n     }\n \n     #[test]\n     fn test_read_whole_string_bad() {\n         let buf = [0xff];\n         let mut r = BufReader::new(buf);\n-        match r.read_to_str() {\n+        match r.read_to_string() {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }"}, {"sha": "fe9016453f78eb726f9cf03d3dd3cd84c75bfc30", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -233,7 +233,7 @@ use owned::Box;\n use result::{Ok, Err, Result};\n use rt::rtio;\n use slice::{Vector, MutableVector, ImmutableVector};\n-use str::{Str, StrSlice, StrAllocating};\n+use str::{Str, StrSlice};\n use str;\n use string::String;\n use uint;\n@@ -566,7 +566,7 @@ pub trait Reader {\n     fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n         if min > buf.len() {\n             return Err(IoError {\n-                detail: Some(\"the buffer is too short\".to_string()),\n+                detail: Some(String::from_str(\"the buffer is too short\")),\n                 ..standard_error(InvalidInput)\n             });\n         }\n@@ -634,7 +634,7 @@ pub trait Reader {\n     fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n         if min > len {\n             return Err(IoError {\n-                detail: Some(\"the buffer is too short\".to_string()),\n+                detail: Some(String::from_str(\"the buffer is too short\")),\n                 ..standard_error(InvalidInput)\n             });\n         }\n@@ -702,10 +702,10 @@ pub trait Reader {\n     /// This function returns all of the same errors as `read_to_end` with an\n     /// additional error if the reader's contents are not a valid sequence of\n     /// UTF-8 bytes.\n-    fn read_to_str(&mut self) -> IoResult<String> {\n+    fn read_to_string(&mut self) -> IoResult<String> {\n         self.read_to_end().and_then(|s| {\n             match str::from_utf8(s.as_slice()) {\n-                Some(s) => Ok(s.to_string()),\n+                Some(s) => Ok(String::from_str(s)),\n                 None => Err(standard_error(InvalidInput)),\n             }\n         })\n@@ -1440,7 +1440,7 @@ pub trait Buffer: Reader {\n     fn read_line(&mut self) -> IoResult<String> {\n         self.read_until('\\n' as u8).and_then(|line|\n             match str::from_utf8(line.as_slice()) {\n-                Some(s) => Ok(s.to_string()),\n+                Some(s) => Ok(String::from_str(s)),\n                 None => Err(standard_error(InvalidInput)),\n             }\n         )"}, {"sha": "79caded6711a22219d7c97af256b9df07da58653", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -443,10 +443,11 @@ mod test {\n     }\n \n     #[test]\n-    fn ipv6_addr_to_str() {\n+    fn ipv6_addr_to_string() {\n         let a1 = Ipv6Addr(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-        assert!(a1.to_str() == \"::ffff:192.0.2.128\".to_string() ||\n-                a1.to_str() == \"::FFFF:192.0.2.128\".to_string());\n-        assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_str(), \"8:9:a:b:c:d:e:f\".to_string());\n+        assert!(a1.to_string() == \"::ffff:192.0.2.128\".to_string() ||\n+                a1.to_string() == \"::FFFF:192.0.2.128\".to_string());\n+        assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n+                   \"8:9:a:b:c:d:e:f\".to_string());\n     }\n }"}, {"sha": "49322098348ff830bd0fb09528de975bb3d20158", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -467,7 +467,7 @@ mod test {\n \n     iotest!(fn listen_ip4_localhost() {\n         let socket_addr = next_test_ip4();\n-        let ip_str = socket_addr.ip.to_str();\n+        let ip_str = socket_addr.ip.to_string();\n         let port = socket_addr.port;\n         let listener = TcpListener::bind(ip_str.as_slice(), port);\n         let mut acceptor = listener.listen();\n@@ -485,7 +485,7 @@ mod test {\n \n     iotest!(fn connect_localhost() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -502,7 +502,7 @@ mod test {\n \n     iotest!(fn connect_ip4_loopback() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -519,7 +519,7 @@ mod test {\n \n     iotest!(fn connect_ip6_loopback() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -536,7 +536,7 @@ mod test {\n \n     iotest!(fn smoke_test_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -553,7 +553,7 @@ mod test {\n \n     iotest!(fn smoke_test_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -570,7 +570,7 @@ mod test {\n \n     iotest!(fn read_eof_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -587,7 +587,7 @@ mod test {\n \n     iotest!(fn read_eof_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -604,7 +604,7 @@ mod test {\n \n     iotest!(fn read_eof_twice_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -629,7 +629,7 @@ mod test {\n \n     iotest!(fn read_eof_twice_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -654,7 +654,7 @@ mod test {\n \n     iotest!(fn write_close_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -681,7 +681,7 @@ mod test {\n \n     iotest!(fn write_close_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -708,7 +708,7 @@ mod test {\n \n     iotest!(fn multiple_connect_serial_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let max = 10u;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n@@ -729,7 +729,7 @@ mod test {\n \n     iotest!(fn multiple_connect_serial_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let max = 10u;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n@@ -750,7 +750,7 @@ mod test {\n \n     iotest!(fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         static MAX: int = 10;\n         let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n@@ -772,7 +772,7 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_str();\n+            let ip_str = addr.ip.to_string();\n             let port = addr.port;\n             if i == MAX { return }\n \n@@ -789,7 +789,7 @@ mod test {\n \n     iotest!(fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         static MAX: int = 10;\n         let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n@@ -811,7 +811,7 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_str();\n+            let ip_str = addr.ip.to_string();\n             let port = addr.port;\n             if i == MAX { return }\n \n@@ -829,7 +829,7 @@ mod test {\n     iotest!(fn multiple_connect_interleaved_lazy_schedule_ip4() {\n         static MAX: int = 10;\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -850,7 +850,7 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_str();\n+            let ip_str = addr.ip.to_string();\n             let port = addr.port;\n             if i == MAX { return }\n \n@@ -868,7 +868,7 @@ mod test {\n     iotest!(fn multiple_connect_interleaved_lazy_schedule_ip6() {\n         static MAX: int = 10;\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -889,7 +889,7 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_str();\n+            let ip_str = addr.ip.to_string();\n             let port = addr.port;\n             if i == MAX { return }\n \n@@ -905,7 +905,7 @@ mod test {\n     })\n \n     pub fn socket_name(addr: SocketAddr) {\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut listener = TcpListener::bind(ip_str.as_slice(), port).unwrap();\n \n@@ -917,7 +917,7 @@ mod test {\n     }\n \n     pub fn peer_name(addr: SocketAddr) {\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n         spawn(proc() {\n@@ -954,7 +954,7 @@ mod test {\n         let port = addr.port;\n         let (tx, rx) = channel();\n         spawn(proc() {\n-            let ip_str = addr.ip.to_str();\n+            let ip_str = addr.ip.to_string();\n             let mut srv = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n             tx.send(());\n             let mut cl = srv.accept().unwrap();\n@@ -965,7 +965,7 @@ mod test {\n         });\n \n         rx.recv();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let mut c = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n         let mut b = [0, ..10];\n         assert_eq!(c.read(b), Ok(1));\n@@ -975,7 +975,7 @@ mod test {\n \n     iotest!(fn double_bind() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let listener = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen();\n         assert!(listener.is_ok());\n@@ -994,15 +994,15 @@ mod test {\n         let (tx, rx) = channel();\n \n         spawn(proc() {\n-            let ip_str = addr.ip.to_str();\n+            let ip_str = addr.ip.to_string();\n             rx.recv();\n             let _stream = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n             // Close\n             rx.recv();\n         });\n \n         {\n-            let ip_str = addr.ip.to_str();\n+            let ip_str = addr.ip.to_string();\n             let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n             tx.send(());\n             {\n@@ -1012,12 +1012,12 @@ mod test {\n             }\n             // Close listener\n         }\n-        let _listener = TcpListener::bind(addr.ip.to_str().as_slice(), port);\n+        let _listener = TcpListener::bind(addr.ip.to_string().as_slice(), port);\n     })\n \n     iotest!(fn tcp_clone_smoke() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -1048,7 +1048,7 @@ mod test {\n \n     iotest!(fn tcp_clone_two_read() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n         let (tx1, rx) = channel();\n@@ -1082,7 +1082,7 @@ mod test {\n \n     iotest!(fn tcp_clone_two_write() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n@@ -1111,7 +1111,7 @@ mod test {\n         use rt::rtio::RtioTcpStream;\n \n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let a = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen();\n         spawn(proc() {\n@@ -1129,7 +1129,7 @@ mod test {\n \n     iotest!(fn accept_timeout() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut a = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen().unwrap();\n \n@@ -1150,7 +1150,7 @@ mod test {\n         if !cfg!(target_os = \"freebsd\") {\n             let (tx, rx) = channel();\n             spawn(proc() {\n-                tx.send(TcpStream::connect(addr.ip.to_str().as_slice(),\n+                tx.send(TcpStream::connect(addr.ip.to_string().as_slice(),\n                                            port).unwrap());\n             });\n             let _l = rx.recv();\n@@ -1168,15 +1168,15 @@ mod test {\n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n         spawn(proc() {\n-            drop(TcpStream::connect(addr.ip.to_str().as_slice(),\n+            drop(TcpStream::connect(addr.ip.to_string().as_slice(),\n                                     port).unwrap());\n         });\n         a.accept().unwrap();\n     })\n \n     iotest!(fn close_readwrite_smoke() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n@@ -1214,7 +1214,7 @@ mod test {\n \n     iotest!(fn close_read_wakes_up() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n@@ -1241,7 +1241,7 @@ mod test {\n \n     iotest!(fn readwrite_timeouts() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n@@ -1275,7 +1275,7 @@ mod test {\n \n     iotest!(fn read_timeouts() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n@@ -1305,7 +1305,7 @@ mod test {\n \n     iotest!(fn write_timeouts() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n@@ -1334,7 +1334,7 @@ mod test {\n \n     iotest!(fn timeout_concurrent_read() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_str();\n+        let ip_str = addr.ip.to_string();\n         let port = addr.port;\n         let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n@@ -1363,15 +1363,15 @@ mod test {\n \n     iotest!(fn clone_while_reading() {\n         let addr = next_test_ip6();\n-        let listen = TcpListener::bind(addr.ip.to_str().as_slice(), addr.port);\n+        let listen = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n         let mut accept = listen.listen().unwrap();\n \n         // Enqueue a task to write to a socket\n         let (tx, rx) = channel();\n         let (txdone, rxdone) = channel();\n         let txdone2 = txdone.clone();\n         spawn(proc() {\n-            let mut tcp = TcpStream::connect(addr.ip.to_str().as_slice(),\n+            let mut tcp = TcpStream::connect(addr.ip.to_string().as_slice(),\n                                              addr.port).unwrap();\n             rx.recv();\n             tcp.write_u8(0).unwrap();"}, {"sha": "8f1046b62fd91040f188e07b661df518f2d44b6f", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -615,7 +615,7 @@ mod tests {\n     })\n \n     pub fn read_all(input: &mut Reader) -> String {\n-        input.read_to_str().unwrap()\n+        input.read_to_string().unwrap()\n     }\n \n     pub fn run_output(cmd: Command) -> String {"}, {"sha": "cdd083202e085217d3bf74583694dd3d245b11b3", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -391,7 +391,7 @@ mod tests {\n             set_stdout(box w);\n             println!(\"hello!\");\n         });\n-        assert_eq!(r.read_to_str().unwrap(), \"hello!\\n\".to_string());\n+        assert_eq!(r.read_to_string().unwrap(), \"hello!\\n\".to_string());\n     })\n \n     iotest!(fn capture_stderr() {\n@@ -404,7 +404,7 @@ mod tests {\n             ::realstd::io::stdio::set_stderr(box w);\n             fail!(\"my special message\");\n         });\n-        let s = r.read_to_str().unwrap();\n+        let s = r.read_to_string().unwrap();\n         assert!(s.as_slice().contains(\"my special message\"));\n     })\n }"}, {"sha": "2acf12b76c00adea15f127673a8277222759d125", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -379,21 +379,21 @@ mod test {\n         let mut r = BufReader::new(data.as_bytes());\n         {\n             let mut r = LimitReader::new(r.by_ref(), 3);\n-            assert_eq!(r.read_line(), Ok(\"012\".to_str()));\n+            assert_eq!(r.read_line(), Ok(\"012\".to_string()));\n             assert_eq!(r.limit(), 0);\n             assert_eq!(r.read_line().err().unwrap().kind, io::EndOfFile);\n         }\n         {\n             let mut r = LimitReader::new(r.by_ref(), 9);\n-            assert_eq!(r.read_line(), Ok(\"3456789\\n\".to_str()));\n+            assert_eq!(r.read_line(), Ok(\"3456789\\n\".to_string()));\n             assert_eq!(r.limit(), 1);\n-            assert_eq!(r.read_line(), Ok(\"0\".to_str()));\n+            assert_eq!(r.read_line(), Ok(\"0\".to_string()));\n         }\n         {\n             let mut r = LimitReader::new(r.by_ref(), 100);\n             assert_eq!(r.read_char(), Ok('1'));\n             assert_eq!(r.limit(), 99);\n-            assert_eq!(r.read_line(), Ok(\"23456789\\n\".to_str()));\n+            assert_eq!(r.read_line(), Ok(\"23456789\\n\".to_string()));\n         }\n     }\n "}, {"sha": "680620f5a752fdd0e455d7578d0b81c18006bf96", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -245,7 +245,7 @@ impl FloatMath for f32 {\n ///\n /// * num - The float value\n #[inline]\n-pub fn to_str(num: f32) -> String {\n+pub fn to_string(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r"}, {"sha": "3180ee28c6fee19442d8278894c852f3ff556dbb", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -253,7 +253,7 @@ impl FloatMath for f64 {\n ///\n /// * num - The float value\n #[inline]\n-pub fn to_str(num: f64) -> String {\n+pub fn to_string(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r"}, {"sha": "3c01edf233925986005a4803c3dd1148191fd4e3", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -55,7 +55,7 @@ impl FromStrRadix for $T {\n \n /// Convert to a string as a byte slice in a given base.\n ///\n-/// Use in place of x.to_str() when you do not need to store the string permanently\n+/// Use in place of x.to_string() when you do not need to store the string permanently\n ///\n /// # Examples\n ///\n@@ -143,7 +143,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_to_str() {\n+    fn test_to_string() {\n         assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_string());\n         assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_string());\n         assert_eq!((-1 as $T).to_str_radix(10u), \"-1\".to_string());\n@@ -155,28 +155,28 @@ mod tests {\n     #[test]\n     fn test_int_to_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8_val.to_str(), \"127\".to_string());\n+        assert_eq!(i8_val.to_string(), \"127\".to_string());\n \n         i8_val += 1 as i8;\n-        assert_eq!(i8_val.to_str(), \"-128\".to_string());\n+        assert_eq!(i8_val.to_string(), \"-128\".to_string());\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16_val.to_str(), \"32767\".to_string());\n+        assert_eq!(i16_val.to_string(), \"32767\".to_string());\n \n         i16_val += 1 as i16;\n-        assert_eq!(i16_val.to_str(), \"-32768\".to_string());\n+        assert_eq!(i16_val.to_string(), \"-32768\".to_string());\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32_val.to_str(), \"2147483647\".to_string());\n+        assert_eq!(i32_val.to_string(), \"2147483647\".to_string());\n \n         i32_val += 1 as i32;\n-        assert_eq!(i32_val.to_str(), \"-2147483648\".to_string());\n+        assert_eq!(i32_val.to_string(), \"-2147483648\".to_string());\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64_val.to_str(), \"9223372036854775807\".to_string());\n+        assert_eq!(i64_val.to_string(), \"9223372036854775807\".to_string());\n \n         i64_val += 1 as i64;\n-        assert_eq!(i64_val.to_str(), \"-9223372036854775808\".to_string());\n+        assert_eq!(i64_val.to_string(), \"-9223372036854775808\".to_string());\n     }\n \n     #[test]"}, {"sha": "88fc6e1ffd85f743be2e01d6365887f3643ecbf7", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -146,7 +146,7 @@ static NAN_BUF:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n /**\n  * Converts an integral number to its string representation as a byte vector.\n  * This is meant to be a common base implementation for all integral string\n- * conversion functions like `to_str()` or `to_str_radix()`.\n+ * conversion functions like `to_string()` or `to_str_radix()`.\n  *\n  * # Arguments\n  * - `num`           - The number to convert. Accepts any number that\n@@ -226,7 +226,7 @@ pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f:\n /**\n  * Converts a number to its string representation as a byte vector.\n  * This is meant to be a common base implementation for all numeric string\n- * conversion functions like `to_str()` or `to_str_radix()`.\n+ * conversion functions like `to_string()` or `to_str_radix()`.\n  *\n  * # Arguments\n  * - `num`           - The number to convert. Accepts any number that\n@@ -894,9 +894,9 @@ mod bench {\n         use f64;\n \n         #[bench]\n-        fn float_to_str(b: &mut Bencher) {\n+        fn float_to_string(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { f64::to_str(rng.gen()); })\n+            b.iter(|| { f64::to_string(rng.gen()); })\n         }\n     }\n }"}, {"sha": "cfcaf0fa8daa35d61ebaa203ecaf86446964fa0e", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -56,7 +56,7 @@ impl FromStrRadix for $T {\n \n /// Convert to a string as a byte slice in a given base.\n ///\n-/// Use in place of x.to_str() when you do not need to store the string permanently\n+/// Use in place of x.to_string() when you do not need to store the string permanently\n ///\n /// # Examples\n ///\n@@ -101,7 +101,7 @@ mod tests {\n     use u16;\n \n     #[test]\n-    pub fn test_to_str() {\n+    pub fn test_to_string() {\n         assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_string());\n         assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_string());\n         assert_eq!((2 as $T).to_str_radix(10u), \"2\".to_string());\n@@ -141,28 +141,28 @@ mod tests {\n     #[test]\n     fn test_uint_to_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n-        assert_eq!(u8_val.to_str(), \"255\".to_string());\n+        assert_eq!(u8_val.to_string(), \"255\".to_string());\n \n         u8_val += 1 as u8;\n-        assert_eq!(u8_val.to_str(), \"0\".to_string());\n+        assert_eq!(u8_val.to_string(), \"0\".to_string());\n \n         let mut u16_val: u16 = 65_535_u16;\n-        assert_eq!(u16_val.to_str(), \"65535\".to_string());\n+        assert_eq!(u16_val.to_string(), \"65535\".to_string());\n \n         u16_val += 1 as u16;\n-        assert_eq!(u16_val.to_str(), \"0\".to_string());\n+        assert_eq!(u16_val.to_string(), \"0\".to_string());\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert_eq!(u32_val.to_str(), \"4294967295\".to_string());\n+        assert_eq!(u32_val.to_string(), \"4294967295\".to_string());\n \n         u32_val += 1 as u32;\n-        assert_eq!(u32_val.to_str(), \"0\".to_string());\n+        assert_eq!(u32_val.to_string(), \"0\".to_string());\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert_eq!(u64_val.to_str(), \"18446744073709551615\".to_string());\n+        assert_eq!(u64_val.to_string(), \"18446744073709551615\".to_string());\n \n         u64_val += 1 as u64;\n-        assert_eq!(u64_val.to_str(), \"0\".to_string());\n+        assert_eq!(u64_val.to_string(), \"0\".to_string());\n     }\n \n     #[test]"}, {"sha": "db56b387f8d023965888ad71043105c3a46e6248", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -223,8 +223,8 @@ fn with_env_lock<T>(f: || -> T) -> T {\n /// ```\n pub fn env() -> Vec<(String,String)> {\n     env_as_bytes().move_iter().map(|(k,v)| {\n-        let k = str::from_utf8_lossy(k.as_slice()).to_string();\n-        let v = str::from_utf8_lossy(v.as_slice()).to_string();\n+        let k = String::from_str(str::from_utf8_lossy(k.as_slice()).as_slice());\n+        let v = String::from_str(str::from_utf8_lossy(v.as_slice()).as_slice());\n         (k,v)\n     }).collect()\n }\n@@ -334,7 +334,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n /// }\n /// ```\n pub fn getenv(n: &str) -> Option<String> {\n-    getenv_as_bytes(n).map(|v| str::from_utf8_lossy(v.as_slice()).to_string())\n+    getenv_as_bytes(n).map(|v| String::from_str(str::from_utf8_lossy(v.as_slice()).as_slice()))\n }\n \n #[cfg(unix)]"}, {"sha": "5c6e140bd29b30aa2827273f5882a9f95719bea6", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -545,7 +545,7 @@ mod tests {\n             ($path:expr, $disp:ident, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    assert!(path.$disp().to_str().as_slice() == $exp);\n+                    assert!(path.$disp().to_string().as_slice() == $exp);\n                 }\n             )\n         )"}, {"sha": "206f75739e82d1e2f72f8ae7d8a9455964f92fd4", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -1314,9 +1314,9 @@ mod tests {\n     #[test]\n     fn test_display_str() {\n         let path = Path::new(\"foo\");\n-        assert_eq!(path.display().to_str(), \"foo\".to_string());\n+        assert_eq!(path.display().to_string(), \"foo\".to_string());\n         let path = Path::new(b\"\\\\\");\n-        assert_eq!(path.filename_display().to_str(), \"\".to_string());\n+        assert_eq!(path.filename_display().to_string(), \"\".to_string());\n \n         let path = Path::new(\"foo\");\n         let mo = path.display().as_maybe_owned();"}, {"sha": "6d60fc19d5dc9b7e45951f37d3432c4b82367cc2", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -78,7 +78,7 @@\n #[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek};\n #[doc(no_inline)] pub use str::{Str, StrVector, StrSlice, OwnedStr};\n #[doc(no_inline)] pub use str::{IntoMaybeOwned, StrAllocating};\n-#[doc(no_inline)] pub use to_str::{ToStr, IntoStr};\n+#[doc(no_inline)] pub use to_str::{ToString, IntoStr};\n #[doc(no_inline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n #[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};"}, {"sha": "72cc596085e075ff7fbd7dd6b7f1f3dcc6528c1a", "filename": "src/libstd/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -638,7 +638,7 @@ mod test {\n             });\n         assert!(r.is_ok());\n \n-        let output = reader.read_to_str().unwrap();\n+        let output = reader.read_to_string().unwrap();\n         assert_eq!(output, \"Hello, world!\".to_string());\n     }\n "}, {"sha": "c19fd81b5705667185f8a8a9391fca11a9114dba", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -10,7 +10,7 @@\n \n /*!\n \n-The `ToStr` trait for converting to strings\n+The `ToString` trait for converting to strings\n \n */\n \n@@ -20,19 +20,19 @@ use fmt;\n use string::String;\n \n /// A generic trait for converting a value to a string\n-pub trait ToStr {\n+pub trait ToString {\n     /// Converts the value of `self` to an owned string\n-    fn to_str(&self) -> String;\n+    fn to_string(&self) -> String;\n }\n \n /// Trait for converting a type to a string, consuming it in the process.\n pub trait IntoStr {\n     /// Consume and convert to a string.\n-    fn into_str(self) -> String;\n+    fn into_string(self) -> String;\n }\n \n-impl<T: fmt::Show> ToStr for T {\n-    fn to_str(&self) -> String {\n+impl<T: fmt::Show> ToString for T {\n+    fn to_string(&self) -> String {\n         format!(\"{}\", *self)\n     }\n }\n@@ -44,23 +44,23 @@ mod tests {\n \n     #[test]\n     fn test_simple_types() {\n-        assert_eq!(1i.to_str(), \"1\".to_string());\n-        assert_eq!((-1i).to_str(), \"-1\".to_string());\n-        assert_eq!(200u.to_str(), \"200\".to_string());\n-        assert_eq!(2u8.to_str(), \"2\".to_string());\n-        assert_eq!(true.to_str(), \"true\".to_string());\n-        assert_eq!(false.to_str(), \"false\".to_string());\n-        assert_eq!(().to_str(), \"()\".to_string());\n-        assert_eq!((\"hi\".to_string()).to_str(), \"hi\".to_string());\n+        assert_eq!(1i.to_string(), \"1\".to_string());\n+        assert_eq!((-1i).to_string(), \"-1\".to_string());\n+        assert_eq!(200u.to_string(), \"200\".to_string());\n+        assert_eq!(2u8.to_string(), \"2\".to_string());\n+        assert_eq!(true.to_string(), \"true\".to_string());\n+        assert_eq!(false.to_string(), \"false\".to_string());\n+        assert_eq!(().to_string(), \"()\".to_string());\n+        assert_eq!((\"hi\".to_string()).to_string(), \"hi\".to_string());\n     }\n \n     #[test]\n     fn test_vectors() {\n         let x: Vec<int> = vec![];\n-        assert_eq!(x.to_str(), \"[]\".to_string());\n-        assert_eq!((vec![1i]).to_str(), \"[1]\".to_string());\n-        assert_eq!((vec![1i, 2, 3]).to_str(), \"[1, 2, 3]\".to_string());\n-        assert!((vec![vec![], vec![1i], vec![1i, 1]]).to_str() ==\n+        assert_eq!(x.to_string(), \"[]\".to_string());\n+        assert_eq!((vec![1i]).to_string(), \"[1]\".to_string());\n+        assert_eq!((vec![1i, 2, 3]).to_string(), \"[1, 2, 3]\".to_string());\n+        assert!((vec![vec![], vec![1i], vec![1i, 1]]).to_string() ==\n                \"[[], [1], [1, 1]]\".to_string());\n     }\n }"}, {"sha": "eeef77e41820981b5d8f0b3e7675a75c39d256b9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -681,7 +681,7 @@ pub enum IntTy {\n \n impl fmt::Show for IntTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", ast_util::int_ty_to_str(*self, None))\n+        write!(f, \"{}\", ast_util::int_ty_to_string(*self, None))\n     }\n }\n \n@@ -696,7 +696,7 @@ pub enum UintTy {\n \n impl fmt::Show for UintTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", ast_util::uint_ty_to_str(*self, None))\n+        write!(f, \"{}\", ast_util::uint_ty_to_string(*self, None))\n     }\n }\n \n@@ -708,7 +708,7 @@ pub enum FloatTy {\n \n impl fmt::Show for FloatTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", ast_util::float_ty_to_str(*self))\n+        write!(f, \"{}\", ast_util::float_ty_to_string(*self))\n     }\n }\n "}, {"sha": "c95ea4a24aadb98256ae59c47fe60c79c7396817", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -79,7 +79,7 @@ impl<'a, T: Copy> Iterator<T> for Values<'a, T> {\n /// The type of the iterator used by with_path.\n pub type PathElems<'a, 'b> = iter::Chain<Values<'a, PathElem>, LinkedPath<'b>>;\n \n-pub fn path_to_str<PI: Iterator<PathElem>>(mut path: PI) -> String {\n+pub fn path_to_string<PI: Iterator<PathElem>>(mut path: PI) -> String {\n     let itr = token::get_ident_interner();\n \n     path.fold(String::new(), |mut s, e| {\n@@ -250,7 +250,7 @@ impl Map {\n         match abi {\n             Some(abi) => abi,\n             None => fail!(\"expected foreign mod or inlined parent, found {}\",\n-                          self.node_to_str(parent))\n+                          self.node_to_string(parent))\n         }\n     }\n \n@@ -265,7 +265,7 @@ impl Map {\n     pub fn expect_item(&self, id: NodeId) -> Gc<Item> {\n         match self.find(id) {\n             Some(NodeItem(item)) => item,\n-            _ => fail!(\"expected item, found {}\", self.node_to_str(id))\n+            _ => fail!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -283,21 +283,21 @@ impl Map {\n                     _ => fail!(\"struct ID bound to enum variant that isn't struct-like\"),\n                 }\n             }\n-            _ => fail!(format!(\"expected struct, found {}\", self.node_to_str(id))),\n+            _ => fail!(format!(\"expected struct, found {}\", self.node_to_string(id))),\n         }\n     }\n \n     pub fn expect_variant(&self, id: NodeId) -> P<Variant> {\n         match self.find(id) {\n             Some(NodeVariant(variant)) => variant,\n-            _ => fail!(format!(\"expected variant, found {}\", self.node_to_str(id))),\n+            _ => fail!(format!(\"expected variant, found {}\", self.node_to_string(id))),\n         }\n     }\n \n     pub fn expect_foreign_item(&self, id: NodeId) -> Gc<ForeignItem> {\n         match self.find(id) {\n             Some(NodeForeignItem(item)) => item,\n-            _ => fail!(\"expected foreign item, found {}\", self.node_to_str(id))\n+            _ => fail!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -326,13 +326,13 @@ impl Map {\n         self.with_path_next(id, None, f)\n     }\n \n-    pub fn path_to_str(&self, id: NodeId) -> String {\n-        self.with_path(id, |path| path_to_str(path))\n+    pub fn path_to_string(&self, id: NodeId) -> String {\n+        self.with_path(id, |path| path_to_string(path))\n     }\n \n     fn path_to_str_with_ident(&self, id: NodeId, i: Ident) -> String {\n         self.with_path(id, |path| {\n-            path_to_str(path.chain(Some(PathName(i.name)).move_iter()))\n+            path_to_string(path.chain(Some(PathName(i.name)).move_iter()))\n         })\n     }\n \n@@ -416,8 +416,8 @@ impl Map {\n             .unwrap_or_else(|| fail!(\"AstMap.span: could not find span for id {}\", id))\n     }\n \n-    pub fn node_to_str(&self, id: NodeId) -> String {\n-        node_id_to_str(self, id)\n+    pub fn node_to_string(&self, id: NodeId) -> String {\n+        node_id_to_string(self, id)\n     }\n }\n \n@@ -664,7 +664,7 @@ pub fn map_decoded_item<F: FoldOps>(map: &Map,\n     ii\n }\n \n-fn node_id_to_str(map: &Map, id: NodeId) -> String {\n+fn node_id_to_string(map: &Map, id: NodeId) -> String {\n     match map.find(id) {\n         Some(NodeItem(item)) => {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n@@ -689,43 +689,43 @@ fn node_id_to_str(map: &Map, id: NodeId) -> String {\n         Some(NodeMethod(m)) => {\n             format!(\"method {} in {} (id={})\",\n                     token::get_ident(m.ident),\n-                    map.path_to_str(id), id)\n+                    map.path_to_string(id), id)\n         }\n         Some(NodeTraitMethod(ref tm)) => {\n             let m = ast_util::trait_method_to_ty_method(&**tm);\n             format!(\"method {} in {} (id={})\",\n                     token::get_ident(m.ident),\n-                    map.path_to_str(id), id)\n+                    map.path_to_string(id), id)\n         }\n         Some(NodeVariant(ref variant)) => {\n             format!(\"variant {} in {} (id={})\",\n                     token::get_ident(variant.node.name),\n-                    map.path_to_str(id), id)\n+                    map.path_to_string(id), id)\n         }\n         Some(NodeExpr(ref expr)) => {\n-            format!(\"expr {} (id={})\", pprust::expr_to_str(&**expr), id)\n+            format!(\"expr {} (id={})\", pprust::expr_to_string(&**expr), id)\n         }\n         Some(NodeStmt(ref stmt)) => {\n-            format!(\"stmt {} (id={})\", pprust::stmt_to_str(&**stmt), id)\n+            format!(\"stmt {} (id={})\", pprust::stmt_to_string(&**stmt), id)\n         }\n         Some(NodeArg(ref pat)) => {\n-            format!(\"arg {} (id={})\", pprust::pat_to_str(&**pat), id)\n+            format!(\"arg {} (id={})\", pprust::pat_to_string(&**pat), id)\n         }\n         Some(NodeLocal(ref pat)) => {\n-            format!(\"local {} (id={})\", pprust::pat_to_str(&**pat), id)\n+            format!(\"local {} (id={})\", pprust::pat_to_string(&**pat), id)\n         }\n         Some(NodePat(ref pat)) => {\n-            format!(\"pat {} (id={})\", pprust::pat_to_str(&**pat), id)\n+            format!(\"pat {} (id={})\", pprust::pat_to_string(&**pat), id)\n         }\n         Some(NodeBlock(ref block)) => {\n-            format!(\"block {} (id={})\", pprust::block_to_str(&**block), id)\n+            format!(\"block {} (id={})\", pprust::block_to_string(&**block), id)\n         }\n         Some(NodeStructCtor(_)) => {\n-            format!(\"struct_ctor {} (id={})\", map.path_to_str(id), id)\n+            format!(\"struct_ctor {} (id={})\", map.path_to_string(id), id)\n         }\n         Some(NodeLifetime(ref l)) => {\n             format!(\"lifetime {} (id={})\",\n-                    pprust::lifetime_to_str(&**l), id)\n+                    pprust::lifetime_to_string(&**l), id)\n         }\n         None => {\n             format!(\"unknown node (id={})\", id)"}, {"sha": "57c60b4a9490351b611b6699dbb87e7294d262cc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -48,7 +48,7 @@ pub fn stmt_id(s: &Stmt) -> NodeId {\n     }\n }\n \n-pub fn binop_to_str(op: BinOp) -> &'static str {\n+pub fn binop_to_string(op: BinOp) -> &'static str {\n     match op {\n         BiAdd => \"+\",\n         BiSub => \"-\",\n@@ -87,7 +87,7 @@ pub fn is_shift_binop(b: BinOp) -> bool {\n     }\n }\n \n-pub fn unop_to_str(op: UnOp) -> &'static str {\n+pub fn unop_to_string(op: UnOp) -> &'static str {\n     match op {\n       UnBox => \"box(GC) \",\n       UnUniq => \"box() \",\n@@ -103,7 +103,7 @@ pub fn is_path(e: Gc<Expr>) -> bool {\n \n // Get a string representation of a signed int type, with its value.\n // We want to avoid \"45int\" and \"-3int\" in favor of \"45\" and \"-3\"\n-pub fn int_ty_to_str(t: IntTy, val: Option<i64>) -> String {\n+pub fn int_ty_to_string(t: IntTy, val: Option<i64>) -> String {\n     let s = match t {\n         TyI if val.is_some() => \"i\",\n         TyI => \"int\",\n@@ -133,7 +133,7 @@ pub fn int_ty_max(t: IntTy) -> u64 {\n \n // Get a string representation of an unsigned int type, with its value.\n // We want to avoid \"42uint\" in favor of \"42u\"\n-pub fn uint_ty_to_str(t: UintTy, val: Option<u64>) -> String {\n+pub fn uint_ty_to_string(t: UintTy, val: Option<u64>) -> String {\n     let s = match t {\n         TyU if val.is_some() => \"u\",\n         TyU => \"uint\",\n@@ -158,7 +158,7 @@ pub fn uint_ty_max(t: UintTy) -> u64 {\n     }\n }\n \n-pub fn float_ty_to_str(t: FloatTy) -> String {\n+pub fn float_ty_to_string(t: FloatTy) -> String {\n     match t {\n         TyF32 => \"f32\".to_string(),\n         TyF64 => \"f64\".to_string(),\n@@ -229,11 +229,11 @@ pub fn unguarded_pat(a: &Arm) -> Option<Vec<Gc<Pat>>> {\n /// listed as `__extensions__::method_name::hash`, with no indication\n /// of the type).\n pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n-    let mut pretty = pprust::ty_to_str(ty);\n+    let mut pretty = pprust::ty_to_string(ty);\n     match *trait_ref {\n         Some(ref trait_ref) => {\n             pretty.push_char('.');\n-            pretty.push_str(pprust::path_to_str(&trait_ref.path).as_slice());\n+            pretty.push_str(pprust::path_to_string(&trait_ref.path).as_slice());\n         }\n         None => {}\n     }"}, {"sha": "b3adf1daf418ca84e72afc556c55e3be95255a00", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -367,7 +367,7 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn span_to_str(&self, sp: Span) -> String {\n+    pub fn span_to_string(&self, sp: Span) -> String {\n         if self.files.borrow().len() == 0 && sp == DUMMY_SP {\n             return \"no-location\".to_string();\n         }\n@@ -687,7 +687,7 @@ mod test {\n         // Test span_to_str for a span ending at the end of filemap\n         let cm = init_code_map();\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n-        let sstr =  cm.span_to_str(span);\n+        let sstr =  cm.span_to_string(span);\n \n         assert_eq!(sstr, \"blork.rs:2:1: 2:12\".to_string());\n     }"}, {"sha": "3805390776e8da9b4ec168743047c18fb78158c2", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -269,7 +269,7 @@ fn print_diagnostic(dst: &mut EmitterWriter,\n     }\n \n     try!(print_maybe_styled(dst,\n-                            format!(\"{}: \", lvl.to_str()).as_slice(),\n+                            format!(\"{}: \", lvl.to_string()).as_slice(),\n                             term::attr::ForegroundColor(lvl.color())));\n     try!(print_maybe_styled(dst,\n                             format!(\"{}\\n\", msg).as_slice(),\n@@ -349,14 +349,14 @@ impl Emitter for EmitterWriter {\n fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         msg: &str, lvl: Level, custom: bool) -> io::IoResult<()> {\n     let sp = rsp.span();\n-    let ss = cm.span_to_str(sp);\n+    let ss = cm.span_to_string(sp);\n     let lines = cm.span_to_lines(sp);\n     if custom {\n         // we want to tell compiletest/runtest to look at the last line of the\n         // span (since `custom_highlight_lines` displays an arrow to the end of\n         // the span)\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n-        let ses = cm.span_to_str(span_end);\n+        let ses = cm.span_to_string(span_end);\n         try!(print_diagnostic(dst, ses.as_slice(), lvl, msg));\n         if rsp.is_full_span() {\n             try!(custom_highlight_lines(dst, cm, sp, lvl, lines));\n@@ -493,7 +493,7 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n         let ss = ei.callee\n                    .span\n                    .as_ref()\n-                   .map_or(\"\".to_string(), |span| cm.span_to_str(*span));\n+                   .map_or(\"\".to_string(), |span| cm.span_to_string(*span));\n         let (pre, post) = match ei.callee.format {\n             codemap::MacroAttribute => (\"#[\", \"]\"),\n             codemap::MacroBang => (\"\", \"!\")\n@@ -502,7 +502,7 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n                               format!(\"in expansion of {}{}{}\", pre,\n                                       ei.callee.name,\n                                       post).as_slice()));\n-        let ss = cm.span_to_str(ei.call_site);\n+        let ss = cm.span_to_string(ei.call_site);\n         try!(print_diagnostic(w, ss.as_slice(), Note, \"expansion site\"));\n         try!(print_macro_backtrace(w, cm, ei.call_site));\n     }"}, {"sha": "13738e658e9f97fd7edd5563cab06ec71cf1e8b6", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -64,7 +64,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     'statement: loop {\n         match state {\n             Asm => {\n-                let (s, style) = match expr_to_str(cx, p.parse_expr(),\n+                let (s, style) = match expr_to_string(cx, p.parse_expr(),\n                                                    \"inline assembly must be a string literal.\") {\n                     Some((s, st)) => (s, st),\n                     // let compilation continue\n@@ -205,7 +205,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     // Append an input operand, with the form of (\"0\", expr)\n     // that links to an output operand.\n     for &(i, out) in read_write_operands.iter() {\n-        inputs.push((token::intern_and_get_ident(i.to_str().as_slice()),\n+        inputs.push((token::intern_and_get_ident(i.to_string().as_slice()),\n                                                  out));\n     }\n "}, {"sha": "a540b23551b534437a80684cc0d1df3e6762a758", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -533,7 +533,7 @@ impl<'a> ExtCtxt<'a> {\n /// Extract a string literal from the macro expanded version of `expr`,\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n-pub fn expr_to_str(cx: &mut ExtCtxt, expr: Gc<ast::Expr>, err_msg: &str)\n+pub fn expr_to_string(cx: &mut ExtCtxt, expr: Gc<ast::Expr>, err_msg: &str)\n                    -> Option<(InternedString, ast::StrStyle)> {\n     // we want to be able to handle e.g. concat(\"foo\", \"bar\")\n     let expr = cx.expand_expr(expr);"}, {"sha": "b24cfb85794edcf2c5754f128f933243429e12d6", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -70,7 +70,7 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Some(exprs) => exprs\n     };\n \n-    let var = match expr_to_str(cx,\n+    let var = match expr_to_string(cx,\n                                 *exprs.get(0),\n                                 \"expected string literal\") {\n         None => return DummyResult::expr(sp),\n@@ -83,7 +83,7 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                                 var).as_slice())\n         }\n         2 => {\n-            match expr_to_str(cx, *exprs.get(1), \"expected string literal\") {\n+            match expr_to_string(cx, *exprs.get(1), \"expected string literal\") {\n                 None => return DummyResult::expr(sp),\n                 Some((s, _style)) => s\n             }"}, {"sha": "74cede2a125add771ed548a336517dc45d83e104", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -1183,7 +1183,7 @@ mod test {\n         // should fail:\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             deriving_hash_type_parameter: false,\n-            crate_name: \"test\".to_str(),\n+            crate_name: \"test\".to_string(),\n         };\n         expand_crate(&sess,cfg,vec!(),vec!(),crate_ast);\n     }\n@@ -1200,7 +1200,7 @@ mod test {\n             Vec::new(), &sess);\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             deriving_hash_type_parameter: false,\n-            crate_name: \"test\".to_str(),\n+            crate_name: \"test\".to_string(),\n         };\n         expand_crate(&sess,cfg,vec!(),vec!(),crate_ast);\n     }\n@@ -1216,7 +1216,7 @@ mod test {\n             Vec::new(), &sess);\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             deriving_hash_type_parameter: false,\n-            crate_name: \"test\".to_str(),\n+            crate_name: \"test\".to_string(),\n         };\n         expand_crate(&sess, cfg, vec!(), vec!(), crate_ast);\n     }\n@@ -1253,7 +1253,7 @@ mod test {\n         // the cfg argument actually does matter, here...\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             deriving_hash_type_parameter: false,\n-            crate_name: \"test\".to_str(),\n+            crate_name: \"test\".to_string(),\n         };\n         expand_crate(&ps,cfg,vec!(),vec!(),crate_ast)\n     }\n@@ -1272,7 +1272,7 @@ mod test {\n     //}\n     //fn expand_and_resolve_and_pretty_print (crate_str: @str) -> String {\n         //let resolved_ast = expand_and_resolve(crate_str);\n-        //pprust::to_str(&resolved_ast,fake_print_crate,get_ident_interner())\n+        //pprust::to_string(&resolved_ast,fake_print_crate,get_ident_interner())\n     //}\n \n     #[test] fn macro_tokens_should_match(){\n@@ -1504,7 +1504,7 @@ mod test {\n     }\n \n     #[test] fn fmt_in_macro_used_inside_module_macro() {\n-        let crate_str = \"macro_rules! fmt_wrap(($b:expr)=>($b.to_str()))\n+        let crate_str = \"macro_rules! fmt_wrap(($b:expr)=>($b.to_string()))\n macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}))\n foo_module!()\n \".to_string();"}, {"sha": "f486d2de3398bd564e6d787435d663d8d8422102", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -126,7 +126,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n                 _ => {\n                     ecx.span_err(p.span,\n                                  format!(\"expected ident for named argument, but found `{}`\",\n-                                         p.this_token_to_str()).as_slice());\n+                                         p.this_token_to_string()).as_slice());\n                     return (invocation, None);\n                 }\n             };\n@@ -690,7 +690,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         fmtsp: sp,\n     };\n     cx.fmtsp = efmt.span;\n-    let fmt = match expr_to_str(cx.ecx,\n+    let fmt = match expr_to_string(cx.ecx,\n                                 efmt,\n                                 \"format argument must be a string literal.\") {\n         Some((fmt, _)) => fmt,"}, {"sha": "1f4d087abd0fe1669513151ea3f88b3e1688ec5b", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -21,7 +21,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          -> Box<base::MacResult> {\n \n     cx.print_backtrace();\n-    println!(\"{}\", print::pprust::tt_to_str(&ast::TTDelim(\n+    println!(\"{}\", print::pprust::tt_to_string(&ast::TTDelim(\n                 Rc::new(tt.iter().map(|x| (*x).clone()).collect()))));\n \n     // any so that `log_syntax` can be invoked as an expression and item."}, {"sha": "a3c901904a9484d940b856e4a086b2b59141b3f9", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -128,21 +128,21 @@ pub mod rt {\n         }\n     }\n \n-    impl_to_source!(ast::Ty, ty_to_str)\n-    impl_to_source!(ast::Block, block_to_str)\n-    impl_to_source!(ast::Arg, arg_to_str)\n-    impl_to_source!(Generics, generics_to_str)\n-    impl_to_source!(Gc<ast::Item>, item_to_str)\n-    impl_to_source!(Gc<ast::Expr>, expr_to_str)\n-    impl_to_source!(Gc<ast::Pat>, pat_to_str)\n+    impl_to_source!(ast::Ty, ty_to_string)\n+    impl_to_source!(ast::Block, block_to_string)\n+    impl_to_source!(ast::Arg, arg_to_string)\n+    impl_to_source!(Generics, generics_to_string)\n+    impl_to_source!(Gc<ast::Item>, item_to_string)\n+    impl_to_source!(Gc<ast::Expr>, expr_to_string)\n+    impl_to_source!(Gc<ast::Pat>, pat_to_string)\n     impl_to_source_slice!(ast::Ty, \", \")\n     impl_to_source_slice!(Gc<ast::Item>, \"\\n\\n\")\n \n     impl<'a> ToSource for &'a str {\n         fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitStr(\n                     token::intern_and_get_ident(*self), ast::CookedStr));\n-            pprust::lit_to_str(&lit)\n+            pprust::lit_to_string(&lit)\n         }\n     }\n \n@@ -155,14 +155,14 @@ pub mod rt {\n     impl ToSource for bool {\n         fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitBool(*self));\n-            pprust::lit_to_str(&lit)\n+            pprust::lit_to_string(&lit)\n         }\n     }\n \n     impl ToSource for char {\n         fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitChar(*self));\n-            pprust::lit_to_str(&lit)\n+            pprust::lit_to_string(&lit)\n         }\n     }\n \n@@ -171,15 +171,15 @@ pub mod rt {\n             impl ToSource for $t {\n                 fn to_source(&self) -> String {\n                     let lit = dummy_spanned(ast::LitInt(*self as i64, ast::$tag));\n-                    pprust::lit_to_str(&lit)\n+                    pprust::lit_to_string(&lit)\n                 }\n             }\n         );\n         (unsigned, $t:ty, $tag:ident) => (\n             impl ToSource for $t {\n                 fn to_source(&self) -> String {\n                     let lit = dummy_spanned(ast::LitUint(*self as u64, ast::$tag));\n-                    pprust::lit_to_str(&lit)\n+                    pprust::lit_to_string(&lit)\n                 }\n             }\n         );"}, {"sha": "8922f423aad31e493fae828cdee470fbcaf0d2d9", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -64,7 +64,7 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         -> Box<base::MacResult> {\n-    let s = pprust::tts_to_str(tts);\n+    let s = pprust::tts_to_string(tts);\n     base::MacExpr::new(cx.expr_str(sp,\n                                    token::intern_and_get_ident(s.as_slice())))\n }\n@@ -126,7 +126,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Some(src) => {\n             // Add this input file to the code map to make it available as\n             // dependency information\n-            let filename = file.display().to_str();\n+            let filename = file.display().to_string();\n             let interned = token::intern_and_get_ident(src);\n             cx.codemap().new_filemap(filename, src.to_string());\n "}, {"sha": "913e0427bda221ee3e25bc3540eb0f1f9ea47515", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -395,7 +395,7 @@ pub fn parse(sess: &ParseSess,\n                     nts, next_eis.len()).to_string());\n             } else if bb_eis.len() == 0u && next_eis.len() == 0u {\n                 return Failure(sp, format!(\"no rules expected the token `{}`\",\n-                            token::to_str(&tok)).to_string());\n+                            token::to_string(&tok)).to_string());\n             } else if next_eis.len() > 0u {\n                 /* Now process the next token */\n                 while next_eis.len() > 0u {\n@@ -442,7 +442,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n       \"ident\" => match p.token {\n         token::IDENT(sn,b) => { p.bump(); token::NtIdent(box sn,b) }\n         _ => {\n-            let token_str = token::to_str(&p.token);\n+            let token_str = token::to_string(&p.token);\n             p.fatal((format!(\"expected ident, found {}\",\n                              token_str.as_slice())).as_slice())\n         }"}, {"sha": "2b481cb0596e7590e011aa0174007b5918df4ecb", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -48,7 +48,7 @@ impl<'a> ParserAnyMacro<'a> {\n             parser.bump()\n         }\n         if parser.token != EOF {\n-            let token_str = parser.this_token_to_str();\n+            let token_str = parser.this_token_to_string();\n             let msg = format!(\"macro expansion ignores token `{}` and any \\\n                                following\",\n                               token_str);\n@@ -131,7 +131,7 @@ fn generic_extension(cx: &ExtCtxt,\n         println!(\"{}! {} {} {}\",\n                  token::get_ident(name),\n                  \"{\",\n-                 print::pprust::tt_to_str(&TTDelim(Rc::new(arg.iter()\n+                 print::pprust::tt_to_string(&TTDelim(Rc::new(arg.iter()\n                                                               .map(|x| (*x).clone())\n                                                               .collect()))),\n                  \"}\");\n@@ -254,7 +254,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n \n     box MacroRulesDefiner {\n         def: RefCell::new(Some(MacroDef {\n-            name: token::get_ident(name).to_str(),\n+            name: token::get_ident(name).to_string(),\n             ext: NormalTT(exp, Some(sp))\n         }))\n     } as Box<MacResult>"}, {"sha": "5b2be78849e274abd8f08aca991ea6d564a1807e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -1026,7 +1026,7 @@ mod test {\n         assert_pred!(\n             matches_codepattern,\n             \"matches_codepattern\",\n-            pprust::to_str(|s| fake_print_crate(s, &folded_crate)),\n+            pprust::to_string(|s| fake_print_crate(s, &folded_crate)),\n             \"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string());\n     }\n \n@@ -1040,7 +1040,7 @@ mod test {\n         assert_pred!(\n             matches_codepattern,\n             \"matches_codepattern\",\n-            pprust::to_str(|s| fake_print_crate(s, &folded_crate)),\n+            pprust::to_string(|s| fake_print_crate(s, &folded_crate)),\n             \"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\".to_string());\n     }\n }"}, {"sha": "53489e32837668c2231c936b2f81f3669dd0f396", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -91,7 +91,7 @@ impl<'a> ParserAttr for Parser<'a> {\n                 (mk_sp(lo, hi), meta_item, style)\n             }\n             _ => {\n-                let token_str = self.this_token_to_str();\n+                let token_str = self.this_token_to_string();\n                 self.fatal(format!(\"expected `#` but found `{}`\",\n                                    token_str).as_slice());\n             }"}, {"sha": "73e5bb97f51d0a2b375bc25eccb03b68cacbcdfb", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -369,7 +369,7 @@ pub fn gather_comments_and_literals(span_diagnostic: &diagnostic::SpanHandler,\n                 literals.push(Literal {lit: s.to_string(), pos: sp.lo});\n             })\n         } else {\n-            debug!(\"tok: {}\", token::to_str(&tok));\n+            debug!(\"tok: {}\", token::to_string(&tok));\n         }\n         first_read = false;\n     }"}, {"sha": "52cf2ff3741c9715ba9ff4ca883e77c597c1c558", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -363,24 +363,24 @@ impl<'a> Parser<'a> {\n         }\n     }\n     // convert a token to a string using self's reader\n-    pub fn token_to_str(token: &token::Token) -> String {\n-        token::to_str(token)\n+    pub fn token_to_string(token: &token::Token) -> String {\n+        token::to_string(token)\n     }\n \n     // convert the current token to a string using self's reader\n-    pub fn this_token_to_str(&mut self) -> String {\n-        Parser::token_to_str(&self.token)\n+    pub fn this_token_to_string(&mut self) -> String {\n+        Parser::token_to_string(&self.token)\n     }\n \n     pub fn unexpected_last(&mut self, t: &token::Token) -> ! {\n-        let token_str = Parser::token_to_str(t);\n+        let token_str = Parser::token_to_string(t);\n         let last_span = self.last_span;\n         self.span_fatal(last_span, format!(\"unexpected token: `{}`\",\n                                                 token_str).as_slice());\n     }\n \n     pub fn unexpected(&mut self) -> ! {\n-        let this_token = self.this_token_to_str();\n+        let this_token = self.this_token_to_string();\n         self.fatal(format!(\"unexpected token: `{}`\", this_token).as_slice());\n     }\n \n@@ -390,8 +390,8 @@ impl<'a> Parser<'a> {\n         if self.token == *t {\n             self.bump();\n         } else {\n-            let token_str = Parser::token_to_str(t);\n-            let this_token_str = self.this_token_to_str();\n+            let token_str = Parser::token_to_string(t);\n+            let this_token_str = self.this_token_to_string();\n             self.fatal(format!(\"expected `{}` but found `{}`\",\n                                token_str,\n                                this_token_str).as_slice())\n@@ -404,15 +404,15 @@ impl<'a> Parser<'a> {\n     pub fn expect_one_of(&mut self,\n                          edible: &[token::Token],\n                          inedible: &[token::Token]) {\n-        fn tokens_to_str(tokens: &[token::Token]) -> String {\n+        fn tokens_to_string(tokens: &[token::Token]) -> String {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n             let b = i.next()\n-                     .map_or(\"\".to_string(), |t| Parser::token_to_str(t));\n+                     .map_or(\"\".to_string(), |t| Parser::token_to_string(t));\n             i.fold(b, |b,a| {\n                 let mut b = b;\n                 b.push_str(\"`, `\");\n-                b.push_str(Parser::token_to_str(a).as_slice());\n+                b.push_str(Parser::token_to_string(a).as_slice());\n                 b\n             })\n         }\n@@ -422,8 +422,8 @@ impl<'a> Parser<'a> {\n             // leave it in the input\n         } else {\n             let expected = edible.iter().map(|x| (*x).clone()).collect::<Vec<_>>().append(inedible);\n-            let expect = tokens_to_str(expected.as_slice());\n-            let actual = self.this_token_to_str();\n+            let expect = tokens_to_string(expected.as_slice());\n+            let actual = self.this_token_to_string();\n             self.fatal(\n                 (if expected.len() != 1 {\n                     (format!(\"expected one of `{}` but found `{}`\",\n@@ -512,7 +512,7 @@ impl<'a> Parser<'a> {\n                 self.bug(\"ident interpolation not converted to real token\");\n             }\n             _ => {\n-                let token_str = self.this_token_to_str();\n+                let token_str = self.this_token_to_string();\n                 self.fatal((format!(\"expected ident, found `{}`\",\n                                     token_str)).as_slice())\n             }\n@@ -556,7 +556,7 @@ impl<'a> Parser<'a> {\n     pub fn expect_keyword(&mut self, kw: keywords::Keyword) {\n         if !self.eat_keyword(kw) {\n             let id_interned_str = token::get_ident(kw.to_ident());\n-            let token_str = self.this_token_to_str();\n+            let token_str = self.this_token_to_string();\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n                                id_interned_str, token_str).as_slice())\n         }\n@@ -565,7 +565,7 @@ impl<'a> Parser<'a> {\n     // signal an error if the given string is a strict keyword\n     pub fn check_strict_keywords(&mut self) {\n         if token::is_strict_keyword(&self.token) {\n-            let token_str = self.this_token_to_str();\n+            let token_str = self.this_token_to_string();\n             let span = self.span;\n             self.span_err(span,\n                           format!(\"found `{}` in ident position\",\n@@ -576,7 +576,7 @@ impl<'a> Parser<'a> {\n     // signal an error if the current token is a reserved keyword\n     pub fn check_reserved_keywords(&mut self) {\n         if token::is_reserved_keyword(&self.token) {\n-            let token_str = self.this_token_to_str();\n+            let token_str = self.this_token_to_string();\n             self.fatal(format!(\"`{}` is a reserved keyword\",\n                                token_str).as_slice())\n         }\n@@ -593,9 +593,9 @@ impl<'a> Parser<'a> {\n                 self.replace_token(token::BINOP(token::AND), lo, span.hi)\n             }\n             _ => {\n-                let token_str = self.this_token_to_str();\n+                let token_str = self.this_token_to_string();\n                 let found_token =\n-                    Parser::token_to_str(&token::BINOP(token::AND));\n+                    Parser::token_to_string(&token::BINOP(token::AND));\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    found_token,\n                                    token_str).as_slice())\n@@ -614,9 +614,9 @@ impl<'a> Parser<'a> {\n                 self.replace_token(token::BINOP(token::OR), lo, span.hi)\n             }\n             _ => {\n-                let found_token = self.this_token_to_str();\n+                let found_token = self.this_token_to_string();\n                 let token_str =\n-                    Parser::token_to_str(&token::BINOP(token::OR));\n+                    Parser::token_to_string(&token::BINOP(token::OR));\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    token_str,\n                                    found_token).as_slice())\n@@ -667,8 +667,8 @@ impl<'a> Parser<'a> {\n \n     fn expect_lt(&mut self) {\n         if !self.eat_lt(true) {\n-            let found_token = self.this_token_to_str();\n-            let token_str = Parser::token_to_str(&token::LT);\n+            let found_token = self.this_token_to_string();\n+            let token_str = Parser::token_to_string(&token::LT);\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n                                token_str,\n                                found_token).as_slice())\n@@ -718,8 +718,8 @@ impl<'a> Parser<'a> {\n                 self.replace_token(token::EQ, lo, span.hi)\n             }\n             _ => {\n-                let gt_str = Parser::token_to_str(&token::GT);\n-                let this_token_str = self.this_token_to_str();\n+                let gt_str = Parser::token_to_string(&token::GT);\n+                let this_token_str = self.this_token_to_string();\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    gt_str,\n                                    this_token_str).as_slice())\n@@ -1247,7 +1247,7 @@ impl<'a> Parser<'a> {\n               }\n \n               _ => {\n-                  let token_str = p.this_token_to_str();\n+                  let token_str = p.this_token_to_string();\n                   p.fatal((format!(\"expected `;` or `{{` but found `{}`\",\n                                    token_str)).as_slice())\n               }\n@@ -2231,7 +2231,7 @@ impl<'a> Parser<'a> {\n                       None => {}\n                       Some(&sp) => p.span_note(sp, \"unclosed delimiter\"),\n                   };\n-                  let token_str = p.this_token_to_str();\n+                  let token_str = p.this_token_to_string();\n                   p.fatal(format!(\"incorrect close delimiter: `{}`\",\n                                   token_str).as_slice())\n               },\n@@ -2822,7 +2822,7 @@ impl<'a> Parser<'a> {\n             if self.token == token::DOTDOT {\n                 self.bump();\n                 if self.token != token::RBRACE {\n-                    let token_str = self.this_token_to_str();\n+                    let token_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected `{}`, found `{}`\", \"}\",\n                                        token_str).as_slice())\n                 }\n@@ -2843,7 +2843,7 @@ impl<'a> Parser<'a> {\n             let subpat = if self.token == token::COLON {\n                 match bind_type {\n                     BindByRef(..) | BindByValue(MutMutable) => {\n-                        let token_str = self.this_token_to_str();\n+                        let token_str = self.this_token_to_string();\n                         self.fatal(format!(\"unexpected `{}`\",\n                                            token_str).as_slice())\n                     }\n@@ -3253,7 +3253,7 @@ impl<'a> Parser<'a> {\n                     } else {\n                         \"\"\n                     };\n-                    let tok_str = self.this_token_to_str();\n+                    let tok_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected {}`(` or `{{`, but found `{}`\",\n                                        ident_str,\n                                        tok_str).as_slice())\n@@ -3714,7 +3714,7 @@ impl<'a> Parser<'a> {\n \n     fn expect_self_ident(&mut self) {\n         if !self.is_self_ident() {\n-            let token_str = self.this_token_to_str();\n+            let token_str = self.this_token_to_string();\n             self.fatal(format!(\"expected `self` but found `{}`\",\n                                token_str).as_slice())\n         }\n@@ -3847,7 +3847,7 @@ impl<'a> Parser<'a> {\n                     vec!(Arg::new_self(explicit_self_sp, mutbl_self))\n                 }\n                 _ => {\n-                    let token_str = self.this_token_to_str();\n+                    let token_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected `,` or `)`, found `{}`\",\n                                        token_str).as_slice())\n                 }\n@@ -4016,7 +4016,7 @@ impl<'a> Parser<'a> {\n \n     // Parses two variants (with the region/type params always optional):\n     //    impl<T> Foo { ... }\n-    //    impl<T> ToStr for ~[T] { ... }\n+    //    impl<T> ToString for ~[T] { ... }\n     fn parse_item_impl(&mut self) -> ItemInfo {\n         // First, parse type parameters if necessary.\n         let generics = self.parse_generics();\n@@ -4151,7 +4151,7 @@ impl<'a> Parser<'a> {\n             is_tuple_like = true;\n             fields = Vec::new();\n         } else {\n-            let token_str = self.this_token_to_str();\n+            let token_str = self.this_token_to_string();\n             self.fatal(format!(\"expected `{}`, `(`, or `;` after struct \\\n                                 name but found `{}`\", \"{\",\n                                token_str).as_slice())\n@@ -4182,7 +4182,7 @@ impl<'a> Parser<'a> {\n             token::RBRACE => {}\n             _ => {\n                 let span = self.span;\n-                let token_str = self.this_token_to_str();\n+                let token_str = self.this_token_to_string();\n                 self.span_fatal(span,\n                                 format!(\"expected `,`, or `}}` but found `{}`\",\n                                         token_str).as_slice())\n@@ -4265,7 +4265,7 @@ impl<'a> Parser<'a> {\n                                  the module\");\n               }\n               _ => {\n-                  let token_str = self.this_token_to_str();\n+                  let token_str = self.this_token_to_string();\n                   self.fatal(format!(\"expected item but found `{}`\",\n                                      token_str).as_slice())\n               }\n@@ -4545,7 +4545,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 let span = self.span;\n-                let token_str = self.this_token_to_str();\n+                let token_str = self.this_token_to_string();\n                 self.span_fatal(span,\n                                 format!(\"expected extern crate name but \\\n                                          found `{}`\",\n@@ -4803,7 +4803,7 @@ impl<'a> Parser<'a> {\n             }\n \n             let span = self.span;\n-            let token_str = self.this_token_to_str();\n+            let token_str = self.this_token_to_string();\n             self.span_fatal(span,\n                             format!(\"expected `{}` or `fn` but found `{}`\", \"{\",\n                                     token_str).as_slice());"}, {"sha": "df33f9dccc63174a5fe61055717b54fe00a74b46", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -140,7 +140,7 @@ impl fmt::Show for Nonterminal {\n     }\n }\n \n-pub fn binop_to_str(o: BinOp) -> &'static str {\n+pub fn binop_to_string(o: BinOp) -> &'static str {\n     match o {\n       PLUS => \"+\",\n       MINUS => \"-\",\n@@ -155,7 +155,7 @@ pub fn binop_to_str(o: BinOp) -> &'static str {\n     }\n }\n \n-pub fn to_str(t: &Token) -> String {\n+pub fn to_string(t: &Token) -> String {\n     match *t {\n       EQ => \"=\".to_string(),\n       LT => \"<\".to_string(),\n@@ -168,9 +168,9 @@ pub fn to_str(t: &Token) -> String {\n       TILDE => \"~\".to_string(),\n       OROR => \"||\".to_string(),\n       ANDAND => \"&&\".to_string(),\n-      BINOP(op) => binop_to_str(op).to_string(),\n+      BINOP(op) => binop_to_string(op).to_string(),\n       BINOPEQ(op) => {\n-          let mut s = binop_to_str(op).to_string();\n+          let mut s = binop_to_string(op).to_string();\n           s.push_str(\"=\");\n           s\n       }\n@@ -213,15 +213,15 @@ pub fn to_str(t: &Token) -> String {\n           res.push_char('\\'');\n           res\n       }\n-      LIT_INT(i, t) => ast_util::int_ty_to_str(t, Some(i)),\n-      LIT_UINT(u, t) => ast_util::uint_ty_to_str(t, Some(u)),\n-      LIT_INT_UNSUFFIXED(i) => { (i as u64).to_str() }\n+      LIT_INT(i, t) => ast_util::int_ty_to_string(t, Some(i)),\n+      LIT_UINT(u, t) => ast_util::uint_ty_to_string(t, Some(u)),\n+      LIT_INT_UNSUFFIXED(i) => { (i as u64).to_string() }\n       LIT_FLOAT(s, t) => {\n         let mut body = String::from_str(get_ident(s).get());\n         if body.as_slice().ends_with(\".\") {\n             body.push_char('0');  // `10.f` is not a float literal\n         }\n-        body.push_str(ast_util::float_ty_to_str(t).as_slice());\n+        body.push_str(ast_util::float_ty_to_string(t).as_slice());\n         body\n       }\n       LIT_FLOAT_UNSUFFIXED(s) => {\n@@ -260,8 +260,8 @@ pub fn to_str(t: &Token) -> String {\n       EOF => \"<eof>\".to_string(),\n       INTERPOLATED(ref nt) => {\n         match nt {\n-            &NtExpr(ref e) => ::print::pprust::expr_to_str(&**e),\n-            &NtMeta(ref e) => ::print::pprust::meta_item_to_str(&**e),\n+            &NtExpr(ref e) => ::print::pprust::expr_to_string(&**e),\n+            &NtMeta(ref e) => ::print::pprust::meta_item_to_string(&**e),\n             _ => {\n                 let mut s = \"an interpolated \".to_string();\n                 match *nt {\n@@ -691,7 +691,7 @@ pub fn gensym_ident(s: &str) -> ast::Ident {\n }\n \n // create a fresh name that maps to the same string as the old one.\n-// note that this guarantees that str_ptr_eq(ident_to_str(src),interner_get(fresh_name(src)));\n+// note that this guarantees that str_ptr_eq(ident_to_string(src),interner_get(fresh_name(src)));\n // that is, that the new name and the old one are connected to ptr_eq strings.\n pub fn fresh_name(src: &ast::Ident) -> Name {\n     let interner = get_ident_interner();\n@@ -700,7 +700,7 @@ pub fn fresh_name(src: &ast::Ident) -> Name {\n     // good error messages and uses of struct names in ambiguous could-be-binding\n     // locations. Also definitely destroys the guarantee given above about ptr_eq.\n     /*let num = rand::task_rng().gen_uint_range(0,0xffff);\n-    gensym(format!(\"{}_{}\",ident_to_str(src),num))*/\n+    gensym(format!(\"{}_{}\",ident_to_string(src),num))*/\n }\n \n // create a fresh mark."}, {"sha": "f4be7465159175e826ad61a1b12f262c925017e5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 160, "deletions": 20, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -128,6 +128,126 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n     eof(&mut s.s)\n }\n \n+pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n+    let mut s = rust_printer(box MemWriter::new());\n+    f(&mut s).unwrap();\n+    eof(&mut s.s).unwrap();\n+    unsafe {\n+        // FIXME(pcwalton): A nasty function to extract the string from an `io::Writer`\n+        // that we \"know\" to be a `MemWriter` that works around the lack of checked\n+        // downcasts.\n+        let (_, wr): (uint, Box<MemWriter>) = mem::transmute_copy(&s.s.out);\n+        let result =\n+            str::from_utf8_owned(Vec::from_slice(wr.get_ref())).unwrap();\n+        mem::forget(wr);\n+        result.to_string()\n+    }\n+}\n+\n+pub fn ty_to_string(ty: &ast::Ty) -> String {\n+    to_string(|s| s.print_type(ty))\n+}\n+\n+pub fn pat_to_string(pat: &ast::Pat) -> String {\n+    to_string(|s| s.print_pat(pat))\n+}\n+\n+pub fn expr_to_string(e: &ast::Expr) -> String {\n+    to_string(|s| s.print_expr(e))\n+}\n+\n+pub fn lifetime_to_string(e: &ast::Lifetime) -> String {\n+    to_string(|s| s.print_lifetime(e))\n+}\n+\n+pub fn tt_to_string(tt: &ast::TokenTree) -> String {\n+    to_string(|s| s.print_tt(tt))\n+}\n+\n+pub fn tts_to_string(tts: &[ast::TokenTree]) -> String {\n+    to_string(|s| s.print_tts(tts))\n+}\n+\n+pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n+    to_string(|s| s.print_stmt(stmt))\n+}\n+\n+pub fn item_to_string(i: &ast::Item) -> String {\n+    to_string(|s| s.print_item(i))\n+}\n+\n+pub fn generics_to_string(generics: &ast::Generics) -> String {\n+    to_string(|s| s.print_generics(generics))\n+}\n+\n+pub fn ty_method_to_string(p: &ast::TypeMethod) -> String {\n+    to_string(|s| s.print_ty_method(p))\n+}\n+\n+pub fn method_to_string(p: &ast::Method) -> String {\n+    to_string(|s| s.print_method(p))\n+}\n+\n+pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n+    to_string(|s| s.print_fn_block_args(p))\n+}\n+\n+pub fn path_to_string(p: &ast::Path) -> String {\n+    to_string(|s| s.print_path(p, false))\n+}\n+\n+pub fn ident_to_string(id: &ast::Ident) -> String {\n+    to_string(|s| s.print_ident(*id))\n+}\n+\n+pub fn fun_to_string(decl: &ast::FnDecl, fn_style: ast::FnStyle, name: ast::Ident,\n+                  opt_explicit_self: Option<ast::ExplicitSelf_>,\n+                  generics: &ast::Generics) -> String {\n+    to_string(|s| {\n+        try!(s.print_fn(decl, Some(fn_style), abi::Rust,\n+                        name, generics, opt_explicit_self, ast::Inherited));\n+        try!(s.end()); // Close the head box\n+        s.end() // Close the outer box\n+    })\n+}\n+\n+pub fn block_to_string(blk: &ast::Block) -> String {\n+    to_string(|s| {\n+        // containing cbox, will be closed by print-block at }\n+        try!(s.cbox(indent_unit));\n+        // head-ibox, will be closed by print-block after {\n+        try!(s.ibox(0u));\n+        s.print_block(blk)\n+    })\n+}\n+\n+pub fn meta_item_to_string(mi: &ast::MetaItem) -> String {\n+    to_string(|s| s.print_meta_item(mi))\n+}\n+\n+pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n+    to_string(|s| s.print_attribute(attr))\n+}\n+\n+pub fn lit_to_string(l: &ast::Lit) -> String {\n+    to_string(|s| s.print_literal(l))\n+}\n+\n+pub fn explicit_self_to_string(explicit_self: ast::ExplicitSelf_) -> String {\n+    to_string(|s| s.print_explicit_self(explicit_self, ast::MutImmutable).map(|_| {}))\n+}\n+\n+pub fn variant_to_string(var: &ast::Variant) -> String {\n+    to_string(|s| s.print_variant(var))\n+}\n+\n+pub fn arg_to_string(arg: &ast::Arg) -> String {\n+    to_string(|s| s.print_arg(arg))\n+}\n+\n+\n+\n+#[cfg(stage0)]\n pub fn to_str(f: |&mut State| -> IoResult<()>) -> String {\n     let mut s = rust_printer(box MemWriter::new());\n     f(&mut s).unwrap();\n@@ -144,62 +264,72 @@ pub fn to_str(f: |&mut State| -> IoResult<()>) -> String {\n     }\n }\n \n+#[cfg(stage0)]\n pub fn ty_to_str(ty: &ast::Ty) -> String {\n     to_str(|s| s.print_type(ty))\n }\n \n+#[cfg(stage0)]\n pub fn pat_to_str(pat: &ast::Pat) -> String {\n     to_str(|s| s.print_pat(pat))\n }\n \n+#[cfg(stage0)]\n pub fn expr_to_str(e: &ast::Expr) -> String {\n     to_str(|s| s.print_expr(e))\n }\n \n+#[cfg(stage0)]\n pub fn lifetime_to_str(e: &ast::Lifetime) -> String {\n     to_str(|s| s.print_lifetime(e))\n }\n \n+#[cfg(stage0)]\n pub fn tt_to_str(tt: &ast::TokenTree) -> String {\n     to_str(|s| s.print_tt(tt))\n }\n \n+#[cfg(stage0)]\n pub fn tts_to_str(tts: &[ast::TokenTree]) -> String {\n     to_str(|s| s.print_tts(tts))\n }\n \n+#[cfg(stage0)]\n pub fn stmt_to_str(stmt: &ast::Stmt) -> String {\n     to_str(|s| s.print_stmt(stmt))\n }\n \n+#[cfg(stage0)]\n pub fn item_to_str(i: &ast::Item) -> String {\n     to_str(|s| s.print_item(i))\n }\n \n+#[cfg(stage0)]\n pub fn generics_to_str(generics: &ast::Generics) -> String {\n     to_str(|s| s.print_generics(generics))\n }\n \n+#[cfg(stage0)]\n pub fn ty_method_to_str(p: &ast::TypeMethod) -> String {\n     to_str(|s| s.print_ty_method(p))\n }\n \n+#[cfg(stage0)]\n pub fn method_to_str(p: &ast::Method) -> String {\n     to_str(|s| s.print_method(p))\n }\n \n+#[cfg(stage0)]\n pub fn fn_block_to_str(p: &ast::FnDecl) -> String {\n     to_str(|s| s.print_fn_block_args(p))\n }\n \n+#[cfg(stage0)]\n pub fn path_to_str(p: &ast::Path) -> String {\n     to_str(|s| s.print_path(p, false))\n }\n \n-pub fn ident_to_str(id: &ast::Ident) -> String {\n-    to_str(|s| s.print_ident(*id))\n-}\n-\n+#[cfg(stage0)]\n pub fn fun_to_str(decl: &ast::FnDecl, fn_style: ast::FnStyle, name: ast::Ident,\n                   opt_explicit_self: Option<ast::ExplicitSelf_>,\n                   generics: &ast::Generics) -> String {\n@@ -211,6 +341,7 @@ pub fn fun_to_str(decl: &ast::FnDecl, fn_style: ast::FnStyle, name: ast::Ident,\n     })\n }\n \n+#[cfg(stage0)]\n pub fn block_to_str(blk: &ast::Block) -> String {\n     to_str(|s| {\n         // containing cbox, will be closed by print-block at }\n@@ -221,30 +352,39 @@ pub fn block_to_str(blk: &ast::Block) -> String {\n     })\n }\n \n+#[cfg(stage0)]\n pub fn meta_item_to_str(mi: &ast::MetaItem) -> String {\n     to_str(|s| s.print_meta_item(mi))\n }\n \n+#[cfg(stage0)]\n pub fn attribute_to_str(attr: &ast::Attribute) -> String {\n     to_str(|s| s.print_attribute(attr))\n }\n \n+#[cfg(stage0)]\n pub fn lit_to_str(l: &ast::Lit) -> String {\n     to_str(|s| s.print_literal(l))\n }\n \n+#[cfg(stage0)]\n pub fn explicit_self_to_str(explicit_self: ast::ExplicitSelf_) -> String {\n     to_str(|s| s.print_explicit_self(explicit_self, ast::MutImmutable).map(|_| {}))\n }\n \n+#[cfg(stage0)]\n pub fn variant_to_str(var: &ast::Variant) -> String {\n     to_str(|s| s.print_variant(var))\n }\n \n+#[cfg(stage0)]\n pub fn arg_to_str(arg: &ast::Arg) -> String {\n     to_str(|s| s.print_arg(arg))\n }\n \n+\n+\n+\n pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> String {\n     match vis {\n         ast::Public => format!(\"pub {}\", s),\n@@ -674,7 +814,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemForeignMod(ref nmod) => {\n                 try!(self.head(\"extern\"));\n-                try!(self.word_nbsp(nmod.abi.to_str().as_slice()));\n+                try!(self.word_nbsp(nmod.abi.to_string().as_slice()));\n                 try!(self.bopen());\n                 try!(self.print_foreign_mod(nmod, item.attrs.as_slice()));\n                 try!(self.bclose(item.span));\n@@ -893,7 +1033,7 @@ impl<'a> State<'a> {\n         match *tt {\n             ast::TTDelim(ref tts) => self.print_tts(tts.as_slice()),\n             ast::TTTok(_, ref tk) => {\n-                try!(word(&mut self.s, parse::token::to_str(tk).as_slice()));\n+                try!(word(&mut self.s, parse::token::to_string(tk).as_slice()));\n                 match *tk {\n                     parse::token::DOC_COMMENT(..) => {\n                         hardbreak(&mut self.s)\n@@ -910,7 +1050,7 @@ impl<'a> State<'a> {\n                 match *sep {\n                     Some(ref tk) => {\n                         try!(word(&mut self.s,\n-                                  parse::token::to_str(tk).as_slice()));\n+                                  parse::token::to_string(tk).as_slice()));\n                     }\n                     None => ()\n                 }\n@@ -1308,11 +1448,11 @@ impl<'a> State<'a> {\n             ast::ExprBinary(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n-                try!(self.word_space(ast_util::binop_to_str(op)));\n+                try!(self.word_space(ast_util::binop_to_string(op)));\n                 try!(self.print_expr(&**rhs));\n             }\n             ast::ExprUnary(op, ref expr) => {\n-                try!(word(&mut self.s, ast_util::unop_to_str(op)));\n+                try!(word(&mut self.s, ast_util::unop_to_string(op)));\n                 try!(self.print_expr_maybe_paren(&**expr));\n             }\n             ast::ExprAddrOf(m, ref expr) => {\n@@ -1488,7 +1628,7 @@ impl<'a> State<'a> {\n             ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n-                try!(word(&mut self.s, ast_util::binop_to_str(op)));\n+                try!(word(&mut self.s, ast_util::binop_to_string(op)));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**rhs));\n             }\n@@ -2328,11 +2468,11 @@ impl<'a> State<'a> {\n             }\n             ast::LitInt(i, t) => {\n                 word(&mut self.s,\n-                     ast_util::int_ty_to_str(t, Some(i)).as_slice())\n+                     ast_util::int_ty_to_string(t, Some(i)).as_slice())\n             }\n             ast::LitUint(u, t) => {\n                 word(&mut self.s,\n-                     ast_util::uint_ty_to_str(t, Some(u)).as_slice())\n+                     ast_util::uint_ty_to_string(t, Some(u)).as_slice())\n             }\n             ast::LitIntUnsuffixed(i) => {\n                 word(&mut self.s, format!(\"{}\", i).as_slice())\n@@ -2342,7 +2482,7 @@ impl<'a> State<'a> {\n                      format!(\n                          \"{}{}\",\n                          f.get(),\n-                         ast_util::float_ty_to_str(t).as_slice()).as_slice())\n+                         ast_util::float_ty_to_string(t).as_slice()).as_slice())\n             }\n             ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, f.get()),\n             ast::LitNil => word(&mut self.s, \"()\"),\n@@ -2480,7 +2620,7 @@ impl<'a> State<'a> {\n             Some(abi::Rust) => Ok(()),\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abi.to_str().as_slice())\n+                self.word_nbsp(abi.to_string().as_slice())\n             }\n             None => Ok(())\n         }\n@@ -2491,7 +2631,7 @@ impl<'a> State<'a> {\n         match opt_abi {\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abi.to_str().as_slice())\n+                self.word_nbsp(abi.to_string().as_slice())\n             }\n             None => Ok(())\n         }\n@@ -2507,7 +2647,7 @@ impl<'a> State<'a> {\n \n         if abi != abi::Rust {\n             try!(self.word_nbsp(\"extern\"));\n-            try!(self.word_nbsp(abi.to_str().as_slice()));\n+            try!(self.word_nbsp(abi.to_string().as_slice()));\n         }\n \n         word(&mut self.s, \"fn\")\n@@ -2538,7 +2678,7 @@ mod test {\n     use parse::token;\n \n     #[test]\n-    fn test_fun_to_str() {\n+    fn test_fun_to_string() {\n         let abba_ident = token::str_to_ident(\"abba\");\n \n         let decl = ast::FnDecl {\n@@ -2550,13 +2690,13 @@ mod test {\n             variadic: false\n         };\n         let generics = ast_util::empty_generics();\n-        assert_eq!(&fun_to_str(&decl, ast::NormalFn, abba_ident,\n+        assert_eq!(&fun_to_string(&decl, ast::NormalFn, abba_ident,\n                                None, &generics),\n                    &\"fn abba()\".to_string());\n     }\n \n     #[test]\n-    fn test_variant_to_str() {\n+    fn test_variant_to_string() {\n         let ident = token::str_to_ident(\"principal_skinner\");\n \n         let var = codemap::respan(codemap::DUMMY_SP, ast::Variant_ {\n@@ -2569,7 +2709,7 @@ mod test {\n             vis: ast::Public,\n         });\n \n-        let varstr = variant_to_str(&var);\n+        let varstr = variant_to_string(&var);\n         assert_eq!(&varstr,&\"pub principal_skinner\".to_string());\n     }\n }"}, {"sha": "b80f47e6c934ee49914a8641244d26c404a56912", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -370,7 +370,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let matches =\n         match getopts::getopts(args_.as_slice(), optgroups().as_slice()) {\n           Ok(m) => m,\n-          Err(f) => return Some(Err(f.to_str()))\n+          Err(f) => return Some(Err(f.to_string()))\n         };\n \n     if matches.opt_present(\"h\") { usage(args[0].as_slice()); return None; }\n@@ -634,7 +634,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         let mut failures = Vec::new();\n         let mut fail_out = String::new();\n         for &(ref f, ref stdout) in self.failures.iter() {\n-            failures.push(f.name.to_str());\n+            failures.push(f.name.to_string());\n             if stdout.len() > 0 {\n                 fail_out.push_str(format!(\"---- {} stdout ----\\n\\t\",\n                                           f.name.as_slice()).as_slice());\n@@ -1522,7 +1522,7 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n-        assert_eq!(filtered.get(0).desc.name.to_str(),\n+        assert_eq!(filtered.get(0).desc.name.to_string(),\n                    \"1\".to_string());\n         assert!(filtered.get(0).desc.ignore == false);\n     }\n@@ -1573,7 +1573,7 @@ mod tests {\n                  \"test::sort_tests\".to_string());\n \n         for (a, b) in expected.iter().zip(filtered.iter()) {\n-            assert!(*a == b.desc.name.to_str());\n+            assert!(*a == b.desc.name.to_string());\n         }\n     }\n "}, {"sha": "325582ff99c98a6370effc3bf2ede983b6579e10", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -385,8 +385,8 @@ pub fn write_boxplot<T: Float + Show + FromPrimitive>(\n \n     let range = hi - lo;\n \n-    let lostr = lo.to_str();\n-    let histr = hi.to_str();\n+    let lostr = lo.to_string();\n+    let histr = hi.to_string();\n \n     let overhead_width = lostr.len() + histr.len() + 4;\n     let range_width = width_hint - overhead_width;"}, {"sha": "9ed46d7a49b7e12ab4f9caeac3cdb1ab31e61ae9", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -1039,7 +1039,7 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n           'U' => format!(\"{:02d}\", (tm.tm_yday - tm.tm_wday + 7) / 7),\n           'u' => {\n             let i = tm.tm_wday as int;\n-            (if i == 0 { 7 } else { i }).to_str()\n+            (if i == 0 { 7 } else { i }).to_string()\n           }\n           'V' => iso_week('V', tm),\n           'v' => {\n@@ -1052,8 +1052,8 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n               format!(\"{:02d}\",\n                              (tm.tm_yday - (tm.tm_wday - 1 + 7) % 7 + 7) / 7)\n           }\n-          'w' => (tm.tm_wday as int).to_str(),\n-          'Y' => (tm.tm_year as int + 1900).to_str(),\n+          'w' => (tm.tm_wday as int).to_string(),\n+          'Y' => (tm.tm_year as int + 1900).to_string(),\n           'y' => format!(\"{:02d}\", (tm.tm_year as int + 1900) % 100),\n           'Z' => \"\".to_string(),    // FIXME(pcwalton): Implement this.\n           'z' => {"}, {"sha": "129e3d0bf0ae821137e0582d3930eafc78563d63", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -765,13 +765,13 @@ impl fmt::Show for Path {\n \n impl<S: hash::Writer> hash::Hash<S> for Url {\n     fn hash(&self, state: &mut S) {\n-        self.to_str().hash(state)\n+        self.to_string().hash(state)\n     }\n }\n \n impl<S: hash::Writer> hash::Hash<S> for Path {\n     fn hash(&self, state: &mut S) {\n-        self.to_str().hash(state)\n+        self.to_string().hash(state)\n     }\n }\n "}, {"sha": "7d93f1f52cf05b82e2b141e605560bb76534624a", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -33,7 +33,7 @@ use uuid::Uuid;\n \n fn main() {\n     let uuid1 = Uuid::new_v4();\n-    println!(\"{}\", uuid1.to_str());\n+    println!(\"{}\", uuid1.to_string());\n }\n ```\n \n@@ -622,7 +622,7 @@ mod test {\n \n         // Round-trip\n         let uuid_orig = Uuid::new_v4();\n-        let orig_str = uuid_orig.to_str();\n+        let orig_str = uuid_orig.to_string();\n         let uuid_out = Uuid::parse_string(orig_str.as_slice()).unwrap();\n         assert!(uuid_orig == uuid_out);\n \n@@ -650,9 +650,9 @@ mod test {\n     }\n \n     #[test]\n-    fn test_to_str() {\n+    fn test_to_string() {\n         let uuid1 = Uuid::new_v4();\n-        let s = uuid1.to_str();\n+        let s = uuid1.to_string();\n \n         assert!(s.len() == 32);\n         assert!(s.as_slice().chars().all(|c| c.is_digit_radix(16)));\n@@ -685,7 +685,7 @@ mod test {\n         let uuid1 = Uuid::new_v4();\n \n         let hs = uuid1.to_hyphenated_str();\n-        let ss = uuid1.to_str();\n+        let ss = uuid1.to_string();\n \n         let hsn = str::from_chars(hs.as_slice()\n                                     .chars()\n@@ -704,7 +704,7 @@ mod test {\n         let uuid_hs = Uuid::parse_string(hs.as_slice()).unwrap();\n         assert!(uuid_hs == uuid);\n \n-        let ss = uuid.to_str();\n+        let ss = uuid.to_string();\n         let uuid_ss = Uuid::parse_string(ss.as_slice()).unwrap();\n         assert!(uuid_ss == uuid);\n     }\n@@ -833,10 +833,10 @@ mod bench {\n     }\n \n     #[bench]\n-    pub fn uuid_to_str(b: &mut Bencher) {\n+    pub fn uuid_to_string(b: &mut Bencher) {\n         let u = Uuid::new_v4();\n         b.iter(|| {\n-            u.to_str();\n+            u.to_string();\n         })\n     }\n "}, {"sha": "1d2d02d7d592689de2661c6d4b79b0e877d887a4", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -90,11 +90,11 @@ impl Results {\n             let mut set = f();\n             timed(&mut self.sequential_strings, || {\n                 for i in range(0u, num_keys) {\n-                    set.insert(i.to_str());\n+                    set.insert(i.to_string());\n                 }\n \n                 for i in range(0u, num_keys) {\n-                    assert!(set.contains(&i.to_str()));\n+                    assert!(set.contains(&i.to_string()));\n                 }\n             })\n         }\n@@ -103,7 +103,7 @@ impl Results {\n             let mut set = f();\n             timed(&mut self.random_strings, || {\n                 for _ in range(0, num_keys) {\n-                    let s = rng.gen::<uint>().to_str();\n+                    let s = rng.gen::<uint>().to_string();\n                     set.insert(s);\n                 }\n             })\n@@ -112,11 +112,11 @@ impl Results {\n         {\n             let mut set = f();\n             for i in range(0u, num_keys) {\n-                set.insert(i.to_str());\n+                set.insert(i.to_string());\n             }\n             timed(&mut self.delete_strings, || {\n                 for i in range(0u, num_keys) {\n-                    assert!(set.remove(&i.to_str()));\n+                    assert!(set.remove(&i.to_string()));\n                 }\n             })\n         }"}, {"sha": "f38517515660970d7b33dbc525567c6449cefae0", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     let n = from_str::<uint>(args.get(1).as_slice()).unwrap();\n \n     for i in range(0u, n) {\n-        let x = i.to_str();\n+        let x = i.to_string();\n         println!(\"{}\", x);\n     }\n }"}, {"sha": "0c76d14852e08695cf9ebc83272b1c2979741080", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -48,7 +48,7 @@ fn show_color_list(set: Vec<Color>) -> String {\n     let mut out = String::new();\n     for col in set.iter() {\n         out.push_char(' ');\n-        out.push_str(col.to_str().as_slice());\n+        out.push_str(col.to_string().as_slice());\n     }\n     out\n }"}, {"sha": "b3deb88543ed46bdec52e56732c69bc2d20886fe", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -64,15 +64,15 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> String {\n                                k.as_slice()\n                                .to_ascii()\n                                .to_upper()\n-                               .into_str(), v).as_slice());\n+                               .into_string(), v).as_slice());\n    }\n \n    return buffer\n }\n \n // given a map, search for the frequency of a pattern\n fn find(mm: &HashMap<Vec<u8> , uint>, key: String) -> uint {\n-   let key = key.to_owned().into_ascii().as_slice().to_lower().into_str();\n+   let key = key.to_owned().into_ascii().as_slice().to_lower().into_string();\n    match mm.find_equiv(&key.as_bytes()) {\n       option::None      => { return 0u; }\n       option::Some(&num) => { return num; }"}, {"sha": "0e0b0b518d587efc815ddadf375e76588cc3a349", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -115,7 +115,7 @@ fn main() {\n \n                 let elapsed = stop - start;\n \n-                println!(\"{}\\t{}\\t{}\", n, fibn, elapsed.to_str());\n+                println!(\"{}\\t{}\\t{}\", n, fibn, elapsed.to_string());\n             }\n         }\n     }"}, {"sha": "bdf6862d0b133ffa1150b60874e13ba0f14e0952", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -67,7 +67,7 @@ fn main() {\n     } else {\n         box io::stdin() as Box<io::Reader>\n     };\n-    let mut seq = rdr.read_to_str().unwrap();\n+    let mut seq = rdr.read_to_string().unwrap();\n     let ilen = seq.len();\n \n     seq = regex!(\">[^\\n]*\\n|\\n\").replace_all(seq.as_slice(), NoExpand(\"\"));\n@@ -109,7 +109,7 @@ fn main() {\n     let (mut variant_strs, mut counts) = (vec!(), vec!());\n     for variant in variants.move_iter() {\n         let seq_arc_copy = seq_arc.clone();\n-        variant_strs.push(variant.to_str().to_owned());\n+        variant_strs.push(variant.to_string().to_owned());\n         counts.push(Future::spawn(proc() {\n             count_matches(seq_arc_copy.as_slice(), &variant)\n         }));"}, {"sha": "00607f850347cc54c5b1c201d5c098e375470506", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -16,18 +16,18 @@\n struct t(Box<t>); //~ ERROR this type cannot be instantiated\n \n trait to_str_2 {\n-    fn my_to_str() -> String;\n+    fn my_to_string() -> String;\n }\n \n // I use an impl here because it will cause\n // the compiler to attempt autoderef and then\n // try to resolve the method.\n impl to_str_2 for t {\n-    fn my_to_str() -> String { \"t\".to_string() }\n+    fn my_to_string() -> String { \"t\".to_string() }\n }\n \n fn new_t(x: t) {\n-    x.my_to_str(); //~ ERROR does not implement\n+    x.my_to_string(); //~ ERROR does not implement\n }\n \n fn main() {"}, {"sha": "57bc11379125f440caa1fda9f6d262ffffe15a50", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -13,17 +13,17 @@ struct Point {\n     y: f64,\n }\n \n-trait NewTrait {\n-    fn a(&self) -> String;\n+trait ToString_ {\n+    fn to_string(&self) -> String;\n }\n \n-impl NewTrait for Point {\n+impl ToString_ for Point {\n     fn new(x: f64, y: f64) -> Point {\n-    //~^ ERROR method `new` is not a member of trait `NewTrait`\n+    //~^ ERROR method `new` is not a member of trait `ToString_`\n         Point { x: x, y: y }\n     }\n \n-    fn a(&self) -> String {\n+    fn to_string(&self) -> String {\n         format!(\"({}, {})\", self.x, self.y)\n     }\n }\n@@ -32,5 +32,5 @@ fn main() {\n     let p = Point::new(0.0, 0.0);\n     //~^ ERROR unresolved name `Point::new`\n     //~^^ ERROR failed to resolve. Use of undeclared module `Point`\n-    println!(\"{}\", p.a());\n+    println!(\"{}\", p.to_string());\n }"}, {"sha": "279cf6d94cbf13626c615f6e6a5237d33e62bc82", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n #![allow(dead_code)]\n #![deny(uppercase_variables)]\n \n@@ -30,7 +32,7 @@ fn main() {\n     let mut buff = [0u8, ..16];\n     match f.read(buff) {\n         Ok(cnt) => println!(\"read this many bytes: {}\", cnt),\n-        Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {}\", EndOfFile.to_str()),\n+        Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {}\", EndOfFile.to_string()),\n                         //~^ ERROR variable names should start with a lowercase character\n     }\n "}, {"sha": "1a2fb33eaabfed231cfcd2a4187c3b1f6d825fc3", "filename": "src/test/compile-fail/moves-based-on-type-block-bad.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n \n struct S {\n     x: Box<E>\n@@ -29,7 +30,7 @@ fn main() {\n         f(&s, |hellothere| {\n             match hellothere.x { //~ ERROR cannot move out\n                 box Foo(_) => {}\n-                box Bar(x) => println!(\"{}\", x.to_str()), //~ NOTE attempting to move value to here\n+                box Bar(x) => println!(\"{}\", x.to_string()), //~ NOTE attempting to move value to here\n                 box Baz => {}\n             }\n         })"}, {"sha": "c7b0bc8822be1dfda61e88f2fb02eed62226f10e", "filename": "src/test/compile-fail/multitrait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -12,7 +12,7 @@ struct S {\n  y: int\n }\n \n-impl Cmp, ToStr for S { //~ ERROR: expected `{` but found `,`\n+impl Cmp, ToString for S { //~ ERROR: expected `{` but found `,`\n   fn eq(&&other: S) { false }\n-  fn to_str(&self) -> String { \"hi\".to_string() }\n+  fn to_string(&self) -> String { \"hi\".to_string() }\n }"}, {"sha": "2fb097f111db47f98727566112fc8e35047c49f0", "filename": "src/test/compile-fail/no-implicit-prelude-nested.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -21,7 +21,7 @@ mod foo {\n         impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n         impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n         impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl ToStr for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+        impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n         impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n \n         fn foo() {\n@@ -33,7 +33,7 @@ mod foo {\n     impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n     impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n     impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-    impl ToStr for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+    impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n     impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n \n     fn foo() {\n@@ -48,7 +48,7 @@ fn qux() {\n         impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n         impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n         impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl ToStr for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+        impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n         impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n \n         fn foo() {"}, {"sha": "c0f7bea25b57ad88fddc5f218e6c75bd06fa1cdb", "filename": "src/test/compile-fail/no-implicit-prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -20,7 +20,7 @@ struct Test;\n impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-impl ToStr for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n \n fn main() {"}, {"sha": "9f91337db9f21a6b106e7b93925ede0f0790b4eb", "filename": "src/test/compile-fail/uninhabited-enum-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Funinhabited-enum-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Funinhabited-enum-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-enum-cast.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -11,7 +11,7 @@\n enum E {}\n \n fn f(e: E) {\n-    println!(\"{}\", (e as int).to_str());   //~ ERROR non-scalar cast\n+    println!(\"{}\", (e as int).to_string());   //~ ERROR non-scalar cast\n }\n \n fn main() {}"}, {"sha": "043f3a233a6253705718e010b41c340379f7af01", "filename": "src/test/compile-fail/use-after-move-implicity-coerced-object.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -23,10 +23,10 @@ impl fmt::Show for Number {\n }\n \n struct List {\n-    list: Vec<Box<ToStr>> }\n+    list: Vec<Box<ToString>> }\n \n impl List {\n-    fn push(&mut self, n: Box<ToStr>) {\n+    fn push(&mut self, n: Box<ToString>) {\n         self.list.push(n);\n     }\n }\n@@ -35,6 +35,6 @@ fn main() {\n     let n = box Number { n: 42 };\n     let mut l = box List { list: Vec::new() };\n     l.push(n);\n-    let x = n.to_str();\n+    let x = n.to_string();\n     //~^ ERROR: use of moved value: `n`\n }"}, {"sha": "8f718add2a312afee49d955138cdd9ad2356d524", "filename": "src/test/debuginfo/cross-crate-type-uniquing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fdebuginfo%2Fcross-crate-type-uniquing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Fdebuginfo%2Fcross-crate-type-uniquing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fcross-crate-type-uniquing.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -21,4 +21,4 @@ pub fn p() -> C {\n     C\n }\n \n-fn main() { }\n\\ No newline at end of file\n+fn main() { }"}, {"sha": "91075633ab8d844c5ac9ea84725018ac779d362b", "filename": "src/test/run-pass/bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbool.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -49,9 +49,9 @@ fn main() {\n     assert_eq!(!true, false);\n     assert_eq!(!false, true);\n \n-    let s = false.to_str();\n+    let s = false.to_string();\n     assert_eq!(s.as_slice(), \"false\");\n-    let s = true.to_str();\n+    let s = true.to_string();\n     assert_eq!(s.as_slice(), \"true\");\n \n     assert!(true > false);"}, {"sha": "33ee2ffd3592ce2f6c708892221f2d79d3724c84", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -45,7 +45,7 @@ fn main() {\n         debug!(\"debug\");\n         info!(\"info\");\n     });\n-    let s = r.read_to_str().unwrap();\n+    let s = r.read_to_string().unwrap();\n     assert!(s.as_slice().contains(\"info\"));\n     assert!(!s.as_slice().contains(\"debug\"));\n }"}, {"sha": "e3dbaa62d353264ed5eb1b40e6bf0e49581a1f1f", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -11,16 +11,16 @@\n // aux-build:cci_class_cast.rs\n extern crate cci_class_cast;\n \n-use std::to_str::ToStr;\n+use std::to_str::ToString;\n use cci_class_cast::kitty::cat;\n \n-fn print_out(thing: Box<ToStr>, expected: String) {\n-  let actual = thing.to_str();\n+fn print_out(thing: Box<ToString>, expected: String) {\n+  let actual = thing.to_string();\n   println!(\"{}\", actual);\n   assert_eq!(actual.to_string(), expected);\n }\n \n pub fn main() {\n-  let nyan: Box<ToStr> = box cat(0u, 2, \"nyan\".to_string()) as Box<ToStr>;\n+  let nyan: Box<ToString> = box cat(0u, 2, \"nyan\".to_string()) as Box<ToString>;\n   print_out(nyan, \"nyan\".to_string());\n }"}, {"sha": "7143888298072da85d34254ace13f980bf6ceddd", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -57,13 +57,13 @@ impl fmt::Show for cat {\n     }\n }\n \n-fn print_out(thing: Box<ToStr>, expected: String) {\n-  let actual = thing.to_str();\n+fn print_out(thing: Box<ToString>, expected: String) {\n+  let actual = thing.to_string();\n   println!(\"{}\", actual);\n   assert_eq!(actual.to_string(), expected);\n }\n \n pub fn main() {\n-  let nyan: Box<ToStr> = box cat(0u, 2, \"nyan\".to_string()) as Box<ToStr>;\n+  let nyan: Box<ToString> = box cat(0u, 2, \"nyan\".to_string()) as Box<ToString>;\n   print_out(nyan, \"nyan\".to_string());\n }"}, {"sha": "fa82e42d793f03ddc52bcaf00588cdff44ef7418", "filename": "src/test/run-pass/deriving-show-2.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -41,15 +41,15 @@ impl fmt::Show for Custom {\n }\n \n pub fn main() {\n-    assert_eq!(B1.to_str(), \"B1\".to_string());\n-    assert_eq!(B2.to_str(), \"B2\".to_string());\n-    assert_eq!(C1(3).to_str(), \"C1(3)\".to_string());\n-    assert_eq!(C2(B2).to_str(), \"C2(B2)\".to_string());\n-    assert_eq!(D1{ a: 2 }.to_str(), \"D1 { a: 2 }\".to_string());\n-    assert_eq!(E.to_str(), \"E\".to_string());\n-    assert_eq!(F(3).to_str(), \"F(3)\".to_string());\n-    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_string());\n-    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_string());\n-    assert_eq!(I{ a: 2, b: 4 }.to_str(), \"I { a: 2, b: 4 }\".to_string());\n-    assert_eq!(J(Custom).to_str(), \"J(yay)\".to_string());\n+    assert_eq!(B1.to_string(), \"B1\".to_string());\n+    assert_eq!(B2.to_string(), \"B2\".to_string());\n+    assert_eq!(C1(3).to_string(), \"C1(3)\".to_string());\n+    assert_eq!(C2(B2).to_string(), \"C2(B2)\".to_string());\n+    assert_eq!(D1{ a: 2 }.to_string(), \"D1 { a: 2 }\".to_string());\n+    assert_eq!(E.to_string(), \"E\".to_string());\n+    assert_eq!(F(3).to_string(), \"F(3)\".to_string());\n+    assert_eq!(G(3, 4).to_string(), \"G(3, 4)\".to_string());\n+    assert_eq!(G(3, 4).to_string(), \"G(3, 4)\".to_string());\n+    assert_eq!(I{ a: 2, b: 4 }.to_string(), \"I { a: 2, b: 4 }\".to_string());\n+    assert_eq!(J(Custom).to_string(), \"J(yay)\".to_string());\n }"}, {"sha": "7e71be4114836c30a441552d24dd19f13e717c35", "filename": "src/test/run-pass/exponential-notation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -11,24 +11,24 @@\n #![feature(macro_rules)]\n \n use s = std::num::strconv;\n-use to_str = std::num::strconv::float_to_str_common;\n+use to_string = std::num::strconv::float_to_str_common;\n \n macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_string()) } })\n \n pub fn main() {\n     // Basic usage\n-    t!(to_str(1.2345678e-5f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpDec, false),\n+    t!(to_string(1.2345678e-5f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpDec, false),\n              \"1.234568e-5\")\n \n     // Hexadecimal output\n-    t!(to_str(7.281738281250e+01f64, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n+    t!(to_string(7.281738281250e+01f64, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n               \"+1.2345p+6\")\n-    t!(to_str(-1.777768135071e-02f64, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n+    t!(to_string(-1.777768135071e-02f64, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n              \"-1.2345p-6\")\n \n     // Some denormals\n-    t!(to_str(4.9406564584124654e-324f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n+    t!(to_string(4.9406564584124654e-324f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n              \"1p-1074\")\n-    t!(to_str(2.2250738585072009e-308f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n+    t!(to_string(2.2250738585072009e-308f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n              \"1p-1022\")\n }"}, {"sha": "3b7c5083bb48ef1a42e820d111b6db91882f2288", "filename": "src/test/run-pass/fixed_length_vec_glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -17,6 +17,6 @@ struct Struc { a: u8, b: [int, ..3], c: int }\n pub fn main() {\n     let arr = [1,2,3];\n     let struc = Struc {a: 13u8, b: arr, c: 42};\n-    let s = repr::repr_to_str(&struc);\n+    let s = repr::repr_to_string(&struc);\n     assert_eq!(s, \"Struc{a: 13u8, b: [1, 2, 3], c: 42}\".to_string());\n }"}, {"sha": "4a89d277e9f5634568952f9ca7b0ee1d538d6418", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -79,8 +79,8 @@ fn read_board_grid<rdr:'static + io::Reader>(mut input: rdr)\n \n mod test {\n     #[test]\n-    pub fn trivial_to_str() {\n-        assert!(lambda.to_str() == \"\\\\\")\n+    pub fn trivial_to_string() {\n+        assert!(lambda.to_string() == \"\\\\\")\n     }\n }\n "}, {"sha": "1555098f2911be5d5df7100abba6f28eb8ce0fbb", "filename": "src/test/run-pass/issue-3037.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-3037.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-3037.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3037.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -10,7 +10,7 @@\n \n enum what { }\n \n-fn what_to_str(x: what) -> String\n+fn what_to_string(x: what) -> String\n {\n     match x {\n     }"}, {"sha": "2568d94fcbf9e4f14d62ae0b00bdcb228e0040e2", "filename": "src/test/run-pass/issue-3559.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3559.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -24,6 +24,6 @@ pub fn main() {\n     let mut table = HashMap::new();\n     table.insert(\"one\".to_string(), 1i);\n     table.insert(\"two\".to_string(), 2i);\n-    assert!(check_strs(table.to_str().as_slice(), \"{one: 1, two: 2}\") ||\n-            check_strs(table.to_str().as_slice(), \"{two: 2, one: 1}\"));\n+    assert!(check_strs(table.to_string().as_slice(), \"{one: 1, two: 2}\") ||\n+            check_strs(table.to_string().as_slice(), \"{two: 2, one: 1}\"));\n }"}, {"sha": "e38969c25263caada3a4b7fd44ce00e7c3397ef4", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -94,7 +94,7 @@ impl AsciiArt {\n     }\n }\n \n-// Allows AsciiArt to be converted to a string using the libcore ToStr trait.\n+// Allows AsciiArt to be converted to a string using the libcore ToString trait.\n // Note that the %s fmt! specifier will not call this automatically.\n impl fmt::Show for AsciiArt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -159,7 +159,7 @@ pub fn check_strs(actual: &str, expected: &str) -> bool {\n \n fn test_ascii_art_ctor() {\n     let art = AsciiArt(3, 3, '*');\n-    assert!(check_strs(art.to_str().as_slice(), \"...\\n...\\n...\"));\n+    assert!(check_strs(art.to_string().as_slice(), \"...\\n...\\n...\"));\n }\n \n \n@@ -168,15 +168,15 @@ fn test_add_pt() {\n     art.add_pt(0, 0);\n     art.add_pt(0, -10);\n     art.add_pt(1, 2);\n-    assert!(check_strs(art.to_str().as_slice(), \"*..\\n...\\n.*.\"));\n+    assert!(check_strs(art.to_string().as_slice(), \"*..\\n...\\n.*.\"));\n }\n \n \n fn test_shapes() {\n     let mut art = AsciiArt(4, 4, '*');\n     art.add_rect(Rect {top_left: Point {x: 0, y: 0}, size: Size {width: 4, height: 4}});\n     art.add_point(Point {x: 2, y: 2});\n-    assert!(check_strs(art.to_str().as_slice(), \"****\\n*..*\\n*.**\\n****\"));\n+    assert!(check_strs(art.to_string().as_slice(), \"****\\n*..*\\n*.**\\n****\"));\n }\n \n pub fn main() {"}, {"sha": "3f219da0a879a2e64ea3d5d1e7fafa8db444813f", "filename": "src/test/run-pass/issue-3702.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-3702.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-3702.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3702.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -11,11 +11,11 @@\n \n pub fn main() {\n   trait Text {\n-    fn to_str(&self) -> String;\n+    fn to_string(&self) -> String;\n   }\n \n   fn to_string(t: Box<Text>) {\n-    println!(\"{}\", t.to_str());\n+    println!(\"{}\", t.to_string());\n   }\n \n }"}, {"sha": "3ebc3e645737626a839859effb12ba98a3d4a16c", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -96,27 +96,27 @@ priv fn parse_response(io: @io::Reader) -> Result {\n     }\n }\n \n-priv fn cmd_to_str(cmd: ~[String]) -> String {\n+priv fn cmd_to_string(cmd: ~[String]) -> String {\n   let mut res = \"*\".to_string();\n-  res.push_str(cmd.len().to_str());\n+  res.push_str(cmd.len().to_string());\n   res.push_str(\"\\r\\n\");\n     for s in cmd.iter() {\n-    res.push_str([\"$\".to_string(), s.len().to_str(), \"\\r\\n\".to_string(),\n+    res.push_str([\"$\".to_string(), s.len().to_string(), \"\\r\\n\".to_string(),\n                   (*s).clone(), \"\\r\\n\".to_string()].concat() );\n     }\n   res\n }\n \n fn query(cmd: ~[String], sb: TcpSocketBuf) -> Result {\n-  let cmd = cmd_to_str(cmd);\n+  let cmd = cmd_to_string(cmd);\n   //println!(\"{}\", cmd);\n   sb.write_str(cmd);\n   let res = parse_response(@sb as @io::Reader);\n   res\n }\n \n fn query2(cmd: ~[String]) -> Result {\n-  let _cmd = cmd_to_str(cmd);\n+  let _cmd = cmd_to_string(cmd);\n     io::with_str_reader(\"$3\\r\\nXXX\\r\\n\".to_string())(|sb| {\n     let res = parse_response(@sb as @io::Reader);\n     println!(\"{:?}\", res);"}, {"sha": "977cd08ba377082dea01b860d9d12e89ce7e0ff6", "filename": "src/test/run-pass/issue-5280.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-5280.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fissue-5280.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5280.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -11,15 +11,15 @@\n type FontTableTag = u32;\n \n trait FontTableTagConversions {\n-  fn tag_to_str(self);\n+  fn tag_to_string(self);\n }\n \n impl FontTableTagConversions for FontTableTag {\n-  fn tag_to_str(self) {\n+  fn tag_to_string(self) {\n     &self;\n   }\n }\n \n pub fn main() {\n-    5.tag_to_str();\n+    5.tag_to_string();\n }"}, {"sha": "783dc32426a651f6139d0fa615167766861b684d", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -38,7 +38,7 @@ impl<A> option_monad<A> for Option<A> {\n }\n \n fn transform(x: Option<int>) -> Option<String> {\n-    x.bind(|n| Some(*n + 1) ).bind(|n| Some(n.to_str()) )\n+    x.bind(|n| Some(*n + 1) ).bind(|n| Some(n.to_string()) )\n }\n \n pub fn main() {"}, {"sha": "92c5e025b9b2149692aa23bb41c73406015de143", "filename": "src/test/run-pass/move-out-of-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -20,7 +20,7 @@ impl StringBuffer {\n     }\n }\n \n-fn to_str(sb: StringBuffer) -> String {\n+fn to_string(sb: StringBuffer) -> String {\n     sb.s\n }\n \n@@ -30,6 +30,6 @@ pub fn main() {\n     };\n     sb.append(\"Hello, \");\n     sb.append(\"World!\");\n-    let str = to_str(sb);\n+    let str = to_string(sb);\n     assert_eq!(str.as_slice(), \"Hello, World!\");\n }"}, {"sha": "8532b5f51dc5e68ebe94cb66623b9b532647e52c", "filename": "src/test/run-pass/new-impl-syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -32,6 +32,6 @@ impl<T:fmt::Show> fmt::Show for PolymorphicThingy<T> {\n }\n \n pub fn main() {\n-    println!(\"{}\", Thingy { x: 1, y: 2 }.to_str());\n-    println!(\"{}\", PolymorphicThingy { x: Thingy { x: 1, y: 2 } }.to_str());\n+    println!(\"{}\", Thingy { x: 1, y: 2 }.to_string());\n+    println!(\"{}\", PolymorphicThingy { x: Thingy { x: 1, y: 2 } }.to_string());\n }"}, {"sha": "283c76adf0dafcc2a90d17ba8114c6c16af9270e", "filename": "src/test/run-pass/overloaded-deref-count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -72,7 +72,7 @@ pub fn main() {\n     // N.B. This is required because method lookup hasn't been performed so\n     // we don't know whether the called method takes mutable self, before\n     // the dereference itself is type-checked (a chicken-and-egg problem).\n-    (*n).to_str();\n+    (*n).to_string();\n     assert_eq!(n.counts(), (2, 4));\n \n     // Mutable deref used for calling a method taking &mut self."}, {"sha": "f3a730aa2b39589b823994ebd3c6ab321ff183f7", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -12,7 +12,7 @@ extern crate collections;\n \n use std::collections::{ Map, MutableMap};\n use std::str::{SendStr, Owned, Slice};\n-use std::to_str::ToStr;\n+use std::to_str::ToString;\n use self::collections::TreeMap;\n use std::option::Some;\n "}, {"sha": "d0dacc2ff7a9d225a4cec29e68091ac35937b21e", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -31,7 +31,7 @@ trait uint_utils {\n \n impl uint_utils for uint {\n     fn str(&self) -> String {\n-        self.to_str()\n+        self.to_string()\n     }\n     fn multi(&self, f: |uint|) {\n         let mut c = 0u;"}, {"sha": "ceffd1e363667d313ce04f3cf3a4e226a14361a9", "filename": "src/test/run-pass/task-stderr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -21,6 +21,6 @@ fn main() {\n     });\n     assert!(res.is_err());\n \n-    let output = reader.read_to_str().unwrap();\n+    let output = reader.read_to_string().unwrap();\n     assert!(output.as_slice().contains(\"Hello, world!\"));\n }"}, {"sha": "d2408509fc5820c0105e083a149060d1ea67333d", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -54,7 +54,7 @@ macro_rules! iotest (\n iotest!(fn eventual_timeout() {\n     use native;\n     let addr = next_test_ip4();\n-    let host = addr.ip.to_str();\n+    let host = addr.ip.to_string();\n     let port = addr.port;\n \n     // Use a native task to receive connections because it turns out libuv is\n@@ -82,7 +82,7 @@ iotest!(fn eventual_timeout() {\n \n iotest!(fn timeout_success() {\n     let addr = next_test_ip4();\n-    let host = addr.ip.to_str();\n+    let host = addr.ip.to_string();\n     let port = addr.port;\n     let _l = TcpListener::bind(host.as_slice(), port).unwrap().listen();\n "}, {"sha": "f52a3455e4157684c16b98c5b29828db88b4f125", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -61,7 +61,7 @@ fn main() {\n     for _ in range(0u, 1000) {\n         let tx = tx.clone();\n         TaskBuilder::new().stack_size(64 * 1024).spawn(proc() {\n-            let host = addr.ip.to_str();\n+            let host = addr.ip.to_string();\n             let port = addr.port;\n             match TcpStream::connect(host.as_slice(), port) {\n                 Ok(stream) => {"}, {"sha": "b36fbca2da048a68f9b82af3c19712e00677ec47", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -27,10 +27,10 @@ fn checktests() {\n     let tests = __test::TESTS;\n \n     assert!(\n-        tests.iter().any(|t| t.desc.name.to_str().as_slice() == \"shouldignore\" &&\n+        tests.iter().any(|t| t.desc.name.to_string().as_slice() == \"shouldignore\" &&\n                          t.desc.ignore));\n \n     assert!(\n-        tests.iter().any(|t| t.desc.name.to_str().as_slice() == \"shouldnotignore\" &&\n+        tests.iter().any(|t| t.desc.name.to_string().as_slice() == \"shouldnotignore\" &&\n                          !t.desc.ignore));\n }"}, {"sha": "43d3b591ffa1b9225e3073ed6e8d7f1877d7b9be", "filename": "src/test/run-pass/trait-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -39,7 +39,7 @@ impl<T:to_str> to_str for Option<T> {\n \n impl to_str for int {\n     fn to_str_(&self) -> String {\n-        self.to_str()\n+        self.to_string()\n     }\n }\n "}, {"sha": "eeda6e2c88b454e084d07d29811915224e6bd59d", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -11,16 +11,16 @@\n \n \n trait to_str {\n-    fn to_string(&self) -> String;\n+    fn to_string_(&self) -> String;\n }\n impl to_str for int {\n-    fn to_string(&self) -> String { self.to_str() }\n+    fn to_string_(&self) -> String { self.to_string() }\n }\n impl to_str for String {\n-    fn to_string(&self) -> String { self.clone() }\n+    fn to_string_(&self) -> String { self.clone() }\n }\n impl to_str for () {\n-    fn to_string(&self) -> String { \"()\".to_string() }\n+    fn to_string_(&self) -> String { \"()\".to_string() }\n }\n \n trait map<T> {\n@@ -40,7 +40,7 @@ fn foo<U, T: map<U>>(x: T) -> Vec<String> {\n     x.map(|_e| \"hi\".to_string() )\n }\n fn bar<U:to_str,T:map<U>>(x: T) -> Vec<String> {\n-    x.map(|_e| _e.to_string() )\n+    x.map(|_e| _e.to_string_() )\n }\n \n pub fn main() {"}, {"sha": "fbe40e837de5f04a1d350b134526c2ceede596f2", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -11,29 +11,29 @@\n \n \n trait to_str {\n-    fn to_string(&self) -> String;\n+    fn to_string_(&self) -> String;\n }\n \n impl to_str for int {\n-    fn to_string(&self) -> String { self.to_str() }\n+    fn to_string_(&self) -> String { self.to_string() }\n }\n \n impl<T:to_str> to_str for Vec<T> {\n-    fn to_string(&self) -> String {\n+    fn to_string_(&self) -> String {\n         format!(\"[{}]\",\n                 self.iter()\n-                    .map(|e| e.to_string())\n+                    .map(|e| e.to_string_())\n                     .collect::<Vec<String>>()\n                     .connect(\", \"))\n     }\n }\n \n pub fn main() {\n-    assert!(1.to_string() == \"1\".to_string());\n-    assert!((vec!(2i, 3, 4)).to_string() == \"[2, 3, 4]\".to_string());\n+    assert!(1.to_string_() == \"1\".to_string());\n+    assert!((vec!(2i, 3, 4)).to_string_() == \"[2, 3, 4]\".to_string());\n \n     fn indirect<T:to_str>(x: T) -> String {\n-        format!(\"{}!\", x.to_string())\n+        format!(\"{}!\", x.to_string_())\n     }\n     assert!(indirect(vec!(10i, 20)) == \"[10, 20]!\".to_string());\n "}, {"sha": "deb08a4608cc0358c533531e7b2d1fff79289caa", "filename": "src/test/run-pass/vec-to_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c334a77b897f7b1cb6cff3c56a71ecb89c82af/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-to_str.rs?ref=12c334a77b897f7b1cb6cff3c56a71ecb89c82af", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n pub fn main() {\n-    assert_eq!((vec!(0i, 1)).to_str(), \"[0, 1]\".to_string());\n-    assert_eq!((&[1i, 2]).to_str(), \"[1, 2]\".to_string());\n+    assert_eq!((vec!(0i, 1)).to_string(), \"[0, 1]\".to_string());\n+    assert_eq!((&[1i, 2]).to_string(), \"[1, 2]\".to_string());\n \n     let foo = vec!(3i, 4);\n     let bar = &[4i, 5];\n \n-    assert_eq!(foo.to_str(), \"[3, 4]\".to_string());\n-    assert_eq!(bar.to_str(), \"[4, 5]\".to_string());\n+    assert_eq!(foo.to_string(), \"[3, 4]\".to_string());\n+    assert_eq!(bar.to_string(), \"[4, 5]\".to_string());\n }"}]}