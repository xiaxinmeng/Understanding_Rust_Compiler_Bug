{"sha": "9be233cbfe134f032ed2d50f7cc66e901bbe3f6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZTIzM2NiZmUxMzRmMDMyZWQyZDUwZjdjYzY2ZTkwMWJiZTNmNmY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-07T12:58:27Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-09T09:42:41Z"}, "message": "Use `Token::uninterpolate` in couple more places matching on `(Nt)Ident`", "tree": {"sha": "29073f8d2cf134e40c898d69696095c26c123814", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29073f8d2cf134e40c898d69696095c26c123814"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f", "html_url": "https://github.com/rust-lang/rust/commit/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d7f67d3b109e95fb0dca8f773a2146db4eb4a93", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d7f67d3b109e95fb0dca8f773a2146db4eb4a93", "html_url": "https://github.com/rust-lang/rust/commit/5d7f67d3b109e95fb0dca8f773a2146db4eb4a93"}], "stats": {"total": 66, "additions": 28, "deletions": 38}, "files": [{"sha": "52a59e82ae23f672db81c1c34d0a268348768a39", "filename": "src/librustc_ast/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fattr%2Fmod.rs?ref=9be233cbfe134f032ed2d50f7cc66e901bbe3f6f", "patch": "@@ -441,7 +441,7 @@ impl MetaItem {\n         I: Iterator<Item = TokenTree>,\n     {\n         // FIXME: Share code with `parse_path`.\n-        let path = match tokens.next() {\n+        let path = match tokens.next().map(TokenTree::uninterpolate) {\n             Some(TokenTree::Token(Token { kind: kind @ token::Ident(..), span }))\n             | Some(TokenTree::Token(Token { kind: kind @ token::ModSep, span })) => 'arm: {\n                 let mut segments = if let token::Ident(name, _) = kind {\n@@ -457,7 +457,7 @@ impl MetaItem {\n                 };\n                 loop {\n                     if let Some(TokenTree::Token(Token { kind: token::Ident(name, _), span })) =\n-                        tokens.next()\n+                        tokens.next().map(TokenTree::uninterpolate)\n                     {\n                         segments.push(PathSegment::from_ident(Ident::new(name, span)));\n                     } else {\n@@ -474,7 +474,6 @@ impl MetaItem {\n                 Path { span, segments }\n             }\n             Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. })) => match *nt {\n-                token::Nonterminal::NtIdent(ident, _) => Path::from_ident(ident),\n                 token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n                 token::Nonterminal::NtPath(ref path) => path.clone(),\n                 _ => return None,"}, {"sha": "b022d969deccb4d9066dccd410d12e5c80dae9e4", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=9be233cbfe134f032ed2d50f7cc66e901bbe3f6f", "patch": "@@ -357,7 +357,7 @@ impl Token {\n \n     /// Returns `true` if the token can appear at the start of an expression.\n     pub fn can_begin_expr(&self) -> bool {\n-        match self.kind {\n+        match self.uninterpolate().kind {\n             Ident(name, is_raw)              =>\n                 ident_can_begin_expr(name, self.span, is_raw), // value name or keyword\n             OpenDelim(..)                     | // tuple, array or block\n@@ -375,12 +375,10 @@ impl Token {\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n             Interpolated(ref nt) => match **nt {\n-                NtIdent(ident, is_raw) => ident_can_begin_expr(ident.name, ident.span, is_raw),\n                 NtLiteral(..) |\n                 NtExpr(..)    |\n                 NtBlock(..)   |\n-                NtPath(..)    |\n-                NtLifetime(..) => true,\n+                NtPath(..) => true,\n                 _ => false,\n             },\n             _ => false,\n@@ -389,7 +387,7 @@ impl Token {\n \n     /// Returns `true` if the token can appear at the start of a type.\n     pub fn can_begin_type(&self) -> bool {\n-        match self.kind {\n+        match self.uninterpolate().kind {\n             Ident(name, is_raw)        =>\n                 ident_can_begin_type(name, self.span, is_raw), // type name or keyword\n             OpenDelim(Paren)            | // tuple\n@@ -403,8 +401,7 @@ impl Token {\n             Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n             Interpolated(ref nt) => match **nt {\n-                NtIdent(ident, is_raw) => ident_can_begin_type(ident.name, ident.span, is_raw),\n-                NtTy(..) | NtPath(..) | NtLifetime(..) => true,\n+                NtTy(..) | NtPath(..) => true,\n                 _ => false,\n             },\n             _ => false,\n@@ -445,11 +442,10 @@ impl Token {\n     ///\n     /// Keep this in sync with `Lit::from_token`.\n     pub fn can_begin_literal_or_bool(&self) -> bool {\n-        match self.kind {\n+        match self.uninterpolate().kind {\n             Literal(..) | BinOp(Minus) => true,\n             Ident(name, false) if name.is_bool_lit() => true,\n             Interpolated(ref nt) => match &**nt {\n-                NtIdent(ident, false) if ident.name.is_bool_lit() => true,\n                 NtExpr(e) | NtLiteral(e) => matches!(e.kind, ast::ExprKind::Lit(_)),\n                 _ => false,\n             },\n@@ -475,24 +471,18 @@ impl Token {\n \n     /// Returns an identifier if this token is an identifier.\n     pub fn ident(&self) -> Option<(ast::Ident, /* is_raw */ bool)> {\n-        match self.kind {\n-            Ident(name, is_raw) => Some((ast::Ident::new(name, self.span), is_raw)),\n-            Interpolated(ref nt) => match **nt {\n-                NtIdent(ident, is_raw) => Some((ident, is_raw)),\n-                _ => None,\n-            },\n+        let token = self.uninterpolate();\n+        match token.kind {\n+            Ident(name, is_raw) => Some((ast::Ident::new(name, token.span), is_raw)),\n             _ => None,\n         }\n     }\n \n     /// Returns a lifetime identifier if this token is a lifetime.\n     pub fn lifetime(&self) -> Option<ast::Ident> {\n-        match self.kind {\n-            Lifetime(name) => Some(ast::Ident::new(name, self.span)),\n-            Interpolated(ref nt) => match **nt {\n-                NtLifetime(ident) => Some(ident),\n-                _ => None,\n-            },\n+        let token = self.uninterpolate();\n+        match token.kind {\n+            Lifetime(name) => Some(ast::Ident::new(name, token.span)),\n             _ => None,\n         }\n     }"}, {"sha": "916a5ff6f46f49a0d6969f6e0d809e19f41b623a", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=9be233cbfe134f032ed2d50f7cc66e901bbe3f6f", "patch": "@@ -116,6 +116,13 @@ impl TokenTree {\n     pub fn close_tt(span: DelimSpan, delim: DelimToken) -> TokenTree {\n         TokenTree::token(token::CloseDelim(delim), span.close)\n     }\n+\n+    pub fn uninterpolate(self) -> TokenTree {\n+        match self {\n+            TokenTree::Token(token) => TokenTree::Token(token.uninterpolate().into_owned()),\n+            tt => tt,\n+        }\n+    }\n }\n \n impl<CTX> HashStable<CTX> for TokenStream"}, {"sha": "d1757394f3a1dee633881c5720e6695022c9727c", "filename": "src/librustc_ast/util/literal.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fliteral.rs?ref=9be233cbfe134f032ed2d50f7cc66e901bbe3f6f", "patch": "@@ -191,23 +191,16 @@ impl Lit {\n     ///\n     /// Keep this in sync with `Token::can_begin_literal_or_bool`.\n     pub fn from_token(token: &Token) -> Result<Lit, LitError> {\n-        let lit = match token.kind {\n+        let lit = match token.uninterpolate().kind {\n             token::Ident(name, false) if name.is_bool_lit() => {\n                 token::Lit::new(token::Bool, name, None)\n             }\n             token::Literal(lit) => lit,\n             token::Interpolated(ref nt) => {\n-                match &**nt {\n-                    token::NtIdent(ident, false) if ident.name.is_bool_lit() => {\n-                        let lit = token::Lit::new(token::Bool, ident.name, None);\n-                        return Lit::from_lit_token(lit, ident.span);\n+                if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n+                    if let ast::ExprKind::Lit(lit) = &expr.kind {\n+                        return Ok(lit.clone());\n                     }\n-                    token::NtExpr(expr) | token::NtLiteral(expr) => {\n-                        if let ast::ExprKind::Lit(lit) = &expr.kind {\n-                            return Ok(lit.clone());\n-                        }\n-                    }\n-                    _ => {}\n                 }\n                 return Err(LitError::NotLiteral);\n             }"}, {"sha": "d28b9cd968218a46169dfbae91232a962e692eb9", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=9be233cbfe134f032ed2d50f7cc66e901bbe3f6f", "patch": "@@ -50,7 +50,6 @@ macro_rules! maybe_whole_expr {\n                         AttrVec::new(),\n                     ));\n                 }\n-                // N.B., `NtIdent(ident)` is normalized to `Ident` in `fn bump`.\n                 _ => {}\n             };\n         }\n@@ -482,7 +481,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn is_mistaken_not_ident_negation(&self) -> bool {\n-        let token_cannot_continue_expr = |t: &Token| match t.kind {\n+        let token_cannot_continue_expr = |t: &Token| match t.uninterpolate().kind {\n             // These tokens can start an expression after `!`, but\n             // can't continue an expression after an ident\n             token::Ident(name, is_raw) => token::ident_can_begin_expr(name, t.span, is_raw),"}, {"sha": "bf612bfc0e4a1718b0bc8ee387a441ca4160697a", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=9be233cbfe134f032ed2d50f7cc66e901bbe3f6f", "patch": "@@ -1544,6 +1544,8 @@ impl<'a> Parser<'a> {\n \n         let is_name_required = match self.token.kind {\n             token::DotDotDot => false,\n+            // FIXME: Consider using interpolated token for this edition check,\n+            // it should match the intent of edition hygiene better.\n             _ => req_name(self.token.uninterpolate().span.edition()),\n         };\n         let (pat, ty) = if is_name_required || self.is_named_param() {"}, {"sha": "f52a91ff5989dd06343224768e54c09d5dc2386f", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be233cbfe134f032ed2d50f7cc66e901bbe3f6f/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=9be233cbfe134f032ed2d50f7cc66e901bbe3f6f", "patch": "@@ -151,7 +151,7 @@ impl<'a> Parser<'a> {\n     /// Note that there are more tokens such as `@` for which we know that the `|`\n     /// is an illegal parse. However, the user's intent is less clear in that case.\n     fn recover_trailing_vert(&mut self, lo: Option<Span>) -> bool {\n-        let is_end_ahead = self.look_ahead(1, |token| match &token.kind {\n+        let is_end_ahead = self.look_ahead(1, |token| match &token.uninterpolate().kind {\n             token::FatArrow // e.g. `a | => 0,`.\n             | token::Ident(kw::If, false) // e.g. `a | if expr`.\n             | token::Eq // e.g. `let a | = 0`."}]}