{"sha": "a65b201d94422eb81addef4bed2d37211e39661b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NWIyMDFkOTQ0MjJlYjgxYWRkZWY0YmVkMmQzNzIxMWUzOTY2MWI=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-08-25T20:28:35Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-08-25T20:28:35Z"}, "message": "prevent error message interleaving on win/unix", "tree": {"sha": "85535c0a9fe0ce7f9e66173be4be0a47655f0ea5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85535c0a9fe0ce7f9e66173be4be0a47655f0ea5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a65b201d94422eb81addef4bed2d37211e39661b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a65b201d94422eb81addef4bed2d37211e39661b", "html_url": "https://github.com/rust-lang/rust/commit/a65b201d94422eb81addef4bed2d37211e39661b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a65b201d94422eb81addef4bed2d37211e39661b/comments", "author": null, "committer": null, "parents": [{"sha": "17a2be8c3571eaff1f09556febe68d8ab733ecf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/17a2be8c3571eaff1f09556febe68d8ab733ecf6", "html_url": "https://github.com/rust-lang/rust/commit/17a2be8c3571eaff1f09556febe68d8ab733ecf6"}], "stats": {"total": 200, "additions": 198, "deletions": 2}, "files": [{"sha": "ed133d21b8a0f7c0792398c4549dbf54d3e50928", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a65b201d94422eb81addef4bed2d37211e39661b/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65b201d94422eb81addef4bed2d37211e39661b/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=a65b201d94422eb81addef4bed2d37211e39661b", "patch": "@@ -724,7 +724,10 @@ impl EmitterWriter {\n         }\n         match write!(&mut self.dst, \"\\n\") {\n             Err(e) => panic!(\"failed to emit error: {}\", e),\n-            _ => ()\n+            _ => match self.dst.flush() {\n+                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                _ => ()\n+            }\n         }\n     }\n }\n@@ -749,6 +752,21 @@ fn overlaps(a1: &Annotation, a2: &Annotation) -> bool {\n fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n         lvl: &Level,\n         dst: &mut Destination) -> io::Result<()> {\n+    use lock;\n+\n+    // In order to prevent error message interleaving, where multiple error lines get intermixed\n+    // when multiple compiler processes error simultaneously, we emit errors with additional\n+    // steps.\n+    //\n+    // On Unix systems, we write into a buffered terminal rather than directly to a terminal. When\n+    // the .flush() is called we take the buffer created from the buffered writes and write it at\n+    // one shot.  Because the Unix systems use ANSI for the colors, which is a text-based styling\n+    // scheme, this buffered approach works and maintains the styling.\n+    //\n+    // On Windows, styling happens through calls to a terminal API. This prevents us from using the\n+    // same buffering approach.  Instead, we use a global Windows mutex, which we acquire long\n+    // enough to output the full error message, then we release.\n+    let _buffer_lock = lock::acquire_global_lock(\"rustc_errors\");\n     for line in rendered_buffer {\n         for part in line {\n             dst.apply_style(lvl.clone(), part.style)?;\n@@ -757,6 +775,7 @@ fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n         }\n         write!(dst, \"\\n\")?;\n     }\n+    dst.flush()?;\n     Ok(())\n }\n \n@@ -783,14 +802,74 @@ fn stderr_isatty() -> bool {\n     }\n }\n \n+pub type BufferedStderr = term::Terminal<Output = BufferedWriter> + Send;\n+\n pub enum Destination {\n     Terminal(Box<term::StderrTerminal>),\n+    BufferedTerminal(Box<BufferedStderr>),\n     Raw(Box<Write + Send>),\n }\n \n+/// Buffered writer gives us a way on Unix to buffer up an entire error message before we output\n+/// it.  This helps to prevent interleaving of multiple error messages when multiple compiler\n+/// processes error simultaneously\n+pub struct BufferedWriter {\n+    buffer: Vec<u8>,\n+}\n+\n+impl BufferedWriter {\n+    // note: we use _new because the conditional compilation at its use site may make this\n+    // this function unused on some platforms\n+    fn _new() -> BufferedWriter {\n+        BufferedWriter {\n+            buffer: vec![]\n+        }\n+    }\n+}\n+\n+impl Write for BufferedWriter {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        for b in buf {\n+            self.buffer.push(*b);\n+        }\n+        Ok(buf.len())\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        let mut stderr = io::stderr();\n+        let result = (|| {\n+            stderr.write_all(&self.buffer)?;\n+            stderr.flush()\n+        })();\n+        self.buffer.clear();\n+        result\n+    }\n+}\n+\n impl Destination {\n+    #[cfg(not(windows))]\n+    /// When not on Windows, prefer the buffered terminal so that we can buffer an entire error\n+    /// to be emitted at one time.\n+    fn from_stderr() -> Destination {\n+        let stderr: Option<Box<BufferedStderr>>  =\n+            term::TerminfoTerminal::new(BufferedWriter::_new())\n+                .map(|t| Box::new(t) as Box<BufferedStderr>);\n+\n+        match stderr {\n+            Some(t) => BufferedTerminal(t),\n+            None    => Raw(Box::new(io::stderr())),\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    /// Return a normal, unbuffered terminal when on Windows.\n     fn from_stderr() -> Destination {\n-        match term::stderr() {\n+        let stderr: Option<Box<term::StderrTerminal>> =\n+            term::TerminfoTerminal::new(io::stderr())\n+                .map(|t| Box::new(t) as Box<term::StderrTerminal>)\n+                .or_else(|| term::WinConsole::new(io::stderr()).ok()\n+                    .map(|t| Box::new(t) as Box<term::StderrTerminal>));\n+\n+        match stderr {\n             Some(t) => Terminal(t),\n             None    => Raw(Box::new(io::stderr())),\n         }\n@@ -839,6 +918,7 @@ impl Destination {\n     fn start_attr(&mut self, attr: term::Attr) -> io::Result<()> {\n         match *self {\n             Terminal(ref mut t) => { t.attr(attr)?; }\n+            BufferedTerminal(ref mut t) => { t.attr(attr)?; }\n             Raw(_) => { }\n         }\n         Ok(())\n@@ -847,6 +927,7 @@ impl Destination {\n     fn reset_attrs(&mut self) -> io::Result<()> {\n         match *self {\n             Terminal(ref mut t) => { t.reset()?; }\n+            BufferedTerminal(ref mut t) => { t.reset()?; }\n             Raw(_) => { }\n         }\n         Ok(())\n@@ -857,12 +938,14 @@ impl Write for Destination {\n     fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n         match *self {\n             Terminal(ref mut t) => t.write(bytes),\n+            BufferedTerminal(ref mut t) => t.write(bytes),\n             Raw(ref mut w) => w.write(bytes),\n         }\n     }\n     fn flush(&mut self) -> io::Result<()> {\n         match *self {\n             Terminal(ref mut t) => t.flush(),\n+            BufferedTerminal(ref mut t) => t.flush(),\n             Raw(ref mut w) => w.flush(),\n         }\n     }"}, {"sha": "c99bc47044853b5084ef722f96d9d5a87c927434", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a65b201d94422eb81addef4bed2d37211e39661b/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65b201d94422eb81addef4bed2d37211e39661b/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=a65b201d94422eb81addef4bed2d37211e39661b", "patch": "@@ -50,6 +50,7 @@ pub mod emitter;\n pub mod snippet;\n pub mod registry;\n pub mod styled_buffer;\n+mod lock;\n \n use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION };\n use syntax_pos::{MacroBacktrace};"}, {"sha": "0a9e0c4bbefb30a974ad504c4bd58f13f907a5aa", "filename": "src/librustc_errors/lock.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a65b201d94422eb81addef4bed2d37211e39661b/src%2Flibrustc_errors%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65b201d94422eb81addef4bed2d37211e39661b/src%2Flibrustc_errors%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flock.rs?ref=a65b201d94422eb81addef4bed2d37211e39661b", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Bindings to acquire a global named lock.\n+//!\n+//! This is intended to be used to synchronize multiple compiler processes to\n+//! ensure that we can output complete errors without interleaving on Windows.\n+//! Note that this is currently only needed for allowing only one 32-bit MSVC\n+//! linker to execute at once on MSVC hosts, so this is only implemented for\n+//! `cfg(windows)`. Also note that this may not always be used on Windows,\n+//! only when targeting 32-bit MSVC.\n+//!\n+//! For more information about why this is necessary, see where this is called.\n+\n+use std::any::Any;\n+\n+#[cfg(windows)]\n+#[allow(bad_style)]\n+pub fn acquire_global_lock(name: &str) -> Box<Any> {\n+    use std::ffi::CString;\n+    use std::io;\n+\n+    type LPSECURITY_ATTRIBUTES = *mut u8;\n+    type BOOL = i32;\n+    type LPCSTR = *const u8;\n+    type HANDLE = *mut u8;\n+    type DWORD = u32;\n+\n+    const INFINITE: DWORD = !0;\n+    const WAIT_OBJECT_0: DWORD = 0;\n+    const WAIT_ABANDONED: DWORD = 0x00000080;\n+\n+    extern \"system\" {\n+        fn CreateMutexA(lpMutexAttributes: LPSECURITY_ATTRIBUTES,\n+                        bInitialOwner: BOOL,\n+                        lpName: LPCSTR) -> HANDLE;\n+        fn WaitForSingleObject(hHandle: HANDLE,\n+                               dwMilliseconds: DWORD) -> DWORD;\n+        fn ReleaseMutex(hMutex: HANDLE) -> BOOL;\n+        fn CloseHandle(hObject: HANDLE) -> BOOL;\n+    }\n+\n+    struct Handle(HANDLE);\n+\n+    impl Drop for Handle {\n+        fn drop(&mut self) {\n+            unsafe {\n+                CloseHandle(self.0);\n+            }\n+        }\n+    }\n+\n+    struct Guard(Handle);\n+\n+    impl Drop for Guard {\n+        fn drop(&mut self) {\n+            unsafe {\n+                ReleaseMutex((self.0).0);\n+            }\n+        }\n+    }\n+\n+    let cname = CString::new(name).unwrap();\n+    unsafe {\n+        // Create a named mutex, with no security attributes and also not\n+        // acquired when we create it.\n+        //\n+        // This will silently create one if it doesn't already exist, or it'll\n+        // open up a handle to one if it already exists.\n+        let mutex = CreateMutexA(0 as *mut _, 0, cname.as_ptr() as *const u8);\n+        if mutex.is_null() {\n+            panic!(\"failed to create global mutex named `{}`: {}\", name,\n+                   io::Error::last_os_error());\n+        }\n+        let mutex = Handle(mutex);\n+\n+        // Acquire the lock through `WaitForSingleObject`.\n+        //\n+        // A return value of `WAIT_OBJECT_0` means we successfully acquired it.\n+        //\n+        // A return value of `WAIT_ABANDONED` means that the previous holder of\n+        // the thread exited without calling `ReleaseMutex`. This can happen,\n+        // for example, when the compiler crashes or is interrupted via ctrl-c\n+        // or the like. In this case, however, we are still transferred\n+        // ownership of the lock so we continue.\n+        //\n+        // If an error happens.. well... that's surprising!\n+        match WaitForSingleObject(mutex.0, INFINITE) {\n+            WAIT_OBJECT_0 | WAIT_ABANDONED => {}\n+            code => {\n+                panic!(\"WaitForSingleObject failed on global mutex named \\\n+                        `{}`: {} (ret={:x})\", name,\n+                       io::Error::last_os_error(), code);\n+            }\n+        }\n+\n+        // Return a guard which will call `ReleaseMutex` when dropped.\n+        Box::new(Guard(mutex))\n+    }\n+}\n+\n+#[cfg(unix)]\n+pub fn acquire_global_lock(_name: &str) -> Box<Any> {\n+    Box::new(())\n+}"}]}